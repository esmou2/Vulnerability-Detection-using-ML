,file_path,source_code,is_vulnerable, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,com.android.quicksearchbox.CorpusResult.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * A sequence of suggestions from a single corpus.
 */
public interface CorpusResult extends SuggestionCursor {

    /**
     * Gets the corpus that produced these suggestions.
     */
    Corpus getCorpus();

    /**
     * The user query that returned these suggestions.
     */
    String getUserQuery();

    /**
     * Gets the latency of the suggestion query that produced this result.
     *
     * @return The latency in milliseconds.
     */
    int getLatency();
}
",False,86,5,22,4,4,21,2,L1
1,com.android.quicksearchbox.SuggestionUtils.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.google.common.annotations.VisibleForTesting;

import android.app.SearchManager;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;

/**
 * Some utilities for suggestions.
 */
public class SuggestionUtils {

    private SuggestionUtils() {
    }

    public static Intent getSuggestionIntent(SuggestionCursor suggestion, Bundle appSearchData) {
        String action = suggestion.getSuggestionIntentAction();

        String data = suggestion.getSuggestionIntentDataString();
        String query = suggestion.getSuggestionQuery();
        String userQuery = suggestion.getUserQuery();
        String extraData = suggestion.getSuggestionIntentExtraData();

        // Now build the Intent
        Intent intent = new Intent(action);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        // We need CLEAR_TOP to avoid reusing an old task that has other activities
        // on top of the one we want.
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
        if (data != null) {
            intent.setData(Uri.parse(data));
        }
        intent.putExtra(SearchManager.USER_QUERY, userQuery);
        if (query != null) {
            intent.putExtra(SearchManager.QUERY, query);
        }
        if (extraData != null) {
            intent.putExtra(SearchManager.EXTRA_DATA_KEY, extraData);
        }
        if (appSearchData != null) {
            intent.putExtra(SearchManager.APP_DATA, appSearchData);
        }

        intent.setComponent(suggestion.getSuggestionIntentComponent());
        return intent;
    }

    /**
     * Gets a unique key that identifies a suggestion. This is used to avoid
     * duplicate suggestions.
     */
    public static String getSuggestionKey(Suggestion suggestion) {
        String action = makeKeyComponent(suggestion.getSuggestionIntentAction());
        String data = makeKeyComponent(normalizeUrl(suggestion.getSuggestionIntentDataString()));
        String query = makeKeyComponent(normalizeUrl(suggestion.getSuggestionQuery()));
        // calculating accurate size of string builder avoids an allocation vs starting with
        // the default size and having to expand.
        int size = action.length() + 2 + data.length() + query.length();
        return new StringBuilder(size)
                .append(action)
                .append('#')
                .append(data)
                .append('#')
                .append(query)
                .toString();
    }

    private static String makeKeyComponent(String str) {
        return str == null ? """" : str;
    }

    private static final String SCHEME_SEPARATOR = ""://"";
    private static final String DEFAULT_SCHEME = ""http"";

    /**
     * Simple url normalization that adds http:// if no scheme exists, and
     * strips empty paths, e.g.,
     * www.google.com/ -> http://www.google.com.  Used to prevent obvious
     * duplication of nav suggestions, bookmarks and urls entered by the user.
     */
    @VisibleForTesting
    static String normalizeUrl(String url) {
        String normalized;
        if (url != null) {
            int start;
            int schemePos = url.indexOf(SCHEME_SEPARATOR);
            if (schemePos == -1) {
                // no scheme - add the default
                normalized = DEFAULT_SCHEME + SCHEME_SEPARATOR + url;
                start = DEFAULT_SCHEME.length() + SCHEME_SEPARATOR.length();
            } else {
                normalized = url;
                start = schemePos + SCHEME_SEPARATOR.length();
            }
            int end = normalized.length();
            if (normalized.indexOf('/', start) == end - 1) {
                end--;
            }
            return normalized.substring(0, end);
        }
        return url;
    }

}
",False,77,7,17,5,4,4,2,L2
2,com.android.quicksearchbox.SuggestionFilter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

/**
 * Interface for choosing which suggestions to include in a promoted list.
 */
public interface SuggestionFilter {
    /**
     * Determines if a suggestion should be added to the promoted suggestion list.
     *
     * @param s The suggestion in question
     * @return true to include it in the results
     */
    boolean accept(Suggestion s);
}
",False,52,4,22,5,5,5,1,L6
3,com.android.quicksearchbox.ShouldQueryStrategy.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.text.TextUtils;
import android.util.Log;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * Decides whether a given source should be queried for a given query, taking
 * into account the source's query threshold and query after zero results flag.
 *
 * This class is thread safe.
 */
class ShouldQueryStrategy {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.ShouldQueryStrategy"";

    // The last query we've seen
    private String mLastQuery = """";

    private final Config mConfig;

    // The current implementation keeps a record of those corpora that have
    // returned zero results for some prefix of the current query. mEmptyCorpora
    // maps from corpus to the length of the query which returned
    // zero results.  When a query is shortened (e.g., by deleting characters)
    // or changed entirely, mEmptyCorpora is pruned (in updateQuery)
    private final HashMap<Corpus, Integer> mEmptyCorpora
            = new HashMap<Corpus, Integer>();

    public ShouldQueryStrategy(Config config) {
        mConfig = config;
    }

    /**
     * Returns whether we should query the given source for the given query.
     */
    public boolean shouldQueryCorpus(Corpus corpus, String query) {
        updateQuery(query);
        if (query.length() == 0
                && !corpus.isWebCorpus() // always query web, to warm up connection
                && !mConfig.showSuggestionsForZeroQuery()) {
                return false;
        }
        if (query.length() >= corpus.getQueryThreshold()) {
            if (!corpus.queryAfterZeroResults() && mEmptyCorpora.containsKey(corpus)) {
                if (DBG) Log.i(TAG, ""Not querying "" + corpus + "", returned 0 after ""
                        + mEmptyCorpora.get(corpus));
                return false;
            }
            return true;
        }
        if (DBG) Log.d(TAG, ""Query too short for corpus "" + corpus);
        return false;
    }

    /**
     * Called to notify ShouldQueryStrategy when a source reports no results for a query.
     */
    public void onZeroResults(Corpus corpus, String query) {
        // Make sure this result is actually for a prefix of the current query.
        if (mLastQuery.startsWith(query) && !corpus.queryAfterZeroResults()
                && !TextUtils.isEmpty(query)) {
            if (DBG) Log.d(TAG, corpus + "" returned 0 results for '"" + query + ""'"");
            mEmptyCorpora.put(corpus, query.length());
        }
    }

    private void updateQuery(String query) {
        if (query.startsWith(mLastQuery)) {
            // This is a refinement of the last query, no changes to mEmptyCorpora needed
        } else if (mLastQuery.startsWith(query)) {
            // This is a widening of the last query: clear out any sources
            // that reported zero results after this query.
            Iterator<Map.Entry<Corpus, Integer>> iter = mEmptyCorpora.entrySet().iterator();
            while (iter.hasNext()) {
                if (iter.next().getValue() > query.length()) {
                    iter.remove();
                }
            }
        } else {
            // This is a completely different query, clear everything.
            mEmptyCorpora.clear();
        }
        mLastQuery = query;
    }
}
",False,48,5,19,5,3,2,2,L2
4,com.android.quicksearchbox.SearchSettingsImpl.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.common.SharedPreferencesCompat;

import android.app.SearchManager;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.util.Log;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;

/**
 * Manages user settings.
 */
public class SearchSettingsImpl implements SearchSettings {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SearchSettingsImpl"";

    // Name of the preferences file used to store search preference
    public static final String PREFERENCES_NAME = ""SearchSettings"";

    // Intent action that opens the ""Searchable Items"" preference
    private static final String ACTION_SEARCHABLE_ITEMS =
            ""com.android.quicksearchbox.action.SEARCHABLE_ITEMS"";

    /**
     * Preference key used for storing the index of the next voice search hint to show.
     */
    private static final String NEXT_VOICE_SEARCH_HINT_INDEX_PREF = ""next_voice_search_hint"";

    /**
     * Preference key used to store the time at which the first voice search hint was displayed.
     */
    private static final String FIRST_VOICE_HINT_DISPLAY_TIME = ""first_voice_search_hint_time"";

    /**
     * Preference key for the version of voice search we last got hints from.
     */
    private static final String LAST_SEEN_VOICE_SEARCH_VERSION = ""voice_search_version"";

    /**
     * Preference key for storing whether searches always go to google.com. Public
     * so that it can be used by PreferenceControllers.
     */
    public static final String USE_GOOGLE_COM_PREF = ""use_google_com"";

    /**
     * Preference key for the base search URL. This value is normally set by
     * a SearchBaseUrlHelper instance. Public so classes can listen to changes
     * on this key.
     */
    public static final String SEARCH_BASE_DOMAIN_PREF = ""search_base_domain"";

    /**
     * This is the time at which the base URL was stored, and is set using
     * @link{System.currentTimeMillis()}.
     */
    private static final String SEARCH_BASE_DOMAIN_APPLY_TIME = ""search_base_domain_apply_time"";

    /**
     * Prefix of per-corpus enable preference
     */
    private static final String CORPUS_ENABLED_PREF_PREFIX = ""enable_corpus_"";

    private final Context mContext;

    private final Config mConfig;

    public SearchSettingsImpl(Context context, Config config) {
        mContext = context;
        mConfig = config;
    }

    protected Context getContext() {
        return mContext;
    }

    protected Config getConfig() {
        return mConfig;
    }

    public void upgradeSettingsIfNeeded() {
    }

    public Intent getSearchableItemsIntent() {
        Intent intent = new Intent(ACTION_SEARCHABLE_ITEMS);
        intent.setPackage(getContext().getPackageName());
        return intent;
    }

    /**
     * Gets the preference key of the preference for whether the given corpus
     * is enabled. The preference is stored in the {@link #PREFERENCES_NAME}
     * preferences file.
     */
    public static String getCorpusEnabledPreference(Corpus corpus) {
        return CORPUS_ENABLED_PREF_PREFIX + corpus.getName();
    }

    public boolean isCorpusEnabled(Corpus corpus) {
        boolean defaultEnabled = corpus.isCorpusDefaultEnabled();
        String sourceEnabledPref = getCorpusEnabledPreference(corpus);
        return getSearchPreferences().getBoolean(sourceEnabledPref, defaultEnabled);
    }

    public SharedPreferences getSearchPreferences() {
        return getContext().getSharedPreferences(PREFERENCES_NAME, Context.MODE_PRIVATE);
    }

    protected void storeBoolean(String name, boolean value) {
        SharedPreferencesCompat.apply(getSearchPreferences().edit().putBoolean(name, value));
    }

    protected void storeInt(String name, int value) {
        SharedPreferencesCompat.apply(getSearchPreferences().edit().putInt(name, value));
    }

    protected void storeLong(String name, long value) {
        SharedPreferencesCompat.apply(getSearchPreferences().edit().putLong(name, value));
    }

    protected void storeString(String name, String value) {
        SharedPreferencesCompat.apply(getSearchPreferences().edit().putString(name, value));
    }

    protected void removePref(String name) {
        SharedPreferencesCompat.apply(getSearchPreferences().edit().remove(name));
    }

    /**
     * Informs our listeners about the updated settings data.
     */
    public void broadcastSettingsChanged() {
        // We use a message broadcast since the listeners could be in multiple processes.
        Intent intent = new Intent(SearchManager.INTENT_ACTION_SEARCH_SETTINGS_CHANGED);
        Log.i(TAG, ""Broadcasting: "" + intent);
        getContext().sendBroadcast(intent);
    }

    public void addMenuItems(Menu menu, boolean showDisabled) {
        MenuInflater inflater = new MenuInflater(getContext());
        inflater.inflate(R.menu.settings, menu);
        MenuItem item = menu.findItem(R.id.menu_settings);
        item.setIntent(getSearchSettingsIntent());
    }

    public Intent getSearchSettingsIntent() {
        Intent settings = new Intent(SearchManager.INTENT_ACTION_SEARCH_SETTINGS);
        settings.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        settings.setPackage(getContext().getPackageName());
        return settings;
    }

    public int getNextVoiceSearchHintIndex(int size) {
            int i = getAndIncrementIntPreference(getSearchPreferences(),
                    NEXT_VOICE_SEARCH_HINT_INDEX_PREF);
            return i % size;
    }

    // TODO: Could this be made atomic to avoid races?
    private int getAndIncrementIntPreference(SharedPreferences prefs, String name) {
        int i = prefs.getInt(name, 0);
        storeInt(name, i + 1);
        return i;
    }

    public void resetVoiceSearchHintFirstSeenTime() {
        storeLong(FIRST_VOICE_HINT_DISPLAY_TIME, System.currentTimeMillis());
    }

    public boolean haveVoiceSearchHintsExpired(int currentVoiceSearchVersion) {
        SharedPreferences prefs = getSearchPreferences();

        if (currentVoiceSearchVersion != 0) {
            long currentTime = System.currentTimeMillis();
            int lastVoiceSearchVersion = prefs.getInt(LAST_SEEN_VOICE_SEARCH_VERSION, 0);
            long firstHintTime = prefs.getLong(FIRST_VOICE_HINT_DISPLAY_TIME, 0);
            if (firstHintTime == 0 || currentVoiceSearchVersion != lastVoiceSearchVersion) {
                SharedPreferencesCompat.apply(prefs.edit()
                        .putInt(LAST_SEEN_VOICE_SEARCH_VERSION, currentVoiceSearchVersion)
                        .putLong(FIRST_VOICE_HINT_DISPLAY_TIME, currentTime));
                firstHintTime = currentTime;
            }
            if (currentTime - firstHintTime > getConfig().getVoiceSearchHintActivePeriod()) {
                if (DBG) Log.d(TAG, ""Voice seach hint period expired; not showing hints."");
                return true;
            } else {
                return false;
            }
        } else {
            if (DBG) Log.d(TAG, ""Could not determine voice search version; not showing hints."");
            return true;
        }
    }

    public boolean allowWebSearchShortcuts() {
        return true;
    }

    /**
     * @return true if user searches should always be based at google.com, false
     *     otherwise.
     */
    @Override
    public boolean shouldUseGoogleCom() {
        // Note that this preserves the old behaviour of using google.com
        // for searches, with the gl= parameter set.
        return getSearchPreferences().getBoolean(USE_GOOGLE_COM_PREF, true);
    }

    @Override
    public void setUseGoogleCom(boolean useGoogleCom) {
        storeBoolean(USE_GOOGLE_COM_PREF, useGoogleCom);
    }

    @Override
    public long getSearchBaseDomainApplyTime() {
        return getSearchPreferences().getLong(SEARCH_BASE_DOMAIN_APPLY_TIME, -1);
    }

    @Override
    public String getSearchBaseDomain() {
        // Note that the only time this will return null is on the first run
        // of the app, or when settings have been cleared. Callers should
        // ideally check that getSearchBaseDomainApplyTime() is not -1 before
        // calling this function.
        return getSearchPreferences().getString(SEARCH_BASE_DOMAIN_PREF, null);
    }

    @Override
    public void setSearchBaseDomain(String searchBaseUrl) {
        Editor sharedPrefEditor = getSearchPreferences().edit();
        sharedPrefEditor.putString(SEARCH_BASE_DOMAIN_PREF, searchBaseUrl);
        sharedPrefEditor.putLong(SEARCH_BASE_DOMAIN_APPLY_TIME, System.currentTimeMillis());

        SharedPreferencesCompat.apply(sharedPrefEditor);
    }
}
",True,47,4,19,4,4,3,4,L8
5,com.android.quicksearchbox.Help.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;

/**
 * Handles app help.
 */
public class Help {

    private final Context mContext;
    private final Config mConfig;

    public Help(Context context, Config config) {
        mContext = context;
        mConfig = config;
    }

    public void addHelpMenuItem(Menu menu, String activityName) {
        addHelpMenuItem(menu, activityName, false);
    }

    public void addHelpMenuItem(Menu menu, String activityName, boolean showAsAction) {
        Intent helpIntent = getHelpIntent(activityName);
        if (helpIntent != null) {
            MenuInflater inflater = new MenuInflater(mContext);
            inflater.inflate(R.menu.help, menu);
            MenuItem item = menu.findItem(R.id.menu_help);
            item.setIntent(helpIntent);
            if (showAsAction) {
                item.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
            }
        }
    }

    private Intent getHelpIntent(String activityName) {
        Uri helpUrl = mConfig.getHelpUrl(activityName);
        if (helpUrl == null) return null;
        return new Intent(Intent.ACTION_VIEW, helpUrl);
    }

}
",False,45,4,18,5,4,3,1,L8
6,com.android.quicksearchbox.QueryTask.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.Consumer;
import com.android.quicksearchbox.util.Consumers;
import com.android.quicksearchbox.util.NamedTask;
import com.android.quicksearchbox.util.NamedTaskExecutor;

import android.os.Handler;
import android.util.Log;

/**
 * A task that gets suggestions from a corpus.
 */
public class QueryTask<C extends SuggestionCursor> implements NamedTask {
    private static final String TAG = ""QSB.QueryTask"";
    private static final boolean DBG = false;

    private final String mQuery;
    private final int mQueryLimit;
    private final SuggestionCursorProvider<C> mProvider;
    private final Handler mHandler;
    private final Consumer<C> mConsumer;
    private final boolean mTheOnlyOne;

    /**
     * Creates a new query task.
     *
     * @param query Query to run.
     * @param queryLimit The number of suggestions to ask each provider for.
     * @param provider The provider to ask for suggestions.
     * @param handler Handler that {@link Consumer#consume} will
     *        get called on. If null, the method is called on the query thread.
     * @param consumer Consumer to notify when the suggestions have been returned.
     * @param onlyTask Indicates if this is the only task within a batch.
     */
    public QueryTask(String query, int queryLimit, SuggestionCursorProvider<C> provider,
            Handler handler, Consumer<C> consumer, boolean onlyTask) {
        mQuery = query;
        mQueryLimit = queryLimit;
        mProvider = provider;
        mHandler = handler;
        mConsumer = consumer;
        mTheOnlyOne = onlyTask;
    }

    public String getName() {
        return mProvider.getName();
    }

    public void run() {
        final C cursor = mProvider.getSuggestions(mQuery, mQueryLimit, mTheOnlyOne);
        if (DBG) Log.d(TAG, ""Suggestions from "" + mProvider + "" = "" + cursor);
        Consumers.consumeCloseableAsync(mHandler, mConsumer, cursor);
    }

    @Override
    public String toString() {
        return mProvider + ""["" + mQuery + ""]"";
    }

    public static <C extends SuggestionCursor> void startQueries(String query,
            int maxResultsPerProvider,
            Iterable<? extends SuggestionCursorProvider<C>> providers,
            NamedTaskExecutor executor, Handler handler,
            Consumer<C> consumer, boolean onlyOneProvider) {

        for (SuggestionCursorProvider<C> provider : providers) {
            QueryTask.startQuery(query, maxResultsPerProvider, provider,
                    executor, handler, consumer, onlyOneProvider);
        }
    }

    public static <C extends SuggestionCursor> void startQuery(String query,
            int maxResultsPerProvider,
            SuggestionCursorProvider<C> provider,
            NamedTaskExecutor executor, Handler handler,
            Consumer<C> consumer, boolean onlyOneProvider) {

        QueryTask<C> task = new QueryTask<C>(query, maxResultsPerProvider, provider, handler,
                consumer, onlyOneProvider);
        executor.execute(task);
    }
}
",False,53,5,20,6,6,2,6,L3
7,com.android.quicksearchbox.SuggestionsProvider.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import java.util.List;


/**
 * Provides a set of suggestion results for a query..
 *
 */
public interface SuggestionsProvider {

    /**
     * Gets suggestions for a query.
     *
     * @param query The query.
     * @param corporaToQuery The corpora to query. Must be non-null.
     */
    Suggestions getSuggestions(String query, List<Corpus> corporaToQuery);

    void close();
}
",False,58,4,20,4,10,3,2,L6
8,com.android.quicksearchbox.SourceShortcutRefresher.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.NamedTask;
import com.android.quicksearchbox.util.NamedTaskExecutor;

import android.util.Log;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * Refreshes shortcuts from their source.
 */
class SourceShortcutRefresher implements ShortcutRefresher {
    private static final String TAG = ""QSB.SourceShortcutRefresher"";
    private static final boolean DBG = false;

    private final NamedTaskExecutor mExecutor;

    private final Set<String> mRefreshed = Collections.synchronizedSet(new HashSet<String>());
    private final Set<String> mRefreshing = Collections.synchronizedSet(new HashSet<String>());

    /**
     * Create a ShortcutRefresher that will refresh shortcuts using the given executor.
     *
     * @param executor Used to execute the tasks.
     */
    public SourceShortcutRefresher(NamedTaskExecutor executor) {
        mExecutor = executor;
    }

    public void refresh(Suggestion shortcut, Listener listener) {
        Source source = shortcut.getSuggestionSource();
        if (source == null) {
            throw new NullPointerException(""source"");
        }
        String shortcutId = shortcut.getShortcutId();
        if (shouldRefresh(source, shortcutId) && !isRefreshing(source, shortcutId)) {
            if (DBG) {
                Log.d(TAG, ""Refreshing shortcut  "" + shortcutId + "" '"" +
                        shortcut.getSuggestionText1() + ""'"");
            }
            markShortcutRefreshing(source, shortcutId);
            String extraData = shortcut.getSuggestionIntentExtraData();
            ShortcutRefreshTask refreshTask = new ShortcutRefreshTask(
                    source, shortcutId, extraData, listener);
            mExecutor.execute(refreshTask);
        }
    }

    /**
     * Returns true if the given shortcut requires refreshing.
     */
    public boolean shouldRefresh(Source source, String shortcutId) {
        return source != null && shortcutId != null
                && !mRefreshed.contains(makeKey(source, shortcutId));
    }

    public boolean isRefreshing(Source source, String shortcutId) {
        return source != null && shortcutId != null
                && mRefreshing.contains(makeKey(source, shortcutId));
    }

    private void markShortcutRefreshing(Source source, String shortcutId) {
        mRefreshing.add(makeKey(source, shortcutId));
    }

    /**
     * Indicate that the shortcut no longer requires refreshing.
     */
    public void markShortcutRefreshed(Source source, String shortcutId) {
        String key = makeKey(source, shortcutId);
        mRefreshed.add(key);
        mRefreshing.remove(key);
    }

    /**
     * Reset internal state.  This results in all shortcuts requiring refreshing.
     */
    public void reset() {
        mRefreshed.clear();
    }

    private static String makeKey(Source source, String shortcutId) {
        return source.getName() + ""#"" + shortcutId;
    }

    /**
     * Refreshes a shortcut with a source and reports the result to a
     * {@link ShortcutRefresher.Listener}.
     */
    private class ShortcutRefreshTask implements NamedTask {
        private final Source mSource;
        private final String mShortcutId;
        private final String mExtraData;
        private final Listener mListener;

        /**
         * @param source The source that should validate the shortcut.
         * @param shortcutId The shortcut to be refreshed.
         * @param listener Who to report back to when the result is in.
         */
        ShortcutRefreshTask(Source source, String shortcutId, String extraData,
                Listener listener) {
            mSource = source;
            mShortcutId = shortcutId;
            mExtraData = extraData;
            mListener = listener;
        }

        public String getName() {
            return mSource.getName();
        }

        public void run() {
            // TODO: Add latency tracking and logging.
            SuggestionCursor refreshed = mSource.refreshShortcut(mShortcutId, mExtraData);
            // Close cursor if empty and pass null as the refreshed cursor
            if (refreshed != null && refreshed.getCount() == 0) {
                refreshed.close();
                refreshed = null;
            }
            markShortcutRefreshed(mSource, mShortcutId);
            mListener.onShortcutRefreshed(mSource, mShortcutId, refreshed);
        }

    }
}
",False,49,4,19,4,7,2,7,L3
9,com.android.quicksearchbox.AbstractInternalSource.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import com.android.quicksearchbox.util.NamedTaskExecutor;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Handler;

/**
 * Abstract implementation of a source that is not backed by a searchable activity.
 */
public abstract class AbstractInternalSource extends AbstractSource {

    public AbstractInternalSource(Context context, Handler uiThread, NamedTaskExecutor iconLoader) {
        super(context, uiThread, iconLoader);
    }

    public String getSuggestUri() {
        return null;
    }

    public boolean canRead() {
        return true;
    }

    public String getDefaultIntentData() {
        return null;
    }

    @Override
    protected String getIconPackage() {
        return getContext().getPackageName();
    }

    public int getQueryThreshold() {
        return 0;
    }

    public Drawable getSourceIcon() {
        return getContext().getResources().getDrawable(getSourceIconResource());
    }

    public Uri getSourceIconUri() {
        return Uri.parse(""android.resource://"" + getContext().getPackageName()
                + ""/"" +  getSourceIconResource());
    }

    protected abstract int getSourceIconResource();

    public int getVersionCode() {
        return QsbApplication.get(getContext()).getVersionCode();
    }

    /**
     * Shortcuts from previous version are compatible with shortcuts from this version, so we just
     * return true. If shortcuts become incompatible during an upgrade, some examination of the
     * version code should be added here.
     */
    @Override
    public boolean isVersionCodeCompatible(int version) {
        return true;
    }

    public boolean queryAfterZeroResults() {
        return true;
    }

}
",False,118,0,0,6,53,1,3,L8
10,com.android.quicksearchbox.ShortcutsProvider.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.app.SearchManager;
import android.content.ComponentName;
import android.content.ContentProvider;
import android.content.ContentValues;
import android.content.Intent;
import android.content.UriMatcher;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.net.Uri;
import android.os.Binder;
import android.text.TextUtils;
import android.util.Log;

/**
 * Handles broadcast intents for adding shortcuts to QSB.
 */
public class ShortcutsProvider extends ContentProvider {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.ExternalShortcutReceiver"";

    public static final String EXTRA_SHORTCUT_SOURCE = ""shortcut_source"";

    private static final int URI_CODE_SHORTCUTS = 0;

    private UriMatcher mUriMatcher;

    @Override
    public boolean onCreate() {
        mUriMatcher = buildUriMatcher();
        return true;
    }

    private UriMatcher buildUriMatcher() {
        String authority = getAuthority();
        UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);
        matcher.addURI(authority, ""shortcuts"", URI_CODE_SHORTCUTS);
        return matcher;
    }

    private String getAuthority() {
        return getContext().getPackageName() + "".shortcuts"";
    }

    @Override
    public String getType(Uri uri) {
        switch (mUriMatcher.match(uri)) {
            case URI_CODE_SHORTCUTS:
                return SearchManager.SUGGEST_MIME_TYPE;
            default:
                throw new IllegalArgumentException(""Unknown URI: "" + uri);
        }
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        switch (mUriMatcher.match(uri)) {
            case URI_CODE_SHORTCUTS:
                addShortcut(values);
                return null;
            default:
                throw new IllegalArgumentException(""Unknown URI: "" + uri);
        }
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        throw new UnsupportedOperationException();
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
            String sortOrder) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        throw new UnsupportedOperationException();
    }

    private void addShortcut(final ContentValues shortcut) {
        String sourceName = shortcut.getAsString(EXTRA_SHORTCUT_SOURCE);
        if (TextUtils.isEmpty(sourceName)) {
            Log.e(TAG, ""Missing "" + EXTRA_SHORTCUT_SOURCE);
            return;
        }

        String sourceAction = shortcut.getAsString(SearchManager.SUGGEST_COLUMN_INTENT_ACTION);
        if (Intent.ACTION_WEB_SEARCH.equals(sourceAction)) {
            if (DBG) {
                Log.d(TAG, ""Ignoring shortcut from "" + sourceName +
                        ""because its intent action was ACTION_WEB_SEARCH."");
            }
            return;
        }

        final ComponentName sourceComponent = ComponentName.unflattenFromString(sourceName);
        if (!checkCallingPackage(sourceComponent.getPackageName())) {
            Log.w(TAG, ""Got shortcut for "" + sourceComponent + "" from a different process"");
            return;
        }

        getQsbApplication().runOnUiThread(new Runnable() {
            public void run() {
                storeShortcut(sourceComponent, shortcut);
            }
        });
    }

    // Called on the main thread
    private void storeShortcut(ComponentName sourceComponent, ContentValues shortcut) {
        if (DBG) Log.d(TAG, ""Adding (PID: "" + Binder.getCallingPid() + ""): "" + shortcut);

        Source source = getCorpora().getSource(sourceComponent.flattenToShortString());
        if (source == null) {
            Log.w(TAG, ""Unknown shortcut source "" + sourceComponent);
            return;
        }

        String userQuery = shortcut.getAsString(SearchManager.USER_QUERY);
        if (userQuery == null) userQuery = """";

        ListSuggestionCursor cursor = new ListSuggestionCursor(userQuery);
        cursor.add(makeSuggestion(source, shortcut));
        getShortcutRepository().reportClick(cursor, 0);
    }

    private boolean checkCallingPackage(String packageName) {
        int callingUid = Binder.getCallingUid();
        PackageManager pm = getContext().getPackageManager();
        String[] uidPkgs = pm.getPackagesForUid(callingUid);
        if (uidPkgs == null) return false;
        for (String uidPkg : uidPkgs) {
            if (packageName.equals(uidPkg)) return true;
        }
        return false;
    }

    private SuggestionData makeSuggestion(Source source, ContentValues shortcut) {
        String format = shortcut.getAsString(SearchManager.SUGGEST_COLUMN_FORMAT);
        String text1 = shortcut.getAsString(SearchManager.SUGGEST_COLUMN_TEXT_1);
        String text2 = shortcut.getAsString(SearchManager.SUGGEST_COLUMN_TEXT_2);
        String text2Url = shortcut.getAsString(SearchManager.SUGGEST_COLUMN_TEXT_2_URL);
        String icon1 = shortcut.getAsString(SearchManager.SUGGEST_COLUMN_ICON_1);
        String icon2 = shortcut.getAsString(SearchManager.SUGGEST_COLUMN_ICON_2);
        String shortcutId = shortcut.getAsString(SearchManager.SUGGEST_COLUMN_SHORTCUT_ID);
        boolean spinnerWhileRefreshing = unboxBoolean(
                shortcut.getAsBoolean(SearchManager.SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING),
                false);
        String intentAction = shortcut.getAsString(SearchManager.SUGGEST_COLUMN_INTENT_ACTION);
        String intentData = shortcut.getAsString(SearchManager.SUGGEST_COLUMN_INTENT_DATA);
        String intentExtraData =
                shortcut.getAsString(SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA);
        String query = shortcut.getAsString(SearchManager.SUGGEST_COLUMN_QUERY);

        SuggestionData suggestion = new SuggestionData(source);
        suggestion.setFormat(format);
        suggestion.setText1(text1);
        suggestion.setText2(text2);
        suggestion.setText2Url(text2Url);
        suggestion.setIcon1(icon1);
        suggestion.setIcon2(icon2);
        suggestion.setShortcutId(shortcutId);
        suggestion.setSpinnerWhileRefreshing(spinnerWhileRefreshing);
        suggestion.setIntentAction(intentAction);
        suggestion.setIntentData(intentData);
        suggestion.setIntentExtraData(intentExtraData);
        suggestion.setSuggestionQuery(query);
        return suggestion;
    }

    private static boolean unboxBoolean(Boolean value, boolean defValue) {
        return value == null ? defValue : value;
    }

    private QsbApplication getQsbApplication() {
        return QsbApplication.get(getContext());
    }

    private ShortcutRepository getShortcutRepository() {
        return getQsbApplication().getShortcutRepository();
    }

    private Corpora getCorpora() {
        return getQsbApplication().getCorpora();
    }

}
",False,120,0,0,6,54,0,6,L10
11,com.android.quicksearchbox.Corpora.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.database.DataSetObserver;

import java.util.Collection;
import java.util.List;

/**
 * Maintains the set of available and enabled corpora.
 */
public interface Corpora {

    /**
     * Gets all corpora, including the web corpus.
     *
     * @return Callers must not modify the returned collection.
     */
    Collection<Corpus> getAllCorpora();

    /**
     * Gets all enabled corpora.
     *
     * @return Callers must not modify the returned list.
     */
    List<Corpus> getEnabledCorpora();

    /**
     * Gets all corpora that should be included in the blended All mode.
     *
     * @return Callers must not modify the returned list.
     */
    List<Corpus> getCorporaInAll();

    /**
     * Gets a corpus by name.
     *
     * @return A corpus, or null.
     */
    Corpus getCorpus(String name);

    /**
     * Gets the web search corpus.
     *
     * @return The web search corpus, or {@code null} if there is no web search corpus.
     */
    Corpus getWebCorpus();

    /**
     * Gets a source by name.
     *
     * @param name Source name.
     * @return A source, or {@code null} if no source with the given name exists.
     */
    Source getSource(String name);

    /**
     * Gets the corpus that contains the given source.
     */
    Corpus getCorpusForSource(Source source);

    /**
     * Updates the corpora.
     */
    void update();

    /**
     * Registers an observer that is called when corpus set changes.
     *
     * @param observer gets notified when the data set changes.
     */
    void registerDataSetObserver(DataSetObserver observer);

    /**
     * Unregisters an observer that has previously been registered with
     * {@link #registerDataSetObserver(DataSetObserver)}
     *
     * @param observer the observer to unregister.
     */
    void unregisterDataSetObserver(DataSetObserver observer);
}
",False,54,4,18,4,6,12,2,L2
12,com.android.quicksearchbox.CursorBackedSourceResult.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import android.content.ComponentName;
import android.database.Cursor;

import java.util.Collection;

public class CursorBackedSourceResult extends CursorBackedSuggestionCursor
        implements SourceResult {

    private final Source mSource;

    public CursorBackedSourceResult(Source source, String userQuery) {
        this(source, userQuery, null);
    }

    public CursorBackedSourceResult(Source source, String userQuery, Cursor cursor) {
        super(userQuery, cursor);
        mSource = source;
    }

    public Source getSource() {
        return mSource;
    }

    @Override
    public Source getSuggestionSource() {
        return mSource;
    }

    @Override
    public ComponentName getSuggestionIntentComponent() {
        return mSource.getIntentComponent();
    }

    public boolean isSuggestionShortcut() {
        return false;
    }

    public boolean isHistorySuggestion() {
        return false;
    }

    @Override
    public String toString() {
        return mSource + ""["" + getUserQuery() + ""]"";
    }

    @Override
    public SuggestionExtras getExtras() {
        if (mCursor == null) return null;
        return CursorBackedSuggestionExtras.createExtrasIfNecessary(mCursor, getPosition());
    }

    public Collection<String> getExtraColumns() {
        if (mCursor == null) return null;
        return CursorBackedSuggestionExtras.getExtraColumns(mCursor);
    }

}",False,51,6,17,4,6,4,5,L3
13,com.android.quicksearchbox.ShortcutRepositoryImplLog.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.Consumer;
import com.android.quicksearchbox.util.Consumers;
import com.android.quicksearchbox.util.SQLiteAsyncQuery;
import com.android.quicksearchbox.util.SQLiteTransaction;
import com.android.quicksearchbox.util.Util;
import com.google.common.annotations.VisibleForTesting;

import org.json.JSONException;

import android.app.SearchManager;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;
import android.os.Handler;
import android.text.TextUtils;
import android.util.Log;

import java.io.File;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executor;

/**
 * A shortcut repository implementation that uses a log of every click.
 *
 * To inspect DB:
 * # sqlite3 /data/data/com.android.quicksearchbox/databases/qsb-log.db
 *
 * TODO: Refactor this class.
 */
public class ShortcutRepositoryImplLog implements ShortcutRepository {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.ShortcutRepositoryImplLog"";

    private static final String DB_NAME = ""qsb-log.db"";
    private static final int DB_VERSION = 32;

    private static final String HAS_HISTORY_QUERY =
        ""SELECT "" + Shortcuts.intent_key.fullName + "" FROM "" + Shortcuts.TABLE_NAME;
    private String mEmptyQueryShortcutQuery ;
    private String mShortcutQuery;

    private static final String SHORTCUT_BY_ID_WHERE =
            Shortcuts.shortcut_id.name() + ""=? AND "" + Shortcuts.source.name() + ""=?"";

    private static final String SOURCE_RANKING_SQL = buildSourceRankingSql();

    private final Context mContext;
    private final Config mConfig;
    private final Corpora mCorpora;
    private final ShortcutRefresher mRefresher;
    private final Handler mUiThread;
    // Used to perform log write operations asynchronously
    private final Executor mLogExecutor;
    private final DbOpenHelper mOpenHelper;
    private final String mSearchSpinner;

    /**
     * Create an instance to the repo.
     */
    public static ShortcutRepository create(Context context, Config config,
            Corpora sources, ShortcutRefresher refresher, Handler uiThread,
            Executor logExecutor) {
        return new ShortcutRepositoryImplLog(context, config, sources, refresher,
                uiThread, logExecutor, DB_NAME);
    }

    /**
     * @param context Used to create / open db
     * @param name The name of the database to create.
     */
    @VisibleForTesting
    ShortcutRepositoryImplLog(Context context, Config config, Corpora corpora,
            ShortcutRefresher refresher, Handler uiThread, Executor logExecutor, String name) {
        mContext = context;
        mConfig = config;
        mCorpora = corpora;
        mRefresher = refresher;
        mUiThread = uiThread;
        mLogExecutor = logExecutor;
        mOpenHelper = new DbOpenHelper(context, name, DB_VERSION, config);
        buildShortcutQueries();

        mSearchSpinner = Util.getResourceUri(mContext, R.drawable.search_spinner).toString();
    }

    // clicklog first, since that's where restrict the result set
    private static final String TABLES = ClickLog.TABLE_NAME + "" INNER JOIN "" +
            Shortcuts.TABLE_NAME + "" ON "" + ClickLog.intent_key.fullName + "" = "" +
            Shortcuts.intent_key.fullName;

    private static final String AS = "" AS "";

    private static final String[] SHORTCUT_QUERY_COLUMNS = {
            Shortcuts.intent_key.fullName,
            Shortcuts.source.fullName,
            Shortcuts.source_version_code.fullName,
            Shortcuts.format.fullName + AS + SearchManager.SUGGEST_COLUMN_FORMAT,
            Shortcuts.title + AS + SearchManager.SUGGEST_COLUMN_TEXT_1,
            Shortcuts.description + AS + SearchManager.SUGGEST_COLUMN_TEXT_2,
            Shortcuts.description_url + AS + SearchManager.SUGGEST_COLUMN_TEXT_2_URL,
            Shortcuts.icon1 + AS + SearchManager.SUGGEST_COLUMN_ICON_1,
            Shortcuts.icon2 + AS + SearchManager.SUGGEST_COLUMN_ICON_2,
            Shortcuts.intent_action + AS + SearchManager.SUGGEST_COLUMN_INTENT_ACTION,
            Shortcuts.intent_component.fullName,
            Shortcuts.intent_data + AS + SearchManager.SUGGEST_COLUMN_INTENT_DATA,
            Shortcuts.intent_query + AS + SearchManager.SUGGEST_COLUMN_QUERY,
            Shortcuts.intent_extradata + AS + SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA,
            Shortcuts.shortcut_id + AS + SearchManager.SUGGEST_COLUMN_SHORTCUT_ID,
            Shortcuts.spinner_while_refreshing + AS +
                    SearchManager.SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING,
            Shortcuts.log_type + AS + CursorBackedSuggestionCursor.SUGGEST_COLUMN_LOG_TYPE,
            Shortcuts.custom_columns.fullName,
        };

    // Avoid GLOB by using >= AND <, with some manipulation (see nextString(String)).
    // to figure out the upper bound (e.g. >= ""abc"" AND < ""abd""
    // This allows us to use parameter binding and still take advantage of the
    // index on the query column.
    private static final String PREFIX_RESTRICTION =
            ClickLog.query.fullName + "" >= ?1 AND "" + ClickLog.query.fullName + "" < ?2"";

    private static final String LAST_HIT_TIME_EXPR = ""MAX("" + ClickLog.hit_time.fullName + "")"";
    private static final String GROUP_BY = ClickLog.intent_key.fullName;
    private static final String PREFER_LATEST_PREFIX =
        ""("" + LAST_HIT_TIME_EXPR + "" = (SELECT "" + LAST_HIT_TIME_EXPR + "" FROM "" +
        ClickLog.TABLE_NAME + "" WHERE "";
    private static final String PREFER_LATEST_SUFFIX = ""))"";

    private void buildShortcutQueries() {
        // SQL expression for the time before which no clicks should be counted.
        String cutOffTime_expr = ""(?3 - "" + mConfig.getMaxStatAgeMillis() + "")"";
        // Filter out clicks that are too old
        String ageRestriction = ClickLog.hit_time.fullName + "" >= "" + cutOffTime_expr;
        String having = null;
        // Order by sum of hit times (seconds since cutoff) for the clicks for each shortcut.
        // This has the effect of multiplying the average hit time with the click count
        String ordering_expr =
                ""SUM(("" + ClickLog.hit_time.fullName + "" - "" + cutOffTime_expr + "") / 1000)"";

        String where = ageRestriction;
        String preferLatest = PREFER_LATEST_PREFIX + where + PREFER_LATEST_SUFFIX;
        String orderBy = preferLatest + "" DESC, "" + ordering_expr + "" DESC"";
        mEmptyQueryShortcutQuery = SQLiteQueryBuilder.buildQueryString(
                false, TABLES, SHORTCUT_QUERY_COLUMNS, where, GROUP_BY, having, orderBy, null);
        if (DBG) Log.d(TAG, ""Empty shortcut query:\n"" + mEmptyQueryShortcutQuery);

        where = PREFIX_RESTRICTION + "" AND "" + ageRestriction;
        preferLatest = PREFER_LATEST_PREFIX + where + PREFER_LATEST_SUFFIX;
        orderBy = preferLatest + "" DESC, "" + ordering_expr + "" DESC"";
        mShortcutQuery = SQLiteQueryBuilder.buildQueryString(
                false, TABLES, SHORTCUT_QUERY_COLUMNS, where, GROUP_BY, having, orderBy, null);
        if (DBG) Log.d(TAG, ""Empty shortcut:\n"" + mShortcutQuery);
    }

    /**
     * @return sql that ranks sources by total clicks, filtering out sources
     *         without enough clicks.
     */
    private static String buildSourceRankingSql() {
        final String orderingExpr = SourceStats.total_clicks.name();
        final String tables = SourceStats.TABLE_NAME;
        final String[] columns = SourceStats.COLUMNS;
        final String where = SourceStats.total_clicks + "" >= $1"";
        final String groupBy = null;
        final String having = null;
        final String orderBy = orderingExpr + "" DESC"";
        final String limit = null;
        return SQLiteQueryBuilder.buildQueryString(
                false, tables, columns, where, groupBy, having, orderBy, limit);
    }

    protected DbOpenHelper getOpenHelper() {
        return mOpenHelper;
    }

    private void runTransactionAsync(final SQLiteTransaction transaction) {
        mLogExecutor.execute(new Runnable() {
            public void run() {
                transaction.run(mOpenHelper.getWritableDatabase());
            }
        });
    }

    private <A> void runQueryAsync(final SQLiteAsyncQuery<A> query, final Consumer<A> consumer) {
        mLogExecutor.execute(new Runnable() {
            public void run() {
                query.run(mOpenHelper.getReadableDatabase(), consumer);
            }
        });
    }

// --------------------- Interface ShortcutRepository ---------------------

    public void hasHistory(Consumer<Boolean> consumer) {
        runQueryAsync(new SQLiteAsyncQuery<Boolean>() {
            @Override
            protected Boolean performQuery(SQLiteDatabase db) {
                return hasHistory(db);
            }
        }, consumer);
    }

    public void removeFromHistory(SuggestionCursor suggestions, int position) {
        suggestions.moveTo(position);
        final String intentKey = makeIntentKey(suggestions);
        runTransactionAsync(new SQLiteTransaction() {
            @Override
            public boolean performTransaction(SQLiteDatabase db) {
                db.delete(Shortcuts.TABLE_NAME, Shortcuts.intent_key.fullName + "" = ?"",
                        new String[]{ intentKey });
                return true;
            }
        });
    }

    public void clearHistory() {
        runTransactionAsync(new SQLiteTransaction() {
            @Override
            public boolean performTransaction(SQLiteDatabase db) {
                db.delete(ClickLog.TABLE_NAME, null, null);
                db.delete(Shortcuts.TABLE_NAME, null, null);
                db.delete(SourceStats.TABLE_NAME, null, null);
                return true;
            }
        });
    }

    @VisibleForTesting
    public void deleteRepository() {
        getOpenHelper().deleteDatabase();
    }

    public void close() {
        getOpenHelper().close();
    }

    public void reportClick(final SuggestionCursor suggestions, final int position) {
        final long now = System.currentTimeMillis();
        reportClickAtTime(suggestions, position, now);
    }

    public void getShortcutsForQuery(final String query, final Collection<Corpus> allowedCorpora,
            final boolean allowWebSearchShortcuts, final Consumer<ShortcutCursor> consumer) {
        final long now = System.currentTimeMillis();
        mLogExecutor.execute(new Runnable() {
            public void run() {
                ShortcutCursor shortcuts = getShortcutsForQuery(query, allowedCorpora,
                        allowWebSearchShortcuts, now);
                Consumers.consumeCloseable(consumer, shortcuts);
            }
        });
    }

    public void updateShortcut(Source source, String shortcutId, SuggestionCursor refreshed) {
        refreshShortcut(source, shortcutId, refreshed);
    }

    public void getCorpusScores(final Consumer<Map<String, Integer>> consumer) {
        runQueryAsync(new SQLiteAsyncQuery<Map<String, Integer>>() {
            @Override
            protected Map<String, Integer> performQuery(SQLiteDatabase db) {
                return getCorpusScores();
            }
        }, consumer);
    }

// -------------------------- end ShortcutRepository --------------------------

    private boolean hasHistory(SQLiteDatabase db) {
        Cursor cursor = db.rawQuery(HAS_HISTORY_QUERY, null);
        try {
            if (DBG) Log.d(TAG, ""hasHistory(): cursor="" + cursor);
            return cursor != null && cursor.getCount() > 0;
        } finally {
            if (cursor != null) cursor.close();
        }
    }

    private Map<String,Integer> getCorpusScores() {
        return getCorpusScores(mConfig.getMinClicksForSourceRanking());
    }

    private boolean shouldRefresh(Suggestion suggestion) {
        return mRefresher.shouldRefresh(suggestion.getSuggestionSource(),
                suggestion.getShortcutId());
    }

    @VisibleForTesting
    ShortcutCursor getShortcutsForQuery(String query, Collection<Corpus> allowedCorpora,
            boolean allowWebSearchShortcuts, long now) {
        if (DBG) Log.d(TAG, ""getShortcutsForQuery("" + query + "","" + allowedCorpora + "")"");
        String sql = query.length() == 0 ? mEmptyQueryShortcutQuery : mShortcutQuery;
        String[] params = buildShortcutQueryParams(query, now);

        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
        Cursor cursor = db.rawQuery(sql, params);
        if (cursor.getCount() == 0) {
            cursor.close();
            return null;
        }

        if (DBG) Log.d(TAG, ""Allowed sources: "");
        HashMap<String,Source> allowedSources = new HashMap<String,Source>();
        for (Corpus corpus : allowedCorpora) {
            for (Source source : corpus.getSources()) {
                if (DBG) Log.d(TAG, ""\t"" + source.getName());
                allowedSources.put(source.getName(), source);
            }
        }

        return new ShortcutCursor(new SuggestionCursorImpl(allowedSources, query, cursor),
                allowWebSearchShortcuts, mUiThread, mRefresher, this);
    }

    @VisibleForTesting
    void refreshShortcut(Source source, final String shortcutId,
            SuggestionCursor refreshed) {
        if (source == null) throw new NullPointerException(""source"");
        if (shortcutId == null) throw new NullPointerException(""shortcutId"");

        final String[] whereArgs = { shortcutId, source.getName() };
        final ContentValues shortcut;
        if (refreshed == null || refreshed.getCount() == 0) {
            shortcut = null;
        } else {
            refreshed.moveTo(0);
            shortcut = makeShortcutRow(refreshed);
        }

        runTransactionAsync(new SQLiteTransaction() {
            @Override
            protected boolean performTransaction(SQLiteDatabase db) {
                if (shortcut == null) {
                    if (DBG) Log.d(TAG, ""Deleting shortcut: "" + shortcutId);
                    db.delete(Shortcuts.TABLE_NAME, SHORTCUT_BY_ID_WHERE, whereArgs);
                } else {
                    if (DBG) Log.d(TAG, ""Updating shortcut: "" + shortcut);
                    db.updateWithOnConflict(Shortcuts.TABLE_NAME, shortcut,
                            SHORTCUT_BY_ID_WHERE, whereArgs, SQLiteDatabase.CONFLICT_REPLACE);
                }
                return true;
            }
        });
    }

    private class SuggestionCursorImpl extends CursorBackedSuggestionCursor {

        private final HashMap<String, Source> mAllowedSources;
        private final int mExtrasColumn;

        public SuggestionCursorImpl(HashMap<String,Source> allowedSources,
                String userQuery, Cursor cursor) {
            super(userQuery, cursor);
            mAllowedSources = allowedSources;
            mExtrasColumn = cursor.getColumnIndex(Shortcuts.custom_columns.name());
        }

        @Override
        public Source getSuggestionSource() {
            int srcCol = mCursor.getColumnIndex(Shortcuts.source.name());
            String srcStr = mCursor.getString(srcCol);
            if (srcStr == null) {
                throw new NullPointerException(""Missing source for shortcut."");
            }
            Source source = mAllowedSources.get(srcStr);
            if (source == null) {
                if (DBG) {
                    Log.d(TAG, ""Source "" + srcStr + "" (position "" + mCursor.getPosition() +
                            "") not allowed"");
                }
                return null;
            }
            int versionCode = mCursor.getInt(Shortcuts.source_version_code.ordinal());
            if (!source.isVersionCodeCompatible(versionCode)) {
                if (DBG) {
                    Log.d(TAG, ""Version "" + versionCode + "" not compatible with "" +
                            source.getVersionCode() + "" for source "" + srcStr);
                }
                return null;
            }
            return source;
        }

        @Override
        public ComponentName getSuggestionIntentComponent() {
            int componentCol = mCursor.getColumnIndex(Shortcuts.intent_component.name());
            // We don't fall back to getSuggestionSource().getIntentComponent() because
            // we want to return the same value that getSuggestionIntentComponent() did for the
            // original suggestion.
            return stringToComponentName(mCursor.getString(componentCol));
        }

        @Override
        public String getSuggestionIcon2() {
            if (isSpinnerWhileRefreshing() && shouldRefresh(this)) {
                if (DBG) Log.d(TAG, ""shortcut "" + getShortcutId() + "" refreshing"");
                return mSearchSpinner;
            }
            if (DBG) Log.d(TAG, ""shortcut "" + getShortcutId() + "" NOT refreshing"");
            return super.getSuggestionIcon2();
        }

        public boolean isSuggestionShortcut() {
            return true;
        }

        public boolean isHistorySuggestion() {
            // This always returns false, even for suggestions that originally came
            // from server-side history, since we'd otherwise have to parse the Genie
            // extra data. This is ok, since this method is only used for the
            // ""Remove from history"" UI, which is also shown for all shortcuts.
            return false;
        }

        @Override
        public SuggestionExtras getExtras() {
            String json = mCursor.getString(mExtrasColumn);
            if (!TextUtils.isEmpty(json)) {
                try {
                    return new JsonBackedSuggestionExtras(json);
                } catch (JSONException e) {
                    Log.e(TAG, ""Could not parse JSON extras from DB: "" + json);
                }
            }
            return null;
        }

        public Collection<String> getExtraColumns() {
            /*
             * We always return null here because:
             * - to return an accurate value, we'd have to aggregate all the extra columns in all
             *   shortcuts in the shortcuts table, which would mean parsing ALL the JSON contained
             *   therein
             * - ListSuggestionCursor does this aggregation, and does it lazily
             * - All shortcuts are put into a ListSuggestionCursor during the promotion process, so
             *   relying on ListSuggestionCursor to do the aggregation means that we only parse the
             *   JSON for shortcuts that are actually displayed.
             */
            return null;
        }
    }

    /**
     * Builds a parameter list for the queries built by {@link #buildShortcutQueries}.
     */
    private static String[] buildShortcutQueryParams(String query, long now) {
        return new String[]{ query, nextString(query), String.valueOf(now) };
    }

    /**
     * Given a string x, this method returns the least string y such that x is not a prefix of y.
     * This is useful to implement prefix filtering by comparison, since the only strings z that
     * have x as a prefix are such that z is greater than or equal to x and z is less than y.
     *
     * @param str A non-empty string. The contract above is not honored for an empty input string,
     *        since all strings have the empty string as a prefix.
     */
    private static String nextString(String str) {
        int len = str.length();
        if (len == 0) {
            return str;
        }
        // The last code point in the string. Within the Basic Multilingual Plane,
        // this is the same as str.charAt(len-1)
        int codePoint = str.codePointBefore(len);
        // This should be safe from overflow, since the largest code point
        // representable in UTF-16 is U+10FFFF.
        int nextCodePoint = codePoint + 1;
        // The index of the start of the last code point.
        // Character.charCount(codePoint) is always 1 (in the BMP) or 2
        int lastIndex = len - Character.charCount(codePoint);
        return new StringBuilder(len)
                .append(str, 0, lastIndex)  // append everything but the last code point
                .appendCodePoint(nextCodePoint)  // instead of the last code point, use successor
                .toString();
    }

    /**
     * Returns the source ranking for sources with a minimum number of clicks.
     *
     * @param minClicks The minimum number of clicks a source must have.
     * @return The list of sources, ranked by total clicks.
     */
    Map<String,Integer> getCorpusScores(int minClicks) {
        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
        final Cursor cursor = db.rawQuery(
                SOURCE_RANKING_SQL, new String[] { String.valueOf(minClicks) });
        try {
            Map<String,Integer> corpora = new HashMap<String,Integer>(cursor.getCount());
            while (cursor.moveToNext()) {
                String name = cursor.getString(SourceStats.corpus.ordinal());
                int clicks = cursor.getInt(SourceStats.total_clicks.ordinal());
                corpora.put(name, clicks);
            }
            return corpora;
        } finally {
            cursor.close();
        }
    }

    private ContentValues makeShortcutRow(Suggestion suggestion) {
        String intentAction = suggestion.getSuggestionIntentAction();
        String intentComponent = componentNameToString(suggestion.getSuggestionIntentComponent());
        String intentData = suggestion.getSuggestionIntentDataString();
        String intentQuery = suggestion.getSuggestionQuery();
        String intentExtraData = suggestion.getSuggestionIntentExtraData();

        Source source = suggestion.getSuggestionSource();
        String sourceName = source.getName();

        String intentKey = makeIntentKey(suggestion);

        // Get URIs for all icons, to make sure that they are stable
        String icon1Uri = getIconUriString(source, suggestion.getSuggestionIcon1());
        String icon2Uri = getIconUriString(source, suggestion.getSuggestionIcon2());

        String extrasJson = null;
        SuggestionExtras extras = suggestion.getExtras();
        if (extras != null) {
            // flatten any custom columns to JSON. We need to keep any custom columns so that
            // shortcuts for custom suggestion views work properly.
            try {
                extrasJson = extras.toJsonString();
            } catch (JSONException e) {
                Log.e(TAG, ""Could not flatten extras to JSON from "" + suggestion, e);
            }
        }

        ContentValues cv = new ContentValues();
        cv.put(Shortcuts.intent_key.name(), intentKey);
        cv.put(Shortcuts.source.name(), sourceName);
        cv.put(Shortcuts.source_version_code.name(), source.getVersionCode());
        cv.put(Shortcuts.format.name(), suggestion.getSuggestionFormat());
        cv.put(Shortcuts.title.name(), suggestion.getSuggestionText1());
        cv.put(Shortcuts.description.name(), suggestion.getSuggestionText2());
        cv.put(Shortcuts.description_url.name(), suggestion.getSuggestionText2Url());
        cv.put(Shortcuts.icon1.name(), icon1Uri);
        cv.put(Shortcuts.icon2.name(), icon2Uri);
        cv.put(Shortcuts.intent_action.name(), intentAction);
        cv.put(Shortcuts.intent_component.name(), intentComponent);
        cv.put(Shortcuts.intent_data.name(), intentData);
        cv.put(Shortcuts.intent_query.name(), intentQuery);
        cv.put(Shortcuts.intent_extradata.name(), intentExtraData);
        cv.put(Shortcuts.shortcut_id.name(), suggestion.getShortcutId());
        if (suggestion.isSpinnerWhileRefreshing()) {
            cv.put(Shortcuts.spinner_while_refreshing.name(), ""true"");
        }
        cv.put(Shortcuts.log_type.name(), suggestion.getSuggestionLogType());
        cv.put(Shortcuts.custom_columns.name(), extrasJson);

        return cv;
    }

    /**
     * Makes a string of the form source#intentData#intentAction#intentQuery
     * for use as a unique identifier of a suggestion.
     * */
    private String makeIntentKey(Suggestion suggestion) {
        String intentAction = suggestion.getSuggestionIntentAction();
        String intentComponent = componentNameToString(suggestion.getSuggestionIntentComponent());
        String intentData = suggestion.getSuggestionIntentDataString();
        String intentQuery = suggestion.getSuggestionQuery();

        Source source = suggestion.getSuggestionSource();
        String sourceName = source.getName();
        StringBuilder key = new StringBuilder(sourceName);
        key.append(""#"");
        if (intentData != null) {
            key.append(intentData);
        }
        key.append(""#"");
        if (intentAction != null) {
            key.append(intentAction);
        }
        key.append(""#"");
        if (intentComponent != null) {
            key.append(intentComponent);
        }
        key.append(""#"");
        if (intentQuery != null) {
            key.append(intentQuery);
        }

        return key.toString();
    }

    private String componentNameToString(ComponentName component) {
        return component == null ? null : component.flattenToShortString();
    }

    private ComponentName stringToComponentName(String str) {
        return str == null ? null : ComponentName.unflattenFromString(str);
    }

    private String getIconUriString(Source source, String drawableId) {
        // Fast path for empty icons
        if (TextUtils.isEmpty(drawableId) || ""0"".equals(drawableId)) {
            return null;
        }
        // Fast path for icon URIs
        if (drawableId.startsWith(ContentResolver.SCHEME_ANDROID_RESOURCE)
                || drawableId.startsWith(ContentResolver.SCHEME_CONTENT)
                || drawableId.startsWith(ContentResolver.SCHEME_FILE)) {
            return drawableId;
        }
        Uri uri = source.getIconUri(drawableId);
        return uri == null ? null : uri.toString();
    }

    @VisibleForTesting
    void reportClickAtTime(SuggestionCursor suggestion,
            int position, long now) {
        suggestion.moveTo(position);
        if (DBG) {
            Log.d(TAG, ""logClicked("" + suggestion + "")"");
        }

        if (SearchManager.SUGGEST_NEVER_MAKE_SHORTCUT.equals(suggestion.getShortcutId())) {
            if (DBG) Log.d(TAG, ""clicked suggestion requested not to be shortcuted"");
            return;
        }

        Corpus corpus = mCorpora.getCorpusForSource(suggestion.getSuggestionSource());
        if (corpus == null) {
            Log.w(TAG, ""no corpus for clicked suggestion"");
            return;
        }

        // Once the user has clicked on a shortcut, don't bother refreshing
        // (especially if this is a new shortcut)
        mRefresher.markShortcutRefreshed(suggestion.getSuggestionSource(),
                suggestion.getShortcutId());

        // Add or update suggestion info
        // Since intent_key is the primary key, any existing
        // suggestion with the same source+data+action will be replaced
        final ContentValues shortcut = makeShortcutRow(suggestion);
        String intentKey = shortcut.getAsString(Shortcuts.intent_key.name());

        // Log click for shortcut
        final ContentValues click = new ContentValues();
        click.put(ClickLog.intent_key.name(), intentKey);
        click.put(ClickLog.query.name(), suggestion.getUserQuery());
        click.put(ClickLog.hit_time.name(), now);
        click.put(ClickLog.corpus.name(), corpus.getName());

        runTransactionAsync(new SQLiteTransaction() {
            @Override
            protected boolean performTransaction(SQLiteDatabase db) {
                if (DBG) Log.d(TAG, ""Adding shortcut: "" + shortcut);
                db.replaceOrThrow(Shortcuts.TABLE_NAME, null, shortcut);
                db.insertOrThrow(ClickLog.TABLE_NAME, null, click);
                return true;
            }
        });
    }

// -------------------------- TABLES --------------------------

    /**
     * shortcuts table
     */
    enum Shortcuts {
        intent_key,
        source,
        source_version_code,
        format,
        title,
        description,
        description_url,
        icon1,
        icon2,
        intent_action,
        intent_component,
        intent_data,
        intent_query,
        intent_extradata,
        shortcut_id,
        spinner_while_refreshing,
        log_type,
        custom_columns;

        static final String TABLE_NAME = ""shortcuts"";

        public final String fullName;

        Shortcuts() {
            fullName = TABLE_NAME + ""."" + name();
        }
    }

    /**
     * clicklog table. Has one record for each click.
     */
    enum ClickLog {
        _id,
        intent_key,
        query,
        hit_time,
        corpus;

        static final String[] COLUMNS = initColumns();

        static final String TABLE_NAME = ""clicklog"";

        private static String[] initColumns() {
            ClickLog[] vals = ClickLog.values();
            String[] columns = new String[vals.length];
            for (int i = 0; i < vals.length; i++) {
                columns[i] = vals[i].fullName;
            }
            return columns;
        }

        public final String fullName;

        ClickLog() {
            fullName = TABLE_NAME + ""."" + name();
        }
    }

    /**
     * This is an aggregate table of {@link ClickLog} that stays up to date with the total
     * clicks for each corpus. This makes computing the corpus ranking more
     * more efficient, at the expense of some extra work when the clicks are reported.
     */
    enum SourceStats {
        corpus,
        total_clicks;

        static final String TABLE_NAME = ""sourcetotals"";

        static final String[] COLUMNS = initColumns();

        private static String[] initColumns() {
            SourceStats[] vals = SourceStats.values();
            String[] columns = new String[vals.length];
            for (int i = 0; i < vals.length; i++) {
                columns[i] = vals[i].fullName;
            }
            return columns;
        }

        public final String fullName;

        SourceStats() {
            fullName = TABLE_NAME + ""."" + name();
        }
    }

// -------------------------- END TABLES --------------------------

    // contains creation and update logic
    private static class DbOpenHelper extends SQLiteOpenHelper {
        private final Config mConfig;
        private String mPath;
        private static final String SHORTCUT_ID_INDEX
                = Shortcuts.TABLE_NAME + ""_"" + Shortcuts.shortcut_id.name();
        private static final String CLICKLOG_QUERY_INDEX
                = ClickLog.TABLE_NAME + ""_"" + ClickLog.query.name();
        private static final String CLICKLOG_HIT_TIME_INDEX
                = ClickLog.TABLE_NAME + ""_"" + ClickLog.hit_time.name();
        private static final String CLICKLOG_INSERT_TRIGGER
                = ClickLog.TABLE_NAME + ""_insert"";
        private static final String SHORTCUTS_DELETE_TRIGGER
                = Shortcuts.TABLE_NAME + ""_delete"";
        private static final String SHORTCUTS_UPDATE_INTENT_KEY_TRIGGER
                = Shortcuts.TABLE_NAME + ""_update_intent_key"";

        public DbOpenHelper(Context context, String name, int version, Config config) {
            super(context, name, null, version);
            mConfig = config;
        }

        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
            // The shortcuts info is not all that important, so we just drop the tables
            // and re-create empty ones.
            Log.i(TAG, ""Upgrading shortcuts DB from version "" +
                    + oldVersion + "" to "" + newVersion + "". This deletes all shortcuts."");
            dropTables(db);
            onCreate(db);
        }

        private void dropTables(SQLiteDatabase db) {
            db.execSQL(""DROP TRIGGER IF EXISTS "" + CLICKLOG_INSERT_TRIGGER);
            db.execSQL(""DROP TRIGGER IF EXISTS "" + SHORTCUTS_DELETE_TRIGGER);
            db.execSQL(""DROP TRIGGER IF EXISTS "" + SHORTCUTS_UPDATE_INTENT_KEY_TRIGGER);
            db.execSQL(""DROP INDEX IF EXISTS "" + CLICKLOG_HIT_TIME_INDEX);
            db.execSQL(""DROP INDEX IF EXISTS "" + CLICKLOG_QUERY_INDEX);
            db.execSQL(""DROP INDEX IF EXISTS "" + SHORTCUT_ID_INDEX);
            db.execSQL(""DROP TABLE IF EXISTS "" + ClickLog.TABLE_NAME);
            db.execSQL(""DROP TABLE IF EXISTS "" + Shortcuts.TABLE_NAME);
            db.execSQL(""DROP TABLE IF EXISTS "" + SourceStats.TABLE_NAME);
        }

        /**
         * Deletes the database file.
         */
        public void deleteDatabase() {
            close();
            if (mPath == null) return;
            try {
                new File(mPath).delete();
                if (DBG) Log.d(TAG, ""deleted "" + mPath);
            } catch (Exception e) {
                Log.w(TAG, ""couldn't delete "" + mPath, e);
            }
        }

        @Override
        public void onOpen(SQLiteDatabase db) {
            super.onOpen(db);
            mPath = db.getPath();
        }

        @Override
        public void onCreate(SQLiteDatabase db) {
            db.execSQL(""CREATE TABLE "" + Shortcuts.TABLE_NAME + "" ("" +
                    // COLLATE UNICODE is needed to make it possible to use nextString()
                    // to implement fast prefix filtering.
                    Shortcuts.intent_key.name() + "" TEXT NOT NULL COLLATE UNICODE PRIMARY KEY, "" +
                    Shortcuts.source.name() + "" TEXT NOT NULL, "" +
                    Shortcuts.source_version_code.name() + "" INTEGER NOT NULL, "" +
                    Shortcuts.format.name() + "" TEXT, "" +
                    Shortcuts.title.name() + "" TEXT, "" +
                    Shortcuts.description.name() + "" TEXT, "" +
                    Shortcuts.description_url.name() + "" TEXT, "" +
                    Shortcuts.icon1.name() + "" TEXT, "" +
                    Shortcuts.icon2.name() + "" TEXT, "" +
                    Shortcuts.intent_action.name() + "" TEXT, "" +
                    Shortcuts.intent_component.name() + "" TEXT, "" +
                    Shortcuts.intent_data.name() + "" TEXT, "" +
                    Shortcuts.intent_query.name() + "" TEXT, "" +
                    Shortcuts.intent_extradata.name() + "" TEXT, "" +
                    Shortcuts.shortcut_id.name() + "" TEXT, "" +
                    Shortcuts.spinner_while_refreshing.name() + "" TEXT, "" +
                    Shortcuts.log_type.name() + "" TEXT, "" +
                    Shortcuts.custom_columns.name() + "" TEXT"" +
                    "");"");

            // index for fast lookup of shortcuts by shortcut_id
            db.execSQL(""CREATE INDEX "" + SHORTCUT_ID_INDEX
                    + "" ON "" + Shortcuts.TABLE_NAME
                    + ""("" + Shortcuts.shortcut_id.name() + "", "" + Shortcuts.source.name() + "")"");

            db.execSQL(""CREATE TABLE "" + ClickLog.TABLE_NAME + "" ( "" +
                    ClickLog._id.name() + "" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, "" +
                    // type must match Shortcuts.intent_key
                    ClickLog.intent_key.name() + "" TEXT NOT NULL COLLATE UNICODE REFERENCES ""
                        + Shortcuts.TABLE_NAME + ""("" + Shortcuts.intent_key + ""), "" +
                    ClickLog.query.name() + "" TEXT, "" +
                    ClickLog.hit_time.name() + "" INTEGER,"" +
                    ClickLog.corpus.name() + "" TEXT"" +
                    "");"");

            // index for fast lookup of clicks by query
            db.execSQL(""CREATE INDEX "" + CLICKLOG_QUERY_INDEX
                    + "" ON "" + ClickLog.TABLE_NAME + ""("" + ClickLog.query.name() + "")"");

            // index for finding old clicks quickly
            db.execSQL(""CREATE INDEX "" + CLICKLOG_HIT_TIME_INDEX
                    + "" ON "" + ClickLog.TABLE_NAME + ""("" + ClickLog.hit_time.name() + "")"");

            // trigger for purging old clicks, i.e. those such that
            // hit_time < now - MAX_MAX_STAT_AGE_MILLIS, where now is the
            // hit_time of the inserted record, and for updating the SourceStats table
            db.execSQL(""CREATE TRIGGER "" + CLICKLOG_INSERT_TRIGGER + "" AFTER INSERT ON ""
                    + ClickLog.TABLE_NAME
                    + "" BEGIN""
                    + "" DELETE FROM "" + ClickLog.TABLE_NAME + "" WHERE ""
                            + ClickLog.hit_time.name() + "" <""
                            + "" NEW."" + ClickLog.hit_time.name()
                                    + "" - "" + mConfig.getMaxStatAgeMillis() + "";""
                    + "" DELETE FROM "" + SourceStats.TABLE_NAME + "";""
                    + "" INSERT INTO "" + SourceStats.TABLE_NAME  + "" ""
                            + ""SELECT "" + ClickLog.corpus + "","" + ""COUNT(*) FROM ""
                            + ClickLog.TABLE_NAME + "" GROUP BY "" + ClickLog.corpus.name() + "";""
                    + "" END"");

            // trigger for deleting clicks about a shortcut once that shortcut has been
            // deleted
            db.execSQL(""CREATE TRIGGER "" + SHORTCUTS_DELETE_TRIGGER + "" AFTER DELETE ON ""
                    + Shortcuts.TABLE_NAME
                    + "" BEGIN""
                    + "" DELETE FROM "" + ClickLog.TABLE_NAME + "" WHERE ""
                            + ClickLog.intent_key.name()
                            + "" = OLD."" + Shortcuts.intent_key.name() + "";""
                    + "" END"");

            // trigger for updating click log entries when a shortcut changes its intent_key
            db.execSQL(""CREATE TRIGGER "" + SHORTCUTS_UPDATE_INTENT_KEY_TRIGGER
                    + "" AFTER UPDATE ON "" + Shortcuts.TABLE_NAME
                    + "" WHEN NEW."" + Shortcuts.intent_key.name()
                            + "" != OLD."" + Shortcuts.intent_key.name()
                    + "" BEGIN""
                    + "" UPDATE "" + ClickLog.TABLE_NAME + "" SET ""
                            + ClickLog.intent_key.name() + "" = NEW."" + Shortcuts.intent_key.name()
                            + "" WHERE ""
                            + ClickLog.intent_key.name() + "" = OLD."" + Shortcuts.intent_key.name()
                            + "";""
                    + "" END"");

            db.execSQL(""CREATE TABLE "" + SourceStats.TABLE_NAME + "" ( "" +
                    SourceStats.corpus.name() + "" TEXT NOT NULL COLLATE UNICODE PRIMARY KEY, "" +
                    SourceStats.total_clicks + "" INTEGER);""
                    );
        }
    }
}
",True,60,4,19,3,18,2,18,L5
14,com.android.quicksearchbox.QsbApplication.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.google.GoogleSource;
import com.android.quicksearchbox.google.GoogleSuggestClient;
import com.android.quicksearchbox.google.SearchBaseUrlHelper;
import com.android.quicksearchbox.preferences.PreferenceControllerFactory;
import com.android.quicksearchbox.ui.DefaultSuggestionViewFactory;
import com.android.quicksearchbox.ui.SuggestionViewFactory;
import com.android.quicksearchbox.util.Factory;
import com.android.quicksearchbox.util.HttpHelper;
import com.android.quicksearchbox.util.JavaNetHttpHelper;
import com.android.quicksearchbox.util.NamedTaskExecutor;
import com.android.quicksearchbox.util.PerNameExecutor;
import com.android.quicksearchbox.util.PriorityThreadFactory;
import com.android.quicksearchbox.util.SingleThreadNamedTaskExecutor;
import com.google.common.util.concurrent.NamingThreadFactory;

import android.app.Activity;
import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.os.Process;
import android.view.ContextThemeWrapper;

import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;

public class QsbApplication {
    private final Context mContext;

    private int mVersionCode;
    private Handler mUiThreadHandler;
    private Config mConfig;
    private SearchSettings mSettings;
    private Sources mSources;
    private Corpora mCorpora;
    private CorpusRanker mCorpusRanker;
    private ShortcutRepository mShortcutRepository;
    private ShortcutRefresher mShortcutRefresher;
    private NamedTaskExecutor mSourceTaskExecutor;
    private ThreadFactory mQueryThreadFactory;
    private SuggestionsProvider mSuggestionsProvider;
    private SuggestionViewFactory mSuggestionViewFactory;
    private GoogleSource mGoogleSource;
    private VoiceSearch mVoiceSearch;
    private Logger mLogger;
    private SuggestionFormatter mSuggestionFormatter;
    private TextAppearanceFactory mTextAppearanceFactory;
    private NamedTaskExecutor mIconLoaderExecutor;
    private HttpHelper mHttpHelper;
    private SearchBaseUrlHelper mSearchBaseUrlHelper;

    public QsbApplication(Context context) {
        // the application context does not use the theme from the <application> tag
        mContext = new ContextThemeWrapper(context, R.style.Theme_QuickSearchBox);
    }

    public static boolean isFroyoOrLater() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
    }

    public static boolean isHoneycombOrLater() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB;
    }

    public static QsbApplication get(Context context) {
        return ((QsbApplicationWrapper) context.getApplicationContext()).getApp();
    }

    protected Context getContext() {
        return mContext;
    }

    public int getVersionCode() {
        if (mVersionCode == 0) {
            try {
                PackageManager pm = getContext().getPackageManager();
                PackageInfo pkgInfo = pm.getPackageInfo(getContext().getPackageName(), 0);
                mVersionCode = pkgInfo.versionCode;
            } catch (PackageManager.NameNotFoundException ex) {
                // The current package should always exist, how else could we
                // run code from it?
                throw new RuntimeException(ex);
            }
        }
        return mVersionCode;
    }

    protected void checkThread() {
        if (Looper.myLooper() != Looper.getMainLooper()) {
            throw new IllegalStateException(""Accessed Application object from thread ""
                    + Thread.currentThread().getName());
        }
    }

    protected void close() {
        checkThread();
        if (mConfig != null) {
            mConfig.close();
            mConfig = null;
        }
        if (mShortcutRepository != null) {
            mShortcutRepository.close();
            mShortcutRepository = null;
        }
        if (mSourceTaskExecutor != null) {
            mSourceTaskExecutor.close();
            mSourceTaskExecutor = null;
        }
        if (mSuggestionsProvider != null) {
            mSuggestionsProvider.close();
            mSuggestionsProvider = null;
        }
    }

    public synchronized Handler getMainThreadHandler() {
        if (mUiThreadHandler == null) {
            mUiThreadHandler = new Handler(Looper.getMainLooper());
        }
        return mUiThreadHandler;
    }

    public void runOnUiThread(Runnable action) {
        getMainThreadHandler().post(action);
    }

    public synchronized NamedTaskExecutor getIconLoaderExecutor() {
        if (mIconLoaderExecutor == null) {
            mIconLoaderExecutor = createIconLoaderExecutor();
        }
        return mIconLoaderExecutor;
    }

    protected NamedTaskExecutor createIconLoaderExecutor() {
        ThreadFactory iconThreadFactory = new PriorityThreadFactory(
                    Process.THREAD_PRIORITY_BACKGROUND);
        return new PerNameExecutor(SingleThreadNamedTaskExecutor.factory(iconThreadFactory));
    }

    /**
     * Indicates that construction of the QSB UI is now complete.
     */
    public void onStartupComplete() {
    }

    /**
     * Gets the QSB configuration object.
     * May be called from any thread.
     */
    public synchronized Config getConfig() {
        if (mConfig == null) {
            mConfig = createConfig();
        }
        return mConfig;
    }

    protected Config createConfig() {
        return new Config(getContext());
    }

    public synchronized SearchSettings getSettings() {
        if (mSettings == null) {
            mSettings = createSettings();
            mSettings.upgradeSettingsIfNeeded();
        }
        return mSettings;
    }

    protected SearchSettings createSettings() {
        return new SearchSettingsImpl(getContext(), getConfig());
    }

    /**
     * Gets all corpora.
     *
     * May only be called from the main thread.
     */
    public Corpora getCorpora() {
        checkThread();
        if (mCorpora == null) {
            mCorpora = createCorpora(getSources());
        }
        return mCorpora;
    }

    protected Corpora createCorpora(Sources sources) {
        SearchableCorpora corpora = new SearchableCorpora(getContext(), getSettings(), sources,
                createCorpusFactory());
        corpora.update();
        return corpora;
    }

    /**
     * Updates the corpora, if they are loaded.
     * May only be called from the main thread.
     */
    public void updateCorpora() {
        checkThread();
        if (mCorpora != null) {
            mCorpora.update();
        }
    }

    protected Sources getSources() {
        checkThread();
        if (mSources == null) {
            mSources = createSources();
        }
        return mSources;
    }

    protected Sources createSources() {
        return new SearchableSources(getContext(), getMainThreadHandler(),
                getIconLoaderExecutor(), getConfig());
    }

    protected CorpusFactory createCorpusFactory() {
        int numWebCorpusThreads = getConfig().getNumWebCorpusThreads();
        return new SearchableCorpusFactory(getContext(), getConfig(), getSettings(),
                createExecutorFactory(numWebCorpusThreads));
    }

    protected Factory<Executor> createExecutorFactory(final int numThreads) {
        final ThreadFactory threadFactory = getQueryThreadFactory();
        return new Factory<Executor>() {
            public Executor create() {
                return Executors.newFixedThreadPool(numThreads, threadFactory);
            }
        };
    }

    /**
     * Gets the corpus ranker.
     * May only be called from the main thread.
     */
    public CorpusRanker getCorpusRanker() {
        checkThread();
        if (mCorpusRanker == null) {
            mCorpusRanker = createCorpusRanker();
        }
        return mCorpusRanker;
    }

    protected CorpusRanker createCorpusRanker() {
        return new DefaultCorpusRanker(getCorpora(), getShortcutRepository());
    }

    /**
     * Gets the shortcut repository.
     * May only be called from the main thread.
     */
    public ShortcutRepository getShortcutRepository() {
        checkThread();
        if (mShortcutRepository == null) {
            mShortcutRepository = createShortcutRepository();
        }
        return mShortcutRepository;
    }

    protected ShortcutRepository createShortcutRepository() {
        ThreadFactory logThreadFactory = new NamingThreadFactory(""ShortcutRepositoryWriter #%d"",
                new PriorityThreadFactory(Process.THREAD_PRIORITY_BACKGROUND));
        Executor logExecutor = Executors.newSingleThreadExecutor(logThreadFactory);
        return ShortcutRepositoryImplLog.create(getContext(), getConfig(), getCorpora(),
            getShortcutRefresher(), getMainThreadHandler(), logExecutor);
    }

    /**
     * Gets the shortcut refresher.
     * May only be called from the main thread.
     */
    public ShortcutRefresher getShortcutRefresher() {
        checkThread();
        if (mShortcutRefresher == null) {
            mShortcutRefresher = createShortcutRefresher();
        }
        return mShortcutRefresher;
    }

    protected ShortcutRefresher createShortcutRefresher() {
        // For now, ShortcutRefresher gets its own SourceTaskExecutor
        return new SourceShortcutRefresher(createSourceTaskExecutor());
    }

    /**
     * Gets the source task executor.
     * May only be called from the main thread.
     */
    public NamedTaskExecutor getSourceTaskExecutor() {
        checkThread();
        if (mSourceTaskExecutor == null) {
            mSourceTaskExecutor = createSourceTaskExecutor();
        }
        return mSourceTaskExecutor;
    }

    protected NamedTaskExecutor createSourceTaskExecutor() {
        ThreadFactory queryThreadFactory = getQueryThreadFactory();
        return new PerNameExecutor(SingleThreadNamedTaskExecutor.factory(queryThreadFactory));
    }

    /**
     * Gets the query thread factory.
     * May only be called from the main thread.
     */
    protected ThreadFactory getQueryThreadFactory() {
        checkThread();
        if (mQueryThreadFactory == null) {
            mQueryThreadFactory = createQueryThreadFactory();
        }
        return mQueryThreadFactory;
    }

    protected ThreadFactory createQueryThreadFactory() {
        String nameFormat = ""QSB #%d"";
        int priority = getConfig().getQueryThreadPriority();
        return new NamingThreadFactory(nameFormat,
                new PriorityThreadFactory(priority));
    }

    /**
     * Gets the suggestion provider.
     *
     * May only be called from the main thread.
     */
    protected SuggestionsProvider getSuggestionsProvider() {
        checkThread();
        if (mSuggestionsProvider == null) {
            mSuggestionsProvider = createSuggestionsProvider();
        }
        return mSuggestionsProvider;
    }

    protected SuggestionsProvider createSuggestionsProvider() {
        return new SuggestionsProviderImpl(getConfig(),
              getSourceTaskExecutor(),
              getMainThreadHandler(),
              getLogger());
    }

    /**
     * Gets the default suggestion view factory.
     * May only be called from the main thread.
     */
    public SuggestionViewFactory getSuggestionViewFactory() {
        checkThread();
        if (mSuggestionViewFactory == null) {
            mSuggestionViewFactory = createSuggestionViewFactory();
        }
        return mSuggestionViewFactory;
    }

    protected SuggestionViewFactory createSuggestionViewFactory() {
        return new DefaultSuggestionViewFactory(getContext());
    }

    public Promoter createBlendingPromoter() {
        return new ShortcutPromoter(getConfig(),
                new RankAwarePromoter(getConfig(), null, null), null);
    }

    public Promoter createSingleCorpusPromoter(Corpus corpus) {
        return new SingleCorpusPromoter(corpus, Integer.MAX_VALUE);
    }

    public Promoter createSingleCorpusResultsPromoter(Corpus corpus) {
        return new SingleCorpusResultsPromoter(corpus, Integer.MAX_VALUE);
    }

    public Promoter createWebPromoter() {
        return new WebPromoter(getConfig().getMaxShortcutsPerWebSource());
    }

    public Promoter createResultsPromoter() {
        SuggestionFilter resultFilter = new ResultFilter();
        return new ShortcutPromoter(getConfig(), null, resultFilter);
    }

    /**
     * Gets the Google source.
     * May only be called from the main thread.
     */
    public GoogleSource getGoogleSource() {
        checkThread();
        if (mGoogleSource == null) {
            mGoogleSource = createGoogleSource();
        }
        return mGoogleSource;
    }

    protected GoogleSource createGoogleSource() {
        return new GoogleSuggestClient(getContext(), getMainThreadHandler(),
                getIconLoaderExecutor(), getConfig());
    }

    /**
     * Gets Voice Search utilities.
     */
    public VoiceSearch getVoiceSearch() {
        checkThread();
        if (mVoiceSearch == null) {
            mVoiceSearch = createVoiceSearch();
        }
        return mVoiceSearch;
    }

    protected VoiceSearch createVoiceSearch() {
        return new VoiceSearch(getContext());
    }

    /**
     * Gets the event logger.
     * May only be called from the main thread.
     */
    public Logger getLogger() {
        checkThread();
        if (mLogger == null) {
            mLogger = createLogger();
        }
        return mLogger;
    }

    protected Logger createLogger() {
        return new EventLogLogger(getContext(), getConfig());
    }

    public SuggestionFormatter getSuggestionFormatter() {
        if (mSuggestionFormatter == null) {
            mSuggestionFormatter = createSuggestionFormatter();
        }
        return mSuggestionFormatter;
    }

    protected SuggestionFormatter createSuggestionFormatter() {
        return new LevenshteinSuggestionFormatter(getTextAppearanceFactory());
    }

    public TextAppearanceFactory getTextAppearanceFactory() {
        if (mTextAppearanceFactory == null) {
            mTextAppearanceFactory = createTextAppearanceFactory();
        }
        return mTextAppearanceFactory;
    }

    protected TextAppearanceFactory createTextAppearanceFactory() {
        return new TextAppearanceFactory(getContext());
    }

    public PreferenceControllerFactory createPreferenceControllerFactory(Activity activity) {
        return new PreferenceControllerFactory(getSettings(), activity);
    }

    public synchronized HttpHelper getHttpHelper() {
        if (mHttpHelper == null) {
            mHttpHelper = createHttpHelper();
        }
        return mHttpHelper;
    }

    protected HttpHelper createHttpHelper() {
        return new JavaNetHttpHelper(
                new JavaNetHttpHelper.PassThroughRewriter(),
                getConfig().getUserAgent());
    }

    public synchronized SearchBaseUrlHelper getSearchBaseUrlHelper() {
        if (mSearchBaseUrlHelper == null) {
            mSearchBaseUrlHelper = createSearchBaseUrlHelper();
        }

        return mSearchBaseUrlHelper;
    }

    protected SearchBaseUrlHelper createSearchBaseUrlHelper() {
        // This cast to ""SearchSettingsImpl"" is somewhat ugly.
        return new SearchBaseUrlHelper(getContext(), getHttpHelper(),
                getSettings(), ((SearchSettingsImpl)getSettings()).getSearchPreferences());
    }

    public Help getHelp() {
        // No point caching this, it's super cheap.
        return new Help(getContext(), getConfig());
    }
}
",False,132,2,11,5,47,19,47,L8
15,com.android.quicksearchbox.QsbApplicationWrapper.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.app.Application;

public class QsbApplicationWrapper extends Application {

    private QsbApplication mApp;

    @Override
    public void onTerminate() {
        synchronized (this) {
            if (mApp != null) {
                mApp.close();
            }
        }
        super.onTerminate();
    }

    public synchronized QsbApplication getApp() {
        if (mApp == null) {
            mApp = createQsbApplication();
        }
        return mApp;
    }

    protected QsbApplication createQsbApplication() {
        return new QsbApplication(this);
    }

}
",False,118,0,0,6,46,1,1,L8
16,com.android.quicksearchbox.SearchableSources.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.NamedTaskExecutor;

import android.app.SearchManager;
import android.app.SearchableInfo;
import android.content.ComponentName;
import android.content.Context;
import android.content.pm.PackageManager.NameNotFoundException;
import android.os.Handler;
import android.util.Log;

import java.util.Collection;
import java.util.HashMap;
import java.util.List;

/**
 * Maintains a list of search sources.
 */
public class SearchableSources implements Sources {

    // set to true to enable the more verbose debug logging for this file
    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SearchableSources"";

    private final Context mContext;
    private final SearchManager mSearchManager;
    private final Handler mUiThread;
    private final Config mConfig;

    // All suggestion sources, by name.
    private HashMap<String, Source> mSources;

    // The web search source to use.
    private Source mWebSearchSource;

    private final NamedTaskExecutor mIconLoaderExecutor;

    /**
     *
     * @param context Used for looking up source information etc.
     */
    public SearchableSources(Context context, Handler uiThread,
            NamedTaskExecutor iconLoader, Config config) {
        mContext = context;
        mSearchManager = (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
        mUiThread = uiThread;
        mIconLoaderExecutor = iconLoader;
        mConfig = config;
    }

    protected Context getContext() {
        return mContext;
    }

    protected Handler getUiThreadHandler() {
        return mUiThread;
    }

    protected SearchManager getSearchManager() {
        return mSearchManager;
    }

    protected NamedTaskExecutor getIconLoaderExecutor() {
        return mIconLoaderExecutor;
    }

    protected Config getConfig() {
        return mConfig;
    }

    public Collection<Source> getSources() {
        return mSources.values();
    }

    public Source getSource(String name) {
        return mSources.get(name);
    }

    public Source getWebSearchSource() {
        return mWebSearchSource;
    }

    /**
     * Updates the list of suggestion sources.
     */
    public void update() {
        if (DBG) Log.d(TAG, ""update()"");
        mSources = new HashMap<String,Source>();

        addSearchableSources();

        addInternalSources();

        mWebSearchSource = createWebSearchSource();
        if (mWebSearchSource != null) {
            addSource(mWebSearchSource);
        }
    }

    protected void addInternalSources() {
    }

    private void addSearchableSources() {
        List<SearchableInfo> searchables = mSearchManager.getSearchablesInGlobalSearch();
        if (searchables == null) {
            Log.e(TAG, ""getSearchablesInGlobalSearch() returned null"");
            return;
        }
        for (SearchableInfo searchable : searchables) {
            SearchableSource source = createSearchableSource(searchable);
            if (source != null) {
                if (DBG) Log.d(TAG, ""Created source "" + source);
                addSource(source);
            }
        }
    }

    protected void addSource(Source source) {
        mSources.put(source.getName(), source);
    }

    protected Source createWebSearchSource() {
        return QsbApplication.get(getContext()).getGoogleSource();
    }

    protected SearchableSource createSearchableSource(SearchableInfo searchable) {
        if (searchable == null) return null;
        try {
            return new SearchableSource(mContext, searchable, getUiThreadHandler(),
                    getIconLoaderExecutor());
        } catch (NameNotFoundException ex) {
            Log.e(TAG, ""Source not found: "" + ex);
            return null;
        }
    }

    public Source createSourceFor(ComponentName component) {
        SearchableInfo info = mSearchManager.getSearchableInfo(component);
        SearchableSource source = createSearchableSource(info);
        if (DBG) Log.d(TAG, ""SearchableSource for "" + component + "": "" + source);
        return source;
    }
}
",True,118,0,0,6,52,1,8,L8
17,com.android.quicksearchbox.ShortcutRepository.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.Consumer;

import java.util.Collection;
import java.util.Map;

/**
 * Holds information about shortcuts (results the user has clicked on before), and returns
 * appropriate shortcuts for a given query.
 */
public interface ShortcutRepository {

    /**
     * Checks whether there is any stored history.
     *
     * @param consumer Consumer that the result will be passed to.
     *        The value passed to the consumer will always be non-null.
     *        The consumer will be called on an unspecified thread, and will always
     *        get called eventually.
     */
    void hasHistory(Consumer<Boolean> consumer);

    /**
     * Removes a single suggestion from the stored history.
     */
    void removeFromHistory(SuggestionCursor suggestions, int position);

    /**
     * Clears all shortcut history.
     */
    void clearHistory();

    /**
     * Closes any database connections etc held by this object.
     */
    void close();

    /**
     * Reports a click on a suggestion.
     * Must be called on the UI thread.
     */
    void reportClick(SuggestionCursor suggestions, int position);

    /**
     * Gets shortcuts for a query.
     *
     * @param query The query. May be empty.
     * @param allowedCorpora The corpora to get shortcuts for.
     * @param allowWebSearchShortcuts Whether to include web search shortcuts.
     * @param consumer Consumer that the shortcuts cursor will be passed to.
     *        The shortcut cursor passed to the consumer may be null if there are no shortcuts.
     *        If non-null, and the consumer returns {@code true}, the consumer must ensure that
     *        the shortcut cursor will get closed eventually.
     *        The consumer will be called on an unspecified thread, and will always
     *        get called eventually.
     */
    void getShortcutsForQuery(String query, Collection<Corpus> allowedCorpora,
            boolean allowWebSearchShortcuts,
            Consumer<ShortcutCursor> consumer);

    /**
     * Updates a shortcut in the repository after it's been refreshed.
     *
     * @param source The source of the shortcut that's been refreshed
     * @param shortcutId The ID of the shortcut that's been refershed
     * @param refreshed The refreshed shortcut suggestion.
     */
    void updateShortcut(Source source, String shortcutId, SuggestionCursor refreshed);

    /**
     * Gets scores for all corpora in the click log.
     *
     * @param consumer Consumer that the result will be passed to.
     *        The result is a map of corpus name to score. A higher score means that the corpus
     *        is more important.
     *        The value passed to the consumer may be non-null.
     *        The consumer will be called on an unspecified thread, and will always
     *        get called eventually.
     */
    void getCorpusScores(Consumer<Map<String,Integer>> consumer);
}
",False,58,4,20,3,11,9,5,L4
18,com.android.quicksearchbox.SearchSettings.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Intent;
import android.view.Menu;

/**
 * Interface for search settings.
 *
 * NOTE: Currently, this is not used very widely, in most instances
 * implementers of this interface are passed around by class name.
 * Should this be deprecated ?
 */
public interface SearchSettings {

    public void upgradeSettingsIfNeeded();

    public Intent getSearchableItemsIntent();

    public boolean isCorpusEnabled(Corpus corpus);

    /**
     * Informs our listeners about the updated settings data.
     */
    public void broadcastSettingsChanged();

    public void addMenuItems(Menu menu, boolean showDisabled);

    public int getNextVoiceSearchHintIndex(int size);

    public void resetVoiceSearchHintFirstSeenTime();

    public boolean haveVoiceSearchHintsExpired(int currentVoiceSearchVersion);

    public Intent getSearchSettingsIntent();

    public boolean allowWebSearchShortcuts();

    /**
     * Determines whether google.com should be used as the base path
     * for all searches (as opposed to using its country specific variants).
     */
    public boolean shouldUseGoogleCom();

    public void setUseGoogleCom(boolean useGoogleCom);

    public long getSearchBaseDomainApplyTime();

    public String getSearchBaseDomain();

    public void setSearchBaseDomain(String searchBaseUrl);
}
",False,51,4,17,5,4,12,1,L3
19,com.android.quicksearchbox.PackageIconLoader.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.CachedLater;
import com.android.quicksearchbox.util.NamedTask;
import com.android.quicksearchbox.util.NamedTaskExecutor;
import com.android.quicksearchbox.util.Now;
import com.android.quicksearchbox.util.NowOrLater;
import com.android.quicksearchbox.util.Util;

import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Handler;
import android.text.TextUtils;
import android.util.Log;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;

/**
 * Loads icons from other packages.
 *
 * Code partly stolen from {@link ContentResolver} and android.app.SuggestionsAdapter.
  */
public class PackageIconLoader implements IconLoader {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.PackageIconLoader"";

    private final Context mContext;

    private final String mPackageName;

    private Context mPackageContext;

    private final Handler mUiThread;

    private final NamedTaskExecutor mIconLoaderExecutor;

    /**
     * Creates a new icon loader.
     *
     * @param context The QSB application context.
     * @param packageName The name of the package from which the icons will be loaded.
     *        Resource IDs without an explicit package will be resolved against the package
     *        of this context.
     */
    public PackageIconLoader(Context context, String packageName, Handler uiThread,
            NamedTaskExecutor iconLoaderExecutor) {
        mContext = context;
        mPackageName = packageName;
        mUiThread = uiThread;
        mIconLoaderExecutor = iconLoaderExecutor;
    }

    private boolean ensurePackageContext() {
        if (mPackageContext == null) {
            try {
                mPackageContext = mContext.createPackageContext(mPackageName,
                        Context.CONTEXT_RESTRICTED);
            } catch (PackageManager.NameNotFoundException ex) {
                // This should only happen if the app has just be uninstalled
                Log.e(TAG, ""Application not found "" + mPackageName);
                return false;
            }
        }
        return true;
    }

    public NowOrLater<Drawable> getIcon(final String drawableId) {
        if (DBG) Log.d(TAG, ""getIcon("" + drawableId + "")"");
        if (TextUtils.isEmpty(drawableId) || ""0"".equals(drawableId)) {
            return new Now<Drawable>(null);
        }
        if (!ensurePackageContext()) {
            return new Now<Drawable>(null);
        }
        NowOrLater<Drawable> drawable;
        try {
            // First, see if it's just an integer
            int resourceId = Integer.parseInt(drawableId);
            // If so, find it by resource ID
            Drawable icon = mPackageContext.getResources().getDrawable(resourceId);
            drawable = new Now<Drawable>(icon);
        } catch (NumberFormatException nfe) {
            // It's not an integer, use it as a URI
            Uri uri = Uri.parse(drawableId);
            if (ContentResolver.SCHEME_ANDROID_RESOURCE.equals(uri.getScheme())) {
                // load all resources synchronously, to reduce UI flickering
                drawable = new Now<Drawable>(getDrawable(uri));
            } else {
                drawable = new IconLaterTask(uri);
            }
        } catch (Resources.NotFoundException nfe) {
            // It was an integer, but it couldn't be found, bail out
            Log.w(TAG, ""Icon resource not found: "" + drawableId);
            drawable = new Now<Drawable>(null);
        }
        return drawable;
    }

    public Uri getIconUri(String drawableId) {
        if (TextUtils.isEmpty(drawableId) || ""0"".equals(drawableId)) {
            return null;
        }
        if (!ensurePackageContext()) return null;
        try {
            int resourceId = Integer.parseInt(drawableId);
            return Util.getResourceUri(mPackageContext, resourceId);
        } catch (NumberFormatException nfe) {
            return Uri.parse(drawableId);
        }
    }

    /**
     * Gets a drawable by URI.
     *
     * @return A drawable, or {@code null} if the drawable could not be loaded.
     */
    private Drawable getDrawable(Uri uri) {
        try {
            String scheme = uri.getScheme();
            if (ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme)) {
                // Load drawables through Resources, to get the source density information
                OpenResourceIdResult r = getResourceId(uri);
                try {
                    return r.r.getDrawable(r.id);
                } catch (Resources.NotFoundException ex) {
                    throw new FileNotFoundException(""Resource does not exist: "" + uri);
                }
            } else {
                // Let the ContentResolver handle content and file URIs.
                InputStream stream = mPackageContext.getContentResolver().openInputStream(uri);
                if (stream == null) {
                    throw new FileNotFoundException(""Failed to open "" + uri);
                }
                try {
                    return Drawable.createFromStream(stream, null);
                } finally {
                    try {
                        stream.close();
                    } catch (IOException ex) {
                        Log.e(TAG, ""Error closing icon stream for "" + uri, ex);
                    }
                }
            }
        } catch (FileNotFoundException fnfe) {
            Log.w(TAG, ""Icon not found: "" + uri + "", "" + fnfe.getMessage());
            return null;
        }
    }

    /**
     * A resource identified by the {@link Resources} that contains it, and a resource id.
     */
    private class OpenResourceIdResult {
        public Resources r;
        public int id;
    }

    /**
     * Resolves an android.resource URI to a {@link Resources} and a resource id.
     */
    private OpenResourceIdResult getResourceId(Uri uri) throws FileNotFoundException {
        String authority = uri.getAuthority();
        Resources r;
        if (TextUtils.isEmpty(authority)) {
            throw new FileNotFoundException(""No authority: "" + uri);
        } else {
            try {
                r = mPackageContext.getPackageManager().getResourcesForApplication(authority);
            } catch (NameNotFoundException ex) {
                throw new FileNotFoundException(""Failed to get resources: "" + ex);
            }
        }
        List<String> path = uri.getPathSegments();
        if (path == null) {
            throw new FileNotFoundException(""No path: "" + uri);
        }
        int len = path.size();
        int id;
        if (len == 1) {
            try {
                id = Integer.parseInt(path.get(0));
            } catch (NumberFormatException e) {
                throw new FileNotFoundException(""Single path segment is not a resource ID: "" + uri);
            }
        } else if (len == 2) {
            id = r.getIdentifier(path.get(1), path.get(0), authority);
        } else {
            throw new FileNotFoundException(""More than two path segments: "" + uri);
        }
        if (id == 0) {
            throw new FileNotFoundException(""No resource found for: "" + uri);
        }
        OpenResourceIdResult res = new OpenResourceIdResult();
        res.r = r;
        res.id = id;
        return res;
    }

    private class IconLaterTask extends CachedLater<Drawable> implements NamedTask {
        private final Uri mUri;

        public IconLaterTask(Uri iconUri) {
            mUri = iconUri;
        }

        @Override
        protected void create() {
            mIconLoaderExecutor.execute(this);
        }

        @Override
        public void run() {
            final Drawable icon = getIcon();
            mUiThread.post(new Runnable(){
                public void run() {
                    store(icon);
                }});
        }

        @Override
        public String getName() {
            return mPackageName;
        }

        private Drawable getIcon() {
            try {
                return getDrawable(mUri);
            } catch (Throwable t) {
                // we're making a call into another package, which could throw any exception.
                // Make sure it doesn't crash QSB
                Log.e(TAG, ""Failed to load icon "" + mUri, t);
                return null;
            }
        }
    }
}
",True,42,5,17,2,7,2,7,L2
20,com.android.quicksearchbox.SearchableCorpusFactory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.Factory;

import android.content.Context;
import android.util.Log;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.concurrent.Executor;

/**
 * Creates corpora.
 */
public class SearchableCorpusFactory implements CorpusFactory {

    private static final String TAG = ""QSB.SearchableCorpusFactory"";

    private final Context mContext;

    private final Config mConfig;

    private final SearchSettings mSettings;

    private final Factory<Executor> mWebCorpusExecutorFactory;

    public SearchableCorpusFactory(Context context, Config config, SearchSettings settings,
            Factory<Executor> webCorpusExecutorFactory) {
        mContext = context;
        mConfig = config;
        mSettings = settings;
        mWebCorpusExecutorFactory = webCorpusExecutorFactory;
    }

    public Collection<Corpus> createCorpora(Sources sources) {
        ArrayList<Corpus> corpora = new ArrayList<Corpus>();
        addSpecialCorpora(corpora, sources);
        addSingleSourceCorpora(corpora, sources);
        return corpora;
    }

    protected Context getContext() {
        return mContext;
    }

    protected Config getConfig() {
        return mConfig;
    }

    protected Executor createWebCorpusExecutor() {
        return mWebCorpusExecutorFactory.create();
    }

    /**
     * Adds any corpora that are not simple single source corpora.
     *
     * @param corpora List to add corpora to.
     * @param sources All available sources.
     */
    protected void addSpecialCorpora(ArrayList<Corpus> corpora, Sources sources) {
        addCorpus(corpora, createWebCorpus(sources));
        addCorpus(corpora, createAppsCorpus(sources));
    }

    /**
     * Adds corpora for all sources that are not already used by a corpus.
     *
     * @param corpora List to add the new corpora to. Corpora will not be created for the sources
     *        used by corpora already in this list.
     * @param sources Sources to create corpora for.
     */
    protected void addSingleSourceCorpora(ArrayList<Corpus> corpora, Sources sources) {
        // Set of all sources that are already used
        HashSet<Source> claimedSources = new HashSet<Source>();
        for (Corpus specialCorpus : corpora) {
            claimedSources.addAll(specialCorpus.getSources());
        }

        // Creates corpora for all unclaimed sources
        for (Source source : sources.getSources()) {
            if (!claimedSources.contains(source)) {
                addCorpus(corpora, createSingleSourceCorpus(source));
            }
        }
    }

    private void addCorpus(ArrayList<Corpus> corpora, Corpus corpus) {
        if (corpus != null) corpora.add(corpus);
    }

    protected Corpus createWebCorpus(Sources sources) {
        Source webSource = getWebSource(sources);
        if (webSource != null && !webSource.canRead()) {
            Log.w(TAG, ""Can't read web source "" + webSource.getName());
            webSource = null;
        }
        Source browserSource = getBrowserSource(sources);
        if (browserSource != null && !browserSource.canRead()) {
            Log.w(TAG, ""Can't read browser source "" + browserSource.getName());
            browserSource = null;
        }
        Executor executor = createWebCorpusExecutor();
        return new WebCorpus(mContext, mConfig, mSettings, executor, webSource, browserSource);
    }

    protected Corpus createAppsCorpus(Sources sources) {
        Source appsSource = getAppsSource(sources);
        return new AppsCorpus(mContext, mConfig, appsSource);
    }

    protected Corpus createSingleSourceCorpus(Source source) {
        if (!source.canRead()) return null;
        return new SingleSourceCorpus(mContext, mConfig, source);
    }

    protected Source getWebSource(Sources sources) {
        return sources.getWebSearchSource();
    }

    protected Source getBrowserSource(Sources sources) {
        String name = getContext().getString(R.string.browser_search_component);
        return sources.getSource(name);
    }

    protected Source getAppsSource(Sources sources) {
        String name = getContext().getString(R.string.installed_apps_component);
        return sources.getSource(name);
    }

}
",False,118,0,0,8,43,1,11,L8
21,com.android.quicksearchbox.SearchableCorpora.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Context;
import android.database.DataSetObservable;
import android.database.DataSetObserver;
import android.text.TextUtils;
import android.util.Log;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

/**
 * Maintains the list of all corpora.
 */
public class SearchableCorpora implements Corpora {

    // set to true to enable the more verbose debug logging for this file
    private static final boolean DBG = false;
    private static final String TAG = ""QSB.DefaultCorpora"";

    private final DataSetObservable mDataSetObservable = new DataSetObservable();

    private final Context mContext;
    private final SearchSettings mSettings;
    private final CorpusFactory mCorpusFactory;

    private Sources mSources;
    // Maps corpus names to corpora
    private HashMap<String,Corpus> mCorporaByName;
    // Maps sources to the corpus that contains them
    private HashMap<Source,Corpus> mCorporaBySource;
    // Enabled corpora
    private List<Corpus> mEnabledCorpora;
    // Web corpus
    private Corpus mWebCorpus;

    /**
     *
     * @param context Used for looking up source information etc.
     */
    public SearchableCorpora(Context context, SearchSettings settings, Sources sources,
            CorpusFactory corpusFactory) {
        mContext = context;
        mSettings = settings;
        mCorpusFactory = corpusFactory;
        mSources = sources;
    }

    protected Context getContext() {
        return mContext;
    }

    public Collection<Corpus> getAllCorpora() {
        return Collections.unmodifiableCollection(mCorporaByName.values());
    }

    public List<Corpus> getEnabledCorpora() {
        return mEnabledCorpora;
    }

    public List<Corpus> getCorporaInAll() {
        ArrayList<Corpus> corpora = new ArrayList<Corpus>(mEnabledCorpora.size());
        for (Corpus corpus : mEnabledCorpora) {
            if (corpus.includeInAll()) {
                corpora.add(corpus);
            }
        }
        return corpora;
    }

    public Corpus getCorpus(String name) {
        return mCorporaByName.get(name);
    }

    public Corpus getWebCorpus() {
        return mWebCorpus;
    }

    public Corpus getCorpusForSource(Source source) {
        return mCorporaBySource.get(source);
    }

    public Source getSource(String name) {
        if (TextUtils.isEmpty(name)) {
            Log.w(TAG, ""Empty source name"");
            return null;
        }
        return mSources.getSource(name);
    }

    public void update() {
        mSources.update();

        Collection<Corpus> corpora = mCorpusFactory.createCorpora(mSources);

        mCorporaByName = new HashMap<String,Corpus>(corpora.size());
        mCorporaBySource = new HashMap<Source,Corpus>(corpora.size());
        mEnabledCorpora = new ArrayList<Corpus>(corpora.size());
        mWebCorpus = null;

        for (Corpus corpus : corpora) {
            mCorporaByName.put(corpus.getName(), corpus);
            for (Source source : corpus.getSources()) {
                mCorporaBySource.put(source, corpus);
            }
            if (mSettings.isCorpusEnabled(corpus)) {
                mEnabledCorpora.add(corpus);
            }
            if (corpus.isWebCorpus()) {
                if (mWebCorpus != null) {
                    Log.w(TAG, ""Multiple web corpora: "" + mWebCorpus + "", "" + corpus);
                }
                mWebCorpus = corpus;
            }
        }

        if (DBG) Log.d(TAG, ""Updated corpora: "" + mCorporaBySource.values());

        mEnabledCorpora = Collections.unmodifiableList(mEnabledCorpora);

        notifyDataSetChanged();
    }

    public void registerDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.registerObserver(observer);
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.unregisterObserver(observer);
    }

    protected void notifyDataSetChanged() {
        mDataSetObservable.notifyChanged();
    }
}
",False,50,4,19,4,7,2,7,L3
22,com.android.quicksearchbox.CursorBackedSuggestionCursor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.app.SearchManager;
import android.content.ComponentName;
import android.content.Intent;
import android.database.Cursor;
import android.database.DataSetObserver;
import android.net.Uri;
import android.util.Log;

public abstract class CursorBackedSuggestionCursor implements SuggestionCursor {

    private static final boolean DBG = false;
    protected static final String TAG = ""QSB.CursorBackedSuggestionCursor"";

    public static final String SUGGEST_COLUMN_LOG_TYPE = ""suggest_log_type"";

    private final String mUserQuery;

    /** The suggestions, or {@code null} if the suggestions query failed. */
    protected final Cursor mCursor;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_FORMAT} in @{link mCursor}. */
    private final int mFormatCol;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_TEXT_1} in @{link mCursor}. */
    private final int mText1Col;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_TEXT_2} in @{link mCursor}. */
    private final int mText2Col;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_TEXT_2_URL} in @{link mCursor}. */
    private final int mText2UrlCol;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_ICON_1} in @{link mCursor}. */
    private final int mIcon1Col;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_ICON_1} in @{link mCursor}. */
    private final int mIcon2Col;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING}
     * in @{link mCursor}.
     **/
    private final int mRefreshSpinnerCol;

    /** True if this result has been closed. */
    private boolean mClosed = false;

    public CursorBackedSuggestionCursor(String userQuery, Cursor cursor) {
        mUserQuery = userQuery;
        mCursor = cursor;
        mFormatCol = getColumnIndex(SearchManager.SUGGEST_COLUMN_FORMAT);
        mText1Col = getColumnIndex(SearchManager.SUGGEST_COLUMN_TEXT_1);
        mText2Col = getColumnIndex(SearchManager.SUGGEST_COLUMN_TEXT_2);
        mText2UrlCol = getColumnIndex(SearchManager.SUGGEST_COLUMN_TEXT_2_URL);
        mIcon1Col = getColumnIndex(SearchManager.SUGGEST_COLUMN_ICON_1);
        mIcon2Col = getColumnIndex(SearchManager.SUGGEST_COLUMN_ICON_2);
        mRefreshSpinnerCol = getColumnIndex(SearchManager.SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING);
    }

    public String getUserQuery() {
        return mUserQuery;
    }

    public abstract Source getSuggestionSource();

    public String getSuggestionLogType() {
        return getStringOrNull(SUGGEST_COLUMN_LOG_TYPE);
    }

    public void close() {
        if (DBG) Log.d(TAG, ""close()"");
        if (mClosed) {
            throw new IllegalStateException(""Double close()"");
        }
        mClosed = true;
        if (mCursor != null) {
            try {
                mCursor.close();
            } catch (RuntimeException ex) {
                // all operations on cross-process cursors can throw random exceptions
                Log.e(TAG, ""close() failed, "", ex);
            }
        }
    }

    @Override
    protected void finalize() {
        if (!mClosed) {
            Log.e(TAG, ""LEAK! Finalized without being closed: "" + toString());
        }
    }

    public int getCount() {
        if (mClosed) {
            throw new IllegalStateException(""getCount() after close()"");
        }
        if (mCursor == null) return 0;
        try {
            return mCursor.getCount();
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getCount() failed, "", ex);
            return 0;
        }
    }

    public void moveTo(int pos) {
        if (mClosed) {
            throw new IllegalStateException(""moveTo("" + pos + "") after close()"");
        }
        try {
            if (!mCursor.moveToPosition(pos)) {
                Log.e(TAG, ""moveToPosition("" + pos + "") failed, count="" + getCount());
            }
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""moveToPosition() failed, "", ex);
        }
    }

    public boolean moveToNext() {
        if (mClosed) {
            throw new IllegalStateException(""moveToNext() after close()"");
        }
        try {
            return mCursor.moveToNext();
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""moveToNext() failed, "", ex);
            return false;
        }
    }

    public int getPosition() {
        if (mClosed) {
            throw new IllegalStateException(""getPosition after close()"");
        }
        try {
            return mCursor.getPosition();
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getPosition() failed, "", ex);
            return -1;
        }
    }

    public String getShortcutId() {
        return getStringOrNull(SearchManager.SUGGEST_COLUMN_SHORTCUT_ID);
    }

    public String getSuggestionFormat() {
        return getStringOrNull(mFormatCol);
    }

    public String getSuggestionText1() {
        return getStringOrNull(mText1Col);
    }

    public String getSuggestionText2() {
        return getStringOrNull(mText2Col);
    }

    public String getSuggestionText2Url() {
        return getStringOrNull(mText2UrlCol);
    }

    public String getSuggestionIcon1() {
        return getStringOrNull(mIcon1Col);
    }

    public String getSuggestionIcon2() {
        return getStringOrNull(mIcon2Col);
    }

    public boolean isSpinnerWhileRefreshing() {
        return ""true"".equals(getStringOrNull(mRefreshSpinnerCol));
    }

    /**
     * Gets the intent action for the current suggestion.
     */
    public String getSuggestionIntentAction() {
        String action = getStringOrNull(SearchManager.SUGGEST_COLUMN_INTENT_ACTION);
        if (action != null) return action;
        return getSuggestionSource().getDefaultIntentAction();
    }

    public abstract ComponentName getSuggestionIntentComponent();

    /**
     * Gets the query for the current suggestion.
     */
    public String getSuggestionQuery() {
        return getStringOrNull(SearchManager.SUGGEST_COLUMN_QUERY);
    }

    public String getSuggestionIntentDataString() {
         // use specific data if supplied, or default data if supplied
         String data = getStringOrNull(SearchManager.SUGGEST_COLUMN_INTENT_DATA);
         if (data == null) {
             data = getSuggestionSource().getDefaultIntentData();
         }
         // then, if an ID was provided, append it.
         if (data != null) {
             String id = getStringOrNull(SearchManager.SUGGEST_COLUMN_INTENT_DATA_ID);
             if (id != null) {
                 data = data + ""/"" + Uri.encode(id);
             }
         }
         return data;
     }

    /**
     * Gets the intent extra data for the current suggestion.
     */
    public String getSuggestionIntentExtraData() {
        return getStringOrNull(SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA);
    }

    public boolean isWebSearchSuggestion() {
        return Intent.ACTION_WEB_SEARCH.equals(getSuggestionIntentAction());
    }

    /**
     * Gets the index of a column in {@link #mCursor} by name.
     *
     * @return The index, or {@code -1} if the column was not found.
     */
    protected int getColumnIndex(String colName) {
        if (mCursor == null) return -1;
        try {
            return mCursor.getColumnIndex(colName);
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getColumnIndex() failed, "", ex);
            return -1;
        }
    }

    /**
     * Gets the string value of a column in {@link #mCursor} by column index.
     *
     * @param col Column index.
     * @return The string value, or {@code null}.
     */
    protected String getStringOrNull(int col) {
        if (mCursor == null) return null;
        if (col == -1) {
            return null;
        }
        try {
            return mCursor.getString(col);
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getString() failed, "", ex);
            return null;
        }
    }

    /**
     * Gets the string value of a column in {@link #mCursor} by column name.
     *
     * @param colName Column name.
     * @return The string value, or {@code null}.
     */
    protected String getStringOrNull(String colName) {
        int col = getColumnIndex(colName);
        return getStringOrNull(col);
    }

    public void registerDataSetObserver(DataSetObserver observer) {
        // We don't watch Cursor-backed SuggestionCursors for changes
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
        // We don't watch Cursor-backed SuggestionCursors for changes
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + ""["" + mUserQuery + ""]"";
    }

}
",True,49,5,21,4,6,3,2,L2
23,com.android.quicksearchbox.SuggestionNonFormatter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * Basic SuggestionFormatter that does no formatting.
 */
public class SuggestionNonFormatter extends SuggestionFormatter {

    public SuggestionNonFormatter(TextAppearanceFactory spanFactory) {
        super(spanFactory);
    }

    @Override
    public CharSequence formatSuggestion(String query, String suggestion) {
        return suggestion;
    }

}
",False,3,0,0,1,2,0,2,L10
24,com.android.quicksearchbox.SingleCorpusResultsPromoter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

/**
 * Promotes non-web-search shortcuts and suggestions from a single corpus.
 */
public class SingleCorpusResultsPromoter extends SingleCorpusPromoter {

    public SingleCorpusResultsPromoter(Corpus corpus, int maxShortcuts) {
        super(corpus, maxShortcuts);
    }

    protected boolean accept(Suggestion s) {
        return !s.isWebSearchSuggestion() && super.accept(s);
    }

}
",False,57,4,19,4,9,1,3,L8
25,com.android.quicksearchbox.AbstractCorpus.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Context;


/**
 * Base class for corpus implementations.
 */
public abstract class AbstractCorpus implements Corpus {

    private final Context mContext;

    private final Config mConfig;

    public AbstractCorpus(Context context, Config config) {
        mContext = context;
        mConfig = config;
    }

    protected Context getContext() {
        return mContext;
    }

    public boolean isCorpusDefaultEnabled() {
        return mConfig.isCorpusEnabledByDefault(this);
    }

    public boolean isCorpusHidden() {
        return mConfig.isCorpusHidden(getName());
    }

    @Override
    public String toString() {
        return getName();
    }

    @Override
    public boolean equals(Object o) {
        if (o != null && getClass().equals(o.getClass())) {
            return getName().equals(((Corpus) o).getName());
        } else {
            return false;
        }
    }

    @Override
    public int hashCode() {
        return getName().hashCode();
    }

}
",True,49,6,19,4,4,4,3,L4
26,com.android.quicksearchbox.AbstractSuggestionWrapper.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import android.content.ComponentName;

/**
 * A Suggestion that delegates all calls to other suggestions.
 */
public abstract class AbstractSuggestionWrapper implements Suggestion {

    /**
     * Gets the current suggestion.
     */
    protected abstract Suggestion current();

    public String getShortcutId() {
        return current().getShortcutId();
    }

    public String getSuggestionFormat() {
        return current().getSuggestionFormat();
    }

    public String getSuggestionIcon1() {
        return current().getSuggestionIcon1();
    }

    public String getSuggestionIcon2() {
        return current().getSuggestionIcon2();
    }

    public String getSuggestionIntentAction() {
        return current().getSuggestionIntentAction();
    }

    public ComponentName getSuggestionIntentComponent() {
        return current().getSuggestionIntentComponent();
    }

    public String getSuggestionIntentDataString() {
        return current().getSuggestionIntentDataString();
    }

    public String getSuggestionIntentExtraData() {
        return current().getSuggestionIntentExtraData();
    }

    public String getSuggestionLogType() {
        return current().getSuggestionLogType();
    }

    public String getSuggestionQuery() {
        return current().getSuggestionQuery();
    }

    public Source getSuggestionSource() {
        return current().getSuggestionSource();
    }

    public String getSuggestionText1() {
        return current().getSuggestionText1();
    }

    public String getSuggestionText2() {
        return current().getSuggestionText2();
    }

    public String getSuggestionText2Url() {
        return current().getSuggestionText2Url();
    }

    public boolean isSpinnerWhileRefreshing() {
        return current().isSpinnerWhileRefreshing();
    }

    public boolean isSuggestionShortcut() {
        return current().isSuggestionShortcut();
    }

    public boolean isWebSearchSuggestion() {
        return current().isWebSearchSuggestion();
    }

    public boolean isHistorySuggestion() {
        return current().isHistorySuggestion();
    }

    public SuggestionExtras getExtras() {
        return current().getExtras();
    }

}
",False,100,6,28,4,5,6,3,L2
27,com.android.quicksearchbox.SearchWidgetProvider.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.common.Search;
import com.android.common.speech.Recognition;
import com.android.quicksearchbox.util.Util;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.SearchManager;
import android.appwidget.AppWidgetManager;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.graphics.Typeface;
import android.net.Uri;
import android.os.Bundle;
import android.os.SystemClock;
import android.speech.RecognizerIntent;
import android.text.Annotation;
import android.text.SpannableStringBuilder;
import android.text.TextUtils;
import android.text.style.StyleSpan;
import android.util.Log;
import android.view.View;
import android.widget.RemoteViews;

import java.util.ArrayList;
import java.util.Random;

/**
 * Search widget provider.
 *
 */
public class SearchWidgetProvider extends BroadcastReceiver {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SearchWidgetProvider"";

    /**
     * The {@link Search#SOURCE} value used when starting searches from the search widget.
     */
    private static final String WIDGET_SEARCH_SOURCE = ""launcher-widget"";

    @Override
    public void onReceive(Context context, Intent intent) {
        if (DBG) Log.d(TAG, ""onReceive("" + intent.toUri(0) + "")"");
        String action = intent.getAction();
        if (AppWidgetManager.ACTION_APPWIDGET_ENABLED.equals(action)) {
            // nothing needs doing
        } else if (AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
            updateSearchWidgets(context);
        } else {
            if (DBG) Log.d(TAG, ""Unhandled intent action="" + action);
        }
    }

    private static SearchWidgetState[] getSearchWidgetStates(Context context) {
        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
        int[] appWidgetIds = appWidgetManager.getAppWidgetIds(myComponentName(context));
        SearchWidgetState[] states = new SearchWidgetState[appWidgetIds.length];
        for (int i = 0; i<appWidgetIds.length; ++i) {
            states[i] = getSearchWidgetState(context, appWidgetIds[i]);
        }
        return states;
    }


    /**
     * Updates all search widgets.
     */
    public static void updateSearchWidgets(Context context) {
        if (DBG) Log.d(TAG, ""updateSearchWidgets"");
        SearchWidgetState[] states = getSearchWidgetStates(context);

        for (SearchWidgetState state : states) {
            state.updateWidget(context, AppWidgetManager.getInstance(context));
        }
    }

    /**
     * Gets the component name of this search widget provider.
     */
    private static ComponentName myComponentName(Context context) {
        String pkg = context.getPackageName();
        String cls = pkg + "".SearchWidgetProvider"";
        return new ComponentName(pkg, cls);
    }

    private static Intent createQsbActivityIntent(Context context, String action,
            Bundle widgetAppData) {
        Intent qsbIntent = new Intent(action);
        qsbIntent.setPackage(context.getPackageName());
        qsbIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                | Intent.FLAG_ACTIVITY_CLEAR_TOP
                | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
        qsbIntent.putExtra(SearchManager.APP_DATA, widgetAppData);
        return qsbIntent;
    }

    private static SearchWidgetState getSearchWidgetState(Context context, int appWidgetId) {
        if (DBG) Log.d(TAG, ""Creating appwidget state "" + appWidgetId);
        SearchWidgetState state = new SearchWidgetState(appWidgetId);

        Bundle widgetAppData = new Bundle();
        widgetAppData.putString(Search.SOURCE, WIDGET_SEARCH_SOURCE);

        // Text field click
        Intent qsbIntent = createQsbActivityIntent(
                context,
                SearchManager.INTENT_ACTION_GLOBAL_SEARCH,
                widgetAppData);
        state.setQueryTextViewIntent(qsbIntent);

        // Voice search button
        Intent voiceSearchIntent = getVoiceSearchIntent(context, widgetAppData);
        state.setVoiceSearchIntent(voiceSearchIntent);

        return state;
    }

    private static Intent getVoiceSearchIntent(Context context, Bundle widgetAppData) {
        VoiceSearch voiceSearch = QsbApplication.get(context).getVoiceSearch();
        return voiceSearch.createVoiceWebSearchIntent(widgetAppData);
    }

    private static class SearchWidgetState {
        private final int mAppWidgetId;
        private Intent mCorpusIndicatorIntent;
        private Intent mQueryTextViewIntent;
        private Intent mVoiceSearchIntent;

        public SearchWidgetState(int appWidgetId) {
            mAppWidgetId = appWidgetId;
        }

        public void setQueryTextViewIntent(Intent queryTextViewIntent) {
            mQueryTextViewIntent = queryTextViewIntent;
        }

        public void setVoiceSearchIntent(Intent voiceSearchIntent) {
            mVoiceSearchIntent = voiceSearchIntent;
        }

        public void updateWidget(Context context,AppWidgetManager appWidgetMgr) {
            if (DBG) Log.d(TAG, ""Updating appwidget "" + mAppWidgetId);
            RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.search_widget);
//            // Corpus indicator
            setOnClickActivityIntent(context, views, R.id.search_icon,
                    mCorpusIndicatorIntent);

            setOnClickActivityIntent(context, views, R.id.search_widget_text,
                    mQueryTextViewIntent);
            // Voice Search button
            if (mVoiceSearchIntent != null) {
                setOnClickActivityIntent(context, views, R.id.search_widget_voice_btn,
                        mVoiceSearchIntent);
                views.setViewVisibility(R.id.search_widget_voice_btn, View.VISIBLE);
            } else {
                views.setViewVisibility(R.id.search_widget_voice_btn, View.GONE);
            }

            appWidgetMgr.updateAppWidget(mAppWidgetId, views);
        }

        private void setOnClickActivityIntent(Context context, RemoteViews views, int viewId,
                Intent intent) {
            PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);
            views.setOnClickPendingIntent(viewId, pendingIntent);
        }
    }

}
",True,120,1,1,6,46,1,3,L10
28,com.android.quicksearchbox.WebPromoter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.util.Log;


public class WebPromoter implements Promoter {

    private static final String TAG = ""QSB.WebPromoter"";
    private static final boolean DBG = false;

    private final int mMaxShortcuts;

    public WebPromoter(int maxShortcuts) {
        mMaxShortcuts = maxShortcuts;
    }

    public void pickPromoted(Suggestions suggestions, int maxPromoted,
            ListSuggestionCursor promoted) {
        // Add web shortcuts
        SuggestionCursor shortcuts = suggestions.getShortcuts();
        int shortcutCount = shortcuts == null ? 0 : shortcuts.getCount();
        if (DBG) Log.d(TAG, ""Shortcut count: "" + shortcutCount);
        int maxShortcutCount = Math.min(mMaxShortcuts, maxPromoted);
        for (int i = 0; i < shortcutCount && promoted.getCount() < maxShortcutCount; i++) {
            shortcuts.moveTo(i);
            if (shortcuts.isWebSearchSuggestion()) {
                if (DBG) Log.d(TAG, ""Including shortcut "" + i);
                promoted.add(new SuggestionPosition(shortcuts, i));
            } else {
                if (DBG) Log.d(TAG, ""Skipping shortcut "" + i);
            }
        }

        // Add web suggestion
        CorpusResult webResult = suggestions.getWebResult();
        int webCount = webResult == null ? 0 : webResult.getCount();
        if (DBG) Log.d(TAG, ""Web suggestion count: "" + webCount);
        for (int i = 0; i < webCount && promoted.getCount() < maxPromoted; i++) {
            webResult.moveTo(i);
            if (webResult.isWebSearchSuggestion()) {
                if (DBG) Log.d(TAG, ""Including suggestion "" + i);
                promoted.add(new SuggestionPosition(webResult, i));
            } else {
                if (DBG) Log.d(TAG, ""Skipping suggestion "" + i);
            }
        }
    }

}",True,57,4,19,4,9,2,7,L6
29,com.android.quicksearchbox.SuggestionPosition.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * A pointer to a suggestion in a {@link SuggestionCursor}.
 *
 */
public class SuggestionPosition extends AbstractSuggestionWrapper {

    private final SuggestionCursor mCursor;

    private final int mPosition;

    public SuggestionPosition(SuggestionCursor cursor) {
        this(cursor, cursor.getPosition());
    }

    public SuggestionPosition(SuggestionCursor cursor, int suggestionPos) {
        mCursor = cursor;
        mPosition = suggestionPos;
    }

    public SuggestionCursor getCursor() {
        return mCursor;
    }

    /**
     * Gets the suggestion cursor, moved to point to the right suggestion.
     */
    @Override
    protected Suggestion current() {
        mCursor.moveTo(mPosition);
        return mCursor;
    }

    public int getPosition() {
        return mPosition;
    }

    @Override
    public String toString() {
        return mCursor + "":"" + mPosition;
    }

}
",False,89,5,25,5,4,18,3,L3
30,com.android.quicksearchbox.Sources.java,"
package com.android.quicksearchbox;

import android.content.ComponentName;

import java.util.Collection;

/**
 * Search source set.
 */
public interface Sources {

    /**
     * Gets all sources.
     */
    Collection<Source> getSources();

    /**
     * Gets a source by name.
     *
     * @return A source, or {@code null} if no source with the given name exists.
     */
    Source getSource(String name);

    /**
     * Gets the web search source.
     */
    Source getWebSearchSource();

    /**
     * Creates a new source for a specific component.
     * @param component Name of the component to search
     * @return a new {@code Source} corresponding to {@code component}.
     */
    Source createSourceFor(ComponentName component);

    /**
     * Updates the list of sources.
     */
    void update();

}
",False,49,4,18,4,5,7,1,L3
31,com.android.quicksearchbox.Logger.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import java.util.Collection;
import java.util.List;


/**
 * Interface for logging implementations.
 */
public interface Logger {

    public static final int SEARCH_METHOD_BUTTON = 0;
    public static final int SEARCH_METHOD_KEYBOARD = 1;

    public static final int SUGGESTION_CLICK_TYPE_LAUNCH = 0;
    public static final int SUGGESTION_CLICK_TYPE_REFINE = 1;
    public static final int SUGGESTION_CLICK_TYPE_QUICK_CONTACT = 2;

    /**
     * Called when QSB has started.
     *
     * @param latency User-visible start-up latency in milliseconds.
     */
    void logStart(int onCreateLatency, int latency, String intentSource, Corpus corpus,
            List<Corpus> orderedCorpora);

    /**
     * Called when a suggestion is clicked.
     *
     * @param suggestionId Suggestion ID; 0-based position of the suggestion in the UI if the list
     *      is flat.
     * @param suggestionCursor all the suggestions shown in the UI.
     * @param queriedCorpora all corpora that were queried to produce the suggestions in
     *        {@code suggestionCursor}, ordered by rank.
     * @param clickType One of the SUGGESTION_CLICK_TYPE constants.
     */
    void logSuggestionClick(long suggestionId, SuggestionCursor suggestionCursor,
            Collection<Corpus> queriedCorpora, int clickType);

    /**
     * The user launched a search.
     *
     * @param startMethod One of {@link #SEARCH_METHOD_BUTTON} or {@link #SEARCH_METHOD_KEYBOARD}.
     * @param numChars The number of characters in the query.
     */
    void logSearch(Corpus corpus, int startMethod, int numChars);

    /**
     * The user launched a voice search.
     */
    void logVoiceSearch(Corpus corpus);

    /**
     * The user left QSB without performing any action (click suggestions, search or voice search).
     *
     * @param suggestionCursor all the suggestions shown in the UI when the user left
     * @param numChars The number of characters in the query typed when the user left.
     */
    void logExit(SuggestionCursor suggestionCursor, int numChars);

    /**
     * Logs the latency of a suggestion query to a specific source.
     *
     * @param result The result of the query.
     */
    void logLatency(CorpusResult result);

}
",False,48,4,17,4,4,7,3,L6
32,com.android.quicksearchbox.ResultFilter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

/**
 * {@link SuggestionFilter} that accepts only results (not web suggestions).
 */
public class ResultFilter implements SuggestionFilter {

    public ResultFilter() {
    }

    public boolean accept(Suggestion s) {
        return !s.isWebSearchSuggestion();
    }

}
",False,47,4,19,5,5,2,2,L7
33,com.android.quicksearchbox.ShortcutCursor.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.google.common.annotations.VisibleForTesting;

import android.os.Handler;
import android.util.Log;

import java.util.HashSet;

/**
 * A SuggestionCursor that allows shortcuts to be updated by overlaying
 * with results from another cursor.
 */
public class ShortcutCursor extends ListSuggestionCursor {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.ShortcutCursor"";

    // mShortcuts is used to close the underlying cursor when we're closed.
    private final SuggestionCursor mShortcuts;
    // mRefreshed contains all the cursors that have been refreshed, so that
    // they can be closed when ShortcutCursor is closed.
    private final HashSet<SuggestionCursor> mRefreshed;

    private boolean mClosed = false;

    private final ShortcutRefresher mRefresher;
    private final ShortcutRepository mShortcutRepo;
    private final Handler mUiThread;

    private ShortcutCursor(String query, SuggestionCursor shortcuts, Handler uiThread,
            ShortcutRefresher refresher, ShortcutRepository repository) {
        super(query);
        mShortcuts = shortcuts;
        mUiThread = uiThread;
        mRefresher = refresher;
        mShortcutRepo = repository;
        mRefreshed = new HashSet<SuggestionCursor>();
    }

    @VisibleForTesting
    ShortcutCursor(String query, Handler uiThread,
            ShortcutRefresher refresher, ShortcutRepository repository) {
        this(query, null, uiThread, refresher, repository);
    }

    @VisibleForTesting
    ShortcutCursor(SuggestionCursor suggestions) {
        this(suggestions, true, null, null, null);
    }

    public ShortcutCursor(SuggestionCursor suggestions, boolean allowWebSearchShortcuts,
            Handler uiThread, ShortcutRefresher refresher, ShortcutRepository repository) {
        this(suggestions.getUserQuery(), suggestions, uiThread, refresher, repository);
        int count = suggestions.getCount();
        if (DBG) Log.d(TAG, ""Total shortcuts: "" + count);
        for (int i = 0; i < count; i++) {
            suggestions.moveTo(i);
            if (suggestions.getSuggestionSource() != null
                    && (allowWebSearchShortcuts || !suggestions.isWebSearchSuggestion())) {
                add(new SuggestionPosition(suggestions));
            } else {
                if (DBG) Log.d(TAG, ""Skipping shortcut "" + i);
            }
        }
    }

    @Override
    public boolean isSuggestionShortcut() {
        // Needed to make refreshed shortcuts be treated as shortcuts
        return true;
    }

    /**
     * Refresh a shortcut from this cursor.
     *
     * @param shortcut The shortcut to refresh. Should be a shortcut taken from this cursor.
     */
    public void refresh(Suggestion shortcut) {
        mRefresher.refresh(shortcut, new ShortcutRefresher.Listener() {
            public void onShortcutRefreshed(final Source source,
                    final String shortcutId, final SuggestionCursor refreshed) {
                if (DBG) Log.d(TAG, ""Shortcut refreshed: "" + shortcutId);
                mShortcutRepo.updateShortcut(source, shortcutId, refreshed);
                mUiThread.post(new Runnable() {
                    public void run() {
                        refresh(source, shortcutId, refreshed);
                    }
                });
            }
        });
    }

    /**
     * Updates this SuggestionCursor with a refreshed result from another.
     * Since this modifies the cursor, it should be called on the UI thread.
     * This class assumes responsibility for closing refreshed.
     */
    private void refresh(Source source, String shortcutId, SuggestionCursor refreshed) {
        if (DBG) Log.d(TAG, ""refresh "" + shortcutId);
        if (mClosed) {
            if (refreshed != null) {
                refreshed.close();
            }
            return;
        }
        if (refreshed != null) {
            mRefreshed.add(refreshed);
        }
        for (int i = 0; i < getCount(); i++) {
            moveTo(i);
            if (shortcutId.equals(getShortcutId()) && source.equals(getSuggestionSource())) {
                if (refreshed != null && refreshed.getCount() > 0) {
                    if (DBG) Log.d(TAG, ""replacing row "" + i);
                    replaceRow(new SuggestionPosition(refreshed));
                } else {
                    if (DBG) Log.d(TAG, ""removing row "" + i);
                    removeRow();
                }
                notifyDataSetChanged();
                break;
            }
        }
    }

    @Override
    public void close() {
        if (DBG) Log.d(TAG, ""close()"");
        if (mClosed) {
            throw new IllegalStateException(""double close"");
        }
        mClosed = true;
        if (mShortcuts != null) {
            mShortcuts.close();
        }
        for (SuggestionCursor cursor : mRefreshed) {
            cursor.close();
        }
        super.close();
    }
}",True,85,5,24,3,9,6,8,L4
34,com.android.quicksearchbox.ListSuggestionCursorNoDuplicates.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.util.Log;

import java.util.HashSet;

/**
 * A SuggestionCursor that is backed by a list of SuggestionPosition objects
 * and doesn't allow duplicate suggestions.
 */
public class ListSuggestionCursorNoDuplicates extends ListSuggestionCursor {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.ListSuggestionCursorNoDuplicates"";

    private final HashSet<String> mSuggestionKeys;

    public ListSuggestionCursorNoDuplicates(String userQuery) {
        super(userQuery);
        mSuggestionKeys = new HashSet<String>();
    }

    @Override
    public boolean add(Suggestion suggestion) {
        String key = SuggestionUtils.getSuggestionKey(suggestion);
        if (mSuggestionKeys.add(key)) {
            return super.add(suggestion);
        } else {
            if (DBG) Log.d(TAG, ""Rejecting duplicate "" + key);
            return false;
        }
    }

}
",False,79,6,20,5,6,3,3,L5
35,com.android.quicksearchbox.SuggestionCursor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import com.android.quicksearchbox.util.QuietlyCloseable;

import android.database.DataSetObserver;

import java.util.Collection;

/**
 * A sequence of suggestions, with a current position.
 */
public interface SuggestionCursor extends Suggestion, QuietlyCloseable {

    /**
     * Gets the query that the user typed to get this suggestion.
     */
    String getUserQuery();

    /**
     * Gets the number of suggestions in this result.
     *
     * @return The number of suggestions, or {@code 0} if this result represents a failed query.
     */
    int getCount();

    /**
     * Moves to a given suggestion.
     *
     * @param pos The position to move to.
     * @throws IndexOutOfBoundsException if {@code pos < 0} or {@code pos >= getCount()}.
     */
    void moveTo(int pos);

    /**
     * Moves to the next suggestion, if there is one.
     *
     * @return {@code false} if there is no next suggestion.
     */
    boolean moveToNext();

    /**
     * Gets the current position within the cursor.
     */
    int getPosition();

    /**
     * Frees any resources used by this cursor.
     */
    void close();

    /**
     * Register an observer that is called when changes happen to this data set.
     *
     * @param observer gets notified when the data set changes.
     */
    void registerDataSetObserver(DataSetObserver observer);

    /**
     * Unregister an observer that has previously been registered with 
     * {@link #registerDataSetObserver(DataSetObserver)}
     *
     * @param observer the observer to unregister.
     */
    void unregisterDataSetObserver(DataSetObserver observer);

    /**
     * Return the extra columns present in this cursor, or null if none exist.
     */
    Collection<String> getExtraColumns();
}
",False,113,4,49,5,4,53,2,L1
36,com.android.quicksearchbox.CorporaUpdateReceiver.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.app.SearchManager;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;

/**
 * Listens for broadcasts that require updates to the corpus set.
 */
public class CorporaUpdateReceiver extends BroadcastReceiver {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.CorporaUpdateReceiver"";

    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)
                || SearchManager.INTENT_ACTION_SEARCH_SETTINGS_CHANGED.equals(action)) {
            if (DBG) Log.d(TAG, ""onReceive("" + intent + "")"");
            updateCorpora(context);
            SearchWidgetProvider.updateSearchWidgets(context);
        }
    }

    private void updateCorpora(Context context) {
        QsbApplication.get(context).updateCorpora();
    }

}
",True,120,0,0,6,48,0,2,L10
37,com.android.quicksearchbox.CorpusRanker.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.Consumer;

import java.util.List;

/**
 * Orders corpora by importance.
 */
public interface CorpusRanker {

    /**
     * Gets a an ordered list of corpora.
     *
     * @param consumer Consumer that will be given the list of ranked corpora.
     *        The consumer is called on an unspecified thread.
     *        The most important corpora come first in the list. Callers should not modify the
     *        list.
     */
    void getCorporaInAll(Consumer<List<Corpus>> consumer);

}
",False,47,4,20,5,4,3,2,L5
38,com.android.quicksearchbox.EventLogLogger.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Context;
import android.util.EventLog;

import java.util.Collection;
import java.util.List;
import java.util.Random;

/**
 * Logs events to {@link EventLog}.
 */
public class EventLogLogger implements Logger {

    private static final char LIST_SEPARATOR = '|';

    private final Context mContext;

    private final Config mConfig;

    private final String mPackageName;

    private final Random mRandom;

    public EventLogLogger(Context context, Config config) {
        mContext = context;
        mConfig = config;
        mPackageName = mContext.getPackageName();
        mRandom = new Random();
    }

    protected Context getContext() {
        return mContext;
    }

    protected int getVersionCode() {
        return QsbApplication.get(getContext()).getVersionCode();
    }

    protected Config getConfig() {
        return mConfig;
    }

    public void logStart(int onCreateLatency, int latency, String intentSource, Corpus corpus,
            List<Corpus> orderedCorpora) {
        // TODO: Add more info to startMethod
        String startMethod = intentSource;
        String currentCorpus = getCorpusLogName(corpus);
        String enabledCorpora = getCorpusLogNames(orderedCorpora);
        EventLogTags.writeQsbStart(mPackageName, getVersionCode(), startMethod,
                latency, currentCorpus, enabledCorpora, onCreateLatency);
    }

    public void logSuggestionClick(long id, SuggestionCursor suggestionCursor,
            Collection<Corpus> queriedCorpora, int clickType) {
        String suggestions = getSuggestions(suggestionCursor);
        String corpora = getCorpusLogNames(queriedCorpora);
        int numChars = suggestionCursor.getUserQuery().length();
        EventLogTags.writeQsbClick(id, suggestions, corpora, numChars,
                clickType);
    }

    public void logSearch(Corpus corpus, int startMethod, int numChars) {
        String corpusName = getCorpusLogName(corpus);
        EventLogTags.writeQsbSearch(corpusName, startMethod, numChars);
    }

    public void logVoiceSearch(Corpus corpus) {
        String corpusName = getCorpusLogName(corpus);
        EventLogTags.writeQsbVoiceSearch(corpusName);
    }

    public void logExit(SuggestionCursor suggestionCursor, int numChars) {
        String suggestions = getSuggestions(suggestionCursor);
        EventLogTags.writeQsbExit(suggestions, numChars);
    }

    public void logLatency(CorpusResult result) {
        if (!shouldLogLatency()) return;
        String corpusName = getCorpusLogName(result.getCorpus());
        int latency = result.getLatency();
        int numChars = result.getUserQuery().length();
        EventLogTags.writeQsbLatency(corpusName, latency, numChars);
    }

    private boolean shouldLogLatency() {
        int freq = mConfig.getLatencyLogFrequency();
        return freq > mRandom.nextInt(1000);
    }

    private String getCorpusLogName(Corpus corpus) {
        if (corpus == null) return null;
        return corpus.getName();
    }

    private String getSuggestions(SuggestionCursor cursor) {
        StringBuilder sb = new StringBuilder();
        final int count = cursor == null ? 0 : cursor.getCount();
        for (int i = 0; i < count; i++) {
            if (i > 0) sb.append(LIST_SEPARATOR);
            cursor.moveTo(i);
            String source = cursor.getSuggestionSource().getName();
            String type = cursor.getSuggestionLogType();
            if (type == null) type = """";
            String shortcut = cursor.isSuggestionShortcut() ? ""shortcut"" : """";
            sb.append(source).append(':').append(type).append(':').append(shortcut);
        }
        return sb.toString();
    }

    private String getCorpusLogNames(Collection<Corpus> corpora) {
        if (corpora == null) return """";
        StringBuilder sb = new StringBuilder();
        for (Corpus corpus : corpora) {
            if (sb.length() > 0) sb.append(LIST_SEPARATOR);
            sb.append(getCorpusLogName(corpus));
        }
        return sb.toString();
    }

}
",True,118,0,0,6,46,1,8,L8
39,com.android.quicksearchbox.AppsCorpus.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


import com.android.quicksearchbox.util.Util;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.Log;

/**
 * The apps search source.
 */
public class AppsCorpus extends SingleSourceCorpus {

    private static final String TAG = ""QSB.AppsCorpus"";

    private static final String APPS_CORPUS_NAME = ""apps"";

    public AppsCorpus(Context context, Config config, Source appsSource) {
        super(context, config, appsSource);
    }

    @Override
    public CharSequence getLabel() {
        return getContext().getText(R.string.corpus_label_apps);
    }

    @Override
    public CharSequence getHint() {
        return getContext().getText(R.string.corpus_hint_apps);
    }

    @Override
    public Drawable getCorpusIcon() {
        return getContext().getResources().getDrawable(R.drawable.corpus_icon_apps);
    }

    @Override
    public Uri getCorpusIconUri() {
        return Util.getResourceUri(getContext(), R.drawable.corpus_icon_apps);
    }

    @Override
    public String getName() {
        return APPS_CORPUS_NAME;
    }

    @Override
    public CharSequence getSettingsDescription() {
        return getContext().getText(R.string.corpus_description_apps);
    }

    @Override
    public Intent createSearchIntent(String query, Bundle appData) {
        Intent appSearchIntent = createAppSearchIntent(query, appData);
        if (appSearchIntent != null) {
            return appSearchIntent;
        } else {
            // Fall back to sending the intent to ApplicationsProvider
            return super.createSearchIntent(query, appData);
        }
    }

    /**
     * Creates an intent that starts the search activity specified in
     * R.string.apps_search_activity.
     *
     * @return An intent, or {@code null} if the search activity is not set or can't be found.
     */
    private Intent createAppSearchIntent(String query, Bundle appData) {
        ComponentName name = getComponentName(getContext(), R.string.apps_search_activity);
        if (name == null) return null;
        Intent intent = AbstractSource.createSourceSearchIntent(name, query, appData);
        if (intent == null) return null;
        ActivityInfo ai = intent.resolveActivityInfo(getContext().getPackageManager(), 0);
        if (ai != null) {
            return intent;
        } else {
            Log.w(TAG, ""Can't find app search activity "" + name);
            return null;
        }
    }

    private static ComponentName getComponentName(Context context, int res) {
        String nameStr = context.getString(res);
        if (TextUtils.isEmpty(nameStr)) {
            return null;
        } else {
            return ComponentName.unflattenFromString(nameStr);
        }
    }
}
",False,118,0,0,7,52,1,6,L8
40,com.android.quicksearchbox.WebCorpus.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


import com.android.quicksearchbox.util.Util;

import android.content.Context;
import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;
import android.util.Patterns;
import android.webkit.URLUtil;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executor;

/**
 * The web search source.
 */
public class WebCorpus extends MultiSourceCorpus {
    private static final String TAG = ""QSB.WebCorpus"";
    private static final boolean DBG = false;

    private static final String WEB_CORPUS_NAME = ""web"";

    private final SearchSettings mSettings;

    private Source mWebSearchSource;

    private final Source mBrowserSource;

    public WebCorpus(Context context, Config config, SearchSettings settings, Executor executor,
            Source webSearchSource, Source browserSource) {
        super(context, config, executor, webSearchSource, browserSource);
        if (DBG) {
            Log.d(TAG, ""init webSource="" + webSearchSource + ""; browser source = "" + browserSource);
        }
        mSettings = settings;
        mWebSearchSource = webSearchSource;
        mBrowserSource = browserSource;
    }

    protected SearchSettings getSettings() {
        return mSettings;
    }

    public void setWebSource(Source web) {
        if (DBG) Log.d(TAG, ""setWebSource("" + web + "")"");
        mWebSearchSource = web;
    }

    public CharSequence getLabel() {
        return getContext().getText(R.string.corpus_label_web);
    }

    public CharSequence getHint() {
        // The web corpus uses a drawable hint instead
        return null;
    }

    private boolean isUrl(String query) {
       return Patterns.WEB_URL.matcher(query).matches();
    }

    public Intent createSearchIntent(String query, Bundle appData) {
        if (isUrl(query)) {
            return createBrowseIntent(query);
        } else if (mWebSearchSource != null){
            return mWebSearchSource.createSearchIntent(query, appData);
        } else {
            return null;
        }
    }

    private Intent createBrowseIntent(String query) {
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.addCategory(Intent.CATEGORY_BROWSABLE);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
        String url = URLUtil.guessUrl(query);
        intent.setData(Uri.parse(url));
        return intent;
    }

    public Intent createVoiceSearchIntent(Bundle appData) {
        // TODO in 2-pane mode, mWebSearchSource may be NULL
        // this functionality should be moved elsewhere.
        if (mWebSearchSource != null){
            return mWebSearchSource.createVoiceSearchIntent(appData);
        } else {
            return null;
        }
    }

    private int getCorpusIconResource() {
        return R.drawable.corpus_icon_web;
    }

    public Drawable getCorpusIcon() {
        return getContext().getResources().getDrawable(getCorpusIconResource());
    }

    public Uri getCorpusIconUri() {
        return Util.getResourceUri(getContext(), getCorpusIconResource());
    }

    public String getName() {
        return WEB_CORPUS_NAME;
    }

    @Override
    public int getQueryThreshold() {
        return 0;
    }

    @Override
    public boolean queryAfterZeroResults() {
        return true;
    }

    @Override
    public boolean voiceSearchEnabled() {
        return true;
    }

    public boolean isWebCorpus() {
        return true;
    }

    public CharSequence getSettingsDescription() {
        return getContext().getText(R.string.corpus_description_web);
    }

    @Override
    protected List<Source> getSourcesToQuery(String query, boolean onlyCorpus) {
        ArrayList<Source> sourcesToQuery = new ArrayList<Source>(2);
        if (mWebSearchSource != null) sourcesToQuery.add(mWebSearchSource);
        if (mBrowserSource != null && query.length() > 0) {
            sourcesToQuery.add(mBrowserSource);
        }
        if (DBG) Log.d(TAG, ""getSourcesToQuery sourcesToQuery="" + sourcesToQuery);
        return sourcesToQuery;
    }

    @Override
    protected Result createResult(String query, ArrayList<SourceResult> results, int latency) {
        return new WebResult(query, results, latency);
    }

    protected class WebResult extends Result {

        public WebResult(String query, ArrayList<SourceResult> results, int latency) {
            super(query, results, latency);
        }

        @Override
        public void fill() {
            SourceResult webSearchResult = null;
            SourceResult browserResult = null;
            for (SourceResult result : getResults()) {
                if (result.getSource().equals(mWebSearchSource)) {
                    webSearchResult = result;
                } else {
                    browserResult = result;
                }
            }
            if (browserResult != null && browserResult.getCount() > 0) {
                add(new SuggestionPosition(browserResult, 0));
            }
            if (webSearchResult != null) {
                int count = webSearchResult.getCount();
                for (int i = 0; i < count; i++) {
                    add(new SuggestionPosition(webSearchResult, i));
                }
            }
        }

    }
}
",True,59,5,19,3,12,1,10,L8
41,com.android.quicksearchbox.SuggestionsProviderImpl.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.BatchingNamedTaskExecutor;
import com.android.quicksearchbox.util.Consumer;
import com.android.quicksearchbox.util.NamedTaskExecutor;
import com.android.quicksearchbox.util.NoOpConsumer;

import android.os.Handler;
import android.util.Log;

import java.util.ArrayList;
import java.util.List;

/**
 * Suggestions provider implementation.
 *
 * The provider will only handle a single query at a time. If a new query comes
 * in, the old one is cancelled.
 */
public class SuggestionsProviderImpl implements SuggestionsProvider {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SuggestionsProviderImpl"";

    private final Config mConfig;

    private final NamedTaskExecutor mQueryExecutor;

    private final Handler mPublishThread;

    private final ShouldQueryStrategy mShouldQueryStrategy;

    private final Logger mLogger;

    private BatchingNamedTaskExecutor mBatchingExecutor;

    public SuggestionsProviderImpl(Config config,
            NamedTaskExecutor queryExecutor,
            Handler publishThread,
            Logger logger) {
        mConfig = config;
        mQueryExecutor = queryExecutor;
        mPublishThread = publishThread;
        mLogger = logger;
        mShouldQueryStrategy = new ShouldQueryStrategy(mConfig);
    }

    public void close() {
        cancelPendingTasks();
    }

    /**
     * Cancels all pending query tasks.
     */
    private void cancelPendingTasks() {
        if (mBatchingExecutor != null) {
            mBatchingExecutor.cancelPendingTasks();
            mBatchingExecutor = null;
        }
    }

    /**
     * Gets the sources that should be queried for the given query.
     */
    private List<Corpus> filterCorpora(String query, List<Corpus> corpora) {
        // If there is only one corpus, always query it
        if (corpora.size() <= 1) return corpora;
        ArrayList<Corpus> corporaToQuery = new ArrayList<Corpus>(corpora.size());
        for (Corpus corpus : corpora) {
            if (shouldQueryCorpus(corpus, query)) {
                if (DBG) Log.d(TAG, ""should query corpus "" + corpus);
                corporaToQuery.add(corpus);
            } else {
                if (DBG) Log.d(TAG, ""should NOT query corpus "" + corpus);
            }
        }
        if (DBG) Log.d(TAG, ""getCorporaToQuery corporaToQuery="" + corporaToQuery);
        return corporaToQuery;
    }

    protected boolean shouldQueryCorpus(Corpus corpus, String query) {
        return mShouldQueryStrategy.shouldQueryCorpus(corpus, query);
    }

    private void updateShouldQueryStrategy(CorpusResult cursor) {
        if (cursor.getCount() == 0) {
            mShouldQueryStrategy.onZeroResults(cursor.getCorpus(),
                    cursor.getUserQuery());
        }
    }

    public Suggestions getSuggestions(String query, List<Corpus> corporaToQuery) {
        if (DBG) Log.d(TAG, ""getSuggestions("" + query + "")"");
        corporaToQuery = filterCorpora(query, corporaToQuery);
        final Suggestions suggestions = new Suggestions(query, corporaToQuery);
        Log.i(TAG, ""chars:"" + query.length() + "",corpora:"" + corporaToQuery);

        // Fast path for the zero sources case
        if (corporaToQuery.size() == 0) {
            return suggestions;
        }

        int initialBatchSize = countDefaultCorpora(corporaToQuery);
        if (initialBatchSize == 0) {
            initialBatchSize = mConfig.getNumPromotedSources();
        }

        mBatchingExecutor = new BatchingNamedTaskExecutor(mQueryExecutor);

        long publishResultDelayMillis = mConfig.getPublishResultDelayMillis();

        Consumer<CorpusResult> receiver;
        if (shouldDisplayResults(query)) {
            receiver = new SuggestionCursorReceiver(
                    mBatchingExecutor, suggestions, initialBatchSize,
                    publishResultDelayMillis);
        } else {
            receiver = new NoOpConsumer<CorpusResult>();
            suggestions.done();
        }

        int maxResultsPerSource = mConfig.getMaxResultsPerSource();
        QueryTask.startQueries(query, maxResultsPerSource, corporaToQuery, mBatchingExecutor,
                mPublishThread, receiver, corporaToQuery.size() == 1);
        mBatchingExecutor.executeNextBatch(initialBatchSize);

        return suggestions;
    }

    private int countDefaultCorpora(List<Corpus> corpora) {
        int count = 0;
        for (Corpus corpus : corpora) {
            if (corpus.isCorpusDefaultEnabled()) {
                count++;
            }
        }
        return count;
    }

    private boolean shouldDisplayResults(String query) {
        if (query.length() == 0 && !mConfig.showSuggestionsForZeroQuery()) {
            // Note that even though we don't display such results, it's
            // useful to run the query itself because it warms up the network
            // connection.
            return false;
        }
        return true;
    }


    private class SuggestionCursorReceiver implements Consumer<CorpusResult> {
        private final BatchingNamedTaskExecutor mExecutor;
        private final Suggestions mSuggestions;
        private final long mResultPublishDelayMillis;
        private final ArrayList<CorpusResult> mPendingResults;
        private final Runnable mResultPublishTask = new Runnable () {
            public void run() {
                if (DBG) Log.d(TAG, ""Publishing delayed results"");
                publishPendingResults();
            }
        };

        private int mCountAtWhichToExecuteNextBatch;

        public SuggestionCursorReceiver(BatchingNamedTaskExecutor executor,
                Suggestions suggestions, int initialBatchSize,
                long publishResultDelayMillis) {
            mExecutor = executor;
            mSuggestions = suggestions;
            mCountAtWhichToExecuteNextBatch = initialBatchSize;
            mResultPublishDelayMillis = publishResultDelayMillis;
            mPendingResults = new ArrayList<CorpusResult>();
        }

        public boolean consume(CorpusResult cursor) {
            if (DBG) {
                Log.d(TAG, ""SuggestionCursorReceiver.consume("" + cursor + "") corpus="" +
                        cursor.getCorpus() + "" count = "" + cursor.getCount());
            }
            updateShouldQueryStrategy(cursor);
            mPendingResults.add(cursor);
            if (mResultPublishDelayMillis > 0
                    && !mSuggestions.isClosed()
                    && mSuggestions.getResultCount() + mPendingResults.size()
                            < mCountAtWhichToExecuteNextBatch) {
                // This is not the last result of the batch, delay publishing
                if (DBG) Log.d(TAG, ""Delaying result by "" + mResultPublishDelayMillis + "" ms"");
                mPublishThread.removeCallbacks(mResultPublishTask);
                mPublishThread.postDelayed(mResultPublishTask, mResultPublishDelayMillis);
            } else {
                // This is the last result, publish immediately
                if (DBG) Log.d(TAG, ""Publishing result immediately"");
                mPublishThread.removeCallbacks(mResultPublishTask);
                publishPendingResults();
            }
            if (!mSuggestions.isClosed()) {
                executeNextBatchIfNeeded();
            }
            if (cursor != null && mLogger != null) {
                mLogger.logLatency(cursor);
            }
            return true;
        }

        private void publishPendingResults() {
            mSuggestions.addCorpusResults(mPendingResults);
            mPendingResults.clear();
        }

        private void executeNextBatchIfNeeded() {
            if (mSuggestions.getResultCount() == mCountAtWhichToExecuteNextBatch) {
                // We've just finished one batch, ask for more
                int nextBatchSize = mConfig.getNumPromotedSources();
                mCountAtWhichToExecuteNextBatch += nextBatchSize;
                mExecutor.executeNextBatch(nextBatchSize);
            }
        }
    }
}
",True,66,4,19,3,13,2,13,L6
42,com.android.quicksearchbox.ShortcutPromoter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.HashMultiset;

/**
 * A promoter limits the maximum number of shortcuts per source
 * (from non-web sources) and blends results
 * from multiple sources.
 */
public class ShortcutPromoter extends AbstractPromoter {

    public ShortcutPromoter(Config config, Promoter next, SuggestionFilter filter) {
        super(filter, next, config);
    }

    @Override
    public void doPickPromoted(Suggestions suggestions, int maxPromoted,
            ListSuggestionCursor promoted) {
        promoteShortcuts(suggestions.getShortcuts(), maxPromoted, promoted);
    }

    @VisibleForTesting
    void promoteShortcuts(SuggestionCursor shortcuts, int maxPromoted,
            ListSuggestionCursor promoted) {
        int shortcutCount = shortcuts == null ? 0 : shortcuts.getCount();
        if (shortcutCount == 0) return;
        HashMultiset<Source> sourceShortcutCounts = HashMultiset.create(shortcutCount);
        for (int i = 0; i < shortcutCount && promoted.getCount() < maxPromoted; i++) {
            shortcuts.moveTo(i);
            Source source = shortcuts.getSuggestionSource();
            if (source != null && accept(shortcuts)) {
                int prevCount = sourceShortcutCounts.add(source, 1);
                int maxShortcuts = source.getMaxShortcuts(getConfig());
                if (prevCount < maxShortcuts) {
                    promoted.add(new SuggestionPosition(shortcuts));
                }
            }
        }
    }

}
",False,60,4,19,3,11,3,10,L7
43,com.android.quicksearchbox.AbstractSuggestionCursorWrapper.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

/**
 * A SuggestionCursor that delegates all calls to other suggestions.
 */
public abstract class AbstractSuggestionCursorWrapper extends AbstractSuggestionWrapper
        implements SuggestionCursor {

    private final String mUserQuery;

    public AbstractSuggestionCursorWrapper(String userQuery) {
        mUserQuery = userQuery;
    }

    public String getUserQuery() {
        return mUserQuery;
    }
}
",False,99,6,35,5,4,5,2,L2
44,com.android.quicksearchbox.SingleSourceCorpusResult.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * A CorpusResult backed by a single SourceResult.
 */
public class SingleSourceCorpusResult extends SuggestionCursorWrapper implements CorpusResult {

    private final Corpus mCorpus;

    private final int mLatency;

    public SingleSourceCorpusResult(Corpus corpus, String userQuery, SuggestionCursor cursor,
            int latency) {
        super(userQuery, cursor);
        mCorpus = corpus;
        mLatency = latency;
    }

    public Corpus getCorpus() {
        return mCorpus;
    }

    public int getLatency() {
        return mLatency;
    }

    @Override
    public String toString() {
        return getCorpus() + ""["" + getUserQuery() + ""]"";
    }

}
",False,49,6,19,4,5,1,5,L8
45,com.android.quicksearchbox.Promoter.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * Promoters choose which suggestions to promote from all the available suggestions.
 *
 */
public interface Promoter {

    /**
     * Gets the promoted suggestions.
     *
     * @param suggestions The suggestions to promote from.
     * @param maxPromoted The maximum number of suggestions to promote.
     * @param promoted List to add the promoted suggestions to.
     */
    void pickPromoted(Suggestions suggestions, int maxPromoted, ListSuggestionCursor promoted);

}
",False,80,4,30,4,9,14,2,L5
46,com.android.quicksearchbox.ShortcutRefresher.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

/**
 * Fires off tasks to validate shortcuts, and reports the results back to a
 * {@link Listener}.
 */
public interface ShortcutRefresher {

    public interface Listener {
        /**
         * Called by the ShortcutRefresher when a shortcut has been refreshed.
         *
         * @param source source of this shortcut.
         * @param shortcutId the id of the shortcut.
         * @param refreshed the updated shortcut, or {@code null} if the shortcut
         *        is no longer valid and should be deleted.
         */
        void onShortcutRefreshed(Source source, String shortcutId,
                SuggestionCursor refreshed);
    }

    /**
     * Starts a task to refresh a single shortcut.
     *
     * @param shortcut The shortcut to be refreshed.
     * @param listener Who to report back to.
     */
    void refresh(Suggestion shortcut, Listener listener);

    /**
     * Returns true if the given shortcut requires refreshing.
     */
    boolean shouldRefresh(Source source, String shortcutId);

    /**
     * Indicates that the shortcut no longer requires refreshing.
     */
    public void markShortcutRefreshed(Source source, String shortcutId);

    /**
     * Resets internal state. This results in all shortcuts requiring refreshing.
     */
    public void reset();

}
",False,86,5,27,4,6,8,3,L2
47,com.android.quicksearchbox.SingleCorpusPromoter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import java.util.HashSet;
import java.util.Set;

/**
 * Promotes shortcuts and suggestions from a single corpus.
 */
public class SingleCorpusPromoter implements Promoter {

    private final Corpus mCorpus;

    private final int mMaxShortcuts;

    private final Set<String> mAllowedSources;

    public SingleCorpusPromoter(Corpus corpus, int maxShortcuts) {
        mCorpus = corpus;
        mMaxShortcuts = maxShortcuts;
        mAllowedSources = new HashSet<String>();
        for (Source source : corpus.getSources()) {
            mAllowedSources.add(source.getName());
        }
    }

    public void pickPromoted(Suggestions suggestions, int maxPromoted,
            ListSuggestionCursor promoted) {
        // Add shortcuts
        SuggestionCursor shortcuts = suggestions.getShortcuts();
        promoteUntilFull(shortcuts, mMaxShortcuts, promoted);
        // Add suggestions
        CorpusResult corpusResult = suggestions.getCorpusResult(mCorpus);
        promoteUntilFull(corpusResult, maxPromoted, promoted);
    }

    private void promoteUntilFull(SuggestionCursor c, int maxSize, ListSuggestionCursor promoted) {
        if (c == null) return;
        int count = c.getCount();
        for (int i = 0; i < count && promoted.getCount() < maxSize; i++) {
            c.moveTo(i);
            if (accept(c)) {
                promoted.add(new SuggestionPosition(c, i));
            }
        }
    }

    protected boolean accept(Suggestion s) {
        return mAllowedSources.contains(s.getSuggestionSource().getName());
    }

}
",False,58,4,19,3,10,3,10,L6
48,com.android.quicksearchbox.Corpus.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;

import java.util.Collection;

/**
 * A corpus is a user-visible set of suggestions. A corpus gets suggestions from one
 * or more sources.
 *
 * Objects that implement this interface should override {@link Object#equals(Object)}
 * and {@link Object#hashCode()} so that they can be used as keys in hash maps.
 */
public interface Corpus extends SuggestionCursorProvider<CorpusResult> {

    /**
     * Gets the localized, human-readable label for this corpus.
     */
    CharSequence getLabel();

    /**
     * Gets the icon for this corpus.
     */
    Drawable getCorpusIcon();

    /**
     * Gets the icon URI for this corpus.
     */
    Uri getCorpusIconUri();

    /**
     * Gets the description to use for this corpus in system search settings.
     */
    CharSequence getSettingsDescription();

    /**
     * Gets the search hint text for this corpus.
     */
    CharSequence getHint();

    /**
     * @return The minimum query length for which this corpus should be queried.
     */
    int getQueryThreshold();

    boolean queryAfterZeroResults();

    boolean voiceSearchEnabled();

    Intent createSearchIntent(String query, Bundle appData);

    Intent createVoiceSearchIntent(Bundle appData);

    boolean isWebCorpus();

    /**
     * Gets the sources that this corpus uses.
     */
    Collection<Source> getSources();

    /**
     * Checks if this corpus is enabled by default.
     */
    boolean isCorpusDefaultEnabled();

    /**
     * Whether this corpus should be included in the blended All mode.
     */
    boolean includeInAll();

    /**
     * Checks if this corpus should be hidden from the corpus selector.
     */
    boolean isCorpusHidden();

}
",False,105,4,44,4,4,46,3,L1
49,com.android.quicksearchbox.Config.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.app.AlarmManager;
import android.content.Context;
import android.net.Uri;
import android.os.Process;
import android.util.Log;

import java.util.HashSet;

/**
 * Provides values for configurable parameters in all of QSB.
 *
 * All the methods in this class return fixed default values. Subclasses may
 * make these values server-side settable.
 *
 */
public class Config {

    private static final String TAG = ""QSB.Config"";
    private static final boolean DBG = false;

    protected static final long SECOND_MILLIS = 1000L;
    protected static final long MINUTE_MILLIS = 60L * SECOND_MILLIS;
    protected static final long DAY_MILLIS = 86400000L;

    private static final int NUM_PROMOTED_SOURCES = 3;
    private static final int MAX_RESULTS_PER_SOURCE = 50;
    private static final long SOURCE_TIMEOUT_MILLIS = 10000;

    private static final int QUERY_THREAD_PRIORITY =
            Process.THREAD_PRIORITY_BACKGROUND + Process.THREAD_PRIORITY_MORE_FAVORABLE;

    private static final long MAX_STAT_AGE_MILLIS = 30 * DAY_MILLIS;
    private static final int MIN_CLICKS_FOR_SOURCE_RANKING = 3;

    private static final int NUM_WEB_CORPUS_THREADS = 2;

    private static final int LATENCY_LOG_FREQUENCY = 1000;

    private static final long TYPING_SUGGESTIONS_UPDATE_DELAY_MILLIS = 100;
    private static final long PUBLISH_RESULT_DELAY_MILLIS = 200;

    private static final long VOICE_SEARCH_HINT_ACTIVE_PERIOD = 7L * DAY_MILLIS;

    private static final long VOICE_SEARCH_HINT_UPDATE_INTERVAL
            = AlarmManager.INTERVAL_FIFTEEN_MINUTES;

    private static final long VOICE_SEARCH_HINT_SHOW_PERIOD_MILLIS
            = AlarmManager.INTERVAL_HOUR * 2;

    private static final long VOICE_SEARCH_HINT_CHANGE_PERIOD = 2L * MINUTE_MILLIS;

    private static final long VOICE_SEARCH_HINT_VISIBLE_PERIOD = 6L * MINUTE_MILLIS;

    private static final int HTTP_CONNECT_TIMEOUT_MILLIS = 4000;
    private static final int HTTP_READ_TIMEOUT_MILLIS = 4000;

    private static final String USER_AGENT = ""Android/1.0"";

    private final Context mContext;
    private HashSet<String> mDefaultCorpora;
    private HashSet<String> mHiddenCorpora;
    private HashSet<String> mDefaultCorporaSuggestUris;

    /**
     * Creates a new config that uses hard-coded default values.
     */
    public Config(Context context) {
        mContext = context;
    }

    protected Context getContext() {
        return mContext;
    }

    /**
     * Releases any resources used by the configuration object.
     *
     * Default implementation does nothing.
     */
    public void close() {
    }

    private HashSet<String> loadResourceStringSet(int res) {
        HashSet<String> defaultCorpora = new HashSet<String>();
        String[] corpora = mContext.getResources().getStringArray(res);
        for (String corpus : corpora) {
            if (DBG) Log.d(TAG, ""Default corpus: "" + corpus);
            defaultCorpora.add(corpus);
        }
        return defaultCorpora;
    }

    /**
     * Checks if we trust the given source not to be spammy.
     */
    public synchronized boolean isCorpusEnabledByDefault(Corpus corpus) {
        if (DBG) Log.d(TAG, ""isCorpusEnabledByDefault("" + corpus.getName() + "")"");
        if (mDefaultCorpora == null) {
            mDefaultCorpora = loadResourceStringSet(R.array.default_corpora);
        }
        if (mDefaultCorpora.contains(corpus.getName())) {
            if (DBG) Log.d(TAG, ""Corpus "" + corpus.getName() + "" IS default"");
            return true;
        }

        if (mDefaultCorporaSuggestUris == null) {
            mDefaultCorporaSuggestUris = loadResourceStringSet(
                    R.array.default_corpora_suggest_uris);
        }

        for (Source s : corpus.getSources()) {
            String uri = s.getSuggestUri();
            if (DBG) Log.d(TAG, ""Suggest URI for "" + corpus.getName() + "": "" + uri);
            if (mDefaultCorporaSuggestUris.contains(uri)) {
                if (DBG) Log.d(TAG, ""Corpus "" + corpus.getName() + "" IS default"");
                return true;
            }
        }
        if (DBG) Log.d(TAG, ""Corpus "" + corpus.getName() + "" is NOT default"");
        return false;
    }

    /**
     * Checks if the given corpus should be hidden from the corpus selection dialog.
     */
    public synchronized boolean isCorpusHidden(String corpusName) {
        if (mHiddenCorpora == null) {
            mHiddenCorpora = loadResourceStringSet(R.array.hidden_corpora);
        }
        return mHiddenCorpora.contains(corpusName);
    }

    /**
     * The number of promoted sources.
     */
    public int getNumPromotedSources() {
        return NUM_PROMOTED_SOURCES;
    }

    /**
     * The number of suggestions visible above the onscreen keyboard.
     */
    public int getNumSuggestionsAboveKeyboard() {
        // Get the list of default corpora from a resource, which allows vendor overlays.
        return mContext.getResources().getInteger(R.integer.num_suggestions_above_keyboard);
    }

    /**
     * The maximum number of suggestions to promote.
     */
    public int getMaxPromotedSuggestions() {
        return mContext.getResources().getInteger(R.integer.max_promoted_suggestions);
    }

    public int getMaxPromotedResults() {
        return mContext.getResources().getInteger(R.integer.max_promoted_results);
    }

    /**
     * The number of results to ask each source for.
     */
    public int getMaxResultsPerSource() {
        return MAX_RESULTS_PER_SOURCE;
    }

    /**
     * The maximum number of shortcuts to show for the web source in All mode.
     */
    public int getMaxShortcutsPerWebSource() {
        return mContext.getResources().getInteger(R.integer.max_shortcuts_per_web_source);
    }

    /**
     * The maximum number of shortcuts to show for each non-web source in All mode.
     */
    public int getMaxShortcutsPerNonWebSource() {
        return mContext.getResources().getInteger(R.integer.max_shortcuts_per_non_web_source);
    }

    /**
     * Gets the maximum number of shortcuts that will be shown from the given source.
     */
    public int getMaxShortcuts(String sourceName) {
        return getMaxShortcutsPerNonWebSource();
    }

    /**
     * The timeout for querying each source, in milliseconds.
     */
    public long getSourceTimeoutMillis() {
        return SOURCE_TIMEOUT_MILLIS;
    }

    /**
     * The priority of query threads.
     *
     * @return A thread priority, as defined in {@link Process}.
     */
    public int getQueryThreadPriority() {
        return QUERY_THREAD_PRIORITY;
    }

    /**
     * The maximum age of log data used for shortcuts.
     */
    public long getMaxStatAgeMillis(){
        return MAX_STAT_AGE_MILLIS;
    }

    /**
     * The minimum number of clicks needed to rank a source.
     */
    public int getMinClicksForSourceRanking(){
        return MIN_CLICKS_FOR_SOURCE_RANKING;
    }

    public int getNumWebCorpusThreads() {
        return NUM_WEB_CORPUS_THREADS;
    }

    /**
     * How often query latency should be logged.
     *
     * @return An integer in the range 0-1000. 0 means that no latency events
     *         should be logged. 1000 means that all latency events should be logged.
     */
    public int getLatencyLogFrequency() {
        return LATENCY_LOG_FREQUENCY;
    }

    /**
     * The delay in milliseconds before suggestions are updated while typing.
     * If a new character is typed before this timeout expires, the timeout is reset.
     */
    public long getTypingUpdateSuggestionsDelayMillis() {
        return TYPING_SUGGESTIONS_UPDATE_DELAY_MILLIS;
    }

    /**
     * The delay in milliseconds before corpus results are published.
     * If a new result arrives before this timeout expires, the timeout is reset.
     */
    public long getPublishResultDelayMillis() {
        return PUBLISH_RESULT_DELAY_MILLIS;
    }

    public boolean allowVoiceSearchHints() {
        return true;
    }

    /**
     * The period of time for which after installing voice search we should consider showing voice
     * search hints.
     *
     * @return The period in milliseconds.
     */
    public long getVoiceSearchHintActivePeriod() {
        return VOICE_SEARCH_HINT_ACTIVE_PERIOD;
    }

    /**
     * The time interval at which we should consider whether or not to show some voice search hints.
     *
     * @return The period in milliseconds.
     */
    public long getVoiceSearchHintUpdatePeriod() {
        return VOICE_SEARCH_HINT_UPDATE_INTERVAL;
    }

    /**
     * The time interval at which, on average, voice search hints are displayed.
     *
     * @return The period in milliseconds.
     */
    public long getVoiceSearchHintShowPeriod() {
        return VOICE_SEARCH_HINT_SHOW_PERIOD_MILLIS;
    }

    /**
     * The amount of time for which voice search hints are displayed in one go.
     *
     * @return The period in milliseconds.
     */
    public long getVoiceSearchHintVisibleTime() {
        return VOICE_SEARCH_HINT_VISIBLE_PERIOD;
    }

    /**
     * The period that we change voice search hints at while they're being displayed.
     *
     * @return The period in milliseconds.
     */
    public long getVoiceSearchHintChangePeriod() {
        return VOICE_SEARCH_HINT_CHANGE_PERIOD;
    }

    public boolean showSuggestionsForZeroQuery() {
        // Get the list of default corpora from a resource, which allows vendor overlays.
        return mContext.getResources().getBoolean(R.bool.show_zero_query_suggestions);
    }

    public boolean showShortcutsForZeroQuery() {
        // Get the list of default corpora from a resource, which allows vendor overlays.
        return mContext.getResources().getBoolean(R.bool.show_zero_query_shortcuts);
    }

    public boolean showScrollingSuggestions() {
        return mContext.getResources().getBoolean(R.bool.show_scrolling_suggestions);
    }

    public boolean showScrollingResults() {
        return mContext.getResources().getBoolean(R.bool.show_scrolling_results);
    }

    public Uri getHelpUrl(String activity) {
        return null;
    }

    public int getHttpConnectTimeout() {
        return HTTP_CONNECT_TIMEOUT_MILLIS;
    }

    public int getHttpReadTimeout() {
        return HTTP_READ_TIMEOUT_MILLIS;
    }

    public String getUserAgent() {
        return USER_AGENT;
    }
}
",False,74,3,30,4,4,31,3,L1
50,com.android.quicksearchbox.AbstractPromoter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

/**
 * Abstract {@link Promoter} that uses a {@link SuggestionFilter} to choose shortcuts.
 */
public abstract class AbstractPromoter implements Promoter {

    private final SuggestionFilter mFilter;
    private final Promoter mNext;
    private final Config mConfig;

    protected AbstractPromoter(SuggestionFilter filter, Promoter next, Config config) {
        mFilter = filter;
        mNext = next;
        mConfig = config;
    }

    public void pickPromoted(
            Suggestions suggestions, int maxPromoted, ListSuggestionCursor promoted) {
        doPickPromoted(suggestions, maxPromoted, promoted);
        if (mNext != null) {
            mNext.pickPromoted(suggestions, maxPromoted, promoted);
        }
    }

    protected abstract void doPickPromoted(
            Suggestions suggestions, int maxPromoted, ListSuggestionCursor promoted);

    protected Config getConfig() {
        return mConfig;
    }

    protected boolean accept(Suggestion s) {
        if (mFilter != null) {
            return mFilter.accept(s);
        } else {
            return true;
        }
    }

}
",False,62,5,19,4,9,2,6,L6
51,com.android.quicksearchbox.SuggestionCursorBackedCursor.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import android.app.SearchManager;
import android.database.AbstractCursor;
import android.database.CursorIndexOutOfBoundsException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

public class SuggestionCursorBackedCursor extends AbstractCursor {

    // This array also used in CursorBackedSuggestionExtras to avoid duplication.
    public static final String[] COLUMNS = {
        ""_id"",  // 0, This will contain the row number. CursorAdapter, used by SuggestionsAdapter,
                // used by SearchDialog, expects an _id column.
        SearchManager.SUGGEST_COLUMN_TEXT_1,  // 1
        SearchManager.SUGGEST_COLUMN_TEXT_2,  // 2
        SearchManager.SUGGEST_COLUMN_TEXT_2_URL,  // 3
        SearchManager.SUGGEST_COLUMN_ICON_1,  // 4
        SearchManager.SUGGEST_COLUMN_ICON_2,  // 5
        SearchManager.SUGGEST_COLUMN_INTENT_ACTION,  // 6
        SearchManager.SUGGEST_COLUMN_INTENT_DATA,  // 7
        SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA,  // 8
        SearchManager.SUGGEST_COLUMN_QUERY,  // 9
        SearchManager.SUGGEST_COLUMN_FORMAT,  // 10
        SearchManager.SUGGEST_COLUMN_SHORTCUT_ID,  // 11
        SearchManager.SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING,  // 12
    };

    private static final int COLUMN_INDEX_ID = 0;
    private static final int COLUMN_INDEX_TEXT1 = 1;
    private static final int COLUMN_INDEX_TEXT2 = 2;
    private static final int COLUMN_INDEX_TEXT2_URL = 3;
    private static final int COLUMN_INDEX_ICON1 = 4;
    private static final int COLUMN_INDEX_ICON2 = 5;
    private static final int COLUMN_INDEX_INTENT_ACTION = 6;
    private static final int COLUMN_INDEX_INTENT_DATA = 7;
    private static final int COLUMN_INDEX_INTENT_EXTRA_DATA = 8;
    private static final int COLUMN_INDEX_QUERY = 9;
    private static final int COLUMN_INDEX_FORMAT = 10;
    private static final int COLUMN_INDEX_SHORTCUT_ID = 11;
    private static final int COLUMN_INDEX_SPINNER_WHILE_REFRESHING = 12;

    private final SuggestionCursor mCursor;
    private ArrayList<String> mExtraColumns;

    public SuggestionCursorBackedCursor(SuggestionCursor cursor) {
        mCursor = cursor;
    }

    @Override
    public void close() {
        super.close();
        mCursor.close();
    }

    @Override
    public String[] getColumnNames() {
        Collection<String> extraColumns = mCursor.getExtraColumns();
        if (extraColumns != null) {
            ArrayList<String> allColumns = new ArrayList<String>(COLUMNS.length +
                    extraColumns.size());
            mExtraColumns = new ArrayList<String>(extraColumns);
            allColumns.addAll(Arrays.asList(COLUMNS));
            allColumns.addAll(mExtraColumns);
            return allColumns.toArray(new String[allColumns.size()]);
        } else {
            return COLUMNS;
        }
    }

    @Override
    public int getCount() {
        return mCursor.getCount();
    }

    private Suggestion get() {
        mCursor.moveTo(getPosition());
        return mCursor;
    }

    private String getExtra(int columnIdx) {
        int extraColumn = columnIdx - COLUMNS.length;
        SuggestionExtras extras = get().getExtras();
        if (extras != null) {
            return extras.getExtra(mExtraColumns.get(extraColumn));
        } else {
            return null;
        }
    }

    @Override
    public int getInt(int column) {
        if (column == COLUMN_INDEX_ID) {
            return getPosition();
        } else {
            try {
                return Integer.valueOf(getString(column));
            } catch (NumberFormatException e) {
                return 0;
            }
        }
    }

    @Override
    public String getString(int column) {
        if (column < COLUMNS.length) {
            switch (column) {
                case COLUMN_INDEX_ID:
                    return String.valueOf(getPosition());
                case COLUMN_INDEX_TEXT1:
                    return get().getSuggestionText1();
                case COLUMN_INDEX_TEXT2:
                    return get().getSuggestionText2();
                case COLUMN_INDEX_TEXT2_URL:
                    return get().getSuggestionText2Url();
                case COLUMN_INDEX_ICON1:
                    return get().getSuggestionIcon1();
                case COLUMN_INDEX_ICON2:
                    return get().getSuggestionIcon2();
                case COLUMN_INDEX_INTENT_ACTION:
                    return get().getSuggestionIntentAction();
                case COLUMN_INDEX_INTENT_DATA:
                    return get().getSuggestionIntentDataString();
                case COLUMN_INDEX_INTENT_EXTRA_DATA:
                    return get().getSuggestionIntentExtraData();
                case COLUMN_INDEX_QUERY:
                    return get().getSuggestionQuery();
                case COLUMN_INDEX_FORMAT:
                    return get().getSuggestionFormat();
                case COLUMN_INDEX_SHORTCUT_ID:
                    return get().getShortcutId();
                case COLUMN_INDEX_SPINNER_WHILE_REFRESHING:
                    return String.valueOf(get().isSpinnerWhileRefreshing());
                default:
                    throw new CursorIndexOutOfBoundsException(""Requested column "" + column
                            + "" of "" + COLUMNS.length);
            }
        } else {
            return getExtra(column);
        }
    }

    @Override
    public long getLong(int column) {
        try {
            return Long.valueOf(getString(column));
        } catch (NumberFormatException e) {
            return 0;
        }
    }

    @Override
    public boolean isNull(int column) {
        return getString(column) == null;
    }

    @Override
    public short getShort(int column) {
        try {
            return Short.valueOf(getString(column));
        } catch (NumberFormatException e) {
            return 0;
        }
    }

    @Override
    public double getDouble(int column) {
        try {
            return Double.valueOf(getString(column));
        } catch (NumberFormatException e) {
            return 0;
        }
    }

    @Override
    public float getFloat(int column) {
        try {
            return Float.valueOf(getString(column));
        } catch (NumberFormatException e) {
            return 0;
        }
    }
}
",True,48,8,17,5,4,3,3,L3
52,com.android.quicksearchbox.CorpusSelectionDialog.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.ui.CorporaAdapter;

import android.app.Dialog;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MotionEvent;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.widget.AdapterView;
import android.widget.GridView;
import android.widget.ImageView;

/**
 * Corpus selection dialog.
 */
public class CorpusSelectionDialog extends Dialog {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SelectSearchSourceDialog"";

    private final SearchSettings mSettings;

    private GridView mCorpusGrid;

    private ImageView mEditItems;

    private OnCorpusSelectedListener mListener;

    private Corpus mCorpus;

    private CorporaAdapter mAdapter;

    public CorpusSelectionDialog(Context context, SearchSettings settings) {
        super(context, R.style.Theme_SelectSearchSource);
        mSettings = settings;
    }

    protected SearchSettings getSettings() {
        return mSettings;
    }

    /**
     * Shows the corpus selection dialog.
     *
     * @param corpus The currently selected corpus.
     */
    public void show(Corpus corpus) {
        mCorpus = corpus;
        show();
    }

    public void setOnCorpusSelectedListener(OnCorpusSelectedListener listener) {
        mListener = listener;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        setContentView(R.layout.corpus_selection_dialog);
        mCorpusGrid = (GridView) findViewById(R.id.corpus_grid);
        mCorpusGrid.setOnItemClickListener(new CorpusClickListener());
        // TODO: for some reason, putting this in the XML layout instead makes
        // the list items unclickable.
        mCorpusGrid.setFocusable(true);

        mEditItems = (ImageView) findViewById(R.id.corpus_edit_items);
        mEditItems.setOnClickListener(new CorpusEditListener());

        Window window = getWindow();
        WindowManager.LayoutParams lp = window.getAttributes();
        lp.width = WindowManager.LayoutParams.MATCH_PARENT;
        lp.height = WindowManager.LayoutParams.MATCH_PARENT;
        // Put window on top of input method
        lp.flags |= WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
        window.setAttributes(lp);
        if (DBG) Log.d(TAG, ""Window params: "" + lp);
    }

    @Override
    protected void onStart() {
        super.onStart();
        Corpora corpora = getQsbApplication().getCorpora();
        CorporaAdapter adapter =
                new CorporaAdapter(getContext(), corpora, R.layout.corpus_grid_item);
        adapter.setCurrentCorpus(mCorpus);
        setAdapter(adapter);
        mCorpusGrid.setSelection(adapter.getCorpusPosition(mCorpus));
    }

    @Override
    protected void onStop() {
        setAdapter(null);
        super.onStop();
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        menu.clear();
        getSettings().addMenuItems(menu, true);
        return true;
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (event.getAction() == MotionEvent.ACTION_DOWN) {
            // Cancel dialog on any touch down event which is not handled by the corpus grid
            cancel();
            return true;
        }
        return false;
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        boolean handled = super.onKeyDown(keyCode, event);
        if (handled) {
            return handled;
        }
        // Dismiss dialog on up move when nothing, or an item on the top row, is selected.
        if (keyCode == KeyEvent.KEYCODE_DPAD_UP) {
            if (mEditItems.isFocused()) {
                cancel();
                return true;
            }
        }
        // Dismiss dialog when typing on hard keyboard (soft keyboard is behind the dialog,
        // so that can't be typed on)
        if (event.isPrintingKey()) {
            cancel();
            return true;
        }
        return false;
    }

    @Override
    public void onBackPressed() {
        SearchActivity searchActivity = getSearchActivity();
        if (searchActivity.startedIntoCorpusSelectionDialog()) {
            searchActivity.onBackPressed();
        }
        cancel();
    }

    private SearchActivity getSearchActivity() {
        return (SearchActivity) getOwnerActivity();
    }

    private void setAdapter(CorporaAdapter adapter) {
        if (adapter == mAdapter) return;
        if (mAdapter != null) mAdapter.close();
        mAdapter = adapter;
        mCorpusGrid.setAdapter(mAdapter);
    }

    private QsbApplication getQsbApplication() {
        return QsbApplication.get(getContext());
    }

    protected void selectCorpus(Corpus corpus) {
        dismiss();
        if (mListener != null) {
            String corpusName = corpus == null ? null : corpus.getName();
            mListener.onCorpusSelected(corpusName);
        }
    }

    private class CorpusClickListener implements AdapterView.OnItemClickListener {
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            Corpus corpus = (Corpus) parent.getItemAtPosition(position);
            if (DBG) Log.d(TAG, ""Corpus selected: "" + corpus);
            selectCorpus(corpus);
        }
    }

    private class CorpusEditListener implements View.OnClickListener {
        public void onClick(View v) {
            Intent intent = getSettings().getSearchableItemsIntent();
            getContext().startActivity(intent);
        }
    }

    public interface OnCorpusSelectedListener {
        void onCorpusSelected(String corpusName);
    }
}
",False,130,1,1,6,60,2,7,L9
53,com.android.quicksearchbox.CachingIconLoader.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.CachedLater;
import com.android.quicksearchbox.util.Consumer;
import com.android.quicksearchbox.util.Now;
import com.android.quicksearchbox.util.NowOrLater;
import com.android.quicksearchbox.util.NowOrLaterWrapper;

import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.text.TextUtils;
import android.util.Log;

import java.util.WeakHashMap;

/**
 * Icon loader that caches the results of another icon loader.
 *
 */
public class CachingIconLoader implements IconLoader {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.CachingIconLoader"";

    private final IconLoader mWrapped;

    private final WeakHashMap<String, Entry> mIconCache;

    /**
     * Creates a new caching icon loader.
     *
     * @param wrapped IconLoader whose results will be cached.
     */
    public CachingIconLoader(IconLoader wrapped) {
        mWrapped = wrapped;
        mIconCache = new WeakHashMap<String, Entry>();
    }

    public NowOrLater<Drawable> getIcon(String drawableId) {
        if (DBG) Log.d(TAG, ""getIcon("" + drawableId + "")"");
        if (TextUtils.isEmpty(drawableId) || ""0"".equals(drawableId)) {
            return new Now<Drawable>(null);
        }
        Entry newEntry = null;
        NowOrLater<Drawable.ConstantState> drawableState;
        synchronized (this) {
            drawableState = queryCache(drawableId);
            if (drawableState == null) {
                newEntry = new Entry();
                storeInIconCache(drawableId, newEntry);
            }
        }
        if (drawableState != null) {
            return new NowOrLaterWrapper<Drawable.ConstantState, Drawable>(drawableState){
                @Override
                public Drawable get(Drawable.ConstantState value) {
                    return value == null ? null : value.newDrawable();
                }};
        }
        NowOrLater<Drawable> drawable = mWrapped.getIcon(drawableId);
        newEntry.set(drawable);
        storeInIconCache(drawableId, newEntry);
        return drawable;
    }

    public Uri getIconUri(String drawableId) {
        return mWrapped.getIconUri(drawableId);
    }

    private synchronized NowOrLater<Drawable.ConstantState> queryCache(String drawableId) {
        NowOrLater<Drawable.ConstantState> cached = mIconCache.get(drawableId);
        if (DBG) {
            if (cached != null) Log.d(TAG, ""Found icon in cache: "" + drawableId);
        }
        return cached;
    }

    private synchronized void storeInIconCache(String resourceUri, Entry drawable) {
        if (drawable != null) {
            mIconCache.put(resourceUri, drawable);
        }
    }

    private static class Entry extends CachedLater<Drawable.ConstantState>
            implements Consumer<Drawable>{
        private NowOrLater<Drawable> mDrawable;
        private boolean mGotDrawable;
        private boolean mCreateRequested;

        public Entry() {
        }

        public synchronized void set(NowOrLater<Drawable> drawable) {
            if (mGotDrawable) throw new IllegalStateException(""set() may only be called once."");
            mGotDrawable = true;
            mDrawable = drawable;
            if (mCreateRequested) {
                getLater();
            }
        }

        @Override
        protected synchronized void create() {
            if (!mCreateRequested) {
                mCreateRequested = true;
                if (mGotDrawable) {
                    getLater();
                }
            }
        }

        private void getLater() {
            NowOrLater<Drawable> drawable = mDrawable;
            mDrawable = null;
            drawable.getLater(this);
        }

        public boolean consume(Drawable value) {
            store(value == null ? null : value.getConstantState());
            return true;
        }
    }

}
",False,40,5,17,1,6,2,6,L2
54,com.android.quicksearchbox.MultiSourceCorpus.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


import com.android.quicksearchbox.util.BarrierConsumer;

import android.content.Context;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.Executor;

/**
 * Base class for corpora backed by multiple sources.
 */
public abstract class MultiSourceCorpus extends AbstractCorpus {

    private final Executor mExecutor;

    private final ArrayList<Source> mSources;

    // calculated values based on properties of sources:
    private boolean mSourcePropertiesValid;
    private int mQueryThreshold;
    private boolean mQueryAfterZeroResults;
    private boolean mVoiceSearchEnabled;
    private boolean mIncludeInAll;

    public MultiSourceCorpus(Context context, Config config,
            Executor executor, Source... sources) {
        super(context, config);
        mExecutor = executor;

        mSources = new ArrayList<Source>();
        for (Source source : sources) {
            addSource(source);
        }

    }

    protected void addSource(Source source) {
        if (source != null) {
            mSources.add(source);
            // invalidate calculated values:
            mSourcePropertiesValid = false;
        }
    }

    public Collection<Source> getSources() {
        return mSources;
    }

    /**
     * Creates a corpus result object for a set of source results.
     * This method should not call {@link Result#fill}.
     *
     * @param query The query text.
     * @param results The results of the queries.
     * @param latency Latency in milliseconds of the suggestion queries.
     * @return An instance of {@link Result} or a subclass of it.
     */
    protected Result createResult(String query, ArrayList<SourceResult> results, int latency) {
        return new Result(query, results, latency);
    }

    /**
     * Gets the sources to query for suggestions for the given input.
     *
     * @param query The current input.
     * @param onlyCorpus If true, this is the only corpus being queried.
     * @return The sources to query.
     */
    protected List<Source> getSourcesToQuery(String query, boolean onlyCorpus) {
        List<Source> sources = new ArrayList<Source>();
        for (Source candidate : getSources()) {
            if (candidate.getQueryThreshold() <= query.length()) {
                sources.add(candidate);
            }
        }
        return sources;
    }

    private void updateSourceProperties() {
        if (mSourcePropertiesValid) return;
        mQueryThreshold = Integer.MAX_VALUE;
        mQueryAfterZeroResults = false;
        mVoiceSearchEnabled = false;
        mIncludeInAll = false;
        for (Source s : getSources()) {
            mQueryThreshold = Math.min(mQueryThreshold, s.getQueryThreshold());
            mQueryAfterZeroResults |= s.queryAfterZeroResults();
            mVoiceSearchEnabled |= s.voiceSearchEnabled();
            mIncludeInAll |= s.includeInAll();
        }
        if (mQueryThreshold == Integer.MAX_VALUE) {
            mQueryThreshold = 0;
        }
        mSourcePropertiesValid = true;
    }

    public int getQueryThreshold() {
        updateSourceProperties();
        return mQueryThreshold;
    }

    public boolean queryAfterZeroResults() {
        updateSourceProperties();
        return mQueryAfterZeroResults;
    }

    public boolean voiceSearchEnabled() {
        updateSourceProperties();
        return mVoiceSearchEnabled;
    }

    public boolean includeInAll() {
        updateSourceProperties();
        return mIncludeInAll;
    }

    public CorpusResult getSuggestions(String query, int queryLimit, boolean onlyCorpus) {
        LatencyTracker latencyTracker = new LatencyTracker();
        List<Source> sources = getSourcesToQuery(query, onlyCorpus);
        BarrierConsumer<SourceResult> consumer =
                new BarrierConsumer<SourceResult>(sources.size());
        boolean onlySource = sources.size() == 1;
        for (Source source : sources) {
            QueryTask<SourceResult> task = new QueryTask<SourceResult>(query, queryLimit,
                    source, null, consumer, onlySource);
            mExecutor.execute(task);
        }
        ArrayList<SourceResult> results = consumer.getValues();
        int latency = latencyTracker.getLatency();
        Result result = createResult(query, results, latency);
        result.fill();
        return result;
    }

    /**
     * Base class for results returned by {@link MultiSourceCorpus#getSuggestions}.
     * Subclasses of {@link MultiSourceCorpus} should override
     * {@link MultiSourceCorpus#createResult} and return an instance of this class or a
     * subclass.
     */
    protected class Result extends ListSuggestionCursor implements CorpusResult {

        private final ArrayList<SourceResult> mResults;

        private final int mLatency;

        public Result(String userQuery, ArrayList<SourceResult> results, int latency) {
            super(userQuery);
            mResults = results;
            mLatency = latency;
        }

        protected ArrayList<SourceResult> getResults() {
            return mResults;
        }

        /**
         * Fills the list of suggestions using the list of results.
         * The default implementation concatenates the results.
         */
        public void fill() {
            for (SourceResult result : getResults()) {
                int count = result.getCount();
                for (int i = 0; i < count; i++) {
                    result.moveTo(i);
                    add(new SuggestionPosition(result));
                }
            }
        }

        public Corpus getCorpus() {
            return MultiSourceCorpus.this;
        }

        public int getLatency() {
            return mLatency;
        }

        @Override
        public void close() {
            super.close();
            for (SourceResult result : mResults) {
                result.close();
            }
        }

        @Override
        public String toString() {
            return ""{"" + getCorpus() + ""["" + getUserQuery() + ""]"" + "";n="" + getCount() + ""}"";
        }
    }

}
",False,58,6,19,2,13,2,13,L4
55,com.android.quicksearchbox.DialogActivity.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.view.Window;
import android.widget.FrameLayout;
import android.widget.TextView;

/**
 * Activity that looks like a dialog window.
 */
public abstract class DialogActivity extends Activity {

    protected TextView mTitleView;
    protected FrameLayout mContentFrame;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        getWindow().requestFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.dialog_activity);
        mTitleView = (TextView) findViewById(R.id.alertTitle);
        mContentFrame = (FrameLayout) findViewById(R.id.content);
    }

    public void setHeading(int titleRes) {
        mTitleView.setText(titleRes);
    }

    public void setHeading(CharSequence title) {
        mTitleView.setText(title);
    }

    public void setDialogContent(int layoutRes) {
        mContentFrame.removeAllViews();
        getLayoutInflater().inflate(layoutRes, mContentFrame);
    }

    public void setDialogContent(View content) {
        mContentFrame.removeAllViews();
        mContentFrame.addView(content);
    }

    public View getDialogContent() {
        if (mContentFrame.getChildCount() > 0) {
            return mContentFrame.getChildAt(0);
        } else {
            return null;
        }
    }

}
",False,1,0,0,0,0,0,0,I0
56,com.android.quicksearchbox.Suggestion.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import android.content.ComponentName;

/**
 * Interface for individual suggestions.
 */
public interface Suggestion {

    /**
     * Gets the source that produced the current suggestion.
     */
    Source getSuggestionSource();

    /**
     * Gets the shortcut ID of the current suggestion.
     */
    String getShortcutId();

    /**
     * Whether to show a spinner while refreshing this shortcut.
     */
    boolean isSpinnerWhileRefreshing();

    /**
     * Gets the format of the text returned by {@link #getSuggestionText1()}
     * and {@link #getSuggestionText2()}.
     *
     * @return {@code null} or ""html""
     */
    String getSuggestionFormat();

    /**
     * Gets the first text line for the current suggestion.
     */
    String getSuggestionText1();

    /**
     * Gets the second text line for the current suggestion.
     */
    String getSuggestionText2();

    /**
     * Gets the second text line URL for the current suggestion.
     */
    String getSuggestionText2Url();

    /**
     * Gets the left-hand-side icon for the current suggestion.
     *
     * @return A string that can be passed to {@link Source#getIcon(String)}.
     */
    String getSuggestionIcon1();

    /**
     * Gets the right-hand-side icon for the current suggestion.
     *
     * @return A string that can be passed to {@link Source#getIcon(String)}.
     */
    String getSuggestionIcon2();

    /**
     * Gets the intent action for the current suggestion.
     */
    String getSuggestionIntentAction();

    /**
     * Gets the name of the activity that the intent for the current suggestion will be sent to.
     */
    ComponentName getSuggestionIntentComponent();

    /**
     * Gets the extra data associated with this suggestion's intent.
     */
    String getSuggestionIntentExtraData();

    /**
     * Gets the data associated with this suggestion's intent.
     */
    String getSuggestionIntentDataString();

    /**
     * Gets the query associated with this suggestion's intent.
     */
    String getSuggestionQuery();

    /**
     * Gets the suggestion log type for the current suggestion. This is logged together
     * with the value returned from {@link Source#getName()}.
     * The value is source-specific. Most sources return {@code null}.
     */
    String getSuggestionLogType();

    /**
     * Checks if this suggestion is a shortcut.
     */
    boolean isSuggestionShortcut();

    /**
     * Checks if this is a web search suggestion.
     */
    boolean isWebSearchSuggestion();

    /**
     * Checks whether this suggestion comes from the user's search history.
     */
    boolean isHistorySuggestion();

    /**
     * Returns any extras associated with this suggestion, or {@code null} if there are none.
     */
    SuggestionExtras getExtras();

}
",False,112,5,38,4,5,39,2,L1
57,com.android.quicksearchbox.SuggestionData.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.google.common.annotations.VisibleForTesting;

import android.content.ComponentName;
import android.content.Intent;


/**
 * Holds data for each suggest item including the display data and how to launch the result.
 * Used for passing from the provider to the suggest cursor.
 */
public class SuggestionData implements Suggestion {

    private final Source mSource;
    private String mFormat;
    private String mText1;
    private String mText2;
    private String mText2Url;
    private String mIcon1;
    private String mIcon2;
    private String mShortcutId;
    private boolean mSpinnerWhileRefreshing;
    private String mIntentAction;
    private String mIntentData;
    private String mIntentExtraData;
    private String mSuggestionQuery;
    private String mLogType;
    private boolean mIsShortcut;
    private boolean mIsHistory;
    private SuggestionExtras mExtras;

    public SuggestionData(Source source) {
        mSource = source;
    }

    public Source getSuggestionSource() {
        return mSource;
    }

    public String getSuggestionFormat() {
        return mFormat;
    }

    public String getSuggestionText1() {
        return mText1;
    }

    public String getSuggestionText2() {
        return mText2;
    }

    public String getSuggestionText2Url() {
        return mText2Url;
    }

    public String getSuggestionIcon1() {
        return mIcon1;
    }

    public String getSuggestionIcon2() {
        return mIcon2;
    }

    public boolean isSpinnerWhileRefreshing() {
        return mSpinnerWhileRefreshing;
    }

    public String getIntentExtraData() {
        return mIntentExtraData;
    }

    public String getShortcutId() {
        return mShortcutId;
    }

    public String getSuggestionIntentAction() {
        if (mIntentAction != null) return mIntentAction;
        return mSource.getDefaultIntentAction();
    }

    public ComponentName getSuggestionIntentComponent() {
        return mSource.getIntentComponent();
    }

    public String getSuggestionIntentDataString() {
        return mIntentData;
    }

    public String getSuggestionIntentExtraData() {
        return mIntentExtraData;
    }

    public String getSuggestionQuery() {
        return mSuggestionQuery;
    }

    public String getSuggestionLogType() {
        return mLogType;
    }

    public boolean isSuggestionShortcut() {
        return mIsShortcut;
    }

    public boolean isWebSearchSuggestion() {
        return Intent.ACTION_WEB_SEARCH.equals(getSuggestionIntentAction());
    }

    public boolean isHistorySuggestion() {
        return mIsHistory;
    }

    @VisibleForTesting
    public SuggestionData setFormat(String format) {
        mFormat = format;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setText1(String text1) {
        mText1 = text1;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setText2(String text2) {
        mText2 = text2;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setText2Url(String text2Url) {
        mText2Url = text2Url;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIcon1(String icon1) {
        mIcon1 = icon1;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIcon2(String icon2) {
        mIcon2 = icon2;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIntentAction(String intentAction) {
        mIntentAction = intentAction;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIntentData(String intentData) {
        mIntentData = intentData;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIntentExtraData(String intentExtraData) {
        mIntentExtraData = intentExtraData;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setSuggestionQuery(String suggestionQuery) {
        mSuggestionQuery = suggestionQuery;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setShortcutId(String shortcutId) {
        mShortcutId = shortcutId;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setSpinnerWhileRefreshing(boolean spinnerWhileRefreshing) {
        mSpinnerWhileRefreshing = spinnerWhileRefreshing;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setSuggestionLogType(String logType) {
        mLogType = logType;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIsShortcut(boolean isShortcut) {
        mIsShortcut = isShortcut;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIsHistory(boolean isHistory) {
        mIsHistory = isHistory;
        return this;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((mFormat == null) ? 0 : mFormat.hashCode());
        result = prime * result + ((mIcon1 == null) ? 0 : mIcon1.hashCode());
        result = prime * result + ((mIcon2 == null) ? 0 : mIcon2.hashCode());
        result = prime * result + ((mIntentAction == null) ? 0 : mIntentAction.hashCode());
        result = prime * result + ((mIntentData == null) ? 0 : mIntentData.hashCode());
        result = prime * result + ((mIntentExtraData == null) ? 0 : mIntentExtraData.hashCode());
        result = prime * result + ((mLogType == null) ? 0 : mLogType.hashCode());
        result = prime * result + ((mShortcutId == null) ? 0 : mShortcutId.hashCode());
        result = prime * result + ((mSource == null) ? 0 : mSource.hashCode());
        result = prime * result + (mSpinnerWhileRefreshing ? 1231 : 1237);
        result = prime * result + ((mSuggestionQuery == null) ? 0 : mSuggestionQuery.hashCode());
        result = prime * result + ((mText1 == null) ? 0 : mText1.hashCode());
        result = prime * result + ((mText2 == null) ? 0 : mText2.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        SuggestionData other = (SuggestionData)obj;
        if (mFormat == null) {
            if (other.mFormat != null)
                return false;
        } else if (!mFormat.equals(other.mFormat))
            return false;
        if (mIcon1 == null) {
            if (other.mIcon1 != null)
                return false;
        } else if (!mIcon1.equals(other.mIcon1))
            return false;
        if (mIcon2 == null) {
            if (other.mIcon2 != null)
                return false;
        } else if (!mIcon2.equals(other.mIcon2))
            return false;
        if (mIntentAction == null) {
            if (other.mIntentAction != null)
                return false;
        } else if (!mIntentAction.equals(other.mIntentAction))
            return false;
        if (mIntentData == null) {
            if (other.mIntentData != null)
                return false;
        } else if (!mIntentData.equals(other.mIntentData))
            return false;
        if (mIntentExtraData == null) {
            if (other.mIntentExtraData != null)
                return false;
        } else if (!mIntentExtraData.equals(other.mIntentExtraData))
            return false;
        if (mLogType == null) {
            if (other.mLogType != null)
                return false;
        } else if (!mLogType.equals(other.mLogType))
            return false;
        if (mShortcutId == null) {
            if (other.mShortcutId != null)
                return false;
        } else if (!mShortcutId.equals(other.mShortcutId))
            return false;
        if (mSource == null) {
            if (other.mSource != null)
                return false;
        } else if (!mSource.equals(other.mSource))
            return false;
        if (mSpinnerWhileRefreshing != other.mSpinnerWhileRefreshing)
            return false;
        if (mSuggestionQuery == null) {
            if (other.mSuggestionQuery != null)
                return false;
        } else if (!mSuggestionQuery.equals(other.mSuggestionQuery))
            return false;
        if (mText1 == null) {
            if (other.mText1 != null)
                return false;
        } else if (!mText1.equals(other.mText1))
            return false;
        if (mText2 == null) {
            if (other.mText2 != null)
                return false;
        } else if (!mText2.equals(other.mText2))
            return false;
        return true;
    }

    /**
     * Returns a string representation of the contents of this SuggestionData,
     * for debugging purposes.
     */
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder(""SuggestionData("");
        appendField(builder, ""source"", mSource.getName());
        appendField(builder, ""text1"", mText1);
        appendField(builder, ""intentAction"", mIntentAction);
        appendField(builder, ""intentData"", mIntentData);
        appendField(builder, ""query"", mSuggestionQuery);
        appendField(builder, ""shortcutid"", mShortcutId);
        appendField(builder, ""logtype"", mLogType);
        return builder.toString();
    }

    private void appendField(StringBuilder builder, String name, String value) {
        if (value != null) {
            builder.append("","").append(name).append(""="").append(value);
        }
    }

    @VisibleForTesting
    public void setExtras(SuggestionExtras extras) {
        mExtras = extras;
    }

    public SuggestionExtras getExtras() {
        return mExtras;
    }

}
",True,31,3,11,4,4,4,4,L2
58,com.android.quicksearchbox.SuggestionExtras.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import org.json.JSONException;

import java.util.Collection;

/**
 * Extra data that can be attached to a suggestion.
 */
public interface SuggestionExtras {

    /**
     * Return the names of custom columns present in these extras.
     */
    Collection<String> getExtraColumnNames();

    /**
     * @param columnName The column to get a value from.
     */
    String getExtra(String columnName);

    /**
     * Flatten these extras as a JSON object.
     */
    String toJsonString() throws JSONException;

}
",False,134,5,53,0,0,12,0,L1
59,com.android.quicksearchbox.VoiceSearch.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import android.app.SearchManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ComponentInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.ResolveInfo;
import android.os.Bundle;
import android.speech.RecognizerIntent;
import android.util.Log;

/**
 * Voice Search integration.
 */
public class VoiceSearch {

    private static final String TAG = ""QSB.VoiceSearch"";

    private final Context mContext;

    public VoiceSearch(Context context) {
        mContext = context;
    }

    protected Context getContext() {
        return mContext;
    }

    public boolean shouldShowVoiceSearch(Corpus corpus) {
        return corpusSupportsVoiceSearch(corpus) && isVoiceSearchAvailable();
    }

    protected boolean corpusSupportsVoiceSearch(Corpus corpus) {
        return (corpus == null || corpus.voiceSearchEnabled());
    }

    protected Intent createVoiceSearchIntent() {
        return new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
    }

    private ResolveInfo getResolveInfo() {
        Intent intent = createVoiceSearchIntent();
        ResolveInfo ri = mContext.getPackageManager().
                resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
        return ri;
    }

    public boolean isVoiceSearchAvailable() {
        return getResolveInfo() != null;
    }

    public Intent createVoiceWebSearchIntent(Bundle appData) {
        if (!isVoiceSearchAvailable()) return null;
        Intent intent = createVoiceSearchIntent();
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,
                RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);
        if (appData != null) {
            intent.putExtra(SearchManager.APP_DATA, appData);
        }
        return intent;
    }

    /**
     * Create an intent to launch the voice search help screen, if any exists.
     * @return The intent, or null.
     */
    public Intent createVoiceSearchHelpIntent() {
        return null;
    }

    /**
     * Gets the {@code versionCode} of the currently installed voice search package.
     *
     * @return The {@code versionCode} of voiceSearch, or 0 if none is installed.
     */
    public int getVersion() {
        ResolveInfo ri = getResolveInfo();
        if (ri == null) return 0;
        ComponentInfo ci = ri.activityInfo != null ? ri.activityInfo : ri.serviceInfo;
        try {
            return getContext().getPackageManager().getPackageInfo(ci.packageName, 0).versionCode;
        } catch (NameNotFoundException e) {
            Log.e(TAG, ""Cannot find voice search package "" + ci.packageName, e);
            return 0;
        }
    }

    public ComponentName getComponent() {
        return createVoiceSearchIntent().resolveActivity(getContext().getPackageManager());
    }
}
",False,45,3,19,5,4,5,1,L8
60,com.android.quicksearchbox.Source.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.NowOrLater;

import android.content.ComponentName;
import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;

/**
 * Interface for suggestion sources.
 *
 */
public interface Source extends SuggestionCursorProvider<SourceResult> {

    /**
     * Gets the name activity that intents from this source are sent to.
     */
    ComponentName getIntentComponent();

    /**
     * Gets the suggestion URI for getting suggestions from this Source.
     */
    String getSuggestUri();

    /**
     * Gets the version code of the source. This is expected to change when the app that
     * this source is for is upgraded.
     */
    int getVersionCode();

    /**
     * Indicates if shortcuts from the given version of this source are compatible with the
     * currently installed version. The version code given will only differ from the currently
     * installed version after the source has been upgraded.
     *
     * @param version version of the source (as returned by {@link #getVersionCode} which originally
     *      created the shortcut.
     */
    boolean isVersionCodeCompatible(int version);

    /**
     * Gets the localized, human-readable label for this source.
     */
    CharSequence getLabel();

    /**
     * Gets the icon for this suggestion source.
     */
    Drawable getSourceIcon();

    /**
     * Gets the icon URI for this suggestion source.
     */
    Uri getSourceIconUri();

    /**
     * Gets an icon from this suggestion source.
     *
     * @param drawableId Resource ID or URI.
     */
    NowOrLater<Drawable> getIcon(String drawableId);

    /**
     * Gets the URI for an icon form this suggestion source.
     *
     * @param drawableId Resource ID or URI.
     */
    Uri getIconUri(String drawableId);

    /**
     * Gets the search hint text for this suggestion source.
     */
    CharSequence getHint();

    /**
     * Gets the description to use for this source in system search settings.
     */
    CharSequence getSettingsDescription();

    /**
     *
     *  Note: this does not guarantee that this source will be queried for queries of
     *  this length or longer, only that it will not be queried for anything shorter.
     *
     * @return The minimum number of characters needed to trigger this source.
     */
    int getQueryThreshold();

    /**
     * Indicates whether a source should be invoked for supersets of queries it has returned zero
     * results for in the past.  For example, if a source returned zero results for ""bo"", it would
     * be ignored for ""bob"".
     *
     * If set to <code>false</code>, this source will only be ignored for a single session; the next
     * time the search dialog is brought up, all sources will be queried.
     *
     * @return <code>true</code> if this source should be queried after returning no results.
     */
    boolean queryAfterZeroResults();

    boolean voiceSearchEnabled();

    /**
     * Whether this source should be included in the blended All mode. The source must
     * also be enabled to be included in All.
     */
    boolean includeInAll();

    /**
     * Gets the maximum number of shortcuts that will be shown from this source.
     */
    int getMaxShortcuts(Config config);

    Intent createSearchIntent(String query, Bundle appData);

    Intent createVoiceSearchIntent(Bundle appData);

    /**
     * Checks if the current process can read the suggestions from this source.
     */
    boolean canRead();

    /**
     * Gets suggestions from this source.
     *
     * @param query The user query.
     * @param onlySource Indicates if this is the only source being queried.
     * @return The suggestion results.
     */
    SourceResult getSuggestions(String query, int queryLimit, boolean onlySource);

    /**
     * Updates a shortcut.
     *
     * @param shortcutId The id of the shortcut to update.
     * @param extraData associated with this shortcut.
     * @return A SuggestionCursor positioned at the updated shortcut.  If the
     *         cursor is empty or <code>null</code>, the shortcut will be removed.
     */
    SuggestionCursor refreshShortcut(String shortcutId, String extraData);

    /**
     * Gets the default intent action for suggestions from this source.
     *
     * @return The default intent action, or {@code null}.
     */
    String getDefaultIntentAction();

    /**
     * Gets the default intent data for suggestions from this source.
     *
     * @return The default intent data, or {@code null}.
     */
    String getDefaultIntentData();

    /**
     * Gets the root source, if this source is a wrapper around another. Otherwise, returns this
     * source.
     */
    Source getRoot();

}
",False,116,5,39,3,5,43,5,L1
61,com.android.quicksearchbox.JsonBackedSuggestionExtras.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import org.json.JSONException;
import org.json.JSONObject;

import android.util.Log;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/**
 * SuggestionExtras taking values from a {@link JSONObject}.
 */
public class JsonBackedSuggestionExtras implements SuggestionExtras {
    private static final String TAG = ""QSB.JsonBackedSuggestionExtras"";

    private final JSONObject mExtras;
    private final Collection<String> mColumns;

    public JsonBackedSuggestionExtras(String json) throws JSONException {
        mExtras = new JSONObject(json);
        mColumns = new ArrayList<String>(mExtras.length());
        Iterator<String> it = mExtras.keys();
        while (it.hasNext()) {
            mColumns.add(it.next());
        }
    }

    public JsonBackedSuggestionExtras(SuggestionExtras extras) throws JSONException {
        mExtras = new JSONObject();
        mColumns = extras.getExtraColumnNames();
        for (String column : extras.getExtraColumnNames()) {
            String value = extras.getExtra(column);
            mExtras.put(column, value == null ? JSONObject.NULL : value);
        }
    }

    public String getExtra(String columnName) {
        try {
            if (mExtras.isNull(columnName)) {
                return null;
            } else {
                return mExtras.getString(columnName);
            }
        } catch (JSONException e) {
            Log.w(TAG, ""Could not extract JSON extra"", e);
            return null;
        }
    }

    public Collection<String> getExtraColumnNames() {
        return mColumns;
    }

    @Override
    public String toString() {
        return mExtras.toString();
    }

    public String toJsonString() {
        return toString();
    }

}
",False,41,5,20,1,1,2,1,L2
62,com.android.quicksearchbox.IconLoader.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.NowOrLater;

import android.content.ContentResolver;
import android.graphics.drawable.Drawable;
import android.net.Uri;

/**
 * Interface for icon loaders.
 *
 */
public interface IconLoader {

    /**
     * Gets a drawable given an ID.
     *
     * The ID could be just the string value of a resource id
     * (e.g., ""2130837524""), in which case we will try to retrieve a drawable from
     * the provider's resources. If the ID is not an integer, it is
     * treated as a Uri and opened with
     * {@link ContentResolver#openOutputStream(android.net.Uri, String)}.
     *
     * All resources and URIs are read using the suggestion provider's context.
     *
     * @return a {@link NowOrLater} for retrieving the icon. If the ID is not formatted as expected,
     *      or no drawable can be found for the provided value, the value from this will be null.
     *
     * @param drawableId a string like ""2130837524"",
     *        ""android.resource://com.android.alarmclock/2130837524"",
     *        or ""content://contacts/photos/253"".
     */
    NowOrLater<Drawable> getIcon(String drawableId);

    /**
     * Converts a drawable ID to a Uri that can be used from other packages.
     */
    Uri getIconUri(String drawableId);

}
",False,41,5,17,2,1,7,1,L1
63,com.android.quicksearchbox.ListSuggestionCursor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.google.common.annotations.VisibleForTesting;

import android.database.DataSetObservable;
import android.database.DataSetObserver;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;

/**
 * A SuggestionCursor that is backed by a list of Suggestions.
 */
public class ListSuggestionCursor extends AbstractSuggestionCursorWrapper {

    private static final int DEFAULT_CAPACITY = 16;

    private final DataSetObservable mDataSetObservable = new DataSetObservable();

    private final ArrayList<Entry> mSuggestions;

    private HashSet<String> mExtraColumns;

    private int mPos = 0;

    public ListSuggestionCursor(String userQuery) {
        this(userQuery, DEFAULT_CAPACITY);
    }

    @VisibleForTesting
    public ListSuggestionCursor(String userQuery, Suggestion...suggestions) {
        this(userQuery, suggestions.length);
        for (Suggestion suggestion : suggestions) {
            add(suggestion);
        }
    }

    public ListSuggestionCursor(String userQuery, int capacity) {
        super(userQuery);
        mSuggestions = new ArrayList<Entry>(capacity);
    }

    /**
     * Adds a suggestion from another suggestion cursor.
     *
     * @return {@code true} if the suggestion was added.
     */
    public boolean add(Suggestion suggestion) {
        mSuggestions.add(new Entry(suggestion));
        return true;
    }

    public void close() {
        mSuggestions.clear();
    }

    public int getPosition() {
        return mPos;
    }

    public void moveTo(int pos) {
        mPos = pos;
    }

    public boolean moveToNext() {
        int size = mSuggestions.size();
        if (mPos >= size) {
            // Already past the end
            return false;
        }
        mPos++;
        return mPos < size;
    }

    public void removeRow() {
        mSuggestions.remove(mPos);
    }

    public void replaceRow(Suggestion suggestion) {
        mSuggestions.set(mPos, new Entry(suggestion));
    }

    public int getCount() {
        return mSuggestions.size();
    }

    @Override
    protected Suggestion current() {
        return mSuggestions.get(mPos).get();
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + ""{["" + getUserQuery() + ""] "" + mSuggestions + ""}"";
    }

    /**
     * Register an observer that is called when changes happen to this data set.
     *
     * @param observer gets notified when the data set changes.
     */
    public void registerDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.registerObserver(observer);
    }

    /**
     * Unregister an observer that has previously been registered with 
     * {@link #registerDataSetObserver(DataSetObserver)}
     *
     * @param observer the observer to unregister.
     */
    public void unregisterDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.unregisterObserver(observer);
    }

    protected void notifyDataSetChanged() {
        mDataSetObservable.notifyChanged();
    }

    @Override
    public SuggestionExtras getExtras() {
        // override with caching to avoid re-parsing the extras
        return mSuggestions.get(mPos).getExtras();
    }

   public Collection<String> getExtraColumns() {
        if (mExtraColumns == null) {
            mExtraColumns = new HashSet<String>();
            for (Entry e : mSuggestions) {
                SuggestionExtras extras = e.getExtras();
                Collection<String> extraColumns = extras == null ? null
                        : extras.getExtraColumnNames();
                if (extraColumns != null) {
                    for (String column : extras.getExtraColumnNames()) {
                        mExtraColumns.add(column);
                    }
                }
            }
        }
        return mExtraColumns.isEmpty() ? null : mExtraColumns;
    }

    /**
     * This class exists purely to cache the suggestion extras.
     */
    private static class Entry {
        private final Suggestion mSuggestion;
        private SuggestionExtras mExtras;
        public Entry(Suggestion s) {
            mSuggestion = s;
        }
        public Suggestion get() {
            return mSuggestion;
        }
        public SuggestionExtras getExtras() {
            if (mExtras == null) {
                mExtras = mSuggestion.getExtras();
            }
            return mExtras;
        }
    }

}
",True,96,5,25,5,5,25,3,L2
64,com.android.quicksearchbox.LevenshteinSuggestionFormatter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.LevenshteinDistance;
import com.android.quicksearchbox.util.LevenshteinDistance.Token;
import com.google.common.annotations.VisibleForTesting;

import android.text.SpannableString;
import android.text.Spanned;
import android.util.Log;

/**
 * Suggestion formatter using the Levenshtein distance (minumum edit distance) to calculate the
 * formatting.
 */
public class LevenshteinSuggestionFormatter extends SuggestionFormatter {
    private static final boolean DBG = false;
    private static final String TAG = ""QSB.LevenshteinSuggestionFormatter"";

    public LevenshteinSuggestionFormatter(TextAppearanceFactory spanFactory) {
        super(spanFactory);
    }

    @Override
    public Spanned formatSuggestion(String query, String suggestion) {
        if (DBG) Log.d(TAG, ""formatSuggestion('"" + query + ""', '"" + suggestion + ""')"");
        query = normalizeQuery(query);
        final Token[] queryTokens = tokenize(query);
        final Token[] suggestionTokens = tokenize(suggestion);
        final int[] matches = findMatches(queryTokens, suggestionTokens);
        if (DBG){
            Log.d(TAG, ""source = "" + queryTokens);
            Log.d(TAG, ""target = "" + suggestionTokens);
            Log.d(TAG, ""matches = "" + matches);
        }
        final SpannableString str = new SpannableString(suggestion);

        final int matchesLen = matches.length;
        for (int i = 0; i < matchesLen; ++i) {
            final Token t = suggestionTokens[i];
            int sourceLen = 0;
            int thisMatch = matches[i];
            if (thisMatch >= 0) {
                sourceLen = queryTokens[thisMatch].length();
            }
            applySuggestedTextStyle(str, t.mStart + sourceLen, t.mEnd);
            applyQueryTextStyle(str, t.mStart, t.mStart + sourceLen);
        }

        return str;
    }

    private String normalizeQuery(String query) {
        return query.toLowerCase();
    }

    /**
     * Finds which tokens in the target match tokens in the source.
     *
     * @param source List of source tokens (i.e. user query)
     * @param target List of target tokens (i.e. suggestion)
     * @return The indices into source which target tokens correspond to. A non-negative value n at
     *      position i means that target token i matches source token n. A negative value means that
     *      the target token i does not match any source token.
     */
    @VisibleForTesting
    int[] findMatches(Token[] source, Token[] target) {
        final LevenshteinDistance table = new LevenshteinDistance(source, target);
        table.calculate();
        final int targetLen = target.length;
        final int[] result = new int[targetLen];
        LevenshteinDistance.EditOperation[] ops = table.getTargetOperations();
        for (int i = 0; i < targetLen; ++i) {
            if (ops[i].getType() == LevenshteinDistance.EDIT_UNCHANGED) {
                result[i] = ops[i].getPosition();
            } else {
                result[i] = -1;
            }
        }
        return result;
    }

    @VisibleForTesting
    Token[] tokenize(final String seq) {
        int pos = 0;
        final int len = seq.length();
        final char[] chars = seq.toCharArray();
        // There can't be more tokens than characters, make an array that is large enough
        Token[] tokens = new Token[len];
        int tokenCount = 0;
        while (pos < len) {
            while (pos < len && (chars[pos] == ' ' || chars[pos] == '\t')) {
                pos++;
            }
            int start = pos;
            while (pos < len && !(chars[pos] == ' ' || chars[pos] == '\t')) {
                pos++;
            }
            int end = pos;
            if (start != end) {
                tokens[tokenCount++] = new Token(chars, start, end);
            }
        }
        // Create a token array of the right size and return
        Token[] ret = new Token[tokenCount];
        System.arraycopy(tokens, 0, ret, 0, tokenCount);
        return ret;
    }

}
",False,37,4,19,1,3,2,3,L1
65,com.android.quicksearchbox.CursorBackedSuggestionExtras.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import android.database.Cursor;
import android.util.Log;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;

/**
 * SuggestionExtras taking values from the extra columns in a suggestion cursor.
 */
public class CursorBackedSuggestionExtras extends AbstractSuggestionExtras {
    private static final String TAG = ""QSB.CursorBackedSuggestionExtras"";

    private static final HashSet<String> DEFAULT_COLUMNS = new HashSet<String>();
    static {
        DEFAULT_COLUMNS.addAll(Arrays.asList(SuggestionCursorBackedCursor.COLUMNS));
    }

    private final Cursor mCursor;
    private final int mCursorPosition;
    private final List<String> mExtraColumns;

    static CursorBackedSuggestionExtras createExtrasIfNecessary(Cursor cursor, int position) {
        List<String> extraColumns = getExtraColumns(cursor);
        if (extraColumns != null) {
            return new CursorBackedSuggestionExtras(cursor, position, extraColumns);
        } else {
            return null;
        }
    }

    static String[] getCursorColumns(Cursor cursor) {
        try {
            return cursor.getColumnNames();
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getColumnNames() failed, "", ex);
            return null;
        }
    }

    static boolean cursorContainsExtras(Cursor cursor) {
        String[] columns = getCursorColumns(cursor);
        for (String cursorColumn : columns) {
            if (!DEFAULT_COLUMNS.contains(cursorColumn)) {
                return true;
            }
        }
        return false;
    }

    static List<String> getExtraColumns(Cursor cursor) {
        String[] columns = getCursorColumns(cursor);
        if (columns == null) return null;
        List<String> extraColumns = null;
        for (String cursorColumn : columns) {
            if (!DEFAULT_COLUMNS.contains(cursorColumn)) {
                if (extraColumns == null) {
                    extraColumns = new ArrayList<String>();
                }
                extraColumns.add(cursorColumn);
            }
        }
        return extraColumns;
    }

    private CursorBackedSuggestionExtras(Cursor cursor, int position, List<String> extraColumns) {
        super(null);
        mCursor = cursor;
        mCursorPosition = position;
        mExtraColumns = extraColumns;
    }

    @Override
    public String doGetExtra(String columnName) {
        try {
            mCursor.moveToPosition(mCursorPosition);
            int columnIdx = mCursor.getColumnIndex(columnName);
            if (columnIdx < 0) return null;
            return mCursor.getString(columnIdx);
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getExtra("" + columnName + "") failed, "", ex);
            return null;
        }
    }

    @Override
    public List<String> doGetExtraColumnNames() {
        return mExtraColumns;
    }

}
",True,50,7,17,6,4,1,2,L3
66,com.android.quicksearchbox.LatencyTracker.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.os.SystemClock;

/**
 * Tracks latency in wall-clock time. Since {@link #getLatency} returns an {@code int},
 * latencies over 2^31 ms (~ 25 days) cannot be measured.
 * This class uses {@link SystemClock#uptimeMillis} which does not advance during deep sleep.
 */
public class LatencyTracker {

    /**
     * Start time, in milliseconds as returned by {@link SystemClock#uptimeMillis}.
     */
    private long mStartTime;

    /**
     * Creates a new latency tracker and sets the start time.
     */
    public LatencyTracker() {
        mStartTime = SystemClock.uptimeMillis();
    }

    /**
     * Resets the start time.
     */
    public void reset() {
        mStartTime = SystemClock.uptimeMillis();
    }

    /**
     * Gets the number of milliseconds since the object was created, or {@link #reset} was called.
     */
    public int getLatency() {
        long now = SystemClock.uptimeMillis();
        return (int) (now - mStartTime);
    }

}
",False,37,6,14,0,0,3,0,L4
67,com.android.quicksearchbox.ContactsSource.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import com.android.quicksearchbox.util.NamedTaskExecutor;

import android.app.SearchableInfo;
import android.content.Context;
import android.content.pm.PackageManager.NameNotFoundException;
import android.os.Handler;

/**
 * Special case SearchableSource for contacts to provide the custom contacts suggestion view.
 */
public class ContactsSource extends SearchableSource {

    public ContactsSource(Context context, SearchableInfo searchable, Handler uiThread,
            NamedTaskExecutor iconLoader) throws NameNotFoundException {
        super(context, searchable, uiThread, iconLoader);
    }

}
",False,119,0,0,8,50,0,2,L10
68,com.android.quicksearchbox.AbstractSource.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.NamedTaskExecutor;
import com.android.quicksearchbox.util.NowOrLater;

import android.app.SearchManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;

/**
 * Abstract suggestion source implementation.
 */
public abstract class AbstractSource implements Source {

    private static final String TAG = ""QSB.AbstractSource"";

    private final Context mContext;
    private final Handler mUiThread;

    private IconLoader mIconLoader;

    private final NamedTaskExecutor mIconLoaderExecutor;

    public AbstractSource(Context context, Handler uiThread, NamedTaskExecutor iconLoader) {
        mContext = context;
        mUiThread = uiThread;
        mIconLoaderExecutor = iconLoader;
    }

    protected Context getContext() {
        return mContext;
    }

    protected IconLoader getIconLoader() {
        if (mIconLoader == null) {
            String iconPackage = getIconPackage();
            mIconLoader = new CachingIconLoader(
                    new PackageIconLoader(mContext, iconPackage, mUiThread, mIconLoaderExecutor));
        }
        return mIconLoader;
    }

    protected abstract String getIconPackage();

    public boolean isVersionCodeCompatible(int version) {
        return getVersionCode() == version;
    }

    public NowOrLater<Drawable> getIcon(String drawableId) {
        return getIconLoader().getIcon(drawableId);
    }

    public Uri getIconUri(String drawableId) {
        return getIconLoader().getIconUri(drawableId);
    }

    public Intent createSearchIntent(String query, Bundle appData) {
        return createSourceSearchIntent(getIntentComponent(), query, appData);
    }

    public static Intent createSourceSearchIntent(ComponentName activity, String query,
            Bundle appData) {
        if (activity == null) {
            Log.w(TAG, ""Tried to create search intent with no target activity"");
            return null;
        }
        Intent intent = new Intent(Intent.ACTION_SEARCH);
        intent.setComponent(activity);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        // We need CLEAR_TOP to avoid reusing an old task that has other activities
        // on top of the one we want.
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
        intent.putExtra(SearchManager.USER_QUERY, query);
        intent.putExtra(SearchManager.QUERY, query);
        if (appData != null) {
            intent.putExtra(SearchManager.APP_DATA, appData);
        }
        return intent;
    }

    protected Intent createVoiceWebSearchIntent(Bundle appData) {
        return QsbApplication.get(mContext).getVoiceSearch()
                .createVoiceWebSearchIntent(appData);
    }

    public Source getRoot() {
        return this;
    }

    @Override
    public boolean equals(Object o) {
        if (o != null && o instanceof Source) {
            Source s = ((Source) o).getRoot();
            if (s.getClass().equals(this.getClass())) {
                return s.getName().equals(getName());
            }
        }
        return false;
    }

    @Override
    public int hashCode() {
        return getName().hashCode();
    }

    @Override
    public String toString() {
        return ""Source{name="" + getName() + ""}"";
    }

}
",True,118,0,0,6,53,6,9,L8
69,com.android.quicksearchbox.SearchActivity.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.common.Search;
import com.android.quicksearchbox.ui.SearchActivityView;
import com.android.quicksearchbox.ui.SuggestionClickListener;
import com.android.quicksearchbox.ui.SuggestionsAdapter;
import com.android.quicksearchbox.util.Consumer;
import com.android.quicksearchbox.util.Consumers;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.CharMatcher;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.SearchManager;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.DataSetObserver;
import android.net.Uri;
import android.os.Bundle;
import android.os.Debug;
import android.os.Handler;
import android.text.TextUtils;
import android.util.Log;
import android.view.Menu;
import android.view.View;
import android.widget.Toast;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;

/**
 * The main activity for Quick Search Box. Shows the search UI.
 *
 */
public class SearchActivity extends Activity {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SearchActivity"";

    private static final String SCHEME_CORPUS = ""qsb.corpus"";

    public static final String INTENT_ACTION_QSB_AND_SELECT_CORPUS
            = ""com.android.quicksearchbox.action.QSB_AND_SELECT_CORPUS"";

    private static final String INTENT_EXTRA_TRACE_START_UP = ""trace_start_up"";

    // Keys for the saved instance state.
    private static final String INSTANCE_KEY_CORPUS = ""corpus"";
    private static final String INSTANCE_KEY_QUERY = ""query"";

    private static final String ACTIVITY_HELP_CONTEXT = ""search"";

    private boolean mTraceStartUp;
    // Measures time from for last onCreate()/onNewIntent() call.
    private LatencyTracker mStartLatencyTracker;
    // Measures time spent inside onCreate()
    private LatencyTracker mOnCreateTracker;
    private int mOnCreateLatency;
    // Whether QSB is starting. True between the calls to onCreate()/onNewIntent() and onResume().
    private boolean mStarting;
    // True if the user has taken some action, e.g. launching a search, voice search,
    // or suggestions, since QSB was last started.
    private boolean mTookAction;

    private SearchActivityView mSearchActivityView;

    private CorporaObserver mCorporaObserver;

    private Bundle mAppSearchData;

    private final Handler mHandler = new Handler();
    private final Runnable mUpdateSuggestionsTask = new Runnable() {
        public void run() {
            updateSuggestions();
        }
    };

    private final Runnable mShowInputMethodTask = new Runnable() {
        public void run() {
            mSearchActivityView.showInputMethodForQuery();
        }
    };

    private OnDestroyListener mDestroyListener;

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        mTraceStartUp = getIntent().hasExtra(INTENT_EXTRA_TRACE_START_UP);
        if (mTraceStartUp) {
            String traceFile = new File(getDir(""traces"", 0), ""qsb-start.trace"").getAbsolutePath();
            Log.i(TAG, ""Writing start-up trace to "" + traceFile);
            Debug.startMethodTracing(traceFile);
        }
        recordStartTime();
        if (DBG) Log.d(TAG, ""onCreate()"");
        super.onCreate(savedInstanceState);

        // This forces the HTTP request to check the users domain to be
        // sent as early as possible.
        QsbApplication.get(this).getSearchBaseUrlHelper();

        mSearchActivityView = setupContentView();

        if (getConfig().showScrollingSuggestions()) {
            mSearchActivityView.setMaxPromotedSuggestions(getConfig().getMaxPromotedSuggestions());
        } else {
            mSearchActivityView.limitSuggestionsToViewHeight();
        }
        if (getConfig().showScrollingResults()) {
            mSearchActivityView.setMaxPromotedResults(getConfig().getMaxPromotedResults());
        } else {
            mSearchActivityView.limitResultsToViewHeight();
        }

        mSearchActivityView.setSearchClickListener(new SearchActivityView.SearchClickListener() {
            public boolean onSearchClicked(int method) {
                return SearchActivity.this.onSearchClicked(method);
            }
        });

        mSearchActivityView.setQueryListener(new SearchActivityView.QueryListener() {
            public void onQueryChanged() {
                updateSuggestionsBuffered();
            }
        });

        mSearchActivityView.setSuggestionClickListener(new ClickHandler());

        mSearchActivityView.setVoiceSearchButtonClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                onVoiceSearchClicked();
            }
        });

        View.OnClickListener finishOnClick = new View.OnClickListener() {
            public void onClick(View v) {
                finish();
            }
        };
        mSearchActivityView.setExitClickListener(finishOnClick);

        // First get setup from intent
        Intent intent = getIntent();
        setupFromIntent(intent);
        // Then restore any saved instance state
        restoreInstanceState(savedInstanceState);

        // Do this at the end, to avoid updating the list view when setSource()
        // is called.
        mSearchActivityView.start();

        mCorporaObserver = new CorporaObserver();
        getCorpora().registerDataSetObserver(mCorporaObserver);
        recordOnCreateDone();
    }

    protected SearchActivityView setupContentView() {
        setContentView(R.layout.search_activity);
        return (SearchActivityView) findViewById(R.id.search_activity_view);
    }

    protected SearchActivityView getSearchActivityView() {
        return mSearchActivityView;
    }

    @Override
    protected void onNewIntent(Intent intent) {
        if (DBG) Log.d(TAG, ""onNewIntent()"");
        recordStartTime();
        setIntent(intent);
        setupFromIntent(intent);
    }

    private void recordStartTime() {
        mStartLatencyTracker = new LatencyTracker();
        mOnCreateTracker = new LatencyTracker();
        mStarting = true;
        mTookAction = false;
    }

    private void recordOnCreateDone() {
        mOnCreateLatency = mOnCreateTracker.getLatency();
    }

    protected void restoreInstanceState(Bundle savedInstanceState) {
        if (savedInstanceState == null) return;
        String corpusName = savedInstanceState.getString(INSTANCE_KEY_CORPUS);
        String query = savedInstanceState.getString(INSTANCE_KEY_QUERY);
        setCorpus(corpusName);
        setQuery(query, false);
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        // We don't save appSearchData, since we always get the value
        // from the intent and the user can't change it.

        outState.putString(INSTANCE_KEY_CORPUS, getCorpusName());
        outState.putString(INSTANCE_KEY_QUERY, getQuery());
    }

    private void setupFromIntent(Intent intent) {
        if (DBG) Log.d(TAG, ""setupFromIntent("" + intent.toUri(0) + "")"");
        String corpusName = getCorpusNameFromUri(intent.getData());
        String query = intent.getStringExtra(SearchManager.QUERY);
        Bundle appSearchData = intent.getBundleExtra(SearchManager.APP_DATA);
        boolean selectAll = intent.getBooleanExtra(SearchManager.EXTRA_SELECT_QUERY, false);

        setCorpus(corpusName);
        setQuery(query, selectAll);
        mAppSearchData = appSearchData;

        if (startedIntoCorpusSelectionDialog()) {
            mSearchActivityView.showCorpusSelectionDialog();
        }
    }

    public boolean startedIntoCorpusSelectionDialog() {
        return INTENT_ACTION_QSB_AND_SELECT_CORPUS.equals(getIntent().getAction());
    }

    /**
     * Removes corpus selector intent action, so that BACK works normally after
     * dismissing and reopening the corpus selector.
     */
    public void clearStartedIntoCorpusSelectionDialog() {
        Intent oldIntent = getIntent();
        if (SearchActivity.INTENT_ACTION_QSB_AND_SELECT_CORPUS.equals(oldIntent.getAction())) {
            Intent newIntent = new Intent(oldIntent);
            newIntent.setAction(SearchManager.INTENT_ACTION_GLOBAL_SEARCH);
            setIntent(newIntent);
        }
    }

    public static Uri getCorpusUri(Corpus corpus) {
        if (corpus == null) return null;
        return new Uri.Builder()
                .scheme(SCHEME_CORPUS)
                .authority(corpus.getName())
                .build();
    }

    private String getCorpusNameFromUri(Uri uri) {
        if (uri == null) return null;
        if (!SCHEME_CORPUS.equals(uri.getScheme())) return null;
        return uri.getAuthority();
    }

    private Corpus getCorpus() {
        return mSearchActivityView.getCorpus();
    }

    private String getCorpusName() {
        return mSearchActivityView.getCorpusName();
    }

    private void setCorpus(String name) {
        mSearchActivityView.setCorpus(name);
    }

    private QsbApplication getQsbApplication() {
        return QsbApplication.get(this);
    }

    private Config getConfig() {
        return getQsbApplication().getConfig();
    }

    protected SearchSettings getSettings() {
        return getQsbApplication().getSettings();
    }

    private Corpora getCorpora() {
        return getQsbApplication().getCorpora();
    }

    private CorpusRanker getCorpusRanker() {
        return getQsbApplication().getCorpusRanker();
    }

    private ShortcutRepository getShortcutRepository() {
        return getQsbApplication().getShortcutRepository();
    }

    private SuggestionsProvider getSuggestionsProvider() {
        return getQsbApplication().getSuggestionsProvider();
    }

    private Logger getLogger() {
        return getQsbApplication().getLogger();
    }

    @VisibleForTesting
    public void setOnDestroyListener(OnDestroyListener l) {
        mDestroyListener = l;
    }

    @Override
    protected void onDestroy() {
        if (DBG) Log.d(TAG, ""onDestroy()"");
        getCorpora().unregisterDataSetObserver(mCorporaObserver);
        mSearchActivityView.destroy();
        super.onDestroy();
        if (mDestroyListener != null) {
            mDestroyListener.onDestroyed();
        }
    }

    @Override
    protected void onStop() {
        if (DBG) Log.d(TAG, ""onStop()"");
        if (!mTookAction) {
            // TODO: This gets logged when starting other activities, e.g. by opening the search
            // settings, or clicking a notification in the status bar.
            // TODO we should log both sets of suggestions in 2-pane mode
            getLogger().logExit(getCurrentSuggestions(), getQuery().length());
        }
        // Close all open suggestion cursors. The query will be redone in onResume()
        // if we come back to this activity.
        mSearchActivityView.clearSuggestions();
        getQsbApplication().getShortcutRefresher().reset();
        mSearchActivityView.onStop();
        super.onStop();
    }

    @Override
    protected void onPause() {
        if (DBG) Log.d(TAG, ""onPause()"");
        mSearchActivityView.onPause();
        super.onPause();
    }

    @Override
    protected void onRestart() {
        if (DBG) Log.d(TAG, ""onRestart()"");
        super.onRestart();
    }

    @Override
    protected void onResume() {
        if (DBG) Log.d(TAG, ""onResume()"");
        super.onResume();
        updateSuggestionsBuffered();
        mSearchActivityView.onResume();
        if (mTraceStartUp) Debug.stopMethodTracing();
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        // Since the menu items are dynamic, we recreate the menu every time.
        menu.clear();
        createMenuItems(menu, true);
        return true;
    }

    public void createMenuItems(Menu menu, boolean showDisabled) {
        getSettings().addMenuItems(menu, showDisabled);
        getQsbApplication().getHelp().addHelpMenuItem(menu, ACTIVITY_HELP_CONTEXT);
    }

    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        if (hasFocus) {
            // Launch the IME after a bit
            mHandler.postDelayed(mShowInputMethodTask, 0);
        }
    }

    protected String getQuery() {
        return mSearchActivityView.getQuery();
    }

    protected void setQuery(String query, boolean selectAll) {
        mSearchActivityView.setQuery(query, selectAll);
    }

    public CorpusSelectionDialog getCorpusSelectionDialog() {
        CorpusSelectionDialog dialog = createCorpusSelectionDialog();
        dialog.setOwnerActivity(this);
        dialog.setOnDismissListener(new CorpusSelectorDismissListener());
        return dialog;
    }

    protected CorpusSelectionDialog createCorpusSelectionDialog() {
        return new CorpusSelectionDialog(this, getSettings());
    }

    /**
     * @return true if a search was performed as a result of this click, false otherwise.
     */
    protected boolean onSearchClicked(int method) {
        String query = CharMatcher.WHITESPACE.trimAndCollapseFrom(getQuery(), ' ');
        if (DBG) Log.d(TAG, ""Search clicked, query="" + query);

        // Don't do empty queries
        if (TextUtils.getTrimmedLength(query) == 0) return false;

        Corpus searchCorpus = getSearchCorpus();
        if (searchCorpus == null) return false;

        mTookAction = true;

        // Log search start
        getLogger().logSearch(getCorpus(), method, query.length());

        // Start search
        startSearch(searchCorpus, query);
        return true;
    }

    protected void startSearch(Corpus searchCorpus, String query) {
        Intent intent = searchCorpus.createSearchIntent(query, mAppSearchData);
        launchIntent(intent);
    }

    protected void onVoiceSearchClicked() {
        if (DBG) Log.d(TAG, ""Voice Search clicked"");
        Corpus searchCorpus = getSearchCorpus();
        if (searchCorpus == null) return;

        mTookAction = true;

        // Log voice search start
        getLogger().logVoiceSearch(searchCorpus);

        // Start voice search
        Intent intent = searchCorpus.createVoiceSearchIntent(mAppSearchData);
        launchIntent(intent);
    }

    protected Corpus getSearchCorpus() {
        return mSearchActivityView.getSearchCorpus();
    }

    protected SuggestionCursor getCurrentSuggestions() {
        return mSearchActivityView.getCurrentPromotedSuggestions();
    }

    protected SuggestionPosition getCurrentSuggestions(SuggestionsAdapter<?> adapter, long id) {
        SuggestionPosition pos = adapter.getSuggestion(id);
        if (pos == null) {
            return null;
        }
        SuggestionCursor suggestions = pos.getCursor();
        int position = pos.getPosition();
        if (suggestions == null) {
            return null;
        }
        int count = suggestions.getCount();
        if (position < 0 || position >= count) {
            Log.w(TAG, ""Invalid suggestion position "" + position + "", count = "" + count);
            return null;
        }
        suggestions.moveTo(position);
        return pos;
    }

    protected Set<Corpus> getCurrentIncludedCorpora() {
        Suggestions suggestions = mSearchActivityView.getSuggestions();
        return suggestions == null  ? null : suggestions.getIncludedCorpora();
    }

    protected void launchIntent(Intent intent) {
        if (DBG) Log.d(TAG, ""launchIntent "" + intent);
        if (intent == null) {
            return;
        }
        try {
            startActivity(intent);
        } catch (RuntimeException ex) {
            // Since the intents for suggestions specified by suggestion providers,
            // guard against them not being handled, not allowed, etc.
            Log.e(TAG, ""Failed to start "" + intent.toUri(0), ex);
        }
    }

    private boolean launchSuggestion(SuggestionsAdapter<?> adapter, long id) {
        SuggestionPosition suggestion = getCurrentSuggestions(adapter, id);
        if (suggestion == null) return false;

        if (DBG) Log.d(TAG, ""Launching suggestion "" + id);
        mTookAction = true;

        // Log suggestion click
        getLogger().logSuggestionClick(id, suggestion.getCursor(), getCurrentIncludedCorpora(),
                Logger.SUGGESTION_CLICK_TYPE_LAUNCH);

        // Create shortcut
        getShortcutRepository().reportClick(suggestion.getCursor(), suggestion.getPosition());

        // Launch intent
        launchSuggestion(suggestion.getCursor(), suggestion.getPosition());

        return true;
    }

    protected void launchSuggestion(SuggestionCursor suggestions, int position) {
        suggestions.moveTo(position);
        Intent intent = SuggestionUtils.getSuggestionIntent(suggestions, mAppSearchData);
        launchIntent(intent);
    }

    protected void removeFromHistoryClicked(final SuggestionsAdapter<?> adapter,
            final long id) {
        SuggestionPosition suggestion = getCurrentSuggestions(adapter, id);
        if (suggestion == null) return;
        CharSequence title = suggestion.getSuggestionText1();
        AlertDialog dialog = new AlertDialog.Builder(this)
                .setTitle(title)
                .setMessage(R.string.remove_from_history)
                .setPositiveButton(android.R.string.ok,
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int which) {
                                // TODO: what if the suggestions have changed?
                                removeFromHistory(adapter, id);
                            }
                        })
                .setNegativeButton(android.R.string.cancel, null)
                .create();
        dialog.show();
    }

    protected void removeFromHistory(SuggestionsAdapter<?> adapter, long id) {
        SuggestionPosition suggestion = getCurrentSuggestions(adapter, id);
        if (suggestion == null) return;
        removeFromHistory(suggestion.getCursor(), suggestion.getPosition());
        // TODO: Log to event log?
    }

    protected void removeFromHistory(SuggestionCursor suggestions, int position) {
        removeShortcut(suggestions, position);
        removeFromHistoryDone(true);
    }

    protected void removeFromHistoryDone(boolean ok) {
        Log.i(TAG, ""Removed query from history, success="" + ok);
        updateSuggestionsBuffered();
        if (!ok) {
            Toast.makeText(this, R.string.remove_from_history_failed, Toast.LENGTH_SHORT).show();
        }
    }

    protected void removeShortcut(SuggestionCursor suggestions, int position) {
        if (suggestions.isSuggestionShortcut()) {
            if (DBG) Log.d(TAG, ""Removing suggestion "" + position + "" from shortcuts"");
            getShortcutRepository().removeFromHistory(suggestions, position);
        }
    }

    protected void clickedQuickContact(SuggestionsAdapter<?> adapter, long id) {
        SuggestionPosition suggestion = getCurrentSuggestions(adapter, id);
        if (suggestion == null) return;

        if (DBG) Log.d(TAG, ""Used suggestion "" + suggestion.getPosition());
        mTookAction = true;

        // Log suggestion click
        getLogger().logSuggestionClick(id, suggestion.getCursor(), getCurrentIncludedCorpora(),
                Logger.SUGGESTION_CLICK_TYPE_QUICK_CONTACT);

        // Create shortcut
        getShortcutRepository().reportClick(suggestion.getCursor(), suggestion.getPosition());
    }

    protected void refineSuggestion(SuggestionsAdapter<?> adapter, long id) {
        if (DBG) Log.d(TAG, ""query refine clicked, pos "" + id);
        SuggestionPosition suggestion = getCurrentSuggestions(adapter, id);
        if (suggestion == null) {
            return;
        }
        String query = suggestion.getSuggestionQuery();
        if (TextUtils.isEmpty(query)) {
            return;
        }

        // Log refine click
        getLogger().logSuggestionClick(id, suggestion.getCursor(), getCurrentIncludedCorpora(),
                Logger.SUGGESTION_CLICK_TYPE_REFINE);

        // Put query + space in query text view
        String queryWithSpace = query + ' ';
        setQuery(queryWithSpace, false);
        updateSuggestions();
        mSearchActivityView.focusQueryTextView();
    }

    private void updateSuggestionsBuffered() {
        if (DBG) Log.d(TAG, ""updateSuggestionsBuffered()"");
        mHandler.removeCallbacks(mUpdateSuggestionsTask);
        long delay = getConfig().getTypingUpdateSuggestionsDelayMillis();
        mHandler.postDelayed(mUpdateSuggestionsTask, delay);
    }

    private void gotSuggestions(Suggestions suggestions) {
        if (mStarting) {
            mStarting = false;
            String source = getIntent().getStringExtra(Search.SOURCE);
            int latency = mStartLatencyTracker.getLatency();
            getLogger().logStart(mOnCreateLatency, latency, source, getCorpus(),
                    suggestions == null ? null : suggestions.getExpectedCorpora());
            getQsbApplication().onStartupComplete();
        }
    }

    private void getCorporaToQuery(Consumer<List<Corpus>> consumer) {
        Corpus corpus = getCorpus();
        if (corpus == null) {
            getCorpusRanker().getCorporaInAll(Consumers.createAsyncConsumer(mHandler, consumer));
        } else {
            List<Corpus> corpora = new ArrayList<Corpus>();
            Corpus searchCorpus = getSearchCorpus();
            if (searchCorpus != null) corpora.add(searchCorpus);
            consumer.consume(corpora);
        }
    }

    protected void getShortcutsForQuery(String query, Collection<Corpus> corporaToQuery,
            final Suggestions suggestions) {
        ShortcutRepository shortcutRepo = getShortcutRepository();
        if (shortcutRepo == null) return;
        if (query.length() == 0 && !getConfig().showShortcutsForZeroQuery()) {
            return;
        }
        Consumer<ShortcutCursor> consumer = Consumers.createAsyncCloseableConsumer(mHandler,
                new Consumer<ShortcutCursor>() {
            public boolean consume(ShortcutCursor shortcuts) {
                suggestions.setShortcuts(shortcuts);
                return true;
            }
        });
        shortcutRepo.getShortcutsForQuery(query, corporaToQuery,
                getSettings().allowWebSearchShortcuts(), consumer);
    }

    public void updateSuggestions() {
        if (DBG) Log.d(TAG, ""updateSuggestions()"");
        final String query = CharMatcher.WHITESPACE.trimLeadingFrom(getQuery());
        getQsbApplication().getSourceTaskExecutor().cancelPendingTasks();
        getCorporaToQuery(new Consumer<List<Corpus>>(){
            @Override
            public boolean consume(List<Corpus> corporaToQuery) {
                updateSuggestions(query, corporaToQuery);
                return true;
            }
        });
    }

    protected void updateSuggestions(String query, List<Corpus> corporaToQuery) {
        if (DBG) Log.d(TAG, ""updateSuggestions(\"""" + query+""\"","" + corporaToQuery + "")"");
        Suggestions suggestions = getSuggestionsProvider().getSuggestions(
                query, corporaToQuery);
        getShortcutsForQuery(query, corporaToQuery, suggestions);

        // Log start latency if this is the first suggestions update
        gotSuggestions(suggestions);

        showSuggestions(suggestions);
    }

    protected void showSuggestions(Suggestions suggestions) {
        mSearchActivityView.setSuggestions(suggestions);
    }

    private class ClickHandler implements SuggestionClickListener {

        public void onSuggestionQuickContactClicked(SuggestionsAdapter<?> adapter, long id) {
            clickedQuickContact(adapter, id);
        }

        public void onSuggestionClicked(SuggestionsAdapter<?> adapter, long id) {
            launchSuggestion(adapter, id);
        }

        public void onSuggestionRemoveFromHistoryClicked(SuggestionsAdapter<?> adapter, long id) {
            removeFromHistoryClicked(adapter, id);
        }

        public void onSuggestionQueryRefineClicked(SuggestionsAdapter<?> adapter, long id) {
            refineSuggestion(adapter, id);
        }
    }

    private class CorpusSelectorDismissListener implements DialogInterface.OnDismissListener {
        public void onDismiss(DialogInterface dialog) {
            if (DBG) Log.d(TAG, ""Corpus selector dismissed"");
            clearStartedIntoCorpusSelectionDialog();
        }
    }

    private class CorporaObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            setCorpus(getCorpusName());
            updateSuggestions();
        }
    }

    public interface OnDestroyListener {
        void onDestroyed();
    }

}
",True,132,1,3,6,50,5,27,L9
70,com.android.quicksearchbox.RankAwarePromoter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.google.common.annotations.VisibleForTesting;

import android.util.Log;

import java.util.Iterator;
import java.util.LinkedList;

/**
 * A promoter that gives preference to suggestions from higher ranking corpora.
 */
public class RankAwarePromoter extends AbstractPromoter {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.RankAwarePromoter"";

    public RankAwarePromoter(Config config, SuggestionFilter filter, Promoter next) {
        super(filter, next, config);
    }

    @Override
    public void doPickPromoted(Suggestions suggestions,
            int maxPromoted, ListSuggestionCursor promoted) {
        promoteSuggestions(suggestions.getCorpusResults(), maxPromoted, promoted);
    }

    @VisibleForTesting
    void promoteSuggestions(Iterable<CorpusResult> suggestions, int maxPromoted,
            ListSuggestionCursor promoted) {
        if (DBG) Log.d(TAG, ""Available results: "" + suggestions);

        // Split non-empty results into important suggestions and not-so-important
        // suggestions, each corpus's cursor positioned at the first suggestion.
        LinkedList<CorpusResult> highRankingSuggestions = new LinkedList<CorpusResult>();
        LinkedList<CorpusResult> lowRankingSuggestions = new LinkedList<CorpusResult>();
        partitionSuggestionsByRank(suggestions, highRankingSuggestions, lowRankingSuggestions);

        // Top results, evenly distributed between each high-ranking corpus.
        promoteTopSuggestions(highRankingSuggestions, promoted, maxPromoted);

        // Then try to fill promoted list with the remaining high-ranking suggestions,
        // and then use the low-ranking suggestions if the list isn't full yet.
        promoteEquallyFromEachCorpus(highRankingSuggestions, promoted, maxPromoted);
        promoteEquallyFromEachCorpus(lowRankingSuggestions, promoted, maxPromoted);

        if (DBG) Log.d(TAG, ""Returning "" + promoted.toString());
    }

    /**
     * Shares the top slots evenly among each of the high-ranking (default) corpora.
     *
     * The corpora will appear in the promoted list in the order they are listed
     * among the incoming suggestions (this method doesn't change their order).
     */
    private void promoteTopSuggestions(LinkedList<CorpusResult> highRankingSuggestions,
            ListSuggestionCursor promoted, int maxPromoted) {

        int slotsLeft = getSlotsLeft(promoted, maxPromoted);
        if (slotsLeft > 0 && !highRankingSuggestions.isEmpty()) {
            int slotsToFill = Math.min(getSlotsAboveKeyboard() - promoted.getCount(), slotsLeft);

            if (slotsToFill > 0) {
                int stripeSize = Math.max(1, slotsToFill / highRankingSuggestions.size());
                roundRobin(highRankingSuggestions, slotsToFill, stripeSize, promoted);
            }
        }
    }

    /**
     * Tries to promote the same number of elements from each corpus.
     *
     * The corpora will appear in the promoted list in the order they are listed
     * among the incoming suggestions (this method doesn't change their order).
     */
    private void promoteEquallyFromEachCorpus(LinkedList<CorpusResult> suggestions,
            ListSuggestionCursor promoted, int maxPromoted) {

        int slotsLeft = getSlotsLeft(promoted, maxPromoted);
        if (slotsLeft == 0) {
            // No more items to add.
            return;
        }

        if (suggestions.isEmpty()) {
            return;
        }

        int stripeSize = Math.max(1, slotsLeft / suggestions.size());
        roundRobin(suggestions, slotsLeft, stripeSize, promoted);

        // We may still have a few slots left
        slotsLeft = getSlotsLeft(promoted, maxPromoted);
        roundRobin(suggestions, slotsLeft, slotsLeft, promoted);
    }

    /**
     * Partitions the suggestions into ""important"" (high-ranking)
     * and ""not-so-important"" (low-ranking) suggestions, dependent on the
     * rank of the corpus the result is part of.
     *
     * @param suggestions
     * @param highRankingSuggestions These should be displayed first to the
     *     user.
     * @param lowRankingSuggestions These should be displayed if the
     *     high-ranking suggestions don't fill all the available space in the
     *     result view.
     */
    private void partitionSuggestionsByRank(Iterable<CorpusResult> suggestions,
            LinkedList<CorpusResult> highRankingSuggestions,
            LinkedList<CorpusResult> lowRankingSuggestions) {

        for (CorpusResult result : suggestions) {
            if (result.getCount() > 0) {
                result.moveTo(0);
                Corpus corpus = result.getCorpus();
                if (isCorpusHighlyRanked(corpus)) {
                    highRankingSuggestions.add(result);
                } else {
                    lowRankingSuggestions.add(result);
                }
            }
        }
    }

    private boolean isCorpusHighlyRanked(Corpus corpus) {
        // The default corpora shipped with QSB (apps, etc.) are
        // more important than ones that were registered later.
        return corpus == null || corpus.isCorpusDefaultEnabled();
    }

    private int getSlotsLeft(ListSuggestionCursor promoted, int maxPromoted) {
        // It's best to calculate this after each addition because duplicates
        // may get filtered out automatically in the list of promoted items.
        return Math.max(0, maxPromoted - promoted.getCount());
    }

    private int getSlotsAboveKeyboard() {
        return getConfig().getNumSuggestionsAboveKeyboard();
    }

    /**
     * Promotes ""stripes"" of suggestions from each corpus.
     *
     * @param results     the list of CorpusResults from which to promote.
     *                    Exhausted CorpusResults are removed from the list.
     * @param maxPromoted maximum number of suggestions to promote.
     * @param stripeSize  number of suggestions to take from each corpus.
     * @param promoted    the list to which promoted suggestions are added.
     * @return the number of suggestions actually promoted.
     */
    private int roundRobin(LinkedList<CorpusResult> results, int maxPromoted, int stripeSize,
            ListSuggestionCursor promoted) {
        int count = 0;
        if (maxPromoted > 0 && !results.isEmpty()) {
            for (Iterator<CorpusResult> iter = results.iterator();
                 count < maxPromoted && iter.hasNext();) {
                CorpusResult result = iter.next();
                count += promote(result, stripeSize, promoted);
                if (result.getPosition() == result.getCount()) {
                    iter.remove();
                }
            }
        }
        return count;
    }

    /**
     * Copies suggestions from a SuggestionCursor to the list of promoted suggestions.
     *
     * @param cursor from which to copy the suggestions
     * @param count maximum number of suggestions to copy
     * @param promoted the list to which to add the suggestions
     * @return the number of suggestions actually copied.
     */
    private int promote(SuggestionCursor cursor, int count, ListSuggestionCursor promoted) {
        if (count < 1 || cursor.getPosition() >= cursor.getCount()) {
            return 0;
        }
        int addedCount = 0;
        do {
            if (accept(cursor)) {
                if (promoted.add(new SuggestionPosition(cursor))) {
                    // Added successfully (wasn't already promoted).
                    addedCount++;
                }
            }
        } while (cursor.moveToNext() && addedCount < count);
        return addedCount;
    }

}
",False,61,4,19,4,10,4,10,L6
71,com.android.quicksearchbox.TextAppearanceFactory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Context;
import android.text.style.TextAppearanceSpan;

/**
 * Factory class for text appearances.
 */
public class TextAppearanceFactory {
    private final Context mContext;

    public TextAppearanceFactory(Context context) {
        mContext = context;
    }

    public Object[] createSuggestionQueryTextAppearance() {
        return new Object[]{
                new TextAppearanceSpan(mContext, R.style.SuggestionText1_Query)
        };
    }

    public Object[] createSuggestionSuggestedTextAppearance() {
        return new Object[]{
                new TextAppearanceSpan(mContext, R.style.SuggestionText1_Suggested)
        };
    }

}
",False,38,4,20,0,0,5,0,L0
72,com.android.quicksearchbox.CorpusFactory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import java.util.Collection;

/**
 * Creates corpora.
 */
public interface CorpusFactory {

    Collection<Corpus> createCorpora(Sources sources);

}
",False,48,4,19,5,4,4,2,L3
73,com.android.quicksearchbox.DefaultCorpusRanker.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.CachedLater;
import com.android.quicksearchbox.util.Consumer;

import android.database.DataSetObserver;
import android.util.Log;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

/**
 * A corpus ranker that uses corpus scores from the shortcut repository to rank
 * corpora.
 */
public class DefaultCorpusRanker implements CorpusRanker {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.DefaultCorpusRanker"";

    private final ShortcutRepository mShortcuts;

    private final Corpora mCorpora;

    // Cached list of ranked corpora.
    private final RankedCorporaCache mRankedCorpora;

    /**
     * Creates a new default corpus ranker.
     *
     * @param corpora Corpora to rank.
     * @param shortcuts Shortcut repository for getting corpus scores.
     */
    public DefaultCorpusRanker(Corpora corpora, ShortcutRepository shortcuts) {
        mCorpora = corpora;
        mCorpora.registerDataSetObserver(new CorporaObserver());
        mShortcuts = shortcuts;
        mRankedCorpora = new RankedCorporaCache();
    }

    public void getCorporaInAll(Consumer<List<Corpus>> consumer) {
        mRankedCorpora.getLater(consumer);
    }

    public void clear() {
        mRankedCorpora.clear();
    }

    private class CorporaObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            clear();
        }
    }

    private class RankedCorporaCache extends CachedLater<List<Corpus>> {

        @Override
        protected void create() {
            mShortcuts.getCorpusScores(new Consumer<Map<String,Integer>>(){
                public boolean consume(Map<String, Integer> clickScores) {
                    Collection<Corpus> enabledCorpora = mCorpora.getCorporaInAll();
                    if (DBG) Log.d(TAG, ""Ranking: "" + enabledCorpora);
                    ArrayList<Corpus> ordered = new ArrayList<Corpus>(enabledCorpora);
                    Collections.sort(ordered, new CorpusComparator(clickScores));

                    if (DBG) Log.d(TAG, ""Click scores: "" + clickScores);
                    if (DBG) Log.d(TAG, ""Ordered: "" + ordered);

                    store(ordered);
                    return true;
                }
            });
        }

    }

    private static class CorpusComparator implements Comparator<Corpus> {
        private final Map<String,Integer> mClickScores;

        public CorpusComparator(Map<String,Integer> clickScores) {
            mClickScores = clickScores;
        }

        public int compare(Corpus corpus1, Corpus corpus2) {
            boolean corpus1IsDefault = corpus1.isCorpusDefaultEnabled();
            boolean corpus2IsDefault = corpus2.isCorpusDefaultEnabled();

            if (corpus1IsDefault != corpus2IsDefault) {
                // Default corpora always come before non-default
                return corpus1IsDefault ? -1 : 1;
            }

            // Then by descending score
            int scoreDiff = getCorpusScore(corpus2) - getCorpusScore(corpus1);
            if (scoreDiff != 0) {
                return scoreDiff;
            }

            // Finally by name
            return corpus1.getLabel().toString().compareTo(corpus2.getLabel().toString());
        }

        /**
         * Scores a corpus. Higher score is better.
         */
        private int getCorpusScore(Corpus corpus) {
            // Web corpus always comes first
            if (corpus.isWebCorpus()) {
                return Integer.MAX_VALUE;
            }
            // Then use click score
            return getClickScore(corpus);
        }

        private int getClickScore(Corpus corpus) {
            if (mClickScores == null) return 0;
            Integer clickScore = mClickScores.get(corpus.getName());
            return clickScore == null ? 0 : clickScore;
        }
    }

}
",False,56,4,19,4,8,2,7,L5
74,com.android.quicksearchbox.SearchableSource.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.NamedTaskExecutor;
import com.android.quicksearchbox.util.Util;

import android.app.PendingIntent;
import android.app.SearchManager;
import android.app.SearchableInfo;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.PathPermission;
import android.content.pm.ProviderInfo;
import android.database.Cursor;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.speech.RecognizerIntent;
import android.util.Log;

import java.util.Arrays;

/**
 * Represents a single suggestion source, e.g. Contacts.
 */
public class SearchableSource extends AbstractSource {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SearchableSource"";

    // TODO: This should be exposed or moved to android-common, see http://b/issue?id=2440614
    // The extra key used in an intent to the speech recognizer for in-app voice search.
    private static final String EXTRA_CALLING_PACKAGE = ""calling_package"";

    private final SearchableInfo mSearchable;

    private final String mName;

    private final ActivityInfo mActivityInfo;

    private final int mVersionCode;

    // Cached label for the activity
    private CharSequence mLabel = null;

    // Cached icon for the activity
    private Drawable.ConstantState mSourceIcon = null;

    private Uri mSuggestUriBase;

    public SearchableSource(Context context, SearchableInfo searchable, Handler uiThread,
            NamedTaskExecutor iconLoader) throws NameNotFoundException {
        super(context, uiThread, iconLoader);
        ComponentName componentName = searchable.getSearchActivity();
        if (DBG) Log.d(TAG, ""created Searchable for "" + componentName);
        mSearchable = searchable;
        mName = componentName.flattenToShortString();
        PackageManager pm = context.getPackageManager();
        mActivityInfo = pm.getActivityInfo(componentName, 0);
        PackageInfo pkgInfo = pm.getPackageInfo(componentName.getPackageName(), 0);
        mVersionCode = pkgInfo.versionCode;
    }

    public SearchableInfo getSearchableInfo() {
        return mSearchable;
    }

    /**
     * Checks if the current process can read the suggestion provider in this source.
     */
    public boolean canRead() {
        String authority = mSearchable.getSuggestAuthority();
        if (authority == null) {
            // TODO: maybe we should have a way to distinguish between having suggestions
            // and being readable.
            return true;
        }

        Uri.Builder uriBuilder = new Uri.Builder()
                .scheme(ContentResolver.SCHEME_CONTENT)
                .authority(authority);
        // if content path provided, insert it now
        String contentPath = mSearchable.getSuggestPath();
        if (contentPath != null) {
            uriBuilder.appendEncodedPath(contentPath);
        }
        // append standard suggestion query path
        uriBuilder.appendEncodedPath(SearchManager.SUGGEST_URI_PATH_QUERY);
        Uri uri = uriBuilder.build();
        return canRead(uri);
    }

    /**
     * Checks if the current process can read the given content URI.
     *
     * TODO: Shouldn't this be a PackageManager / Context / ContentResolver method?
     */
    private boolean canRead(Uri uri) {
        ProviderInfo provider = getContext().getPackageManager().resolveContentProvider(
                uri.getAuthority(), 0);
        if (provider == null) {
            Log.w(TAG, getName() + "" has bad suggestion authority "" + uri.getAuthority());
            return false;
        }
        String readPermission = provider.readPermission;
        if (readPermission == null) {
            // No permission required to read anything in the content provider
            return true;
        }
        int pid = android.os.Process.myPid();
        int uid = android.os.Process.myUid();
        if (getContext().checkPermission(readPermission, pid, uid)
                == PackageManager.PERMISSION_GRANTED) {
            // We have permission to read everything in the content provider
            return true;
        }
        PathPermission[] pathPermissions = provider.pathPermissions;
        if (pathPermissions == null || pathPermissions.length == 0) {
            // We don't have the readPermission, and there are no pathPermissions
            if (DBG) Log.d(TAG, ""Missing "" + readPermission);
            return false;
        }
        String path = uri.getPath();
        for (PathPermission perm : pathPermissions) {
            String pathReadPermission = perm.getReadPermission();
            if (pathReadPermission != null
                    && perm.match(path)
                    && getContext().checkPermission(pathReadPermission, pid, uid)
                            == PackageManager.PERMISSION_GRANTED) {
                // We have the path permission
                return true;
            }
        }
        if (DBG) Log.d(TAG, ""Missing "" + readPermission + "" and no path permission applies"");
        return false;
    }

    public ComponentName getIntentComponent() {
        return mSearchable.getSearchActivity();
    }

    public int getVersionCode() {
        return mVersionCode;
    }

    public String getName() {
        return mName;
    }

    @Override
    protected String getIconPackage() {
        // Get icons from the package containing the suggestion provider, if any
        String iconPackage = mSearchable.getSuggestPackage();
        if (iconPackage != null) {
            return iconPackage;
        } else {
            // Fall back to the package containing the searchable activity
            return mSearchable.getSearchActivity().getPackageName();
        }
    }

    public CharSequence getLabel() {
        if (mLabel == null) {
            // Load label lazily
            mLabel = mActivityInfo.loadLabel(getContext().getPackageManager());
        }
        return mLabel;
    }

    public CharSequence getHint() {
        return getText(mSearchable.getHintId());
    }

    public int getQueryThreshold() {
        return mSearchable.getSuggestThreshold();
    }

    public CharSequence getSettingsDescription() {
        return getText(mSearchable.getSettingsDescriptionId());
    }

    public Drawable getSourceIcon() {
        if (mSourceIcon == null) {
            Drawable icon = loadSourceIcon();
            if (icon == null) {
                icon = getContext().getResources().getDrawable(R.drawable.corpus_icon_default);
            }
            // Can't share Drawable instances, save constant state instead.
            mSourceIcon = (icon != null) ? icon.getConstantState() : null;
            // Optimization, return the Drawable the first time
            return icon;
        }
        return (mSourceIcon != null) ? mSourceIcon.newDrawable() : null;
    }

    private Drawable loadSourceIcon() {
        int iconRes = getSourceIconResource();
        if (iconRes == 0) return null;
        PackageManager pm = getContext().getPackageManager();
        return pm.getDrawable(mActivityInfo.packageName, iconRes,
                mActivityInfo.applicationInfo);
    }

    public Uri getSourceIconUri() {
        int resourceId = getSourceIconResource();
        if (resourceId == 0) {
            return Util.getResourceUri(getContext(), R.drawable.corpus_icon_default);
        } else {
            return Util.getResourceUri(getContext(), mActivityInfo.applicationInfo, resourceId);
        }
    }

    private int getSourceIconResource() {
        return mActivityInfo.getIconResource();
    }

    public boolean voiceSearchEnabled() {
        return mSearchable.getVoiceSearchEnabled();
    }

    public Intent createVoiceSearchIntent(Bundle appData) {
        if (mSearchable.getVoiceSearchLaunchWebSearch()) {
            return createVoiceWebSearchIntent(appData);
        } else if (mSearchable.getVoiceSearchLaunchRecognizer()) {
            return createVoiceAppSearchIntent(appData);
        }
        return null;
    }

    /**
     * Create and return an Intent that can launch the voice search activity, perform a specific
     * voice transcription, and forward the results to the searchable activity.
     *
     * This code is copied from SearchDialog
     *
     * @return A completely-configured intent ready to send to the voice search activity
     */
    private Intent createVoiceAppSearchIntent(Bundle appData) {
        ComponentName searchActivity = mSearchable.getSearchActivity();

        // create the necessary intent to set up a search-and-forward operation
        // in the voice search system.   We have to keep the bundle separate,
        // because it becomes immutable once it enters the PendingIntent
        Intent queryIntent = new Intent(Intent.ACTION_SEARCH);
        queryIntent.setComponent(searchActivity);
        PendingIntent pending = PendingIntent.getActivity(
                getContext(), 0, queryIntent, PendingIntent.FLAG_ONE_SHOT);

        // Now set up the bundle that will be inserted into the pending intent
        // when it's time to do the search.  We always build it here (even if empty)
        // because the voice search activity will always need to insert ""QUERY"" into
        // it anyway.
        Bundle queryExtras = new Bundle();
        if (appData != null) {
            queryExtras.putBundle(SearchManager.APP_DATA, appData);
        }

        // Now build the intent to launch the voice search.  Add all necessary
        // extras to launch the voice recognizer, and then all the necessary extras
        // to forward the results to the searchable activity
        Intent voiceIntent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
        voiceIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        // Add all of the configuration options supplied by the searchable's metadata
        String languageModel = getString(mSearchable.getVoiceLanguageModeId());
        if (languageModel == null) {
            languageModel = RecognizerIntent.LANGUAGE_MODEL_FREE_FORM;
        }
        String prompt = getString(mSearchable.getVoicePromptTextId());
        String language = getString(mSearchable.getVoiceLanguageId());
        int maxResults = mSearchable.getVoiceMaxResults();
        if (maxResults <= 0) {
            maxResults = 1;
        }

        voiceIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, languageModel);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_PROMPT, prompt);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE, language);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, maxResults);
        voiceIntent.putExtra(EXTRA_CALLING_PACKAGE,
                searchActivity == null ? null : searchActivity.toShortString());

        // Add the values that configure forwarding the results
        voiceIntent.putExtra(RecognizerIntent.EXTRA_RESULTS_PENDINGINTENT, pending);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_RESULTS_PENDINGINTENT_BUNDLE, queryExtras);

        return voiceIntent;
    }

    public SourceResult getSuggestions(String query, int queryLimit, boolean onlySource) {
        try {
            Cursor cursor = getSuggestions(getContext(), mSearchable, query, queryLimit);
            if (DBG) Log.d(TAG, toString() + ""["" + query + ""] returned."");
            return new CursorBackedSourceResult(this, query, cursor);
        } catch (RuntimeException ex) {
            Log.e(TAG, toString() + ""["" + query + ""] failed"", ex);
            return new CursorBackedSourceResult(this, query);
        }
    }

    public SuggestionCursor refreshShortcut(String shortcutId, String extraData) {
        Cursor cursor = null;
        try {
            cursor = getValidationCursor(getContext(), mSearchable, shortcutId, extraData);
            if (DBG) Log.d(TAG, toString() + ""["" + shortcutId + ""] returned."");
            if (cursor != null && cursor.getCount() > 0) {
                cursor.moveToFirst();
            }
            return new CursorBackedSourceResult(this, null, cursor);
        } catch (RuntimeException ex) {
            Log.e(TAG, toString() + ""["" + shortcutId + ""] failed"", ex);
            if (cursor != null) {
                cursor.close();
            }
            // TODO: Should we delete the shortcut even if the failure is temporary?
            return null;
        }
    }

    public String getSuggestUri() {
        Uri uri = getSuggestUriBase(mSearchable);
        if (uri == null) return null;
        return uri.toString();
    }

    private synchronized Uri getSuggestUriBase(SearchableInfo searchable) {
        if (searchable == null) {
            return null;
        }
        if (mSuggestUriBase == null) {

            String authority = searchable.getSuggestAuthority();
            if (authority == null) {
                return null;
            }

            Uri.Builder uriBuilder = new Uri.Builder()
                    .scheme(ContentResolver.SCHEME_CONTENT)
                    .authority(authority);

            // if content path provided, insert it now
            final String contentPath = searchable.getSuggestPath();
            if (contentPath != null) {
                uriBuilder.appendEncodedPath(contentPath);
            }

            // append standard suggestion query path
            uriBuilder.appendPath(SearchManager.SUGGEST_URI_PATH_QUERY);
            mSuggestUriBase = uriBuilder.build();
        }
        return mSuggestUriBase;
    }

    /**
     * This is a copy of {@link SearchManager#getSuggestions(SearchableInfo, String)}.
     */
    private Cursor getSuggestions(Context context, SearchableInfo searchable, String query,
            int queryLimit) {

        Uri base = getSuggestUriBase(searchable);
        if (base == null) return null;
        Uri.Builder uriBuilder = base.buildUpon();

        // get the query selection, may be null
        String selection = searchable.getSuggestSelection();
        // inject query, either as selection args or inline
        String[] selArgs = null;
        if (selection != null) {    // use selection if provided
            selArgs = new String[] { query };
        } else {                    // no selection, use REST pattern
            uriBuilder.appendPath(query);
        }

        uriBuilder.appendQueryParameter(""limit"", String.valueOf(queryLimit));

        Uri uri = uriBuilder.build();

        // finally, make the query
        if (DBG) {
            Log.d(TAG, ""query("" + uri + "",null,"" + selection + "",""
                    + Arrays.toString(selArgs) + "",null)"");
        }
        Cursor c = context.getContentResolver().query(uri, null, selection, selArgs, null);
        if (DBG) Log.d(TAG, ""Got cursor from "" + mName + "": "" + c);
        return c;
    }

    private static Cursor getValidationCursor(Context context, SearchableInfo searchable,
            String shortcutId, String extraData) {
        String authority = searchable.getSuggestAuthority();
        if (authority == null) {
            return null;
        }

        Uri.Builder uriBuilder = new Uri.Builder()
                .scheme(ContentResolver.SCHEME_CONTENT)
                .authority(authority);

        // if content path provided, insert it now
        final String contentPath = searchable.getSuggestPath();
        if (contentPath != null) {
            uriBuilder.appendEncodedPath(contentPath);
        }

        // append the shortcut path and id
        uriBuilder.appendPath(SearchManager.SUGGEST_URI_PATH_SHORTCUT);
        uriBuilder.appendPath(shortcutId);

        Uri uri = uriBuilder
                .appendQueryParameter(SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA, extraData)
                .build();

        if (DBG) Log.d(TAG, ""Requesting refresh "" + uri);
        // finally, make the query
        return context.getContentResolver().query(uri, null, null, null, null);
    }

    public int getMaxShortcuts(Config config) {
        return config.getMaxShortcuts(getName());
    }

    public boolean includeInAll() {
        return true;
    }

    public boolean queryAfterZeroResults() {
        return mSearchable.queryAfterZeroResults();
    }

    public String getDefaultIntentAction() {
        String action = mSearchable.getSuggestIntentAction();
        if (action != null) return action;
        return Intent.ACTION_SEARCH;
    }

    public String getDefaultIntentData() {
        return mSearchable.getSuggestIntentData();
    }

    private CharSequence getText(int id) {
        if (id == 0) return null;
        return getContext().getPackageManager().getText(mActivityInfo.packageName, id,
                mActivityInfo.applicationInfo);
    }

    private String getString(int id) {
        CharSequence text = getText(id);
        return text == null ? null : text.toString();
    }
}
",True,119,1,1,7,50,3,7,L8
75,com.android.quicksearchbox.SuggestionFormatter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.text.Spannable;

/**
 * Suggestion formatter interface. This is used to bold (or otherwise highlight) portions of a
 * suggestion which were not a part of the query.
 */
public abstract class SuggestionFormatter {

    private final TextAppearanceFactory mSpanFactory;

    protected SuggestionFormatter(TextAppearanceFactory spanFactory) {
        mSpanFactory = spanFactory;
    }

    /**
     * Formats a suggestion for display in the UI.
     *
     * @param query the query as entered by the user
     * @param suggestion the suggestion
     * @return Formatted suggestion text.
     */
    public abstract CharSequence formatSuggestion(String query, String suggestion);

    protected void applyQueryTextStyle(Spannable text, int start, int end) {
        if (start == end) return;
        setSpans(text, start, end, mSpanFactory.createSuggestionQueryTextAppearance());
    }

    protected void applySuggestedTextStyle(Spannable text, int start, int end) {
        if (start == end) return;
        setSpans(text, start, end, mSpanFactory.createSuggestionSuggestedTextAppearance());
    }

    private void setSpans(Spannable text, int start, int end, Object[] spans) {
        for (Object span : spans) {
            text.setSpan(span, start, end, 0);
        }
    }

}
",False,37,4,20,1,1,4,1,L0
76,com.android.quicksearchbox.SuggestionCursorWrapper.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.database.DataSetObserver;

import java.util.Collection;

/**
 * A suggestion cursor that delegates all methods to another SuggestionCursor.
 */
public class SuggestionCursorWrapper extends AbstractSuggestionCursorWrapper {

    private final SuggestionCursor mCursor;

    public SuggestionCursorWrapper(String userQuery, SuggestionCursor cursor) {
        super(userQuery);
        mCursor = cursor;
    }

    public void close() {
        if (mCursor != null) {
            mCursor.close();
        }
    }

    public int getCount() {
        return mCursor == null ? 0 : mCursor.getCount();
    }

    public int getPosition() {
        return mCursor == null ? 0 : mCursor.getPosition();
    }

    public void moveTo(int pos) {
        if (mCursor != null) {
            mCursor.moveTo(pos);
        }
    }

    public boolean moveToNext() {
        if (mCursor != null) {
            return mCursor.moveToNext();
        } else {
            return false;
        }
    }

    public void registerDataSetObserver(DataSetObserver observer) {
        if (mCursor != null) {
            mCursor.registerDataSetObserver(observer);
        }
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
        if (mCursor != null) {
            mCursor.unregisterDataSetObserver(observer);
        }
    }

    @Override
    protected SuggestionCursor current() {
        return mCursor;
    }

    public Collection<String> getExtraColumns() {
        return mCursor.getExtraColumns();
    }

}
",False,66,7,19,6,4,3,2,L2
77,com.android.quicksearchbox.SourceResult.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

/**
 * The result of getting suggestions from a single source.
 */
public interface SourceResult extends SuggestionCursor {

    Source getSource();

}
",False,67,4,21,4,5,12,2,L1
78,com.android.quicksearchbox.SuggestionCursorProvider.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * Interface for objects that can produce a SuggestionCursor given a query.
 */
public interface SuggestionCursorProvider<C extends SuggestionCursor> {

    /**
     * Gets the name of the provider. This is used for logging and
     * to execute tasks on the queue for the provider.
     */
    String getName();

    /**
     * Gets suggestions from the provider.
     *
     * @param query The user query.
     * @param queryLimit An advisory maximum number of results that the source should return.
     * @param onlyOne Indicates if this provider is the only one being used for the query.
     * @return The suggestion results. Must not be {@code null}.
     */
    C getSuggestions(String query, int queryLimit, boolean onlyOne);
}
",False,99,4,31,6,3,33,1,L1
79,com.android.quicksearchbox.Suggestions.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.google.common.annotations.VisibleForTesting;

import android.database.DataSetObservable;
import android.database.DataSetObserver;
import android.util.Log;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Collects all corpus results for a single query.
 */
public class Suggestions {
    private static final boolean DBG = false;
    private static final String TAG = ""QSB.Suggestions"";

    /** True if {@link Suggestions#close} has been called. */
    private boolean mClosed = false;
    protected final String mQuery;

    private ShortcutCursor mShortcuts;

    private final MyShortcutsObserver mShortcutsObserver = new MyShortcutsObserver();

    /**
     * The observers that want notifications of changes to the published suggestions.
     * This object may be accessed on any thread.
     */
    private final DataSetObservable mDataSetObservable = new DataSetObservable();

    /** The sources that are expected to report. */
    private final List<Corpus> mExpectedCorpora;
    private final HashMap<String, Integer> mCorpusPositions;

    /**
     * All {@link SuggestionCursor} objects that have been published so far,
     * in the same order as {@link #mExpectedCorpora}. There may be {@code null} items
     * in the array, if not all corpora have published yet.
     * This object may only be accessed on the UI thread.
     * */
    private final CorpusResult[] mCorpusResults;

    private CorpusResult mWebResult;

    private int mRefCount = 0;

    private boolean mDone = false;

    public Suggestions(String query, List<Corpus> expectedCorpora) {
        mQuery = query;
        mExpectedCorpora = expectedCorpora;
        mCorpusResults = new CorpusResult[mExpectedCorpora.size()];
        // create a map of corpus name -> position in mExpectedCorpora for sorting later
        // (we want to keep the ordering of corpora in mCorpusResults).
        mCorpusPositions = new HashMap<String, Integer>();
        for (int i = 0; i < mExpectedCorpora.size(); ++i) {
            mCorpusPositions.put(mExpectedCorpora.get(i).getName(), i);
        }
        if (DBG) {
            Log.d(TAG, ""new Suggestions ["" + hashCode() + ""] query \"""" + query
                    + ""\"" expected corpora: "" + mExpectedCorpora);
        }
    }

    public void acquire() {
        mRefCount++;
    }

    public void release() {
        mRefCount--;
        if (mRefCount <= 0) {
            close();
        }
    }

    public List<Corpus> getExpectedCorpora() {
        return mExpectedCorpora;
    }

    /**
     * Gets the number of corpora that are expected to report.
     */
    @VisibleForTesting
    public int getExpectedResultCount() {
        return mExpectedCorpora.size();
    }

    public boolean expectsCorpus(Corpus corpus) {
        for (Corpus expectedCorpus : mExpectedCorpora) {
            if (expectedCorpus.equals(corpus)) return true;
        }
        return false;
    }

    /**
     * Gets the set of corpora that have reported results to this suggestions set.
     *
     * @return A collection of corpora.
     */
    public Set<Corpus> getIncludedCorpora() {
        HashSet<Corpus> corpora = new HashSet<Corpus>();
        for (CorpusResult result : mCorpusResults) {
            if (result != null) {
                corpora.add(result.getCorpus());
            }
        }
        return corpora;
    }

    /**
     * Sets the shortcut suggestions.
     * Must be called on the UI thread, or before this object is seen by the UI thread.
     *
     * @param shortcuts The shortcuts.
     */
    public void setShortcuts(ShortcutCursor shortcuts) {
        if (DBG) Log.d(TAG, ""setShortcuts("" + shortcuts + "")"");
        if (mShortcuts != null) {
            throw new IllegalStateException(""Got duplicate shortcuts: old: "" + mShortcuts
                    + "", new: "" + shortcuts);
        }
        if (shortcuts == null) return;
        if (isClosed()) {
            shortcuts.close();
            return;
        }
        if (!mQuery.equals(shortcuts.getUserQuery())) {
            throw new IllegalArgumentException(""Got shortcuts for wrong query: ""
                    + mQuery + "" != "" + shortcuts.getUserQuery());
        }
        mShortcuts = shortcuts;
        if (shortcuts != null) {
            mShortcuts.registerDataSetObserver(mShortcutsObserver);
        }
        notifyDataSetChanged();
    }

    /**
     * Marks the suggestions set as complete, regardless of whether all corpora have
     * returned.
     */
    public void done() {
        mDone = true;
    }

    /**
     * Checks whether all sources have reported.
     * Must be called on the UI thread, or before this object is seen by the UI thread.
     */
    public boolean isDone() {
        // TODO: Handle early completion because we have all the results we want.
        return mDone || countCorpusResults() >= mExpectedCorpora.size();
    }

    private int countCorpusResults() {
        int count = 0;
        for (int i = 0; i < mCorpusResults.length; ++i) {
            if (mCorpusResults[i] != null) {
                count++;
            }
        }
        return count;
    }

    /**
     * Adds a list of corpus results. Must be called on the UI thread, or before this
     * object is seen by the UI thread.
     */
    public void addCorpusResults(List<CorpusResult> corpusResults) {
        if (isClosed()) {
            for (CorpusResult corpusResult : corpusResults) {
                corpusResult.close();
            }
            return;
        }

        for (CorpusResult corpusResult : corpusResults) {
            if (DBG) {
                Log.d(TAG, ""addCorpusResult[""+ hashCode() + ""] corpus:"" +
                        corpusResult.getCorpus().getName() + "" results:"" + corpusResult.getCount());
            }
            if (!mQuery.equals(corpusResult.getUserQuery())) {
              throw new IllegalArgumentException(""Got result for wrong query: ""
                    + mQuery + "" != "" + corpusResult.getUserQuery());
            }
            Integer pos = mCorpusPositions.get(corpusResult.getCorpus().getName());
            if (pos == null) {
                Log.w(TAG, ""Got unexpected CorpusResult from corpus "" +
                        corpusResult.getCorpus().getName());
                corpusResult.close();
            } else {
                mCorpusResults[pos] = corpusResult;
                if (corpusResult.getCorpus().isWebCorpus()) {
                    mWebResult = corpusResult;
                }
            }
        }
        notifyDataSetChanged();
    }

    /**
     * Registers an observer that will be notified when the reported results or
     * the done status changes.
     */
    public void registerDataSetObserver(DataSetObserver observer) {
        if (mClosed) {
            throw new IllegalStateException(""registerDataSetObserver() when closed"");
        }
        mDataSetObservable.registerObserver(observer);
    }


    /**
     * Unregisters an observer.
     */
    public void unregisterDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.unregisterObserver(observer);
    }

    /**
     * Calls {@link DataSetObserver#onChanged()} on all observers.
     */
    protected void notifyDataSetChanged() {
        if (DBG) Log.d(TAG, ""notifyDataSetChanged()"");
        mDataSetObservable.notifyChanged();
    }

    /**
     * Closes all the source results and unregisters all observers.
     */
    private void close() {
        if (DBG) Log.d(TAG, ""close() ["" + hashCode() + ""]"");
        if (mClosed) {
            throw new IllegalStateException(""Double close()"");
        }
        mClosed = true;
        mDataSetObservable.unregisterAll();
        if (mShortcuts != null) {
            mShortcuts.close();
            mShortcuts = null;
        }

        for (CorpusResult result : mCorpusResults) {
            if (result != null) {
                result.close();
            }
        }
        Arrays.fill(mCorpusResults, null);
    }

    public boolean isClosed() {
        return mClosed;
    }

    public ShortcutCursor getShortcuts() {
        return mShortcuts;
    }

    private void refreshShortcuts(SuggestionCursor promoted) {
        if (DBG) Log.d(TAG, ""refreshShortcuts("" + promoted + "")"");
        for (int i = 0; i < promoted.getCount(); ++i) {
            promoted.moveTo(i);
            if (promoted.isSuggestionShortcut()) {
                getShortcuts().refresh(promoted);
            }
        }
    }

    @Override
    protected void finalize() {
        if (!mClosed) {
            Log.e(TAG, ""LEAK! Finalized without being closed: Suggestions["" + getQuery() + ""]"");
        }
    }

    public String getQuery() {
        return mQuery;
    }

    public SuggestionCursor getPromoted(Promoter promoter, int maxPromoted) {
        SuggestionCursor promoted = buildPromoted(promoter, maxPromoted);
        refreshShortcuts(promoted);
        return promoted;
    }

    protected SuggestionCursor buildPromoted(Promoter promoter, int maxPromoted) {
        ListSuggestionCursor promoted = new ListSuggestionCursorNoDuplicates(mQuery);
        if (promoter == null) {
            return promoted;
        }
        promoter.pickPromoted(this, maxPromoted, promoted);
        if (DBG) {
            Log.d(TAG, ""pickPromoted("" + getShortcuts() + "","" + mCorpusResults + "",""
                    + maxPromoted + "") = "" + promoted);
        }
        return promoted;
    }

    /**
     * Gets the list of corpus results reported so far. Do not modify or hang on to
     * the returned iterator.
     */
    public Iterable<CorpusResult> getCorpusResults() {
        ArrayList<CorpusResult> results = new ArrayList<CorpusResult>(mCorpusResults.length);
        for (int i = 0; i < mCorpusResults.length; ++i) {
            if (mCorpusResults[i] != null) {
                results.add(mCorpusResults[i]);
            }
        }
        return results;
    }

    public CorpusResult getCorpusResult(Corpus corpus) {
        for (CorpusResult result : mCorpusResults) {
            if (result != null && corpus.equals(result.getCorpus())) {
                return result;
            }
        }
        return null;
    }

    public CorpusResult getWebResult() {
        return mWebResult;
    }

    /**
     * Gets the number of source results.
     * Must be called on the UI thread, or before this object is seen by the UI thread.
     */
    public int getResultCount() {
        if (isClosed()) {
            throw new IllegalStateException(""Called getSourceCount() when closed."");
        }
        return countCorpusResults();
    }

    @Override
    public String toString() {
        return ""Suggestions@"" + hashCode() + ""{expectedCorpora="" + mExpectedCorpora
                + "",countCorpusResults()="" + countCorpusResults() + ""}"";
    }

    private class MyShortcutsObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            notifyDataSetChanged();
        }
    }

}
",True,83,5,19,3,10,20,10,L5
80,com.android.quicksearchbox.SingleSourceCorpus.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Context;
import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;

import java.util.Collection;
import java.util.Collections;

/**
 * A corpus that uses a single source.
 */
public class SingleSourceCorpus extends AbstractCorpus {

    private final Source mSource;

    public SingleSourceCorpus(Context context, Config config, Source source) {
        super(context, config);
        mSource = source;
    }

    public Drawable getCorpusIcon() {
        return mSource.getSourceIcon();
    }

    public Uri getCorpusIconUri() {
        return mSource.getSourceIconUri();
    }

    public CharSequence getLabel() {
        return mSource.getLabel();
    }

    public CharSequence getHint() {
        return mSource.getHint();
    }

    public CharSequence getSettingsDescription() {
        return mSource.getSettingsDescription();
    }

    public CorpusResult getSuggestions(String query, int queryLimit, boolean onlyCorpus) {
        LatencyTracker latencyTracker = new LatencyTracker();
        SourceResult sourceResult = mSource.getSuggestions(query, queryLimit, true);
        int latency = latencyTracker.getLatency();
        return new SingleSourceCorpusResult(this, query, sourceResult, latency);
    }

    public String getName() {
        return mSource.getName();
    }

    public boolean queryAfterZeroResults() {
        return mSource.queryAfterZeroResults();
    }

    public int getQueryThreshold() {
        return mSource.getQueryThreshold();
    }

    public boolean voiceSearchEnabled() {
        return mSource.voiceSearchEnabled();
    }

    public Intent createSearchIntent(String query, Bundle appData) {
        return mSource.createSearchIntent(query, appData);
    }

    public Intent createVoiceSearchIntent(Bundle appData) {
        return mSource.createVoiceSearchIntent(appData);
    }

    public boolean includeInAll() {
        return mSource.includeInAll();
    }

    public boolean isWebCorpus() {
        return false;
    }

    public Collection<Source> getSources() {
        return Collections.singletonList(mSource);
    }

}
",False,51,5,19,4,8,2,8,L8
81,com.android.quicksearchbox.AbstractSuggestionExtras.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import org.json.JSONException;

import java.util.Collection;
import java.util.HashSet;

/**
 * Abstract SuggestionExtras supporting flattening to JSON.
 */
public abstract class AbstractSuggestionExtras implements SuggestionExtras {

    private final SuggestionExtras mMore;

    protected AbstractSuggestionExtras(SuggestionExtras more) {
        mMore = more;
    }

    public Collection<String> getExtraColumnNames() {
        HashSet<String> columns = new HashSet<String>();
        columns.addAll(doGetExtraColumnNames());
        if (mMore != null) {
            columns.addAll(mMore.getExtraColumnNames());
        }
        return columns;
    }

    protected abstract Collection<String> doGetExtraColumnNames();

    public String getExtra(String columnName) {
        String extra = doGetExtra(columnName);
        if (extra == null && mMore != null) {
            extra = mMore.getExtra(columnName);
        }
        return extra;
    }

    protected abstract String doGetExtra(String columnName);

    public String toJsonString() throws JSONException {
        return new JsonBackedSuggestionExtras(this).toString();
    }

}
",False,40,8,17,1,2,2,2,L2
82,com.android.quicksearchbox.google.AbstractGoogleSource.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.google;

import com.android.quicksearchbox.AbstractInternalSource;
import com.android.quicksearchbox.Config;
import com.android.quicksearchbox.CursorBackedSourceResult;
import com.android.quicksearchbox.R;
import com.android.quicksearchbox.SourceResult;
import com.android.quicksearchbox.SuggestionCursor;
import com.android.quicksearchbox.util.NamedTaskExecutor;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;

/**
 * Special source implementation for Google suggestions.
 */
public abstract class AbstractGoogleSource extends AbstractInternalSource implements GoogleSource {

    /*
     * This name corresponds to what was used in previous version of quick search box. We use the
     * same name so that shortcuts continue to work after an upgrade. (It also makes logging more
     * consistent).
     */
    private static final String GOOGLE_SOURCE_NAME =
        ""com.android.quicksearchbox/.google.GoogleSearch"";

    public AbstractGoogleSource(Context context, Handler uiThread, NamedTaskExecutor iconLoader) {
        super(context, uiThread, iconLoader);
    }

    public abstract ComponentName getIntentComponent();

    public abstract SuggestionCursor refreshShortcut(String shortcutId, String extraData);

    /**
     * Called by QSB to get web suggestions for a query.
     */
    public abstract SourceResult queryInternal(String query);

    /**
     * Called by external apps to get web suggestions for a query.
     */
    public abstract SourceResult queryExternal(String query);

    public Intent createVoiceSearchIntent(Bundle appData) {
        return createVoiceWebSearchIntent(appData);
    }

    public String getDefaultIntentAction() {
        return Intent.ACTION_WEB_SEARCH;
    }

    public CharSequence getHint() {
        return getContext().getString(R.string.google_search_hint);
    }

    public CharSequence getLabel() {
        return getContext().getString(R.string.google_search_label);
    }

    public String getName() {
        return GOOGLE_SOURCE_NAME;
    }

    public CharSequence getSettingsDescription() {
        return getContext().getString(R.string.google_search_description);
    }

    @Override
    protected int getSourceIconResource() {
        return R.mipmap.google_icon;
    }

    public SourceResult getSuggestions(String query, int queryLimit, boolean onlySource) {
        return emptyIfNull(queryInternal(query), query);
    }

    public SourceResult getSuggestionsExternal(String query) {
        return emptyIfNull(queryExternal(query), query);
    }

    private SourceResult emptyIfNull(SourceResult result, String query) {
        return result == null ? new CursorBackedSourceResult(this, query) : result;
    }

    public boolean voiceSearchEnabled() {
        return true;
    }

    public int getMaxShortcuts(Config config) {
        return config.getMaxShortcutsPerWebSource();
    }

    public boolean includeInAll() {
        return true;
    }

}
",False,118,0,0,7,50,1,8,L8
83,com.android.quicksearchbox.google.AbstractGoogleSourceResult.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.google;

import com.android.quicksearchbox.R;
import com.android.quicksearchbox.Source;
import com.android.quicksearchbox.SourceResult;
import com.android.quicksearchbox.SuggestionExtras;

import android.content.ComponentName;
import android.database.DataSetObserver;

import java.util.Collection;

public abstract class AbstractGoogleSourceResult implements SourceResult {

    private final Source mSource;
    private final String mUserQuery;
    private int mPos = 0;

    public AbstractGoogleSourceResult(Source source, String userQuery) {
        mSource = source;
        mUserQuery = userQuery;
    }

    public abstract int getCount();

    public abstract String getSuggestionQuery();

    public Source getSource() {
        return mSource;
    }

    public void close() {
    }

    public int getPosition() {
        return mPos;
    }

    public String getUserQuery() {
        return mUserQuery;
    }

    public void moveTo(int pos) {
        mPos = pos;
    }

    public boolean moveToNext() {
        int size = getCount();
        if (mPos >= size) {
            // Already past the end
            return false;
        }
        mPos++;
        return mPos < size;
    }

    public void registerDataSetObserver(DataSetObserver observer) {
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
    }

    public String getSuggestionText1() {
        return getSuggestionQuery();
    }

    public Source getSuggestionSource() {
        return mSource;
    }

    public boolean isSuggestionShortcut() {
        return false;
    }

    public String getShortcutId() {
        return null;
    }

    public String getSuggestionFormat() {
        return null;
    }

    public String getSuggestionIcon1() {
        return String.valueOf(R.drawable.magnifying_glass);
    }

    public String getSuggestionIcon2() {
        return null;
    }

    public String getSuggestionIntentAction() {
        return mSource.getDefaultIntentAction();
    }

    public ComponentName getSuggestionIntentComponent() {
        return mSource.getIntentComponent();
    }

    public String getSuggestionIntentDataString() {
        return null;
    }

    public String getSuggestionIntentExtraData() {
        return null;
    }

    public String getSuggestionLogType() {
        return null;
    }

    public String getSuggestionText2() {
        return null;
    }

    public String getSuggestionText2Url() {
        return null;
    }

    public boolean isSpinnerWhileRefreshing() {
        return false;
    }

    public boolean isWebSearchSuggestion() {
        return true;
    }

    public boolean isHistorySuggestion() {
        return false;
    }

    public SuggestionExtras getExtras() {
        return null;
    }

    public Collection<String> getExtraColumns() {
        return null;
    }
}
",False,45,5,19,4,4,1,3,L8
84,com.android.quicksearchbox.google.GoogleSuggestClient.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.google;

import com.android.quicksearchbox.Config;
import com.android.quicksearchbox.R;
import com.android.quicksearchbox.Source;
import com.android.quicksearchbox.SourceResult;
import com.android.quicksearchbox.SuggestionCursor;
import com.android.quicksearchbox.util.NamedTaskExecutor;

import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.apache.http.util.EntityUtils;
import org.json.JSONArray;
import org.json.JSONException;

import android.content.ComponentName;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.http.AndroidHttpClient;
import android.net.NetworkInfo;
import android.os.Build;
import android.os.Handler;
import android.text.TextUtils;
import android.util.Log;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Locale;

/**
 * Use network-based Google Suggests to provide search suggestions.
 */
public class GoogleSuggestClient extends AbstractGoogleSource {

    private static final boolean DBG = false;
    private static final String LOG_TAG = ""GoogleSearch"";

    private static final String USER_AGENT = ""Android/"" + Build.VERSION.RELEASE;
    private String mSuggestUri;

    // TODO: this should be defined somewhere
    private static final String HTTP_TIMEOUT = ""http.conn-manager.timeout"";

    private final HttpClient mHttpClient;

    public GoogleSuggestClient(Context context, Handler uiThread,
            NamedTaskExecutor iconLoader, Config config) {
        super(context, uiThread, iconLoader);
        mHttpClient = AndroidHttpClient.newInstance(USER_AGENT, context);
        HttpParams params = mHttpClient.getParams();
        params.setLongParameter(HTTP_TIMEOUT, config.getHttpConnectTimeout());

        // NOTE:  Do not look up the resource here;  Localization changes may not have completed
        // yet (e.g. we may still be reading the SIM card).
        mSuggestUri = null;
    }

    @Override
    public ComponentName getIntentComponent() {
        return new ComponentName(getContext(), GoogleSearch.class);
    }

    @Override
    public SourceResult queryInternal(String query) {
        return query(query);
    }

    @Override
    public SourceResult queryExternal(String query) {
        return query(query);
    }

    /**
     * Queries for a given search term and returns a cursor containing
     * suggestions ordered by best match.
     */
    private SourceResult query(String query) {
        if (TextUtils.isEmpty(query)) {
            return null;
        }
        if (!isNetworkConnected()) {
            Log.i(LOG_TAG, ""Not connected to network."");
            return null;
        }
        try {
            query = URLEncoder.encode(query, ""UTF-8"");
            if (mSuggestUri == null) {
                Locale l = Locale.getDefault();
                String language = GoogleSearch.getLanguage(l);
                mSuggestUri = getContext().getResources().getString(R.string.google_suggest_base,
                                                                    language);
            }

            String suggestUri = mSuggestUri + query;
            if (DBG) Log.d(LOG_TAG, ""Sending request: "" + suggestUri);
            HttpGet method = new HttpGet(suggestUri);
            HttpResponse response = mHttpClient.execute(method);
            if (response.getStatusLine().getStatusCode() == 200) {

                /* Goto http://www.google.com/complete/search?json=true&q=foo
                 * to see what the data format looks like. It's basically a json
                 * array containing 4 other arrays. We only care about the middle
                 * 2 which contain the suggestions and their popularity.
                 */
                JSONArray results = new JSONArray(EntityUtils.toString(response.getEntity()));
                JSONArray suggestions = results.getJSONArray(1);
                JSONArray popularity = results.getJSONArray(2);
                if (DBG) Log.d(LOG_TAG, ""Got "" + suggestions.length() + "" results"");
                return new GoogleSuggestCursor(this, query, suggestions, popularity);
            } else {
                if (DBG) Log.d(LOG_TAG, ""Request failed "" + response.getStatusLine());
            }
        } catch (UnsupportedEncodingException e) {
            Log.w(LOG_TAG, ""Error"", e);
        } catch (IOException e) {
            Log.w(LOG_TAG, ""Error"", e);
        } catch (JSONException e) {
            Log.w(LOG_TAG, ""Error"", e);
        }
        return null;
    }

    @Override
    public SuggestionCursor refreshShortcut(String shortcutId, String oldExtraData) {
        return null;
    }

    private boolean isNetworkConnected() {
        NetworkInfo networkInfo = getActiveNetworkInfo();
        return networkInfo != null && networkInfo.isConnected();
    }

    private NetworkInfo getActiveNetworkInfo() {
        ConnectivityManager connectivity =
                (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);
        if (connectivity == null) {
            return null;
        }
        return connectivity.getActiveNetworkInfo();
    }

    private static class GoogleSuggestCursor extends AbstractGoogleSourceResult {

        /* Contains the actual suggestions */
        private final JSONArray mSuggestions;

        /* This contains the popularity of each suggestion
         * i.e. 165,000 results. It's not related to sorting.
         */
        private final JSONArray mPopularity;

        public GoogleSuggestCursor(Source source, String userQuery,
                JSONArray suggestions, JSONArray popularity) {
            super(source, userQuery);
            mSuggestions = suggestions;
            mPopularity = popularity;
        }

        @Override
        public int getCount() {
            return mSuggestions.length();
        }

        @Override
        public String getSuggestionQuery() {
            try {
                return mSuggestions.getString(getPosition());
            } catch (JSONException e) {
                Log.w(LOG_TAG, ""Error parsing response: "" + e);
                return null;
            }
        }

        @Override
        public String getSuggestionText2() {
            try {
                return mPopularity.getString(getPosition());
            } catch (JSONException e) {
                Log.w(LOG_TAG, ""Error parsing response: "" + e);
                return null;
            }
        }
    }
}
",True,118,0,0,7,48,1,9,L8
85,com.android.quicksearchbox.google.SearchBaseUrlHelper.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.google;

import com.android.quicksearchbox.R;
import com.android.quicksearchbox.SearchSettings;
import com.android.quicksearchbox.SearchSettingsImpl;
import com.android.quicksearchbox.util.HttpHelper;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.AsyncTask;
import android.text.TextUtils;
import android.util.Log;

import java.util.Locale;

/**
 * Helper to build the base URL for all search requests.
 */
public class SearchBaseUrlHelper implements SharedPreferences.OnSharedPreferenceChangeListener {
    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SearchBaseUrlHelper"";

    private static final String DOMAIN_CHECK_URL =
            ""https://www.google.com/searchdomaincheck?format=domain"";

    private static final long SEARCH_BASE_URL_EXPIRY_MS = 24 * 3600 * 1000L;

    private final HttpHelper mHttpHelper;
    private final Context mContext;
    private final SearchSettings mSearchSettings;

    /**
     * Note that this constructor will spawn a thread to issue a HTTP
     * request if shouldUseGoogleCom is false.
     */
    public SearchBaseUrlHelper(Context context, HttpHelper helper,
            SearchSettings searchSettings, SharedPreferences prefs) {
        mHttpHelper = helper;
        mContext = context;
        mSearchSettings = searchSettings;

        // Note: This earlier used an inner class, but that causes issues
        // because SharedPreferencesImpl uses a WeakHashMap< > and the listener
        // will be GC'ed unless we keep a reference to it here.
        prefs.registerOnSharedPreferenceChangeListener(this);

        maybeUpdateBaseUrlSetting(false);
    }

    /**
     * Update the base search url, either:
     * (a) it has never been set (first run)
     * (b) it has expired
     * (c) if the caller forces an update by setting the ""force"" parameter.
     *
     * @param force if true, then the URL is reset whether or not it has
     *     expired.
     */
    public void maybeUpdateBaseUrlSetting(boolean force) {
        long lastUpdateTime = mSearchSettings.getSearchBaseDomainApplyTime();
        long currentTime = System.currentTimeMillis();

        if (force || lastUpdateTime == -1 ||
                currentTime - lastUpdateTime >= SEARCH_BASE_URL_EXPIRY_MS) {
            if (mSearchSettings.shouldUseGoogleCom()) {
                setSearchBaseDomain(getDefaultBaseDomain());
            } else {
                checkSearchDomain();
            }
        }
    }

    /**
     * @return the base url for searches.
     */
    public String getSearchBaseUrl() {
        return mContext.getResources().getString(R.string.google_search_base_pattern,
                getSearchDomain(), GoogleSearch.getLanguage(Locale.getDefault()));
    }

    /**
     * @return the search domain. This is of the form ""google.co.xx"" or ""google.com"",
     *     used by UI code.
     */
    public String getSearchDomain() {
        String domain = mSearchSettings.getSearchBaseDomain();

        if (domain == null) {
            if (DBG) {
                Log.w(TAG, ""Search base domain was null, last apply time="" +
                        mSearchSettings.getSearchBaseDomainApplyTime());
            }

            // This is required to deal with the case wherein getSearchDomain
            // is called before checkSearchDomain returns a valid URL. This will
            // happen *only* on the first run of the app when the ""use google.com""
            // option is unchecked. In other cases, the previously set domain (or
            // the default) will be returned.
            //
            // We have no choice in this case but to use the default search domain.
            domain = getDefaultBaseDomain();
        }

        if (domain.startsWith(""."")) {
            if (DBG) Log.d(TAG, ""Prepending www to "" + domain);
            domain = ""www"" + domain;
        }
        return domain;
    }

    /**
     * Issue a request to google.com/searchdomaincheck to retrieve the base
     * URL for search requests.
     */
    private void checkSearchDomain() {
        final HttpHelper.GetRequest request = new HttpHelper.GetRequest(DOMAIN_CHECK_URL);

        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void ... params) {
                if (DBG) Log.d(TAG, ""Starting request to /searchdomaincheck"");
                String domain;
                try {
                    domain = mHttpHelper.get(request);
                } catch (Exception e) {
                    if (DBG) Log.d(TAG, ""Request to /searchdomaincheck failed : "" + e);
                    // Swallow any exceptions thrown by the HTTP helper, in
                    // this rare case, we just use the default URL.
                    domain = getDefaultBaseDomain();

                    return null;
                }

                if (DBG) Log.d(TAG, ""Request to /searchdomaincheck succeeded"");
                setSearchBaseDomain(domain);

                return null;
            }
        }.execute();
    }

    private String getDefaultBaseDomain() {
        return mContext.getResources().getString(R.string.default_search_domain);
    }

    private void setSearchBaseDomain(String domain) {
        if (DBG) Log.d(TAG, ""Setting search domain to : "" + domain);

        mSearchSettings.setSearchBaseDomain(domain);
    }

    @Override
    public void onSharedPreferenceChanged(SharedPreferences pref, String key) {
        // Listen for changes only to the SEARCH_BASE_URL preference.
        if (DBG) Log.d(TAG, ""Handling changed preference : "" + key);
        if (SearchSettingsImpl.USE_GOOGLE_COM_PREF.equals(key)) {
            maybeUpdateBaseUrlSetting(true);
        }
    }
}",True,118,0,0,7,44,2,4,L8
86,com.android.quicksearchbox.google.GoogleSuggestionProvider.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.google;

import com.android.quicksearchbox.CursorBackedSourceResult;
import com.android.quicksearchbox.QsbApplication;
import com.android.quicksearchbox.Source;
import com.android.quicksearchbox.SourceResult;
import com.android.quicksearchbox.SuggestionCursorBackedCursor;

import android.app.SearchManager;
import android.content.ContentProvider;
import android.content.ContentValues;
import android.content.Context;
import android.content.UriMatcher;
import android.database.Cursor;
import android.net.Uri;
import android.util.Log;

/**
 * A suggestion provider which provides content from Genie, a service that offers
 * a superset of the content provided by Google Suggest.
 */
public class GoogleSuggestionProvider extends ContentProvider {
    private static final boolean DBG = false;
    private static final String TAG = ""QSB.GoogleSuggestionProvider"";

    // UriMatcher constants
    private static final int SEARCH_SUGGEST = 0;
    private static final int SEARCH_SHORTCUT = 1;

    private UriMatcher mUriMatcher;

    private GoogleSource mSource;

    @Override
    public boolean onCreate() {
        mSource = QsbApplication.get(getContext()).getGoogleSource();
        mUriMatcher = buildUriMatcher(getContext());
        return true;
    }

    /**
     * This will always return {@link SearchManager#SUGGEST_MIME_TYPE} as this
     * provider is purely to provide suggestions.
     */
    @Override
    public String getType(Uri uri) {
        return SearchManager.SUGGEST_MIME_TYPE;
    }

    private SourceResult emptyIfNull(SourceResult result, Source source, String query) {
        return result == null ? new CursorBackedSourceResult(source, query) : result;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection,
            String[] selectionArgs, String sortOrder) {

        if (DBG) Log.d(TAG, ""query uri="" + uri);
        int match = mUriMatcher.match(uri);

        if (match == SEARCH_SUGGEST) {
            String query = getQuery(uri);
            return new SuggestionCursorBackedCursor(
                    emptyIfNull(mSource.queryExternal(query), mSource, query));
        } else if (match == SEARCH_SHORTCUT) {
            String shortcutId = getQuery(uri);
            String extraData =
                uri.getQueryParameter(SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA);
            return new SuggestionCursorBackedCursor(mSource.refreshShortcut(shortcutId, extraData));
        } else {
            throw new IllegalArgumentException(""Unknown URI "" + uri);
        }
    }

    /**
     * Gets the search text from a uri.
     */
    private String getQuery(Uri uri) {
        if (uri.getPathSegments().size() > 1) {
            return uri.getLastPathSegment();
        } else {
            return """";
        }
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection,
            String[] selectionArgs) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        throw new UnsupportedOperationException();
    }

    private UriMatcher buildUriMatcher(Context context) {
        String authority = getAuthority(context);
        UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);
        matcher.addURI(authority, SearchManager.SUGGEST_URI_PATH_QUERY,
                SEARCH_SUGGEST);
        matcher.addURI(authority, SearchManager.SUGGEST_URI_PATH_QUERY + ""/*"",
                SEARCH_SUGGEST);
        matcher.addURI(authority, SearchManager.SUGGEST_URI_PATH_SHORTCUT,
                SEARCH_SHORTCUT);
        matcher.addURI(authority, SearchManager.SUGGEST_URI_PATH_SHORTCUT + ""/*"",
                SEARCH_SHORTCUT);
        return matcher;
    }

    protected String getAuthority(Context context) {
        return context.getPackageName() + "".google"";
    }

}
",False,119,0,0,6,53,0,6,L10
87,com.android.quicksearchbox.google.GoogleSource.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.google;

import com.android.quicksearchbox.Source;
import com.android.quicksearchbox.SourceResult;
import com.android.quicksearchbox.SuggestionCursor;

/**
 * Special source interface for Google suggestions.
 */
public interface GoogleSource extends Source {

    SuggestionCursor refreshShortcut(String shortcutId, String extraData);

    /**
     * Called by QSB to get web suggestions for a query.
     */
    SourceResult queryInternal(String query);

    /**
     * Called by external apps to get web suggestions for a query.
     */
    SourceResult queryExternal(String query);

}
",False,45,4,19,4,5,3,3,L8
88,com.android.quicksearchbox.google.GoogleSearch.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.google;

import com.android.common.Search;
import com.android.quicksearchbox.QsbApplication;

import android.app.Activity;
import android.app.PendingIntent;
import android.app.SearchManager;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.location.Location;
import android.net.Uri;
import android.os.Bundle;
import android.provider.Browser;
import android.text.TextUtils;
import android.util.Log;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Locale;

/**
 * This class is purely here to get search queries and route them to
 * the global {@link Intent#ACTION_WEB_SEARCH}.
 */
public class GoogleSearch extends Activity {
    private static final String TAG = ""GoogleSearch"";
    private static final boolean DBG = false;

    // Used to figure out which domain to base search requests
    // on.
    private SearchBaseUrlHelper mSearchDomainHelper;

    // ""source"" parameter for Google search requests from unknown sources (e.g. apps). This will get
    // prefixed with the string 'android-' before being sent on the wire.
    final static String GOOGLE_SEARCH_SOURCE_UNKNOWN = ""unknown"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Intent intent = getIntent();
        String action = intent != null ? intent.getAction() : null;

        // This should probably be moved so as to
        // send out the request to /checksearchdomain as early as possible.
        mSearchDomainHelper = QsbApplication.get(this).getSearchBaseUrlHelper();

        if (Intent.ACTION_WEB_SEARCH.equals(action) || Intent.ACTION_SEARCH.equals(action)) {
            handleWebSearchIntent(intent);
        }

        finish();
    }

    /**
     * Construct the language code (hl= paramater) for the given locale.
     */
    public static String getLanguage(Locale locale) {
        String language = locale.getLanguage();
        StringBuilder hl = new StringBuilder(language);
        String country = locale.getCountry();

        if (!TextUtils.isEmpty(country) && useLangCountryHl(language, country)) {
            hl.append('-');
            hl.append(country);
        }

        if (DBG) Log.d(TAG, ""language "" + language + "", country "" + country + "" -> hl="" + hl);
        return hl.toString();
    }

    // TODO: This is a workaround for bug 3232296. When that is fixed, this method can be removed.
    private static boolean useLangCountryHl(String language, String country) {
        // lang-country is currently only supported for a small number of locales
        if (""en"".equals(language)) {
            return ""GB"".equals(country);
        } else if (""zh"".equals(language)) {
            return ""CN"".equals(country) || ""TW"".equals(country);
        } else if (""pt"".equals(language)) {
            return ""BR"".equals(country) || ""PT"".equals(country);
        } else {
            return false;
        }
    }

    private void handleWebSearchIntent(Intent intent) {
        Intent launchUriIntent = createLaunchUriIntentFromSearchIntent(intent);
        PendingIntent pending =
            intent.getParcelableExtra(SearchManager.EXTRA_WEB_SEARCH_PENDINGINTENT);
        if (pending == null || !launchPendingIntent(pending, launchUriIntent)) {
            launchIntent(launchUriIntent);
        }
    }

    private Intent createLaunchUriIntentFromSearchIntent(Intent intent) {
        String query = intent.getStringExtra(SearchManager.QUERY);
        if (TextUtils.isEmpty(query)) {
            Log.w(TAG, ""Got search intent with no query."");
            return null;
        }

        // If the caller specified a 'source' url parameter, use that and if not use default.
        Bundle appSearchData = intent.getBundleExtra(SearchManager.APP_DATA);
        String source = GOOGLE_SEARCH_SOURCE_UNKNOWN;
        if (appSearchData != null) {
            source = appSearchData.getString(Search.SOURCE);
        }
        
        // The browser can pass along an application id which it uses to figure out which
        // window to place a new search into. So if this exists, we'll pass it back to
        // the browser. Otherwise, add our own package name as the application id, so that
        // the browser can organize all searches launched from this provider together.
        String applicationId = intent.getStringExtra(Browser.EXTRA_APPLICATION_ID);
        if (applicationId == null) {
            applicationId = getPackageName();
        }

        try {
            String searchUri = mSearchDomainHelper.getSearchBaseUrl()
                    + ""&source=android-"" + source
                    + ""&q="" + URLEncoder.encode(query, ""UTF-8"");
            Intent launchUriIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(searchUri));
            launchUriIntent.putExtra(Browser.EXTRA_APPLICATION_ID, applicationId);
            launchUriIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            return launchUriIntent;
        } catch (UnsupportedEncodingException e) {
            Log.w(TAG, ""Error"", e);
            return null;
        }

    }

    private void launchIntent(Intent intent) {
        try {
            Log.i(TAG, ""Launching intent: "" + intent.toUri(0));
            startActivity(intent);
        } catch (ActivityNotFoundException ex) {
            Log.w(TAG, ""No activity found to handle: "" + intent);
        }
    }

    private boolean launchPendingIntent(PendingIntent pending, Intent fillIn) {
        try {
            pending.send(this, Activity.RESULT_OK, fillIn);
            return true;
        } catch (PendingIntent.CanceledException ex) {
            Log.i(TAG, ""Pending intent cancelled: "" + pending);
            return false;
        }
    }

}
",True,118,0,0,6,46,2,2,L8
89,com.android.quicksearchbox.util.JavaNetHttpHelper.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.os.Build;
import android.util.Log;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

/**
 * Simple HTTP client API.
 */
public class JavaNetHttpHelper implements HttpHelper {
    private static final String TAG = ""QSB.JavaNetHttpHelper"";
    private static final boolean DBG = false;

    private static final int BUFFER_SIZE = 1024 * 4;
    private static final String USER_AGENT_HEADER = ""User-Agent"";
    private static final String DEFAULT_CHARSET = ""UTF-8"";

    private int mConnectTimeout;
    private int mReadTimeout;
    private final String mUserAgent;
    private final HttpHelper.UrlRewriter mRewriter;

    /**
     * Creates a new HTTP helper.
     *
     * @param rewriter URI rewriter
     * @param userAgent User agent string, e.g. ""MyApp/1.0"".
     */
    public JavaNetHttpHelper(UrlRewriter rewriter, String userAgent) {
        mUserAgent = userAgent + "" ("" + Build.DEVICE + "" "" + Build.ID + "")"";
        mRewriter = rewriter;
    }

    /**
     * Executes a GET request and returns the response content.
     *
     * @param request Request.
     * @return The response content. This is the empty string if the response
     *         contained no content.
     * @throws IOException If an IO error occurs.
     * @throws HttpException If the response has a status code other than 200.
     */
    public String get(GetRequest request) throws IOException, HttpException {
        return get(request.getUrl(), request.getHeaders());
    }

    /**
     * Executes a GET request and returns the response content.
     *
     * @param url Request URI.
     * @param requestHeaders Request headers.
     * @return The response content. This is the empty string if the response
     *         contained no content.
     * @throws IOException If an IO error occurs.
     * @throws HttpException If the response has a status code other than 200.
     */
    public String get(String url, Map<String,String> requestHeaders)
            throws IOException, HttpException {
        HttpURLConnection c = null;
        try {
            c = createConnection(url, requestHeaders);
            c.setRequestMethod(""GET"");
            c.connect();
            return getResponseFrom(c);
        } finally {
            if (c != null) {
                c.disconnect();
            }
        }
    }

    @Override
    public String post(PostRequest request) throws IOException, HttpException {
        return post(request.getUrl(), request.getHeaders(), request.getContent());
    }

    public String post(String url, Map<String,String> requestHeaders, String content)
            throws IOException, HttpException {
        HttpURLConnection c = null;
        try {
            if (requestHeaders == null) {
                requestHeaders = new HashMap<String, String>();
            }
            requestHeaders.put(""Content-Length"",
                    Integer.toString(content == null ? 0 : content.length()));
            c = createConnection(url, requestHeaders);
            c.setDoOutput(content != null);
            c.setRequestMethod(""POST"");
            c.connect();
            if (content != null) {
                OutputStreamWriter writer = new OutputStreamWriter(c.getOutputStream());
                writer.write(content);
                writer.close();
            }
            return getResponseFrom(c);
        } finally {
            if (c != null) {
                c.disconnect();
            }
        }
    }

    private HttpURLConnection createConnection(String url, Map<String, String> headers)
            throws IOException, HttpException {
        URL u = new URL(mRewriter.rewrite(url));
        if (DBG) Log.d(TAG, ""URL="" + url + "" rewritten='"" + u + ""'"");
        HttpURLConnection c = (HttpURLConnection) u.openConnection();
        if (headers != null) {
            for (Map.Entry<String,String> e : headers.entrySet()) {
                String name = e.getKey();
                String value = e.getValue();
                if (DBG) Log.d(TAG, ""  "" + name + "": "" + value);
                c.addRequestProperty(name, value);
            }
        }
        c.addRequestProperty(USER_AGENT_HEADER, mUserAgent);
        if (mConnectTimeout != 0) {
            c.setConnectTimeout(mConnectTimeout);
        }
        if (mReadTimeout != 0) {
            c.setReadTimeout(mReadTimeout);
        }
        return c;
    }

    private String getResponseFrom(HttpURLConnection c) throws IOException, HttpException {
        if (c.getResponseCode() != HttpURLConnection.HTTP_OK) {
            throw new HttpException(c.getResponseCode(), c.getResponseMessage());
        }
        if (DBG) {
            Log.d(TAG, ""Content-Type: "" + c.getContentType() + "" (assuming "" +
                    DEFAULT_CHARSET + "")"");
        }
        BufferedReader reader = new BufferedReader(
                new InputStreamReader(c.getInputStream(), DEFAULT_CHARSET));
        StringBuilder string = new StringBuilder();
        char[] chars = new char[BUFFER_SIZE];
        int bytes;
        while ((bytes = reader.read(chars)) != -1) {
            string.append(chars, 0, bytes);
        }
        return string.toString();
    }

    public void setConnectTimeout(int timeoutMillis) {
        mConnectTimeout = timeoutMillis;
    }

    public void setReadTimeout(int timeoutMillis) {
        mReadTimeout = timeoutMillis;
    }

    /**
     * A Url rewriter that does nothing, i.e., returns the
     * url that is passed to it.
     */
    public static class PassThroughRewriter implements UrlRewriter {
        @Override
        public String rewrite(String url) {
            return url;
        }
    }
}
",True,34,4,19,1,1,1,1,L8
90,com.android.quicksearchbox.util.Consumer.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

/**
 * Interface for data consumers.
 *
 * @param <A> The type of data to consume.
 */
public interface Consumer<A> {

    /**
     * Consumes a value.
     *
     * @param value The value to consume.
     * @return {@code true} if the value was accepted, {@code false} otherwise.
     */
    boolean consume(A value);

}
",False,148,5,50,0,0,21,0,L0
91,com.android.quicksearchbox.util.Util.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.net.Uri;
import android.util.Log;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * General utilities.
 */
public class Util {

    private static final String TAG = ""QSB.Util"";

    public static <A> Set<A> setOfFirstN(List<A> list, int n) {
        int end = Math.min(list.size(), n);
        HashSet<A> set = new HashSet<A>(end);
        for (int i = 0; i < end; i++) {
            set.add(list.get(i));
        }
        return set;
    }

    public static Uri getResourceUri(Context packageContext, int res) {
        try {
            Resources resources = packageContext.getResources();
            return getResourceUri(resources, packageContext.getPackageName(), res);
        } catch (Resources.NotFoundException e) {
            Log.e(TAG, ""Resource not found: "" + res + "" in "" + packageContext.getPackageName());
            return null;
        }
    }

    public static Uri getResourceUri(Context context, ApplicationInfo appInfo, int res) {
        try {
            Resources resources = context.getPackageManager().getResourcesForApplication(appInfo);
            return getResourceUri(resources, appInfo.packageName, res);
        } catch (PackageManager.NameNotFoundException e) {
            Log.e(TAG, ""Resources not found for "" + appInfo.packageName);
            return null;
        } catch (Resources.NotFoundException e) {
            Log.e(TAG, ""Resource not found: "" + res + "" in "" + appInfo.packageName);
            return null;
        }
    }

    private static Uri getResourceUri(Resources resources, String appPkg, int res)
            throws Resources.NotFoundException {
        String resPkg = resources.getResourcePackageName(res);
        String type = resources.getResourceTypeName(res);
        String name = resources.getResourceEntryName(res);
        return makeResourceUri(appPkg, resPkg, type, name);
    }

    private static Uri makeResourceUri(String appPkg, String resPkg, String type, String name) {
        Uri.Builder uriBuilder = new Uri.Builder();
        uriBuilder.scheme(ContentResolver.SCHEME_ANDROID_RESOURCE);
        uriBuilder.encodedAuthority(appPkg);
        uriBuilder.appendEncodedPath(type);
        if (!appPkg.equals(resPkg)) {
            uriBuilder.appendEncodedPath(resPkg + "":"" + name);
        } else {
            uriBuilder.appendEncodedPath(name);
        }
        return uriBuilder.build();
    }
}
",False,38,4,18,0,0,7,0,L0
92,com.android.quicksearchbox.util.PriorityThreadFactory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.os.Process;

import java.util.concurrent.ThreadFactory;

/**
 * A thread factory that creates threads with a given thread priority.
 */
public class PriorityThreadFactory implements ThreadFactory {

    private final int mPriority;

    /**
     * Creates a new thread factory.
     *
     * @param priority The thread priority of the threads created by this factory.
     *        For values, see {@link Process}.
     */
    public PriorityThreadFactory(int priority) {
        mPriority = priority;
    }

    public Thread newThread(Runnable r) {
        return new Thread(r) {
            @Override
            public void run() {
                Process.setThreadPriority(mPriority);
                super.run();
            }
        };
    }

}
",True,35,4,19,0,0,3,0,L0
93,com.android.quicksearchbox.util.HttpHelper.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * An interface that can issue HTTP GET / POST requests
 * with timeouts.
 */
public interface HttpHelper {

    public String get(GetRequest request) throws IOException, HttpException;

    public String get(String url, Map<String,String> requestHeaders)
            throws IOException, HttpException;

    public String post(PostRequest request) throws IOException, HttpException;

    public String post(String url, Map<String,String> requestHeaders, String content)
            throws IOException, HttpException;

    public void setConnectTimeout(int timeoutMillis);

    public void setReadTimeout(int timeoutMillis);

    public static class GetRequest {
        private String mUrl;
        private Map<String,String> mHeaders;

        /**
         * Creates a new request.
         */
        public GetRequest() {
        }

        /**
         * Creates a new request.
         *
         * @param url Request URI.
         */
        public GetRequest(String url) {
            mUrl = url;
        }

        /**
         * Gets the request URI.
         */
        public String getUrl() {
            return mUrl;
        }
        /**
         * Sets the request URI.
         */
        public void setUrl(String url) {
            mUrl = url;
        }

        /**
         * Gets the request headers.
         *
         * @return The response headers. May return {@code null} if no headers are set.
         */
        public Map<String, String> getHeaders() {
            return mHeaders;
        }

        /**
         * Sets a request header.
         *
         * @param name Header name.
         * @param value Header value.
         */
        public void setHeader(String name, String value) {
            if (mHeaders == null) {
                mHeaders = new HashMap<String,String>();
            }
            mHeaders.put(name, value);
        }
    }

    public static class PostRequest extends GetRequest {

        private String mContent;

        public PostRequest() {
        }

        public PostRequest(String url) {
            super(url);
        }

        public void setContent(String content) {
            mContent = content;
        }

        public String getContent() {
            return mContent;
        }
    }

    /**
     * A HTTP exception.
     */
    public static class HttpException extends IOException {
        private final int mStatusCode;
        private final String mReasonPhrase;

        public HttpException(int statusCode, String reasonPhrase) {
            super(statusCode + "" "" + reasonPhrase);
            mStatusCode = statusCode;
            mReasonPhrase = reasonPhrase;
        }

        /**
         * Gets the HTTP response status code.
         */
        public int getStatusCode() {
            return mStatusCode;
        }

        /**
         * Gets the HTTP response reason phrase.
         */
        public String getReasonPhrase() {
            return mReasonPhrase;
        }
    }

    /**
     * An interface for URL rewriting.
     */
    public static interface UrlRewriter {
      public String rewrite(String url);
    }
}
",False,34,4,19,0,0,3,0,L8
94,com.android.quicksearchbox.util.AsyncDataSetObservable.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.database.DataSetObservable;
import android.os.Handler;

/**
 * A version of {@link DataSetObservable} that performs callbacks on given {@link Handler}.
 */
public class AsyncDataSetObservable extends DataSetObservable {

    private final Handler mHandler;

    private final Runnable mChangedRunnable = new Runnable() {
        public void run() {
            AsyncDataSetObservable.super.notifyChanged();
        }
    };

    private final Runnable mInvalidatedRunnable = new Runnable() {
        public void run() {
            AsyncDataSetObservable.super.notifyInvalidated();
        }
    };

    /**
     * @param handler Handler to run callbacks on.
     */
    public AsyncDataSetObservable(Handler handler) {
        mHandler = handler;
    }

    @Override
    public void notifyChanged() {
        if (mHandler == null) {
            super.notifyChanged();
        } else {
            mHandler.post(mChangedRunnable);
        }
    }

    @Override
    public void notifyInvalidated() {
        if (mHandler == null) {
            super.notifyInvalidated();
        } else {
            mHandler.post(mInvalidatedRunnable);
        }
    }

}
",False,1,0,0,0,0,0,0,I0
95,com.android.quicksearchbox.util.BarrierConsumer.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import java.util.ArrayList;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * A consumer that consumes a fixed number of values. When the expected number of values
 * has been consumed, further values are rejected.
 */
public class BarrierConsumer<A> implements Consumer<A> {

    private final Lock mLock = new ReentrantLock();
    private final Condition mNotFull = mLock.newCondition();

    private final int mExpectedCount;

    // Set to null when getValues() returns.
    private ArrayList<A> mValues;

    /**
     * Constructs a new BarrierConsumer.
     *
     * @param expectedCount The number of values to consume.
     */
    public BarrierConsumer(int expectedCount) {
        mExpectedCount = expectedCount;
        mValues = new ArrayList<A>(expectedCount);
    }

    /**
     * Blocks until the expected number of results is available, or until the thread is
     * interrupted. This method should not be called multiple times.
     *
     * @return A list of values, never {@code null}.
     */
    public ArrayList<A> getValues() {
        mLock.lock();
        try {
            try {
                while (!isFull()) {
                    mNotFull.await();
                }
            } catch (InterruptedException ex) {
                // Return the values that we've gotten so far
            }
            ArrayList<A> values = mValues;
            mValues = null;  // mark that getValues() has returned
            return values;
        } finally {
            mLock.unlock();
        }
    }

    public boolean consume(A value) {
        mLock.lock();
        try {
            // Do nothing if getValues() has alrady returned,
            // or enough values have already been consumed
            if (mValues == null || isFull()) {
                return false;
            }
            mValues.add(value);
            if (isFull()) {
                // Wake up any thread waiting in getValues()
                mNotFull.signal();
            }
            return true;
        } finally {
            mLock.unlock();
        }
    }

    private boolean isFull() {
        return mValues.size() == mExpectedCount;
    }
}
",False,37,7,19,1,1,1,1,L4
96,com.android.quicksearchbox.util.NamedTaskExecutor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

/**
 * Runs tasks that have a name tag.
 */
public interface NamedTaskExecutor {

    /**
     * Schedules a task for execution. Implementations should not throw
     * {@link java.util.concurrent.RejectedExecutionException} if the task
     * cannot be run. They should drop it silently instead.
     */
    void execute(NamedTask task);

    /**
     * Stops any unstarted tasks from running. Implementations of this method must be
     * idempotent.
     */
    void cancelPendingTasks();

    /**
     * Shuts down this executor, freeing any resources that it owns. The executor
     * may not be used after calling this method. Implementations of this method must be
     * idempotent.
     */
    void close();

}
",False,51,3,22,1,1,20,1,L0
97,com.android.quicksearchbox.util.QuietlyCloseable.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import java.io.Closeable;

/**
 * Interface for closeable objects whose close method doesn't throw IOExceptions.
 */
public interface QuietlyCloseable extends Closeable {

    void close();

}
",False,132,5,55,0,0,2,0,L1
98,com.android.quicksearchbox.util.Consumers.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.os.Handler;

/**
 * Consumer utilities.
 */
public class Consumers {

    private Consumers() {}

    public static <A extends QuietlyCloseable> void consumeCloseable(Consumer<A> consumer,
            A value) {
        boolean accepted = false;
        try {
            accepted = consumer.consume(value);
        } finally {
            if (!accepted && value != null) value.close();
        }
    }

    public static <A> void consumeAsync(Handler handler,
            final Consumer<A> consumer, final A value) {
        if (handler == null) {
            consumer.consume(value);
        } else {
            handler.post(new Runnable() {
                public void run() {
                    consumer.consume(value);
                }
            });
        }
    }

    public static <A extends QuietlyCloseable> void consumeCloseableAsync(Handler handler,
            final Consumer<A> consumer, final A value) {
        if (handler == null) {
            consumeCloseable(consumer, value);
        } else {
            handler.post(new Runnable() {
                public void run() {
                    consumeCloseable(consumer, value);
                }
            });
        }
    }

    public static <A> Consumer<A> createAsyncConsumer(
            final Handler handler, final Consumer<A> consumer) {
        return new Consumer<A>() {
            public boolean consume(A value) {
                consumeAsync(handler, consumer, value);
                return true;
            }
        };
    }

    public static <A extends QuietlyCloseable> Consumer<A> createAsyncCloseableConsumer(
            final Handler handler, final Consumer<A> consumer) {
        return new Consumer<A>() {
            public boolean consume(A value) {
                consumeCloseableAsync(handler, consumer, value);
                return true;
            }
        };
    }

}
",False,44,5,16,1,2,4,2,L2
99,com.android.quicksearchbox.util.NamedTask.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

/**
 * A task that has a name.
 */
public interface NamedTask extends Runnable {

    String getName();

}
",False,52,4,20,0,0,9,0,L0
100,com.android.quicksearchbox.util.SQLiteTransaction.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.database.sqlite.SQLiteDatabase;

/**
 * Abstract helper base class for SQLite write transactions.
 */
public abstract class SQLiteTransaction {

    /**
     * Executes the statements that form the transaction.
     *
     * @param db A writable database.
     * @return {@code true} if the transaction should be committed.
     */
    protected abstract boolean performTransaction(SQLiteDatabase db);

    /**
     * Runs the transaction against the database. The results are committed if
     * {@link #performTransaction(SQLiteDatabase)} completes normally and returns {@code true}.
     */
    public void run(SQLiteDatabase db) {
        db.beginTransaction();
        try {
            if (performTransaction(db)) {
                db.setTransactionSuccessful();
            }
        } finally {
            db.endTransaction();
        }
    }
}
",False,35,5,19,0,0,1,0,L5
101,com.android.quicksearchbox.util.SQLiteAsyncQuery.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.database.sqlite.SQLiteDatabase;

/**
 * Abstract helper base class for asynchronous SQLite queries.
 *
 * @param <A> The type of the result of the query.
 */
public abstract class SQLiteAsyncQuery<A> {

    /**
     * Performs a query and computes some value from the result
     *
     * @param db A readable database.
     * @return The result of the query.
     */
    protected abstract A performQuery(SQLiteDatabase db);

    /**
     * Runs the query against the database and passes the result to the consumer.
     */
    public void run(SQLiteDatabase db, Consumer<A> consumer) {
        A result = performQuery(db);
        consumer.consume(result);
    }
}
",False,36,5,19,1,1,1,1,L5
102,com.android.quicksearchbox.util.PerNameExecutor.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;


import java.util.HashMap;

/**
 * Uses a separate executor for each task name.
 */
public class PerNameExecutor implements NamedTaskExecutor {

    private final Factory<NamedTaskExecutor> mExecutorFactory;
    private HashMap<String, NamedTaskExecutor> mExecutors;

    /**
     * @param executorFactory Used to run the commands.
     */
    public PerNameExecutor(Factory<NamedTaskExecutor> executorFactory) {
        mExecutorFactory = executorFactory;
    }

    public synchronized void cancelPendingTasks() {
        if (mExecutors == null) return;
        for (NamedTaskExecutor executor : mExecutors.values()) {
            executor.cancelPendingTasks();
        }
    }

    public synchronized void close() {
        if (mExecutors == null) return;
        for (NamedTaskExecutor executor : mExecutors.values()) {
            executor.close();
        }
    }

    public synchronized void execute(NamedTask task) {
        if (mExecutors == null) {
            mExecutors = new HashMap<String, NamedTaskExecutor>();
        }
        String name = task.getName();
        NamedTaskExecutor executor = mExecutors.get(name);
        if (executor == null) {
            executor = mExecutorFactory.create();
            mExecutors.put(name, executor);
        }
        executor.execute(task);
    }

}
",False,37,4,19,1,3,2,3,L1
103,com.android.quicksearchbox.util.NowOrLaterWrapper.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.util;

/**
 * {@link NowOrLater} class that converts from one type to another.
 */
public abstract class NowOrLaterWrapper<A, B> implements NowOrLater<B> {

    private final NowOrLater<A> mWrapped;

    public NowOrLaterWrapper(NowOrLater<A> wrapped) {
        mWrapped = wrapped;
    }

    public void getLater(final Consumer<? super B> consumer) {
        mWrapped.getLater(new Consumer<A>(){
            public boolean consume(A value) {
                return consumer.consume(get(value));
            }});
    }

    public B getNow() {
        return get(mWrapped.getNow());
    }

    public boolean haveNow() {
        return mWrapped.haveNow();
    }

    /**
     * Perform the appropriate conversion. This will be called once for every call to 
     * {@link #getLater(Consumer)} or {@link #getNow()}. The thread that it's called on will depend
     * on the behaviour of the wrapped object and the caller.
     */
    public abstract B get(A value);

}
",False,37,6,17,1,2,1,2,L2
104,com.android.quicksearchbox.util.BatchingNamedTaskExecutor.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;


import android.util.Log;

import java.util.ArrayList;
import java.util.List;

/**
 * Executes NamedTasks in batches of a given size.  Tasks are queued until
 * executeNextBatch is called.
 */
public class BatchingNamedTaskExecutor implements NamedTaskExecutor {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.BatchingNamedTaskExecutor"";

    private final NamedTaskExecutor mExecutor;

    /** Queue of tasks waiting to be dispatched to mExecutor **/
    private final ArrayList<NamedTask> mQueuedTasks = new ArrayList<NamedTask>();

    /**
     * Creates a new BatchingSourceTaskExecutor.
     *
     * @param executor A SourceTaskExecutor for actually executing the tasks.
     */
    public BatchingNamedTaskExecutor(NamedTaskExecutor executor) {
        mExecutor = executor;
    }

    public void execute(NamedTask task) {
        synchronized (mQueuedTasks) {
            if (DBG) Log.d(TAG, ""Queuing "" + task);
            mQueuedTasks.add(task);
        }
    }

    private void dispatch(NamedTask task) {
        if (DBG) Log.d(TAG, ""Dispatching "" + task);
        mExecutor.execute(task);
    }

    /**
     * Instructs the executor to submit the next batch of results.
     * @param batchSize the maximum number of entries to execute.
     */
    public void executeNextBatch(int batchSize) {
        NamedTask[] batch = new NamedTask[0];
        synchronized (mQueuedTasks) {
            int count = Math.min(mQueuedTasks.size(), batchSize);
            List<NamedTask> nextTasks = mQueuedTasks.subList(0, count);
            batch = nextTasks.toArray(batch);
            nextTasks.clear();
            if (DBG) Log.d(TAG, ""Dispatching batch of "" + count);
        }

        for (NamedTask task : batch) {
            dispatch(task);
        }
    }

    /**
     * Cancel any unstarted tasks running in this executor.  This instance 
     * should not be re-used after calling this method.
     */
    public void cancelPendingTasks() {
        synchronized (mQueuedTasks) {
            mQueuedTasks.clear();
        }
    }

    public void close() {
        cancelPendingTasks();
        mExecutor.close();
    }
}
",False,37,5,19,1,2,1,2,L6
105,com.android.quicksearchbox.util.NoOpConsumer.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import com.android.quicksearchbox.util.Consumer;

/**
  * A Consumer that does nothing with the objects it receives.
  */
public class NoOpConsumer<A> implements Consumer<A> {
    public boolean consume(A result) {
        // Tell the caller that we haven't taken ownership of this result.
        return false;
    }
}

",False,36,5,19,1,1,1,1,L6
106,com.android.quicksearchbox.util.NowOrLater.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.util;

/**
 * Interface for an object that may be constructed asynchronously. In cases when the object is ready
 * (on constructible) immediately, it provides synchronous access to it. Otherwise, the object can
 * be sent to a {@link Consumer} later.
 */
public interface NowOrLater<C> {

    /**
     * Indicates if the object is ready (or constructible synchronously).
     */
    boolean haveNow();

    /**
     * Gets the object now. Should only be called if {@link #haveNow()} returns {@code true},
     * otherwise an {@link IllegalStateException} will be thrown.
     */
    C getNow();

    /**
     * Request the object asynchronously. This can be called even if the object is ready now, in
     * which case the callback may be made in context. The thread on which the consumer is called
     * back depends on the implementation.
     */
    void getLater(Consumer<? super C> consumer);

}
",False,143,5,54,1,1,12,1,L0
107,com.android.quicksearchbox.util.LevenshteinDistance.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

/**
 * This class represents the matrix used in the Levenshtein distance algorithm, together
 * with the algorithm itself which operates on the matrix.
 *
 * We also track of the individual operations applied to transform the source string into the
 * target string so we can trace the path taken through the matrix afterwards, in order to
 * perform the formatting as required.
 */
public class LevenshteinDistance {
    public static final int EDIT_DELETE = 0;
    public static final int EDIT_INSERT = 1;
    public static final int EDIT_REPLACE = 2;
    public static final int EDIT_UNCHANGED = 3;

    private final Token[] mSource;
    private final Token[] mTarget;
    private final int[][] mEditTypeTable;
    private final int[][] mDistanceTable;

    public LevenshteinDistance(Token[] source, Token[] target) {
        final int sourceSize = source.length;
        final int targetSize = target.length;
        final int[][] editTab = new int[sourceSize+1][targetSize+1];
        final int[][] distTab = new int[sourceSize+1][targetSize+1];
        editTab[0][0] = EDIT_UNCHANGED;
        distTab[0][0] = 0;
        for (int i = 1; i <= sourceSize; ++i) {
            editTab[i][0] = EDIT_DELETE;
            distTab[i][0] = i;
        }
        for (int i = 1; i <= targetSize; ++i) {
            editTab[0][i] = EDIT_INSERT;
            distTab[0][i] = i;
        }
        mEditTypeTable = editTab;
        mDistanceTable = distTab;
        mSource = source;
        mTarget = target;
    }

    /**
     * Implementation of Levenshtein distance algorithm.
     *
     * @return The Levenshtein distance.
     */
    public int calculate() {
        final Token[] src = mSource;
        final Token[] trg = mTarget;
        final int sourceLen = src.length;
        final int targetLen = trg.length;
        final int[][] distTab = mDistanceTable;
        final int[][] editTab = mEditTypeTable;
        for (int s = 1; s <= sourceLen; ++s) {
            Token sourceToken = src[s-1];
            for (int t = 1; t <= targetLen; ++t) {
                Token targetToken = trg[t-1];
                int cost = sourceToken.prefixOf(targetToken) ? 0 : 1;

                int distance = distTab[s-1][t] + 1;
                int type = EDIT_DELETE;

                int d = distTab[s][t - 1];
                if (d + 1 < distance ) {
                    distance = d + 1;
                    type = EDIT_INSERT;
                }

                d = distTab[s - 1][t - 1];
                if (d + cost < distance) {
                    distance = d + cost;
                    type = cost == 0 ? EDIT_UNCHANGED : EDIT_REPLACE;
                }
                distTab[s][t] = distance;
                editTab[s][t] = type;
            }
        }
        return distTab[sourceLen][targetLen];
    }

    /**
     * Gets the list of operations which were applied to each target token; {@link #calculate} must
     * have been called on this object before using this method.
     * @return A list of {@link EditOperation}s indicating the origin of each token in the target
     *      string. The position of the token indicates the position in the source string of the
     *      token that was unchanged/replaced, or the position in the source after which a target
     *      token was inserted.
     */
    public EditOperation[] getTargetOperations() {
        final int trgLen = mTarget.length;
        final EditOperation[] ops = new EditOperation[trgLen];
        int targetPos = trgLen;
        int sourcePos = mSource.length;
        final int[][] editTab = mEditTypeTable;
        while (targetPos > 0) {
            int editType = editTab[sourcePos][targetPos];
            switch (editType) {
                case LevenshteinDistance.EDIT_DELETE:
                    sourcePos--;
                    break;
                case LevenshteinDistance.EDIT_INSERT:
                    targetPos--;
                    ops[targetPos] = new EditOperation(editType, sourcePos);
                    break;
                case LevenshteinDistance.EDIT_UNCHANGED:
                case LevenshteinDistance.EDIT_REPLACE:
                    targetPos--;
                    sourcePos--;
                    ops[targetPos] = new EditOperation(editType, sourcePos);
                    break;
            }
        }

        return ops;
    }

    public static final class EditOperation {
        private final int mType;
        private final int mPosition;
        public EditOperation(int type, int position) {
            mType = type;
            mPosition = position;
        }
        public int getType() {
            return mType;
        }
        public int getPosition() {
            return mPosition;
        }
    }

    public static final class Token implements CharSequence {
        private final char[] mContainer;
        public final int mStart;
        public final int mEnd;

        public Token(char[] container, int start, int end) {
            mContainer = container;
            mStart = start;
            mEnd = end;
        }

        public int length() {
            return mEnd - mStart;
        }

        @Override
        public String toString() {
            // used in tests only.
            return subSequence(0, length());
        }

        public boolean prefixOf(final Token that) {
            final int len = length();
            if (len > that.length()) return false;
            final int thisStart = mStart;
            final int thatStart = that.mStart;
            final char[] thisContainer = mContainer;
            final char[] thatContainer = that.mContainer;
            for (int i = 0; i < len; ++i) {
                if (thisContainer[thisStart + i] != thatContainer[thatStart + i]) {
                    return false;
                }
            }
            return true;
        }

        public char charAt(int index) {
            return mContainer[index + mStart];
        }

        public String subSequence(int start, int end) {
            return new String(mContainer, mStart + start, length());
        }

    }
}
",False,36,5,19,0,0,3,0,L0
108,com.android.quicksearchbox.util.SingleThreadNamedTaskExecutor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.util.Log;

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;

/**
 * Executor that uses a single thread and an unbounded work queue.
 */
public class SingleThreadNamedTaskExecutor implements NamedTaskExecutor {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SingleThreadNamedTaskExecutor"";

    private final LinkedBlockingQueue<NamedTask> mQueue;
    private final Thread mWorker;
    private volatile boolean mClosed = false;

    public SingleThreadNamedTaskExecutor(ThreadFactory threadFactory) {
        mQueue = new LinkedBlockingQueue<NamedTask>();
        mWorker = threadFactory.newThread(new Worker());
        mWorker.start();
    }

    public void cancelPendingTasks() {
        if (DBG) Log.d(TAG, ""Cancelling "" + mQueue.size() + "" tasks: "" + mWorker.getName());
        if (mClosed) {
            throw new IllegalStateException(""cancelPendingTasks() after close()"");
        }
        mQueue.clear();
    }

    public void close() {
        mClosed = true;
        mWorker.interrupt();
        mQueue.clear();
    }

    public void execute(NamedTask task) {
        if (mClosed) {
            throw new IllegalStateException(""execute() after close()"");
        }
        mQueue.add(task);
    }

    private class Worker implements Runnable {
        public void run() {
            try {
                loop();
            } finally {
                if (!mClosed) Log.w(TAG, ""Worker exited before close"");
            }
        }

        private void loop() {
            Thread currentThread = Thread.currentThread();
            String threadName = currentThread.getName();
            while (!mClosed) {
                NamedTask task;
                try {
                    task = mQueue.take();
                } catch (InterruptedException ex) {
                    continue;
                }
                currentThread.setName(threadName + "" "" + task.getName());
                try {
                    if (DBG) Log.d(TAG, ""Running task "" + task.getName());
                    task.run();
                    if (DBG) Log.d(TAG, ""Task "" + task.getName() + "" complete"");
                } catch (RuntimeException ex) {
                    Log.e(TAG, ""Task "" + task.getName() + "" failed"", ex);
                }
            }
        }
    }

    public static Factory<NamedTaskExecutor> factory(final ThreadFactory threadFactory) {
        return new Factory<NamedTaskExecutor>() {
            public NamedTaskExecutor create() {
                return new SingleThreadNamedTaskExecutor(threadFactory);
            }
        };
    }

}
",True,38,4,19,1,3,3,3,L1
109,com.android.quicksearchbox.util.CachedLater.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.util.Log;

import java.util.ArrayList;
import java.util.List;

/**
 * Abstract base class for a one-place cache that holds a value that is produced
 * asynchronously.
 *
 * @param <A> The type of the data held in the cache.
 */
public abstract class CachedLater<A> implements NowOrLater<A> {

    private static final String TAG = ""QSB.AsyncCache"";
    private static final boolean DBG = false;

    private final Object mLock = new Object();

    private A mValue;

    private boolean mCreating;
    private boolean mValid;

    private List<Consumer<? super A>> mWaitingConsumers;

    /**
     * Creates the object to store in the cache. This method must call
     * {@link #store} when it's done.
     * This method must not block.
     */
    protected abstract void create();

    /**
     * Saves a new value to the cache.
     */
    protected void store(A value) {
        if (DBG) Log.d(TAG, ""store()"");
        List<Consumer<? super A>> waitingConsumers;
        synchronized (mLock) {
            mValue = value;
            mValid = true;
            mCreating = false;
            waitingConsumers = mWaitingConsumers;
            mWaitingConsumers = null;
        }
        if (waitingConsumers != null) {
            for (Consumer<? super A> consumer : waitingConsumers) {
                if (DBG) Log.d(TAG, ""Calling consumer: "" + consumer);
                consumer.consume(value);
            }
        }
    }

    /**
     * Gets the value.
     *
     * @param consumer A consumer that will be given the cached value.
     *        The consumer may be called synchronously, or asynchronously on
     *        an unspecified thread.
     */
    public void getLater(Consumer<? super A> consumer) {
        if (DBG) Log.d(TAG, ""getLater()"");
        boolean valid;
        A value;
        synchronized (mLock) {
            valid = mValid;
            value = mValue;
            if (!valid) {
                if (mWaitingConsumers == null) {
                    mWaitingConsumers = new ArrayList<Consumer<? super A>>();
                }
                mWaitingConsumers.add(consumer);
            }
        }
        if (valid) {
            if (DBG) Log.d(TAG, ""valid, calling consumer synchronously"");
            consumer.consume(value);
        } else {
            boolean create = false;
            synchronized (mLock) {
                if (!mCreating) {
                    mCreating = true;
                    create = true;
                }
            }
            if (create) {
                if (DBG) Log.d(TAG, ""not valid, calling create()"");
                create();
            } else {
                if (DBG) Log.d(TAG, ""not valid, already creating"");
            }
        }
    }

    /**
     * Clears the cache.
     */
    public void clear() {
        if (DBG) Log.d(TAG, ""clear()"");
        synchronized (mLock) {
            mValue = null;
            mValid = false;
        }
    }

    public boolean haveNow() {
        synchronized (mLock) {
            return mValid;
        }
    }

    public synchronized A getNow() {
        synchronized (mLock) {
            if (!haveNow()) {
                throw new IllegalStateException(""getNow() called when haveNow() is false"");
            }
            return mValue;
        }
    }

}
",False,42,4,22,1,2,4,2,L1
110,com.android.quicksearchbox.util.Factory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

public interface Factory<A> {

    A create();

}
",False,39,4,22,0,0,5,0,L0
111,com.android.quicksearchbox.util.Now.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.util;

/**
 * A {@link NowOrLater} object that is always ready now.
 */
public class Now<C> implements NowOrLater<C> {

    private final C mValue;

    public Now(C value) {
        mValue = value;
    }

    public void getLater(Consumer<? super C> consumer) {
        consumer.consume(getNow());
    }

    public C getNow() {
        return mValue;
    }

    public boolean haveNow() {
        return true;
    }

}
",False,57,6,17,1,2,4,2,L1
112,com.android.quicksearchbox.ui.QueryTextView.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.ui;

import android.content.Context;
import android.util.AttributeSet;
import android.util.Log;
import android.view.inputmethod.CompletionInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;

/**
 * The query text field.
 */
public class QueryTextView extends EditText {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.QueryTextView"";

    private CommitCompletionListener mCommitCompletionListener;

    public QueryTextView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    public QueryTextView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public QueryTextView(Context context) {
        super(context);
    }

    /**
     * Sets the text selection in the query text view.
     *
     * @param selectAll If {@code true}, selects the entire query.
     *        If {@false}, no characters are selected, and the cursor is placed
     *        at the end of the query.
     */
    public void setTextSelection(boolean selectAll) {
        if (selectAll) {
            selectAll();
        } else {
            setSelection(length());
        }
    }

    protected void replaceText(CharSequence text) {
        clearComposingText();
        setText(text);
        setTextSelection(false);
    }

    public void setCommitCompletionListener(CommitCompletionListener listener) {
        mCommitCompletionListener = listener;
    }

    private InputMethodManager getInputMethodManager() {
        return (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
    }

    public void showInputMethod() {
        InputMethodManager imm = getInputMethodManager();
        if (imm != null) {
            imm.showSoftInput(this, 0);
        }
    }

    public void hideInputMethod() {
        InputMethodManager imm = getInputMethodManager();
        if (imm != null) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
    }

    @Override
    public void onCommitCompletion(CompletionInfo completion) {
        if (DBG) Log.d(TAG, ""onCommitCompletion("" + completion + "")"");
        hideInputMethod();
        replaceText(completion.getText());
        if (mCommitCompletionListener != null) {
            mCommitCompletionListener.onCommitCompletion(completion.getPosition());
        }
    }

    public interface CommitCompletionListener {
        void onCommitCompletion(int position);
    }

}
",False,7,3,2,0,0,2,0,L9
113,com.android.quicksearchbox.ui.BaseSuggestionView.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.R;
import com.android.quicksearchbox.Suggestion;

import android.content.Context;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.view.View;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;

/**
 * Base class for suggestion views.
 */
public abstract class BaseSuggestionView extends RelativeLayout implements SuggestionView {

    protected TextView mText1;
    protected TextView mText2;
    protected ImageView mIcon1;
    protected ImageView mIcon2;
    private long mSuggestionId;
    private SuggestionsAdapter<?> mAdapter;

    public BaseSuggestionView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    public BaseSuggestionView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public BaseSuggestionView(Context context) {
        super(context);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mText1 = (TextView) findViewById(R.id.text1);
        mText2 = (TextView) findViewById(R.id.text2);
        mIcon1 = (ImageView) findViewById(R.id.icon1);
        mIcon2 = (ImageView) findViewById(R.id.icon2);
    }

    public void bindAsSuggestion(Suggestion suggestion, String userQuery) {
        setOnClickListener(new ClickListener());
        if (isFromHistory(suggestion)) {
            setLongClickable(true);
            setOnLongClickListener(new LongClickListener());
        } else {
            setLongClickable(false);
            setOnLongClickListener(null);
        }
    }

    public void bindAdapter(SuggestionsAdapter<?> adapter, long suggestionId) {
        mAdapter = adapter;
        mSuggestionId = suggestionId;
    }

    protected boolean isFromHistory(Suggestion suggestion) {
        return suggestion.isSuggestionShortcut() || suggestion.isHistorySuggestion();
    }

    /**
     * Sets the first text line.
     */
    protected void setText1(CharSequence text) {
        mText1.setText(text);
    }

    /**
     * Sets the second text line.
     */
    protected void setText2(CharSequence text) {
        mText2.setText(text);
        if (TextUtils.isEmpty(text)) {
            mText2.setVisibility(GONE);
        } else {
            mText2.setVisibility(VISIBLE);
        }
    }

    protected void onSuggestionClicked() {
        if (mAdapter != null) {
            mAdapter.onSuggestionClicked(mSuggestionId);
        }
    }

    protected void onSuggestionQuickContactClicked() {
        if (mAdapter != null) {
            mAdapter.onSuggestionQuickContactClicked(mSuggestionId);
        }
    }

    protected void onRemoveFromHistoryClicked() {
        if (mAdapter != null) {
            mAdapter.onSuggestionRemoveFromHistoryClicked(mSuggestionId);
        }
    }

    protected void onSuggestionQueryRefineClicked() {
        if (mAdapter != null) {
            mAdapter.onSuggestionQueryRefineClicked(mSuggestionId);
        }
    }

    private class ClickListener implements OnClickListener {
        public void onClick(View v) {
            onSuggestionClicked();
        }
    }

    private class LongClickListener implements View.OnLongClickListener {
        public boolean onLongClick(View v) {
            onRemoveFromHistoryClicked();
            return true;
        }
    }

}
",False,60,6,18,4,12,3,3,L8
114,com.android.quicksearchbox.ui.CorporaAdapter.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Corpora;
import com.android.quicksearchbox.Corpus;
import com.android.quicksearchbox.R;

import android.content.Context;
import android.database.DataSetObserver;
import android.graphics.drawable.Drawable;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/**
 * Adapter for showing a list of sources in the source selection activity.
 */
public class CorporaAdapter extends BaseAdapter {

    private static final String TAG = ""CorporaAdapter"";
    private static final boolean DBG = false;

    private final Context mContext;

    private final Corpora mCorpora;

    private final int mCorpusViewRes;

    private final DataSetObserver mCorporaObserver = new CorporaObserver();

    private List<Corpus> mSortedCorpora;

    private String mCurrentCorpusName;

    public CorporaAdapter(Context context, Corpora corpora, int corpusViewRes) {
        mContext = context;
        mCorpora = corpora;
        mCorpusViewRes = corpusViewRes;
        mCorpora.registerDataSetObserver(mCorporaObserver);
        updateCorpora();
    }

    public void setCurrentCorpus(Corpus corpus) {
        mCurrentCorpusName = corpus == null ? null : corpus.getName();
        notifyDataSetChanged();
    }

    private void updateCorpora() {
        List<Corpus> enabledCorpora = mCorpora.getEnabledCorpora();
        ArrayList<Corpus> sorted = new ArrayList<Corpus>(enabledCorpora.size());
        for (Corpus corpus : enabledCorpora) {
            if (!corpus.isCorpusHidden()) {
                sorted.add(corpus);
            }
        }
        Collections.sort(sorted, new CorpusComparator());
        mSortedCorpora = sorted;
        notifyDataSetChanged();
    }

    private static class CorpusComparator implements Comparator<Corpus> {
        public int compare(Corpus corpus1, Corpus corpus2) {
            // Comparing a corpus against itself
            if (corpus1 == corpus2) return 0;
            // Web always comes first
            if (corpus1.isWebCorpus()) return -1;
            if (corpus2.isWebCorpus()) return 1;
            // Alphabetically by name
            return corpus1.getLabel().toString().compareTo(corpus2.getLabel().toString());
        }
    }

    public void close() {
        mCorpora.unregisterDataSetObserver(mCorporaObserver);
    }

    public int getCount() {
        return 1 + (mSortedCorpora == null ? 0 : mSortedCorpora.size());
    }

    public Corpus getItem(int position) {
        if (position == 0) {
            return null;
        } else {
            return mSortedCorpora.get(position - 1);
        }
    }

    public long getItemId(int position) {
        return position;
    }

    /**
     * Gets the position of the given corpus.
     */
    public int getCorpusPosition(Corpus corpus) {
        if (corpus == null) {
            return 0;
        }
        int count = getCount();
        for (int i = 0; i < count; i++) {
            if (corpus.equals(getItem(i))) {
                return i;
            }
        }
        Log.w(TAG, ""Corpus not in adapter: "" + corpus);
        return 0;
    }

    public View getView(int position, View convertView, ViewGroup parent) {
        CorpusView view = (CorpusView) convertView;
        if (view == null) {
            view = createView(parent);
        }
        Corpus corpus = getItem(position);
        if (DBG) Log.d(TAG, ""Binding "" + position + "", corpus="" + corpus);
        bindView(view, corpus);
        return view;
    }

    protected void bindView(CorpusView view, Corpus corpus) {
        Drawable icon = getCorpusIcon(corpus);
        CharSequence label = getCorpusLabel(corpus);
        boolean isCurrent = isCurrentCorpus(corpus);
        if (DBG) Log.d(TAG, ""bind:name="" + corpus + "",label="" + label + "",current="" + isCurrent);
        view.setIcon(icon);
        view.setLabel(label);
        view.setChecked(isCurrent);
    }

    protected Drawable getCorpusIcon(Corpus corpus) {
        if (corpus == null) {
            return mContext.getResources().getDrawable(R.mipmap.search_app_icon);
        } else {
            return corpus.getCorpusIcon();
        }
    }

    protected CharSequence getCorpusLabel(Corpus corpus) {
        if (corpus == null) {
            return mContext.getText(R.string.corpus_label_global);
        } else {
            return corpus.getLabel();
        }
    }

    protected boolean isCurrentCorpus(Corpus corpus) {
        if (corpus == null) {
            return mCurrentCorpusName == null;
        } else {
            return corpus.getName().equals(mCurrentCorpusName);
        }
    }

    protected CorpusView createView(ViewGroup parent) {
        return (CorpusView) LayoutInflater.from(mContext).inflate(mCorpusViewRes, parent, false);
    }

    protected LayoutInflater getInflater() {
        return (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }

    private class CorporaObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            updateCorpora();
        }

        @Override
        public void onInvalidated() {
            updateCorpora();
        }
    }

}
",True,21,3,3,4,5,1,4,L9
115,com.android.quicksearchbox.ui.SuggestionView.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Suggestion;

/**
 * Interface to be implemented by any view appearing in the list of suggestions.
 */
public interface SuggestionView {
    /**
     * Set the view's contents based on the given suggestion.
     */
    void bindAsSuggestion(Suggestion suggestion, String userQuery);

    /**
     * Binds this view to a list adapter.
     *
     * @param adapter The adapter of the list which the view is appearing in
     * @param position The position of this view with the list.
     */
    void bindAdapter(SuggestionsAdapter<?> adapter, long position);

}
",False,65,7,15,4,12,3,2,L8
116,com.android.quicksearchbox.ui.DelayingSuggestionsAdapter.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.CorpusResult;
import com.android.quicksearchbox.Promoter;
import com.android.quicksearchbox.SuggestionCursor;
import com.android.quicksearchbox.SuggestionPosition;
import com.android.quicksearchbox.Suggestions;

import android.database.DataSetObserver;
import android.util.Log;
import android.view.View.OnFocusChangeListener;

/**
 * A {@link SuggestionsListAdapter} that doesn't expose the new suggestions
 * until there are some results to show.
 */
public class DelayingSuggestionsAdapter<A> implements SuggestionsAdapter<A> {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.DelayingSuggestionsAdapter"";

    private DataSetObserver mPendingDataSetObserver;

    private Suggestions mPendingSuggestions;

    private final SuggestionsAdapterBase<A> mDelayedAdapter;

    public DelayingSuggestionsAdapter(SuggestionsAdapterBase<A> delayed) {
        mDelayedAdapter = delayed;
    }

    public void close() {
        setPendingSuggestions(null);
        mDelayedAdapter.close();
    }

    @Override
    public void setSuggestions(Suggestions suggestions) {
        if (suggestions == null) {
            mDelayedAdapter.setSuggestions(null);
            setPendingSuggestions(null);
            return;
        }
        if (shouldPublish(suggestions)) {
            if (DBG) Log.d(TAG, ""Publishing suggestions immediately: "" + suggestions);
            mDelayedAdapter.setSuggestions(suggestions);
            // Clear any old pending suggestions.
            setPendingSuggestions(null);
        } else {
            if (DBG) Log.d(TAG, ""Delaying suggestions publishing: "" + suggestions);
            setPendingSuggestions(suggestions);
        }
    }

    /**
     * Gets whether the given suggestions are non-empty for the selected source.
     */
    private boolean shouldPublish(Suggestions suggestions) {
        if (suggestions.isDone()) return true;
        SuggestionCursor cursor = mDelayedAdapter.getPromoted(suggestions);
        if (cursor != null && cursor.getCount() > 0) {
            return true;
        } else if (mDelayedAdapter.willPublishNonPromotedSuggestions()) {
            Iterable<CorpusResult> results = suggestions.getCorpusResults();
            for (CorpusResult result : results) {
                if (result.getCount() > 0) {
                    return true;
                }
            }
        }
        return false;
    }

    private void setPendingSuggestions(Suggestions suggestions) {
        if (mPendingSuggestions == suggestions) {
            return;
        }
        if (mDelayedAdapter.isClosed()) {
            if (suggestions != null) {
                suggestions.release();
            }
            return;
        }
        if (mPendingDataSetObserver == null) {
            mPendingDataSetObserver = new PendingSuggestionsObserver();
        }
        if (mPendingSuggestions != null) {
            mPendingSuggestions.unregisterDataSetObserver(mPendingDataSetObserver);
            // Close old suggestions, but only if they are not also the current
            // suggestions.
            if (mPendingSuggestions != getSuggestions()) {
                mPendingSuggestions.release();
            }
        }
        mPendingSuggestions = suggestions;
        if (mPendingSuggestions != null) {
            mPendingSuggestions.registerDataSetObserver(mPendingDataSetObserver);
        }
    }

    protected void onPendingSuggestionsChanged() {
        if (DBG) {
            Log.d(TAG, ""onPendingSuggestionsChanged(), mPendingSuggestions=""
                    + mPendingSuggestions);
        }
        if (shouldPublish(mPendingSuggestions)) {
            if (DBG) Log.d(TAG, ""Suggestions now available, publishing: "" + mPendingSuggestions);
            mDelayedAdapter.setSuggestions(mPendingSuggestions);
            // The suggestions are no longer pending.
            setPendingSuggestions(null);
        }
    }

    private class PendingSuggestionsObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            onPendingSuggestionsChanged();
        }
    }

    public A getListAdapter() {
        return mDelayedAdapter.getListAdapter();
    }

    public SuggestionCursor getCurrentPromotedSuggestions() {
        return mDelayedAdapter.getCurrentPromotedSuggestions();
    }

    public Suggestions getSuggestions() {
        return mDelayedAdapter.getSuggestions();
    }

    public SuggestionPosition getSuggestion(long suggestionId) {
        return mDelayedAdapter.getSuggestion(suggestionId);
    }

    public void onSuggestionClicked(long suggestionId) {
        mDelayedAdapter.onSuggestionClicked(suggestionId);
    }

    public void onSuggestionQueryRefineClicked(long suggestionId) {
        mDelayedAdapter.onSuggestionQueryRefineClicked(suggestionId);
    }

    public void onSuggestionQuickContactClicked(long suggestionId) {
        mDelayedAdapter.onSuggestionQuickContactClicked(suggestionId);
    }

    public void onSuggestionRemoveFromHistoryClicked(long suggestionId) {
        mDelayedAdapter.onSuggestionRemoveFromHistoryClicked(suggestionId);
    }

    public void setMaxPromoted(int maxPromoted) {
        mDelayedAdapter.setMaxPromoted(maxPromoted);
    }

    public void setOnFocusChangeListener(OnFocusChangeListener l) {
        mDelayedAdapter.setOnFocusChangeListener(l);
    }

    @Override
    public void setPromoter(Promoter promoter) {
        mDelayedAdapter.setPromoter(promoter);
    }

    public void setSuggestionClickListener(SuggestionClickListener listener) {
        mDelayedAdapter.setSuggestionClickListener(listener);
    }

    @Override
    public boolean isEmpty() {
        return mDelayedAdapter.isEmpty();
    }

}
",False,35,3,2,4,11,2,8,L9
117,com.android.quicksearchbox.ui.SuggestionsListView.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.ui;

import android.view.View;
import android.widget.AbsListView;

/**
 * Interface for suggestions list UI views.
 */
public interface SuggestionsListView<A> {

    /**
     * See {@link View#setOnKeyListener}.
     */
    void setOnKeyListener(View.OnKeyListener l);

    /**
     * See {@link AbsListView#setOnScrollListener}.
     */
    void setOnScrollListener(AbsListView.OnScrollListener l);

    /**
     * See {@link View#setOnFocusChangeListener}.
     */
    void setOnFocusChangeListener(View.OnFocusChangeListener l);

    /**
     * See {@link View#setVisibility}.
     */
    void setVisibility(int visibility);

    /**
     * Sets the adapter for the list. See {@link AbsListView#setAdapter}
     */
    void setSuggestionsAdapter(SuggestionsAdapter<A> adapter);

    /**
     * Gets the adapter for the list.
     */
    SuggestionsAdapter<A> getSuggestionsAdapter();

    /**
     * Gets the ID of the currently selected item.
     */
    long getSelectedItemId();

    /**
     * Set whether or not to limit suggestions by view height. If {@code true}, only enough
     * suggestions to fill the view without scrolling will be shown.
     */
    void setLimitSuggestionsToViewHeight(boolean limit);

}
",False,34,3,4,5,10,4,1,L9
118,com.android.quicksearchbox.ui.SuggestionViewFactory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Suggestion;
import com.android.quicksearchbox.SuggestionCursor;

import android.view.View;
import android.view.ViewGroup;

import java.util.Collection;

/**
 * Factory interface for suggestion views.
 */
public interface SuggestionViewFactory {

    /**
     * Returns all the view types that are used by this factory. Each view type corresponds to a
     * specific layout that is used to display suggestions. The returned set must have at least one
     * item in it.
     *
     * View types must be unique across all suggestion view factories.
     */
    Collection<String> getSuggestionViewTypes();

    /**
     * Returns the view type to be used for displaying the given suggestion. This MUST correspond to
     * one of the view types returned by {@link #getSuggestionViewTypes()}.
     */
    String getViewType(Suggestion suggestion);

    /**
     * Gets a view corresponding to the current suggestion in the given cursor.
     *
     * @param convertView The old view to reuse, if possible. Note: You should check that this view
     *        is non-null and of an appropriate type before using. If it is not possible to convert
     *        this view to display the correct data, this method can create a new view.
     * @param parent The parent that this view will eventually be attached to
     * @return A View corresponding to the data within this suggestion.
     */
    View getView(SuggestionCursor suggestion, String userQuery, View convertView, ViewGroup parent);

    /**
     * Checks whether this factory can create views for the given suggestion.
     */
    boolean canCreateView(Suggestion suggestion);

}
",False,68,4,35,5,4,7,2,L2
119,com.android.quicksearchbox.ui.ClusteredSuggestionsView.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.ui;

import android.content.Context;
import android.util.AttributeSet;
import android.view.View;
import android.widget.ExpandableListAdapter;
import android.widget.ExpandableListView;

/**
 * Suggestions view that displays suggestions clustered by corpus type.
 */
public class ClusteredSuggestionsView extends ExpandableListView
        implements SuggestionsListView<ExpandableListAdapter> {

    SuggestionsAdapter<ExpandableListAdapter> mSuggestionsAdapter;

    public ClusteredSuggestionsView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public void setSuggestionsAdapter(SuggestionsAdapter<ExpandableListAdapter> adapter) {
        mSuggestionsAdapter = adapter;
        super.setAdapter(adapter == null ? null : adapter.getListAdapter());
    }

    public SuggestionsAdapter<ExpandableListAdapter> getSuggestionsAdapter() {
        return mSuggestionsAdapter;
    }

    public void setLimitSuggestionsToViewHeight(boolean limit) {
        // not supported
    }

    @Override
    public void onFinishInflate() {
        super.onFinishInflate();
        setItemsCanFocus(false);
        setOnGroupClickListener(new OnGroupClickListener(){
            public boolean onGroupClick(
                    ExpandableListView parent, View v, int groupPosition, long id) {
                // disable collapsing / expanding
                return true;
            }});
    }

    public void expandAll() {
        if (mSuggestionsAdapter != null) {
            ExpandableListAdapter adapter = mSuggestionsAdapter.getListAdapter();
            for (int i = 0; i < adapter.getGroupCount(); ++i) {
                expandGroup(i);
            }
        }
    }

}
",False,28,1,1,5,10,1,2,L10
120,com.android.quicksearchbox.ui.SearchActivityViewTwoPane.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Corpus;
import com.android.quicksearchbox.Promoter;
import com.android.quicksearchbox.R;
import com.android.quicksearchbox.Suggestions;

import android.animation.Animator;
import android.animation.ObjectAnimator;
import android.animation.ValueAnimator;
import android.animation.ValueAnimator.AnimatorUpdateListener;
import android.content.ComponentName;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Resources;
import android.database.DataSetObserver;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.AttributeSet;
import android.util.Log;
import android.view.Menu;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ExpandableListAdapter;
import android.widget.ImageView;
import android.widget.PopupMenu;

/**
 * Two-pane variant for the search activity view.
 */
public class SearchActivityViewTwoPane extends SearchActivityView {

    private static final int ENTRY_ANIMATION_START_DELAY = 150; // in millis
    private static final int ENTRY_ANIMATION_DURATION = 150; // in millis
    private static final float ANIMATION_STARTING_WIDTH_FACTOR = 0.5f;
    private static final String TOOLBAR_ICON_METADATA_NAME = ""com.android.launcher.toolbar_icon"";

    private ImageView mMenuButton;

    // View that shows the results other than the query completions
    private ClusteredSuggestionsView mResultsView;
    private SuggestionsAdapter<ExpandableListAdapter> mResultsAdapter;
    private View mResultsHeader;
    private View mSearchPlate;
    private boolean mJustCreated;

    public SearchActivityViewTwoPane(Context context) {
        super(context);
    }

    public SearchActivityViewTwoPane(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public SearchActivityViewTwoPane(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();

        mMenuButton = (ImageView) findViewById(R.id.menu_button);
        mMenuButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                showPopupMenu();
            }
        });

        mResultsView = (ClusteredSuggestionsView) findViewById(R.id.shortcuts);
        mResultsAdapter = createClusteredSuggestionsAdapter();
        mResultsAdapter.getListAdapter().registerDataSetObserver(new DataSetObserver(){
            @Override
            public void onChanged() {
                mResultsView.expandAll();
            }
        });
        mResultsView.setOnKeyListener(new SuggestionsViewKeyListener());
        mResultsView.setFocusable(true);
        mResultsHeader = findViewById(R.id.shortcut_title);
        mSearchPlate = findViewById(R.id.left_pane);
        mJustCreated = true;

        View dismissBg = findViewById(R.id.dismiss_bg);
        dismissBg.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                if (isQueryEmpty() && mExitClickListener != null) {
                    mExitClickListener.onClick(v);
                }
            }
        });
    }

    private void showPopupMenu() {
        PopupMenu popup = new PopupMenu(getContext(), mMenuButton);
        Menu menu = popup.getMenu();
        getActivity().createMenuItems(menu, false);
        popup.show();
    }

    protected SuggestionsAdapter<ExpandableListAdapter> createClusteredSuggestionsAdapter() {
        return new DelayingSuggestionsAdapter<ExpandableListAdapter>(
                new ClusteredSuggestionsAdapter(
                        getQsbApplication().getSuggestionViewFactory(),
                        getContext()));
    }

    @Override
    public void onResume() {
        if (mJustCreated) {
            setupEntryAnimations();
            mJustCreated = false;
        }
    }

    @Override
    public void onPause() {
        super.onPause();
        getActivity().overridePendingTransition(R.anim.fade_in_fast, R.anim.fade_out_fast);
    }

    private void setupEntryAnimations() {
        // TODO: Use the left/top of the source bounds to start the animation from
        final int endingWidth = getResources().getDimensionPixelSize(R.dimen.suggestions_width);
        final int startingWidth = (int) (endingWidth * ANIMATION_STARTING_WIDTH_FACTOR);

        ViewGroup.LayoutParams params = mSearchPlate.getLayoutParams();
        params.width = startingWidth;
        mSearchPlate.setLayoutParams(params);

        Animator animator = ObjectAnimator.ofInt(mSearchPlate, ""alpha"", 0, 255);
        animator.setDuration(ENTRY_ANIMATION_DURATION);
        ((ValueAnimator)animator).addUpdateListener(new AnimatorUpdateListener() {

            public void onAnimationUpdate(ValueAnimator animator) {
                ViewGroup.LayoutParams params = mSearchPlate.getLayoutParams();
                params.width = startingWidth
                        + (int) ((Integer) animator.getAnimatedValue() / 255f
                                * (endingWidth - startingWidth));
                mSearchPlate.setLayoutParams(params);
            }
        });
        animator.setStartDelay(ENTRY_ANIMATION_START_DELAY);
        animator.start();

    }

    @Override
    public void onStop() {
    }

    @Override
    public void start() {
        super.start();
        mResultsAdapter.getListAdapter().registerDataSetObserver(new ResultsObserver());
        mResultsView.setSuggestionsAdapter(mResultsAdapter);
    }

    @Override
    public void destroy() {
        mResultsView.setSuggestionsAdapter(null);

        super.destroy();
    }

    @Override
    protected Drawable getVoiceSearchIcon() {
        ComponentName voiceSearch = getVoiceSearch().getComponent();
        if (voiceSearch != null) {
            // this code copied from Launcher to get the same icon that's displayed on home screen
            try {
                PackageManager packageManager = getContext().getPackageManager();
                // Look for the toolbar icon specified in the activity meta-data
                Bundle metaData = packageManager.getActivityInfo(
                        voiceSearch, PackageManager.GET_META_DATA).metaData;
                if (metaData != null) {
                    int iconResId = metaData.getInt(TOOLBAR_ICON_METADATA_NAME);
                    if (iconResId != 0) {
                        Resources res = packageManager.getResourcesForActivity(voiceSearch);
                        if (DBG) Log.d(TAG, ""Got toolbar icon from Voice Search"");
                        return res.getDrawable(iconResId);
                    }
                }
            } catch (NameNotFoundException e) {
                // Do nothing
            }
        }
        if (DBG) Log.d(TAG, ""Failed to get toolbar icon from Voice Search; using default."");
        return super.getVoiceSearchIcon();
    }

    @Override
    public void considerHidingInputMethod() {
        // Don't hide keyboard when interacting with suggestions list
    }

    @Override
    public void hideSuggestions() {
        // Never hiding suggestions view in two-pane UI
    }

    @Override
    public void showSuggestions() {
        // Never hiding suggestions view in two-pane UI
    }

    @Override
    public void showCorpusSelectionDialog() {
        // not used
    }

    @Override
    public void clearSuggestions() {
        super.clearSuggestions();
        mResultsAdapter.setSuggestions(null);
    }

    @Override
    public void setMaxPromotedResults(int maxPromoted) {
        mResultsView.setLimitSuggestionsToViewHeight(false);
        mResultsAdapter.setMaxPromoted(maxPromoted);
    }

    @Override
    public void limitResultsToViewHeight() {
        mResultsView.setLimitSuggestionsToViewHeight(true);
    }

    @Override
    public void setSuggestionClickListener(SuggestionClickListener listener) {
        super.setSuggestionClickListener(listener);
        mResultsAdapter.setSuggestionClickListener(listener);
    }

    @Override
    public void setSuggestions(Suggestions suggestions) {
        super.setSuggestions(suggestions);
        suggestions.acquire();
        mResultsAdapter.setSuggestions(suggestions);
    }

    @Override
    protected void setCorpus(Corpus corpus) {
        super.setCorpus(corpus);
        mResultsAdapter.setPromoter(createResultsPromoter());
    }

    @Override
    protected Promoter createSuggestionsPromoter() {
        return getQsbApplication().createWebPromoter();
    }

    protected Promoter createResultsPromoter() {
        Corpus corpus = getCorpus();
        if (corpus == null) {
            return getQsbApplication().createResultsPromoter();
        } else {
            return getQsbApplication().createSingleCorpusResultsPromoter(corpus);
        }
    }

    protected void onResultsChanged() {
        checkHideResultsHeader();
    }

    @Override
    protected void updateQueryTextView(boolean queryEmpty) {
        super.updateQueryTextView(queryEmpty);
        if (mSearchCloseButton == null) return;

        if (queryEmpty) {
            mSearchCloseButton.setImageResource(R.drawable.ic_clear_disabled);
        } else {
            mSearchCloseButton.setImageResource(R.drawable.ic_clear);
        }
    }

    private void checkHideResultsHeader() {
        if (mResultsHeader != null) {
            if (!mResultsAdapter.isEmpty()) {
                if (DBG) Log.d(TAG, ""Results non-empty"");
                mResultsHeader.setVisibility(VISIBLE);
            } else {
                if (DBG) Log.d(TAG, ""Results empty"");
                mResultsHeader.setVisibility(INVISIBLE);
            }
        }
    }

    @Override
    public Corpus getSearchCorpus() {
        return getWebCorpus();
    }

    protected class ResultsObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            onResultsChanged();
        }
    }

}
",True,132,0,0,6,64,0,13,L10
121,com.android.quicksearchbox.ui.SearchActivityViewSinglePane.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Corpus;
import com.android.quicksearchbox.CorpusSelectionDialog;
import com.android.quicksearchbox.Promoter;
import com.android.quicksearchbox.R;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.util.AttributeSet;
import android.view.View;
import android.widget.ImageButton;

/**
 * Finishes the containing activity on BACK, even if input method is showing.
 */
public class SearchActivityViewSinglePane extends SearchActivityView {

    private CorpusSelectionDialog mCorpusSelectionDialog;

    private ImageButton mCorpusIndicator;

    public SearchActivityViewSinglePane(Context context) {
        super(context);
    }

    public SearchActivityViewSinglePane(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public SearchActivityViewSinglePane(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mCorpusIndicator = (ImageButton) findViewById(R.id.corpus_indicator);
        mCorpusIndicator.setOnKeyListener(mButtonsKeyListener);
        mCorpusIndicator.setOnClickListener(new View.OnClickListener(){
            public void onClick(View v) {
                showCorpusSelectionDialog();
            }});
    }

    @Override
    public void onResume() {
        if (!isCorpusSelectionDialogShowing()) {
            focusQueryTextView();
        }
    }

    @Override
    public void onStop() {
        dismissCorpusSelectionDialog();
    }

    @Override
    protected void setCorpus(Corpus corpus) {
        super.setCorpus(corpus);

        if (mCorpusIndicator != null) {
            Drawable sourceIcon;
            if (corpus == null) {
                sourceIcon = getContext().getResources().getDrawable(R.mipmap.search_app_icon);
            } else {
                sourceIcon = corpus.getCorpusIcon();
            }
            mCorpusIndicator.setImageDrawable(sourceIcon);
        }
    }

    @Override
    protected Promoter createSuggestionsPromoter() {
        Corpus corpus = getCorpus();
        if (corpus == null) {
            return getQsbApplication().createBlendingPromoter();
        } else {
            return getQsbApplication().createSingleCorpusPromoter(corpus);
        }
    }

    /**
     * Gets the corpus to use for any searches. This is the web corpus in ""All"" mode,
     * and the selected corpus otherwise.
     */
    @Override
    public Corpus getSearchCorpus() {
        Corpus corpus = getCorpus();
        return corpus == null ? getWebCorpus() : corpus;
    }

    @Override
    public void showCorpusSelectionDialog() {
        if (mCorpusSelectionDialog == null) {
            mCorpusSelectionDialog = getActivity().getCorpusSelectionDialog();
            mCorpusSelectionDialog.setOnCorpusSelectedListener(new CorpusSelectionListener());
        }
        mCorpusSelectionDialog.show(getCorpus());
    }

    protected boolean isCorpusSelectionDialogShowing() {
        return mCorpusSelectionDialog != null && mCorpusSelectionDialog.isShowing();
    }

    protected void dismissCorpusSelectionDialog() {
        if (mCorpusSelectionDialog != null) {
            mCorpusSelectionDialog.dismiss();
        }
    }

    @Override
    public void considerHidingInputMethod() {
        mQueryTextView.hideInputMethod();
    }

    private class CorpusSelectionListener
            implements CorpusSelectionDialog.OnCorpusSelectedListener {
        public void onCorpusSelected(String corpusName) {
            SearchActivityViewSinglePane.this.onCorpusSelected(corpusName);
        }
    }

}
",False,130,0,0,6,66,0,7,L10
122,com.android.quicksearchbox.ui.ContactSuggestionView.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.R;
import com.android.quicksearchbox.SearchableSource;
import com.android.quicksearchbox.Source;
import com.android.quicksearchbox.Suggestion;

import android.app.SearchableInfo;
import android.content.Context;
import android.net.Uri;
import android.provider.ContactsContract;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.view.View;

/**
 * View for contacts appearing in the suggestions list.
 */
public class ContactSuggestionView extends DefaultSuggestionView {

    private static final String VIEW_ID = ""contact"";

    private ContactBadge mQuickContact;

    public ContactSuggestionView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    public ContactSuggestionView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public ContactSuggestionView(Context context) {
        super(context);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mQuickContact = (ContactBadge) findViewById(R.id.icon1);
    }

    @Override
    public void bindAsSuggestion(Suggestion suggestion, String userQuery) {
        super.bindAsSuggestion(suggestion, userQuery);
        mQuickContact.assignContactUri(Uri.parse(suggestion.getSuggestionIntentDataString()));
        mQuickContact.setExtraOnClickListener(new ContactBadgeClickListener());
    }

    private class ContactBadgeClickListener implements View.OnClickListener {
        public void onClick(View v) {
            onSuggestionQuickContactClicked();
        }
    }

    public static class Factory extends SuggestionViewInflater {
        public Factory(Context context) {
            super(VIEW_ID, ContactSuggestionView.class, R.layout.contact_suggestion, context);
        }

        @Override
        public boolean canCreateView(Suggestion suggestion) {
            Source source = suggestion.getSuggestionSource();
            if (source instanceof SearchableSource) {
                SearchableSource searchableSource = (SearchableSource) source;
                return isSearchableContacts(searchableSource.getSearchableInfo());
            }
            return false;
        }

        protected boolean isSearchableContacts(SearchableInfo searchable) {
            return TextUtils.equals(ContactsContract.AUTHORITY, searchable.getSuggestAuthority());
        }
    }
}",False,118,0,0,7,52,1,7,L8
123,com.android.quicksearchbox.ui.SuggestionsView.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.R;
import com.android.quicksearchbox.SuggestionPosition;

import android.content.Context;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;
import android.widget.FrameLayout;
import android.widget.ListAdapter;
import android.widget.ListView;

/**
 * Holds a list of suggestions.
 */
public class SuggestionsView extends ListView implements SuggestionsListView<ListAdapter> {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SuggestionsView"";

    private boolean mLimitSuggestionsToViewHeight;
    private SuggestionsAdapter<ListAdapter> mSuggestionsAdapter;

    public SuggestionsView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public void setSuggestionsAdapter(SuggestionsAdapter<ListAdapter> adapter) {
        super.setAdapter(adapter == null ? null : adapter.getListAdapter());
        mSuggestionsAdapter = adapter;
        if (mLimitSuggestionsToViewHeight) {
            setMaxPromotedByHeight();
        }
    }

    public SuggestionsAdapter<ListAdapter> getSuggestionsAdapter() {
        return mSuggestionsAdapter;
    }

    @Override
    public void onFinishInflate() {
        super.onFinishInflate();
        setItemsCanFocus(true);
    }

    /**
     * Gets the position of the selected suggestion.
     *
     * @return A 0-based index, or {@code -1} if no suggestion is selected.
     */
    public int getSelectedPosition() {
        return getSelectedItemPosition();
    }

    /**
     * Gets the selected suggestion.
     *
     * @return {@code null} if no suggestion is selected.
     */
    public SuggestionPosition getSelectedSuggestion() {
        return (SuggestionPosition) getSelectedItem();
    }

    public void setLimitSuggestionsToViewHeight(boolean limit) {
        mLimitSuggestionsToViewHeight = limit;
        if (mLimitSuggestionsToViewHeight) {
            setMaxPromotedByHeight();
        }
    }

    @Override
    protected void onSizeChanged (int w, int h, int oldw, int oldh) {
        if (mLimitSuggestionsToViewHeight) {
            setMaxPromotedByHeight();
        }
    }

    private void setMaxPromotedByHeight() {
        if (mSuggestionsAdapter != null) {
            float maxHeight;
            if (getParent() instanceof FrameLayout) {
                // We put the SuggestionView inside a frame layout so that we know what its
                // maximum height is. Since this views height is set to 'wrap content' (in two-pane
                // mode at least), we can't use our own height for these calculations.
                maxHeight = ((View) getParent()).getHeight();
                if (DBG) Log.d(TAG, ""Parent height="" + maxHeight);
            } else {
                maxHeight = getHeight();
                if (DBG) Log.d(TAG, ""This height="" + maxHeight);
            }
            float suggestionHeight =
                getContext().getResources().getDimension(R.dimen.suggestion_view_height);
            if (suggestionHeight != 0) {
                int suggestions = Math.max(1, (int) Math.floor(maxHeight / suggestionHeight));
                if (DBG) {
                    Log.d(TAG, ""view height="" + maxHeight + "" suggestion height="" +
                            suggestionHeight + "" -> maxSuggestions="" + suggestions);
                }
                mSuggestionsAdapter.setMaxPromoted(suggestions);
            }
        }
    }

}
",False,33,3,3,5,10,1,3,L9
124,com.android.quicksearchbox.ui.SuggestionsAdapterBase.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Promoter;
import com.android.quicksearchbox.Suggestion;
import com.android.quicksearchbox.SuggestionCursor;
import com.android.quicksearchbox.SuggestionPosition;
import com.android.quicksearchbox.Suggestions;

import android.database.DataSetObserver;
import android.util.Log;
import android.view.View;
import android.view.View.OnFocusChangeListener;
import android.view.ViewGroup;

import java.util.HashMap;

/**
 * Base class for suggestions adapters. The templated class A is the list adapter class.
 */
public abstract class SuggestionsAdapterBase<A> implements SuggestionsAdapter<A> {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SuggestionsAdapter"";

    private DataSetObserver mDataSetObserver;

    private Promoter mPromoter;

    private int mMaxPromoted;

    private SuggestionCursor mPromotedSuggestions;
    private final HashMap<String, Integer> mViewTypeMap;
    private final SuggestionViewFactory mViewFactory;

    private Suggestions mSuggestions;

    private SuggestionClickListener mSuggestionClickListener;
    private OnFocusChangeListener mOnFocusChangeListener;

    private boolean mClosed = false;

    protected SuggestionsAdapterBase(SuggestionViewFactory viewFactory) {
        mViewFactory = viewFactory;
        mViewTypeMap = new HashMap<String, Integer>();
        for (String viewType : mViewFactory.getSuggestionViewTypes()) {
            if (!mViewTypeMap.containsKey(viewType)) {
                mViewTypeMap.put(viewType, mViewTypeMap.size());
            }
        }
    }

    public abstract boolean isEmpty();

    /**
     * Indicates if this adapter will publish suggestions other than those in the promoted list.
     */
    public abstract boolean willPublishNonPromotedSuggestions();

    public void setMaxPromoted(int maxPromoted) {
        if (DBG) Log.d(TAG, ""setMaxPromoted "" + maxPromoted);
        mMaxPromoted = maxPromoted;
        onSuggestionsChanged();
    }

    public boolean isClosed() {
        return mClosed;
    }

    public void close() {
        setSuggestions(null);
        mClosed = true;
    }

    public void setPromoter(Promoter promoter) {
        mPromoter = promoter;
        onSuggestionsChanged();
    }

    public void setSuggestionClickListener(SuggestionClickListener listener) {
        mSuggestionClickListener = listener;
    }

    public void setOnFocusChangeListener(OnFocusChangeListener l) {
        mOnFocusChangeListener = l;
    }

    public void setSuggestions(Suggestions suggestions) {
        if (mSuggestions == suggestions) {
            return;
        }
        if (mClosed) {
            if (suggestions != null) {
                suggestions.release();
            }
            return;
        }
        if (mDataSetObserver == null) {
            mDataSetObserver = new MySuggestionsObserver();
        }
        // TODO: delay the change if there are no suggestions for the currently visible tab.
        if (mSuggestions != null) {
            mSuggestions.unregisterDataSetObserver(mDataSetObserver);
            mSuggestions.release();
        }
        mSuggestions = suggestions;
        if (mSuggestions != null) {
            mSuggestions.registerDataSetObserver(mDataSetObserver);
        }
        onSuggestionsChanged();
    }

    public Suggestions getSuggestions() {
        return mSuggestions;
    }

    public abstract SuggestionPosition getSuggestion(long suggestionId);

    protected int getPromotedCount() {
        return mPromotedSuggestions == null ? 0 : mPromotedSuggestions.getCount();
    }

    protected SuggestionPosition getPromotedSuggestion(int position) {
        if (mPromotedSuggestions == null) return null;
        return new SuggestionPosition(mPromotedSuggestions, position);
    }

    protected int getViewTypeCount() {
        return mViewTypeMap.size();
    }

    private String suggestionViewType(Suggestion suggestion) {
        String viewType = mViewFactory.getViewType(suggestion);
        if (!mViewTypeMap.containsKey(viewType)) {
            throw new IllegalStateException(""Unknown viewType "" + viewType);
        }
        return viewType;
    }

    protected int getSuggestionViewType(SuggestionCursor cursor, int position) {
        if (cursor == null) {
            return 0;
        }
        cursor.moveTo(position);
        return mViewTypeMap.get(suggestionViewType(cursor));
    }

    protected int getSuggestionViewTypeCount() {
        return mViewTypeMap.size();
    }

    protected View getView(SuggestionCursor suggestions, int position, long suggestionId,
            View convertView, ViewGroup parent) {
        suggestions.moveTo(position);
        View v = mViewFactory.getView(suggestions, suggestions.getUserQuery(), convertView, parent);
        if (v instanceof SuggestionView) {
            ((SuggestionView) v).bindAdapter(this, suggestionId);
        } else {
            SuggestionViewClickListener l = new SuggestionViewClickListener(suggestionId);
            v.setOnClickListener(l);
        }

        if (mOnFocusChangeListener != null) {
            v.setOnFocusChangeListener(mOnFocusChangeListener);
        }
        return v;
    }

    protected void onSuggestionsChanged() {
        if (DBG) Log.d(TAG, ""onSuggestionsChanged("" + mSuggestions + "")"");
        SuggestionCursor cursor = getPromoted(mSuggestions);
        changePromoted(cursor);
    }

    /**
     * Gets the cursor containing the currently shown suggestions. The caller should not hold
     * on to or modify the returned cursor.
     */
    public SuggestionCursor getCurrentPromotedSuggestions() {
        return mPromotedSuggestions;
    }

    /**
     * Gets the cursor for the given source.
     */
    protected SuggestionCursor getPromoted(Suggestions suggestions) {
        if (suggestions == null) return null;
        return suggestions.getPromoted(mPromoter, mMaxPromoted);
    }

    /**
     * Replace the cursor.
     *
     * This does not close the old cursor. Instead, all the cursors are closed in
     * {@link #setSuggestions(Suggestions)}.
     */
    private void changePromoted(SuggestionCursor newCursor) {
        if (DBG) {
            Log.d(TAG, ""changeCursor("" + newCursor + "") count="" +
                    (newCursor == null ? 0 : newCursor.getCount()));
        }
        if (newCursor == mPromotedSuggestions) {
            if (newCursor != null) {
                // Shortcuts may have changed without the cursor changing.
                notifyDataSetChanged();
            }
            return;
        }
        mPromotedSuggestions = newCursor;
        if (mPromotedSuggestions != null) {
            notifyDataSetChanged();
        } else {
            notifyDataSetInvalidated();
        }
    }

    public void onSuggestionClicked(long suggestionId) {
        if (mClosed) {
            Log.w(TAG, ""onSuggestionClicked after close"");
        } else if (mSuggestionClickListener != null) {
            mSuggestionClickListener.onSuggestionClicked(this, suggestionId);
        }
    }

    public void onSuggestionQuickContactClicked(long suggestionId) {
        if (mClosed) {
            Log.w(TAG, ""onSuggestionQuickContactClicked after close"");
        } else if (mSuggestionClickListener != null) {
            mSuggestionClickListener.onSuggestionQuickContactClicked(this, suggestionId);
        }
    }

    public void onSuggestionRemoveFromHistoryClicked(long suggestionId) {
        if (mClosed) {
            Log.w(TAG, ""onSuggestionRemoveFromHistoryClicked after close"");
        } else if (mSuggestionClickListener != null) {
            mSuggestionClickListener.onSuggestionRemoveFromHistoryClicked(this, suggestionId);
        }
    }

    public void onSuggestionQueryRefineClicked(long suggestionId) {
        if (mClosed) {
            Log.w(TAG, ""onSuggestionQueryRefineClicked after close"");
        } else if (mSuggestionClickListener != null) {
            mSuggestionClickListener.onSuggestionQueryRefineClicked(this, suggestionId);
        }
    }

    public abstract A getListAdapter();

    protected abstract void notifyDataSetInvalidated();

    protected abstract void notifyDataSetChanged();

    private class MySuggestionsObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            onSuggestionsChanged();
        }
    }

    private class SuggestionViewClickListener implements View.OnClickListener {
        private final long mSuggestionId;
        public SuggestionViewClickListener(long suggestionId) {
            mSuggestionId = suggestionId;
        }
        public void onClick(View v) {
            onSuggestionClicked(mSuggestionId);
        }
    }

}
",False,37,4,3,4,11,3,9,L9
125,com.android.quicksearchbox.ui.SuggestionClickListener.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

/**
 * Listener interface for clicks on suggestions.
 */
public interface SuggestionClickListener {

    /**
     * Called when a suggestion is clicked.
     *
     * @param adapter Adapter that contains the clicked suggestion.
     * @param suggestionId The ID of the suggestion clicked. If the suggestion list is flat, this
     *      will be the position within the list.
     */
    void onSuggestionClicked(SuggestionsAdapter<?> adapter, long suggestionId);

    /**
     * Called when a quick contact badge in a suggestion is clicked.
     *
     * @param adapter Adapter that contains the clicked suggestion.
     * @param suggestionId The ID of the suggestion clicked. If the suggestion list is flat, this
     *      will be the position within the list.
     */
    void onSuggestionQuickContactClicked(SuggestionsAdapter<?> adapter, long suggestionId);

    /**
     * Called when the user requests to remove a suggestion from the search history.
     *
     * @param adapter Adapter that contains the clicked suggestion.
     * @param suggestionId The ID of the suggestion clicked. If the suggestion list is flat, this
     *      will be the position within the list.
     */
    void onSuggestionRemoveFromHistoryClicked(SuggestionsAdapter<?> adapter, long suggestionId);

    /**
     * Called when the ""query refine"" button of a suggestion is clicked.
     *
     * @param adapter Adapter that contains the clicked suggestion.
     * @param suggestionId The ID of the suggestion clicked. If the suggestion list is flat, this
     *      will be the position within the list.
     */
    void onSuggestionQueryRefineClicked(SuggestionsAdapter<?> adapter, long suggestionId);
}
",False,35,2,5,5,10,6,1,L8
126,com.android.quicksearchbox.ui.WebSearchSuggestionView.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.QsbApplication;
import com.android.quicksearchbox.R;
import com.android.quicksearchbox.Suggestion;
import com.android.quicksearchbox.SuggestionFormatter;

import android.content.Context;
import android.util.AttributeSet;
import android.view.KeyEvent;
import android.view.View;

/**
 * View for web search suggestions.
 */
public class WebSearchSuggestionView extends BaseSuggestionView {

    private static final String VIEW_ID = ""web_search"";

    private final SuggestionFormatter mSuggestionFormatter;

    public WebSearchSuggestionView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mSuggestionFormatter = QsbApplication.get(context).getSuggestionFormatter();
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        KeyListener keyListener = new KeyListener();
        setOnKeyListener(keyListener);
        mIcon2.setOnKeyListener(keyListener);
        mIcon2.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                onSuggestionQueryRefineClicked();
            }
        });
        mIcon2.setFocusable(true);
    }

    @Override
    public void bindAsSuggestion(Suggestion suggestion, String userQuery) {
        super.bindAsSuggestion(suggestion, userQuery);

        CharSequence text1 = mSuggestionFormatter.formatSuggestion(userQuery,
                suggestion.getSuggestionText1());
        setText1(text1);
        setIsHistorySuggestion(suggestion.isHistorySuggestion());
    }

    private void setIsHistorySuggestion(boolean isHistory) {
        if (isHistory) {
            mIcon1.setImageResource(R.drawable.ic_history_suggestion);
            mIcon1.setVisibility(VISIBLE);
        } else {
            mIcon1.setVisibility(INVISIBLE);
        }
    }

    private class KeyListener implements View.OnKeyListener {
        public boolean onKey(View v, int keyCode, KeyEvent event) {
            boolean consumed = false;
            if (event.getAction() == KeyEvent.ACTION_DOWN) {
                if (keyCode == KeyEvent.KEYCODE_DPAD_RIGHT && v != mIcon2) {
                    consumed = mIcon2.requestFocus();
                } else if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT && v == mIcon2) {
                    consumed = requestFocus();
                }
            }
            return consumed;
        }
    }

    public static class Factory extends SuggestionViewInflater {

        public Factory(Context context) {
            super(VIEW_ID, WebSearchSuggestionView.class, R.layout.web_search_suggestion, context);
        }

        @Override
        public boolean canCreateView(Suggestion suggestion) {
            return suggestion.isWebSearchSuggestion();
        }
    }

}
",False,118,0,0,6,51,1,5,L8
127,com.android.quicksearchbox.ui.SuggestionViewInflater.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Suggestion;
import com.android.quicksearchbox.SuggestionCursor;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import java.util.Collection;
import java.util.Collections;

/**
 * Suggestion view factory that inflates views from XML.
 */
public class SuggestionViewInflater implements SuggestionViewFactory {

    private final String mViewType;
    private final Class<?> mViewClass;
    private final int mLayoutId;
    private final Context mContext;

    /**
     * @param viewType The unique type of views inflated by this factory
     * @param viewClass The expected type of view classes.
     * @param layoutId resource ID of layout to use.
     * @param context Context to use for inflating the views.
     */
    public SuggestionViewInflater(String viewType, Class<? extends SuggestionView> viewClass,
            int layoutId, Context context) {
        mViewType = viewType;
        mViewClass = viewClass;
        mLayoutId = layoutId;
        mContext = context;
    }

    protected LayoutInflater getInflater() {
        return (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }

    public Collection<String> getSuggestionViewTypes() {
        return Collections.singletonList(mViewType);
    }

    public View getView(SuggestionCursor suggestion, String userQuery,
            View convertView, ViewGroup parent) {
        if (convertView == null || !convertView.getClass().equals(mViewClass)) {
            int layoutId = mLayoutId;
            convertView = getInflater().inflate(layoutId, parent, false);
        }
        if (!(convertView instanceof SuggestionView)) {
            throw new IllegalArgumentException(""Not a SuggestionView: "" + convertView);
        }
        ((SuggestionView) convertView).bindAsSuggestion(suggestion, userQuery);
        return convertView;
    }

    public String getViewType(Suggestion suggestion) {
        return mViewType;
    }

    public boolean canCreateView(Suggestion suggestion) {
        return true;
    }

}
",True,61,6,18,5,8,3,4,L8
128,com.android.quicksearchbox.ui.SearchActivityView.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Corpora;
import com.android.quicksearchbox.Corpus;
import com.android.quicksearchbox.CorpusResult;
import com.android.quicksearchbox.Logger;
import com.android.quicksearchbox.Promoter;
import com.android.quicksearchbox.QsbApplication;
import com.android.quicksearchbox.R;
import com.android.quicksearchbox.SearchActivity;
import com.android.quicksearchbox.SuggestionCursor;
import com.android.quicksearchbox.Suggestions;
import com.android.quicksearchbox.VoiceSearch;

import android.content.Context;
import android.database.DataSetObserver;
import android.graphics.drawable.Drawable;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.AttributeSet;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.view.inputmethod.CompletionInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.AbsListView;
import android.widget.ImageButton;
import android.widget.ListAdapter;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.TextView.OnEditorActionListener;

import java.util.ArrayList;
import java.util.Arrays;

public abstract class SearchActivityView extends RelativeLayout {
    protected static final boolean DBG = false;
    protected static final String TAG = ""QSB.SearchActivityView"";

    // The string used for privateImeOptions to identify to the IME that it should not show
    // a microphone button since one already exists in the search dialog.
    // TODO: This should move to android-common or something.
    private static final String IME_OPTION_NO_MICROPHONE = ""nm"";

    private Corpus mCorpus;

    protected QueryTextView mQueryTextView;
    // True if the query was empty on the previous call to updateQuery()
    protected boolean mQueryWasEmpty = true;
    protected Drawable mQueryTextEmptyBg;
    protected Drawable mQueryTextNotEmptyBg;

    protected SuggestionsListView<ListAdapter> mSuggestionsView;
    protected SuggestionsAdapter<ListAdapter> mSuggestionsAdapter;

    protected ImageButton mSearchCloseButton;
    protected ImageButton mSearchGoButton;
    protected ImageButton mVoiceSearchButton;

    protected ButtonsKeyListener mButtonsKeyListener;

    private boolean mUpdateSuggestions;

    private QueryListener mQueryListener;
    private SearchClickListener mSearchClickListener;
    protected View.OnClickListener mExitClickListener;

    public SearchActivityView(Context context) {
        super(context);
    }

    public SearchActivityView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public SearchActivityView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    @Override
    protected void onFinishInflate() {
        mQueryTextView = (QueryTextView) findViewById(R.id.search_src_text);

        mSuggestionsView = (SuggestionsView) findViewById(R.id.suggestions);
        mSuggestionsView.setOnScrollListener(new InputMethodCloser());
        mSuggestionsView.setOnKeyListener(new SuggestionsViewKeyListener());
        mSuggestionsView.setOnFocusChangeListener(new SuggestListFocusListener());

        mSuggestionsAdapter = createSuggestionsAdapter();
        // TODO: why do we need focus listeners both on the SuggestionsView and the individual
        // suggestions?
        mSuggestionsAdapter.setOnFocusChangeListener(new SuggestListFocusListener());

        mSearchCloseButton = (ImageButton) findViewById(R.id.search_close_btn);
        mSearchGoButton = (ImageButton) findViewById(R.id.search_go_btn);
        mVoiceSearchButton = (ImageButton) findViewById(R.id.search_voice_btn);
        mVoiceSearchButton.setImageDrawable(getVoiceSearchIcon());

        mQueryTextView.addTextChangedListener(new SearchTextWatcher());
        mQueryTextView.setOnEditorActionListener(new QueryTextEditorActionListener());
        mQueryTextView.setOnFocusChangeListener(new QueryTextViewFocusListener());
        mQueryTextEmptyBg = mQueryTextView.getBackground();

        mSearchGoButton.setOnClickListener(new SearchGoButtonClickListener());

        mButtonsKeyListener = new ButtonsKeyListener();
        mSearchGoButton.setOnKeyListener(mButtonsKeyListener);
        mVoiceSearchButton.setOnKeyListener(mButtonsKeyListener);
        if (mSearchCloseButton != null) {
            mSearchCloseButton.setOnKeyListener(mButtonsKeyListener);
            mSearchCloseButton.setOnClickListener(new CloseClickListener());
        }

        mUpdateSuggestions = true;
    }

    public abstract void onResume();

    public abstract void onStop();

    public void onPause() {
        // Override if necessary
    }

    public void start() {
        mSuggestionsAdapter.getListAdapter().registerDataSetObserver(new SuggestionsObserver());
        mSuggestionsView.setSuggestionsAdapter(mSuggestionsAdapter);
    }

    public void destroy() {
        mSuggestionsView.setSuggestionsAdapter(null);  // closes mSuggestionsAdapter
    }

    // TODO: Get rid of this. To make it more easily testable,
    // the SearchActivityView should not depend on QsbApplication.
    protected QsbApplication getQsbApplication() {
        return QsbApplication.get(getContext());
    }

    protected Drawable getVoiceSearchIcon() {
        return getResources().getDrawable(R.drawable.ic_btn_speak_now);
    }

    protected VoiceSearch getVoiceSearch() {
        return getQsbApplication().getVoiceSearch();
    }

    protected SuggestionsAdapter<ListAdapter> createSuggestionsAdapter() {
        return new DelayingSuggestionsAdapter<ListAdapter>(new SuggestionsListAdapter(
                getQsbApplication().getSuggestionViewFactory()));
    }

    protected Corpora getCorpora() {
        return getQsbApplication().getCorpora();
    }

    public Corpus getCorpus() {
        return mCorpus;
    }

    protected abstract Promoter createSuggestionsPromoter();

    protected Corpus getCorpus(String sourceName) {
        if (sourceName == null) return null;
        Corpus corpus = getCorpora().getCorpus(sourceName);
        if (corpus == null) {
            Log.w(TAG, ""Unknown corpus "" + sourceName);
            return null;
        }
        return corpus;
    }

    public void onCorpusSelected(String corpusName) {
        setCorpus(corpusName);
        focusQueryTextView();
        showInputMethodForQuery();
    }

    public void setCorpus(String corpusName) {
        if (DBG) Log.d(TAG, ""setCorpus("" + corpusName + "")"");
        Corpus corpus = getCorpus(corpusName);
        setCorpus(corpus);
        updateUi();
    }

    protected void setCorpus(Corpus corpus) {
        mCorpus = corpus;
        mSuggestionsAdapter.setPromoter(createSuggestionsPromoter());
        Suggestions suggestions = getSuggestions();
        if (corpus == null || suggestions == null || !suggestions.expectsCorpus(corpus)) {
            getActivity().updateSuggestions();
        }
    }

    public String getCorpusName() {
        Corpus corpus = getCorpus();
        return corpus == null ? null : corpus.getName();
    }

    public abstract Corpus getSearchCorpus();

    public Corpus getWebCorpus() {
        Corpus webCorpus = getCorpora().getWebCorpus();
        if (webCorpus == null) {
            Log.e(TAG, ""No web corpus"");
        }
        return webCorpus;
    }

    public void setMaxPromotedSuggestions(int maxPromoted) {
        mSuggestionsView.setLimitSuggestionsToViewHeight(false);
        mSuggestionsAdapter.setMaxPromoted(maxPromoted);
    }

    public void limitSuggestionsToViewHeight() {
        mSuggestionsView.setLimitSuggestionsToViewHeight(true);
    }

    public void setMaxPromotedResults(int maxPromoted) {
    }

    public void limitResultsToViewHeight() {
    }

    public void setQueryListener(QueryListener listener) {
        mQueryListener = listener;
    }

    public void setSearchClickListener(SearchClickListener listener) {
        mSearchClickListener = listener;
    }

    public abstract void showCorpusSelectionDialog();

    public void setVoiceSearchButtonClickListener(View.OnClickListener listener) {
        if (mVoiceSearchButton != null) {
            mVoiceSearchButton.setOnClickListener(listener);
        }
    }

    public void setSuggestionClickListener(final SuggestionClickListener listener) {
        mSuggestionsAdapter.setSuggestionClickListener(listener);
        mQueryTextView.setCommitCompletionListener(new QueryTextView.CommitCompletionListener() {
            @Override
            public void onCommitCompletion(int position) {
                mSuggestionsAdapter.onSuggestionClicked(position);
            }
        });
    }

    public void setExitClickListener(final View.OnClickListener listener) {
        mExitClickListener = listener;
    }

    public Suggestions getSuggestions() {
        return mSuggestionsAdapter.getSuggestions();
    }

    public SuggestionCursor getCurrentPromotedSuggestions() {
        return mSuggestionsAdapter.getCurrentPromotedSuggestions();
    }

    public void setSuggestions(Suggestions suggestions) {
        suggestions.acquire();
        mSuggestionsAdapter.setSuggestions(suggestions);
    }

    public void clearSuggestions() {
        mSuggestionsAdapter.setSuggestions(null);
    }

    public String getQuery() {
        CharSequence q = mQueryTextView.getText();
        return q == null ? """" : q.toString();
    }

    public boolean isQueryEmpty() {
        return TextUtils.isEmpty(getQuery());
    }

    /**
     * Sets the text in the query box. Does not update the suggestions.
     */
    public void setQuery(String query, boolean selectAll) {
        mUpdateSuggestions = false;
        mQueryTextView.setText(query);
        mQueryTextView.setTextSelection(selectAll);
        mUpdateSuggestions = true;
    }

    protected SearchActivity getActivity() {
        Context context = getContext();
        if (context instanceof SearchActivity) {
            return (SearchActivity) context;
        } else {
            return null;
        }
    }

    public void hideSuggestions() {
        mSuggestionsView.setVisibility(GONE);
    }

    public void showSuggestions() {
        mSuggestionsView.setVisibility(VISIBLE);
    }

    public void focusQueryTextView() {
        mQueryTextView.requestFocus();
    }

    protected void updateUi() {
        updateUi(isQueryEmpty());
    }

    protected void updateUi(boolean queryEmpty) {
        updateQueryTextView(queryEmpty);
        updateSearchGoButton(queryEmpty);
        updateVoiceSearchButton(queryEmpty);
    }

    protected void updateQueryTextView(boolean queryEmpty) {
        if (queryEmpty) {
            if (isSearchCorpusWeb()) {
                mQueryTextView.setBackgroundDrawable(mQueryTextEmptyBg);
                mQueryTextView.setHint(null);
            } else {
                if (mQueryTextNotEmptyBg == null) {
                    mQueryTextNotEmptyBg =
                            getResources().getDrawable(R.drawable.textfield_search_empty);
                }
                mQueryTextView.setBackgroundDrawable(mQueryTextNotEmptyBg);
                Corpus corpus = getCorpus();
                mQueryTextView.setHint(corpus == null ? """" : corpus.getHint());
            }
        } else {
            mQueryTextView.setBackgroundResource(R.drawable.textfield_search);
        }
    }

    private void updateSearchGoButton(boolean queryEmpty) {
        if (queryEmpty) {
            mSearchGoButton.setVisibility(View.GONE);
        } else {
            mSearchGoButton.setVisibility(View.VISIBLE);
        }
    }

    protected void updateVoiceSearchButton(boolean queryEmpty) {
        if (shouldShowVoiceSearch(queryEmpty)
                && getVoiceSearch().shouldShowVoiceSearch(getCorpus())) {
            mVoiceSearchButton.setVisibility(View.VISIBLE);
            mQueryTextView.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
        } else {
            mVoiceSearchButton.setVisibility(View.GONE);
            mQueryTextView.setPrivateImeOptions(null);
        }
    }

    protected boolean shouldShowVoiceSearch(boolean queryEmpty) {
        return queryEmpty;
    }

    /**
     * Hides the input method.
     */
    protected void hideInputMethod() {
        InputMethodManager imm = (InputMethodManager)
                getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        if (imm != null) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
    }

    public abstract void considerHidingInputMethod();

    public void showInputMethodForQuery() {
        mQueryTextView.showInputMethod();
    }

    /**
     * Dismiss the activity if BACK is pressed when the search box is empty.
     */
    @Override
    public boolean dispatchKeyEventPreIme(KeyEvent event) {
        SearchActivity activity = getActivity();
        if (activity != null && event.getKeyCode() == KeyEvent.KEYCODE_BACK
                && isQueryEmpty()) {
            KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null) {
                if (event.getAction() == KeyEvent.ACTION_DOWN
                        && event.getRepeatCount() == 0) {
                    state.startTracking(event, this);
                    return true;
                } else if (event.getAction() == KeyEvent.ACTION_UP
                        && !event.isCanceled() && state.isTracking(event)) {
                    hideInputMethod();
                    activity.onBackPressed();
                    return true;
                }
            }
        }
        return super.dispatchKeyEventPreIme(event);
    }

    /**
     * If the input method is in fullscreen mode, and the selector corpus
     * is All or Web, use the web search suggestions as completions.
     */
    protected void updateInputMethodSuggestions() {
        InputMethodManager imm = (InputMethodManager)
                getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        if (imm == null || !imm.isFullscreenMode()) return;
        Suggestions suggestions = mSuggestionsAdapter.getSuggestions();
        if (suggestions == null) return;
        CompletionInfo[] completions = webSuggestionsToCompletions(suggestions);
        if (DBG) Log.d(TAG, ""displayCompletions("" + Arrays.toString(completions) + "")"");
        imm.displayCompletions(mQueryTextView, completions);
    }

    private CompletionInfo[] webSuggestionsToCompletions(Suggestions suggestions) {
        // TODO: This should also include include web search shortcuts
        CorpusResult cursor = suggestions.getWebResult();
        if (cursor == null) return null;
        int count = cursor.getCount();
        ArrayList<CompletionInfo> completions = new ArrayList<CompletionInfo>(count);
        boolean usingWebCorpus = isSearchCorpusWeb();
        for (int i = 0; i < count; i++) {
            cursor.moveTo(i);
            if (!usingWebCorpus || cursor.isWebSearchSuggestion()) {
                String text1 = cursor.getSuggestionText1();
                completions.add(new CompletionInfo(i, i, text1));
            }
        }
        return completions.toArray(new CompletionInfo[completions.size()]);
    }

    protected void onSuggestionsChanged() {
        updateInputMethodSuggestions();
    }

    /**
     * Checks if the corpus used for typed searches is the web corpus.
     */
    protected boolean isSearchCorpusWeb() {
        Corpus corpus = getSearchCorpus();
        return corpus != null && corpus.isWebCorpus();
    }

    protected boolean onSuggestionKeyDown(SuggestionsAdapter<?> adapter,
            long suggestionId, int keyCode, KeyEvent event) {
        // Treat enter or search as a click
        if (       keyCode == KeyEvent.KEYCODE_ENTER
                || keyCode == KeyEvent.KEYCODE_SEARCH
                || keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
            if (adapter != null) {
                adapter.onSuggestionClicked(suggestionId);
                return true;
            } else {
                return false;
            }
        }

        return false;
    }

    protected boolean onSearchClicked(int method) {
        if (mSearchClickListener != null) {
            return mSearchClickListener.onSearchClicked(method);
        }
        return false;
    }

    /**
     * Filters the suggestions list when the search text changes.
     */
    private class SearchTextWatcher implements TextWatcher {
        public void afterTextChanged(Editable s) {
            boolean empty = s.length() == 0;
            if (empty != mQueryWasEmpty) {
                mQueryWasEmpty = empty;
                updateUi(empty);
            }
            if (mUpdateSuggestions) {
                if (mQueryListener != null) {
                    mQueryListener.onQueryChanged();
                }
            }
        }

        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
        }

        public void onTextChanged(CharSequence s, int start, int before, int count) {
        }
    }

    /**
     * Handles key events on the suggestions list view.
     */
    protected class SuggestionsViewKeyListener implements View.OnKeyListener {
        public boolean onKey(View v, int keyCode, KeyEvent event) {
            if (event.getAction() == KeyEvent.ACTION_DOWN
                    && v instanceof SuggestionsListView<?>) {
                SuggestionsListView<?> listView = (SuggestionsListView<?>) v;
                if (onSuggestionKeyDown(listView.getSuggestionsAdapter(), 
                        listView.getSelectedItemId(), keyCode, event)) {
                    return true;
                }
            }
            return forwardKeyToQueryTextView(keyCode, event);
        }
    }

    private class InputMethodCloser implements SuggestionsView.OnScrollListener {

        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount,
                int totalItemCount) {
        }

        public void onScrollStateChanged(AbsListView view, int scrollState) {
            considerHidingInputMethod();
        }
    }

    /**
     * Listens for clicks on the source selector.
     */
    private class SearchGoButtonClickListener implements View.OnClickListener {
        public void onClick(View view) {
            onSearchClicked(Logger.SEARCH_METHOD_BUTTON);
        }
    }

    /**
     * This class handles enter key presses in the query text view.
     */
    private class QueryTextEditorActionListener implements OnEditorActionListener {
        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
            boolean consumed = false;
            if (event != null) {
                if (event.getAction() == KeyEvent.ACTION_UP) {
                    consumed = onSearchClicked(Logger.SEARCH_METHOD_KEYBOARD);
                } else if (event.getAction() == KeyEvent.ACTION_DOWN) {
                    // we have to consume the down event so that we receive the up event too
                    consumed = true;
                }
            }
            if (DBG) Log.d(TAG, ""onEditorAction consumed="" + consumed);
            return consumed;
        }
    }

    /**
     * Handles key events on the search and voice search buttons,
     * by refocusing to EditText.
     */
    private class ButtonsKeyListener implements View.OnKeyListener {
        public boolean onKey(View v, int keyCode, KeyEvent event) {
            return forwardKeyToQueryTextView(keyCode, event);
        }
    }

    private boolean forwardKeyToQueryTextView(int keyCode, KeyEvent event) {
        if (!event.isSystem() && shouldForwardToQueryTextView(keyCode)) {
            if (DBG) Log.d(TAG, ""Forwarding key to query box: "" + event);
            if (mQueryTextView.requestFocus()) {
                return mQueryTextView.dispatchKeyEvent(event);
            }
        }
        return false;
    }

    private boolean shouldForwardToQueryTextView(int keyCode) {
        switch (keyCode) {
            case KeyEvent.KEYCODE_DPAD_UP:
            case KeyEvent.KEYCODE_DPAD_DOWN:
            case KeyEvent.KEYCODE_DPAD_LEFT:
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            case KeyEvent.KEYCODE_DPAD_CENTER:
            case KeyEvent.KEYCODE_ENTER:
            case KeyEvent.KEYCODE_SEARCH:
                return false;
            default:
                return true;
        }
    }

    /**
     * Hides the input method when the suggestions get focus.
     */
    private class SuggestListFocusListener implements OnFocusChangeListener {
        public void onFocusChange(View v, boolean focused) {
            if (DBG) Log.d(TAG, ""Suggestions focus change, now: "" + focused);
            if (focused) {
                considerHidingInputMethod();
            }
        }
    }

    private class QueryTextViewFocusListener implements OnFocusChangeListener {
        public void onFocusChange(View v, boolean focused) {
            if (DBG) Log.d(TAG, ""Query focus change, now: "" + focused);
            if (focused) {
                // The query box got focus, show the input method
                showInputMethodForQuery();
            }
        }
    }

    protected class SuggestionsObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            onSuggestionsChanged();
        }
    }

    public interface QueryListener {
        void onQueryChanged();
    }

    public interface SearchClickListener {
        boolean onSearchClicked(int method);
    }

    private class CloseClickListener implements OnClickListener {
        public void onClick(View v) {
            if (!isQueryEmpty()) {
                mQueryTextView.setText("""");
            } else {
                mExitClickListener.onClick(v);
            }
        }
    }
}
",True,131,1,2,6,57,3,19,L9
129,com.android.quicksearchbox.ui.CorpusView.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.R;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.util.AttributeSet;
import android.view.ViewDebug;
import android.widget.Checkable;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;


/**
 * A corpus in the corpus selection list.
 */
public class CorpusView extends RelativeLayout implements Checkable {

    private ImageView mIcon;
    private TextView mLabel;
    private boolean mChecked;

    private static final int[] CHECKED_STATE_SET = {
        android.R.attr.state_checked
    };

    public CorpusView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public CorpusView(Context context) {
        super(context);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mIcon = (ImageView) findViewById(R.id.source_icon);
        mLabel = (TextView) findViewById(R.id.source_label);
    }

    public void setLabel(CharSequence label) {
        mLabel.setText(label);
    }

    public void setIcon(Drawable icon) {
        mIcon.setImageDrawable(icon);
    }

    @ViewDebug.ExportedProperty
    public boolean isChecked() {
        return mChecked;
    }

    public void setChecked(boolean checked) {
        if (mChecked != checked) {
            mChecked = checked;
            refreshDrawableState();
        }
    }

    public void toggle() {
        setChecked(!mChecked);
    }

    @Override
    protected int[] onCreateDrawableState(int extraSpace) {
        final int[] drawableState = super.onCreateDrawableState(extraSpace + 1);
        if (isChecked()) {
            mergeDrawableStates(drawableState, CHECKED_STATE_SET);
        }
        return drawableState;
    }

}
",False,8,4,3,0,0,1,0,L9
130,com.android.quicksearchbox.ui.ContactBadge.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.ui;

import android.content.Context;
import android.util.AttributeSet;
import android.view.View;
import android.widget.QuickContactBadge;

/**
 * A {@link QuickContactBadge} that allows setting a click listener.
 * The base class may use {@link View#setOnClickListener} internally,
 * so this class adds a separate click listener field.
 */
public class ContactBadge extends QuickContactBadge {

    private View.OnClickListener mExtraOnClickListener;

    public ContactBadge(Context context) {
        super(context);
    }

    public ContactBadge(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public ContactBadge(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    @Override
    public void onClick(View v) {
        super.onClick(v);
        if (mExtraOnClickListener != null) {
            mExtraOnClickListener.onClick(v);
        }
    }

    public void setExtraOnClickListener(View.OnClickListener extraOnClickListener) {
        mExtraOnClickListener = extraOnClickListener;
    }

}
",False,33,6,19,0,0,1,0,L8
131,com.android.quicksearchbox.ui.DefaultSuggestionView.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.R;
import com.android.quicksearchbox.Source;
import com.android.quicksearchbox.Suggestion;
import com.android.quicksearchbox.util.Consumer;
import com.android.quicksearchbox.util.NowOrLater;

import android.content.Context;
import android.content.res.ColorStateList;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.text.Html;
import android.text.Spannable;
import android.text.SpannableString;
import android.text.TextUtils;
import android.text.style.TextAppearanceSpan;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;
import android.widget.ImageView;
import android.widget.TextView;

/**
 * View for the items in the suggestions list. This includes promoted suggestions,
 * sources, and suggestions under each source.
 */
public class DefaultSuggestionView extends BaseSuggestionView {

    private static final boolean DBG = false;

    private static final String VIEW_ID = ""default"";

    private final String TAG = ""QSB.DefaultSuggestionView"";

    private AsyncIcon mAsyncIcon1;
    private AsyncIcon mAsyncIcon2;

    public DefaultSuggestionView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    public DefaultSuggestionView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public DefaultSuggestionView(Context context) {
        super(context);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mText1 = (TextView) findViewById(R.id.text1);
        mText2 = (TextView) findViewById(R.id.text2);
        mAsyncIcon1 = new AsyncIcon(mIcon1) {
            // override default icon (when no other available) with default source icon
            @Override
            protected String getFallbackIconId(Source source) {
                return source.getSourceIconUri().toString();
            }
            @Override
            protected Drawable getFallbackIcon(Source source) {
                return source.getSourceIcon();
            }
        };
        mAsyncIcon2 = new AsyncIcon(mIcon2);
    }

    @Override
    public void bindAsSuggestion(Suggestion suggestion, String userQuery) {
        super.bindAsSuggestion(suggestion, userQuery);

        CharSequence text1 = formatText(suggestion.getSuggestionText1(), suggestion);
        CharSequence text2 = suggestion.getSuggestionText2Url();
        if (text2 != null) {
            text2 = formatUrl(text2);
        } else {
            text2 = formatText(suggestion.getSuggestionText2(), suggestion);
        }
        // If there is no text for the second line, allow the first line to be up to two lines
        if (TextUtils.isEmpty(text2)) {
            mText1.setSingleLine(false);
            mText1.setMaxLines(2);
            mText1.setEllipsize(TextUtils.TruncateAt.START);
        } else {
            mText1.setSingleLine(true);
            mText1.setMaxLines(1);
            mText1.setEllipsize(TextUtils.TruncateAt.MIDDLE);
        }
        setText1(text1);
        setText2(text2);
        mAsyncIcon1.set(suggestion.getSuggestionSource(), suggestion.getSuggestionIcon1());
        mAsyncIcon2.set(suggestion.getSuggestionSource(), suggestion.getSuggestionIcon2());

        if (DBG) {
            Log.d(TAG, ""bindAsSuggestion(), text1="" + text1 + "",text2="" + text2 + "",q='"" +
                    userQuery + "",fromHistory="" + isFromHistory(suggestion));
        }
    }

    private CharSequence formatUrl(CharSequence url) {
        SpannableString text = new SpannableString(url);
        ColorStateList colors = getResources().getColorStateList(R.color.url_text);
        text.setSpan(new TextAppearanceSpan(null, 0, 0, colors, null),
                0, url.length(),
                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        return text;
    }

    private CharSequence formatText(String str, Suggestion suggestion) {
        boolean isHtml = ""html"".equals(suggestion.getSuggestionFormat());
        if (isHtml && looksLikeHtml(str)) {
            return Html.fromHtml(str);
        } else {
            return str;
        }
    }

    private boolean looksLikeHtml(String str) {
        if (TextUtils.isEmpty(str)) return false;
        for (int i = str.length() - 1; i >= 0; i--) {
            char c = str.charAt(i);
            if (c == '>' || c == '&') return true;
        }
        return false;
    }

    /**
     * Sets the drawable in an image view, makes sure the view is only visible if there
     * is a drawable.
     */
    private static void setViewDrawable(ImageView v, Drawable drawable) {
        // Set the icon even if the drawable is null, since we need to clear any
        // previous icon.
        v.setImageDrawable(drawable);

        if (drawable == null) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);

            // This is a hack to get any animated drawables (like a 'working' spinner)
            // to animate. You have to setVisible true on an AnimationDrawable to get
            // it to start animating, but it must first have been false or else the
            // call to setVisible will be ineffective. We need to clear up the story
            // about animated drawables in the future, see http://b/1878430.
            drawable.setVisible(false, false);
            drawable.setVisible(true, false);
        }
    }

    private class AsyncIcon {
        private final ImageView mView;
        private String mCurrentId;
        private String mWantedId;

        public AsyncIcon(ImageView view) {
            mView = view;
        }

        public void set(final Source source, final String sourceIconId) {
            if (sourceIconId != null) {
                // The iconId can just be a package-relative resource ID, which may overlap with
                // other packages. Make sure it's globally unique.
                Uri iconUri = source.getIconUri(sourceIconId);
                final String uniqueIconId = iconUri == null ? null : iconUri.toString();
                mWantedId = uniqueIconId;
                if (!TextUtils.equals(mWantedId, mCurrentId)) {
                    if (DBG) Log.d(TAG, ""getting icon Id="" + uniqueIconId);
                    NowOrLater<Drawable> icon = source.getIcon(sourceIconId);
                    if (icon.haveNow()) {
                        if (DBG) Log.d(TAG, ""getIcon ready now"");
                        handleNewDrawable(icon.getNow(), uniqueIconId, source);
                    } else {
                        // make sure old icon is not visible while new one is loaded
                        if (DBG) Log.d(TAG , ""getIcon getting later"");
                        clearDrawable();
                        icon.getLater(new Consumer<Drawable>(){
                            public boolean consume(Drawable icon) {
                                if (DBG) {
                                    Log.d(TAG, ""IconConsumer.consume got id "" + uniqueIconId +
                                            "" want id "" + mWantedId);
                                }
                                // ensure we have not been re-bound since the request was made.
                                if (TextUtils.equals(uniqueIconId, mWantedId)) {
                                    handleNewDrawable(icon, uniqueIconId, source);
                                    return true;
                                }
                                return false;
                            }});
                    }
                }
            } else {
                mWantedId = null;
                handleNewDrawable(null, null, source);
            }
        }

        private void handleNewDrawable(Drawable icon, String id, Source source) {
            if (icon == null) {
                mWantedId = getFallbackIconId(source);
                if (TextUtils.equals(mWantedId, mCurrentId)) {
                    return;
                }
                icon = getFallbackIcon(source);
            }
            setDrawable(icon, id);
        }

        private void setDrawable(Drawable icon, String id) {
            mCurrentId = id;
            setViewDrawable(mView, icon);
        }

        private void clearDrawable() {
            mCurrentId = null;
            mView.setImageDrawable(null);
        }

        protected String getFallbackIconId(Source source) {
            return null;
        }

        protected Drawable getFallbackIcon(Source source) {
            return null;
        }

    }

    public static class Factory extends SuggestionViewInflater {
        public Factory(Context context) {
            super(VIEW_ID, DefaultSuggestionView.class, R.layout.suggestion, context);
        }
    }

}
",False,62,5,19,5,8,2,6,L8
132,com.android.quicksearchbox.ui.DefaultSuggestionViewFactory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Suggestion;
import com.android.quicksearchbox.SuggestionCursor;

import android.content.Context;
import android.view.View;
import android.view.ViewGroup;

import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;

/**
 * Suggestion view factory for Google suggestions.
 */
public class DefaultSuggestionViewFactory implements SuggestionViewFactory {

    private final LinkedList<SuggestionViewFactory> mFactories
            = new LinkedList<SuggestionViewFactory>();
    private final SuggestionViewFactory mDefaultFactory;
    private HashSet<String> mViewTypes;

    public DefaultSuggestionViewFactory(Context context) {
        mDefaultFactory = new DefaultSuggestionView.Factory(context);
        addFactory(new WebSearchSuggestionView.Factory(context));
        addFactory(new ContactSuggestionView.Factory(context));
    }

    /**
     * Must only be called from the constructor
     */
    protected final void addFactory(SuggestionViewFactory factory) {
        mFactories.addFirst(factory);
    }

    public Collection<String> getSuggestionViewTypes() {
        if (mViewTypes == null) {
            mViewTypes = new HashSet<String>();
            mViewTypes.addAll(mDefaultFactory.getSuggestionViewTypes());
            for (SuggestionViewFactory factory : mFactories) {
                mViewTypes.addAll(factory.getSuggestionViewTypes());
            }
        }
        return mViewTypes;
    }

    public View getView(SuggestionCursor suggestion, String userQuery,
            View convertView, ViewGroup parent) {
        for (SuggestionViewFactory factory : mFactories) {
            if (factory.canCreateView(suggestion)) {
                return factory.getView(suggestion, userQuery, convertView, parent);
            }
        }
        return mDefaultFactory.getView(suggestion, userQuery, convertView, parent);
    }

    public String getViewType(Suggestion suggestion) {
        for (SuggestionViewFactory factory : mFactories) {
            if (factory.canCreateView(suggestion)) {
                return factory.getViewType(suggestion);
            }
        }
        return mDefaultFactory.getViewType(suggestion);
    }

    @Override
    public boolean canCreateView(Suggestion suggestion) {
        return true;
    }

}
",False,118,0,0,6,51,1,6,L8
133,com.android.quicksearchbox.ui.ClusteredSuggestionsAdapter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.CorpusResult;
import com.android.quicksearchbox.ListSuggestionCursor;
import com.android.quicksearchbox.R;
import com.android.quicksearchbox.Suggestion;
import com.android.quicksearchbox.SuggestionCursor;
import com.android.quicksearchbox.SuggestionPosition;
import com.android.quicksearchbox.SuggestionUtils;
import com.android.quicksearchbox.Suggestions;

import android.content.Context;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseExpandableListAdapter;
import android.widget.ExpandableListAdapter;

import java.util.ArrayList;
import java.util.HashSet;

/**
 * Adapter for suggestions list where suggestions are clustered by corpus.
 */
public class ClusteredSuggestionsAdapter extends SuggestionsAdapterBase<ExpandableListAdapter> {

    private static final String TAG = ""QSB.ClusteredSuggestionsAdapter"";

    private final static int GROUP_SHIFT = 32;
    private final static long CHILD_MASK = 0xffffffff;

    private final Adapter mAdapter;
    private final Context mContext;
    private final LayoutInflater mInflater;

    public ClusteredSuggestionsAdapter(SuggestionViewFactory viewFactory, Context context) {
        super(viewFactory);
        mAdapter = new Adapter();
        mContext = context;
        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }

    @Override
    public boolean isEmpty() {
        return mAdapter.getGroupCount() == 0;
    }

    @Override
    public boolean willPublishNonPromotedSuggestions() {
        return true;
    }

    @Override
    public SuggestionPosition getSuggestion(long suggestionId) {
        return mAdapter.getChildById(suggestionId);
    }

    @Override
    public ExpandableListAdapter getListAdapter() {
        return mAdapter;
    }

    @Override
    protected void notifyDataSetChanged() {
        mAdapter.buildCorpusGroups();
        mAdapter.notifyDataSetChanged();
    }

    @Override
    protected void notifyDataSetInvalidated() {
        mAdapter.buildCorpusGroups();
        mAdapter.notifyDataSetInvalidated();
    }

    private class Adapter extends BaseExpandableListAdapter {

        private ArrayList<SuggestionCursor> mCorpusGroups;

        public void buildCorpusGroups() {
            Suggestions suggestions = getSuggestions();
            SuggestionCursor promoted = getCurrentPromotedSuggestions();
            HashSet<String> promotedSuggestions = new HashSet<String>();
            if (promoted != null && promoted.getCount() > 0) {
                promoted.moveTo(0);
                do {
                    promotedSuggestions.add(SuggestionUtils.getSuggestionKey(promoted));
                } while (promoted.moveToNext());
            }
            if (suggestions == null) {
                mCorpusGroups = null;
            } else {
                if (mCorpusGroups == null) {
                    mCorpusGroups = new ArrayList<SuggestionCursor>();
                } else {
                    mCorpusGroups.clear();
                }
                for (CorpusResult result : suggestions.getCorpusResults()) {
                    ListSuggestionCursor corpusSuggestions = new ListSuggestionCursor(
                            result.getUserQuery());
                    for (int i = 0; i < result.getCount(); ++i) {
                        result.moveTo(i);
                        if (!result.isWebSearchSuggestion()) {
                            if (!promotedSuggestions.contains(
                                    SuggestionUtils.getSuggestionKey(result))) {
                                corpusSuggestions.add(new SuggestionPosition(result, i));
                            }
                        }
                    }
                    if (corpusSuggestions.getCount() > 0) {
                        mCorpusGroups.add(corpusSuggestions);
                    }
                }
            }
        }

        @Override
        public long getCombinedChildId(long groupId, long childId) {
            // add one to the child ID to ensure that the group elements do not have the same ID
            // as the first child within the group.
            return (groupId << GROUP_SHIFT) | ((childId + 1) & CHILD_MASK);
        }

        @Override
        public long getCombinedGroupId(long groupId) {
            return groupId << GROUP_SHIFT;
        }

        public int getChildPosition(long childId) {
            return (int) (childId & CHILD_MASK) - 1;
        }

        public int getGroupPosition(long childId) {
            return (int) ((childId >> GROUP_SHIFT) & CHILD_MASK);
        }

        @Override
        public Suggestion getChild(int groupPosition, int childPosition) {
            SuggestionCursor c = getGroup(groupPosition);
            if (c != null) {
                c.moveTo(childPosition);
                return new SuggestionPosition(c, childPosition);
            }
            return null;
        }

        public SuggestionPosition getChildById(long childId) {
            SuggestionCursor groupCursor = getGroup(getGroupPosition(childId));
            if (groupCursor != null) {
                return new SuggestionPosition(groupCursor, getChildPosition(childId));
            } else {
                Log.w(TAG, ""Invalid childId "" + Long.toHexString(childId) + "" (invalid group)"");
                return null;
            }
        }

        @Override
        public long getChildId(int groupPosition, int childPosition) {
            return childPosition;
        }

        @Override
        public View getChildView(int groupPosition, int childPosition, boolean isLastChild,
                View convertView, ViewGroup parent) {
            SuggestionCursor cursor = getGroup(groupPosition);
            if (cursor == null) return null;
            return getView(cursor, childPosition, getCombinedChildId(groupPosition, childPosition),
                    convertView, parent);
        }

        @Override
        public int getChildrenCount(int groupPosition) {
            SuggestionCursor group = getGroup(groupPosition);
            return group == null ? 0 : group.getCount();
        }

        @Override
        public SuggestionCursor getGroup(int groupPosition) {
            if (groupPosition < promotedGroupCount()) {
                return getCurrentPromotedSuggestions();
            } else {
                int pos = groupPosition - promotedGroupCount();
                if ((pos < 0 ) || (pos >= mCorpusGroups.size())) return null;
                return mCorpusGroups.get(pos);
            }
        }

        private int promotedCount() {
            SuggestionCursor promoted = getCurrentPromotedSuggestions();
            return (promoted == null ? 0 : promoted.getCount());
        }

        private int promotedGroupCount() {
            return (promotedCount() == 0) ? 0 : 1;
        }

        private int corpusGroupCount() {
            return mCorpusGroups == null ? 0 : mCorpusGroups.size();
        }

        @Override
        public int getGroupCount() {
            return promotedGroupCount() + corpusGroupCount();
        }

        @Override
        public long getGroupId(int groupPosition) {
            return groupPosition;
        }

        @Override
        public View getGroupView(
                int groupPosition, boolean isExpanded, View convertView, ViewGroup parent) {
            if (convertView == null) {
                convertView = mInflater.inflate(R.layout.suggestion_group, parent, false);
            }
            if (groupPosition == 0) {
                // don't show the group separator for the first group, to avoid seeing an empty
                // gap at the top of the list.
                convertView.getLayoutParams().height = 0;
            } else {
                convertView.getLayoutParams().height = mContext.getResources().
                        getDimensionPixelSize(R.dimen.suggestion_group_spacing);
            }
            // since we've fiddled with the layout params:
            convertView.requestLayout();
            return convertView;
        }

        @Override
        public boolean hasStableIds() {
            return false;
        }

        @Override
        public boolean isChildSelectable(int groupPosition, int childPosition) {
            return true;
        }

        @Override
        public int getChildType(int groupPosition, int childPosition) {
            return getSuggestionViewType(getGroup(groupPosition), childPosition);
        }

        @Override
        public int getChildTypeCount() {
            return getSuggestionViewTypeCount();
        }
    }

}
",False,30,1,1,4,13,1,9,L10
134,com.android.quicksearchbox.ui.SuggestionsAdapter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Promoter;
import com.android.quicksearchbox.SuggestionCursor;
import com.android.quicksearchbox.SuggestionPosition;
import com.android.quicksearchbox.Suggestions;

import android.view.View.OnFocusChangeListener;
import android.widget.ExpandableListAdapter;
import android.widget.ListAdapter;

/**
 * Interface for suggestions adapters.
 *
 * @param <A> the adapter class used by the UI, probably either {@link ListAdapter} or
 *      {@link ExpandableListAdapter}.
 */
public interface SuggestionsAdapter<A> {

    /**
     * Sets the maximum number of promoted suggestions to be provided by this adapter.
     */
    void setMaxPromoted(int maxPromoted);

    /**
     * Sets the suggestion promoter.
     */
    void setPromoter(Promoter promoter);

    /**
     * Sets the listener to be notified of clicks on suggestions.
     */
    void setSuggestionClickListener(SuggestionClickListener listener);

    /**
     * Sets the listener to be notified of focus change events on suggestion views.
     */
    void setOnFocusChangeListener(OnFocusChangeListener l);

    /**
     * Sets the current suggestions.
     */
    void setSuggestions(Suggestions suggestions);

    /**
     * Indicates if there's any suggestions in this adapter.
     */
    boolean isEmpty();

    /**
     * Gets the current suggestions.
     */
    Suggestions getSuggestions();

    /**
     * Gets the cursor and position corresponding to the given suggestion ID.
     * @param suggestionId Suggestion ID.
     */
    SuggestionPosition getSuggestion(long suggestionId);

    /**
     * Gets the current list of promoted suggestions.
     */
    SuggestionCursor getCurrentPromotedSuggestions();

    /**
     * Handles a regular click on a suggestion.
     *
     * @param suggestionId The ID of the suggestion clicked. If the suggestion list is flat, this
     *      will be the position within the list.
     */
    void onSuggestionClicked(long suggestionId);

    /**
     * Handles a click on a quick contact badge.
     *
     * @param suggestionId The ID of the suggestion clicked. If the suggestion list is flat, this
     *      will be the position within the list.
     */
    void onSuggestionQuickContactClicked(long suggestionId);

    /**
     * Handles a request to remove a suggestion from history.
     *
     * @param suggestionId The ID of the suggestion clicked. If the suggestion list is flat, this
     *      will be the position within the list.
     */
    void onSuggestionRemoveFromHistoryClicked(long suggestionId);

    /**
     * Handles a click on the query refinement button.
     *
     * @param suggestionId The ID of the suggestion clicked. If the suggestion list is flat, this
     *      will be the position within the list.
     */
    void onSuggestionQueryRefineClicked(long suggestionId);

    /**
     * Gets the adapter to be used by the UI view.
     */
    A getListAdapter();

}
",False,68,7,13,4,10,11,5,L8
135,com.android.quicksearchbox.ui.SuggestionsListAdapter.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.SuggestionPosition;
import com.android.quicksearchbox.Suggestions;

import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ListAdapter;

/**
 * Uses a {@link Suggestions} object to back a {@link SuggestionsView}.
 */
public class SuggestionsListAdapter extends SuggestionsAdapterBase<ListAdapter> {

    private Adapter mAdapter;

    public SuggestionsListAdapter(SuggestionViewFactory viewFactory) {
        super(viewFactory);
        mAdapter = new Adapter();
    }

    @Override
    public boolean isEmpty() {
        return mAdapter.getCount() == 0;
    }

    @Override
    public boolean willPublishNonPromotedSuggestions() {
        return false;
    }

    @Override
    public SuggestionPosition getSuggestion(long suggestionId) {
        return new SuggestionPosition(getCurrentPromotedSuggestions(), (int) suggestionId);
    }

    @Override
    public BaseAdapter getListAdapter() {
        return mAdapter;
    }

    @Override
    public void notifyDataSetChanged() {
        mAdapter.notifyDataSetChanged();
    }

    @Override
    public void notifyDataSetInvalidated() {
        mAdapter.notifyDataSetInvalidated();
    }

    class Adapter extends BaseAdapter {

        @Override
        public int getCount() {
            return getPromotedCount();
        }

        @Override
        public Object getItem(int position) {
            return getPromotedSuggestion(position);
        }

        @Override
        public long getItemId(int position) {
            return position;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            return SuggestionsListAdapter.this.getView(
                    getCurrentPromotedSuggestions(), position, position, convertView, parent);
        }

        @Override
        public int getItemViewType(int position) {
            return getSuggestionViewType(getCurrentPromotedSuggestions(), position);
        }

        @Override
        public int getViewTypeCount() {
            return getSuggestionViewTypeCount();
        }

    }

}
",False,35,3,3,4,14,1,4,L9
136,com.android.quicksearchbox.preferences.SearchableItemPreference.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.preferences;

import com.android.quicksearchbox.R;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.preference.CheckBoxPreference;
import android.view.View;
import android.widget.ImageView;

/**
 * A CheckBoxPreference with an icon added.
 */
public class SearchableItemPreference extends CheckBoxPreference {

    private Drawable mIcon;

    SearchableItemPreference(Context context) {
        super(context);
        setLayoutResource(R.layout.searchable_item_preference);
    }

    public void setIcon(Drawable icon) {
        mIcon = icon;
    }

     @Override
    protected void onBindView(View view) {
        super.onBindView(view);
        ImageView icon = (ImageView) view.findViewById(R.id.icon);
        icon.setImageDrawable(mIcon);
    }

}
",False,34,6,19,0,0,1,0,L8
137,com.android.quicksearchbox.preferences.OkCancelPreference.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.preferences;

import android.content.Context;
import android.preference.DialogPreference;
import android.util.AttributeSet;

/**
 * Dialog preference that allows registering a listener for the result.
 */
public class OkCancelPreference extends DialogPreference {

    private Listener mListener;

    public OkCancelPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected void onDialogClosed(boolean positiveResult) {
        super.onDialogClosed(positiveResult);

        if (mListener != null) {
            mListener.onDialogClosed(positiveResult);
        }
    }

    public void setListener(Listener listener) {
        mListener = listener;
    }

    public interface Listener {
        void onDialogClosed(boolean okClicked);
    }

}
",False,34,6,19,0,0,1,0,L8
138,com.android.quicksearchbox.preferences.SearchableItemsController.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.preferences;

import com.android.quicksearchbox.Corpora;
import com.android.quicksearchbox.Corpus;
import com.android.quicksearchbox.R;
import com.android.quicksearchbox.SearchSettings;
import com.android.quicksearchbox.SearchSettingsImpl;

import android.content.Context;
import android.content.res.Resources;
import android.preference.Preference;
import android.preference.Preference.OnPreferenceChangeListener;
import android.preference.PreferenceGroup;
import android.util.Log;

/**
 * Logic backing the searchable items activity or fragment.
 */
public class SearchableItemsController implements PreferenceController, OnPreferenceChangeListener {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SearchableItemsSettings"";

    public static final String SEARCH_CORPORA_PREF = ""search_corpora"";

    private final SearchSettings mSearchSettings;
    private final Corpora mCorpora;
    private final Context mContext;

    // References to the top-level preference objects
    private PreferenceGroup mCorporaPreferences;

    public SearchableItemsController(SearchSettings searchSettings, Corpora corpora,
            Context context) {
        mSearchSettings = searchSettings;
        mCorpora = corpora;
        mContext = context;
    }

    public void handlePreference(Preference corporaPreferences) {
        mCorporaPreferences = (PreferenceGroup) corporaPreferences;
        populateSourcePreference();
    }

    public String getCorporaPreferenceKey() {
        return SEARCH_CORPORA_PREF;
    }

    private SearchSettings getSettings() {
        return mSearchSettings;
    }

    private Corpora getCorpora() {
        return mCorpora;
    }

    private Context getContext() {
        return mContext;
    }

    private Resources getResources() {
        return getContext().getResources();
    }


    /**
     * Fills the suggestion source list.
     */
    private void populateSourcePreference() {
        boolean includeNonAllCorpora =
                getResources().getBoolean(R.bool.show_non_all_corpora_in_settings);
        mCorporaPreferences.setOrderingAsAdded(false);
        for (Corpus corpus : getCorpora().getAllCorpora()) {
            if (includeNonAllCorpora || corpus.includeInAll()) {
                Preference pref = createCorpusPreference(corpus);
                if (pref != null) {
                    if (DBG) Log.d(TAG, ""Adding corpus: "" + corpus);
                    mCorporaPreferences.addPreference(pref);
                }
            }
        }
    }

    /**
     * Adds a suggestion source to the list of suggestion source checkbox preferences.
     */
    private Preference createCorpusPreference(Corpus corpus) {
        SearchableItemPreference sourcePref = new SearchableItemPreference(getContext());
        sourcePref.setKey(SearchSettingsImpl.getCorpusEnabledPreference(corpus));
        // Put web corpus first. The rest are alphabetical.
        if (corpus.isWebCorpus()) {
            sourcePref.setOrder(0);
        }
        sourcePref.setDefaultValue(corpus.isCorpusDefaultEnabled());
        sourcePref.setOnPreferenceChangeListener(this);
        CharSequence label = corpus.getLabel();
        sourcePref.setTitle(label);
        CharSequence description = corpus.getSettingsDescription();
        sourcePref.setSummaryOn(description);
        sourcePref.setSummaryOff(description);
        sourcePref.setIcon(corpus.getCorpusIcon());
        return sourcePref;
    }

    public boolean onPreferenceChange(Preference preference, Object newValue) {
        getSettings().broadcastSettingsChanged();
        return true;
    }

    public void onCreateComplete() {
    }

    public void onStop() {
    }

    public void onDestroy() {
    }

    public void onResume() {
    }

}
",False,50,5,19,5,6,1,6,L8
139,com.android.quicksearchbox.preferences.SearchableItemsFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.preferences;

import com.android.quicksearchbox.R;

import android.preference.PreferenceGroup;

/**
 * Fragment for selecting searchable items
 */
public class SearchableItemsFragment extends SettingsFragmentBase {

    @Override
    protected int getPreferencesResourceId() {
        return R.xml.preferences_searchable_items;
    }

    @Override
    protected void handlePreferenceGroup(PreferenceGroup screen) {
        getController().handlePreference(screen);
    }
}
",False,120,0,0,7,48,0,2,L10
140,com.android.quicksearchbox.preferences.DeviceSearchFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.preferences;

import com.android.quicksearchbox.R;

/**
 * 'Device' preferences.
 */
public class DeviceSearchFragment extends SettingsFragmentBase {

    @Override
    protected int getPreferencesResourceId() {
        return R.xml.device_search_preferences;
    }

}
",False,120,0,0,7,48,0,1,L10
141,com.android.quicksearchbox.preferences.SettingsFragmentBase.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.preferences;

import com.android.quicksearchbox.QsbApplication;

import android.os.Bundle;
import android.preference.Preference;
import android.preference.PreferenceCategory;
import android.preference.PreferenceFragment;
import android.preference.PreferenceGroup;

/**
 * System search settings fragment.
 */
public abstract class SettingsFragmentBase extends PreferenceFragment {

    // Name of the preferences file used to store search preference
    public static final String PREFERENCES_NAME = ""SearchSettings"";

    private PreferenceController mController;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mController = createController();

        getPreferenceManager().setSharedPreferencesName(getPreferencesName());

        addPreferencesFromResource(getPreferencesResourceId());

        handlePreferenceGroup(getPreferenceScreen());

        mController.onCreateComplete();
    }

    protected PreferenceController getController() {
        return mController;
    }

    protected PreferenceControllerFactory createController() {
        QsbApplication app = QsbApplication.get(getActivity());
        return app.createPreferenceControllerFactory(getActivity());
    }

    protected String getPreferencesName() {
        return PREFERENCES_NAME;
    }

    protected abstract int getPreferencesResourceId();

    protected void handlePreferenceGroup(PreferenceGroup group) {
        for (int i = 0; i < group.getPreferenceCount(); ++i) {
            Preference p = group.getPreference(i);
            if (p instanceof PreferenceCategory) {
                handlePreferenceGroup((PreferenceCategory) p);
            } else {
                mController.handlePreference(group.getPreference(i));
            }
        }
    }

    @Override
    public void onResume() {
        super.onResume();
        mController.onResume();
    }

    @Override
    public void onStop() {
        mController.onStop();
        super.onStop();
    }

    @Override
    public void onDestroy() {
        mController.onDestroy();
        super.onDestroy();
    }
}
",False,121,1,2,6,48,2,3,L9
142,com.android.quicksearchbox.preferences.PreferenceController.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.preferences;

import android.app.Activity;
import android.preference.Preference;

/**
 * Interfaces for classes that handle logic behind a settings preference.
 */
public interface PreferenceController {

    /**
     * Handle a preference. This should take any action necessary to implement the logic behind the
     * given preference. It will be called from {@link Activity#onCreate}.
     * @param p
     */
    void handlePreference(Preference p);

    /**
     * Called when {@link Activity#onCreate} has completed and is just about to return.
     */
    void onCreateComplete();

    /**
     * Called from {@link Activity#onResume}.
     */
    void onResume();

    /**
     * Called from {@link Activity#onStop}.
     */
    void onStop();

    /**
     * called from {@link Activity#onDestroy}
     */
    void onDestroy();

}
",False,35,5,17,0,0,5,0,L8
143,com.android.quicksearchbox.preferences.ClearShortcutsController.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.preferences;

import com.android.quicksearchbox.ShortcutRepository;
import com.android.quicksearchbox.util.Consumer;
import com.android.quicksearchbox.util.Consumers;

import android.os.Handler;
import android.preference.Preference;
import android.util.Log;

/**
 * Logic behind the 'clear shortcuts' preference.
 */
public class ClearShortcutsController implements PreferenceController {

    public static final String CLEAR_SHORTCUTS_PREF = ""clear_shortcuts"";

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.ClearShortcutsController"";

    private final ShortcutRepository mShortcuts;
    private final Handler mHandler = new Handler();

    private OkCancelPreference mClearShortcutsPreference;


    public ClearShortcutsController(ShortcutRepository shortcuts) {
        mShortcuts = shortcuts;
    }

    @Override
    public void handlePreference(Preference p) {
        mClearShortcutsPreference = (OkCancelPreference) p;
        mClearShortcutsPreference.setListener(new OkCancelPreference.Listener() {
            @Override
            public void onDialogClosed(boolean okClicked) {
                if (okClicked) {
                    clearShortcuts();
                }
            }
        });
    }

    public void onCreateComplete() {
    }

    public void onStop() {
    }

    public void onDestroy() {
    }

    @Override
    public void onResume() {
        updateClearShortcutsPreference();
    }

    /**
     * Enables/disables the ""Clear search shortcuts"" preference depending
     * on whether there is any search history.
     */
    private void updateClearShortcutsPreference() {
        mShortcuts.hasHistory(Consumers.createAsyncConsumer(mHandler, new Consumer<Boolean>() {
            @Override
            public boolean consume(Boolean hasHistory) {
                if (DBG) Log.d(TAG, ""hasHistory()="" + hasHistory);
                mClearShortcutsPreference.setEnabled(hasHistory);
                return true;
            }
        }));
    }

    private void clearShortcuts() {
        Log.i(TAG, ""Clearing shortcuts..."");
        mShortcuts.clearHistory();
        mClearShortcutsPreference.setEnabled(false);
    }
}
",False,55,5,19,4,10,1,5,L8
144,com.android.quicksearchbox.preferences.PreferenceControllerFactory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.preferences;

import com.android.quicksearchbox.Corpora;
import com.android.quicksearchbox.QsbApplication;
import com.android.quicksearchbox.SearchSettings;
import com.android.quicksearchbox.ShortcutRepository;

import android.content.Context;
import android.preference.Preference;

import java.util.ArrayList;

/**
 * Class to handle logic behind the preferences in settings.
 */
public class PreferenceControllerFactory implements PreferenceController {

    private final SearchSettings mSettings;
    private final Context mContext;
    private final ArrayList<PreferenceController> mControllers;

    public PreferenceControllerFactory(SearchSettings settings, Context context) {
        mSettings = settings;
        mContext = context;
        mControllers = new ArrayList<PreferenceController>();
    }

    protected Context getContext() {
        return mContext;
    }

    public void handlePreference(Preference p) {
        String key = p.getKey();
        if (key == null) return;
        if (SearchableItemsController.SEARCH_CORPORA_PREF.equals(key)) {
            Corpora corpora = QsbApplication.get(mContext).getCorpora();
            addController(new SearchableItemsController(mSettings, corpora, getContext()), p);
        } else if (ClearShortcutsController.CLEAR_SHORTCUTS_PREF.equals(key)) {
            ShortcutRepository shortcuts = QsbApplication.get(getContext()).getShortcutRepository();
            addController(new ClearShortcutsController(shortcuts), p);
        } else {
            throw new UnknownPreferenceException(p);
        }
    }

    public void onCreateComplete() {
        for (PreferenceController controller : mControllers) {
            controller.onCreateComplete();
        }
    }

    public void onResume() {
        for (PreferenceController controller : mControllers) {
            controller.onResume();
        }
    }

    public void onStop() {
        for (PreferenceController controller : mControllers) {
            controller.onStop();
        }
    }

    public void onDestroy() {
        for (PreferenceController controller : mControllers) {
            controller.onDestroy();
        }
    }

    protected void addController(PreferenceController controller, Preference forPreference) {
        mControllers.add(controller);
        controller.handlePreference(forPreference);
    }

    private static class UnknownPreferenceException extends RuntimeException {
        public UnknownPreferenceException(Preference p) {
            super(""Preference key "" + p.getKey() + ""; class: "" + p.getClass().toString());
        }
    }
}
",False,121,2,2,6,50,2,7,L8
145,com.android.quicksearchbox.preferences.SearchSettingsActivity.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.preferences;

import com.android.quicksearchbox.QsbApplication;
import com.android.quicksearchbox.R;

import android.preference.PreferenceActivity;
import android.util.Log;
import android.view.Menu;

import java.util.List;

/**
 * Activity for setting global search preferences.
 */
public class SearchSettingsActivity extends PreferenceActivity {
    private static final String TAG = ""QSB.SearchSettingsActivity"";
    private static final boolean DBG = false;

    private static final String CLEAR_SHORTCUTS_FRAGMENT = DeviceSearchFragment.class.getName();

    private static final String ACTIVITY_HELP_CONTEXT = ""settings"";

    /**
     * Populate the activity with the top-level headers.
     */
    @Override
    public void onBuildHeaders(List<Header> target) {
        loadHeadersFromResource(R.xml.preferences_headers, target);
        onHeadersBuilt(target);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getQsbApplication().getHelp().addHelpMenuItem(menu, ACTIVITY_HELP_CONTEXT, true);
        return true;
    }

    protected QsbApplication getQsbApplication() {
        return QsbApplication.get(this);
    }

    /**
     * Get the name of the fragment that contains only a 'clear shortcuts' preference, and hence
     * can be removed if zero-query shortcuts are disabled. Returns null if no such fragment exists.
     */
    protected String getShortcutsOnlyFragment() {
        return CLEAR_SHORTCUTS_FRAGMENT;
    }

    protected void onHeadersBuilt(List<Header> target) {
        String shortcutsFragment = getShortcutsOnlyFragment();
        if (shortcutsFragment == null) return;
        if (DBG) Log.d(TAG, ""onHeadersBuilt shortcutsFragment="" + shortcutsFragment);
        if (!QsbApplication.get(this).getConfig().showShortcutsForZeroQuery()) {
            // remove 'clear shortcuts'
            for (int i = 0; i < target.size(); ++i) {
                String fragment = target.get(i).fragment;
                if (DBG) Log.d(TAG, ""fragment "" + i + "": "" + fragment);
                if (shortcutsFragment.equals(fragment)) {
                    target.remove(i);
                    break;
                }
            }
        }
    }

}
",False,119,0,0,6,47,0,3,L10
