,file_path,source_code,is_vulnerable, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,com.android.quicksearchbox.CorpusResult.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * A sequence of suggestions from a single corpus.
 */
public interface CorpusResult extends SuggestionCursor {

    /**
     * Gets the corpus that produced these suggestions.
     */
    Corpus getCorpus();

    /**
     * The user query that returned these suggestions.
     */
    String getUserQuery();

    /**
     * Gets the latency of the suggestion query that produced this result.
     *
     * @return The latency in milliseconds.
     */
    int getLatency();
}
",False,47,4,16,3,3,17,2,L2
1,com.android.quicksearchbox.ShouldQueryStrategy.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.util.Log;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * Decides whether a given source should be queried for a given query, taking
 * into account the source's query threshold and query after zero results flag.
 *
 * This class is thread safe.
 */
class ShouldQueryStrategy {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.ShouldQueryStrategy"";

    // The last query we've seen
    private String mLastQuery = """";

    // The current implementation keeps a record of those corpora that have
    // returned zero results for some prefix of the current query. mEmptyCorpora
    // maps from corpus to the length of the query which returned
    // zero results.  When a query is shortened (e.g., by deleting characters)
    // or changed entirely, mEmptyCorpora is pruned (in updateQuery)
    private final HashMap<Corpus, Integer> mEmptyCorpora
            = new HashMap<Corpus, Integer>();

    /**
     * Returns whether we should query the given source for the given query.
     */
    public boolean shouldQueryCorpus(Corpus corpus, String query) {
        updateQuery(query);
        if (query.length() >= corpus.getQueryThreshold()) {
            if (!corpus.queryAfterZeroResults() && mEmptyCorpora.containsKey(corpus)) {
                if (DBG) Log.i(TAG, ""Not querying "" + corpus + "", returned 0 after ""
                        + mEmptyCorpora.get(corpus));
                return false;
            }
            return true;
        }
        return false;
    }

    /**
     * Called to notify ShouldQueryStrategy when a source reports no results for a query.
     */
    public void onZeroResults(Corpus corpus, String query) {
        // Make sure this result is actually for a prefix of the current query.
        if (mLastQuery.startsWith(query) && !corpus.queryAfterZeroResults()) {
            if (DBG) Log.d(TAG, corpus + "" returned 0 results for "" + query);
            mEmptyCorpora.put(corpus, query.length());
        }
    }

    private void updateQuery(String query) {
        if (query.startsWith(mLastQuery)) {
            // This is a refinement of the last query, no changes to mEmptyCorpora needed
        } else if (mLastQuery.startsWith(query)) {
            // This is a widening of the last query: clear out any sources
            // that reported zero results after this query.
            Iterator<Map.Entry<Corpus, Integer>> iter = mEmptyCorpora.entrySet().iterator();
            while (iter.hasNext()) {
                if (iter.next().getValue() > query.length()) {
                    iter.remove();
                }
            }
        } else {
            // This is a completely different query, clear everything.
            mEmptyCorpora.clear();
        }
        mLastQuery = query;
    }
}
",False,25,6,5,3,4,2,1,L3
2,com.android.quicksearchbox.QueryTask.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.Consumer;
import com.android.quicksearchbox.util.NamedTask;
import com.android.quicksearchbox.util.NamedTaskExecutor;

import android.os.Handler;

/**
 * A task that gets suggestions from a corpus.
 */
public class QueryTask<C extends SuggestionCursor> implements NamedTask {
    private final String mQuery;
    private final int mQueryLimit;
    private final SuggestionCursorProvider<C> mProvider;
    private final Handler mHandler;
    private final Consumer<C> mConsumer;

    /**
     * Creates a new query task.
     *
     * @param query Query to run.
     * @param queryLimit The number of suggestions to ask each provider for.
     * @param provider The provider to ask for suggestions.
     * @param handler Handler that {@link Consumer#consume} will
     *        get called on. If null, the method is called on the query thread.
     * @param consumer Consumer to notify when the suggestions have been returned.
     */
    public QueryTask(String query, int queryLimit, SuggestionCursorProvider<C> provider,
            Handler handler, Consumer<C> consumer) {
        mQuery = query;
        mQueryLimit = queryLimit;
        mProvider = provider;
        mHandler = handler;
        mConsumer = consumer;
    }

    public String getName() {
        return mProvider.getName();
    }

    public void run() {
        final C cursor = mProvider.getSuggestions(mQuery, mQueryLimit);
        if (mHandler == null) {
            mConsumer.consume(cursor);
        } else {
            mHandler.post(new Runnable() {
                public void run() {
                    boolean accepted = mConsumer.consume(cursor);
                    if (!accepted) {
                        cursor.close();
                    }
                }
            });
        }
    }

    @Override
    public String toString() {
        return mProvider + ""["" + mQuery + ""]"";
    }

    public static <C extends SuggestionCursor> void startQueries(String query,
            int maxResultsPerProvider,
            Iterable<? extends SuggestionCursorProvider<C>> providers,
            NamedTaskExecutor executor, Handler handler,
            Consumer<C> consumer) {

        for (SuggestionCursorProvider<C> provider : providers) {
            QueryTask<C> task = new QueryTask<C>(query, maxResultsPerProvider, provider, handler,
                    consumer);
            executor.execute(task);
        }
    }

}
",False,26,5,7,3,5,2,5,L4
3,com.android.quicksearchbox.SuggestionsProvider.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import java.util.List;

/**
 * Provides a set of suggestion results for a query..
 *
 */
public interface SuggestionsProvider {
    /**
     * Gets suggestions for a query.
     *
     * @param query The query.
     * @param corpora The corpora to query.
     * @param maxSuggestions The maximum number of suggestions to return.
     */
    Suggestions getSuggestions(String query, List<Corpus> corpora, int maxSuggestions);

    void close();
}
",False,31,5,5,3,8,3,2,L5
4,com.android.quicksearchbox.SourceShortcutRefresher.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.NamedTask;
import com.android.quicksearchbox.util.NamedTaskExecutor;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * Refreshes shortcuts from their source.
 */
class SourceShortcutRefresher implements ShortcutRefresher {

    private final NamedTaskExecutor mExecutor;

    private final Set<String> mRefreshed = Collections.synchronizedSet(new HashSet<String>());

    /**
     * Create a ShortcutRefresher that will refresh shortcuts using the given executor.
     *
     * @param executor Used to execute the tasks.
     */
    public SourceShortcutRefresher(NamedTaskExecutor executor) {
        mExecutor = executor;
    }

    /**
     * Sends off the refresher tasks.
     *
     * @param shortcuts The shortcuts to refresh.
     * @param listener Who to report back to.
     */
    public void refresh(SuggestionCursor shortcuts, final Listener listener) {
        int count = shortcuts.getCount();
        for (int i = 0; i < count; i++) {
            shortcuts.moveTo(i);
            Source source = shortcuts.getSuggestionSource();
            if (source == null) {
                throw new NullPointerException(""source"");
            }
            String shortcutId = shortcuts.getShortcutId();
            if (shouldRefresh(source, shortcutId)) {
                String extraData = shortcuts.getSuggestionIntentExtraData();
                ShortcutRefreshTask refreshTask = new ShortcutRefreshTask(
                        source, shortcutId, extraData, listener);
                mExecutor.execute(refreshTask);
            }
        }
    }

    /**
     * Returns true if the given shortcut requires refreshing.
     */
    public boolean shouldRefresh(Source source, String shortcutId) {
        return source != null && shortcutId != null
                && !mRefreshed.contains(makeKey(source, shortcutId));
    }

    /**
     * Indicate that the shortcut no longer requires refreshing.
     */
    public void markShortcutRefreshed(Source source, String shortcutId) {
        mRefreshed.add(makeKey(source, shortcutId));
    }

    /**
     * Reset internal state.  This results in all shortcuts requiring refreshing.
     */
    public void reset() {
        mRefreshed.clear();
    }

    /**
     * Cancel any pending shortcut refresh requests.
     */
    public void cancelPendingTasks() {
        mExecutor.cancelPendingTasks();
    }

    private static String makeKey(Source source, String shortcutId) {
        return source.getName() + ""#"" + shortcutId;
    }

    /**
     * Refreshes a shortcut with a source and reports the result to a
     * {@link ShortcutRefresher.Listener}.
     */
    private class ShortcutRefreshTask implements NamedTask {
        private final Source mSource;
        private final String mShortcutId;
        private final String mExtraData;
        private final Listener mListener;

        /**
         * @param source The source that should validate the shortcut.
         * @param shortcutId The shortcut to be refreshed.
         * @param listener Who to report back to when the result is in.
         */
        ShortcutRefreshTask(Source source, String shortcutId, String extraData,
                Listener listener) {
            mSource = source;
            mShortcutId = shortcutId;
            mExtraData = extraData;
            mListener = listener;
        }

        public String getName() {
            return mSource.getName();
        }

        public void run() {
            // TODO: Add latency tracking and logging.
            SuggestionCursor refreshed = mSource.refreshShortcut(mShortcutId, mExtraData);
            // Close cursor if empty and pass null as the refreshed cursor
            if (refreshed != null && refreshed.getCount() == 0) {
                refreshed.close();
                refreshed = null;
            }
            markShortcutRefreshed(mSource, mShortcutId);
            mListener.onShortcutRefreshed(mSource, mShortcutId, refreshed);
        }

    }
}
",False,24,5,5,2,6,2,6,L2
5,com.android.quicksearchbox.Corpora.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.database.DataSetObserver;

import java.util.Collection;

/**
 * Maintains the set of available and enabled corpora.
 */
public interface Corpora {

    boolean isCorpusEnabled(Corpus corpus);

    /**
     * Checks if a corpus should be enabled by default.
     */
    boolean isCorpusDefaultEnabled(Corpus corpus);

    /**
     * Gets all corpora, including the web corpus.
     *
     * @return Callers must not modify the returned collection.
     */
    Collection<Corpus> getAllCorpora();

    /**
     * Gets all enabled corpora.
     *
     * @return Callers must not modify the returned collection.
     */
    Collection<Corpus> getEnabledCorpora();

    /**
     * Gets a corpus by name.
     *
     * @return A corpus, or null.
     */
    Corpus getCorpus(String name);

    /**
     * Gets the web search corpus.
     *
     * @return The web search corpus, or {@code null} if there is no web search corpus.
     */
    Corpus getWebCorpus();

    /**
     * Gets a source by name.
     *
     * @param name Source name.
     * @return A source, or {@code null} if no source with the given name exists.
     */
    Source getSource(String name);

    /**
     * Gets the corpus that contains the given source.
     */
    Corpus getCorpusForSource(Source source);

    /**
     * Frees any resources used by the corpus set.
     */
    void close();

    /**
     * Registers an observer that is called when corpus set changes.
     *
     * @param observer gets notified when the data set changes.
     */
    void registerDataSetObserver(DataSetObserver observer);

    /**
     * Unregisters an observer that has previously been registered with
     * {@link #registerDataSetObserver(DataSetObserver)}
     *
     * @param observer the observer to unregister.
     */
    void unregisterDataSetObserver(DataSetObserver observer);
}
",False,32,4,13,2,5,13,2,L3
6,com.android.quicksearchbox.ShortcutRepositoryImplLog.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.SQLiteTransaction;
import com.android.quicksearchbox.util.Util;
import com.google.common.annotations.VisibleForTesting;

import android.app.SearchManager;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;
import android.os.Handler;
import android.text.TextUtils;
import android.util.Log;

import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executor;

/**
 * A shortcut repository implementation that uses a log of every click.
 *
 * To inspect DB:
 * # sqlite3 /data/data/com.android.quicksearchbox/databases/qsb-log.db
 *
 * TODO: Refactor this class.
 */
public class ShortcutRepositoryImplLog implements ShortcutRepository {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.ShortcutRepositoryImplLog"";

    private static final String DB_NAME = ""qsb-log.db"";
    private static final int DB_VERSION = 30;

    private static final String HAS_HISTORY_QUERY =
        ""SELECT "" + Shortcuts.intent_key.fullName + "" FROM "" + Shortcuts.TABLE_NAME;
    private final String mEmptyQueryShortcutQuery ;
    private final String mShortcutQuery;

    private static final String SHORTCUT_BY_ID_WHERE =
            Shortcuts.shortcut_id.name() + ""=? AND "" + Shortcuts.source.name() + ""=?"";

    private static final String SOURCE_RANKING_SQL = buildSourceRankingSql();

    private final Context mContext;
    private final Config mConfig;
    private final Corpora mCorpora;
    private final ShortcutRefresher mRefresher;
    private final Handler mUiThread;
    // Used to perform log write operations asynchronously
    private final Executor mLogExecutor;
    private final DbOpenHelper mOpenHelper;
    private final String mSearchSpinner;

    /**
     * Create an instance to the repo.
     */
    public static ShortcutRepository create(Context context, Config config,
            Corpora sources, ShortcutRefresher refresher, Handler uiThread,
            Executor logExecutor) {
        return new ShortcutRepositoryImplLog(context, config, sources, refresher,
                uiThread, logExecutor, DB_NAME);
    }

    /**
     * @param context Used to create / open db
     * @param name The name of the database to create.
     */
    @VisibleForTesting
    ShortcutRepositoryImplLog(Context context, Config config, Corpora corpora,
            ShortcutRefresher refresher, Handler uiThread, Executor logExecutor, String name) {
        mContext = context;
        mConfig = config;
        mCorpora = corpora;
        mRefresher = refresher;
        mUiThread = uiThread;
        mLogExecutor = logExecutor;
        mOpenHelper = new DbOpenHelper(context, name, DB_VERSION, config);
        mEmptyQueryShortcutQuery = buildShortcutQuery(true);
        mShortcutQuery = buildShortcutQuery(false);
        mSearchSpinner = Util.getResourceUri(mContext, R.drawable.search_spinner).toString();
    }

    private String buildShortcutQuery(boolean emptyQuery) {
        // clicklog first, since that's where restrict the result set
        String tables = ClickLog.TABLE_NAME + "" INNER JOIN "" + Shortcuts.TABLE_NAME
                + "" ON "" + ClickLog.intent_key.fullName + "" = "" + Shortcuts.intent_key.fullName;
        String[] columns = {
            Shortcuts.intent_key.fullName,
            Shortcuts.source.fullName,
            Shortcuts.source_version_code.fullName,
            Shortcuts.format.fullName + "" AS "" + SearchManager.SUGGEST_COLUMN_FORMAT,
            Shortcuts.title + "" AS "" + SearchManager.SUGGEST_COLUMN_TEXT_1,
            Shortcuts.description + "" AS "" + SearchManager.SUGGEST_COLUMN_TEXT_2,
            Shortcuts.description_url + "" AS "" + SearchManager.SUGGEST_COLUMN_TEXT_2_URL,
            Shortcuts.icon1 + "" AS "" + SearchManager.SUGGEST_COLUMN_ICON_1,
            Shortcuts.icon2 + "" AS "" + SearchManager.SUGGEST_COLUMN_ICON_2,
            Shortcuts.intent_action + "" AS "" + SearchManager.SUGGEST_COLUMN_INTENT_ACTION,
            Shortcuts.intent_data + "" AS "" + SearchManager.SUGGEST_COLUMN_INTENT_DATA,
            Shortcuts.intent_query + "" AS "" + SearchManager.SUGGEST_COLUMN_QUERY,
            Shortcuts.intent_extradata + "" AS "" + SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA,
            Shortcuts.shortcut_id + "" AS "" + SearchManager.SUGGEST_COLUMN_SHORTCUT_ID,
            Shortcuts.spinner_while_refreshing + "" AS "" + SearchManager.SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING,
            Shortcuts.log_type + "" AS "" + CursorBackedSuggestionCursor.SUGGEST_COLUMN_LOG_TYPE,
        };
        // SQL expression for the time before which no clicks should be counted.
        String cutOffTime_expr = ""("" + ""?3"" + "" - "" + mConfig.getMaxStatAgeMillis() + "")"";
        // Avoid GLOB by using >= AND <, with some manipulation (see nextString(String)).
        // to figure out the upper bound (e.g. >= ""abc"" AND < ""abd""
        // This allows us to use parameter binding and still take advantage of the
        // index on the query column.
        String prefixRestriction =
                ClickLog.query.fullName + "" >= ?1 AND "" + ClickLog.query.fullName + "" < ?2"";
        // Filter out clicks that are too old
        String ageRestriction = ClickLog.hit_time.fullName + "" >= "" + cutOffTime_expr;
        String where = (emptyQuery ? """" : prefixRestriction + "" AND "") + ageRestriction;
        String groupBy = ClickLog.intent_key.fullName;
        String having = null;
        String hit_count_expr = ""COUNT("" + ClickLog._id.fullName + "")"";
        String last_hit_time_expr = ""MAX("" + ClickLog.hit_time.fullName + "")"";
        String scale_expr =
            // time (msec) from cut-off to last hit time
            ""(("" + last_hit_time_expr + "" - "" + cutOffTime_expr + "") / ""
            // divided by time (sec) from cut-off to now
            // we use msec/sec to get 1000 as max score
            + (mConfig.getMaxStatAgeMillis() / 1000) + "")"";
        String ordering_expr = ""("" + hit_count_expr + "" * "" + scale_expr + "")"";
        String preferLatest = ""("" + last_hit_time_expr + "" = (SELECT "" + last_hit_time_expr +
                "" FROM "" + ClickLog.TABLE_NAME + "" WHERE "" + where + ""))"";
        String orderBy = preferLatest + "" DESC, "" + ordering_expr + "" DESC"";
        return SQLiteQueryBuilder.buildQueryString(
                false, tables, columns, where, groupBy, having, orderBy, null);
    }

    /**
     * @return sql that ranks sources by total clicks, filtering out sources
     *         without enough clicks.
     */
    private static String buildSourceRankingSql() {
        final String orderingExpr = SourceStats.total_clicks.name();
        final String tables = SourceStats.TABLE_NAME;
        final String[] columns = SourceStats.COLUMNS;
        final String where = SourceStats.total_clicks + "" >= $1"";
        final String groupBy = null;
        final String having = null;
        final String orderBy = orderingExpr + "" DESC"";
        final String limit = null;
        return SQLiteQueryBuilder.buildQueryString(
                false, tables, columns, where, groupBy, having, orderBy, limit);
    }

    protected DbOpenHelper getOpenHelper() {
        return mOpenHelper;
    }

    private void runTransactionAsync(final SQLiteTransaction transaction) {
        mLogExecutor.execute(new Runnable() {
            public void run() {
                transaction.run(mOpenHelper.getWritableDatabase());
            }
        });
    }

// --------------------- Interface ShortcutRepository ---------------------

    public boolean hasHistory() {
        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
        Cursor cursor = db.rawQuery(HAS_HISTORY_QUERY, null);
        try {
            if (DBG) Log.d(TAG, ""hasHistory(): cursor="" + cursor);
            return cursor != null && cursor.getCount() > 0;
        } finally {
            if (cursor != null) cursor.close();
        }
    }

    public void clearHistory() {
        runTransactionAsync(new SQLiteTransaction() {
            @Override
            public boolean performTransaction(SQLiteDatabase db) {
                db.delete(ClickLog.TABLE_NAME, null, null);
                db.delete(Shortcuts.TABLE_NAME, null, null);
                db.delete(SourceStats.TABLE_NAME, null, null);
                return true;
            }
        });
    }

    @VisibleForTesting
    public void deleteRepository() {
        getOpenHelper().deleteDatabase();
    }

    public void close() {
        getOpenHelper().close();
    }

    public void reportClick(final SuggestionCursor suggestions, final int position) {
        final long now = System.currentTimeMillis();
        reportClickAtTime(suggestions, position, now);
    }

    public SuggestionCursor getShortcutsForQuery(String query, List<Corpus> allowedCorpora,
            int maxShortcuts) {
        ShortcutCursor shortcuts = getShortcutsForQuery(query, allowedCorpora, maxShortcuts,
                        System.currentTimeMillis());
        if (shortcuts != null) {
            startRefresh(shortcuts);
        }
        return shortcuts;
    }

    public Map<String,Integer> getCorpusScores() {
        return getCorpusScores(mConfig.getMinClicksForSourceRanking());
    }

// -------------------------- end ShortcutRepository --------------------------

    private boolean shouldRefresh(SuggestionCursor suggestion) {
        return mRefresher.shouldRefresh(suggestion.getSuggestionSource(),
                suggestion.getShortcutId());
    }

    /* package for testing */ ShortcutCursor getShortcutsForQuery(String query,
            List<Corpus> allowedCorpora, int maxShortcuts, long now) {
        if (DBG) Log.d(TAG, ""getShortcutsForQuery("" + query + "","" + allowedCorpora + "")"");
        String sql = query.length() == 0 ? mEmptyQueryShortcutQuery : mShortcutQuery;
        String[] params = buildShortcutQueryParams(query, now);

        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
        Cursor cursor = db.rawQuery(sql, params);
        if (cursor.getCount() == 0) {
            cursor.close();
            return null;
        }

        HashMap<String,Source> allowedSources = new HashMap<String,Source>();
        for (Corpus corpus : allowedCorpora) {
            for (Source source : corpus.getSources()) {
                allowedSources.put(source.getName(), source);
            }
        }

        return new ShortcutCursor(maxShortcuts,
                new SuggestionCursorImpl(allowedSources, query, cursor));
    }

    private void startRefresh(final ShortcutCursor shortcuts) {
        mRefresher.refresh(shortcuts, new ShortcutRefresher.Listener() {
            public void onShortcutRefreshed(final Source source,
                    final String shortcutId, final SuggestionCursor refreshed) {
                refreshShortcut(source, shortcutId, refreshed);
                mUiThread.post(new Runnable() {
                    public void run() {
                        shortcuts.refresh(source, shortcutId, refreshed);
                    }
                });
            }
        });
    }

    @VisibleForTesting
    void refreshShortcut(Source source, final String shortcutId,
            SuggestionCursor refreshed) {
        if (source == null) throw new NullPointerException(""source"");
        if (shortcutId == null) throw new NullPointerException(""shortcutId"");

        final String[] whereArgs = { shortcutId, source.getName() };
        final ContentValues shortcut;
        if (refreshed == null || refreshed.getCount() == 0) {
            shortcut = null;
        } else {
            shortcut = makeShortcutRow(refreshed);
        }

        runTransactionAsync(new SQLiteTransaction() {
            @Override
            protected boolean performTransaction(SQLiteDatabase db) {
                if (shortcut == null) {
                    if (DBG) Log.d(TAG, ""Deleting shortcut: "" + shortcutId);
                    db.delete(Shortcuts.TABLE_NAME, SHORTCUT_BY_ID_WHERE, whereArgs);
                } else {
                    if (DBG) Log.d(TAG, ""Updating shortcut: "" + shortcut);
                    db.updateWithOnConflict(Shortcuts.TABLE_NAME, shortcut,
                            SHORTCUT_BY_ID_WHERE, whereArgs, SQLiteDatabase.CONFLICT_REPLACE);
                }
                return true;
            }
        });
    }

    private class SuggestionCursorImpl extends CursorBackedSuggestionCursor {

        private final HashMap<String, Source> mAllowedSources;

        public SuggestionCursorImpl(HashMap<String,Source> allowedSources,
                String userQuery, Cursor cursor) {
            super(userQuery, cursor);
            mAllowedSources = allowedSources;
        }

        @Override
        public Source getSuggestionSource() {
            // TODO: Using ordinal() is hacky, look up the column instead
            String srcStr = mCursor.getString(Shortcuts.source.ordinal());
            if (srcStr == null) {
                throw new NullPointerException(""Missing source for shortcut."");
            }
            Source source = mAllowedSources.get(srcStr);
            if (source == null) {
                if (DBG) Log.d(TAG, ""Source "" + srcStr + "" not allowed"");
                return null;
            }
            int versionCode = mCursor.getInt(Shortcuts.source_version_code.ordinal());
            if (versionCode != source.getVersionCode()) {
                if (DBG) {
                    Log.d(TAG, ""Wrong version ("" + versionCode + "" != "" + source.getVersionCode()
                            + "") for source "" + srcStr);
                }
                return null;
            }
            return source;
        }

        @Override
        public String getSuggestionIcon2() {
            if (isSpinnerWhileRefreshing() && shouldRefresh(this)) {
                return mSearchSpinner;
            }
            return super.getSuggestionIcon2();
        }

        public boolean isSuggestionShortcut() {
            return true;
        }

        @Override
        public String toString() {
            return ""shortcuts["" + getUserQuery() + ""]"";
        }

    }

    /**
     * Builds a parameter list for the query returned by {@link #buildShortcutQuery(boolean)}.
     */
    private static String[] buildShortcutQueryParams(String query, long now) {
        return new String[]{ query, nextString(query), String.valueOf(now) };
    }

    /**
     * Given a string x, this method returns the least string y such that x is not a prefix of y.
     * This is useful to implement prefix filtering by comparison, since the only strings z that
     * have x as a prefix are such that z is greater than or equal to x and z is less than y.
     *
     * @param str A non-empty string. The contract above is not honored for an empty input string,
     *        since all strings have the empty string as a prefix.
     */
    private static String nextString(String str) {
        int len = str.length();
        if (len == 0) {
            return str;
        }
        // The last code point in the string. Within the Basic Multilingual Plane,
        // this is the same as str.charAt(len-1)
        int codePoint = str.codePointBefore(len);
        // This should be safe from overflow, since the largest code point
        // representable in UTF-16 is U+10FFFF.
        int nextCodePoint = codePoint + 1;
        // The index of the start of the last code point.
        // Character.charCount(codePoint) is always 1 (in the BMP) or 2
        int lastIndex = len - Character.charCount(codePoint);
        return new StringBuilder(len)
                .append(str, 0, lastIndex)  // append everything but the last code point
                .appendCodePoint(nextCodePoint)  // instead of the last code point, use successor
                .toString();
    }

    /**
     * Returns the source ranking for sources with a minimum number of clicks.
     *
     * @param minClicks The minimum number of clicks a source must have.
     * @return The list of sources, ranked by total clicks.
     */
    Map<String,Integer> getCorpusScores(int minClicks) {
        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
        final Cursor cursor = db.rawQuery(
                SOURCE_RANKING_SQL, new String[] { String.valueOf(minClicks) });
        try {
            Map<String,Integer> corpora = new HashMap<String,Integer>(cursor.getCount());
            while (cursor.moveToNext()) {
                String name = cursor.getString(SourceStats.corpus.ordinal());
                int clicks = cursor.getInt(SourceStats.total_clicks.ordinal());
                corpora.put(name, clicks);
            }
            return corpora;
        } finally {
            cursor.close();
        }
    }

    private ContentValues makeShortcutRow(SuggestionCursor suggestion) {
        String intentAction = suggestion.getSuggestionIntentAction();
        String intentData = suggestion.getSuggestionIntentDataString();
        String intentQuery = suggestion.getSuggestionQuery();
        String intentExtraData = suggestion.getSuggestionIntentExtraData();

        Source source = suggestion.getSuggestionSource();
        String sourceName = source.getName();
        StringBuilder key = new StringBuilder(sourceName);
        key.append(""#"");
        if (intentData != null) {
            key.append(intentData);
        }
        key.append(""#"");
        if (intentAction != null) {
            key.append(intentAction);
        }
        key.append(""#"");
        if (intentQuery != null) {
            key.append(intentQuery);
        }
        // A string of the form source#intentData#intentAction#intentQuery 
        // for use as a unique identifier of a suggestion.
        String intentKey = key.toString();

        // Get URIs for all icons, to make sure that they are stable
        String icon1Uri = getIconUriString(source, suggestion.getSuggestionIcon1());
        String icon2Uri = getIconUriString(source, suggestion.getSuggestionIcon2());

        ContentValues cv = new ContentValues();
        cv.put(Shortcuts.intent_key.name(), intentKey);
        cv.put(Shortcuts.source.name(), sourceName);
        cv.put(Shortcuts.source_version_code.name(), source.getVersionCode());
        cv.put(Shortcuts.format.name(), suggestion.getSuggestionFormat());
        cv.put(Shortcuts.title.name(), suggestion.getSuggestionText1());
        cv.put(Shortcuts.description.name(), suggestion.getSuggestionText2());
        cv.put(Shortcuts.description_url.name(), suggestion.getSuggestionText2Url());
        cv.put(Shortcuts.icon1.name(), icon1Uri);
        cv.put(Shortcuts.icon2.name(), icon2Uri);
        cv.put(Shortcuts.intent_action.name(), intentAction);
        cv.put(Shortcuts.intent_data.name(), intentData);
        cv.put(Shortcuts.intent_query.name(), intentQuery);
        cv.put(Shortcuts.intent_extradata.name(), intentExtraData);
        cv.put(Shortcuts.shortcut_id.name(), suggestion.getShortcutId());
        if (suggestion.isSpinnerWhileRefreshing()) {
            cv.put(Shortcuts.spinner_while_refreshing.name(), ""true"");
        }
        cv.put(Shortcuts.log_type.name(), suggestion.getSuggestionLogType());

        return cv;
    }

    private String getIconUriString(Source source, String drawableId) {
        // Fast path for empty icons
        if (TextUtils.isEmpty(drawableId) || ""0"".equals(drawableId)) {
            return null;
        }
        // Fast path for icon URIs
        if (drawableId.startsWith(ContentResolver.SCHEME_ANDROID_RESOURCE)
                || drawableId.startsWith(ContentResolver.SCHEME_CONTENT)
                || drawableId.startsWith(ContentResolver.SCHEME_FILE)) {
            return drawableId;
        }
        Uri uri = source.getIconUri(drawableId);
        return uri == null ? null : uri.toString();
    }

    @VisibleForTesting
    void reportClickAtTime(SuggestionCursor suggestion,
            int position, long now) {
        suggestion.moveTo(position);
        if (DBG) {
            Log.d(TAG, ""logClicked("" + suggestion + "")"");
        }

        if (SearchManager.SUGGEST_NEVER_MAKE_SHORTCUT.equals(suggestion.getShortcutId())) {
            if (DBG) Log.d(TAG, ""clicked suggestion requested not to be shortcuted"");
            return;
        }

        Corpus corpus = mCorpora.getCorpusForSource(suggestion.getSuggestionSource());
        if (corpus == null) {
            Log.w(TAG, ""no corpus for clicked suggestion"");
            return;
        }

        // Once the user has clicked on a shortcut, don't bother refreshing
        // (especially if this is a new shortcut)
        mRefresher.markShortcutRefreshed(suggestion.getSuggestionSource(),
                suggestion.getShortcutId());

        // Add or update suggestion info
        // Since intent_key is the primary key, any existing
        // suggestion with the same source+data+action will be replaced
        final ContentValues shortcut = makeShortcutRow(suggestion);
        String intentKey = shortcut.getAsString(Shortcuts.intent_key.name());

        // Log click for shortcut
        final ContentValues click = new ContentValues();
        click.put(ClickLog.intent_key.name(), intentKey);
        click.put(ClickLog.query.name(), suggestion.getUserQuery());
        click.put(ClickLog.hit_time.name(), now);
        click.put(ClickLog.corpus.name(), corpus.getName());

        runTransactionAsync(new SQLiteTransaction() {
            @Override
            protected boolean performTransaction(SQLiteDatabase db) {
                if (DBG) Log.d(TAG, ""Adding shortcut: "" + shortcut);
                db.replaceOrThrow(Shortcuts.TABLE_NAME, null, shortcut);
                db.insertOrThrow(ClickLog.TABLE_NAME, null, click);
                return true;
            }
        });
    }

// -------------------------- TABLES --------------------------

    /**
     * shortcuts table
     */
    enum Shortcuts {
        intent_key,
        source,
        source_version_code,
        format,
        title,
        description,
        description_url,
        icon1,
        icon2,
        intent_action,
        intent_data,
        intent_query,
        intent_extradata,
        shortcut_id,
        spinner_while_refreshing,
        log_type;

        static final String TABLE_NAME = ""shortcuts"";

        public final String fullName;

        Shortcuts() {
            fullName = TABLE_NAME + ""."" + name();
        }
    }

    /**
     * clicklog table. Has one record for each click.
     */
    enum ClickLog {
        _id,
        intent_key,
        query,
        hit_time,
        corpus;

        static final String[] COLUMNS = initColumns();

        static final String TABLE_NAME = ""clicklog"";

        private static String[] initColumns() {
            ClickLog[] vals = ClickLog.values();
            String[] columns = new String[vals.length];
            for (int i = 0; i < vals.length; i++) {
                columns[i] = vals[i].fullName;
            }
            return columns;
        }

        public final String fullName;

        ClickLog() {
            fullName = TABLE_NAME + ""."" + name();
        }
    }

    /**
     * This is an aggregate table of {@link ClickLog} that stays up to date with the total
     * clicks for each corpus. This makes computing the corpus ranking more
     * more efficient, at the expense of some extra work when the clicks are reported.
     */
    enum SourceStats {
        corpus,
        total_clicks;

        static final String TABLE_NAME = ""sourcetotals"";

        static final String[] COLUMNS = initColumns();

        private static String[] initColumns() {
            SourceStats[] vals = SourceStats.values();
            String[] columns = new String[vals.length];
            for (int i = 0; i < vals.length; i++) {
                columns[i] = vals[i].fullName;
            }
            return columns;
        }

        public final String fullName;

        SourceStats() {
            fullName = TABLE_NAME + ""."" + name();
        }
    }

// -------------------------- END TABLES --------------------------

    // contains creation and update logic
    private static class DbOpenHelper extends SQLiteOpenHelper {
        private Config mConfig;
        private String mPath;
        private static final String SHORTCUT_ID_INDEX
                = Shortcuts.TABLE_NAME + ""_"" + Shortcuts.shortcut_id.name();
        private static final String CLICKLOG_QUERY_INDEX
                = ClickLog.TABLE_NAME + ""_"" + ClickLog.query.name();
        private static final String CLICKLOG_HIT_TIME_INDEX
                = ClickLog.TABLE_NAME + ""_"" + ClickLog.hit_time.name();
        private static final String CLICKLOG_INSERT_TRIGGER
                = ClickLog.TABLE_NAME + ""_insert"";
        private static final String SHORTCUTS_DELETE_TRIGGER
                = Shortcuts.TABLE_NAME + ""_delete"";
        private static final String SHORTCUTS_UPDATE_INTENT_KEY_TRIGGER
                = Shortcuts.TABLE_NAME + ""_update_intent_key"";

        public DbOpenHelper(Context context, String name, int version, Config config) {
            super(context, name, null, version);
            mConfig = config;
        }

        public String getPath() {
            return mPath;
        }

        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
            // The shortcuts info is not all that important, so we just drop the tables
            // and re-create empty ones.
            Log.i(TAG, ""Upgrading shortcuts DB from version "" +
                    + oldVersion + "" to "" + newVersion + "". This deletes all shortcuts."");
            dropTables(db);
            onCreate(db);
        }

        private void dropTables(SQLiteDatabase db) {
            db.execSQL(""DROP TRIGGER IF EXISTS "" + CLICKLOG_INSERT_TRIGGER);
            db.execSQL(""DROP TRIGGER IF EXISTS "" + SHORTCUTS_DELETE_TRIGGER);
            db.execSQL(""DROP TRIGGER IF EXISTS "" + SHORTCUTS_UPDATE_INTENT_KEY_TRIGGER);
            db.execSQL(""DROP INDEX IF EXISTS "" + CLICKLOG_HIT_TIME_INDEX);
            db.execSQL(""DROP INDEX IF EXISTS "" + CLICKLOG_QUERY_INDEX);
            db.execSQL(""DROP INDEX IF EXISTS "" + SHORTCUT_ID_INDEX);
            db.execSQL(""DROP TABLE IF EXISTS "" + ClickLog.TABLE_NAME);
            db.execSQL(""DROP TABLE IF EXISTS "" + Shortcuts.TABLE_NAME);
            db.execSQL(""DROP TABLE IF EXISTS "" + SourceStats.TABLE_NAME);
        }

        /**
         * Deletes the database file.
         */
        public void deleteDatabase() {
            close();
            if (mPath == null) return;
            try {
                new File(mPath).delete();
                if (DBG) Log.d(TAG, ""deleted "" + mPath);
            } catch (Exception e) {
                Log.w(TAG, ""couldn't delete "" + mPath, e);
            }
        }

        @Override
        public void onOpen(SQLiteDatabase db) {
            super.onOpen(db);
            mPath = db.getPath();
        }

        @Override
        public void onCreate(SQLiteDatabase db) {
            db.execSQL(""CREATE TABLE "" + Shortcuts.TABLE_NAME + "" ("" +
                    // COLLATE UNICODE is needed to make it possible to use nextString()
                    // to implement fast prefix filtering.
                    Shortcuts.intent_key.name() + "" TEXT NOT NULL COLLATE UNICODE PRIMARY KEY, "" +
                    Shortcuts.source.name() + "" TEXT NOT NULL, "" +
                    Shortcuts.source_version_code.name() + "" INTEGER NOT NULL, "" +
                    Shortcuts.format.name() + "" TEXT, "" +
                    Shortcuts.title.name() + "" TEXT, "" +
                    Shortcuts.description.name() + "" TEXT, "" +
                    Shortcuts.description_url.name() + "" TEXT, "" +
                    Shortcuts.icon1.name() + "" TEXT, "" +
                    Shortcuts.icon2.name() + "" TEXT, "" +
                    Shortcuts.intent_action.name() + "" TEXT, "" +
                    Shortcuts.intent_data.name() + "" TEXT, "" +
                    Shortcuts.intent_query.name() + "" TEXT, "" +
                    Shortcuts.intent_extradata.name() + "" TEXT, "" +
                    Shortcuts.shortcut_id.name() + "" TEXT, "" +
                    Shortcuts.spinner_while_refreshing.name() + "" TEXT, "" +
                    Shortcuts.log_type.name() + "" TEXT"" +
                    "");"");

            // index for fast lookup of shortcuts by shortcut_id
            db.execSQL(""CREATE INDEX "" + SHORTCUT_ID_INDEX
                    + "" ON "" + Shortcuts.TABLE_NAME
                    + ""("" + Shortcuts.shortcut_id.name() + "", "" + Shortcuts.source.name() + "")"");

            db.execSQL(""CREATE TABLE "" + ClickLog.TABLE_NAME + "" ( "" +
                    ClickLog._id.name() + "" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, "" +
                    // type must match Shortcuts.intent_key
                    ClickLog.intent_key.name() + "" TEXT NOT NULL COLLATE UNICODE REFERENCES ""
                        + Shortcuts.TABLE_NAME + ""("" + Shortcuts.intent_key + ""), "" +
                    ClickLog.query.name() + "" TEXT, "" +
                    ClickLog.hit_time.name() + "" INTEGER,"" +
                    ClickLog.corpus.name() + "" TEXT"" +
                    "");"");

            // index for fast lookup of clicks by query
            db.execSQL(""CREATE INDEX "" + CLICKLOG_QUERY_INDEX
                    + "" ON "" + ClickLog.TABLE_NAME + ""("" + ClickLog.query.name() + "")"");

            // index for finding old clicks quickly
            db.execSQL(""CREATE INDEX "" + CLICKLOG_HIT_TIME_INDEX
                    + "" ON "" + ClickLog.TABLE_NAME + ""("" + ClickLog.hit_time.name() + "")"");

            // trigger for purging old clicks, i.e. those such that
            // hit_time < now - MAX_MAX_STAT_AGE_MILLIS, where now is the
            // hit_time of the inserted record, and for updating the SourceStats table
            db.execSQL(""CREATE TRIGGER "" + CLICKLOG_INSERT_TRIGGER + "" AFTER INSERT ON ""
                    + ClickLog.TABLE_NAME
                    + "" BEGIN""
                    + "" DELETE FROM "" + ClickLog.TABLE_NAME + "" WHERE ""
                            + ClickLog.hit_time.name() + "" <""
                            + "" NEW."" + ClickLog.hit_time.name()
                                    + "" - "" + mConfig.getMaxStatAgeMillis() + "";""
                    + "" DELETE FROM "" + SourceStats.TABLE_NAME + "";""
                    + "" INSERT INTO "" + SourceStats.TABLE_NAME  + "" ""
                            + ""SELECT "" + ClickLog.corpus + "","" + ""COUNT(*) FROM ""
                            + ClickLog.TABLE_NAME + "" GROUP BY "" + ClickLog.corpus.name() + "";""
                    + "" END"");

            // trigger for deleting clicks about a shortcut once that shortcut has been
            // deleted
            db.execSQL(""CREATE TRIGGER "" + SHORTCUTS_DELETE_TRIGGER + "" AFTER DELETE ON ""
                    + Shortcuts.TABLE_NAME
                    + "" BEGIN""
                    + "" DELETE FROM "" + ClickLog.TABLE_NAME + "" WHERE ""
                            + ClickLog.intent_key.name()
                            + "" = OLD."" + Shortcuts.intent_key.name() + "";""
                    + "" END"");

            // trigger for updating click log entries when a shortcut changes its intent_key
            db.execSQL(""CREATE TRIGGER "" + SHORTCUTS_UPDATE_INTENT_KEY_TRIGGER
                    + "" AFTER UPDATE ON "" + Shortcuts.TABLE_NAME
                    + "" WHEN NEW."" + Shortcuts.intent_key.name()
                            + "" != OLD."" + Shortcuts.intent_key.name()
                    + "" BEGIN""
                    + "" UPDATE "" + ClickLog.TABLE_NAME + "" SET ""
                            + ClickLog.intent_key.name() + "" = NEW."" + Shortcuts.intent_key.name()
                            + "" WHERE ""
                            + ClickLog.intent_key.name() + "" = OLD."" + Shortcuts.intent_key.name()
                            + "";""
                    + "" END"");

            db.execSQL(""CREATE TABLE "" + SourceStats.TABLE_NAME + "" ( "" +
                    SourceStats.corpus.name() + "" TEXT NOT NULL COLLATE UNICODE PRIMARY KEY, "" +
                    SourceStats.total_clicks + "" INTEGER);""
                    );
        }
    }
}
",True,36,5,5,2,13,2,13,L4
7,com.android.quicksearchbox.QsbApplication.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.ui.CorpusViewFactory;
import com.android.quicksearchbox.ui.CorpusViewInflater;
import com.android.quicksearchbox.ui.DelayingSuggestionsAdapter;
import com.android.quicksearchbox.ui.EmptySuggestionsFooter;
import com.android.quicksearchbox.ui.SuggestionViewFactory;
import com.android.quicksearchbox.ui.SuggestionViewInflater;
import com.android.quicksearchbox.ui.SuggestionsAdapter;
import com.android.quicksearchbox.ui.SuggestionsFooter;
import com.android.quicksearchbox.util.Factory;
import com.android.quicksearchbox.util.NamedTaskExecutor;
import com.android.quicksearchbox.util.PerNameExecutor;
import com.android.quicksearchbox.util.PriorityThreadFactory;
import com.android.quicksearchbox.util.SingleThreadNamedTaskExecutor;
import com.google.common.util.concurrent.NamingThreadFactory;

import android.app.Application;
import android.os.Handler;
import android.os.Looper;
import android.os.Process;

import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;

public class QsbApplication extends Application {

    private Handler mUiThreadHandler;
    private Config mConfig;
    private Corpora mCorpora;
    private CorpusRanker mCorpusRanker;
    private ShortcutRepository mShortcutRepository;
    private ShortcutRefresher mShortcutRefresher;
    private NamedTaskExecutor mSourceTaskExecutor;
    private ThreadFactory mQueryThreadFactory;
    private SuggestionsProvider mSuggestionsProvider;
    private SuggestionViewFactory mSuggestionViewFactory;
    private CorpusViewFactory mCorpusViewFactory;
    private Logger mLogger;

    @Override
    public void onTerminate() {
        close();
        super.onTerminate();
    }

    protected void checkThread() {
        if (Looper.myLooper() != Looper.getMainLooper()) {
            throw new IllegalStateException(""Accessed Application object from thread ""
                    + Thread.currentThread().getName());
        }
    }

    protected void close() {
        checkThread();
        if (mConfig != null) {
            mConfig.close();
            mConfig = null;
        }
        if (mCorpora != null) {
            mCorpora.close();
            mCorpora = null;
        }
        if (mShortcutRepository != null) {
            mShortcutRepository.close();
            mShortcutRepository = null;
        }
        if (mSourceTaskExecutor != null) {
            mSourceTaskExecutor.close();
            mSourceTaskExecutor = null;
        }
        if (mSuggestionsProvider != null) {
            mSuggestionsProvider.close();
            mSuggestionsProvider = null;
        }
    }

    public synchronized Handler getMainThreadHandler() {
        if (mUiThreadHandler == null) {
            mUiThreadHandler = new Handler(Looper.getMainLooper());
        }
        return mUiThreadHandler;
    }

    /**
     * Gets the QSB configuration object.
     * May be called from any thread.
     */
    public synchronized Config getConfig() {
        if (mConfig == null) {
            mConfig = createConfig();
        }
        return mConfig;
    }

    protected Config createConfig() {
        return new Config(this);
    }

    /**
     * Gets the corpora.
     * May only be called from the main thread.
     */
    public Corpora getCorpora() {
        checkThread();
        if (mCorpora == null) {
            mCorpora = createCorpora();
        }
        return mCorpora;
    }

    protected Corpora createCorpora() {
        SearchableCorpora corpora = new SearchableCorpora(this, getConfig(), createSources(),
                createCorpusFactory());
        corpora.load();
        return corpora;
    }

    protected Sources createSources() {
        return new SearchableSources(this, getMainThreadHandler());
    }

    protected CorpusFactory createCorpusFactory() {
        int numWebCorpusThreads = getConfig().getNumWebCorpusThreads();
        return new SearchableCorpusFactory(this, createExecutorFactory(numWebCorpusThreads));
    }

    protected Factory<Executor> createExecutorFactory(final int numThreads) {
        final ThreadFactory threadFactory = getQueryThreadFactory();
        return new Factory<Executor>() {
            public Executor create() {
                return Executors.newFixedThreadPool(numThreads, threadFactory);
            }
        };
    }

    /**
     * Gets the corpus ranker.
     * May only be called from the main thread.
     */
    public CorpusRanker getCorpusRanker() {
        checkThread();
        if (mCorpusRanker == null) {
            mCorpusRanker = createCorpusRanker();
        }
        return mCorpusRanker;
    }

    protected CorpusRanker createCorpusRanker() {
        return new DefaultCorpusRanker(getCorpora(), getShortcutRepository());
    }

    /**
     * Gets the shortcut repository.
     * May only be called from the main thread.
     */
    public ShortcutRepository getShortcutRepository() {
        checkThread();
        if (mShortcutRepository == null) {
            mShortcutRepository = createShortcutRepository();
        }
        return mShortcutRepository;
    }

    protected ShortcutRepository createShortcutRepository() {
        ThreadFactory logThreadFactory = new NamingThreadFactory(""ShortcutRepositoryWriter #%d"",
                new PriorityThreadFactory(Process.THREAD_PRIORITY_BACKGROUND));
        Executor logExecutor = Executors.newSingleThreadExecutor(logThreadFactory);
        return ShortcutRepositoryImplLog.create(this, getConfig(), getCorpora(),
            getShortcutRefresher(), getMainThreadHandler(), logExecutor);
    }

    /**
     * Gets the shortcut refresher.
     * May only be called from the main thread.
     */
    public ShortcutRefresher getShortcutRefresher() {
        checkThread();
        if (mShortcutRefresher == null) {
            mShortcutRefresher = createShortcutRefresher();
        }
        return mShortcutRefresher;
    }

    protected ShortcutRefresher createShortcutRefresher() {
        // For now, ShortcutRefresher gets its own SourceTaskExecutor
        return new SourceShortcutRefresher(createSourceTaskExecutor());
    }

    /**
     * Gets the source task executor.
     * May only be called from the main thread.
     */
    public NamedTaskExecutor getSourceTaskExecutor() {
        checkThread();
        if (mSourceTaskExecutor == null) {
            mSourceTaskExecutor = createSourceTaskExecutor();
        }
        return mSourceTaskExecutor;
    }

    protected NamedTaskExecutor createSourceTaskExecutor() {
        Config config = getConfig();
        ThreadFactory queryThreadFactory = getQueryThreadFactory();
        return new PerNameExecutor(SingleThreadNamedTaskExecutor.factory(queryThreadFactory));
    }

    /**
     * Gets the query thread factory.
     * May only be called from the main thread.
     */
    protected ThreadFactory getQueryThreadFactory() {
        checkThread();
        if (mQueryThreadFactory == null) {
            mQueryThreadFactory = createQueryThreadFactory();
        }
        return mQueryThreadFactory;
    }

    protected ThreadFactory createQueryThreadFactory() {
        String nameFormat = ""QSB #%d"";
        int priority = getConfig().getQueryThreadPriority();
        return new NamingThreadFactory(nameFormat,
                new PriorityThreadFactory(priority));
    }

    /**
     * Gets the suggestion provider.
     * May only be called from the main thread.
     */
    protected SuggestionsProvider getSuggestionsProvider() {
        checkThread();
        if (mSuggestionsProvider == null) {
            mSuggestionsProvider = createSuggestionsProvider();
        }
        return mSuggestionsProvider;
    }

    protected SuggestionsProvider createSuggestionsProvider() {
        Promoter promoter =  new ShortcutPromoter(
                new RankAwarePromoter(getConfig(), getCorpora()));
        SuggestionsProvider provider = new SuggestionsProviderImpl(getConfig(),
                getSourceTaskExecutor(),
                getMainThreadHandler(),
                promoter,
                getShortcutRepository(),
                getCorpora(),
                getLogger());
        return provider;
    }

    /**
     * Gets the suggestion view factory.
     * May only be called from the main thread.
     */
    public SuggestionViewFactory getSuggestionViewFactory() {
        checkThread();
        if (mSuggestionViewFactory == null) {
            mSuggestionViewFactory = createSuggestionViewFactory();
        }
        return mSuggestionViewFactory;
    }

    protected SuggestionViewFactory createSuggestionViewFactory() {
        return new SuggestionViewInflater(this);
    }

    /**
     * Gets the corpus view factory.
     * May only be called from the main thread.
     */
    public CorpusViewFactory getCorpusViewFactory() {
        checkThread();
        if (mCorpusViewFactory == null) {
            mCorpusViewFactory = createCorpusViewFactory();
        }
        return mCorpusViewFactory;
    }

    protected CorpusViewFactory createCorpusViewFactory() {
        return new CorpusViewInflater(this);
    }

    /**
     * Creates a suggestions adapter.
     * May only be called from the main thread.
     */
    public SuggestionsAdapter createSuggestionsAdapter() {
        Config config = getConfig();
        SuggestionViewFactory viewFactory = getSuggestionViewFactory();
        DelayingSuggestionsAdapter adapter = new DelayingSuggestionsAdapter(viewFactory);
        return adapter;
    }

    /**
     * Creates a footer view to add at the bottom of the search activity.
     */
    public SuggestionsFooter createSuggestionsFooter() {
        return new EmptySuggestionsFooter(this);
    }

    /**
     * Gets the event logger.
     * May only be called from the main thread.
     */
    public Logger getLogger() {
        checkThread();
        if (mLogger == null) {
            mLogger = createLogger();
        }
        return mLogger;
    }

    protected Logger createLogger() {
        return new EventLogLogger(this, getConfig());
    }
}
",False,78,2,4,4,33,5,33,L5
8,com.android.quicksearchbox.SearchableSources.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.app.SearchManager;
import android.app.SearchableInfo;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.database.DataSetObservable;
import android.database.DataSetObserver;
import android.os.Handler;
import android.util.Log;

import java.util.Collection;
import java.util.HashMap;
import java.util.List;

/**
 * Maintains a list of search sources.
 */
public class SearchableSources implements Sources {

    // set to true to enable the more verbose debug logging for this file
    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SearchableSources"";

    // The number of milliseconds that source update requests are delayed to
    // allow grouping multiple requests.
    private static final long UPDATE_SOURCES_DELAY_MILLIS = 200;

    private final DataSetObservable mDataSetObservable = new DataSetObservable();

    private final Context mContext;
    private final SearchManager mSearchManager;
    private boolean mLoaded;

    // All suggestion sources, by name.
    private HashMap<String, Source> mSources;

    // The web search source to use.
    private Source mWebSearchSource;

    private final Handler mUiThread;

    private Runnable mUpdateSources = new Runnable() {
        public void run() {
            mUiThread.removeCallbacks(this);
            updateSources();
            notifyDataSetChanged();
        }
    };

    /**
     *
     * @param context Used for looking up source information etc.
     */
    public SearchableSources(Context context, Handler uiThread) {
        mContext = context;
        mUiThread = uiThread;
        mSearchManager = (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
        mLoaded = false;
    }

    public Collection<Source> getSources() {
        if (!mLoaded) {
            throw new IllegalStateException(""getSources(): sources not loaded."");
        }
        return mSources.values();
    }

    public Source getSource(String name) {
        return mSources.get(name);
    }

    public Source getWebSearchSource() {
        if (!mLoaded) {
            throw new IllegalStateException(""getWebSearchSource(): sources not loaded."");
        }
        return mWebSearchSource;
    }

    // Broadcast receiver for package change notifications
    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)
                    || SearchManager.INTENT_ACTION_SEARCH_SETTINGS_CHANGED.equals(action)) {
                if (DBG) Log.d(TAG, ""onReceive("" + intent + "")"");
                // TODO: Instead of rebuilding the whole list on every change,
                // just add, remove or update the application that has changed.
                // Adding and updating seem tricky, since I can't see an easy way to list the
                // launchable activities in a given package.
                mUiThread.postDelayed(mUpdateSources, UPDATE_SOURCES_DELAY_MILLIS);
            }
        }
    };

    public void load() {
        if (mLoaded) {
            throw new IllegalStateException(""load(): Already loaded."");
        }

        // Listen for searchables changes.
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED);
        intentFilter.addAction(SearchManager.INTENT_ACTION_SEARCH_SETTINGS_CHANGED);
        mContext.registerReceiver(mBroadcastReceiver, intentFilter);

        // update list of sources
        updateSources();

        mLoaded = true;

        notifyDataSetChanged();
    }

    public void close() {
        mContext.unregisterReceiver(mBroadcastReceiver);

        mDataSetObservable.unregisterAll();

        mSources = null;
        mLoaded = false;
    }

    /**
     * Loads the list of suggestion sources.
     */
    private void updateSources() {
        if (DBG) Log.d(TAG, ""updateSources()"");
        mSources = new HashMap<String,Source>();

        addSearchableSources();

        mWebSearchSource = createWebSearchSource();
        addSource(mWebSearchSource);
    }

    private void addSearchableSources() {
        List<SearchableInfo> searchables = mSearchManager.getSearchablesInGlobalSearch();
        if (searchables == null) {
            Log.e(TAG, ""getSearchablesInGlobalSearch() returned null"");
            return;
        }
        for (SearchableInfo searchable : searchables) {
            SearchableSource source = createSearchableSource(searchable);
            if (source != null && source.canRead()) {
                if (DBG) Log.d(TAG, ""Created source "" + source);
                addSource(source);
            }
        }
    }

    private void addSource(Source source) {
        mSources.put(source.getName(), source);
    }

    private Source createWebSearchSource() {
        ComponentName name = getWebSearchComponent();
        SearchableInfo webSearchable = mSearchManager.getSearchableInfo(name);
        if (webSearchable == null) {
            Log.e(TAG, ""Web search source "" + name + "" is not searchable."");
            return null;
        }
        return createSearchableSource(webSearchable);
    }

    private ComponentName getWebSearchComponent() {
        // Looks for an activity in the current package that handles ACTION_WEB_SEARCH.
        // This indirect method is used to allow easy replacement of the web
        // search activity when extending this package.
        Intent webSearchIntent = new Intent(Intent.ACTION_WEB_SEARCH);
        webSearchIntent.setPackage(mContext.getPackageName());
        PackageManager pm = mContext.getPackageManager();
        return webSearchIntent.resolveActivity(pm);
    }

    private SearchableSource createSearchableSource(SearchableInfo searchable) {
        if (searchable == null) return null;
        try {
            return new SearchableSource(mContext, searchable);
        } catch (NameNotFoundException ex) {
            Log.e(TAG, ""Source not found: "" + ex);
            return null;
        }
    }

    public void registerDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.registerObserver(observer);
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.unregisterObserver(observer);
    }

    protected void notifyDataSetChanged() {
        mDataSetObservable.notifyChanged();
    }
}
",True,73,0,0,8,31,1,4,L5
9,com.android.quicksearchbox.ShortcutRepository.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import java.util.List;
import java.util.Map;

/**
 * Holds information about shortcuts (results the user has clicked on before), and returns
 * appropriate shortcuts for a given query.
 */
public interface ShortcutRepository {

    /**
     * Checks whether there is any stored history.
     */
    boolean hasHistory();

    /**
     * Clears all shortcut history.
     */
    void clearHistory();

    /**
     * Closes any database connections etc held by this object.
     */
    void close();

    /**
     * Reports a click on a suggestion.
     * Must be called on the UI thread.
     */
    void reportClick(SuggestionCursor suggestions, int position);

    /**
     * Gets shortcuts for a query.
     *
     * @param query The query. May be empty.
     * @param allowedCorpora The corpora to get shortcuts for.
     * @param maxShortcuts The maximum number of shortcuts to return.
     * @return A cursor containing shortcutted results for the query.
     */
    SuggestionCursor getShortcutsForQuery(String query, List<Corpus> allowedCorpora,
            int maxShortcuts);

    /**
     * @return A map for corpus name to score. A higher score means that the corpus
     *         is more important.
     */
    Map<String,Integer> getCorpusScores();
}
",False,29,4,9,3,4,7,2,L3
10,com.android.quicksearchbox.SearchSettings.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.SearchManager;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.database.ContentObserver;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.Preference;
import android.preference.PreferenceActivity;
import android.preference.PreferenceGroup;
import android.preference.PreferenceScreen;
import android.preference.Preference.OnPreferenceChangeListener;
import android.preference.Preference.OnPreferenceClickListener;
import android.provider.Settings;
import android.provider.Settings.System;
import android.util.Log;
import android.view.Menu;

import java.util.List;

/**
 * Activity for setting global search preferences. Changes to search preferences trigger a broadcast
 * intent that causes all SuggestionSources objects to be updated.
 */
public class SearchSettings extends PreferenceActivity
        implements OnPreferenceClickListener, OnPreferenceChangeListener {

    private static final boolean DBG = false;
    private static final String TAG = ""SearchSettings"";

    // Name of the preferences file used to store search preference
    public static final String PREFERENCES_NAME = ""SearchSettings"";

    // Only used to find the preferences after inflating
    private static final String CLEAR_SHORTCUTS_PREF = ""clear_shortcuts"";
    private static final String SEARCH_ENGINE_SETTINGS_PREF = ""search_engine_settings"";
    private static final String SEARCH_CORPORA_PREF = ""search_corpora"";

    // Preifx of per-corpus enable preference
    private static final String CORPUS_ENABLED_PREF_PREFIX = ""enable_corpus_"";

    // References to the top-level preference objects
    private Preference mClearShortcutsPreference;
    private PreferenceScreen mSearchEngineSettingsPreference;
    private PreferenceGroup mSourcePreferences;

    // Dialog ids
    private static final int CLEAR_SHORTCUTS_CONFIRM_DIALOG = 0;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        getPreferenceManager().setSharedPreferencesName(PREFERENCES_NAME);

        addPreferencesFromResource(R.xml.preferences);

        PreferenceScreen preferenceScreen = getPreferenceScreen();
        mClearShortcutsPreference = preferenceScreen.findPreference(CLEAR_SHORTCUTS_PREF);
        mSearchEngineSettingsPreference = (PreferenceScreen) preferenceScreen.findPreference(
                SEARCH_ENGINE_SETTINGS_PREF);
        mSourcePreferences = (PreferenceGroup) getPreferenceScreen().findPreference(
                SEARCH_CORPORA_PREF);

        mClearShortcutsPreference.setOnPreferenceClickListener(this);

        updateClearShortcutsPreference();
        populateSourcePreference();
        populateSearchEnginePreference();
    }

    /**
     * Gets the preference key of the preference for whether the given corpus
     * is enabled. The preference is stored in the {@link #PREFERENCES_NAME}
     * preferences file.
     */
    public static String getCorpusEnabledPreference(Corpus corpus) {
        return CORPUS_ENABLED_PREF_PREFIX + corpus.getName();
    }

    public static SharedPreferences getSearchPreferences(Context context) {
        return context.getSharedPreferences(PREFERENCES_NAME, Context.MODE_PRIVATE);
    }

    private QsbApplication getQsbApplication() {
        return (QsbApplication) getApplication();
    }

    private Corpora getCorpora() {
        return getQsbApplication().getCorpora();
    }

    private ShortcutRepository getShortcuts() {
        return getQsbApplication().getShortcutRepository();
    }

    /**
     * Enables/disables the ""Clear search shortcuts"" preference depending
     * on whether there is any search history.
     */
    private void updateClearShortcutsPreference() {
        boolean hasHistory = getShortcuts().hasHistory();
        if (DBG) Log.d(TAG, ""hasHistory()="" + hasHistory);
        mClearShortcutsPreference.setEnabled(hasHistory);
    }

    /**
     * Populates the preference item for the web search engine, which links to further
     * search settings.
     */
    private void populateSearchEnginePreference() {
        Intent intent = new Intent(SearchManager.INTENT_ACTION_WEB_SEARCH_SETTINGS);
        intent.setPackage(getPackageName());

        CharSequence webSearchSettingsLabel = getActivityLabel(intent);
        mSearchEngineSettingsPreference.setTitle(webSearchSettingsLabel);
        mSearchEngineSettingsPreference.setIntent(intent);
    }

    private CharSequence getActivityLabel(Intent intent) {
        PackageManager pm = getPackageManager();
        List<ResolveInfo> resolveInfos = pm.queryIntentActivities(intent, 0);
        if (resolveInfos.size() == 0) {
            Log.e(TAG, ""No web search settings activity"");
            return null;
        }
        if (resolveInfos.size() > 1) {
            Log.e(TAG, ""More than one web search settings activity"");
            return null;
        }
        return resolveInfos.get(0).activityInfo.loadLabel(pm);
    }

    /**
     * Fills the suggestion source list.
     */
    private void populateSourcePreference() {
        mSourcePreferences.setOrderingAsAdded(false);
        for (Corpus corpus : getCorpora().getAllCorpora()) {
            Preference pref = createCorpusPreference(corpus);
            if (pref != null) {
                if (DBG) Log.d(TAG, ""Adding corpus: "" + corpus);
                mSourcePreferences.addPreference(pref);
            }
        }
    }

    /**
     * Adds a suggestion source to the list of suggestion source checkbox preferences.
     */
    private Preference createCorpusPreference(Corpus corpus) {
        CheckBoxPreference sourcePref = new CheckBoxPreference(this);
        sourcePref.setKey(getCorpusEnabledPreference(corpus));
        // Put web corpus first. The rest are alphabetical.
        if (corpus.isWebCorpus()) {
            sourcePref.setOrder(0);
        }
        sourcePref.setDefaultValue(getCorpora().isCorpusDefaultEnabled(corpus));
        sourcePref.setOnPreferenceChangeListener(this);
        CharSequence label = corpus.getLabel();
        sourcePref.setTitle(label);
        CharSequence description = corpus.getSettingsDescription();
        sourcePref.setSummaryOn(description);
        sourcePref.setSummaryOff(description);
        return sourcePref;
    }

    /**
     * Handles clicks on the ""Clear search shortcuts"" preference.
     */
    public synchronized boolean onPreferenceClick(Preference preference) {
        if (preference == mClearShortcutsPreference) {
            showDialog(CLEAR_SHORTCUTS_CONFIRM_DIALOG);
            return true;
        }
        return false;
    }

    @Override
    protected Dialog onCreateDialog(int id, Bundle args) {
        switch (id) {
            case CLEAR_SHORTCUTS_CONFIRM_DIALOG:
                return new AlertDialog.Builder(this)
                        .setTitle(R.string.clear_shortcuts)
                        .setMessage(R.string.clear_shortcuts_prompt)
                        .setPositiveButton(R.string.agree, new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int whichButton) {
                                if (DBG) Log.d(TAG, ""Clearing history..."");
                                getShortcuts().clearHistory();
                                mClearShortcutsPreference.setEnabled(false);
                            }
                        })
                        .setNegativeButton(R.string.disagree, null).create();
            default:
                Log.e(TAG, ""unknown dialog"" + id);
                return null;
        }
    }

    /**
     * Informs our listeners about the updated settings data.
     */
    private void broadcastSettingsChanged() {
        // We use a message broadcast since the listeners could be in multiple processes.
        Intent intent = new Intent(SearchManager.INTENT_ACTION_SEARCH_SETTINGS_CHANGED);
        Log.i(TAG, ""Broadcasting: "" + intent);
        sendBroadcast(intent);
    }

    public synchronized boolean onPreferenceChange(Preference preference, Object newValue) {
        broadcastSettingsChanged();
        return true;
    }

    public static boolean getShowWebSuggestions(Context context) {
        return (Settings.System.getInt(context.getContentResolver(),
                Settings.System.SHOW_WEB_SUGGESTIONS,
                1 /* default on until user actually changes it */) == 1);
    }

    public static void setShowWebSuggestions(Context context, boolean showWebSuggestions) {
        System.putInt(context.getContentResolver(), System.SHOW_WEB_SUGGESTIONS,
            showWebSuggestions ? 1 : 0);
    }

    public static void registerShowWebSuggestionsSettingObserver(
            Context context, ContentObserver observer) {
        context.getContentResolver().registerContentObserver(
                Settings.System.getUriFor(Settings.System.SHOW_WEB_SUGGESTIONS),
                false, observer);
    }

    public static void unregisterShowWebSuggestionsSettingObserver(
            Context context, ContentObserver observer) {
        context.getContentResolver().unregisterContentObserver(observer);
    }

    public static void addSearchSettingsMenuItem(Context context, Menu menu) {
        Intent settings = new Intent(SearchManager.INTENT_ACTION_SEARCH_SETTINGS);
        settings.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        // Don't show activity chooser if there are multiple search settings activities,
        // e.g. from different QSB implementations.
        settings.setPackage(context.getPackageName());
        menu.add(Menu.NONE, Menu.NONE, 0, R.string.menu_settings)
                .setIcon(android.R.drawable.ic_menu_preferences).setAlphabeticShortcut('P')
                .setIntent(settings);
    }
}
",True,79,3,3,5,35,5,5,L5
11,com.android.quicksearchbox.PackageIconLoader.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.Util;

import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.text.TextUtils;
import android.util.Log;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;

/**
 * Loads icons from other packages.
 *
 * Code partly stolen from {@link ContentResolver} and android.app.SuggestionsAdapter.
  */
public class PackageIconLoader implements IconLoader {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.PackageIconLoader"";

    private final Context mContext;

    private final String mPackageName;

    private Context mPackageContext;

    /**
     * Creates a new icon loader.
     *
     * @param context The QSB application context.
     * @param packageName The name of the package from which the icons will be loaded.
     *        Resource IDs without an explicit package will be resolved against the package
     *        of this context.
     */
    public PackageIconLoader(Context context, String packageName) {
        mContext = context;
        mPackageName = packageName;
    }

    private boolean ensurePackageContext() {
        if (mPackageContext == null) {
            try {
                mPackageContext = mContext.createPackageContext(mPackageName,
                        Context.CONTEXT_RESTRICTED);
            } catch (PackageManager.NameNotFoundException ex) {
                // This should only happen if the app has just be uninstalled
                Log.e(TAG, ""Application not found "" + mPackageName);
                return false;
            }
        }
        return true;
    }

    public Drawable getIcon(String drawableId) {
        if (DBG) Log.d(TAG, ""getIcon("" + drawableId + "")"");
        if (TextUtils.isEmpty(drawableId) || ""0"".equals(drawableId)) {
            return null;
        }
        if (!ensurePackageContext()) return null;
        try {
            // First, see if it's just an integer
            int resourceId = Integer.parseInt(drawableId);
            // If so, find it by resource ID
            return mPackageContext.getResources().getDrawable(resourceId);
        } catch (NumberFormatException nfe) {
            // It's not an integer, use it as a URI
            Uri uri = Uri.parse(drawableId);
            return getDrawable(uri);
        } catch (Resources.NotFoundException nfe) {
            // It was an integer, but it couldn't be found, bail out
            Log.w(TAG, ""Icon resource not found: "" + drawableId);
            return null;
        }
    }

    public Uri getIconUri(String drawableId) {
        if (TextUtils.isEmpty(drawableId) || ""0"".equals(drawableId)) {
            return null;
        }
        if (!ensurePackageContext()) return null;
        try {
            int resourceId = Integer.parseInt(drawableId);
            return Util.getResourceUri(mPackageContext, resourceId);
        } catch (NumberFormatException nfe) {
            return Uri.parse(drawableId);
        }
    }

    /**
     * Gets a drawable by URI.
     *
     * @return A drawable, or {@code null} if the drawable could not be loaded.
     */
    private Drawable getDrawable(Uri uri) {
        try {
            String scheme = uri.getScheme();
            if (ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme)) {
                // Load drawables through Resources, to get the source density information
                OpenResourceIdResult r = getResourceId(uri);
                try {
                    return r.r.getDrawable(r.id);
                } catch (Resources.NotFoundException ex) {
                    throw new FileNotFoundException(""Resource does not exist: "" + uri);
                }
            } else {
                // Let the ContentResolver handle content and file URIs.
                InputStream stream = mPackageContext.getContentResolver().openInputStream(uri);
                if (stream == null) {
                    throw new FileNotFoundException(""Failed to open "" + uri);
                }
                try {
                    return Drawable.createFromStream(stream, null);
                } finally {
                    try {
                        stream.close();
                    } catch (IOException ex) {
                        Log.e(TAG, ""Error closing icon stream for "" + uri, ex);
                    }
                }
            }
        } catch (FileNotFoundException fnfe) {
            Log.w(TAG, ""Icon not found: "" + uri + "", "" + fnfe.getMessage());
            return null;
        }
    }

    /**
     * A resource identified by the {@link Resources} that contains it, and a resource id.
     */
    private class OpenResourceIdResult {
        public Resources r;
        public int id;
    }

    /**
     * Resolves an android.resource URI to a {@link Resources} and a resource id.
     */
    private OpenResourceIdResult getResourceId(Uri uri) throws FileNotFoundException {
        String authority = uri.getAuthority();
        Resources r;
        if (TextUtils.isEmpty(authority)) {
            throw new FileNotFoundException(""No authority: "" + uri);
        } else {
            try {
                r = mPackageContext.getPackageManager().getResourcesForApplication(authority);
            } catch (NameNotFoundException ex) {
                throw new FileNotFoundException(""Failed to get resources: "" + ex);
            }
        }
        List<String> path = uri.getPathSegments();
        if (path == null) {
            throw new FileNotFoundException(""No path: "" + uri);
        }
        int len = path.size();
        int id;
        if (len == 1) {
            try {
                id = Integer.parseInt(path.get(0));
            } catch (NumberFormatException e) {
                throw new FileNotFoundException(""Single path segment is not a resource ID: "" + uri);
            }
        } else if (len == 2) {
            id = r.getIdentifier(path.get(1), path.get(0), authority);
        } else {
            throw new FileNotFoundException(""More than two path segments: "" + uri);
        }
        if (id == 0) {
            throw new FileNotFoundException(""No resource found for: "" + uri);
        }
        OpenResourceIdResult res = new OpenResourceIdResult();
        res.r = r;
        res.id = id;
        return res;
    }
}
",True,19,6,5,1,2,2,2,L1
12,com.android.quicksearchbox.SearchableCorpusFactory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.Factory;

import android.content.Context;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.concurrent.Executor;

/**
 * Creates corpora.
 */
public class SearchableCorpusFactory implements CorpusFactory {

    private final Context mContext;

    private final Factory<Executor> mWebCorpusExecutorFactory;

    public SearchableCorpusFactory(Context context, Factory<Executor> webCorpusExecutorFactory) {
        mContext = context;
        mWebCorpusExecutorFactory = webCorpusExecutorFactory;
    }

    public Collection<Corpus> createCorpora(Sources sources) {
        ArrayList<Corpus> corpora = new ArrayList<Corpus>();
        addSpecialCorpora(corpora, sources);
        addSingleSourceCorpora(corpora, sources);
        return corpora;
    }

    protected Context getContext() {
        return mContext;
    }

    protected Executor createWebCorpusExecutor() {
        return mWebCorpusExecutorFactory.create();
    }

    /**
     * Adds any corpora that are not simple single source corpora.
     *
     * @param corpora List to add corpora to.
     * @param sources All available sources.
     */
    protected void addSpecialCorpora(ArrayList<Corpus> corpora, Sources sources) {
        corpora.add(createWebCorpus(sources));
        corpora.add(createAppsCorpus(sources));
    }

    /**
     * Adds corpora for all sources that are not already used by a corpus.
     *
     * @param corpora List to add the new corpora to. Corpora will not be created for the sources
     *        used by corpora already in this list.
     * @param sources Sources to create corpora for.
     */
    protected void addSingleSourceCorpora(ArrayList<Corpus> corpora, Sources sources) {
        // Set of all sources that are already used
        HashSet<Source> claimedSources = new HashSet<Source>();
        for (Corpus specialCorpus : corpora) {
            claimedSources.addAll(specialCorpus.getSources());
        }

        // Creates corpora for all unclaimed sources
        for (Source source : sources.getSources()) {
            if (!claimedSources.contains(source)) {
                corpora.add(createSingleSourceCorpus(source));
            }
        }
    }

    protected Corpus createWebCorpus(Sources sources) {
        Source webSource = sources.getWebSearchSource();
        Source browserSource = getBrowserSource(sources);
        Executor executor = createWebCorpusExecutor();
        return new WebCorpus(mContext, executor, webSource, browserSource);
    }

    protected Corpus createAppsCorpus(Sources sources) {
        Source appsSource = getAppsSource(sources);
        return new AppsCorpus(mContext, appsSource);
    }

    protected Corpus createSingleSourceCorpus(Source source) {
        return new SingleSourceCorpus(mContext, source);
    }

    protected Source getBrowserSource(Sources sources) {
        String name = getContext().getString(R.string.browser_search_component);
        return sources.getSource(name);
    }

    protected Source getAppsSource(Sources sources) {
        String name = getContext().getString(R.string.installed_apps_component);
        return sources.getSource(name);
    }

}
",False,73,0,0,6,29,1,8,L5
13,com.android.quicksearchbox.SearchWidgetConfigActivity.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.ui.CorporaAdapter;
import com.android.quicksearchbox.ui.CorpusViewFactory;

import android.appwidget.AppWidgetManager;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ListAdapter;

/**
 * The configuration screen for search widgets.
 */
public class SearchWidgetConfigActivity extends ChoiceActivity {
    static final String TAG = ""QSB.SearchWidgetConfigActivity"";

    private static final String PREFS_NAME = ""SearchWidgetConfig"";
    private static final String WIDGET_CORPUS_PREF_PREFIX = ""widget_corpus_"";

    private CorporaAdapter mAdapter;

    private int mAppWidgetId;

    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);

        setHeading(R.string.search_widget);
        setOnItemClickListener(new SourceClickListener());

        Intent intent = getIntent();
        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,
                AppWidgetManager.INVALID_APPWIDGET_ID);
        if (mAppWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
            finish();
        }
    }

    @Override
    protected void onStart() {
        setAdapter(CorporaAdapter.createListAdapter(getViewFactory(), getCorpusRanker()));
        super.onStart();
    }

    @Override
    protected void onStop() {
        setAdapter(null);
        super.onStop();
    }

    @Override
    public void setAdapter(ListAdapter adapter) {
        if (adapter == mAdapter) return;
        if (mAdapter != null) mAdapter.close();
        mAdapter = (CorporaAdapter) adapter;
        super.setAdapter(adapter);
    }

    protected void selectCorpus(Corpus corpus) {
        writeWidgetCorpusPref(mAppWidgetId, corpus);
        updateWidget(corpus);

        Intent result = new Intent();
        result.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);
        setResult(RESULT_OK, result);
        finish();
    }

    private void updateWidget(Corpus corpus) {
        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(this);
        SearchWidgetProvider.setupSearchWidget(this, appWidgetManager,
                mAppWidgetId, corpus);
    }

    private static SharedPreferences getWidgetPreferences(Context context) {
        return context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE);
    }

    private static String getCorpusPrefKey(int appWidgetId) {
        return WIDGET_CORPUS_PREF_PREFIX + appWidgetId;
    }

    private void writeWidgetCorpusPref(int appWidgetId, Corpus corpus) {
        String corpusName = corpus == null ? null : corpus.getName();
        SharedPreferences.Editor prefs = getWidgetPreferences(this).edit();
        prefs.putString(getCorpusPrefKey(appWidgetId), corpusName);
        prefs.commit();
    }

    public static String readWidgetCorpusPref(Context context, int appWidgetId) {
        SharedPreferences prefs = getWidgetPreferences(context);
        return prefs.getString(getCorpusPrefKey(appWidgetId), null);
    }

    private QsbApplication getQsbApplication() {
        return (QsbApplication) getApplication();
    }

    private CorpusRanker getCorpusRanker() {
        return getQsbApplication().getCorpusRanker();
    }

    private CorpusViewFactory getViewFactory() {
        return getQsbApplication().getCorpusViewFactory();
    }

    private class SourceClickListener implements AdapterView.OnItemClickListener {
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            Corpus corpus = (Corpus) parent.getItemAtPosition(position);
            selectCorpus(corpus);
        }
    }
}
",True,84,0,0,5,39,1,8,L7
14,com.android.quicksearchbox.SearchableCorpora.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Context;
import android.content.SharedPreferences;
import android.database.DataSetObservable;
import android.database.DataSetObserver;
import android.util.Log;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

/**
 * Maintains the list of all suggestion sources.
 */
public class SearchableCorpora implements Corpora {

    // set to true to enable the more verbose debug logging for this file
    private static final boolean DBG = false;
    private static final String TAG = ""QSB.DefaultCorpora"";

    private final DataSetObservable mDataSetObservable = new DataSetObservable();

    private final Context mContext;
    private final Config mConfig;
    private final CorpusFactory mCorpusFactory;
    private final SharedPreferences mPreferences;

    private boolean mLoaded = false;

    private Sources mSources;
    // Maps corpus names to corpora
    private HashMap<String,Corpus> mCorporaByName;
    // Maps sources to the corpus that contains them
    private HashMap<Source,Corpus> mCorporaBySource;
    // Enabled corpora
    private List<Corpus> mEnabledCorpora;
    // Web corpus
    private Corpus mWebCorpus;

    /**
     *
     * @param context Used for looking up source information etc.
     */
    public SearchableCorpora(Context context, Config config, Sources sources,
            CorpusFactory corpusFactory) {
        mContext = context;
        mConfig = config;
        mCorpusFactory = corpusFactory;
        mPreferences = SearchSettings.getSearchPreferences(context);
        mSources = sources;
    }

    protected Context getContext() {
        return mContext;
    }

    private void checkLoaded() {
        if (!mLoaded) {
            throw new IllegalStateException(""corpora not loaded."");
        }
    }

    public Collection<Corpus> getAllCorpora() {
        checkLoaded();
        return Collections.unmodifiableCollection(mCorporaByName.values());
    }

    public Collection<Corpus> getEnabledCorpora() {
        checkLoaded();
        return mEnabledCorpora;
    }

    public Corpus getCorpus(String name) {
        checkLoaded();
        return mCorporaByName.get(name);
    }

    public Corpus getWebCorpus() {
        return mWebCorpus;
    }

    public Corpus getCorpusForSource(Source source) {
        checkLoaded();
        return mCorporaBySource.get(source);
    }

    public Source getSource(String name) {
        checkLoaded();
        return mSources.getSource(name);
    }

    /**
     * After calling, clients must call {@link #close()} when done with this object.
     */
    public void load() {
        if (mLoaded) {
            throw new IllegalStateException(""load(): Already loaded."");
        }

        mSources.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updateCorpora();
            }
        });

        // will cause a callback to updateCorpora()
        mSources.load();
        mLoaded = true;
    }

    /**
     * Releases all resources used by this object. It is possible to call
     * {@link #load()} again after calling this method.
     */
    public void close() {
        checkLoaded();

        mSources.close();
        mSources = null;
        mLoaded = false;
    }

    private void updateCorpora() {
        Collection<Corpus> corpora = mCorpusFactory.createCorpora(mSources);

        mCorporaByName = new HashMap<String,Corpus>(corpora.size());
        mCorporaBySource = new HashMap<Source,Corpus>(corpora.size());
        mEnabledCorpora = new ArrayList<Corpus>(corpora.size());
        mWebCorpus = null;

        for (Corpus corpus : corpora) {
            mCorporaByName.put(corpus.getName(), corpus);
            for (Source source : corpus.getSources()) {
                mCorporaBySource.put(source, corpus);
            }
            if (isCorpusEnabled(corpus)) {
                mEnabledCorpora.add(corpus);
            }
            if (corpus.isWebCorpus()) {
                if (mWebCorpus != null) {
                    Log.w(TAG, ""Multiple web corpora: "" + mWebCorpus + "", "" + corpus);
                }
                mWebCorpus = corpus;
            }
        }

        if (DBG) Log.d(TAG, ""Updated corpora: "" + mCorporaBySource.values());

        mEnabledCorpora = Collections.unmodifiableList(mEnabledCorpora);

        notifyDataSetChanged();
    }

    public boolean isCorpusEnabled(Corpus corpus) {
        if (corpus == null) return false;
        boolean defaultEnabled = isCorpusDefaultEnabled(corpus);
        String sourceEnabledPref = SearchSettings.getCorpusEnabledPreference(corpus);
        return mPreferences.getBoolean(sourceEnabledPref, defaultEnabled);
    }

    public boolean isCorpusDefaultEnabled(Corpus corpus) {
        String name = corpus.getName();
        return mConfig.isCorpusEnabledByDefault(name);
    }

    public void registerDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.registerObserver(observer);
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.unregisterObserver(observer);
    }

    protected void notifyDataSetChanged() {
        mDataSetObservable.notifyChanged();
    }
}
",False,74,1,1,6,27,2,8,L5
15,com.android.quicksearchbox.CursorBackedSuggestionCursor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.app.SearchManager;
import android.database.Cursor;
import android.database.DataSetObserver;
import android.net.Uri;
import android.util.Log;

public abstract class CursorBackedSuggestionCursor extends AbstractSuggestionCursor {

    private static final boolean DBG = false;
    protected static final String TAG = ""QSB.CursorBackedSuggestionCursor"";

    public static final String SUGGEST_COLUMN_LOG_TYPE = ""suggest_log_type"";

    /** The suggestions, or {@code null} if the suggestions query failed. */
    protected final Cursor mCursor;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_FORMAT} in @{link mCursor}. */
    private final int mFormatCol;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_TEXT_1} in @{link mCursor}. */
    private final int mText1Col;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_TEXT_2} in @{link mCursor}. */
    private final int mText2Col;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_TEXT_2_URL} in @{link mCursor}. */
    private final int mText2UrlCol;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_ICON_1} in @{link mCursor}. */
    private final int mIcon1Col;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_ICON_1} in @{link mCursor}. */
    private final int mIcon2Col;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING}
     * in @{link mCursor}.
     **/
    private final int mRefreshSpinnerCol;

    /** True if this result has been closed. */
    private boolean mClosed = false;

    public CursorBackedSuggestionCursor(String userQuery, Cursor cursor) {
        super(userQuery);
        mCursor = cursor;
        mFormatCol = getColumnIndex(SearchManager.SUGGEST_COLUMN_FORMAT);
        mText1Col = getColumnIndex(SearchManager.SUGGEST_COLUMN_TEXT_1);
        mText2Col = getColumnIndex(SearchManager.SUGGEST_COLUMN_TEXT_2);
        mText2UrlCol = getColumnIndex(SearchManager.SUGGEST_COLUMN_TEXT_2_URL);
        mIcon1Col = getColumnIndex(SearchManager.SUGGEST_COLUMN_ICON_1);
        mIcon2Col = getColumnIndex(SearchManager.SUGGEST_COLUMN_ICON_2);
        mRefreshSpinnerCol = getColumnIndex(SearchManager.SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING);
    }

    public abstract Source getSuggestionSource();

    public String getSuggestionLogType() {
        return getStringOrNull(SUGGEST_COLUMN_LOG_TYPE);
    }

    public void close() {
        if (DBG) Log.d(TAG, ""close()"");
        if (mClosed) {
            throw new IllegalStateException(""Double close()"");
        }
        mClosed = true;
        if (mCursor != null) {
            try {
                mCursor.close();
            } catch (RuntimeException ex) {
                // all operations on cross-process cursors can throw random exceptions
                Log.e(TAG, ""close() failed, "", ex);
            }
        }
    }

    @Override
    protected void finalize() {
        if (!mClosed) {
            Log.e(TAG, ""LEAK! Finalized without being closed: "" + toString());
        }
    }

    public int getCount() {
        if (mClosed) {
            throw new IllegalStateException(""getCount() after close()"");
        }
        if (mCursor == null) return 0;
        try {
            return mCursor.getCount();
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getCount() failed, "", ex);
            return 0;
        }
    }

    public void moveTo(int pos) {
        if (mClosed) {
            throw new IllegalStateException(""moveTo("" + pos + "") after close()"");
        }
        try {
            if (!mCursor.moveToPosition(pos)) {
                Log.e(TAG, ""moveToPosition("" + pos + "") failed, count="" + getCount());
            }
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""moveToPosition() failed, "", ex);
        }
    }

    public boolean moveToNext() {
        if (mClosed) {
            throw new IllegalStateException(""moveToNext() after close()"");
        }
        try {
            return mCursor.moveToNext();
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""moveToNext() failed, "", ex);
            return false;
        }
    }

    public int getPosition() {
        if (mClosed) {
            throw new IllegalStateException(""getPosition after close()"");
        }
        try {
            return mCursor.getPosition();
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getPosition() failed, "", ex);
            return -1;
        }
    }

    public String getShortcutId() {
        return getStringOrNull(SearchManager.SUGGEST_COLUMN_SHORTCUT_ID);
    }

    public String getSuggestionFormat() {
        return getStringOrNull(mFormatCol);
    }

    public String getSuggestionText1() {
        return getStringOrNull(mText1Col);
    }

    public String getSuggestionText2() {
        return getStringOrNull(mText2Col);
    }

    public String getSuggestionText2Url() {
        return getStringOrNull(mText2UrlCol);
    }

    public String getSuggestionIcon1() {
        return getStringOrNull(mIcon1Col);
    }

    public String getSuggestionIcon2() {
        return getStringOrNull(mIcon2Col);
    }

    public boolean isSpinnerWhileRefreshing() {
        return ""true"".equals(getStringOrNull(mRefreshSpinnerCol));
    }

    /**
     * Gets the intent action for the current suggestion.
     */
    public String getSuggestionIntentAction() {
        return getStringOrNull(SearchManager.SUGGEST_COLUMN_INTENT_ACTION);
    }

    /**
     * Gets the query for the current suggestion.
     */
    public String getSuggestionQuery() {
        return getStringOrNull(SearchManager.SUGGEST_COLUMN_QUERY);
    }

    public String getSuggestionIntentDataString() {
         // use specific data if supplied, or default data if supplied
         String data = getStringOrNull(SearchManager.SUGGEST_COLUMN_INTENT_DATA);
         if (data == null) {
             data = getSuggestionSource().getDefaultIntentData();
         }
         // then, if an ID was provided, append it.
         if (data != null) {
             String id = getStringOrNull(SearchManager.SUGGEST_COLUMN_INTENT_DATA_ID);
             if (id != null) {
                 data = data + ""/"" + Uri.encode(id);
             }
         }
         return data;
     }

    /**
     * Gets the intent extra data for the current suggestion.
     */
    public String getSuggestionIntentExtraData() {
        return getStringOrNull(SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA);
    }

    /**
     * Gets the index of a column in {@link #mCursor} by name.
     *
     * @return The index, or {@code -1} if the column was not found.
     */
    protected int getColumnIndex(String colName) {
        if (mCursor == null) return -1;
        try {
            return mCursor.getColumnIndex(colName);
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getColumnIndex() failed, "", ex);
            return -1;
        }
    }

    /**
     * Gets the string value of a column in {@link #mCursor} by column index.
     *
     * @param col Column index.
     * @return The string value, or {@code null}.
     */
    protected String getStringOrNull(int col) {
        if (mCursor == null) return null;
        if (col == -1) {
            return null;
        }
        try {
            return mCursor.getString(col);
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getString() failed, "", ex);
            return null;
        }
    }

    /**
     * Gets the string value of a column in {@link #mCursor} by column name.
     *
     * @param colName Column name.
     * @return The string value, or {@code null}.
     */
    protected String getStringOrNull(String colName) {
        int col = getColumnIndex(colName);
        return getStringOrNull(col);
    }

    private String makeKeyComponent(String str) {
        return str == null ? """" : str;
    }

    public String getSuggestionKey() {
        String action = makeKeyComponent(getSuggestionIntentAction());
        String data = makeKeyComponent(normalizeUrl(getSuggestionIntentDataString()));
        String query = makeKeyComponent(normalizeUrl(getSuggestionQuery()));
        // calculating accurate size of string builder avoids an allocation vs starting with
        // the default size and having to expand.
        int size = action.length() + 2 + data.length() + query.length();
        return new StringBuilder(size)
                .append(action)
                .append('#')
                .append(data)
                .append('#')
                .append(query)
                .toString();
    }

    /** Simple url normalization that strips http:// and empty paths, i.e.,
     *  http://www.google.com/ -> www.google.com.  Used to prevent obvious
     * duplication of nav suggestions, bookmarks and urls entered by the user.
     */
    private static String normalizeUrl(String url) {
        if (url != null && url.startsWith(""http://"")) {
            int start = 7;   // length of http://
            int end = url.length();
            if (url.indexOf('/', start) == end - 1) {
                end--;
            }
            return url.substring(start, end);
        }
        return url;
    }

    public void registerDataSetObserver(DataSetObserver observer) {
        // We don't watch Cursor-backed SuggestionCursors for changes
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
        // We don't watch Cursor-backed SuggestionCursors for changes
    }

}
",True,24,5,6,2,3,3,2,L4
16,com.android.quicksearchbox.AbstractSuggestionCursor.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * Base class for suggestion cursors.
 */
public abstract class AbstractSuggestionCursor implements SuggestionCursor {

    private final String mUserQuery;

    public AbstractSuggestionCursor(String userQuery) {
        mUserQuery = userQuery;
    }

    public String getUserQuery() {
        return mUserQuery;
    }

    public String getSuggestionDisplayQuery() {
        String query = getSuggestionQuery();
        if (query != null) {
            return query;
        }
        Source source = getSuggestionSource();
        if (source.shouldRewriteQueryFromData()) {
            String data = getSuggestionIntentDataString();
            if (data != null) {
                return data;
            }
        }
        if (source.shouldRewriteQueryFromText()) {
            String text1 = getSuggestionText1();
            if (text1 != null) {
                return text1;
            }
        }
        return null;
    }

}
",False,55,4,22,2,2,9,2,L1
17,com.android.quicksearchbox.AbstractCorpus.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * Base class for corpus implementations.
 */
public abstract class AbstractCorpus implements Corpus {

    public AbstractCorpus() {
    }

    @Override
    public String toString() {
        return getName();
    }

    @Override
    public boolean equals(Object o) {
        if (o != null && getClass().equals(o.getClass())) {
            return getName().equals(((Corpus) o).getName());
        } else {
            return false;
        }
    }

    @Override
    public int hashCode() {
        return getName().hashCode();
    }

}
",True,33,5,10,3,4,3,2,L3
18,com.android.quicksearchbox.SearchWidgetProvider.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.common.Search;
import com.android.quicksearchbox.ui.CorpusViewFactory;

import android.app.PendingIntent;
import android.app.SearchManager;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.RemoteViews;

/**
 * Search widget provider.
 *
 */
public class SearchWidgetProvider extends AppWidgetProvider {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SearchWidgetProvider"";

    private static final String WIDGET_SEARCH_SOURCE = ""launcher-widget"";

    @Override
    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
        final int count = appWidgetIds.length;
        for (int i = 0; i < count; i++) {
            updateSearchWidget(context, appWidgetManager, appWidgetIds[i]);
        }
    }

    private void updateSearchWidget(Context context, AppWidgetManager appWidgetManager,
            int appWidgetId) {
        String corpusName = SearchWidgetConfigActivity.readWidgetCorpusPref(context, appWidgetId);
        Corpus corpus = corpusName == null ? null : getCorpora(context).getCorpus(corpusName);
        setupSearchWidget(context, appWidgetManager, appWidgetId, corpus);
    }

    public static void setupSearchWidget(Context context, AppWidgetManager appWidgetManager,
            int appWidgetId, Corpus corpus) {
        if (DBG) Log.d(TAG, ""setupSearchWidget()"");
        RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.search_widget);

        Bundle widgetAppData = new Bundle();
        widgetAppData.putString(Search.SOURCE, WIDGET_SEARCH_SOURCE);

        // Corpus indicator
        bindCorpusIndicator(context, views, widgetAppData, corpus);

        // Hint
        CharSequence hint;
        int backgroundId;
        if (corpus == null || corpus.isWebCorpus()) {
            hint = null;
            backgroundId = R.drawable.textfield_search_empty_google;
        } else {
            hint = corpus.getHint();
            backgroundId = R.drawable.textfield_search_empty;
        }
        views.setCharSequence(R.id.search_widget_text, ""setHint"", hint);
        views.setInt(R.id.search_widget_text, ""setBackgroundResource"", backgroundId);

        // Text field click
        Intent qsbIntent = new Intent(SearchManager.INTENT_ACTION_GLOBAL_SEARCH);
        qsbIntent.setPackage(context.getPackageName());
        qsbIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                | Intent.FLAG_ACTIVITY_CLEAR_TOP
                | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
        qsbIntent.putExtra(SearchManager.APP_DATA, widgetAppData);
        qsbIntent.setData(SearchActivity.getCorpusUri(corpus));
        setOnClickIntent(context, views, R.id.search_widget_text, qsbIntent);

        Intent voiceSearchIntent = getVoiceSearchIntent(context, corpus, widgetAppData);
        if (voiceSearchIntent != null) {
            setOnClickIntent(context, views, R.id.search_widget_voice_btn, voiceSearchIntent);
            views.setViewVisibility(R.id.search_widget_voice_btn, View.VISIBLE);
        } else {
            views.setViewVisibility(R.id.search_widget_voice_btn, View.GONE);
        }

        appWidgetManager.updateAppWidget(appWidgetId, views);
    }

    private static void bindCorpusIndicator(Context context, RemoteViews views,
            Bundle widgetAppData, Corpus corpus) {
        Uri sourceIconUri = getCorpusIconUri(context, corpus);
        views.setImageViewUri(R.id.corpus_indicator, sourceIconUri);

        Intent intent = new Intent(SearchActivity.INTENT_ACTION_QSB_AND_SELECT_CORPUS);
        intent.setPackage(context.getPackageName());
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                | Intent.FLAG_ACTIVITY_CLEAR_TOP
                | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
        intent.putExtra(SearchManager.APP_DATA, widgetAppData);
        intent.setData(SearchActivity.getCorpusUri(corpus));
        setOnClickIntent(context, views, R.id.corpus_indicator, intent);
    }

    private static Intent getVoiceSearchIntent(Context context, Corpus corpus,
            Bundle widgetAppData) {
        Launcher launcher = new Launcher(context);
        if (!launcher.shouldShowVoiceSearch(corpus)) return null;
        if (corpus == null) {
            return WebCorpus.createVoiceWebSearchIntent(widgetAppData);
        } else {
            return corpus.createVoiceSearchIntent(widgetAppData);
        }
    }

    private static void setOnClickIntent(Context context, RemoteViews views,
            int viewId, Intent intent) {
        PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);
        views.setOnClickPendingIntent(viewId, pendingIntent);
    }

    private static Uri getCorpusIconUri(Context context, Corpus corpus) {
        if (corpus == null) {
            return getCorpusViewFactory(context).getGlobalSearchIconUri();
        }
        return corpus.getCorpusIconUri();
    }

    private static QsbApplication getQsbApplication(Context context) {
        return (QsbApplication) context.getApplicationContext();
    }

    private static Corpora getCorpora(Context context) {
        return getQsbApplication(context).getCorpora();
    }

    private static CorpusViewFactory getCorpusViewFactory(Context context) {
        return getQsbApplication(context).getCorpusViewFactory();
    }

}
",False,84,0,0,5,52,1,8,L7
19,com.android.quicksearchbox.SuggestionPosition.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * A pointer to a suggestion in a {@link SuggestionCursor}.
 *
 */
public class SuggestionPosition {

    private final SuggestionCursor mCursor;

    private final int mPosition;

    public SuggestionPosition(SuggestionCursor cursor) {
        this(cursor, cursor.getPosition());
    }

    public SuggestionPosition(SuggestionCursor cursor, int suggestionPos) {
        mCursor = cursor;
        mPosition = suggestionPos;
    }

    /**
     * Gets the suggestion cursor, moved to point to the right suggestion.
     */
    protected SuggestionCursor current() {
        mCursor.moveTo(mPosition);
        return mCursor;
    }

    public int getPosition() {
        return mPosition;
    }

    @Override
    public String toString() {
        return mCursor + "":"" + mPosition;
    }

}
",False,45,5,14,3,2,14,1,L2
20,com.android.quicksearchbox.Sources.java,"
package com.android.quicksearchbox;

import android.database.DataSetObserver;

import java.util.Collection;

/**
 * Search source set.
 */
public interface Sources {

    /**
     * Gets all sources.
     */
    Collection<Source> getSources();

    /**
     * Gets a source by name.
     *
     * @return A source, or {@code null} if no source with the given name exists.
     */
    Source getSource(String name);

    /**
     * Gets the web search source.
     */
    Source getWebSearchSource();

    /**
     * After calling, clients must call {@link #close()} when done with this object.
     */
    void load();

    /**
     * Releases all resources used by this object. It is possible to call
     * {@link #load()} again after calling this method.
     */
    void close();

    /**
     * Register an observer that is called when changes happen to this data set.
     *
     * @param observer gets notified when the data set changes.
     */
    void registerDataSetObserver(DataSetObserver observer);

    /**
     * Unregister an observer that has previously been registered with
     * {@link #registerDataSetObserver(DataSetObserver)}
     *
     * @param observer the observer to unregister.
     */
    void unregisterDataSetObserver(DataSetObserver observer);

}
",False,23,5,7,2,3,7,1,L5
21,com.android.quicksearchbox.Launcher.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import android.app.SearchManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.net.Uri;
import android.os.Bundle;
import android.speech.RecognizerIntent;
import android.util.Log;

/**
 * Launches suggestions and searches.
 *
 */
public class Launcher {

    private static final String TAG = ""Launcher"";

    private final Context mContext;

    /**
     * Data sent by the app that launched QSB.
     */
    public Launcher(Context context) {
        mContext = context;
    }

    /**
     * Gets the corpus to use for any searches. This is the web corpus in ""All"" mode,
     * and the selected corpus otherwise.
     */
    public Corpus getSearchCorpus(Corpora corpora, Corpus selectedCorpus) {
        if (selectedCorpus != null) {
            return selectedCorpus;
        } else {
            Corpus webCorpus = corpora.getWebCorpus();
            if (webCorpus == null) {
                Log.e(TAG, ""No web corpus"");
            }
            return webCorpus;
        }
    }

    public boolean shouldShowVoiceSearch(Corpus corpus) {
        if (corpus != null && !corpus.voiceSearchEnabled()) {
            return false;
        }
        return isVoiceSearchAvailable();
    }

    private boolean isVoiceSearchAvailable() {
        Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
        ResolveInfo ri = mContext.getPackageManager().
                resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
        return ri != null;
    }

    public Intent getSuggestionIntent(SuggestionCursor cursor, int position,
            Bundle appSearchData) {
        cursor.moveTo(position);
        Source source = cursor.getSuggestionSource();
        String action = cursor.getSuggestionIntentAction();
        // use specific action if supplied, or default action if supplied, or fixed default
        if (action == null) {
            action = source.getDefaultIntentAction();
            if (action == null) {
                action = Intent.ACTION_SEARCH;
            }
        }

        String data = cursor.getSuggestionIntentDataString();
        String query = cursor.getSuggestionQuery();
        String userQuery = cursor.getUserQuery();
        String extraData = cursor.getSuggestionIntentExtraData();

        // Now build the Intent
        Intent intent = new Intent(action);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        // We need CLEAR_TOP to avoid reusing an old task that has other activities
        // on top of the one we want.
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
        if (data != null) {
            intent.setData(Uri.parse(data));
        }
        intent.putExtra(SearchManager.USER_QUERY, userQuery);
        if (query != null) {
            intent.putExtra(SearchManager.QUERY, query);
        }
        if (extraData != null) {
            intent.putExtra(SearchManager.EXTRA_DATA_KEY, extraData);
        }
        if (appSearchData != null) {
            intent.putExtra(SearchManager.APP_DATA, appSearchData);
        }

        intent.setComponent(cursor.getSuggestionSource().getComponentName());
        return intent;
    }

    public void launchIntent(Intent intent) {
        if (intent == null) {
            return;
        }
        try {
            mContext.startActivity(intent);
        } catch (RuntimeException ex) {
            // Since the intents for suggestions specified by suggestion providers,
            // guard against them not being handled, not allowed, etc.
            Log.e(TAG, ""Failed to start "" + intent.toUri(0), ex);
        }
    }

}
",True,14,2,3,2,4,2,4,L6
22,com.android.quicksearchbox.Logger.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import java.util.Collection;
import java.util.List;


/**
 * Interface for logging implementations.
 */
public interface Logger {

    public static final int SEARCH_METHOD_BUTTON = 0;
    public static final int SEARCH_METHOD_KEYBOARD = 1;

    /**
     * Called when QSB has started.
     *
     * @param latency User-visible start-up latency in milliseconds.
     */
    void logStart(int latency, String intentSource, Corpus corpus,
            List<Corpus> orderedCorpora);

    /**
     * Called when a suggestion is clicked.
     *
     * @param position 0-based position of the suggestion in the UI.
     * @param suggestionCursor all the suggestions shown in the UI.
     * @param queriedCorpora all corpora that were queried to produce the suggestions in
     *        {@code suggestionCursor}, ordered by rank.
     */
    void logSuggestionClick(int position, SuggestionCursor suggestionCursor,
            Collection<Corpus> queriedCorpora);

    /**
     * The user launched a search.
     *
     * @param startMethod One of {@link #SEARCH_METHOD_BUTTON} or {@link #SEARCH_METHOD_KEYBOARD}.
     * @param numChars The number of characters in the query.
     */
    void logSearch(Corpus corpus, int startMethod, int numChars);

    /**
     * The user launched a voice search.
     */
    void logVoiceSearch(Corpus corpus);

    /**
     * The user left QSB without performing any action (click suggestions, search or voice search).
     *
     * @param suggestionCursor all the suggestions shown in the UI when the user left
     * @param numChars The number of characters in the query typed when the user left.
     */
    void logExit(SuggestionCursor suggestionCursor, int numChars);

    /**
     * Logs the latency of a suggestion query to a specific source.
     *
     * @param result The result of the query.
     */
    void logLatency(CorpusResult result);

}
",False,25,5,5,3,3,4,3,L5
23,com.android.quicksearchbox.ShortcutCursor.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.util.Log;

import java.util.HashSet;

/**
 * A SuggestionCursor that allows shortcuts to be updated by overlaying
 * with results from another cursor.
 */
class ShortcutCursor extends ListSuggestionCursor {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.ShortcutCursor"";

    // mShortcuts is used to close the underlying cursor when we're closed.
    private final CursorBackedSuggestionCursor mShortcuts;
    // mRefreshed contains all the cursors that have been refreshed, so that
    // they can be closed when ShortcutCursor is closed.
    private final HashSet<SuggestionCursor> mRefreshed;

    private boolean mClosed;

    public ShortcutCursor(int maxShortcuts, CursorBackedSuggestionCursor shortcuts) {
        super(shortcuts.getUserQuery());
        mShortcuts = shortcuts;
        mRefreshed = new HashSet<SuggestionCursor>();
        int count = shortcuts.getCount();
        for (int i = 0; i < count; i++) {
            if (getCount() >= maxShortcuts) break;
            shortcuts.moveTo(i);
            if (shortcuts.getSuggestionSource() != null) {
                add(new SuggestionPosition(shortcuts));
            } else {
                if (DBG) Log.d(TAG, ""Skipping shortcut "" + i);
            }
        }
    }

    /**
     * Updates this SuggestionCursor with a refreshed result from another.
     * Since this modifies the cursor, it should be called on the UI thread.
     * This class assumes responsibility for closing refreshed.
     */
    public void refresh(Source source, String shortcutId, SuggestionCursor refreshed) {
        if (DBG) Log.d(TAG, ""refresh "" + shortcutId);
        if (mClosed) {
            if (refreshed != null) {
                refreshed.close();
            }
            return;
        }
        if (refreshed != null) {
            mRefreshed.add(refreshed);
        }
        int count = getCount();
        for (int i = 0; i < count; i++) {
            moveTo(i);
            if (shortcutId.equals(getShortcutId()) && source.equals(getSuggestionSource())) {
              if (refreshed != null && refreshed.getCount() > 0) {
                  replaceRow(new SuggestionPosition(refreshed));
              } else {
                  removeRow();
              }
              notifyDataSetChanged();
              break;
            }
        }
    }

    @Override
    public void close() {
        if (DBG) Log.d(TAG, ""close()"");
        if (mClosed) {
            throw new IllegalStateException(""Double close()"");
        }
        mClosed = true;
        mShortcuts.close();
        for (SuggestionCursor cursor : mRefreshed) {
             cursor.close();
        }
        super.close();
    }
}",True,27,6,5,2,7,1,7,L4
24,com.android.quicksearchbox.ListSuggestionCursorNoDuplicates.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.util.Log;

import java.util.HashSet;

/**
 * A SuggestionCursor that is backed by a list of SuggestionPosition objects
 * and doesn't allow duplicate suggestions.
 */
public class ListSuggestionCursorNoDuplicates extends ListSuggestionCursor {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.ListSuggestionCursorNoDuplicates"";

    private final HashSet<String> mSuggestionKeys;

    public ListSuggestionCursorNoDuplicates(String userQuery) {
        super(userQuery);
        mSuggestionKeys = new HashSet<String>();
    }

    @Override
    public boolean add(SuggestionPosition suggestionPos) {
        String key = suggestionPos.current().getSuggestionKey();
        if (mSuggestionKeys.add(key)) {
            return super.add(suggestionPos);
        } else {
            if (DBG) Log.d(TAG, ""Rejecting duplicate "" + key);
            return false;
        }
    }

}
",False,32,7,7,3,3,1,3,L4
25,com.android.quicksearchbox.SuggestionCursor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.database.DataSetObserver;


/**
 * A sequence of suggestions, with a current position.
 */
public interface SuggestionCursor {

    /**
     * Gets the number of suggestions in this result.
     *
     * @return The number of suggestions, or {@code 0} if this result represents a failed query.
     */
    int getCount();

    /**
     * Moves to a given suggestion.
     *
     * @param pos The position to move to.
     * @throws IndexOutOfBoundsException if {@code pos < 0} or {@code pos >= getCount()}.
     */
    void moveTo(int pos);

    /**
     * Moves to the next suggestion, if there is one.
     *
     * @return {@code false} if there is no next suggestion.
     */
    boolean moveToNext();

    /**
     * Gets the current position within the cursor.
     */
    int getPosition();

    /**
     * Frees any resources used by this cursor.
     */
    void close();

    /**
     * Register an observer that is called when changes happen to this data set.
     *
     * @param observer gets notified when the data set changes.
     */
    void registerDataSetObserver(DataSetObserver observer);

    /**
     * Unregister an observer that has previously been registered with 
     * {@link #registerDataSetObserver(DataSetObserver)}
     *
     * @param observer the observer to unregister.
     */
    void unregisterDataSetObserver(DataSetObserver observer);

    /**
     * Gets the source that produced the current suggestion.
     */
    Source getSuggestionSource();

    /**
     * Gets the query that the user typed to get this suggestion.
     */
    String getUserQuery();

    /**
     * Gets the shortcut ID of the current suggestion.
     */
    String getShortcutId();

    /**
     * Whether to show a spinner while refreshing this shortcut.
     */
    boolean isSpinnerWhileRefreshing();

    /**
     * Gets the format of the text returned by {@link #getSuggestionText1()}
     * and {@link #getSuggestionText2()}.
     *
     * @return {@code null} or ""html""
     */
    String getSuggestionFormat();

    /**
     * Gets the first text line for the current suggestion.
     */
    String getSuggestionText1();

    /**
     * Gets the second text line for the current suggestion.
     */
    String getSuggestionText2();

    /**
     * Gets the second text line URL for the current suggestion.
     */
    String getSuggestionText2Url();

    /**
     * Gets the left-hand-side icon for the current suggestion.
     *
     * @return A string that can be passed to {@link Source#getIcon(String)}.
     */
    String getSuggestionIcon1();

    /**
     * Gets the right-hand-side icon for the current suggestion.
     *
     * @return A string that can be passed to {@link Source#getIcon(String)}.
     */
    String getSuggestionIcon2();

    /**
     * Gets the intent action for the current suggestion.
     */
    String getSuggestionIntentAction();

    /**
     * Gets the extra data associated with this suggestion's intent.
     */
    String getSuggestionIntentExtraData();

    /**
     * Gets the data associated with this suggestion's intent.
     */
    String getSuggestionIntentDataString();

    /**
     * Gets the data associated with this suggestion's intent.
     */
    String getSuggestionQuery();

    String getSuggestionDisplayQuery();

    /**
     * Gets a unique key that identifies this suggestion. This is used to avoid
     * duplicate suggestions in the promoted list. This key should be based on
     * the intent of the suggestion.
     */
    String getSuggestionKey();

    /**
     * Gets the suggestion log type for the current suggestion. This is logged together
     * with the value returned from {@link Source#getName()}.
     * The value is source-specific. Most sources return {@code null}.
     */
    String getSuggestionLogType();

    /**
     * Checks if this suggestion is a shortcut.
     */
    boolean isSuggestionShortcut();
}
",False,81,3,45,2,2,48,1,L0
26,com.android.quicksearchbox.CorpusRanker.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.database.DataSetObserver;

import java.util.List;

/**
 * Orders corpora by importance.
 */
public interface CorpusRanker {

    /**
     * Gets a an ordered list of corpora.
     *
     * @return The most important corpora come first in the list. Callers should not mofify the
     *         returned list.
     */
    List<Corpus> getRankedCorpora();

    /**
     * Registers an observer that is called when the corpus list changes.
     *
     * @param observer gets notified when the corpus list changes.
     */
    void registerDataSetObserver(DataSetObserver observer);

    /**
     * Unregisters an observer that has previously been registered with
     * {@link #registerDataSetObserver(DataSetObserver)}
     *
     * @param observer the observer to unregister.
     */
    void unregisterDataSetObserver(DataSetObserver observer);

}
",False,27,5,7,3,4,7,1,L4
27,com.android.quicksearchbox.EventLogLogger.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.util.EventLog;

import java.util.Collection;
import java.util.List;
import java.util.Random;

/**
 * Logs events to {@link EventLog}.
 */
public class EventLogLogger implements Logger {

    private static final char LIST_SEPARATOR = '|';

    private final Context mContext;

    private final Config mConfig;

    private final String mPackageName;

    private final int mVersionCode;

    private final Random mRandom;

    public EventLogLogger(Context context, Config config) {
        mContext = context;
        mConfig = config;
        mPackageName= mContext.getPackageName();
        try {
            PackageInfo pkgInfo = mContext.getPackageManager().getPackageInfo(mPackageName, 0);
            mVersionCode = pkgInfo.versionCode;
        } catch (PackageManager.NameNotFoundException ex) {
            // The current package should always exist, how else could we
            // run code from it?
            throw new RuntimeException(ex);
        }
        mRandom = new Random();
    }

    protected Context getContext() {
        return mContext;
    }

    protected int getVersionCode() {
        return mVersionCode;
    }

    protected Config getConfig() {
        return mConfig;
    }

    public void logStart(int latency, String intentSource, Corpus corpus,
            List<Corpus> orderedCorpora) {
        // TODO: Add more info to startMethod
        String startMethod = intentSource;
        String currentCorpus = getCorpusLogName(corpus);
        String enabledCorpora = getCorpusLogNames(orderedCorpora);
        EventLogTags.writeQsbStart(mPackageName, mVersionCode, startMethod,
                latency, currentCorpus, enabledCorpora);
    }

    public void logSuggestionClick(int position,
            SuggestionCursor suggestionCursor, Collection<Corpus> queriedCorpora) {
        String suggestions = getSuggestions(suggestionCursor);
        String corpora = getCorpusLogNames(queriedCorpora);
        int numChars = suggestionCursor.getUserQuery().length();
        EventLogTags.writeQsbClick(position, suggestions, corpora, numChars);
    }

    public void logSearch(Corpus corpus, int startMethod, int numChars) {
        String corpusName = getCorpusLogName(corpus);
        EventLogTags.writeQsbSearch(corpusName, startMethod, numChars);
    }

    public void logVoiceSearch(Corpus corpus) {
        String corpusName = getCorpusLogName(corpus);
        EventLogTags.writeQsbVoiceSearch(corpusName);
    }

    public void logExit(SuggestionCursor suggestionCursor, int numChars) {
        String suggestions = getSuggestions(suggestionCursor);
        EventLogTags.writeQsbExit(suggestions, numChars);
    }

    public void logLatency(CorpusResult result) {
        if (!shouldLogLatency()) return;
        String corpusName = getCorpusLogName(result.getCorpus());
        int latency = result.getLatency();
        int numChars = result.getUserQuery().length();
        EventLogTags.writeQsbLatency(corpusName, latency, numChars);
    }

    private boolean shouldLogLatency() {
        int freq = mConfig.getLatencyLogFrequency();
        return freq > mRandom.nextInt(1000);
    }

    private String getCorpusLogName(Corpus corpus) {
        if (corpus == null) return null;
        return corpus.getName();
    }

    private String getSuggestions(SuggestionCursor cursor) {
        StringBuilder sb = new StringBuilder();
        final int count = cursor == null ? 0 : cursor.getCount();
        for (int i = 0; i < count; i++) {
            if (i > 0) sb.append(LIST_SEPARATOR);
            cursor.moveTo(i);
            String source = cursor.getSuggestionSource().getName();
            String type = cursor.getSuggestionLogType();
            if (type == null) type = """";
            String shortcut = cursor.isSuggestionShortcut() ? ""shortcut"" : """";
            sb.append(source).append(':').append(type).append(':').append(shortcut);
        }
        return sb.toString();
    }

    private String getCorpusLogNames(Collection<Corpus> corpora) {
        StringBuilder sb = new StringBuilder();
        for (Corpus corpus : corpora) {
            if (sb.length() > 0) sb.append(LIST_SEPARATOR);
            sb.append(getCorpusLogName(corpus));
        }
        return sb.toString();
    }

}
",True,25,5,5,3,6,1,6,L5
28,com.android.quicksearchbox.AppsCorpus.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


import com.android.quicksearchbox.util.Util;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.Log;

/**
 * The apps search source.
 */
public class AppsCorpus extends SingleSourceCorpus {

    private static final String TAG = ""QSB.AppsCorpus"";

    private static final String APPS_CORPUS_NAME = ""apps"";

    public AppsCorpus(Context context, Source appsSource) {
        super(context, appsSource);
    }

    @Override
    public CharSequence getLabel() {
        return getContext().getText(R.string.corpus_label_apps);
    }

    @Override
    public CharSequence getHint() {
        return getContext().getText(R.string.corpus_hint_apps);
    }

    @Override
    public Drawable getCorpusIcon() {
        // TODO: Should we have a different icon for the apps corpus?
        return getContext().getResources().getDrawable(android.R.drawable.sym_def_app_icon);
    }

    @Override
    public Uri getCorpusIconUri() {
        return Util.getResourceUri(getContext(), android.R.drawable.sym_def_app_icon);
    }

    @Override
    public String getName() {
        return APPS_CORPUS_NAME;
    }

    @Override
    public CharSequence getSettingsDescription() {
        return getContext().getText(R.string.corpus_description_apps);
    }

    @Override
    public Intent createSearchIntent(String query, Bundle appData) {
        Intent appSearchIntent = createAppSearchIntent(query, appData);
        if (appSearchIntent != null) {
            return appSearchIntent;
        } else {
            // Fall back to sending the intent to ApplicationsProvider
            return super.createSearchIntent(query, appData);
        }
    }

    /**
     * Creates an intent that starts the search activity specified in
     * R.string.apps_search_activity.
     *
     * @return An intent, or {@code null} if the search activity is not set or can't be found.
     */
    private Intent createAppSearchIntent(String query, Bundle appData) {
        ComponentName name = getComponentName(getContext(), R.string.apps_search_activity);
        if (name == null) return null;
        Intent intent = SearchableSource.createSourceSearchIntent(name, query, appData);
        if (intent == null) return null;
        ActivityInfo ai = intent.resolveActivityInfo(getContext().getPackageManager(), 0);
        if (ai != null) {
            return intent;
        } else {
            Log.w(TAG, ""Can't find app search acitivity "" + name);
            return null;
        }
    }

    private static ComponentName getComponentName(Context context, int res) {
        String nameStr = context.getString(res);
        if (TextUtils.isEmpty(nameStr)) {
            return null;
        } else {
            return ComponentName.unflattenFromString(nameStr);
        }
    }
}
",False,73,0,0,7,33,1,4,L5
29,com.android.quicksearchbox.WebCorpus.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


import com.android.quicksearchbox.util.Util;

import android.app.SearchManager;
import android.content.Context;
import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.speech.RecognizerIntent;
import android.util.Patterns;
import android.webkit.URLUtil;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executor;

/**
 * The web search source.
 */
public class WebCorpus extends MultiSourceCorpus {

    private static final String WEB_CORPUS_NAME = ""web"";

    private final Source mWebSearchSource;

    private final Source mBrowserSource;

    public WebCorpus(Context context, Executor executor,
            Source webSearchSource, Source browserSource) {
        super(context, executor, webSearchSource, browserSource);
        mWebSearchSource = webSearchSource;
        mBrowserSource = browserSource;
    }

    public CharSequence getLabel() {
        return getContext().getText(R.string.corpus_label_web);
    }

    public CharSequence getHint() {
        // The web corpus uses a drawable hint instead
        return null;
    }

    private boolean isUrl(String query) {
       return Patterns.WEB_URL.matcher(query).matches();
    }

    public Intent createSearchIntent(String query, Bundle appData) {
        return isUrl(query)? createBrowseIntent(query) : createWebSearchIntent(query, appData);
    }

    private static Intent createWebSearchIntent(String query, Bundle appData) {
        Intent intent = new Intent(Intent.ACTION_WEB_SEARCH);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        // We need CLEAR_TOP to avoid reusing an old task that has other activities
        // on top of the one we want.
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
        intent.putExtra(SearchManager.USER_QUERY, query);
        intent.putExtra(SearchManager.QUERY, query);
        if (appData != null) {
            intent.putExtra(SearchManager.APP_DATA, appData);
        }
        // TODO: Include something like this, to let the web search activity
        // know how this query was started.
        //intent.putExtra(SearchManager.SEARCH_MODE, SearchManager.MODE_GLOBAL_SEARCH_TYPED_QUERY);
        return intent;
    }

    private static Intent createBrowseIntent(String query) {
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.addCategory(Intent.CATEGORY_BROWSABLE);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
        String url = URLUtil.guessUrl(query);
        intent.setData(Uri.parse(url));
        return intent;
    }

    public SuggestionData createSearchShortcut(String query) {
        SuggestionData shortcut = new SuggestionData(mWebSearchSource);
        if (isUrl(query)) {
            shortcut.setIntentAction(Intent.ACTION_VIEW);
            shortcut.setIcon1(String.valueOf(R.drawable.globe));
            shortcut.setText1(query);
            // Set query so that trackball selection works
            shortcut.setSuggestionQuery(query);
            shortcut.setIntentData(URLUtil.guessUrl(query));
        } else {
            shortcut.setIntentAction(Intent.ACTION_WEB_SEARCH);
            shortcut.setIcon1(String.valueOf(R.drawable.magnifying_glass));
            shortcut.setText1(query);
            shortcut.setSuggestionQuery(query);
        }
        return shortcut;
    }

    public Intent createVoiceSearchIntent(Bundle appData) {
        return createVoiceWebSearchIntent(appData);
    }

    public static Intent createVoiceWebSearchIntent(Bundle appData) {
        Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,
                RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);
        if (appData != null) {
            intent.putExtra(SearchManager.APP_DATA, appData);
        }
        return intent;
    }

    private int getCorpusIconResource() {
        return R.drawable.corpus_icon_web;
    }

    public Drawable getCorpusIcon() {
        return getContext().getResources().getDrawable(getCorpusIconResource());
    }

    public Uri getCorpusIconUri() {
        return Util.getResourceUri(getContext(), getCorpusIconResource());
    }

    public String getName() {
        return WEB_CORPUS_NAME;
    }

    public int getQueryThreshold() {
        return 0;
    }

    public boolean queryAfterZeroResults() {
        return true;
    }

    public boolean voiceSearchEnabled() {
        return true;
    }

    public boolean isWebCorpus() {
        return true;
    }

    public CharSequence getSettingsDescription() {
        return getContext().getText(R.string.corpus_description_web);
    }

    @Override
    protected List<Source> getSourcesToQuery(String query) {
        ArrayList<Source> sourcesToQuery = new ArrayList<Source>(2);
        if (mWebSearchSource != null
                && SearchSettings.getShowWebSuggestions(getContext())) {
            sourcesToQuery.add(mWebSearchSource);
        }
        if (mBrowserSource != null && query.length() > 0) {
            sourcesToQuery.add(mBrowserSource);
        }
        return sourcesToQuery;
    }

    @Override
    protected Result createResult(String query, ArrayList<SourceResult> results, int latency) {
        return new WebResult(query, results, latency);
    }

    protected class WebResult extends Result {

        public WebResult(String query, ArrayList<SourceResult> results, int latency) {
            super(query, results, latency);
        }

        @Override
        public void fill() {
            SourceResult webSearchResult = null;
            SourceResult browserResult = null;
            for (SourceResult result : getResults()) {
                if (result.getSource().equals(mWebSearchSource)) {
                    webSearchResult = result;
                } else {
                    browserResult = result;
                }
            }
            if (browserResult != null && browserResult.getCount() > 0) {
                add(new SuggestionPosition(browserResult, 0));
            }
            if (webSearchResult != null) {
                int count = webSearchResult.getCount();
                for (int i = 0; i < count; i++) {
                    add(new SuggestionPosition(webSearchResult, i));
                }
            }
        }

    }
}
",True,75,2,1,6,33,3,9,L5
30,com.android.quicksearchbox.SuggestionsProviderImpl.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.BatchingNamedTaskExecutor;
import com.android.quicksearchbox.util.Consumer;
import com.android.quicksearchbox.util.NamedTaskExecutor;
import com.android.quicksearchbox.util.Util;

import android.os.Handler;
import android.util.Log;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

/**
 * Suggestions provider implementation.
 *
 * The provider will only handle a single query at a time. If a new query comes
 * in, the old one is canceled.
 */
public class SuggestionsProviderImpl implements SuggestionsProvider {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SuggestionsProviderImpl"";

    private final Config mConfig;

    private final NamedTaskExecutor mQueryExecutor;

    private final Handler mPublishThread;

    private final Promoter mPromoter;

    private final ShortcutRepository mShortcutRepo;

    private final Logger mLogger;

    private final ShouldQueryStrategy mShouldQueryStrategy = new ShouldQueryStrategy();

    private final Corpora mCorpora;

    private BatchingNamedTaskExecutor mBatchingExecutor;

    public SuggestionsProviderImpl(Config config,
            NamedTaskExecutor queryExecutor,
            Handler publishThread,
            Promoter promoter,
            ShortcutRepository shortcutRepo,
            Corpora corpora,
            Logger logger) {
        mConfig = config;
        mQueryExecutor = queryExecutor;
        mPublishThread = publishThread;
        mPromoter = promoter;
        mShortcutRepo = shortcutRepo;
        mLogger = logger;
        mCorpora = corpora;
    }

    public void close() {
        cancelPendingTasks();
    }

    /**
     * Cancels all pending query tasks.
     */
    private void cancelPendingTasks() {
        if (mBatchingExecutor != null) {
            mBatchingExecutor.cancelPendingTasks();
            mBatchingExecutor = null;
        }
    }

    protected SuggestionCursor getShortcutsForQuery(String query, List<Corpus> corpora,
            int maxShortcuts) {
        if (mShortcutRepo == null) return null;
        return mShortcutRepo.getShortcutsForQuery(query, corpora, maxShortcuts);
    }

    /**
     * Gets the sources that should be queried for the given query.
     */
    private List<Corpus> getCorporaToQuery(String query, List<Corpus> orderedCorpora) {
        ArrayList<Corpus> corporaToQuery = new ArrayList<Corpus>(orderedCorpora.size());
        for (Corpus corpus : orderedCorpora) {
            if (shouldQueryCorpus(corpus, query)) {
                corporaToQuery.add(corpus);
            }
        }
        return corporaToQuery;
    }

    protected boolean shouldQueryCorpus(Corpus corpus, String query) {
        if (query.length() == 0 && !corpus.isWebCorpus()) {
            // Only the web corpus sees zero length queries.
            return false;
        }
        return mShouldQueryStrategy.shouldQueryCorpus(corpus, query);
    }

    private void updateShouldQueryStrategy(CorpusResult cursor) {
        if (cursor.getCount() == 0) {
            mShouldQueryStrategy.onZeroResults(cursor.getCorpus(),
                    cursor.getUserQuery());
        }
    }

    public Suggestions getSuggestions(String query, List<Corpus> corpora, int maxSuggestions) {
        if (DBG) Log.d(TAG, ""getSuggestions("" + query + "")"");
        cancelPendingTasks();
        List<Corpus> corporaToQuery = getCorporaToQuery(query, corpora);
        final Suggestions suggestions = new Suggestions(mPromoter,
                maxSuggestions,
                query,
                corporaToQuery.size());
        int maxShortcuts = mConfig.getMaxShortcutsReturned();
        SuggestionCursor shortcuts = getShortcutsForQuery(query, corpora, maxShortcuts);
        if (shortcuts != null) {
            suggestions.setShortcuts(shortcuts);
        }

        // Fast path for the zero sources case
        if (corporaToQuery.size() == 0) {
            return suggestions;
        }

        int initialBatchSize = countDefaultCorpora(corporaToQuery);
        initialBatchSize = Math.min(initialBatchSize, mConfig.getNumPromotedSources());
        if (initialBatchSize == 0) {
            initialBatchSize = mConfig.getNumPromotedSources();
        }

        mBatchingExecutor = new BatchingNamedTaskExecutor(mQueryExecutor);

        SuggestionCursorReceiver receiver = new SuggestionCursorReceiver(
                mBatchingExecutor, suggestions, initialBatchSize);

        int maxResultsPerSource = mConfig.getMaxResultsPerSource();
        QueryTask.startQueries(query, maxResultsPerSource, corporaToQuery, mBatchingExecutor,
                mPublishThread, receiver);
        mBatchingExecutor.executeNextBatch(initialBatchSize);

        return suggestions;
    }

    private int countDefaultCorpora(List<Corpus> corpora) {
        int count = 0;
        for (Corpus corpus : corpora) {
            if (mCorpora.isCorpusDefaultEnabled(corpus)) {
                count++;
            }
        }
        return count;
    }

    private class SuggestionCursorReceiver implements Consumer<CorpusResult> {
        private final BatchingNamedTaskExecutor mExecutor;
        private final Suggestions mSuggestions;

        private int mCountAtWhichToExecuteNextBatch;

        public SuggestionCursorReceiver(BatchingNamedTaskExecutor executor,
                Suggestions suggestions, int initialBatchSize) {
            mExecutor = executor;
            mSuggestions = suggestions;
            mCountAtWhichToExecuteNextBatch = initialBatchSize;
        }

        public boolean consume(CorpusResult cursor) {
            updateShouldQueryStrategy(cursor);
            mSuggestions.addCorpusResult(cursor);
            if (!mSuggestions.isClosed()) {
                executeNextBatchIfNeeded();
            }
            if (cursor != null && mLogger != null) {
                mLogger.logLatency(cursor);
            }
            return true;
        }

        private void executeNextBatchIfNeeded() {
            if (mSuggestions.getSourceCount() == mCountAtWhichToExecuteNextBatch) {
                // We've just finished one batch
                if (mSuggestions.getPromoted().getCount() < mConfig.getMaxPromotedSuggestions()) {
                    // But we still don't have enough results, ask for more
                    int nextBatchSize = mConfig.getNumPromotedSources();
                    mCountAtWhichToExecuteNextBatch += nextBatchSize;
                    mExecutor.executeNextBatch(nextBatchSize);
                }
            }
        }
    }

}
",False,42,5,5,3,16,1,16,L5
31,com.android.quicksearchbox.ShortcutPromoter.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.util.Log;

import java.util.ArrayList;

/**
 * A promoter that first promotes any shortcuts, and then delegates to another
 * promoter.
 *
 */
public class ShortcutPromoter implements Promoter {

    private static final String TAG = ""QSB.ShortcutPromoter"";
    private static final boolean DBG = false;

    /** The promoter to use when there are no more shortcuts. */
    private final Promoter mNextPromoter;

    /**
     * Creates a new ShortcutPromoter.
     *
     * @param nextPromoter The promoter to use when there are no more shortcuts.
     *        May be {@code null}.
     */
    public ShortcutPromoter(Promoter nextPromoter) {
        mNextPromoter = nextPromoter;
    }

    public void pickPromoted(SuggestionCursor shortcuts,
            ArrayList<CorpusResult> suggestions, int maxPromoted,
            ListSuggestionCursor promoted) {
        int shortcutCount = shortcuts == null ? 0 : shortcuts.getCount();
        int promotedShortcutCount = Math.min(shortcutCount, maxPromoted);
        if (DBG) {
            Log.d(TAG, ""pickPromoted(shortcutCount = "" + shortcutCount +
                    "", maxPromoted = "" + maxPromoted + "")"");
        }

        for (int i = 0; i < promotedShortcutCount; i++) {
            promoted.add(new SuggestionPosition(shortcuts, i));
        }

        if (promoted.getCount() < maxPromoted && mNextPromoter != null) {
            mNextPromoter.pickPromoted(null, suggestions, maxPromoted, promoted);
        }
    }

}
",False,29,5,5,3,5,2,5,L4
32,com.android.quicksearchbox.AbstractSuggestionCursorWrapper.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

/**
 * A SuggestionCursor that delegates all suggestions-specific calls to one or more
 * other suggestion cursors.
 */
public abstract class AbstractSuggestionCursorWrapper extends AbstractSuggestionCursor {

    public AbstractSuggestionCursorWrapper(String userQuery) {
        super(userQuery);
    }

    /**
     * Gets the SuggestionCursor to use for the current suggestion.
     */
    protected abstract SuggestionCursor current();

    public String getShortcutId() {
        return current().getShortcutId();
    }

    @Override
    public String getSuggestionDisplayQuery() {
        return current().getSuggestionDisplayQuery();
    }

    public String getSuggestionFormat() {
        return current().getSuggestionFormat();
    }

    public String getSuggestionIcon1() {
        return current().getSuggestionIcon1();
    }

    public String getSuggestionIcon2() {
        return current().getSuggestionIcon2();
    }

    public String getSuggestionIntentAction() {
        return current().getSuggestionIntentAction();
    }

    public String getSuggestionIntentDataString() {
        return current().getSuggestionIntentDataString();
    }

    public String getSuggestionIntentExtraData() {
        return current().getSuggestionIntentExtraData();
    }

    public String getSuggestionKey() {
        return current().getSuggestionKey();
    }

    public String getSuggestionLogType() {
        return current().getSuggestionLogType();
    }

    public String getSuggestionQuery() {
        return current().getSuggestionQuery();
    }

    public Source getSuggestionSource() {
        return current().getSuggestionSource();
    }

    public String getSuggestionText1() {
        return current().getSuggestionText1();
    }

    public String getSuggestionText2() {
        return current().getSuggestionText2();
    }

    public String getSuggestionText2Url() {
        return current().getSuggestionText2Url();
    }

    public boolean isSpinnerWhileRefreshing() {
        return current().isSpinnerWhileRefreshing();
    }

    public boolean isSuggestionShortcut() {
        return current().isSuggestionShortcut();
    }
}
",False,53,5,18,2,3,4,3,L1
33,com.android.quicksearchbox.SingleSourceCorpusResult.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * A CorpusResult backed by a single SourceResult.
 */
public class SingleSourceCorpusResult extends SuggestionCursorWrapper implements CorpusResult {

    private final Corpus mCorpus;

    private final int mLatency;

    public SingleSourceCorpusResult(Corpus corpus, String userQuery, SuggestionCursor cursor,
            int latency) {
        super(userQuery, cursor);
        mCorpus = corpus;
        mLatency = latency;
    }

    public Corpus getCorpus() {
        return mCorpus;
    }

    public int getLatency() {
        return mLatency;
    }

    @Override
    public String toString() {
        return getCorpus() + ""["" + getUserQuery() + ""]"";
    }

}
",False,27,7,5,3,5,1,5,L5
34,com.android.quicksearchbox.DataSuggestionCursor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.google.common.annotations.VisibleForTesting;

import android.database.DataSetObservable;
import android.database.DataSetObserver;

import java.util.ArrayList;

/**
 * A SuggestionCursor that is backed by a list of SuggestionData objects.
 */
public class DataSuggestionCursor extends AbstractSuggestionCursor {

    private final DataSetObservable mDataSetObservable = new DataSetObservable();

    private final ArrayList<SuggestionData> mSuggestions;

    private int mPos;

    public DataSuggestionCursor(String userQuery) {
        super(userQuery);
        mSuggestions = new ArrayList<SuggestionData>();
        mPos = 0;
    }

    @VisibleForTesting
    public DataSuggestionCursor(String userQuery, SuggestionData... suggestions) {
        this(userQuery);
        for (SuggestionData suggestion : suggestions) {
            mSuggestions.add(suggestion);
        }
    }

    /**
     * Adds a suggestion.
     *
     * @param suggestion
     * @return {@code true}
     */
    public boolean add(SuggestionData suggestion) {
        mSuggestions.add(suggestion);
        notifyDataSetChanged();
        return true;
    }

    private SuggestionData current() {
        return mSuggestions.get(mPos);
    }

    public void close() {
        mSuggestions.clear();
    }

    public int getPosition() {
        return mPos;
    }

    public void moveTo(int pos) {
        mPos = pos;
    }

    public boolean moveToNext() {
        int size = mSuggestions.size();
        if (mPos >= size) {
            // Already past the end
            return false;
        }
        mPos++;
        return mPos < size;
    }

    public int getCount() {
        return mSuggestions.size();
    }

    /**
     * Register an observer that is called when changes happen to this data set.
     *
     * @param observer gets notified when the data set changes.
     */
    public void registerDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.registerObserver(observer);
    }

    /**
     * Unregister an observer that has previously been registered with 
     * {@link #registerDataSetObserver(DataSetObserver)}
     *
     * @param observer the observer to unregister.
     */
    public void unregisterDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.unregisterObserver(observer);
    }

    protected void notifyDataSetChanged() {
        mDataSetObservable.notifyChanged();
    }

    public String getShortcutId() {
        return current().getShortcutId();
    }

    public String getSuggestionFormat() {
        return current().getSuggestionFormat();
    }

    public String getSuggestionIcon1() {
        return current().getSuggestionIcon1();
    }

    public String getSuggestionIcon2() {
        return current().getSuggestionIcon2();
    }

    public String getSuggestionIntentAction() {
        return current().getSuggestionIntentAction();
    }

    public String getSuggestionIntentDataString() {
        return current().getSuggestionIntentDataString();
    }

    public String getSuggestionIntentExtraData() {
        return current().getSuggestionIntentExtraData();
    }

    public String getSuggestionKey() {
        return current().getSuggestionKey();
    }

    public String getSuggestionLogType() {
        return current().getSuggestionLogType();
    }

    public String getSuggestionQuery() {
        return current().getSuggestionQuery();
    }

    public Source getSuggestionSource() {
        return current().getSuggestionSource();
    }

    public String getSuggestionText1() {
        return current().getSuggestionText1();
    }

    public String getSuggestionText2() {
        return current().getSuggestionText2();
    }

    public String getSuggestionText2Url() {
        return current().getSuggestionText2Url();
    }

    public boolean isSpinnerWhileRefreshing() {
        return current().isSpinnerWhileRefreshing();
    }

    public boolean isSuggestionShortcut() {
        return false;
    }
}
",False,24,3,9,2,3,5,3,L2
35,com.android.quicksearchbox.Promoter.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import java.util.ArrayList;

/**
 * Promoters choose which suggestions to promote from all the available suggestions.
 *
 */
public interface Promoter {

    /**
     * Gets the promoted suggestions.
     *
     * @param shortcuts The shortcuts for the query.
     * @param suggestions The suggestions from each source.
     * @param maxPromoted The maximum number of suggestions to promote.
     * @param promoted List to add the promoted suggestions to.
     */
    void pickPromoted(SuggestionCursor shortcuts,
            ArrayList<CorpusResult> suggestions, int maxPromoted,
            ListSuggestionCursor promoted);

}
",False,41,5,11,3,5,8,3,L3
36,com.android.quicksearchbox.ShortcutRefresher.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

/**
 * Fires off tasks to validate shortcuts, and reports the results back to a
 * {@link Listener}.
 */
public interface ShortcutRefresher {

    public interface Listener {
        /**
         * Called by the ShortcutRefresher when a shortcut has been refreshed.
         *
         * @param source source of this shortcut.
         * @param shortcutId the id of the shortcut.
         * @param refreshed the updated shortcut, or {@code null} if the shortcut
         *        is no longer valid and should be deleted.
         */
        void onShortcutRefreshed(Source source, String shortcutId,
                SuggestionCursor refreshed);
    }

    /**
     * Sends off the refresher tasks.
     *
     * @param shortcuts The shortcuts to refresh.
     * @param listener Who to report back to.
     */
    void refresh(SuggestionCursor shortcuts, final Listener listener);

    /**
     * Returns true if the given shortcut requires refreshing.
     */
    boolean shouldRefresh(Source source, String shortcutId);

    /**
     * Indicates that the shortcut no longer requires refreshing.
     */
    public void markShortcutRefreshed(Source source, String shortcutId);

    /**
     * Resets internal state. This results in all shortcuts requiring refreshing.
     */
    public void reset();

    /**
     * Cancels any pending shortcut refresh requests.
     */
    public void cancelPendingTasks();

}
",False,25,5,7,2,2,7,2,L1
37,com.android.quicksearchbox.Corpus.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;

import java.util.Collection;

/**
 * A corpus is a user-visible set of suggestions. A corpus gets suggestions from one
 * or more sources.
 *
 * Objects that implement this interface should override {@link Object#equals(Object)}
 * and {@link Object#hashCode()} so that they can be used as keys in hash maps.
 */
public interface Corpus extends SuggestionCursorProvider<CorpusResult> {

    /**
     * Gets the localized, human-readable label for this corpus.
     */
    CharSequence getLabel();

    /**
     * Gets the icon for this corpus.
     */
    Drawable getCorpusIcon();

    /**
     * Gets the icon URI for this corpus.
     */
    Uri getCorpusIconUri();

    /**
     * Gets the description to use for this corpus in system search settings.
     */
    CharSequence getSettingsDescription();

    /**
     * Gets the search hint text for this corpus.
     */
    CharSequence getHint();

    int getQueryThreshold();

    boolean queryAfterZeroResults();

    boolean voiceSearchEnabled();

    Intent createSearchIntent(String query, Bundle appData);

    Intent createVoiceSearchIntent(Bundle appData);

    SuggestionData createSearchShortcut(String query);

    boolean isWebCorpus();

    /**
     * Gets the sources that this corpus uses.
     */
    Collection<Source> getSources();
}
",False,56,4,35,2,4,36,4,L2
38,com.android.quicksearchbox.Config.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Context;
import android.content.res.Resources;
import android.os.Process;
import android.util.Log;

import java.util.HashSet;

/**
 * Provides values for configurable parameters in all of QSB.
 *
 * All the methods in this class return fixed default values. Subclasses may
 * make these values server-side settable.
 *
 */
public class Config {

    private static final String TAG = ""QSB.Config"";

    private static final long DAY_MILLIS = 86400000L;

    private static final int NUM_SUGGESTIONS_ABOVE_KEYBOARD = 4;
    private static final int NUM_PROMOTED_SOURCES = 3;
    private static final int MAX_PROMOTED_SUGGESTIONS = 8;
    private static final int MAX_RESULTS_PER_SOURCE = 50;
    private static final long SOURCE_TIMEOUT_MILLIS = 10000;

    private static final int QUERY_THREAD_PRIORITY =
            Process.THREAD_PRIORITY_BACKGROUND + Process.THREAD_PRIORITY_MORE_FAVORABLE;

    private static final long MAX_STAT_AGE_MILLIS = 30 * DAY_MILLIS;
    private static final int MIN_CLICKS_FOR_SOURCE_RANKING = 3;
    private static final int MAX_SHORTCUTS_RETURNED = MAX_PROMOTED_SUGGESTIONS;

    private static final int NUM_WEB_CORPUS_THREADS = 2;

    private static final int LATENCY_LOG_FREQUENCY = 1000;

    private static final long TYPING_SUGGESTIONS_UPDATE_DELAY_MILLIS = 100;

    private final Context mContext;
    private HashSet<String> mDefaultCorpora;

    /**
     * Creates a new config that uses hard-coded default values.
     */
    public Config(Context context) {
        mContext = context;
    }

    protected Context getContext() {
        return mContext;
    }

    /**
     * Releases any resources used by the configuration object.
     *
     * Default implementation does nothing.
     */
    public void close() {
    }

    private HashSet<String> loadDefaultCorpora() {
        HashSet<String> defaultCorpora = new HashSet<String>();
        try {
            // Get the list of default corpora from a resource, which allows vendor overlays.
            String[] corpora = mContext.getResources().getStringArray(R.array.default_corpora);
            for (String corpus : corpora) {
                defaultCorpora.add(corpus);
            }
            return defaultCorpora;
        } catch (Resources.NotFoundException ex) {
            Log.e(TAG, ""Could not load default corpora"", ex);
            return defaultCorpora;
        }
    }

    /**
     * Checks if we trust the given source not to be spammy.
     */
    public synchronized boolean isCorpusEnabledByDefault(String corpusName) {
        if (mDefaultCorpora == null) {
            mDefaultCorpora = loadDefaultCorpora();
        }
        return mDefaultCorpora.contains(corpusName);
    }

    /**
     * The number of promoted sources.
     */
    public int getNumPromotedSources() {
        return NUM_PROMOTED_SOURCES;
    }

    /**
     * The number of suggestions visible above the onscreen keyboard.
     */
    public int getNumSuggestionsAboveKeyboard() {
        try {
            // Get the list of default corpora from a resource, which allows vendor overlays.
            return mContext.getResources().getInteger(R.integer.num_suggestions_above_keyboard);
        } catch (Resources.NotFoundException ex) {
            Log.e(TAG, ""Could not load num_suggestions_above_keyboard"", ex);
            return NUM_SUGGESTIONS_ABOVE_KEYBOARD;
        }
    }

    /**
     * The maximum number of suggestions to promote.
     */
    public int getMaxPromotedSuggestions() {
        return MAX_PROMOTED_SUGGESTIONS;
    }

    /**
     * The number of results to ask each source for.
     */
    public int getMaxResultsPerSource() {
        return MAX_RESULTS_PER_SOURCE;
    }

    /**
     * The timeout for querying each source, in milliseconds.
     */
    public long getSourceTimeoutMillis() {
        return SOURCE_TIMEOUT_MILLIS;
    }

    /**
     * The priority of query threads.
     *
     * @return A thread priority, as defined in {@link Process}.
     */
    public int getQueryThreadPriority() {
        return QUERY_THREAD_PRIORITY;
    }

    /**
     * The maximum age of log data used for shortcuts.
     */
    public long getMaxStatAgeMillis(){
        return MAX_STAT_AGE_MILLIS;
    }

    /**
     * The minimum number of clicks needed to rank a source.
     */
    public int getMinClicksForSourceRanking(){
        return MIN_CLICKS_FOR_SOURCE_RANKING;
    }

    /**
     * The maximum number of shortcuts shown.
     */
    public int getMaxShortcutsReturned(){
        return MAX_SHORTCUTS_RETURNED;
    }

    public int getNumWebCorpusThreads() {
        return NUM_WEB_CORPUS_THREADS;
    }

    /**
     * How often query latency should be logged.
     *
     * @return An integer in the range 0-1000. 0 means that no latency events
     *         should be logged. 1000 means that all latency events should be logged.
     */
    public int getLatencyLogFrequency() {
        return LATENCY_LOG_FREQUENCY;
    }

    /**
     * The delay in milliseconds before suggestions are updated while typing.
     * If a new character is typed before this timeout expires, the timeout is reset.
     */
    public long getTypingUpdateSuggestionsDelayMillis() {
        return TYPING_SUGGESTIONS_UPDATE_DELAY_MILLIS;
    }
}
",False,22,5,10,0,0,10,0,L3
39,com.android.quicksearchbox.ChoiceActivity.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.app.Activity;
import android.os.Bundle;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.TextView;

/**
 * Activity that shows a list of choices.
 */
public abstract class ChoiceActivity extends Activity {

    protected TextView mTitleView;
    protected ListView mChoicesView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        getWindow().requestFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.choice_activity);
        mTitleView = (TextView) findViewById(R.id.alertTitle);
        mChoicesView = (ListView) findViewById(R.id.list);
    }

    public void setHeading(int titleRes) {
        mTitleView.setText(titleRes);
    }

    public void setHeading(CharSequence title) {
        mTitleView.setText(title);
    }

    public void setAdapter(ListAdapter adapter) {
        mChoicesView.setAdapter(adapter);
    }

    public void setOnItemClickListener(AdapterView.OnItemClickListener listener) {
        mChoicesView.setOnItemClickListener(listener);
        // TODO: for some reason, putting this in the XML layout instead makes
        // the list items unclickable.
        mChoicesView.setFocusable(true);
    }
}
",False,3,2,1,0,0,1,0,L7
40,com.android.quicksearchbox.CorpusSelectionDialog.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.ui.CorporaAdapter;
import com.android.quicksearchbox.ui.CorpusViewFactory;

import android.app.Dialog;
import android.content.Context;
import android.os.Bundle;
import android.util.Log;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MotionEvent;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.widget.AdapterView;
import android.widget.GridView;

/**
 * Corpus selection dialog.
 */
public class CorpusSelectionDialog extends Dialog {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SelectSearchSourceDialog"";

    private static final int NUM_COLUMNS = 4;

    private GridView mCorpusGrid;

    private OnCorpusSelectedListener mListener;

    private Corpus mCorpus;

    private CorporaAdapter mAdapter;

    public CorpusSelectionDialog(Context context) {
        super(context, R.style.Theme_SelectSearchSource);
    }

    /**
     * Shows the corpus selection dialog.
     *
     * @param corpus The currently selected corpus.
     */
    public void show(Corpus corpus) {
        mCorpus = corpus;
        show();
    }

    public void setOnCorpusSelectedListener(OnCorpusSelectedListener listener) {
        mListener = listener;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        setContentView(R.layout.corpus_selection_dialog);
        mCorpusGrid = (GridView) findViewById(R.id.corpus_grid);
        mCorpusGrid.setNumColumns(NUM_COLUMNS);
        mCorpusGrid.setOnItemClickListener(new CorpusClickListener());
        // TODO: for some reason, putting this in the XML layout instead makes
        // the list items unclickable.
        mCorpusGrid.setFocusable(true);

        Window window = getWindow();
        WindowManager.LayoutParams lp = window.getAttributes();
        lp.width = WindowManager.LayoutParams.MATCH_PARENT;
        lp.height = WindowManager.LayoutParams.MATCH_PARENT;
        // Put window on top of input method
        lp.flags |= WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
        window.setAttributes(lp);
        if (DBG) Log.d(TAG, ""Window params: "" + lp);
    }

    @Override
    protected void onStart() {
        super.onStart();
        CorporaAdapter adapter =
                CorporaAdapter.createGridAdapter(getViewFactory(), getCorpusRanker());
        setAdapter(adapter);
        mCorpusGrid.setSelection(adapter.getCorpusPosition(mCorpus));
    }

    @Override
    protected void onStop() {
        setAdapter(null);
        super.onStop();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        SearchSettings.addSearchSettingsMenuItem(getContext(), menu);
        return true;
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (event.getAction() == MotionEvent.ACTION_DOWN) {
            // Cancel dialog on any touch down event which is not handled by the corpus grid
            cancel();
            return true;
        }
        return false;
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        boolean handled = super.onKeyDown(keyCode, event);
        if (handled) {
            return handled;
        }
        // Dismiss dialog on up move when nothing, or an item on the top row, is selected.
        if (keyCode == KeyEvent.KEYCODE_DPAD_UP) {
            int selectedRow = mCorpusGrid.getSelectedItemPosition() / NUM_COLUMNS;
            if (selectedRow <= 0) {
                cancel();
                return true;
            }
        }
        // Dismiss dialog when typing on hard keyboard (soft keyboard is behind the dialog,
        // so that can't be typed on)
        if (event.isPrintingKey()) {
            cancel();
            return true;
        }
        return false;
    }

    @Override
    public void onBackPressed() {
        SearchActivity searchActivity = getSearchActivity();
        if (searchActivity.startedIntoCorpusSelectionDialog()) {
            searchActivity.onBackPressed();
        }
        cancel();
    }

    private SearchActivity getSearchActivity() {
        return (SearchActivity) getOwnerActivity();
    }

    private void setAdapter(CorporaAdapter adapter) {
        if (adapter == mAdapter) return;
        if (mAdapter != null) mAdapter.close();
        mAdapter = adapter;
        mCorpusGrid.setAdapter(mAdapter);
    }

    private QsbApplication getQsbApplication() {
        return (QsbApplication) getContext().getApplicationContext();
    }

    private CorpusRanker getCorpusRanker() {
        return getQsbApplication().getCorpusRanker();
    }

    private CorpusViewFactory getViewFactory() {
        return getQsbApplication().getCorpusViewFactory();
    }

    protected void selectCorpus(Corpus corpus) {
        dismiss();
        if (mListener != null) {
            mListener.onCorpusSelected(corpus);
        }
    }

    private class CorpusClickListener implements AdapterView.OnItemClickListener {
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            Corpus corpus = (Corpus) parent.getItemAtPosition(position);
            selectCorpus(corpus);
        }
    }

    public interface OnCorpusSelectedListener {
        void onCorpusSelected(Corpus corpus);
    }
}
",False,81,0,0,5,44,1,7,L6
41,com.android.quicksearchbox.CachingIconLoader.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.text.TextUtils;
import android.util.Log;

import java.util.WeakHashMap;

/**
 * Icon loader that caches the results of another icon loader.
 *
 */
public class CachingIconLoader implements IconLoader {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.CachingIconLoader"";

    private final IconLoader mWrapped;

    private final WeakHashMap<String, Drawable.ConstantState> mIconCache;

    /**
     * Creates a new caching icon loader.
     *
     * @param wrapped IconLoader whose results will be cached.
     */
    public CachingIconLoader(IconLoader wrapped) {
        mWrapped = wrapped;
        mIconCache = new WeakHashMap<String, Drawable.ConstantState>();
    }

    public Drawable getIcon(String drawableId) {
        if (DBG) Log.d(TAG, ""getIcon("" + drawableId + "")"");
        if (TextUtils.isEmpty(drawableId) || ""0"".equals(drawableId)) {
            return null;
        }
        Drawable drawable = checkIconCache(drawableId);
        if (drawable != null) {
            return drawable;
        }
        drawable = mWrapped.getIcon(drawableId);
        storeInIconCache(drawableId, drawable);
        return drawable;
    }

    public Uri getIconUri(String drawableId) {
        return mWrapped.getIconUri(drawableId);
    }

    private Drawable checkIconCache(String drawableId) {
        Drawable.ConstantState cached = mIconCache.get(drawableId);
        if (cached == null) {
            return null;
        }
        if (DBG) Log.d(TAG, ""Found icon in cache: "" + drawableId);
        return cached.newDrawable();
    }

    private void storeInIconCache(String resourceUri, Drawable drawable) {
        if (drawable != null) {
            mIconCache.put(resourceUri, drawable.getConstantState());
        }
    }
}
",False,18,6,5,1,1,2,1,L1
42,com.android.quicksearchbox.MultiSourceCorpus.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


import com.android.quicksearchbox.util.BarrierConsumer;

import android.content.Context;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.Executor;

/**
 * Base class for corpora backed by multiple sources.
 */
public abstract class MultiSourceCorpus extends AbstractCorpus {

    private final Context mContext;

    private final Executor mExecutor;

    private final ArrayList<Source> mSources;

    public MultiSourceCorpus(Context context, Executor executor, Source... sources) {
        mContext = context;
        mExecutor = executor;

        mSources = new ArrayList<Source>();
        for (Source source : sources) {
            if (source != null) {
                mSources.add(source);
            }
        }
    }

    protected Context getContext() {
        return mContext;
    }

    public Collection<Source> getSources() {
        return mSources;
    }

    /**
     * Creates a corpus result object for a set of source results.
     * This method should not call {@link Result#fill}.
     *
     * @param query The query text.
     * @param results The results of the queries.
     * @param latency Latency in milliseconds of the suggestion queries.
     * @return An instance of {@link Result} or a subclass of it.
     */
    protected Result createResult(String query, ArrayList<SourceResult> results, int latency) {
        return new Result(query, results, latency);
    }

    /**
     * Gets the sources to query for the given input.
     *
     * @param query The current input.
     * @return The sources to query.
     */
    protected List<Source> getSourcesToQuery(String query) {
        return mSources;
    }

    public CorpusResult getSuggestions(String query, int queryLimit) {
        LatencyTracker latencyTracker = new LatencyTracker();
        List<Source> sources = getSourcesToQuery(query);
        BarrierConsumer<SourceResult> consumer =
                new BarrierConsumer<SourceResult>(sources.size());
        for (Source source : sources) {
            QueryTask<SourceResult> task = new QueryTask<SourceResult>(query, queryLimit,
                    source, null, consumer);
            mExecutor.execute(task);
        }
        ArrayList<SourceResult> results = consumer.getValues();
        int latency = latencyTracker.getLatency();
        Result result = createResult(query, results, latency);
        result.fill();
        return result;
    }

    /**
     * Base class for results returned by {@link MultiSourceCorpus#getSuggestions}.
     * Subclasses of {@link MultiSourceCorpus} should override
     * {@link MultiSourceCorpus#createResult} and return an instance of this class or a
     * subclass.
     */
    protected class Result extends ListSuggestionCursor implements CorpusResult {

        private final ArrayList<SourceResult> mResults;

        private final int mLatency;

        public Result(String userQuery, ArrayList<SourceResult> results, int latency) {
            super(userQuery);
            mResults = results;
            mLatency = latency;
        }

        protected ArrayList<SourceResult> getResults() {
            return mResults;
        }

        /**
         * Fills the list of suggestions using the list of results.
         * The default implementation concatenates the results.
         */
        public void fill() {
            for (SourceResult result : getResults()) {
                int count = result.getCount();
                for (int i = 0; i < count; i++) {
                    result.moveTo(i);
                    add(new SuggestionPosition(result));
                }
            }
        }

        public Corpus getCorpus() {
            return MultiSourceCorpus.this;
        }

        public int getLatency() {
            return mLatency;
        }

        @Override
        public void close() {
            super.close();
            for (SourceResult result : mResults) {
                result.close();
            }
        }

        @Override
        public String toString() {
            return getCorpus() + ""["" + getUserQuery() + ""]"";
        }
    }

}
",False,35,6,4,2,12,2,12,L4
43,com.android.quicksearchbox.SuggestionData.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.google.common.annotations.VisibleForTesting;


/**
 * Holds data for each suggest item including the display data and how to launch the result.
 * Used for passing from the provider to the suggest cursor.
 */
public class SuggestionData {

    private final Source mSource;
    private String mFormat;
    private String mText1;
    private String mText2;
    private String mText2Url;
    private String mIcon1;
    private String mIcon2;
    private String mShortcutId;
    private boolean mSpinnerWhileRefreshing;
    private String mIntentAction;
    private String mIntentData;
    private String mIntentExtraData;
    private String mSuggestionQuery;
    private String mLogType;

    public SuggestionData(Source source) {
        mSource = source;
    }

    public Source getSuggestionSource() {
        return mSource;
    }

    public String getSuggestionFormat() {
        return mFormat;
    }

    public String getSuggestionText1() {
        return mText1;
    }

    public String getSuggestionText2() {
        return mText2;
    }

    public String getSuggestionText2Url() {
        return mText2Url;
    }

    public String getSuggestionIcon1() {
        return mIcon1;
    }

    public String getSuggestionIcon2() {
        return mIcon2;
    }

    public boolean isSpinnerWhileRefreshing() {
        return mSpinnerWhileRefreshing;
    }

    public String getIntentExtraData() {
        return mIntentExtraData;
    }

    public String getShortcutId() {
        return mShortcutId;
    }

    public String getSuggestionIntentAction() {
        return mIntentAction;
    }

    public String getSuggestionIntentDataString() {
        return mIntentData;
    }

    public String getSuggestionIntentExtraData() {
        return mIntentExtraData;
    }

    public String getSuggestionQuery() {
        return mSuggestionQuery;
    }

    public String getSuggestionLogType() {
        return mLogType;
    }

    @VisibleForTesting
    public SuggestionData setFormat(String format) {
        mFormat = format;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setText1(String text1) {
        mText1 = text1;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setText2(String text2) {
        mText2 = text2;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setText2Url(String text2Url) {
        mText2Url = text2Url;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIcon1(String icon1) {
        mIcon1 = icon1;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIcon2(String icon2) {
        mIcon2 = icon2;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIntentAction(String intentAction) {
        mIntentAction = intentAction;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIntentData(String intentData) {
        mIntentData = intentData;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIntentExtraData(String intentExtraData) {
        mIntentExtraData = intentExtraData;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setSuggestionQuery(String suggestionQuery) {
        mSuggestionQuery = suggestionQuery;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setShortcutId(String shortcutId) {
        mShortcutId = shortcutId;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setSpinnerWhileRefreshing(boolean spinnerWhileRefreshing) {
        mSpinnerWhileRefreshing = spinnerWhileRefreshing;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setSuggestionLogType(String logType) {
        mLogType = logType;
        return this;
    }

    private String makeKeyComponent(String str) {
        return str == null ? """" : str;
    }

    public String getSuggestionKey() {
        String action = makeKeyComponent(mIntentAction);
        String data = makeKeyComponent(mIntentData);
        String query = makeKeyComponent(mSuggestionQuery);
        // calculating accurate size of string builder avoids an allocation vs starting with
        // the default size and having to expand.
        int size = action.length() + 2 + data.length() + query.length();
        return new StringBuilder(size)
                .append(action)
                .append('#')
                .append(data)
                .append('#')
                .append(query)
                .toString();
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((mFormat == null) ? 0 : mFormat.hashCode());
        result = prime * result + ((mIcon1 == null) ? 0 : mIcon1.hashCode());
        result = prime * result + ((mIcon2 == null) ? 0 : mIcon2.hashCode());
        result = prime * result + ((mIntentAction == null) ? 0 : mIntentAction.hashCode());
        result = prime * result + ((mIntentData == null) ? 0 : mIntentData.hashCode());
        result = prime * result + ((mIntentExtraData == null) ? 0 : mIntentExtraData.hashCode());
        result = prime * result + ((mLogType == null) ? 0 : mLogType.hashCode());
        result = prime * result + ((mShortcutId == null) ? 0 : mShortcutId.hashCode());
        result = prime * result + ((mSource == null) ? 0 : mSource.hashCode());
        result = prime * result + (mSpinnerWhileRefreshing ? 1231 : 1237);
        result = prime * result + ((mSuggestionQuery == null) ? 0 : mSuggestionQuery.hashCode());
        result = prime * result + ((mText1 == null) ? 0 : mText1.hashCode());
        result = prime * result + ((mText2 == null) ? 0 : mText2.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        SuggestionData other = (SuggestionData)obj;
        if (mFormat == null) {
            if (other.mFormat != null)
                return false;
        } else if (!mFormat.equals(other.mFormat))
            return false;
        if (mIcon1 == null) {
            if (other.mIcon1 != null)
                return false;
        } else if (!mIcon1.equals(other.mIcon1))
            return false;
        if (mIcon2 == null) {
            if (other.mIcon2 != null)
                return false;
        } else if (!mIcon2.equals(other.mIcon2))
            return false;
        if (mIntentAction == null) {
            if (other.mIntentAction != null)
                return false;
        } else if (!mIntentAction.equals(other.mIntentAction))
            return false;
        if (mIntentData == null) {
            if (other.mIntentData != null)
                return false;
        } else if (!mIntentData.equals(other.mIntentData))
            return false;
        if (mIntentExtraData == null) {
            if (other.mIntentExtraData != null)
                return false;
        } else if (!mIntentExtraData.equals(other.mIntentExtraData))
            return false;
        if (mLogType == null) {
            if (other.mLogType != null)
                return false;
        } else if (!mLogType.equals(other.mLogType))
            return false;
        if (mShortcutId == null) {
            if (other.mShortcutId != null)
                return false;
        } else if (!mShortcutId.equals(other.mShortcutId))
            return false;
        if (mSource == null) {
            if (other.mSource != null)
                return false;
        } else if (!mSource.equals(other.mSource))
            return false;
        if (mSpinnerWhileRefreshing != other.mSpinnerWhileRefreshing)
            return false;
        if (mSuggestionQuery == null) {
            if (other.mSuggestionQuery != null)
                return false;
        } else if (!mSuggestionQuery.equals(other.mSuggestionQuery))
            return false;
        if (mText1 == null) {
            if (other.mText1 != null)
                return false;
        } else if (!mText1.equals(other.mText1))
            return false;
        if (mText2 == null) {
            if (other.mText2 != null)
                return false;
        } else if (!mText2.equals(other.mText2))
            return false;
        return true;
    }

    /**
     * Returns a string representation of the contents of this SuggestionData,
     * for debugging purposes.
     */
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder(""SuggestionData("");
        appendField(builder, ""source"", mSource.getName());
        appendField(builder, ""text1"", mText1);
        appendField(builder, ""intentAction"", mIntentAction);
        appendField(builder, ""intentData"", mIntentData);
        appendField(builder, ""query"", mSuggestionQuery);
        appendField(builder, ""shortcutid"", mShortcutId);
        appendField(builder, ""logtype"", mLogType);
        return builder.toString();
    }

    private void appendField(StringBuilder builder, String name, String value) {
        if (value != null) {
            builder.append("","").append(name).append(""="").append(value);
        }
    }

}
",True,63,4,36,2,2,11,2,L1
44,com.android.quicksearchbox.Source.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.ComponentName;
import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;

/**
 * Interface for suggestion sources.
 *
 */
public interface Source extends SuggestionCursorProvider<SourceResult> {

    /**
     * Gets the name of the activity that this source is for. When a suggestion is
     * clicked, the resulting intent will be sent to this activity.
     */
    ComponentName getComponentName();

    /**
     * Gets the version code of the source. This is expected to change when the app that
     * this source is for is upgraded.
     */
    int getVersionCode();

    /**
     * Gets the localized, human-readable label for this source.
     */
    CharSequence getLabel();

    /**
     * Gets the icon for this suggestion source.
     */
    Drawable getSourceIcon();

    /**
     * Gets the icon URI for this suggestion source.
     */
    Uri getSourceIconUri();

    /**
     * Gets an icon from this suggestion source.
     *
     * @param drawableId Resource ID or URI.
     */
    Drawable getIcon(String drawableId);

    /**
     * Gets the URI for an icon form this suggestion source.
     *
     * @param drawableId Resource ID or URI.
     */
    Uri getIconUri(String drawableId);

    /**
     * Gets the search hint text for this suggestion source.
     */
    CharSequence getHint();

    /**
     * Gets the description to use for this source in system search settings.
     */
    CharSequence getSettingsDescription();

    /**
     *
     *  Note: this does not guarantee that this source will be queried for queries of
     *  this length or longer, only that it will not be queried for anything shorter.
     *
     * @return The minimum number of characters needed to trigger this source.
     */
    int getQueryThreshold();

    /**
     * Indicates whether a source should be invoked for supersets of queries it has returned zero
     * results for in the past.  For example, if a source returned zero results for ""bo"", it would
     * be ignored for ""bob"".
     *
     * If set to <code>false</code>, this source will only be ignored for a single session; the next
     * time the search dialog is brought up, all sources will be queried.
     *
     * @return <code>true</code> if this source should be queried after returning no results.
     */
    boolean queryAfterZeroResults();

    boolean voiceSearchEnabled();

    Intent createSearchIntent(String query, Bundle appData);

    Intent createVoiceSearchIntent(Bundle appData);

    /**
     * Gets suggestions from this source.
     *
     * @param query The user query.
     * @param queryLimit An advisory maximum number of results that the source should return.
     * @return The suggestion results.
     */
    SourceResult getSuggestions(String query, int queryLimit);

    /**
     * Updates a shorcut.
     *
     * @param shortcutId The id of the shortcut to update.
     * @param extraData associated with this shortcut.
     * @return A SuggestionCursor positioned at the updated shortcut.  If the
     *         cursor is empty or <code>null</code>, the shortcut will be removed.
     */
    SuggestionCursor refreshShortcut(String shortcutId, String extraData);

    /**
     * Checks whether this is a web suggestion source.
     */
    boolean isWebSuggestionSource();

    /**
     * Checks whether the text in the query field should come from the suggestion intent data.
     */
    boolean shouldRewriteQueryFromData();

    /**
     * Checks whether the text in the query field should come from the suggestion title.
     */
    boolean shouldRewriteQueryFromText();

    /**
     * Gets the default intent action for suggestions from this source.
     *
     * @return The default intent action, or {@code null}.
     */
    String getDefaultIntentAction();

    /**
     * Gets the default intent data for suggestions from this source.
     *
     * @return The default intent data, or {@code null}.
     */
    String getDefaultIntentData();

}
",False,78,4,32,1,3,34,3,L0
45,com.android.quicksearchbox.RoundRobinPromoter.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.util.Log;

import java.util.ArrayList;

/**
 * A promoter that promotes one suggestion from each source.
 *
 */
public class RoundRobinPromoter implements Promoter {

    private static final String TAG = ""QSB.RoundRobinPromoter"";
    private static final boolean DBG = false;

    /**
     * Creates a new RoundRobinPromoter.
     */
    public RoundRobinPromoter() {
    }

    public void pickPromoted(SuggestionCursor shortcuts,
            ArrayList<CorpusResult> suggestions, int maxPromoted,
            ListSuggestionCursor promoted) {
        if (DBG) Log.d(TAG, ""pickPromoted(maxPromoted = "" + maxPromoted + "")"");
        final int sourceCount = suggestions.size();
        if (sourceCount == 0) return;
        int sourcePos = 0;
        int suggestionPos = 0;
        int maxCount = 0;
        // TODO: This is inefficient when there are several exhausted sources.
        while (promoted.getCount() < maxPromoted) {
            SuggestionCursor sourceResult = suggestions.get(sourcePos);
            int count = sourceResult.getCount();
            if (count > maxCount) maxCount = count;
            if (suggestionPos < count) {
                if (DBG) Log.d(TAG, ""Promoting "" + sourcePos + "":"" + suggestionPos);
                promoted.add(new SuggestionPosition(sourceResult, suggestionPos));
            }
            sourcePos++;
            if (sourcePos >= sourceCount) {
                sourcePos = 0;
                suggestionPos++;
                if (suggestionPos >= maxCount) break;
            }
        }
    }

}
",False,13,0,0,3,5,0,5,L7
46,com.android.quicksearchbox.IconLoader.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.ContentResolver;
import android.graphics.drawable.Drawable;
import android.net.Uri;

/**
 * Interface for icon loaders.
 *
 */
public interface IconLoader {

    /**
     * Gets a drawable given an ID.
     *
     * The ID could be just the string value of a resource id
     * (e.g., ""2130837524""), in which case we will try to retrieve a drawable from
     * the provider's resources. If the ID is not an integer, it is
     * treated as a Uri and opened with
     * {@link ContentResolver#openOutputStream(android.net.Uri, String)}.
     *
     * All resources and URIs are read using the suggestion provider's context.
     *
     * If the ID is not formatted as expected, or no drawable can be found for
     * the provided value, this method returns null.
     *
     * @param drawableId a string like ""2130837524"",
     *        ""android.resource://com.android.alarmclock/2130837524"",
     *        or ""content://contacts/photos/253"".
     * @return a Drawable, or {@code null} if none found
     */
    Drawable getIcon(String drawableId);

    /**
     * Converts a drawable ID to a Uri that can be used from other packages.
     */
    Uri getIconUri(String drawableId);

}
",False,22,6,7,0,0,7,0,L0
47,com.android.quicksearchbox.ListSuggestionCursor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.database.DataSetObservable;
import android.database.DataSetObserver;

import java.util.ArrayList;

/**
 * A SuggestionCursor that is backed by a list of SuggestionPosition objects.
 * This cursor does not own the SuggestionCursors that the SuggestionPosition
 * objects refer to.
 *
 */
public class ListSuggestionCursor extends AbstractSuggestionCursorWrapper {

    private final DataSetObservable mDataSetObservable = new DataSetObservable();

    private final ArrayList<SuggestionPosition> mSuggestions;

    private int mPos;

    public ListSuggestionCursor(String userQuery) {
        super(userQuery);
        mSuggestions = new ArrayList<SuggestionPosition>();
        mPos = 0;
    }

    /**
     * Adds a suggestion from another suggestion cursor.
     *
     * @param suggestionPos
     * @return {@code true} if the suggestion was added.
     */
    public boolean add(SuggestionPosition suggestionPos) {
        mSuggestions.add(suggestionPos);
        return true;
    }

    public void close() {
        mSuggestions.clear();
    }

    public int getPosition() {
        return mPos;
    }

    public void moveTo(int pos) {
        mPos = pos;
    }

    public boolean moveToNext() {
        int size = mSuggestions.size();
        if (mPos >= size) {
            // Already past the end
            return false;
        }
        mPos++;
        return mPos < size;
    }

    public void removeRow() {
        mSuggestions.remove(mPos);
    }

    public void replaceRow(SuggestionPosition suggestionPos) {
        mSuggestions.set(mPos, suggestionPos);
    }

    public int getCount() {
        return mSuggestions.size();
    }

    @Override
    protected SuggestionCursor current() {
        return mSuggestions.get(mPos).current();
    }

    @Override
    public String toString() {
        return ""["" + getUserQuery() + ""] "" + mSuggestions;
    }

    /**
     * Register an observer that is called when changes happen to this data set.
     *
     * @param observer gets notified when the data set changes.
     */
    public void registerDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.registerObserver(observer);
    }

    /**
     * Unregister an observer that has previously been registered with 
     * {@link #registerDataSetObserver(DataSetObserver)}
     *
     * @param observer the observer to unregister.
     */
    public void unregisterDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.unregisterObserver(observer);
    }

    protected void notifyDataSetChanged() {
        mDataSetObservable.notifyChanged();
    }
}
",False,46,5,14,3,4,14,4,L2
48,com.android.quicksearchbox.LatencyTracker.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.os.SystemClock;

/**
 * Tracks latency in wall-clock time. Since {@link #getLatency} returns an {@code int},
 * latencies over 2^31 ms (~ 25 days) cannot be measured.
 * This class uses {@link SystemClock#uptimeMillis} which does not advance during deep sleep.
 */
public class LatencyTracker {

    /**
     * Start time, in milliseconds as returned by {@link SystemClock#uptimeMillis}.
     */
    private long mStartTime;

    /**
     * Creates a new latency tracker and sets the start time.
     */
    public LatencyTracker() {
        mStartTime = SystemClock.uptimeMillis();
    }

    /**
     * Resets the start time.
     */
    public void reset() {
        mStartTime = SystemClock.uptimeMillis();
    }

    /**
     * Gets the number of milliseconds since the object was created, or {@link #reset} was called.
     */
    public int getLatency() {
        long now = SystemClock.uptimeMillis();
        return (int) (now - mStartTime);
    }

}
",False,19,6,7,0,0,3,0,L4
49,com.android.quicksearchbox.SearchActivity.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.common.Search;
import com.android.quicksearchbox.ui.CorpusViewFactory;
import com.android.quicksearchbox.ui.SuggestionClickListener;
import com.android.quicksearchbox.ui.SuggestionSelectionListener;
import com.android.quicksearchbox.ui.SuggestionsAdapter;
import com.android.quicksearchbox.ui.SuggestionsFooter;
import com.android.quicksearchbox.ui.SuggestionsView;

import android.app.Activity;
import android.app.SearchManager;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.os.Debug;
import android.os.Handler;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.Log;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.View;
import android.view.ViewGroup;
import android.view.View.OnFocusChangeListener;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;
import android.widget.ImageButton;

import java.io.File;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

/**
 * The main activity for Quick Search Box. Shows the search UI.
 *
 */
public class SearchActivity extends Activity {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SearchActivity"";
    private static final boolean TRACE = false;

    private static final String SCHEME_CORPUS = ""qsb.corpus"";

    public static final String INTENT_ACTION_QSB_AND_SELECT_CORPUS
            = ""com.android.quicksearchbox.action.QSB_AND_SELECT_CORPUS"";

    // The string used for privateImeOptions to identify to the IME that it should not show
    // a microphone button since one already exists in the search dialog.
    // TODO: This should move to android-common or something.
    private static final String IME_OPTION_NO_MICROPHONE = ""nm"";

    // Keys for the saved instance state.
    private static final String INSTANCE_KEY_CORPUS = ""corpus"";
    private static final String INSTANCE_KEY_USER_QUERY = ""query"";

    // Measures time from for last onCreate()/onNewIntent() call.
    private LatencyTracker mStartLatencyTracker;
    // Whether QSB is starting. True between the calls to onCreate()/onNewIntent() and onResume().
    private boolean mStarting;
    // True if the user has taken some action, e.g. launching a search, voice search,
    // or suggestions, since QSB was last started.
    private boolean mTookAction;

    private CorpusSelectionDialog mCorpusSelectionDialog;

    protected SuggestionsAdapter mSuggestionsAdapter;

    protected EditText mQueryTextView;
    // True if the query was empty on the previous call to updateQuery()
    protected boolean mQueryWasEmpty = true;

    protected SuggestionsView mSuggestionsView;
    protected SuggestionsFooter mSuggestionsFooter;

    protected ImageButton mSearchGoButton;
    protected ImageButton mVoiceSearchButton;
    protected ImageButton mCorpusIndicator;

    private Launcher mLauncher;

    private Corpus mCorpus;
    private Bundle mAppSearchData;
    private boolean mUpdateSuggestions;
    private String mUserQuery;
    private boolean mSelectAll;

    private Handler mHandler = new Handler();
    private Runnable mUpdateSuggestionsTask = new Runnable() {
        public void run() {
            updateSuggestions(getQuery());
        }
    };

    private Runnable mShowInputMethodTask = new Runnable() {
        public void run() {
            showInputMethodForQuery();
        }
    };

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        if (TRACE) startMethodTracing();
        recordStartTime();
        if (DBG) Log.d(TAG, ""onCreate()"");
        super.onCreate(savedInstanceState);

        setContentView(R.layout.search_activity);

        mSuggestionsAdapter = getQsbApplication().createSuggestionsAdapter();

        mQueryTextView = (EditText) findViewById(R.id.search_src_text);
        mSuggestionsView = (SuggestionsView) findViewById(R.id.suggestions);
        mSuggestionsView.setSuggestionClickListener(new ClickHandler());
        mSuggestionsView.setSuggestionSelectionListener(new SelectionHandler());
        mSuggestionsView.setInteractionListener(new InputMethodCloser());
        mSuggestionsView.setOnKeyListener(new SuggestionsViewKeyListener());
        mSuggestionsView.setOnFocusChangeListener(new SuggestListFocusListener());

        mSuggestionsFooter = getQsbApplication().createSuggestionsFooter();
        ViewGroup footerFrame = (ViewGroup) findViewById(R.id.footer);
        mSuggestionsFooter.addToContainer(footerFrame);

        mSearchGoButton = (ImageButton) findViewById(R.id.search_go_btn);
        mVoiceSearchButton = (ImageButton) findViewById(R.id.search_voice_btn);
        mCorpusIndicator = (ImageButton) findViewById(R.id.corpus_indicator);

        mLauncher = new Launcher(this);

        mQueryTextView.addTextChangedListener(new SearchTextWatcher());
        mQueryTextView.setOnKeyListener(new QueryTextViewKeyListener());
        mQueryTextView.setOnFocusChangeListener(new QueryTextViewFocusListener());

        mCorpusIndicator.setOnClickListener(new CorpusIndicatorClickListener());

        mSearchGoButton.setOnClickListener(new SearchGoButtonClickListener());

        mVoiceSearchButton.setOnClickListener(new VoiceSearchButtonClickListener());

        ButtonsKeyListener buttonsKeyListener = new ButtonsKeyListener();
        mSearchGoButton.setOnKeyListener(buttonsKeyListener);
        mVoiceSearchButton.setOnKeyListener(buttonsKeyListener);
        mCorpusIndicator.setOnKeyListener(buttonsKeyListener);

        mUpdateSuggestions = true;

        // First get setup from intent
        Intent intent = getIntent();
        setupFromIntent(intent);
        // Then restore any saved instance state
        restoreInstanceState(savedInstanceState);

        // Do this at the end, to avoid updating the list view when setSource()
        // is called.
        mSuggestionsView.setAdapter(mSuggestionsAdapter);
        mSuggestionsFooter.setAdapter(mSuggestionsAdapter);
    }

    private void startMethodTracing() {
        File traceDir = getDir(""traces"", 0);
        String traceFile = new File(traceDir, ""qsb.trace"").getAbsolutePath();
        Debug.startMethodTracing(traceFile);
    }

    @Override
    protected void onNewIntent(Intent intent) {
        recordStartTime();
        setIntent(intent);
        setupFromIntent(intent);
    }

    private void recordStartTime() {
        mStartLatencyTracker = new LatencyTracker();
        mStarting = true;
        mTookAction = false;
    }

    protected void restoreInstanceState(Bundle savedInstanceState) {
        if (savedInstanceState == null) return;
        String corpusName = savedInstanceState.getString(INSTANCE_KEY_CORPUS);
        String query = savedInstanceState.getString(INSTANCE_KEY_USER_QUERY);
        setCorpus(getCorpus(corpusName));
        setUserQuery(query);
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        // We don't save appSearchData, since we always get the value
        // from the intent and the user can't change it.

        String corpusName = mCorpus == null ? null : mCorpus.getName();
        outState.putString(INSTANCE_KEY_CORPUS, corpusName);
        outState.putString(INSTANCE_KEY_USER_QUERY, mUserQuery);
    }

    private void setupFromIntent(Intent intent) {
        if (DBG) Log.d(TAG, ""setupFromIntent("" + intent.toUri(0) + "")"");
        Corpus corpus = getCorpusFromUri(intent.getData());
        String query = intent.getStringExtra(SearchManager.QUERY);
        Bundle appSearchData = intent.getBundleExtra(SearchManager.APP_DATA);

        setCorpus(corpus);
        setUserQuery(query);
        mSelectAll = intent.getBooleanExtra(SearchManager.EXTRA_SELECT_QUERY, false);
        mAppSearchData = appSearchData;

        if (startedIntoCorpusSelectionDialog()) {
            showCorpusSelectionDialog();
        }
    }

    public boolean startedIntoCorpusSelectionDialog() {
        return INTENT_ACTION_QSB_AND_SELECT_CORPUS.equals(getIntent().getAction());
    }

    /**
     * Removes corpus selector intent action, so that BACK works normally after
     * dismissing and reopening the corpus selector.
     */
    private void clearStartedIntoCorpusSelectionDialog() {
        Intent oldIntent = getIntent();
        if (SearchActivity.INTENT_ACTION_QSB_AND_SELECT_CORPUS.equals(oldIntent.getAction())) {
            Intent newIntent = new Intent(oldIntent);
            newIntent.setAction(SearchManager.INTENT_ACTION_GLOBAL_SEARCH);
            setIntent(newIntent);
        }
    }

    public static Uri getCorpusUri(Corpus corpus) {
        if (corpus == null) return null;
        return new Uri.Builder()
                .scheme(SCHEME_CORPUS)
                .authority(corpus.getName())
                .build();
    }

    private Corpus getCorpusFromUri(Uri uri) {
        if (uri == null) return null;
        if (!SCHEME_CORPUS.equals(uri.getScheme())) return null;
        String name = uri.getAuthority();
        return getCorpus(name);
    }

    private Corpus getCorpus(String sourceName) {
        if (sourceName == null) return null;
        Corpus corpus = getCorpora().getCorpus(sourceName);
        if (corpus == null) {
            Log.w(TAG, ""Unknown corpus "" + sourceName);
            return null;
        }
        return corpus;
    }

    private void setCorpus(Corpus corpus) {
        if (DBG) Log.d(TAG, ""setCorpus("" + corpus + "")"");
        mCorpus = corpus;
        Drawable sourceIcon;
        if (corpus == null) {
            sourceIcon = getCorpusViewFactory().getGlobalSearchIcon();
        } else {
            sourceIcon = corpus.getCorpusIcon();
        }
        mSuggestionsAdapter.setCorpus(corpus);
        mCorpusIndicator.setImageDrawable(sourceIcon);

        updateUi(getQuery().length() == 0);
    }

    private QsbApplication getQsbApplication() {
        return (QsbApplication) getApplication();
    }

    private Config getConfig() {
        return getQsbApplication().getConfig();
    }

    private Corpora getCorpora() {
        return getQsbApplication().getCorpora();
    }

    private ShortcutRepository getShortcutRepository() {
        return getQsbApplication().getShortcutRepository();
    }

    private SuggestionsProvider getSuggestionsProvider() {
        return getQsbApplication().getSuggestionsProvider();
    }

    private CorpusRanker getCorpusRanker() {
        return getQsbApplication().getCorpusRanker();
    }

    private CorpusViewFactory getCorpusViewFactory() {
        return getQsbApplication().getCorpusViewFactory();
    }

    private Logger getLogger() {
        return getQsbApplication().getLogger();
    }

    @Override
    protected void onDestroy() {
        if (DBG) Log.d(TAG, ""onDestroy()"");
        super.onDestroy();
        mSuggestionsFooter.setAdapter(null);
        mSuggestionsView.setAdapter(null);  // closes mSuggestionsAdapter
    }

    @Override
    protected void onStop() {
        if (DBG) Log.d(TAG, ""onStop()"");
        if (!mTookAction) {
            // TODO: This gets logged when starting other activities, e.g. by opening he search
            // settings, or clicking a notification in the status bar.
            getLogger().logExit(getCurrentSuggestions(), getQuery().length());
        }
        // Close all open suggestion cursors. The query will be redone in onResume()
        // if we come back to this activity.
        mSuggestionsAdapter.setSuggestions(null);
        getQsbApplication().getShortcutRefresher().reset();
        dismissCorpusSelectionDialog();
        super.onStop();
    }

    @Override
    protected void onResume() {
        if (DBG) Log.d(TAG, ""onResume()"");
        super.onResume();
        setQuery(mUserQuery, mSelectAll);
        // Only select everything the first time after creating the activity.
        mSelectAll = false;
        updateSuggestionsBuffered();
        if (!isCorpusSelectionDialogShowing()) {
            mQueryTextView.requestFocus();
        }
        if (TRACE) Debug.stopMethodTracing();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        SearchSettings.addSearchSettingsMenuItem(this, menu);
        return true;
    }

    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        if (hasFocus) {
            // Launch the IME after a bit
            mHandler.postDelayed(mShowInputMethodTask, 0);
        }
    }

    /**
     * Sets the query as typed by the user. Does not update the suggestions
     * or the text in the query box.
     */
    protected void setUserQuery(String userQuery) {
        if (userQuery == null) userQuery = """";
        mUserQuery = userQuery;
    }

    protected String getQuery() {
        CharSequence q = mQueryTextView.getText();
        return q == null ? """" : q.toString();
    }

    /** 
     * Restores the query entered by the user.
     */
    private void restoreUserQuery() {
        if (DBG) Log.d(TAG, ""Restoring query to '"" + mUserQuery + ""'"");
        setQuery(mUserQuery, false);
    }

    /**
     * Sets the text in the query box. Does not update the suggestions,
     * and does not change the saved user-entered query.
     * {@link #restoreUserQuery()} will restore the query to the last
     * user-entered query.
     */
    private void setQuery(String query, boolean selectAll) {
        mUpdateSuggestions = false;
        mQueryTextView.setText(query);
        setTextSelection(selectAll);
        mUpdateSuggestions = true;
    }

    /**
     * Sets the text selection in the query text view.
     *
     * @param selectAll If {@code true}, selects the entire query.
     *        If {@false}, no characters are selected, and the cursor is placed
     *        at the end of the query.
     */
    private void setTextSelection(boolean selectAll) {
        if (selectAll) {
            mQueryTextView.selectAll();
        } else {
            mQueryTextView.setSelection(mQueryTextView.length());
        }
    }

    private void updateUi(boolean queryEmpty) {
        updateQueryTextView(queryEmpty);
        updateSearchGoButton(queryEmpty);
        updateVoiceSearchButton(queryEmpty);
    }

    private void updateQueryTextView(boolean queryEmpty) {
        if (queryEmpty) {
            if (mCorpus == null || mCorpus.isWebCorpus()) {
                mQueryTextView.setBackgroundResource(R.drawable.textfield_search_empty_google);
                mQueryTextView.setHint(null);
            } else {
                mQueryTextView.setBackgroundResource(R.drawable.textfield_search_empty);
                mQueryTextView.setHint(mCorpus.getHint());
            }
        } else {
            mQueryTextView.setBackgroundResource(R.drawable.textfield_search);
        }
    }

    private void updateSearchGoButton(boolean queryEmpty) {
        if (queryEmpty) {
            mSearchGoButton.setVisibility(View.GONE);
        } else {
            mSearchGoButton.setVisibility(View.VISIBLE);
        }
    }

    protected void updateVoiceSearchButton(boolean queryEmpty) {
        if (queryEmpty && mLauncher.shouldShowVoiceSearch(mCorpus)) {
            mVoiceSearchButton.setVisibility(View.VISIBLE);
            mQueryTextView.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
        } else {
            mVoiceSearchButton.setVisibility(View.GONE);
            mQueryTextView.setPrivateImeOptions(null);
        }
    }

    protected void showCorpusSelectionDialog() {
        if (mCorpusSelectionDialog == null) {
            mCorpusSelectionDialog = new CorpusSelectionDialog(this);
            mCorpusSelectionDialog.setOwnerActivity(this);
            mCorpusSelectionDialog.setOnDismissListener(new CorpusSelectorDismissListener());
            mCorpusSelectionDialog.setOnCorpusSelectedListener(new CorpusSelectionListener());
        }
        mCorpusSelectionDialog.show(mCorpus);
    }

    protected boolean isCorpusSelectionDialogShowing() {
        return mCorpusSelectionDialog != null && mCorpusSelectionDialog.isShowing();
    }

    protected void dismissCorpusSelectionDialog() {
        if (mCorpusSelectionDialog != null) {
            mCorpusSelectionDialog.dismiss();
        }
    }

    protected void onSearchClicked(int method) {
        String query = getQuery();
        if (DBG) Log.d(TAG, ""Search clicked, query="" + query);

        // Don't do empty queries
        if (TextUtils.getTrimmedLength(query) == 0) return;

        Corpus searchCorpus = mLauncher.getSearchCorpus(getCorpora(), mCorpus);
        if (searchCorpus == null) return;

        mTookAction = true;

        // Log search start
        getLogger().logSearch(mCorpus, method, query.length());

        // Create shortcut
        SuggestionData searchShortcut = searchCorpus.createSearchShortcut(query);
        if (searchShortcut != null) {
            DataSuggestionCursor cursor = new DataSuggestionCursor(query);
            cursor.add(searchShortcut);
            getShortcutRepository().reportClick(cursor, 0);
        }

        // Start search
        Intent intent = searchCorpus.createSearchIntent(query, mAppSearchData);
        mLauncher.launchIntent(intent);
    }

    protected void onVoiceSearchClicked() {
        if (DBG) Log.d(TAG, ""Voice Search clicked"");
        Corpus searchCorpus = mLauncher.getSearchCorpus(getCorpora(), mCorpus);
        if (searchCorpus == null) return;

        mTookAction = true;

        // Log voice search start
        getLogger().logVoiceSearch(searchCorpus);

        // Start voice search
        Intent intent = searchCorpus.createVoiceSearchIntent(mAppSearchData);
        mLauncher.launchIntent(intent);
    }

    protected SuggestionCursor getCurrentSuggestions() {
        return mSuggestionsAdapter.getCurrentSuggestions();
    }

    protected boolean launchSuggestion(int position) {
        SuggestionCursor suggestions = getCurrentSuggestions();
        if (position < 0 || position >= suggestions.getCount()) {
            Log.w(TAG, ""Tried to launch invalid suggestion "" + position);
            return false;
        }

        if (DBG) Log.d(TAG, ""Launching suggestion "" + position);
        mTookAction = true;

        // Log suggestion click
        Collection<Corpus> corpora = mSuggestionsAdapter.getSuggestions().getIncludedCorpora();
        getLogger().logSuggestionClick(position, suggestions, corpora);

        // Create shortcut
        getShortcutRepository().reportClick(suggestions, position);

        // Launch intent
        Intent intent = mLauncher.getSuggestionIntent(suggestions, position, mAppSearchData);
        mLauncher.launchIntent(intent);

        return true;
    }

    protected boolean onSuggestionLongClicked(int position) {
        if (DBG) Log.d(TAG, ""Long clicked on suggestion "" + position);
        return false;
    }

    protected boolean onSuggestionKeyDown(int position, int keyCode, KeyEvent event) {
        // Treat enter or search as a click
        if (keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_SEARCH) {
            return launchSuggestion(position);
        }

        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && position == 0) {
            // Moved up from the top suggestion, restore the user query and focus query box
            if (DBG) Log.d(TAG, ""Up and out"");
            restoreUserQuery();
            return false;  // let the framework handle the move
        }

        if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT
                || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {
            // Moved left / right from a suggestion, keep current query, move
            // focus to query box, and move cursor to far left / right
            if (DBG) Log.d(TAG, ""Left/right on a suggestion"");
            String query = getQuery();
            int cursorPos = (keyCode == KeyEvent.KEYCODE_DPAD_LEFT) ? 0 : query.length();
            mQueryTextView.setSelection(cursorPos);
            mQueryTextView.requestFocus();
            updateSuggestions(query);
            return true;
        }

        return false;
    }

    protected void onSourceSelected() {
        if (DBG) Log.d(TAG, ""No suggestion selected"");
        restoreUserQuery();
    }

    protected int getSelectedPosition() {
        return mSuggestionsView.getSelectedPosition();
    }

    /**
     * Hides the input method.
     */
    protected void hideInputMethod() {
        InputMethodManager imm = (InputMethodManager) getSystemService(INPUT_METHOD_SERVICE);
        if (imm != null) {
            imm.hideSoftInputFromWindow(mQueryTextView.getWindowToken(), 0);
        }
    }

    protected void showInputMethodForQuery() {
        InputMethodManager imm = (InputMethodManager) getSystemService(INPUT_METHOD_SERVICE);
        if (imm != null) {
            imm.showSoftInput(mQueryTextView, 0);
        }
    }

    /**
     * Hides the input method when the suggestions get focus.
     */
    private class SuggestListFocusListener implements OnFocusChangeListener {
        public void onFocusChange(View v, boolean focused) {
            if (DBG) Log.d(TAG, ""Suggestions focus change, now: "" + focused);
            if (focused) {
                // The suggestions list got focus, hide the input method
                hideInputMethod();
            }
        }
    }

    private class QueryTextViewFocusListener implements OnFocusChangeListener {
        public void onFocusChange(View v, boolean focused) {
            if (DBG) Log.d(TAG, ""Query focus change, now: "" + focused);
            if (focused) {
                // The query box got focus, show the input method
                showInputMethodForQuery();
            }
        }
    }

    private List<Corpus> getCorporaToQuery() {
        if (mCorpus == null) {
            return getCorpusRanker().getRankedCorpora();
        } else {
            return Collections.singletonList(mCorpus);
        }
    }

    private int getMaxSuggestions() {
        Config config = getConfig();
        return mCorpus == null
                ? config.getMaxPromotedSuggestions()
                : config.getMaxResultsPerSource();
    }

    private void updateSuggestionsBuffered() {
        mHandler.removeCallbacks(mUpdateSuggestionsTask);
        long delay = getConfig().getTypingUpdateSuggestionsDelayMillis();
        mHandler.postDelayed(mUpdateSuggestionsTask, delay);
    }

    private void updateSuggestions(String query) {
        // Log start latency if this is the first suggestions update
        if (mStarting) {
            mStarting = false;
            String source = getIntent().getStringExtra(Search.SOURCE);
            List<Corpus> rankedCorpora = getCorpusRanker().getRankedCorpora();
            int latency = mStartLatencyTracker.getLatency();
            getLogger().logStart(latency, source, mCorpus, rankedCorpora);
        }

        query = ltrim(query);
        List<Corpus> corporaToQuery = getCorporaToQuery();
        Suggestions suggestions = getSuggestionsProvider().getSuggestions(
                query, corporaToQuery, getMaxSuggestions());
        mSuggestionsAdapter.setSuggestions(suggestions);
    }

    private boolean forwardKeyToQueryTextView(int keyCode, KeyEvent event) {
        if (!event.isSystem() && !isDpadKey(keyCode)) {
            if (DBG) Log.d(TAG, ""Forwarding key to query box: "" + event);
            if (mQueryTextView.requestFocus()) {
                return mQueryTextView.dispatchKeyEvent(event);
            }
        }
        return false;
    }

    private boolean isDpadKey(int keyCode) {
        switch (keyCode) {
            case KeyEvent.KEYCODE_DPAD_UP:
            case KeyEvent.KEYCODE_DPAD_DOWN:
            case KeyEvent.KEYCODE_DPAD_LEFT:
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            case KeyEvent.KEYCODE_DPAD_CENTER:
                return true;
            default:
                return false;
        }
    }

    /**
     * Filters the suggestions list when the search text changes.
     */
    private class SearchTextWatcher implements TextWatcher {
        public void afterTextChanged(Editable s) {
            boolean empty = s.length() == 0;
            if (empty != mQueryWasEmpty) {
                mQueryWasEmpty = empty;
                updateUi(empty);
            }
            if (mUpdateSuggestions) {
                String query = s == null ? """" : s.toString();
                setUserQuery(query);
                updateSuggestionsBuffered();
            }
        }

        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
        }

        public void onTextChanged(CharSequence s, int start, int before, int count) {
        }
    }

    /**
     * Handles non-text keys in the query text view.
     */
    private class QueryTextViewKeyListener implements View.OnKeyListener {
        public boolean onKey(View view, int keyCode, KeyEvent event) {
            // Handle IME search action key
            if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_UP) {
                onSearchClicked(Logger.SEARCH_METHOD_KEYBOARD);
            }
            return false;
        }
    }

    /**
     * Handles key events on the search and voice search buttons,
     * by refocusing to EditText.
     */
    private class ButtonsKeyListener implements View.OnKeyListener {
        public boolean onKey(View v, int keyCode, KeyEvent event) {
            return forwardKeyToQueryTextView(keyCode, event);
        }
    }

    /**
     * Handles key events on the suggestions list view.
     */
    private class SuggestionsViewKeyListener implements View.OnKeyListener {
        public boolean onKey(View v, int keyCode, KeyEvent event) {
            if (event.getAction() == KeyEvent.ACTION_DOWN) {
                int position = getSelectedPosition();
                if (onSuggestionKeyDown(position, keyCode, event)) {
                        return true;
                }
            }
            return forwardKeyToQueryTextView(keyCode, event);
        }
    }

    private class InputMethodCloser implements SuggestionsView.InteractionListener {
        public void onInteraction() {
            hideInputMethod();
        }
    }

    private class ClickHandler implements SuggestionClickListener {
       public void onSuggestionClicked(int position) {
           launchSuggestion(position);
       }

       public boolean onSuggestionLongClicked(int position) {
           return SearchActivity.this.onSuggestionLongClicked(position);
       }
    }

    private class SelectionHandler implements SuggestionSelectionListener {
        public void onSuggestionSelected(int position) {
            SuggestionCursor suggestions = getCurrentSuggestions();
            suggestions.moveTo(position);
            String displayQuery = suggestions.getSuggestionDisplayQuery();
            if (TextUtils.isEmpty(displayQuery)) {
                restoreUserQuery();
            } else {
                setQuery(displayQuery, false);
            }
        }

        public void onNothingSelected() {
                // This happens when a suggestion has been selected with the
                // dpad / trackball and then a different UI element is touched.
                // Do nothing, since we want to keep the query of the selection
                // in the search box.
        }
    }

    /**
     * Listens for clicks on the source selector.
     */
    private class SearchGoButtonClickListener implements View.OnClickListener {
        public void onClick(View view) {
            onSearchClicked(Logger.SEARCH_METHOD_BUTTON);
        }
    }

    /**
     * Listens for clicks on the search button.
     */
    private class CorpusIndicatorClickListener implements View.OnClickListener {
        public void onClick(View view) {
            showCorpusSelectionDialog();
        }
    }

    private class CorpusSelectorDismissListener implements DialogInterface.OnDismissListener {
        public void onDismiss(DialogInterface dialog) {
            if (DBG) Log.d(TAG, ""Corpus selector dismissed"");
            clearStartedIntoCorpusSelectionDialog();
        }
    }

    private class CorpusSelectionListener
            implements CorpusSelectionDialog.OnCorpusSelectedListener {
        public void onCorpusSelected(Corpus corpus) {
            setCorpus(corpus);
            updateSuggestions(getQuery());
            mQueryTextView.requestFocus();
            showInputMethodForQuery();
        }
    }

    /**
     * Listens for clicks on the voice search button.
     */
    private class VoiceSearchButtonClickListener implements View.OnClickListener {
        public void onClick(View view) {
            onVoiceSearchClicked();
        }
    }

    private static String ltrim(String text) {
        int start = 0;
        int length = text.length();
        while (start < length && Character.isWhitespace(text.charAt(start))) {
            start++;
        }
        return start > 0 ? text.substring(start, length) : text;
    }

}
",True,84,2,2,5,32,3,24,L6
50,com.android.quicksearchbox.RankAwarePromoter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.util.Log;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;

/**
 * A promoter that gives preference to suggestions from higher ranking corpora.
 */
public class RankAwarePromoter implements Promoter {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.RankAwarePromoter"";

    private final Config mConfig;
    private final Corpora mCorpora;

    public RankAwarePromoter(Config config, Corpora corpora) {
        mConfig = config;
        mCorpora = corpora;
    }

    public void pickPromoted(SuggestionCursor shortcuts, ArrayList<CorpusResult> suggestions,
            int maxPromoted, ListSuggestionCursor promoted) {

        if (DBG) Log.d(TAG, ""Available results: "" + suggestions);

        // Split non-empty results into default sources and other, positioned at first suggestion
        LinkedList<CorpusResult> defaultResults = new LinkedList<CorpusResult>();
        LinkedList<CorpusResult> otherResults = new LinkedList<CorpusResult>();
        for (CorpusResult result : suggestions) {
            if (result.getCount() > 0) {
                result.moveTo(0);
                if (mCorpora.isCorpusDefaultEnabled(result.getCorpus())) {
                    defaultResults.add(result);
                } else {
                    otherResults.add(result);
                }
            }
        }

        // Share the top slots equally among each of the default corpora
        if (maxPromoted > 0 && !defaultResults.isEmpty()) {
            int slotsToFill = Math.min(getSlotsAboveKeyboard() - promoted.getCount(), maxPromoted);
            if (slotsToFill > 0) {
                int stripeSize = Math.max(1, slotsToFill / defaultResults.size());
                maxPromoted -= roundRobin(defaultResults, slotsToFill, stripeSize, promoted);
            }
        }

        // Then try to fill with the remaining promoted results
        if (maxPromoted > 0 && !defaultResults.isEmpty()) {
            int stripeSize = Math.max(1, maxPromoted / defaultResults.size());
            maxPromoted -= roundRobin(defaultResults, maxPromoted, stripeSize, promoted);
            // We may still have a few slots left
            maxPromoted -= roundRobin(defaultResults, maxPromoted, maxPromoted, promoted);
        }

        // Then try to fill with the rest
        if (maxPromoted > 0 && !otherResults.isEmpty()) {
            int stripeSize = Math.max(1, maxPromoted / otherResults.size());
            maxPromoted -= roundRobin(otherResults, maxPromoted, stripeSize, promoted);
            // We may still have a few slots left
            maxPromoted -= roundRobin(otherResults, maxPromoted, maxPromoted, promoted);
        }

        if (DBG) Log.d(TAG, ""Returning "" + promoted.toString());
    }

    private int getSlotsAboveKeyboard() {
        return mConfig.getNumSuggestionsAboveKeyboard();
    }

    /**
     * Promotes ""stripes"" of suggestions from each corpus.
     *
     * @param results     the list of CorpusResults from which to promote.
     *                    Exhausted CorpusResults are removed from the list.
     * @param maxPromoted maximum number of suggestions to promote.
     * @param stripeSize  number of suggestions to take from each corpus.
     * @param promoted    the list to which promoted suggestions are added.
     * @return the number of suggestions actually promoted.
     */
    private int roundRobin(LinkedList<CorpusResult> results, int maxPromoted, int stripeSize,
            ListSuggestionCursor promoted) {
        int count = 0;
        if (maxPromoted > 0 && !results.isEmpty()) {
            for (Iterator<CorpusResult> iter = results.iterator();
                 count < maxPromoted && iter.hasNext();) {
                CorpusResult result = iter.next();
                count += promote(result, stripeSize, promoted);
                if (result.getPosition() == result.getCount()) {
                    iter.remove();
                }
            }
        }
        return count;
    }

    /**
     * Copies suggestions from a SuggestionCursor to the list of promoted suggestions.
     *
     * @param cursor from which to copy the suggestions
     * @param count maximum number of suggestions to copy
     * @param promoted the list to which to add the suggestions
     * @return the number of suggestions actually copied.
     */
    private int promote(SuggestionCursor cursor, int count, ListSuggestionCursor promoted) {
        if (count < 1 || cursor.getPosition() >= cursor.getCount()) {
            return 0;
        }
        int i = 0;
        do {
            promoted.add(new SuggestionPosition(cursor));
            i++;
        } while (cursor.moveToNext() && i < count);
        return i;
    }
}
",True,31,5,5,3,7,2,7,L4
51,com.android.quicksearchbox.AbstractCorpusRanker.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.database.DataSetObservable;
import android.database.DataSetObserver;

import java.util.Collections;
import java.util.List;

/**
 * Abstract base class for corpus rankers.
 */
public abstract class AbstractCorpusRanker implements CorpusRanker {

    private final DataSetObservable mDataSetObservable = new DataSetObservable();

    private final Corpora mCorpora;

    // Cached list of ranked corpora. Set to null when mCorpora changes.
    private List<Corpus> mRankedCorpora;

    public AbstractCorpusRanker(Corpora corpora) {
        mCorpora = corpora;
        mCorpora.registerDataSetObserver(new CorporaObserver());
    }

    /**
     * Creates a ranked list of corpora.
     */
    protected abstract List<Corpus> rankCorpora(Corpora corpora);

    public List<Corpus> getRankedCorpora() {
        if (mRankedCorpora == null) {
            mRankedCorpora = Collections.unmodifiableList(rankCorpora(mCorpora));
        }
        return mRankedCorpora;
    }

    public void registerDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.registerObserver(observer);
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.unregisterObserver(observer);
    }

    protected void notifyDataSetChanged() {
        mDataSetObservable.notifyChanged();
    }

    private class CorporaObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            mRankedCorpora = null;
            notifyDataSetChanged();
        }
    }
}
",False,27,6,5,3,4,2,3,L4
52,com.android.quicksearchbox.CorpusFactory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import java.util.Collection;

/**
 * Creates corpora.
 */
public interface CorpusFactory {

    Collection<Corpus> createCorpora(Sources sources);

}
",False,25,5,6,3,4,4,2,L5
53,com.android.quicksearchbox.DefaultCorpusRanker.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.util.Log;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

public class DefaultCorpusRanker extends AbstractCorpusRanker {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.DefaultCorpusRanker"";

    private final ShortcutRepository mShortcuts;

    public DefaultCorpusRanker(Corpora corpora, ShortcutRepository shortcuts) {
        super(corpora);
        mShortcuts = shortcuts;
    }

    private static class CorpusComparator implements Comparator<Corpus> {
        private final Corpora mCorpora;
        private final Map<String,Integer> mClickScores;

        public CorpusComparator(Corpora corpora, Map<String,Integer> clickScores) {
            mCorpora = corpora;
            mClickScores = clickScores;
        }

        public int compare(Corpus corpus1, Corpus corpus2) {
            boolean corpus1IsDefault = mCorpora.isCorpusDefaultEnabled(corpus1);
            boolean corpus2IsDefault = mCorpora.isCorpusDefaultEnabled(corpus2);

            if (corpus1IsDefault != corpus2IsDefault) {
                // Default corpora always come before non-default
                return corpus1IsDefault ? -1 : 1;
            } else {
                // Then by descending score
                return getCorpusScore(corpus2) - getCorpusScore(corpus1);
            }
        }

        /**
         * Scores a corpus. Higher score is better.
         */
        private int getCorpusScore(Corpus corpus) {
            // Web corpus always comes first
            if (corpus.isWebCorpus()) {
                return Integer.MAX_VALUE;
            }
            // Then use click score
            Integer clickScore = mClickScores.get(corpus.getName());
            if (clickScore != null) {
                return clickScore;
            }
            return 0;
        }
    }

    @Override
    public List<Corpus> rankCorpora(Corpora corpora) {
        Collection<Corpus> enabledCorpora = corpora.getEnabledCorpora();
        if (DBG) Log.d(TAG, ""Ranking: "" + enabledCorpora);

        Map<String,Integer> clickScores = mShortcuts.getCorpusScores();
        ArrayList<Corpus> ordered = new ArrayList<Corpus>(enabledCorpora);
        Collections.sort(ordered, new CorpusComparator(corpora, clickScores));

        if (DBG) Log.d(TAG, ""Click scores: "" + clickScores);
        if (DBG) Log.d(TAG, ""Ordered: "" + ordered);
        return ordered;
    }

}
",False,27,5,5,3,5,1,5,L5
54,com.android.quicksearchbox.SearchableSource.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.Util;

import android.app.PendingIntent;
import android.app.SearchManager;
import android.app.SearchableInfo;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PathPermission;
import android.content.pm.ProviderInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.database.Cursor;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.speech.RecognizerIntent;
import android.util.Log;

import java.util.Arrays;

/**
 * Represents a single suggestion source, e.g. Contacts.
 *
 */
public class SearchableSource implements Source {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SearchableSource"";

    // TODO: This should be exposed or moved to android-common, see http://b/issue?id=2440614
    // The extra key used in an intent to the speech recognizer for in-app voice search.
    private static final String EXTRA_CALLING_PACKAGE = ""calling_package"";

    private final Context mContext;

    private final SearchableInfo mSearchable;

    private final String mName;

    private final ActivityInfo mActivityInfo;

    private final int mVersionCode;

    // Cached label for the activity
    private CharSequence mLabel = null;

    // Cached icon for the activity
    private Drawable.ConstantState mSourceIcon = null;

    private final IconLoader mIconLoader;

    public SearchableSource(Context context, SearchableInfo searchable)
            throws NameNotFoundException {
        ComponentName componentName = searchable.getSearchActivity();
        mContext = context;
        mSearchable = searchable;
        mName = componentName.flattenToShortString();
        PackageManager pm = context.getPackageManager();
        mActivityInfo = pm.getActivityInfo(componentName, 0);
        PackageInfo pkgInfo = pm.getPackageInfo(componentName.getPackageName(), 0);
        mVersionCode = pkgInfo.versionCode;
        mIconLoader = createIconLoader(context, searchable.getSuggestPackage());
    }

    protected Context getContext() {
        return mContext;
    }

    protected SearchableInfo getSearchableInfo() {
        return mSearchable;
    }

    /**
     * Checks if the current process can read the suggestion provider in this source.
     */
    public boolean canRead() {
        String authority = mSearchable.getSuggestAuthority();
        if (authority == null) {
            Log.w(TAG, getName() + "" has no searchSuggestAuthority"");
            return false;
        }

        Uri.Builder uriBuilder = new Uri.Builder()
                .scheme(ContentResolver.SCHEME_CONTENT)
                .authority(authority);
        // if content path provided, insert it now
        String contentPath = mSearchable.getSuggestPath();
        if (contentPath != null) {
            uriBuilder.appendEncodedPath(contentPath);
        }
        // append standard suggestion query path
        uriBuilder.appendEncodedPath(SearchManager.SUGGEST_URI_PATH_QUERY);
        Uri uri = uriBuilder.build();
        return canRead(uri);
    }

    /**
     * Checks if the current process can read the given content URI.
     *
     * TODO: Shouldn't this be a PackageManager / Context / ContentResolver method?
     */
    private boolean canRead(Uri uri) {
        ProviderInfo provider = mContext.getPackageManager().resolveContentProvider(
                uri.getAuthority(), 0);
        if (provider == null) {
            Log.w(TAG, getName() + "" has bad suggestion authority "" + uri.getAuthority());
            return false;
        }
        String readPermission = provider.readPermission;
        if (readPermission == null) {
            // No permission required to read anything in the content provider
            return true;
        }
        int pid = android.os.Process.myPid();
        int uid = android.os.Process.myUid();
        if (mContext.checkPermission(readPermission, pid, uid)
                == PackageManager.PERMISSION_GRANTED) {
            // We have permission to read everything in the content provider
            return true;
        }
        PathPermission[] pathPermissions = provider.pathPermissions;
        if (pathPermissions == null || pathPermissions.length == 0) {
            // We don't have the readPermission, and there are no pathPermissions
            if (DBG) Log.d(TAG, ""Missing "" + readPermission);
            return false;
        }
        String path = uri.getPath();
        for (PathPermission perm : pathPermissions) {
            String pathReadPermission = perm.getReadPermission();
            if (pathReadPermission != null
                    && perm.match(path)
                    && mContext.checkPermission(pathReadPermission, pid, uid)
                            == PackageManager.PERMISSION_GRANTED) {
                // We have the path permission
                return true;
            }
        }
        if (DBG) Log.d(TAG, ""Missing "" + readPermission + "" and no path permission applies"");
        return false;
    }

    private IconLoader createIconLoader(Context context, String providerPackage) {
        if (providerPackage == null) return null;
        return new CachingIconLoader(new PackageIconLoader(context, providerPackage));
    }

    public ComponentName getComponentName() {
        return mSearchable.getSearchActivity();
    }

    public int getVersionCode() {
        return mVersionCode;
    }

    public String getName() {
        return mName;
    }

    public Drawable getIcon(String drawableId) {
        return mIconLoader == null ? null : mIconLoader.getIcon(drawableId);
    }

    public Uri getIconUri(String drawableId) {
        return mIconLoader == null ? null : mIconLoader.getIconUri(drawableId);
    }

    public CharSequence getLabel() {
        if (mLabel == null) {
            // Load label lazily
            mLabel = mActivityInfo.loadLabel(mContext.getPackageManager());
        }
        return mLabel;
    }

    public CharSequence getHint() {
        return getText(mSearchable.getHintId());
    }

    public int getQueryThreshold() {
        return mSearchable.getSuggestThreshold();
    }

    public CharSequence getSettingsDescription() {
        return getText(mSearchable.getSettingsDescriptionId());
    }

    public Drawable getSourceIcon() {
        if (mSourceIcon == null) {
            // Load icon lazily
            int iconRes = getSourceIconResource();
            PackageManager pm = mContext.getPackageManager();
            Drawable icon = pm.getDrawable(mActivityInfo.packageName, iconRes,
                    mActivityInfo.applicationInfo);
            // Can't share Drawable instances, save constant state instead.
            mSourceIcon = (icon != null) ? icon.getConstantState() : null;
            // Optimization, return the Drawable the first time
            return icon;
        }
        return (mSourceIcon != null) ? mSourceIcon.newDrawable() : null;
    }

    public Uri getSourceIconUri() {
        int resourceId = getSourceIconResource();
        return Util.getResourceUri(getContext(), mActivityInfo.applicationInfo, resourceId);
    }

    private int getSourceIconResource() {
        int icon = mActivityInfo.getIconResource();
        return (icon != 0) ? icon : android.R.drawable.sym_def_app_icon;
    }

    public boolean voiceSearchEnabled() {
        return mSearchable.getVoiceSearchEnabled();
    }

    public Intent createSearchIntent(String query, Bundle appData) {
        return createSourceSearchIntent(getComponentName(), query, appData);
    }

    public static Intent createSourceSearchIntent(ComponentName activity, String query,
            Bundle appData) {
        if (activity == null) {
            Log.w(TAG, ""Tried to create search intent with no target activity"");
            return null;
        }
        Intent intent = new Intent(Intent.ACTION_SEARCH);
        intent.setComponent(activity);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        // We need CLEAR_TOP to avoid reusing an old task that has other activities
        // on top of the one we want.
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
        intent.putExtra(SearchManager.USER_QUERY, query);
        intent.putExtra(SearchManager.QUERY, query);
        if (appData != null) {
            intent.putExtra(SearchManager.APP_DATA, appData);
        }
        return intent;
    }

    public Intent createVoiceSearchIntent(Bundle appData) {
        if (mSearchable.getVoiceSearchLaunchWebSearch()) {
            return WebCorpus.createVoiceWebSearchIntent(appData);
        } else if (mSearchable.getVoiceSearchLaunchRecognizer()) {
            return createVoiceAppSearchIntent(appData);
        }
        return null;
    }

    /**
     * Create and return an Intent that can launch the voice search activity, perform a specific
     * voice transcription, and forward the results to the searchable activity.
     *
     * This code is copied from SearchDialog
     *
     * @return A completely-configured intent ready to send to the voice search activity
     */
    private Intent createVoiceAppSearchIntent(Bundle appData) {
        ComponentName searchActivity = mSearchable.getSearchActivity();

        // create the necessary intent to set up a search-and-forward operation
        // in the voice search system.   We have to keep the bundle separate,
        // because it becomes immutable once it enters the PendingIntent
        Intent queryIntent = new Intent(Intent.ACTION_SEARCH);
        queryIntent.setComponent(searchActivity);
        PendingIntent pending = PendingIntent.getActivity(
                getContext(), 0, queryIntent, PendingIntent.FLAG_ONE_SHOT);

        // Now set up the bundle that will be inserted into the pending intent
        // when it's time to do the search.  We always build it here (even if empty)
        // because the voice search activity will always need to insert ""QUERY"" into
        // it anyway.
        Bundle queryExtras = new Bundle();
        if (appData != null) {
            queryExtras.putBundle(SearchManager.APP_DATA, appData);
        }

        // Now build the intent to launch the voice search.  Add all necessary
        // extras to launch the voice recognizer, and then all the necessary extras
        // to forward the results to the searchable activity
        Intent voiceIntent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
        voiceIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        // Add all of the configuration options supplied by the searchable's metadata
        String languageModel = getString(mSearchable.getVoiceLanguageModeId());
        if (languageModel == null) {
            languageModel = RecognizerIntent.LANGUAGE_MODEL_FREE_FORM;
        }
        String prompt = getString(mSearchable.getVoicePromptTextId());
        String language = getString(mSearchable.getVoiceLanguageId());
        int maxResults = mSearchable.getVoiceMaxResults();
        if (maxResults <= 0) {
            maxResults = 1;
        }

        voiceIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, languageModel);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_PROMPT, prompt);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE, language);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, maxResults);
        voiceIntent.putExtra(EXTRA_CALLING_PACKAGE,
                searchActivity == null ? null : searchActivity.toShortString());

        // Add the values that configure forwarding the results
        voiceIntent.putExtra(RecognizerIntent.EXTRA_RESULTS_PENDINGINTENT, pending);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_RESULTS_PENDINGINTENT_BUNDLE, queryExtras);

        return voiceIntent;
    }

    public SourceResult getSuggestions(String query, int queryLimit) {
        try {
            Cursor cursor = getSuggestions(mContext, mSearchable, query, queryLimit);
            if (DBG) Log.d(TAG, toString() + ""["" + query + ""] returned."");
            return new CursorBackedSourceResult(query, cursor);
        } catch (RuntimeException ex) {
            Log.e(TAG, toString() + ""["" + query + ""] failed"", ex);
            return new CursorBackedSourceResult(query);
        }
    }

    public SuggestionCursor refreshShortcut(String shortcutId, String extraData) {
        Cursor cursor = null;
        try {
            cursor = getValidationCursor(mContext, mSearchable, shortcutId, extraData);
            if (DBG) Log.d(TAG, toString() + ""["" + shortcutId + ""] returned."");
            if (cursor != null && cursor.getCount() > 0) {
                cursor.moveToFirst();
            }
            return new CursorBackedSourceResult(null, cursor);
        } catch (RuntimeException ex) {
            Log.e(TAG, toString() + ""["" + shortcutId + ""] failed"", ex);
            if (cursor != null) {
                cursor.close();
            }
            // TODO: Should we delete the shortcut even if the failure is temporary?
            return null;
        }
    }

    private class CursorBackedSourceResult extends CursorBackedSuggestionCursor
            implements SourceResult {

        public CursorBackedSourceResult(String userQuery) {
            this(userQuery, null);
        }

        public CursorBackedSourceResult(String userQuery, Cursor cursor) {
            super(userQuery, cursor);
        }

        public Source getSource() {
            return SearchableSource.this;
        }

        @Override
        public Source getSuggestionSource() {
            return SearchableSource.this;
        }

        public boolean isSuggestionShortcut() {
            return false;
        }

        @Override
        public String toString() {
            return SearchableSource.this + ""["" + getUserQuery() + ""]"";
        }

    }

    /**
     * This is a copy of {@link SearchManager#getSuggestions(SearchableInfo, String)}.
     */
    private static Cursor getSuggestions(Context context, SearchableInfo searchable, String query,
            int queryLimit) {
        if (searchable == null) {
            return null;
        }

        String authority = searchable.getSuggestAuthority();
        if (authority == null) {
            return null;
        }

        Uri.Builder uriBuilder = new Uri.Builder()
                .scheme(ContentResolver.SCHEME_CONTENT)
                .authority(authority);

        // if content path provided, insert it now
        final String contentPath = searchable.getSuggestPath();
        if (contentPath != null) {
            uriBuilder.appendEncodedPath(contentPath);
        }

        // append standard suggestion query path
        uriBuilder.appendPath(SearchManager.SUGGEST_URI_PATH_QUERY);

        // get the query selection, may be null
        String selection = searchable.getSuggestSelection();
        // inject query, either as selection args or inline
        String[] selArgs = null;
        if (selection != null) {    // use selection if provided
            selArgs = new String[] { query };
        } else {                    // no selection, use REST pattern
            uriBuilder.appendPath(query);
        }

        uriBuilder.appendQueryParameter(""limit"", String.valueOf(queryLimit));

        Uri uri = uriBuilder.build();

        // finally, make the query
        if (DBG) {
            Log.d(TAG, ""query("" + uri + "",null,"" + selection + "",""
                    + Arrays.toString(selArgs) + "",null)"");
        }
        return context.getContentResolver().query(uri, null, selection, selArgs, null);
    }

    private static Cursor getValidationCursor(Context context, SearchableInfo searchable,
            String shortcutId, String extraData) {
        String authority = searchable.getSuggestAuthority();
        if (authority == null) {
            return null;
        }

        Uri.Builder uriBuilder = new Uri.Builder()
                .scheme(ContentResolver.SCHEME_CONTENT)
                .authority(authority);

        // if content path provided, insert it now
        final String contentPath = searchable.getSuggestPath();
        if (contentPath != null) {
            uriBuilder.appendEncodedPath(contentPath);
        }

        // append the shortcut path and id
        uriBuilder.appendPath(SearchManager.SUGGEST_URI_PATH_SHORTCUT);
        uriBuilder.appendPath(shortcutId);

        Uri uri = uriBuilder
                .appendQueryParameter(SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA, extraData)
                .build();

        if (DBG) Log.d(TAG, ""Requesting refresh "" + uri);
        // finally, make the query
        return context.getContentResolver().query(uri, null, null, null, null);
    }

    public boolean isWebSuggestionSource() {
        return false;
    }

    public boolean queryAfterZeroResults() {
        return mSearchable.queryAfterZeroResults();
    }

    public boolean shouldRewriteQueryFromData() {
        return mSearchable.shouldRewriteQueryFromData();
    }

    public boolean shouldRewriteQueryFromText() {
        return mSearchable.shouldRewriteQueryFromText();
    }

    @Override
    public boolean equals(Object o) {
        if (o != null && o.getClass().equals(this.getClass())) {
            SearchableSource s = (SearchableSource) o;
            return s.mName.equals(mName);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return mName.hashCode();
    }

    @Override
    public String toString() {
        return ""SearchableSource{component="" + getName() + ""}"";
    }

    public String getDefaultIntentAction() {
        return mSearchable.getSuggestIntentAction();
    }

    public String getDefaultIntentData() {
        return mSearchable.getSuggestIntentData();
    }

    private CharSequence getText(int id) {
        if (id == 0) return null;
        return mContext.getPackageManager().getText(mActivityInfo.packageName, id,
                mActivityInfo.applicationInfo);
    }

    private String getString(int id) {
        CharSequence text = getText(id);
        return text == null ? null : text.toString();
    }
}
",True,73,0,0,7,33,2,10,L5
55,com.android.quicksearchbox.SuggestionCursorWrapper.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.database.DataSetObserver;

/**
 * A suggestion cursor that delegates all methods to another SuggestionCursor.
 */
public class SuggestionCursorWrapper extends AbstractSuggestionCursorWrapper {

    private final SuggestionCursor mCursor;

    public SuggestionCursorWrapper(String userQuery, SuggestionCursor cursor) {
        super(userQuery);
        mCursor = cursor;
    }

    public void close() {
        if (mCursor != null) {
            mCursor.close();
        }
    }

    public int getCount() {
        return mCursor == null ? 0 : mCursor.getCount();
    }

    public int getPosition() {
        return mCursor == null ? 0 : mCursor.getPosition();
    }

    public void moveTo(int pos) {
        if (mCursor != null) {
            mCursor.moveTo(pos);
        }
    }

    public boolean moveToNext() {
        if (mCursor != null) {
            return mCursor.moveToNext();
        } else {
            return false;
        }
    }

    public void registerDataSetObserver(DataSetObserver observer) {
        if (mCursor != null) {
            mCursor.registerDataSetObserver(observer);
        }
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
        if (mCursor != null) {
            mCursor.unregisterDataSetObserver(observer);
        }
    }

    @Override
    protected SuggestionCursor current() {
        return mCursor;
    }

}
",False,35,8,11,3,2,3,2,L2
56,com.android.quicksearchbox.SourceResult.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

/**
 * The result of getting suggestions from a single source.
 */
public interface SourceResult extends SuggestionCursor {

    Source getSource();

}
",False,32,5,12,2,2,6,2,L0
57,com.android.quicksearchbox.SuggestionCursorProvider.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * Interface for objects that can produce a SuggestionCursor given a query.
 */
public interface SuggestionCursorProvider<C extends SuggestionCursor> {

    /**
     * Gets the name of the provider. This is used for logging and
     * to execute tasks on the queue for the provider.
     */
    String getName();

    /**
     * Gets suggestions from the provider.
     *
     * @param query The user query.
     * @param queryLimit An advisory maximum number of results that the source should return.
     * @return The suggestion results.
     */
    C getSuggestions(String query, int queryLimit);
}
",False,66,4,32,3,1,22,1,L0
58,com.android.quicksearchbox.Suggestions.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.google.common.annotations.VisibleForTesting;

import android.database.DataSetObservable;
import android.database.DataSetObserver;
import android.util.Log;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

/**
 * Contains all {@link SuggestionCursor} objects that have been reported.
 */
public class Suggestions {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.Suggestions"";

    private final int mMaxPromoted;

    private final String mQuery;

    /** The number of sources that are expected to report. */
    private final int mExpectedCorpusCount;

    /**
     * The observers that want notifications of changes to the published suggestions.
     * This object may be accessed on any thread.
     */
    private final DataSetObservable mDataSetObservable = new DataSetObservable();

    /**
     * All {@link SuggestionCursor} objects that have been published so far,
     * in the order that they were published.
     * This object may only be accessed on the UI thread.
     * */
    private final ArrayList<CorpusResult> mCorpusResults;

    private SuggestionCursor mShortcuts;

    private MyShortcutsObserver mShortcutsObserver = new MyShortcutsObserver();

    /** True if {@link Suggestions#close} has been called. */
    private boolean mClosed = false;

    private final Promoter mPromoter;

    private ListSuggestionCursor mPromoted;

    /**
     * Creates a new empty Suggestions.
     *
     * @param expectedCorpusCount The number of sources that are expected to report.
     */
    public Suggestions(Promoter promoter, int maxPromoted,
            String query, int expectedCorpusCount) {
        mPromoter = promoter;
        mMaxPromoted = maxPromoted;
        mQuery = query;
        mExpectedCorpusCount = expectedCorpusCount;
        mCorpusResults = new ArrayList<CorpusResult>(mExpectedCorpusCount);
        mPromoted = null;  // will be set by updatePromoted()
    }

    @VisibleForTesting
    public String getQuery() {
        return mQuery;
    }

    /**
     * Gets the number of sources that are expected to report.
     */
    @VisibleForTesting
    public int getExpectedSourceCount() {
        return mExpectedCorpusCount;
    }

    /**
     * Registers an observer that will be notified when the reported results or
     * the done status changes.
     */
    public void registerDataSetObserver(DataSetObserver observer) {
        if (mClosed) {
            throw new IllegalStateException(""registerDataSetObserver() when closed"");
        }
        mDataSetObservable.registerObserver(observer);
    }

    /**
     * Unregisters an observer.
     */
    public void unregisterDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.unregisterObserver(observer);
    }

    public SuggestionCursor getPromoted() {
        if (mPromoted == null) {
            updatePromoted();
        }
        return mPromoted;
    }

    /**
     * Gets the set of corpora that have reported results to this suggestions set.
     *
     * @return A collection of corpora.
     */
    public Set<Corpus> getIncludedCorpora() {
        HashSet<Corpus> corpora = new HashSet<Corpus>();
        for (CorpusResult result : mCorpusResults) {
            corpora.add(result.getCorpus());
        }
        return corpora;
    }

    /**
     * Calls {@link DataSetObserver#onChanged()} on all observers.
     */
    private void notifyDataSetChanged() {
        if (DBG) Log.d(TAG, ""notifyDataSetChanged()"");
        mDataSetObservable.notifyChanged();
    }

    /**
     * Closes all the source results and unregisters all observers.
     */
    public void close() {
        if (DBG) Log.d(TAG, ""close()"");
        if (mClosed) {
            throw new IllegalStateException(""Double close()"");
        }
        mDataSetObservable.unregisterAll();
        mClosed = true;
        if (mShortcuts != null) {
            mShortcuts.close();
            mShortcuts = null;
        }
        for (CorpusResult result : mCorpusResults) {
            result.close();
        }
        mCorpusResults.clear();
    }

    public boolean isClosed() {
        return mClosed;
    }

    @Override
    protected void finalize() {
        if (!mClosed) {
            Log.e(TAG, ""LEAK! Finalized without being closed: Suggestions["" + mQuery + ""]"");
        }
    }

    /**
     * Checks whether all sources have reported.
     * Must be called on the UI thread, or before this object is seen by the UI thread.
     */
    public boolean isDone() {
        // TODO: Handle early completion because we have all the results we want.
        return mCorpusResults.size() >= mExpectedCorpusCount;
    }

    /**
     * Sets the shortcut suggestions.
     * Must be called on the UI thread, or before this object is seen by the UI thread.
     *
     * @param shortcuts The shortcuts.
     */
    public void setShortcuts(SuggestionCursor shortcuts) {
        if (DBG) Log.d(TAG, ""setShortcuts("" + shortcuts + "")"");
        mShortcuts = shortcuts;
        if (shortcuts != null) {
            mShortcuts.registerDataSetObserver(mShortcutsObserver);
        }
    }

    /**
     * Adds a corpus result. Must be called on the UI thread, or before this
     * object is seen by the UI thread.
     */
    public void addCorpusResult(CorpusResult corpusResult) {
        if (mClosed) {
            corpusResult.close();
            return;
        }
        if (!mQuery.equals(corpusResult.getUserQuery())) {
          throw new IllegalArgumentException(""Got result for wrong query: ""
                + mQuery + "" != "" + corpusResult.getUserQuery());
        }
        mCorpusResults.add(corpusResult);
        mPromoted = null;
        notifyDataSetChanged();
    }

    private void updatePromoted() {
        mPromoted = new ListSuggestionCursorNoDuplicates(mQuery);
        if (mPromoter == null) {
            return;
        }
        mPromoter.pickPromoted(mShortcuts, mCorpusResults, mMaxPromoted, mPromoted);
    }

    /**
     * Gets the number of source results.
     * Must be called on the UI thread, or before this object is seen by the UI thread.
     */
    public int getSourceCount() {
        if (mClosed) {
            throw new IllegalStateException(""Called getSourceCount() when closed."");
        }
        return mCorpusResults == null ? 0 : mCorpusResults.size();
    }

    private class MyShortcutsObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            mPromoted = null;
            notifyDataSetChanged();
        }
    }

}
",True,36,6,7,3,6,7,6,L4
59,com.android.quicksearchbox.SingleSourceCorpus.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Context;
import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;

import java.util.Collection;
import java.util.Collections;

/**
 * A corpus that uses a single source.
 */
public class SingleSourceCorpus extends AbstractCorpus {

    private final Context mContext;

    private final Source mSource;

    public SingleSourceCorpus(Context context, Source source) {
        mContext = context;
        mSource = source;
    }

    protected Context getContext() {
        return mContext;
    }

    public Drawable getCorpusIcon() {
        return mSource.getSourceIcon();
    }

    public Uri getCorpusIconUri() {
        return mSource.getSourceIconUri();
    }

    public CharSequence getLabel() {
        return mSource.getLabel();
    }

    public CharSequence getHint() {
        return mSource.getHint();
    }

    public CharSequence getSettingsDescription() {
        return mSource.getSettingsDescription();
    }

    public CorpusResult getSuggestions(String query, int queryLimit) {
        LatencyTracker latencyTracker = new LatencyTracker();
        SourceResult sourceResult = mSource.getSuggestions(query, queryLimit);
        int latency = latencyTracker.getLatency();
        return new SingleSourceCorpusResult(this, query, sourceResult, latency);
    }

    public String getName() {
        return mSource.getName();
    }

    public boolean queryAfterZeroResults() {
        return mSource.queryAfterZeroResults();
    }

    public int getQueryThreshold() {
        return mSource.getQueryThreshold();
    }

    public boolean voiceSearchEnabled() {
        return mSource.voiceSearchEnabled();
    }

    public Intent createSearchIntent(String query, Bundle appData) {
        return mSource.createSearchIntent(query, appData);
    }

    public Intent createVoiceSearchIntent(Bundle appData) {
        return mSource.createVoiceSearchIntent(appData);
    }

    public SuggestionData createSearchShortcut(String query) {
        // We don't make shortcuts for searches in app corpora
        return null;
    }

    public boolean isWebCorpus() {
        return false;
    }

    public Collection<Source> getSources() {
        return Collections.singletonList(mSource);
    }

}
",False,29,6,5,3,8,2,8,L5
60,com.android.quicksearchbox.google.GoogleSettings.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.google;

import com.android.quicksearchbox.R;
import com.android.quicksearchbox.SearchSettings;

import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.Preference;
import android.preference.PreferenceActivity;
import android.preference.PreferenceScreen;
import android.preference.Preference.OnPreferenceClickListener;

/**
 * Activity for setting Google search preferences.
 */
public class GoogleSettings extends PreferenceActivity implements OnPreferenceClickListener {

    private static final String SHOW_WEB_SUGGESTIONS_PREF = ""show_web_suggestions"";

    private CheckBoxPreference mShowWebSuggestionsPreference;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        addPreferencesFromResource(R.xml.google_preferences);
        PreferenceScreen preferenceScreen = getPreferenceScreen();
        mShowWebSuggestionsPreference = (CheckBoxPreference)
                findPreference(SHOW_WEB_SUGGESTIONS_PREF);
        mShowWebSuggestionsPreference.setOnPreferenceClickListener(this);
        updateShowWebSuggestionsPreference();
    }

    /**
     * Updates the ""show web suggestions"" preference from the value in system settings.
     */
    private void updateShowWebSuggestionsPreference() {
        boolean showWebSuggestions = SearchSettings.getShowWebSuggestions(this);
        mShowWebSuggestionsPreference.setChecked(showWebSuggestions);
    }

    /**
     * Stores the ""show web suggestions"" preference to the system settings.
     */
    private void storeShowWebSuggestionsPreference() {
        boolean showWebSuggestions = mShowWebSuggestionsPreference.isChecked();
        SearchSettings.setShowWebSuggestions(this, showWebSuggestions);
    }

    public boolean onPreferenceClick(Preference preference) {
        if (preference == mShowWebSuggestionsPreference) {
            storeShowWebSuggestionsPreference();
            return true;
        }
        return false;
    }

}
",False,74,0,0,6,35,0,1,L7
61,com.android.quicksearchbox.google.GoogleSuggestionProvider.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.google;

import com.android.quicksearchbox.R;

import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.params.HttpParams;
import org.apache.http.util.EntityUtils;
import org.json.JSONArray;
import org.json.JSONException;

import android.app.SearchManager;
import android.content.ContentProvider;
import android.content.ContentValues;
import android.content.Context;
import android.database.AbstractCursor;
import android.database.Cursor;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.net.http.AndroidHttpClient;
import android.text.TextUtils;
import android.util.Log;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Locale;

/**
 * Use network-based Google Suggests to provide search suggestions.
 *
 * Future:  Merge live suggestions with saved recent queries
 */
public class GoogleSuggestionProvider extends ContentProvider {

    private static final boolean DBG = false;
    private static final String LOG_TAG = ""GoogleSearch"";

    private static final String USER_AGENT = ""Android/1.0"";
    private String mSuggestUri;
    private static final int HTTP_TIMEOUT_MS = 1000;

    // TODO: this should be defined somewhere
    private static final String HTTP_TIMEOUT = ""http.connection-manager.timeout"";

    // Indexes into COLUMNS
    private static final int COL_ID = 0;
    private static final int COL_TEXT_1 = 1;
    private static final int COL_TEXT_2 = 2;
    private static final int COL_ICON_1 = 3;
    private static final int COL_ICON_2 = 4;
    private static final int COL_QUERY = 5;

    /* The suggestion columns used */
    private static final String[] COLUMNS = new String[] {
        ""_id"",
        SearchManager.SUGGEST_COLUMN_TEXT_1,
        SearchManager.SUGGEST_COLUMN_TEXT_2,
        SearchManager.SUGGEST_COLUMN_ICON_1,
        SearchManager.SUGGEST_COLUMN_ICON_2,
        SearchManager.SUGGEST_COLUMN_QUERY
    };

    private HttpClient mHttpClient;

    @Override
    public boolean onCreate() {
        mHttpClient = AndroidHttpClient.newInstance(USER_AGENT, getContext());
        HttpParams params = mHttpClient.getParams();
        params.setLongParameter(HTTP_TIMEOUT, HTTP_TIMEOUT_MS);

        // NOTE:  Do not look up the resource here;  Localization changes may not have completed
        // yet (e.g. we may still be reading the SIM card).
        mSuggestUri = null;
        return true;
    }

    /**
     * This will always return {@link SearchManager#SUGGEST_MIME_TYPE} as this
     * provider is purely to provide suggestions.
     */
    @Override
    public String getType(Uri uri) {
        return SearchManager.SUGGEST_MIME_TYPE;
    }

    /**
     * Queries for a given search term and returns a cursor containing
     * suggestions ordered by best match.
     */
    @Override
    public Cursor query(Uri uri, String[] projection, String selection,
            String[] selectionArgs, String sortOrder) {
        String query = getQuery(uri);
        if (TextUtils.isEmpty(query)) {
            return null;
        }
        if (!isNetworkConnected()) {
            Log.i(LOG_TAG, ""Not connected to network."");
            return null;
        }
        try {
            query = URLEncoder.encode(query, ""UTF-8"");
            // NOTE:  This code uses resources to optionally select the search Uri, based on the
            // MCC value from the SIM.  iThe default string will most likely be fine.  It is
            // paramerterized to accept info from the Locale, the language code is the first
            // parameter (%1$s) and the country code is the second (%2$s).  This code *must*
            // function in the same way as a similar lookup in
            // com.android.browser.BrowserActivity#onCreate().  If you change
            // either of these functions, change them both.  (The same is true for the underlying
            // resource strings, which are stored in mcc-specific xml files.)
            if (mSuggestUri == null) {
                Locale l = Locale.getDefault();
                String language = l.getLanguage();
                String country = l.getCountry().toLowerCase();
                // Chinese and Portuguese have two langauge variants.
                if (""zh"".equals(language)) {
                    if (""cn"".equals(country)) {
                        language = ""zh-CN"";
                    } else if (""tw"".equals(country)) {
                        language = ""zh-TW"";
                    }
                } else if (""pt"".equals(language)) {
                    if (""br"".equals(country)) {
                        language = ""pt-BR"";
                    } else if (""pt"".equals(country)) {
                        language = ""pt-PT"";
                    }
                }
                mSuggestUri = getContext().getResources().getString(R.string.google_suggest_base,
                                                                    language,
                                                                    country)
                        + ""json=true&q="";
            }

            String suggestUri = mSuggestUri + query;
            if (DBG) Log.d(LOG_TAG, ""Sending request: "" + suggestUri);
            HttpGet method = new HttpGet(suggestUri);
            HttpResponse response = mHttpClient.execute(method);
            if (response.getStatusLine().getStatusCode() == 200) {

                /* Goto http://www.google.com/complete/search?json=true&q=foo
                 * to see what the data format looks like. It's basically a json
                 * array containing 4 other arrays. We only care about the middle
                 * 2 which contain the suggestions and their popularity.
                 */
                JSONArray results = new JSONArray(EntityUtils.toString(response.getEntity()));
                JSONArray suggestions = results.getJSONArray(1);
                JSONArray popularity = results.getJSONArray(2);
                if (DBG) Log.d(LOG_TAG, ""Got "" + suggestions.length() + "" results"");
                return new SuggestionsCursor(suggestions, popularity);
            } else {
                if (DBG) Log.d(LOG_TAG, ""Request failed "" + response.getStatusLine());
            }
        } catch (UnsupportedEncodingException e) {
            Log.w(LOG_TAG, ""Error"", e);
        } catch (IOException e) {
            Log.w(LOG_TAG, ""Error"", e);
        } catch (JSONException e) {
            Log.w(LOG_TAG, ""Error"", e);
        }
        return null;
    }

    /**
     * Gets the search text from a uri.
     */
    private String getQuery(Uri uri) {
        if (uri.getPathSegments().size() > 1) {
            return uri.getLastPathSegment();
        } else {
            return """";
        }
    }

    private boolean isNetworkConnected() {
        NetworkInfo networkInfo = getActiveNetworkInfo();
        return networkInfo != null && networkInfo.isConnected();
    }

    private NetworkInfo getActiveNetworkInfo() {
        ConnectivityManager connectivity =
                (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);
        if (connectivity == null) {
            return null;
        }
        return connectivity.getActiveNetworkInfo();
    }

    private static class SuggestionsCursor extends AbstractCursor {

        /* Contains the actual suggestions */
        final JSONArray mSuggestions;

        /* This contains the popularity of each suggestion
         * i.e. 165,000 results. It's not related to sorting.
         */
        final JSONArray mPopularity;
        public SuggestionsCursor(JSONArray suggestions, JSONArray popularity) {
            mSuggestions = suggestions;
            mPopularity = popularity;
        }

        @Override
        public int getCount() {
            return mSuggestions.length();
        }

        @Override
        public String[] getColumnNames() {
            return COLUMNS;
        }

        @Override
        public String getString(int column) {
            if (mPos == -1) return null;
            try {
                switch (column) {
                    case COL_ID:
                        return String.valueOf(mPos);
                    case COL_TEXT_1:
                    case COL_QUERY:
                        return mSuggestions.getString(mPos);
                    case COL_TEXT_2:
                        return mPopularity.getString(mPos);
                    case COL_ICON_1:
                        return String.valueOf(R.drawable.magnifying_glass);
                    case COL_ICON_2:
                        return null;
                    default:
                        Log.w(LOG_TAG, ""Bad column: "" + column);
                        return null;
                }
            } catch (JSONException e) {
                Log.w(LOG_TAG, ""Error parsing response: "" + e);
                return null;
            }

        }

        @Override
        public double getDouble(int column) {
            throw new UnsupportedOperationException();
        }

        @Override
        public float getFloat(int column) {
            throw new UnsupportedOperationException();
        }

        @Override
        public int getInt(int column) {
            throw new UnsupportedOperationException();
        }

        @Override
        public long getLong(int column) {
            if (column == COL_ID) {
                return mPos;        // use row# as the _Id
            }
            throw new UnsupportedOperationException();
        }

        @Override
        public short getShort(int column) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean isNull(int column) {
            throw new UnsupportedOperationException();
        }
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection,
            String[] selectionArgs) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        throw new UnsupportedOperationException();
    }
}
",True,1,0,0,0,0,0,0,I0
62,com.android.quicksearchbox.google.GoogleSearch.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.google;

import com.android.common.Search;
import com.android.quicksearchbox.R;

import android.app.Activity;
import android.app.SearchManager;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.provider.Browser;
import android.text.TextUtils;
import android.util.Log;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Locale;

/**
 * This class is purely here to get search queries and route them to
 * the global {@link Intent#ACTION_WEB_SEARCH}.
 */
public class GoogleSearch extends Activity {
    private static final String TAG = ""GoogleSearch"";

    // The template URL we should use to format google search requests.
    private String googleSearchUrlBase = null;

    // ""source"" parameter for Google search requests from unknown sources (e.g. apps). This will get
    // prefixed with the string 'android-' before being sent on the wire.
    final static String GOOGLE_SEARCH_SOURCE_UNKNOWN = ""unknown"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Intent intent = getIntent();
        String action = intent != null ? intent.getAction() : null;
        if (Intent.ACTION_WEB_SEARCH.equals(action) || Intent.ACTION_SEARCH.equals(action)) {
            handleWebSearchIntent(intent);
        }
        finish();
    }

    /**
     * NOTE: This function is similar to the one found in
     * com.google.android.providers.enhancedgooglesearch.Launcher. If you are changing this
     * make sure you change both.
     */
    private void handleWebSearchIntent(Intent intent) {
        String query = intent.getStringExtra(SearchManager.QUERY);
        if (TextUtils.isEmpty(query)) {
            Log.w(TAG, ""Got search intent with no query."");
            return;
        }

        if (googleSearchUrlBase == null) {
            Locale l = Locale.getDefault();
            String language = l.getLanguage();
            String country = l.getCountry().toLowerCase();
            // Chinese and Portuguese have two langauge variants.
            if (""zh"".equals(language)) {
                if (""cn"".equals(country)) {
                    language = ""zh-CN"";
                } else if (""tw"".equals(country)) {
                    language = ""zh-TW"";
                }
            } else if (""pt"".equals(language)) {
                if (""br"".equals(country)) {
                    language = ""pt-BR"";
                } else if (""pt"".equals(country)) {
                    language = ""pt-PT"";
                }
            }
            googleSearchUrlBase = getResources().getString(
                    R.string.google_search_base, language, country);
        }

        // If the caller specified a 'source' url parameter, use that and if not use default.
        Bundle appSearchData = intent.getBundleExtra(SearchManager.APP_DATA);
        String source = GOOGLE_SEARCH_SOURCE_UNKNOWN;
        if (appSearchData != null) {
            source = appSearchData.getString(Search.SOURCE);
        }
        
        // The browser can pass along an application id which it uses to figure out which
        // window to place a new search into. So if this exists, we'll pass it back to
        // the browser. Otherwise, add our own package name as the application id, so that
        // the browser can organize all searches launched from this provider together.
        String applicationId = intent.getStringExtra(Browser.EXTRA_APPLICATION_ID);
        if (applicationId == null) {
            applicationId = getPackageName();
        }

        try {
            String searchUri = googleSearchUrlBase
                    + ""&source=android-"" + source
                    + ""&q="" + URLEncoder.encode(query, ""UTF-8"");
            Intent launchUriIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(searchUri));
            launchUriIntent.putExtra(Browser.EXTRA_APPLICATION_ID, applicationId);
            launchUriIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startActivity(launchUriIntent);
        } catch (UnsupportedEncodingException e) {
            Log.w(TAG, ""Error"", e);
        }
    }

}
",False,1,0,0,0,0,0,0,I0
63,com.android.quicksearchbox.util.Consumer.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

/**
 * Interface for data consumers.
 *
 * @param <A> The type of data to consume.
 */
public interface Consumer<A> {

    /**
     * Consumes a value.
     *
     * @param value The value to consume.
     * @return {@code true} if the value was accepted, {@code false} otherwise.
     */
    boolean consume(A value);

}
",False,21,5,7,0,0,3,0,L4
64,com.android.quicksearchbox.util.Util.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.net.Uri;
import android.util.Log;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * General utilities.
 */
public class Util {

    private static final String TAG = ""QSB.Util"";

    public static <A> Set<A> setOfFirstN(List<A> list, int n) {
        int end = Math.min(list.size(), n);
        HashSet<A> set = new HashSet<A>(end);
        for (int i = 0; i < end; i++) {
            set.add(list.get(i));
        }
        return set;
    }

    public static Uri getResourceUri(Context packageContext, int res) {
        try {
            Resources resources = packageContext.getResources();
            return getResourceUri(resources, packageContext.getPackageName(), res);
        } catch (Resources.NotFoundException e) {
            Log.e(TAG, ""Resource not found: "" + res + "" in "" + packageContext.getPackageName());
            return null;
        }
    }

    public static Uri getResourceUri(Context context, ApplicationInfo appInfo, int res) {
        try {
            Resources resources = context.getPackageManager().getResourcesForApplication(appInfo);
            return getResourceUri(resources, appInfo.packageName, res);
        } catch (PackageManager.NameNotFoundException e) {
            Log.e(TAG, ""Resources not found for "" + appInfo.packageName);
            return null;
        } catch (Resources.NotFoundException e) {
            Log.e(TAG, ""Resource not found: "" + res + "" in "" + appInfo.packageName);
            return null;
        }
    }

    private static Uri getResourceUri(Resources resources, String appPkg, int res)
            throws Resources.NotFoundException {
        String resPkg = resources.getResourcePackageName(res);
        String type = resources.getResourceTypeName(res);
        String name = resources.getResourceEntryName(res);
        return makeResourceUri(appPkg, resPkg, type, name);
    }

    private static Uri makeResourceUri(String appPkg, String resPkg, String type, String name) {
        Uri.Builder uriBuilder = new Uri.Builder();
        uriBuilder.scheme(ContentResolver.SCHEME_ANDROID_RESOURCE);
        uriBuilder.encodedAuthority(appPkg);
        uriBuilder.appendEncodedPath(type);
        if (!appPkg.equals(resPkg)) {
            uriBuilder.appendEncodedPath(resPkg + "":"" + name);
        } else {
            uriBuilder.appendEncodedPath(name);
        }
        return uriBuilder.build();
    }
}
",False,22,5,8,0,0,8,0,L0
65,com.android.quicksearchbox.util.PriorityThreadFactory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.os.Process;

import java.util.concurrent.ThreadFactory;

/**
 * A thread factory that creates threads with a given thread priority.
 */
public class PriorityThreadFactory implements ThreadFactory {

    private final int mPriority;

    /**
     * Creates a new thread factory.
     *
     * @param priority The thread priority of the threads created by this factory.
     *        For values, see {@link Process}.
     */
    public PriorityThreadFactory(int priority) {
        mPriority = priority;
    }

    public Thread newThread(Runnable r) {
        return new Thread(r) {
            @Override
            public void run() {
                Process.setThreadPriority(mPriority);
                super.run();
            }
        };
    }

}
",True,17,5,5,0,0,2,0,L0
66,com.android.quicksearchbox.util.BarrierConsumer.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import java.util.ArrayList;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * A consumer that consumes a fixed number of values. When the expected number of values
 * has been consumed, further values are rejected.
 */
public class BarrierConsumer<A> implements Consumer<A> {

    private final Lock mLock = new ReentrantLock();
    private final Condition mNotFull = mLock.newCondition();

    private final int mExpectedCount;

    // Set to null when getValues() returns.
    private ArrayList<A> mValues;

    /**
     * Constructs a new BarrierConsumer.
     *
     * @param expectedCount The number of values to consume.
     */
    public BarrierConsumer(int expectedCount) {
        mExpectedCount = expectedCount;
        mValues = new ArrayList<A>(expectedCount);
    }

    /**
     * Blocks until the expected number of results is available, or until the thread is
     * interrupted. This method should not be called multiple times.
     *
     * @return A list of values, never {@code null}.
     */
    public ArrayList<A> getValues() {
        mLock.lock();
        try {
            try {
                while (!isFull()) {
                    mNotFull.await();
                }
            } catch (InterruptedException ex) {
                // Return the values that we've gotten so far
            }
            ArrayList<A> values = mValues;
            mValues = null;  // mark that getValues() has returned
            return values;
        } finally {
            mLock.unlock();
        }
    }

    public boolean consume(A value) {
        mLock.lock();
        try {
            // Do nothing if getValues() has alrady returned,
            // or enough values have already been consumed
            if (mValues == null || isFull()) {
                return false;
            }
            mValues.add(value);
            if (isFull()) {
                // Wake up any thread waiting in getValues()
                mNotFull.signal();
            }
            return true;
        } finally {
            mLock.unlock();
        }
    }

    private boolean isFull() {
        return mValues.size() == mExpectedCount;
    }
}
",False,19,7,4,1,1,1,1,L4
67,com.android.quicksearchbox.util.NamedTaskExecutor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

/**
 * Runs tasks that have a name tag.
 */
public interface NamedTaskExecutor {

    /**
     * Schedules a task for execution. Implementations should not throw
     * {@link java.util.concurrent.RejectedExecutionException} if the task
     * cannot be run. They should drop it silently instead.
     */
    void execute(NamedTask task);

    /**
     * Stops any unstarted tasks from running. Implementations of this method must be
     * idempotent.
     */
    void cancelPendingTasks();

    /**
     * Shuts down this executor, freeing any resources that it owns. The executor
     * may not be used after calling this method. Implementations of this method must be
     * idempotent.
     */
    void close();

}
",False,30,5,10,1,1,10,1,L0
68,com.android.quicksearchbox.util.NamedTask.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

/**
 * A task that has a name.
 */
public interface NamedTask extends Runnable {

    String getName();

}
",False,31,5,8,0,0,8,0,L0
69,com.android.quicksearchbox.util.SQLiteTransaction.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.database.sqlite.SQLiteDatabase;

/**
 * Abstract helper base class for SQLite write transactions.
 */
public abstract class SQLiteTransaction {

    /**
     * Executes the statements that form the transaction.
     *
     * @param db A writable database.
     * @return {@code true} if the transaction should be committed.
     */
    protected abstract boolean performTransaction(SQLiteDatabase db);

    /**
     * Runs the transaction against the database. The results are committed if
     * {@link #performTransaction(SQLiteDatabase)} completes normally and returns {@code true}.
     */
    public void run(SQLiteDatabase db) {
        db.beginTransaction();
        try {
            if (performTransaction(db)) {
                db.setTransactionSuccessful();
            }
        } finally {
            db.endTransaction();
        }
    }
}
",False,18,6,5,0,0,1,0,L4
70,com.android.quicksearchbox.util.PerNameExecutor.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;


import java.util.HashMap;

/**
 * Uses a separate executor for each task name.
 */
public class PerNameExecutor implements NamedTaskExecutor {

    private final Factory<NamedTaskExecutor> mExecutorFactory;
    private HashMap<String, NamedTaskExecutor> mExecutors;

    /**
     * @param executorFactory Used to run the commands.
     */
    public PerNameExecutor(Factory<NamedTaskExecutor> executorFactory) {
        mExecutorFactory = executorFactory;
    }

    public synchronized void cancelPendingTasks() {
        for (NamedTaskExecutor executor : mExecutors.values()) {
            executor.cancelPendingTasks();
        }
    }

    public synchronized void close() {
        for (NamedTaskExecutor executor : mExecutors.values()) {
            executor.close();
        }
    }

    public synchronized void execute(NamedTask task) {
        if (mExecutors == null) {
            mExecutors = new HashMap<String, NamedTaskExecutor>();
        }
        String name = task.getName();
        NamedTaskExecutor executor = mExecutors.get(name);
        if (executor == null) {
            executor = mExecutorFactory.create();
            mExecutors.put(name, executor);
        }
        executor.execute(task);
    }

}
",False,20,5,5,1,3,2,3,L1
71,com.android.quicksearchbox.util.BatchingNamedTaskExecutor.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;


import android.util.Log;

import java.util.ArrayList;
import java.util.List;

/**
 * Executes NamedTasks in batches of a given size.  Tasks are queued until
 * executeNextBatch is called.
 */
public class BatchingNamedTaskExecutor implements NamedTaskExecutor {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.BatchingNamedTaskExecutor"";

    private final NamedTaskExecutor mExecutor;

    /** Queue of tasks waiting to be dispatched to mExecutor **/
    private final ArrayList<NamedTask> mQueuedTasks = new ArrayList<NamedTask>();

    /**
     * Creates a new BatchingSourceTaskExecutor.
     *
     * @param executor A SourceTaskExecutor for actually executing the tasks.
     */
    public BatchingNamedTaskExecutor(NamedTaskExecutor executor) {
        mExecutor = executor;
    }

    public void execute(NamedTask task) {
        synchronized (mQueuedTasks) {
            if (DBG) Log.d(TAG, ""Queuing "" + task);
            mQueuedTasks.add(task);
        }
    }

    private void dispatch(NamedTask task) {
        if (DBG) Log.d(TAG, ""Dispatching "" + task);
        mExecutor.execute(task);
    }

    /**
     * Instructs the executor to submit the next batch of results.
     * @param batchSize the maximum number of entries to execute.
     */
    public void executeNextBatch(int batchSize) {
        NamedTask[] batch = new NamedTask[0];
        synchronized (mQueuedTasks) {
            int count = Math.min(mQueuedTasks.size(), batchSize);
            List<NamedTask> nextTasks = mQueuedTasks.subList(0, count);
            batch = nextTasks.toArray(batch);
            nextTasks.clear();
            if (DBG) Log.d(TAG, ""Dispatching batch of "" + count);
        }

        for (NamedTask task : batch) {
            dispatch(task);
        }
    }

    /**
     * Cancel any unstarted tasks running in this executor.  This instance 
     * should not be re-used after calling this method.
     */
    public void cancelPendingTasks() {
        synchronized (mQueuedTasks) {
            mQueuedTasks.clear();
        }
        mExecutor.cancelPendingTasks();
    }

    public void close() {
        cancelPendingTasks();
        mExecutor.close();
    }
}
",True,19,6,5,1,2,1,2,L5
72,com.android.quicksearchbox.util.SingleThreadNamedTaskExecutor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.util.Log;

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;

/**
 * Executor that uses a single thread and an unbounded work queue.
 */
public class SingleThreadNamedTaskExecutor implements NamedTaskExecutor {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SingleThreadNamedTaskExecutor"";

    private final LinkedBlockingQueue<NamedTask> mQueue;
    private final Thread mWorker;
    private volatile boolean mClosed = false;

    public SingleThreadNamedTaskExecutor(ThreadFactory threadFactory) {
        mQueue = new LinkedBlockingQueue<NamedTask>();
        mWorker = threadFactory.newThread(new Worker());
        mWorker.start();
    }

    public void cancelPendingTasks() {
        if (DBG) Log.d(TAG, ""Cancelling "" + mQueue.size() + "" tasks: "" + mWorker.getName());
        if (mClosed) {
            throw new IllegalStateException(""cancelPendingTasks() after close()"");
        }
        mQueue.clear();
    }

    public void close() {
        mClosed = true;
        mWorker.interrupt();
        mQueue.clear();
    }

    public void execute(NamedTask task) {
        if (mClosed) {
            throw new IllegalStateException(""execute() after close()"");
        }
        mQueue.add(task);
    }

    private class Worker implements Runnable {
        public void run() {
            try {
                loop();
            } finally {
                if (!mClosed) Log.w(TAG, ""Worker exited before close"");
            }
        }

        private void loop() {
            Thread currentThread = Thread.currentThread();
            String threadName = currentThread.getName();
            while (!mClosed) {
                NamedTask task;
                try {
                    task = mQueue.take();
                } catch (InterruptedException ex) {
                    continue;
                }
                currentThread.setName(threadName + "" "" + task.getName());
                try {
                    task.run();
                } catch (RuntimeException ex) {
                    Log.e(TAG, ""Task "" + task.getName() + "" failed"", ex);
                }
            }
        }
    }

    public static Factory<NamedTaskExecutor> factory(final ThreadFactory threadFactory) {
        return new Factory<NamedTaskExecutor>() {
            public NamedTaskExecutor create() {
                return new SingleThreadNamedTaskExecutor(threadFactory);
            }
        };
    }

}
",True,20,5,5,1,3,2,3,L1
73,com.android.quicksearchbox.util.Factory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

public interface Factory<A> {

    A create();

}
",False,21,5,7,0,0,5,0,L0
74,com.android.quicksearchbox.ui.CorporaAdapter.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Corpus;
import com.android.quicksearchbox.CorpusRanker;

import android.database.DataSetObserver;
import android.graphics.drawable.Drawable;
import android.util.Log;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;

import java.util.List;

/**
 * Adapter for showing a list of sources in the source selection activity.
 */
public class CorporaAdapter extends BaseAdapter {

    private static final String TAG = ""CorporaAdapter"";
    private static final boolean DBG = false;

    private final CorpusViewFactory mViewFactory;

    private final CorpusRanker mRanker;

    private final DataSetObserver mCorporaObserver = new CorporaObserver();

    private List<Corpus> mRankedEnabledCorpora;

    private boolean mGridView;

    private CorporaAdapter(CorpusViewFactory viewFactory,
            CorpusRanker ranker, boolean gridView) {
        mViewFactory = viewFactory;
        mRanker = ranker;
        mGridView = gridView;
        mRanker.registerDataSetObserver(mCorporaObserver);
        updateCorpora();
    }

    public static CorporaAdapter createListAdapter(CorpusViewFactory viewFactory,
            CorpusRanker ranker) {
        return new CorporaAdapter(viewFactory, ranker, false);
    }

    public static CorporaAdapter createGridAdapter(CorpusViewFactory viewFactory,
            CorpusRanker ranker) {
        return new CorporaAdapter(viewFactory, ranker, true);
    }

    private void updateCorpora() {
        mRankedEnabledCorpora = mRanker.getRankedCorpora();
        notifyDataSetChanged();
    }

    public void close() {
        mRanker.unregisterDataSetObserver(mCorporaObserver);
    }

    public int getCount() {
        return 1 + mRankedEnabledCorpora.size();
    }

    public Corpus getItem(int position) {
        if (position == 0) {
            return null;
        } else {
            return mRankedEnabledCorpora.get(position - 1);
        }
    }

    public long getItemId(int position) {
        return position;
    }

    /**
     * Gets the position of the given corpus.
     */
    public int getCorpusPosition(Corpus corpus) {
        if (corpus == null) {
            return 0;
        }
        int count = getCount();
        for (int i = 0; i < count; i++) {
            if (corpus.equals(getItem(i))) {
                return i;
            }
        }
        Log.w(TAG, ""Corpus not in adapter: "" + corpus);
        return 0;
    }

    public View getView(int position, View convertView, ViewGroup parent) {
        CorpusView view = (CorpusView) convertView;
        if (view == null) {
            view = createView(parent);
        }
        Corpus corpus = getItem(position);
        Drawable icon;
        CharSequence label;
        if (corpus == null) {
            icon = mViewFactory.getGlobalSearchIcon();
            label = mViewFactory.getGlobalSearchLabel();
        } else {
            icon = corpus.getCorpusIcon();
            label = corpus.getLabel();
        }
        if (DBG) Log.d(TAG, ""Binding "" + position + "", label="" + label);
        view.setIcon(icon);
        view.setLabel(label);
        return view;
    }

    protected CorpusView createView(ViewGroup parent) {
        if (mGridView) {
            return mViewFactory.createGridCorpusView(parent);
        } else {
            return mViewFactory.createListCorpusView(parent);
        }
    }

    private class CorporaObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            updateCorpora();
        }

        @Override
        public void onInvalidated() {
            updateCorpora();
        }
    }

}
",True,16,3,2,3,4,2,4,L6
75,com.android.quicksearchbox.ui.SuggestionView.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.SuggestionCursor;

/**
 * Interface to be implemented by any view appearing in the list of suggestions.
 */
public interface SuggestionView {
    /**
     * Set the view's contents based on the given suggestion.
     */
    void bindAsSuggestion(SuggestionCursor suggestion);

}
",False,29,6,6,3,2,5,1,L1
76,com.android.quicksearchbox.ui.DelayingSuggestionsAdapter.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.SuggestionCursor;
import com.android.quicksearchbox.Suggestions;

import android.database.DataSetObserver;
import android.util.Log;

/**
 * A {@link SuggestionsAdapter} that doesn't expose the new suggestions
 * until there are some results to show.
 */
public class DelayingSuggestionsAdapter extends SuggestionsAdapter {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.DelayingSuggestionsAdapter"";

    private DataSetObserver mPendingDataSetObserver;

    private Suggestions mPendingSuggestions;

    public DelayingSuggestionsAdapter(SuggestionViewFactory viewFactory) {
        super(viewFactory);
    }

    @Override
    public void close() {
        setPendingSuggestions(null);
        super.close();
    }

    @Override
    public void setSuggestions(Suggestions suggestions) {
        if (suggestions == null) {
            super.setSuggestions(null);
            setPendingSuggestions(null);
            return;
        }
        if (shouldPublish(suggestions)) {
            if (DBG) Log.d(TAG, ""Publishing suggestions immediately: "" + suggestions);
            super.setSuggestions(suggestions);
            // Clear any old pending suggestions.
            setPendingSuggestions(null);
        } else {
            if (DBG) Log.d(TAG, ""Delaying suggestions publishing: "" + suggestions);
            setPendingSuggestions(suggestions);
        }
    }

    /**
     * Gets whether the given suggestions are non-empty for the selected source.
     */
    private boolean shouldPublish(Suggestions suggestions) {
        if (suggestions.isDone()) return true;
        SuggestionCursor cursor = getCorpusCursor(suggestions, getCorpus());
        return cursor != null && cursor.getCount() > 0;
    }

    private void setPendingSuggestions(Suggestions suggestions) {
        if (mPendingSuggestions == suggestions) {
            return;
        }
        if (isClosed()) {
            if (suggestions != null) {
                suggestions.close();
            }
            return;
        }
        if (mPendingDataSetObserver == null) {
            mPendingDataSetObserver = new PendingSuggestionsObserver();
        }
        if (mPendingSuggestions != null) {
            mPendingSuggestions.unregisterDataSetObserver(mPendingDataSetObserver);
            // Close old suggestions, but only if they are not also the current
            // suggestions.
            if (mPendingSuggestions != getSuggestions()) {
                mPendingSuggestions.close();
            }
        }
        mPendingSuggestions = suggestions;
        if (mPendingSuggestions != null) {
            mPendingSuggestions.registerDataSetObserver(mPendingDataSetObserver);
        }
    }

    protected void onPendingSuggestionsChanged() {
        if (DBG) {
            Log.d(TAG, ""onPendingSuggestionsChanged(), mPendingSuggestions=""
                    + mPendingSuggestions);
        }
        if (shouldPublish(mPendingSuggestions)) {
            if (DBG) Log.d(TAG, ""Suggestions now available, publishing: "" + mPendingSuggestions);
            super.setSuggestions(mPendingSuggestions);
            // The suggestions are no longer pending.
            setPendingSuggestions(null);
        }
    }

    private class PendingSuggestionsObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            onPendingSuggestionsChanged();
        }
    }

}
",True,33,5,5,3,8,1,4,L5
77,com.android.quicksearchbox.ui.SuggestionViewFactory.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.SuggestionCursor;

import android.view.View;
import android.view.ViewGroup;

/**
 * Creates suggestion views.
 */
public interface SuggestionViewFactory {

    /**
     * Gets the number of distinct suggestion view types created by this factory.
     */
    int getSuggestionViewTypeCount();

    /**
     * Gets the view type associated with a given suggestion.
     */
    int getSuggestionViewType(SuggestionCursor suggestion);

    /**
     * Gets a suggestion view, possibly recycling convertView.
     *
     * @param viewType The type of view to return.
     * @param convertView A view which may be re-used, or {@code null}.
     * @param parentViewType Used to create LayoutParams of the right type.
     */
    SuggestionView getSuggestionView(int viewType, View convertView, ViewGroup parentViewType);

}
",False,26,5,6,3,2,4,2,L5
78,com.android.quicksearchbox.ui.SuggestionsFooter.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.SuggestionCursor;
import com.android.quicksearchbox.Suggestions;

import android.content.Context;
import android.database.DataSetObserver;
import android.view.ViewGroup;

/**
 * View shown at the bottom of the suggestions list.
 */
public abstract class SuggestionsFooter {

    private final DataSetObserver mDataSetObserver = new AdapterObserver();

    private final Context mContext;

    private SuggestionsAdapter mAdapter;

    public SuggestionsFooter(Context context) {
        mContext = context;
    }

    public abstract void addToContainer(ViewGroup parent);

    protected abstract void onSuggestionsChanged();

    protected Context getContext() {
        return mContext;
    }

    public void setAdapter(SuggestionsAdapter adapter) {
        if (mAdapter == adapter) {
            return;
        }
        if (mAdapter != null) {
            mAdapter.unregisterDataSetObserver(mDataSetObserver);
        }
        mAdapter = adapter;
        if (mAdapter != null) {
            mAdapter.registerDataSetObserver(mDataSetObserver);
        }
        onSuggestionsChanged();
    }

    protected Suggestions getSuggestions() {
        return mAdapter == null ? null : mAdapter.getSuggestions();
    }

    protected SuggestionCursor getCurrentSuggestions() {
        return mAdapter == null ? null : mAdapter.getCurrentSuggestions();
    }

    private class AdapterObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            onSuggestionsChanged();
        }

        @Override
        public void onInvalidated() {
            onSuggestionsChanged();
        }
    }

}
",False,34,5,5,3,9,3,3,L5
79,com.android.quicksearchbox.ui.ContactSuggestionView.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import android.content.Context;
import android.net.Uri;
import android.util.AttributeSet;
import android.widget.QuickContactBadge;
import com.android.quicksearchbox.R;
import com.android.quicksearchbox.SuggestionCursor;

/**
 * View for contacts appearing in the suggestions list.
 */
public class ContactSuggestionView extends DefaultSuggestionView {

    private QuickContactBadge mQuickContact;

    public ContactSuggestionView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    public ContactSuggestionView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public ContactSuggestionView(Context context) {
        super(context);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mQuickContact = (QuickContactBadge) findViewById(R.id.icon1);
    }

    @Override
    public void bindAsSuggestion(SuggestionCursor suggestion) {
        super.bindAsSuggestion(suggestion);
        mQuickContact.assignContactUri(Uri.parse(suggestion.getSuggestionIntentDataString()));
    }
}",False,7,0,0,3,2,0,2,L7
80,com.android.quicksearchbox.ui.EmptySuggestionsFooter.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import android.content.Context;
import android.view.ViewGroup;

/**
 * Suggestions footer that doesn't add a footer view.
 */
public class EmptySuggestionsFooter extends SuggestionsFooter {

    public EmptySuggestionsFooter(Context context) {
        super(context);
    }

    @Override
    public void addToContainer(ViewGroup parent) {
        // Do nothing
    }

    @Override
    protected void onSuggestionsChanged() {
        // Do nothing
    }

}
",False,34,5,5,4,9,1,1,L5
81,com.android.quicksearchbox.ui.SuggestionsView.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.SuggestionPosition;

import android.content.Context;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ListView;

/**
 * Holds a list of suggestions.
 */
public class SuggestionsView extends ListView {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SuggestionsView"";

    private SuggestionClickListener mSuggestionClickListener;

    private SuggestionSelectionListener mSuggestionSelectionListener;

    private InteractionListener mInteractionListener;

    public SuggestionsView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    public void onFinishInflate() {
        super.onFinishInflate();
        setOnItemClickListener(new ItemClickListener());
        setOnItemLongClickListener(new ItemLongClickListener());
        setOnItemSelectedListener(new ItemSelectedListener());
    }

    public void setSuggestionClickListener(SuggestionClickListener listener) {
        mSuggestionClickListener = listener;
    }

    public void setSuggestionSelectionListener(SuggestionSelectionListener listener) {
        mSuggestionSelectionListener = listener;
    }

    public void setInteractionListener(InteractionListener listener) {
        mInteractionListener = listener;
    }

    /**
     * Gets the position of the selected suggestion.
     *
     * @return A 0-based index, or {@code -1} if no suggestion is selected.
     */
    public int getSelectedPosition() {
        return getSelectedItemPosition();
    }

    /**
     * Gets the selected suggestion.
     *
     * @return {@code null} if no suggestion is selected.
     */
    public SuggestionPosition getSelectedSuggestion() {
        return (SuggestionPosition) getSelectedItem();
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent event) {
        if (event.getAction() == MotionEvent.ACTION_DOWN && mInteractionListener != null) {
            mInteractionListener.onInteraction();
        }
        return super.onInterceptTouchEvent(event);
    }

    @Override
    protected void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect) {
        super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
        if (DBG) {
            Log.d(TAG, ""Suggestions focus change, gainFocus: "" + gainFocus
                    + "", selected="" + getSelectedItemPosition());
        }
        // In non-touch mode, ListView does not clear the list selection when
        // the ListView loses focus. And when it regains focus, onItemSelected() never gets
        // called if the new selected position is the same as the old. We work around that
        // by firing extra selection events on focus changes in non-touch mode.
        // This implementation can result in duplicate selection events when the old selected
        // item is not the same as the new.
        if (!isInTouchMode()) {
            if (gainFocus) {
                int position = getSelectedPosition();
                if (position != INVALID_POSITION) {
                    fireSuggestionSelected(position);
                }
            } else {
                fireNothingSelected();
            }
        }
    }

    private void fireSuggestionSelected(int position) {
        if (DBG) Log.d(TAG, ""fireSuggestionSelected("" + position + "")"");
        if (mSuggestionSelectionListener != null) {
            mSuggestionSelectionListener.onSuggestionSelected(position);
        }
    }

    private void fireNothingSelected() {
        if (DBG) Log.d(TAG, ""fireNothingSelected()"");
        if (mSuggestionSelectionListener != null) {
            mSuggestionSelectionListener.onNothingSelected();
        }
    }

    public interface InteractionListener {
        /**
         * Called when the user interacts with this view.
         */
        void onInteraction();
    }

    private class ItemClickListener implements AdapterView.OnItemClickListener {
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            if (DBG) Log.d(TAG, ""onItemClick("" + position + "")"");
            SuggestionView suggestionView = (SuggestionView) view;
            if (mSuggestionClickListener != null) {
                mSuggestionClickListener.onSuggestionClicked(position);
            }
        }
    }

    private class ItemLongClickListener implements AdapterView.OnItemLongClickListener {
        public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {
            if (DBG) Log.d(TAG, ""onItemLongClick("" + position + "")"");
            SuggestionView suggestionView = (SuggestionView) view;
            if (mSuggestionClickListener != null) {
                return mSuggestionClickListener.onSuggestionLongClicked(position);
            }
            return false;
        }
    }

    private class ItemSelectedListener implements AdapterView.OnItemSelectedListener {
        public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
            // Only fire suggestion selection events when the list has focus.
            // This suppresses selection events caused by data set changes (as opposed
            // to user action).
            if (hasFocus()) {
                fireSuggestionSelected(position);
            } else {
                if (DBG) Log.d(TAG, ""Suppressed selection event for position "" + position);
            }
        }

        public void onNothingSelected(AdapterView<?> parent) {
            fireNothingSelected();
        }
    }
}
",False,14,3,3,4,4,1,4,L6
82,com.android.quicksearchbox.ui.SuggestionSelectionListener.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;


/**
 * Listener interface for suggestion selection.
 */
public interface SuggestionSelectionListener {
    /**
     * Called when a suggestion is selected
     *
     * @param position Position of the new selected suggestion.
     */
    void onSuggestionSelected(int position);

    /**
     * Called when the selection changed so that no suggestion is selected.
     */
    void onNothingSelected();
}
",False,7,3,3,0,0,2,0,L6
83,com.android.quicksearchbox.ui.SuggestionClickListener.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

/**
 * Listener interface for clicks on suggestions.
 */
public interface SuggestionClickListener {
    /**
     * Called when a suggestion is clicked.
     *
     * @param position Position of the clicked suggestion.
     */
    void onSuggestionClicked(int position);
    /**
     * Called when a suggestion is long clicked.
     *
     * @param position Position of the long clicked suggestion.
     */
    boolean onSuggestionLongClicked(int position);
}
",False,7,3,3,0,0,2,0,L6
84,com.android.quicksearchbox.ui.SuggestionViewInflater.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.R;
import com.android.quicksearchbox.SuggestionCursor;

import android.content.Context;
import android.provider.ContactsContract;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

/**
 * Inflates suggestion views.
 */
public class SuggestionViewInflater implements SuggestionViewFactory {

    // The suggestion view classes that may be returned by this factory.
    private static final Class<?>[] SUGGESTION_VIEW_CLASSES = {
            DefaultSuggestionView.class,
            ContactSuggestionView.class,
    };

    // The layout ids associated with each of the above classes.
    private static final int[] SUGGESTION_VIEW_LAYOUTS = {
            R.layout.suggestion,
            R.layout.contact_suggestion,
    };

    private static final String CONTACT_LOOKUP_URI
            = ContactsContract.Contacts.CONTENT_LOOKUP_URI.toString();

    private final Context mContext;

    public SuggestionViewInflater(Context context) {
        mContext = context;
    }

    protected LayoutInflater getInflater() {
        return (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }

    public int getSuggestionViewTypeCount() {
        return SUGGESTION_VIEW_CLASSES.length;
    }

    public int getSuggestionViewType(SuggestionCursor suggestion) {
        return isContactSuggestion(suggestion) ? 1 : 0;
    }

    public SuggestionView getSuggestionView(int viewType, View convertView,
            ViewGroup parentViewType) {
        if (convertView == null || !convertView.getClass().equals(
                SUGGESTION_VIEW_CLASSES[viewType])) {
            int layoutId = SUGGESTION_VIEW_LAYOUTS[viewType];
            convertView = getInflater().inflate(layoutId, parentViewType, false);
        }
        return (SuggestionView) convertView;
    }

    private boolean isContactSuggestion(SuggestionCursor suggestion) {
        String intentData = suggestion.getSuggestionIntentDataString();
        return intentData != null && intentData.startsWith(CONTACT_LOOKUP_URI);
    }
}
",True,22,5,5,3,3,1,3,L5
85,com.android.quicksearchbox.ui.CorpusViewFactory.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.view.ViewGroup;

/**
 * Creates corpus views.
 */
public interface CorpusViewFactory {

    CorpusView createGridCorpusView(ViewGroup parentViewType);

    CorpusView createListCorpusView(ViewGroup parentViewType);

    String getGlobalSearchLabel();

    Drawable getGlobalSearchIcon();

    Uri getGlobalSearchIconUri();
}
",False,19,5,7,1,1,7,1,L5
86,com.android.quicksearchbox.ui.SearchActivityView.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import android.app.Activity;
import android.content.Context;
import android.util.AttributeSet;
import android.view.KeyEvent;
import android.view.inputmethod.InputMethodManager;
import android.widget.RelativeLayout;

/**
 * Finishes the containing activity on BACK, even if input method is showing.
 */
public class SearchActivityView extends RelativeLayout {

    public SearchActivityView(Context context) {
        super(context);
    }

    public SearchActivityView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public SearchActivityView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    private Activity getActivity() {
        Context context = getContext();
        if (context instanceof Activity) {
            return (Activity) context;
        } else {
            return null;
        }
    }

    /**
     * Hides the input method.
     */
    protected void hideInputMethod() {
        InputMethodManager imm = (InputMethodManager)
                getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        if (imm != null) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
    }

    /**
     * Overrides the handling of the back key to dismiss the activity.
     */
    @Override
    public boolean dispatchKeyEventPreIme(KeyEvent event) {
        Activity activity = getActivity();
        if (activity != null && event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
            KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null) {
                if (event.getAction() == KeyEvent.ACTION_DOWN
                        && event.getRepeatCount() == 0) {
                    state.startTracking(event, this);
                    return true;
                } else if (event.getAction() == KeyEvent.ACTION_UP
                        && !event.isCanceled() && state.isTracking(event)) {
                    hideInputMethod();
                    activity.onBackPressed();
                    return true;
                }
            }
        }
        return super.dispatchKeyEventPreIme(event);
    }
}
",False,1,0,0,0,0,0,0,I0
87,com.android.quicksearchbox.ui.CorpusView.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.R;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.util.AttributeSet;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;


/**
 * A corpus in the corpus selection list.
 */
public class CorpusView extends RelativeLayout {

    private ImageView mIcon;
    private TextView mLabel;

    public CorpusView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public CorpusView(Context context) {
        super(context);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mIcon = (ImageView) findViewById(R.id.source_icon);
        mLabel = (TextView) findViewById(R.id.source_label);
    }

    public void setLabel(CharSequence label) {
        mLabel.setText(label);
    }

    public void setIcon(Drawable icon) {
        mIcon.setImageDrawable(icon);
    }
}
",False,19,6,5,0,0,3,0,L5
88,com.android.quicksearchbox.ui.CorpusViewInflater.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.R;
import com.android.quicksearchbox.util.Util;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.view.LayoutInflater;
import android.view.ViewGroup;

/**
 * Inflates corpus views.
 */
public class CorpusViewInflater implements CorpusViewFactory {

    private final Context mContext;

    public CorpusViewInflater(Context context) {
        mContext = context;
    }

    protected LayoutInflater getInflater() {
        return (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }

    public CorpusView createGridCorpusView(ViewGroup parentViewType) {
        return inflateCorpusView(R.layout.corpus_grid_item, parentViewType);
    }

    public CorpusView createListCorpusView(ViewGroup parentViewType) {
        return inflateCorpusView(R.layout.corpus_list_item, parentViewType);
    }

    protected CorpusView inflateCorpusView(int res, ViewGroup parentViewType) {
        return (CorpusView) getInflater().inflate(res, parentViewType, false);
    }

    public String getGlobalSearchLabel() {
        return mContext.getString(R.string.corpus_label_global);
    }

    private int getGlobalSearchIconResource() {
        return R.drawable.search_app_icon;
    }

    public Drawable getGlobalSearchIcon() {
        return mContext.getResources().getDrawable(getGlobalSearchIconResource());
    }

    public Uri getGlobalSearchIconUri() {
        return Util.getResourceUri(mContext, getGlobalSearchIconResource());
    }

}
",False,19,5,5,1,3,1,3,L5
89,com.android.quicksearchbox.ui.DefaultSuggestionView.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.R;
import com.android.quicksearchbox.Source;
import com.android.quicksearchbox.SuggestionCursor;

import android.content.Context;
import android.content.res.ColorStateList;
import android.graphics.drawable.Drawable;
import android.text.Html;
import android.text.Spannable;
import android.text.SpannableString;
import android.text.TextUtils;
import android.text.style.TextAppearanceSpan;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;

/**
 * View for the items in the suggestions list. This includes promoted suggestions,
 * sources, and suggestions under each source.
 *
 */
public class DefaultSuggestionView extends RelativeLayout implements SuggestionView {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SuggestionView"";

    private TextView mText1;
    private TextView mText2;
    private ImageView mIcon1;
    private ImageView mIcon2;

    public DefaultSuggestionView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    public DefaultSuggestionView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public DefaultSuggestionView(Context context) {
        super(context);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mText1 = (TextView) findViewById(R.id.text1);
        mText2 = (TextView) findViewById(R.id.text2);
        mIcon1 = (ImageView) findViewById(R.id.icon1);
        mIcon2 = (ImageView) findViewById(R.id.icon2);
    }

    public void bindAsSuggestion(SuggestionCursor suggestion) {
        String format = suggestion.getSuggestionFormat();
        CharSequence text1 = formatText(suggestion.getSuggestionText1(), format);
        CharSequence text2 = suggestion.getSuggestionText2Url();
        if (text2 != null) {
            text2 = formatUrl(text2);
        } else {
            text2 = formatText(suggestion.getSuggestionText2(), format);
        }
        Drawable icon1 = getSuggestionDrawableIcon1(suggestion);
        Drawable icon2 = getSuggestionDrawableIcon2(suggestion);
        if (DBG) {
            Log.d(TAG, ""bindAsSuggestion(), text1="" + text1 + "",text2="" + text2
                    + "",icon1="" + icon1 + "",icon2="" + icon2);
        }
        setText1(text1);
        setText2(text2);
        setIcon1(icon1);
        setIcon2(icon2);
    }

    private CharSequence formatUrl(CharSequence url) {
        SpannableString text = new SpannableString(url);
        ColorStateList colors = getResources().getColorStateList(R.color.url_text);
        text.setSpan(new TextAppearanceSpan(null, 0, 0, colors, null),
                0, url.length(),
                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        return text;
    }

    public Drawable getSuggestionDrawableIcon1(SuggestionCursor suggestion) {
        Source source = suggestion.getSuggestionSource();
        String icon1Id = suggestion.getSuggestionIcon1();
        Drawable icon1 = source.getIcon(icon1Id);
        return icon1 == null ? source.getSourceIcon() : icon1;
    }

    public Drawable getSuggestionDrawableIcon2(SuggestionCursor suggestion) {
        Source source = suggestion.getSuggestionSource();
        return source.getIcon(suggestion.getSuggestionIcon2());
    }

    private CharSequence formatText(String str, String format) {
        boolean isHtml = ""html"".equals(format);
        if (isHtml && looksLikeHtml(str)) {
            return Html.fromHtml(str);
        } else {
            return str;
        }
    }

    private boolean looksLikeHtml(String str) {
        if (TextUtils.isEmpty(str)) return false;
        for (int i = str.length() - 1; i >= 0; i--) {
            char c = str.charAt(i);
            if (c == '>' || c == '&') return true;
        }
        return false;
    }

    /**
     * Sets the first text line.
     */
    private void setText1(CharSequence text) {
        mText1.setText(text);
    }

    /**
     * Sets the second text line.
     */
    private void setText2(CharSequence text) {
        mText2.setText(text);
        if (TextUtils.isEmpty(text)) {
            mText2.setVisibility(GONE);
        } else {
            mText2.setVisibility(VISIBLE);
        }
    }

    /**
     * Sets the left-hand-side icon.
     */
    private void setIcon1(Drawable icon) {
        setViewDrawable(mIcon1, icon);
    }

    /**
     * Sets the right-hand-side icon.
     */
    private void setIcon2(Drawable icon) {
        setViewDrawable(mIcon2, icon);
    }

    /**
     * Sets the drawable in an image view, makes sure the view is only visible if there
     * is a drawable.
     */
    private static void setViewDrawable(ImageView v, Drawable drawable) {
        // Set the icon even if the drawable is null, since we need to clear any
        // previous icon.
        v.setImageDrawable(drawable);

        if (drawable == null) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);

            // This is a hack to get any animated drawables (like a 'working' spinner)
            // to animate. You have to setVisible true on an AnimationDrawable to get
            // it to start animating, but it must first have been false or else the
            // call to setVisible will be ineffective. We need to clear up the story
            // about animated drawables in the future, see http://b/1878430.
            drawable.setVisible(false, false);
            drawable.setVisible(true, false);
        }
    }

}
",False,7,1,1,2,3,1,3,L7
90,com.android.quicksearchbox.ui.SuggestionsAdapter.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Corpus;
import com.android.quicksearchbox.SuggestionCursor;
import com.android.quicksearchbox.SuggestionPosition;
import com.android.quicksearchbox.Suggestions;

import android.database.DataSetObserver;
import android.util.Log;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;

/**
 * Uses a {@link Suggestions} object to back a {@link SuggestionsView}.
 */
public class SuggestionsAdapter extends BaseAdapter {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SuggestionsAdapter"";

    private DataSetObserver mDataSetObserver;

    private final SuggestionViewFactory mViewFactory;

    private SuggestionCursor mCursor;

    private Corpus mCorpus = null;

    private Suggestions mSuggestions;

    private boolean mClosed = false;

    public SuggestionsAdapter(SuggestionViewFactory viewFactory) {
        mViewFactory = viewFactory;
    }

    public boolean isClosed() {
        return mClosed;
    }

    public void close() {
        setSuggestions(null);
        mCorpus = null;
        mClosed = true;
    }

    public void setSuggestions(Suggestions suggestions) {
        if (mSuggestions == suggestions) {
            return;
        }
        if (mClosed) {
            if (suggestions != null) {
                suggestions.close();
            }
            return;
        }
        if (mDataSetObserver == null) {
            mDataSetObserver = new MySuggestionsObserver();
        }
        // TODO: delay the change if there are no suggestions for the currently visible tab.
        if (mSuggestions != null) {
            mSuggestions.unregisterDataSetObserver(mDataSetObserver);
            mSuggestions.close();
        }
        mSuggestions = suggestions;
        if (mSuggestions != null) {
            mSuggestions.registerDataSetObserver(mDataSetObserver);
        }
        onSuggestionsChanged();
    }

    public Suggestions getSuggestions() {
        return mSuggestions;
    }

    /**
     * Gets the source whose results are displayed.
     */
    public Corpus getCorpus() {
        return mCorpus;
    }

    /**
     * Sets the source whose results are displayed.
     */
    public void setCorpus(Corpus corpus) {
        mCorpus = corpus;
        onSuggestionsChanged();
    }

    public int getCount() {
        return mCursor == null ? 0 : mCursor.getCount();
    }

    public SuggestionPosition getItem(int position) {
        if (mCursor == null) return null;
        return new SuggestionPosition(mCursor, position);
    }

    public long getItemId(int position) {
        return position;
    }

    @Override
    public int getViewTypeCount() {
        return mViewFactory.getSuggestionViewTypeCount();
    }

    @Override
    public int getItemViewType(int position) {
        if (mCursor == null) {
            return 0;
        }
        mCursor.moveTo(position);
        return mViewFactory.getSuggestionViewType(mCursor);
    }

    public View getView(int position, View convertView, ViewGroup parent) {
        if (mCursor == null) {
            throw new IllegalStateException(""getView() called with null cursor"");
        }
        mCursor.moveTo(position);
        int viewType = mViewFactory.getSuggestionViewType(mCursor);
        SuggestionView view = mViewFactory.getSuggestionView(viewType, convertView, parent);
        view.bindAsSuggestion(mCursor);
        return (View) view;
    }

    protected void onSuggestionsChanged() {
        if (DBG) Log.d(TAG, ""onSuggestionsChanged(), mSuggestions="" + mSuggestions);
        SuggestionCursor cursor = getCorpusCursor(mSuggestions, mCorpus);
        changeCursor(cursor);
    }

    /**
     * Gets the cursor containing the currently shown suggestions. The caller should not hold
     * on to or modify the returned cursor.
     */
    public SuggestionCursor getCurrentSuggestions() {
        return mCursor;
    }

    /**
     * Gets the cursor for the given source.
     */
    protected SuggestionCursor getCorpusCursor(Suggestions suggestions, Corpus corpus) {
        if (suggestions == null) return null;
        return suggestions.getPromoted();
    }

    /**
     * Replace the cursor.
     *
     * This does not close the old cursor. Instead, all the cursors are closed in
     * {@link #setSuggestions(Suggestions)}.
     */
    private void changeCursor(SuggestionCursor newCursor) {
        if (DBG) Log.d(TAG, ""changeCursor("" + newCursor + "")"");
        if (newCursor == mCursor) {
            // Shortcuts may have changed without the cursor changing.
            notifyDataSetChanged();
            return;
        }
        mCursor = newCursor;
        if (mCursor != null) {
            // TODO: Register observers here to watch for
            // changes in the cursor, e.g. shortcut refreshes?
            notifyDataSetChanged();
        } else {
            notifyDataSetInvalidated();
        }
    }

    private class MySuggestionsObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            onSuggestionsChanged();
        }
    }

}
",True,35,5,6,3,7,4,6,L5
