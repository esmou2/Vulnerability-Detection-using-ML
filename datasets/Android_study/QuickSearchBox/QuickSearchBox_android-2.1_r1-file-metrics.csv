,file_path,source_code,is_vulnerable, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,com.android.quicksearchbox.QueryTask.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.Consumer;
import com.android.quicksearchbox.util.Consumers;
import com.android.quicksearchbox.util.NamedTask;
import com.android.quicksearchbox.util.NamedTaskExecutor;

import android.os.Handler;
import android.util.Log;

/**
 * A task that gets suggestions from a corpus.
 */
public class QueryTask<C extends SuggestionCursor> implements NamedTask {
    private static final String TAG = ""QSB.QueryTask"";
    private static final boolean DBG = false;

    private final String mQuery;
    private final int mQueryLimit;
    private final SuggestionCursorProvider<C> mProvider;
    private final Handler mHandler;
    private final Consumer<C> mConsumer;

    /**
     * Creates a new query task.
     *
     * @param query Query to run.
     * @param queryLimit The number of suggestions to ask each provider for.
     * @param provider The provider to ask for suggestions.
     * @param handler Handler that {@link Consumer#consume} will
     *        get called on. If null, the method is called on the query thread.
     * @param consumer Consumer to notify when the suggestions have been returned.
     */
    public QueryTask(String query, int queryLimit, SuggestionCursorProvider<C> provider,
            Handler handler, Consumer<C> consumer) {
        mQuery = query;
        mQueryLimit = queryLimit;
        mProvider = provider;
        mHandler = handler;
        mConsumer = consumer;
    }

    @Override
    public String getName() {
        return mProvider.getName();
    }

    @Override
    public void run() {
        final C cursor = mProvider.getSuggestions(mQuery, mQueryLimit);
        if (DBG) Log.d(TAG, ""Suggestions from "" + mProvider + "" = "" + cursor);
        Consumers.consumeCloseableAsync(mHandler, mConsumer, cursor);
    }

    @Override
    public String toString() {
        return mProvider + ""["" + mQuery + ""]"";
    }

    public static <C extends SuggestionCursor> void startQuery(String query,
            int maxResults,
            SuggestionCursorProvider<C> provider,
            NamedTaskExecutor executor, Handler handler,
            Consumer<C> consumer) {

        QueryTask<C> task = new QueryTask<C>(query, maxResults, provider, handler,
                consumer);
        executor.execute(task);
    }
}
",False,26,5,7,3,5,2,5,L4
1,com.android.quicksearchbox.SuggestionsProvider.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

/**
 * Provides a set of suggestion results for a query..
 *
 */
public interface SuggestionsProvider {

    /**
     * Gets suggestions for a query.
     *
     * @param query The query.
     * @param source The source to query. Must be non-null.
     */
    Suggestions getSuggestions(String query, Source source);

    void close();
}
",False,31,5,5,3,8,3,2,L5
2,com.android.quicksearchbox.QsbApplication.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.os.Process;
import android.view.ContextThemeWrapper;

import com.android.quicksearchbox.google.GoogleSource;
import com.android.quicksearchbox.google.GoogleSuggestClient;
import com.android.quicksearchbox.google.SearchBaseUrlHelper;
import com.android.quicksearchbox.ui.DefaultSuggestionViewFactory;
import com.android.quicksearchbox.ui.SuggestionViewFactory;
import com.android.quicksearchbox.util.Factory;
import com.android.quicksearchbox.util.HttpHelper;
import com.android.quicksearchbox.util.JavaNetHttpHelper;
import com.android.quicksearchbox.util.NamedTaskExecutor;
import com.android.quicksearchbox.util.PerNameExecutor;
import com.android.quicksearchbox.util.PriorityThreadFactory;
import com.android.quicksearchbox.util.SingleThreadNamedTaskExecutor;
import com.google.common.util.concurrent.ThreadFactoryBuilder;

import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;

public class QsbApplication {
    private final Context mContext;

    private int mVersionCode;
    private Handler mUiThreadHandler;
    private Config mConfig;
    private SearchSettings mSettings;
    private NamedTaskExecutor mSourceTaskExecutor;
    private ThreadFactory mQueryThreadFactory;
    private SuggestionsProvider mSuggestionsProvider;
    private SuggestionViewFactory mSuggestionViewFactory;
    private GoogleSource mGoogleSource;
    private VoiceSearch mVoiceSearch;
    private Logger mLogger;
    private SuggestionFormatter mSuggestionFormatter;
    private TextAppearanceFactory mTextAppearanceFactory;
    private NamedTaskExecutor mIconLoaderExecutor;
    private HttpHelper mHttpHelper;
    private SearchBaseUrlHelper mSearchBaseUrlHelper;

    public QsbApplication(Context context) {
        // the application context does not use the theme from the <application> tag
        mContext = new ContextThemeWrapper(context, R.style.Theme_QuickSearchBox);
    }

    public static boolean isFroyoOrLater() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
    }

    public static boolean isHoneycombOrLater() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB;
    }

    public static QsbApplication get(Context context) {
        return ((QsbApplicationWrapper) context.getApplicationContext()).getApp();
    }

    protected Context getContext() {
        return mContext;
    }

    public int getVersionCode() {
        if (mVersionCode == 0) {
            try {
                PackageManager pm = getContext().getPackageManager();
                PackageInfo pkgInfo = pm.getPackageInfo(getContext().getPackageName(), 0);
                mVersionCode = pkgInfo.versionCode;
            } catch (PackageManager.NameNotFoundException ex) {
                // The current package should always exist, how else could we
                // run code from it?
                throw new RuntimeException(ex);
            }
        }
        return mVersionCode;
    }

    protected void checkThread() {
        if (Looper.myLooper() != Looper.getMainLooper()) {
            throw new IllegalStateException(""Accessed Application object from thread ""
                    + Thread.currentThread().getName());
        }
    }

    protected void close() {
        checkThread();
        if (mConfig != null) {
            mConfig.close();
            mConfig = null;
        }
        if (mSuggestionsProvider != null) {
            mSuggestionsProvider.close();
            mSuggestionsProvider = null;
        }
    }

    public synchronized Handler getMainThreadHandler() {
        if (mUiThreadHandler == null) {
            mUiThreadHandler = new Handler(Looper.getMainLooper());
        }
        return mUiThreadHandler;
    }

    public void runOnUiThread(Runnable action) {
        getMainThreadHandler().post(action);
    }

    public synchronized NamedTaskExecutor getIconLoaderExecutor() {
        if (mIconLoaderExecutor == null) {
            mIconLoaderExecutor = createIconLoaderExecutor();
        }
        return mIconLoaderExecutor;
    }

    protected NamedTaskExecutor createIconLoaderExecutor() {
        ThreadFactory iconThreadFactory = new PriorityThreadFactory(
                    Process.THREAD_PRIORITY_BACKGROUND);
        return new PerNameExecutor(SingleThreadNamedTaskExecutor.factory(iconThreadFactory));
    }

    /**
     * Indicates that construction of the QSB UI is now complete.
     */
    public void onStartupComplete() {
    }

    /**
     * Gets the QSB configuration object.
     * May be called from any thread.
     */
    public synchronized Config getConfig() {
        if (mConfig == null) {
            mConfig = createConfig();
        }
        return mConfig;
    }

    protected Config createConfig() {
        return new Config(getContext());
    }

    public synchronized SearchSettings getSettings() {
        if (mSettings == null) {
            mSettings = createSettings();
            mSettings.upgradeSettingsIfNeeded();
        }
        return mSettings;
    }

    protected SearchSettings createSettings() {
        return new SearchSettingsImpl(getContext(), getConfig());
    }

    protected Factory<Executor> createExecutorFactory(final int numThreads) {
        final ThreadFactory threadFactory = getQueryThreadFactory();
        return new Factory<Executor>() {
            @Override
            public Executor create() {
                return Executors.newFixedThreadPool(numThreads, threadFactory);
            }
        };
    }

    /**
    /**
     * Gets the source task executor.
     * May only be called from the main thread.
     */
    public NamedTaskExecutor getSourceTaskExecutor() {
        checkThread();
        if (mSourceTaskExecutor == null) {
            mSourceTaskExecutor = createSourceTaskExecutor();
        }
        return mSourceTaskExecutor;
    }

    protected NamedTaskExecutor createSourceTaskExecutor() {
        ThreadFactory queryThreadFactory = getQueryThreadFactory();
        return new PerNameExecutor(SingleThreadNamedTaskExecutor.factory(queryThreadFactory));
    }

    /**
     * Gets the query thread factory.
     * May only be called from the main thread.
     */
    protected ThreadFactory getQueryThreadFactory() {
        checkThread();
        if (mQueryThreadFactory == null) {
            mQueryThreadFactory = createQueryThreadFactory();
        }
        return mQueryThreadFactory;
    }

    protected ThreadFactory createQueryThreadFactory() {
        String nameFormat = ""QSB #%d"";
        int priority = getConfig().getQueryThreadPriority();
        return new ThreadFactoryBuilder()
                .setNameFormat(nameFormat)
                .setThreadFactory(new PriorityThreadFactory(priority))
                .build();
    }

    /**
     * Gets the suggestion provider.
     *
     * May only be called from the main thread.
     */
    protected SuggestionsProvider getSuggestionsProvider() {
        checkThread();
        if (mSuggestionsProvider == null) {
            mSuggestionsProvider = createSuggestionsProvider();
        }
        return mSuggestionsProvider;
    }

    protected SuggestionsProvider createSuggestionsProvider() {
        return new SuggestionsProviderImpl(getConfig(),
              getSourceTaskExecutor(),
              getMainThreadHandler(),
              getLogger());
    }

    /**
     * Gets the default suggestion view factory.
     * May only be called from the main thread.
     */
    public SuggestionViewFactory getSuggestionViewFactory() {
        checkThread();
        if (mSuggestionViewFactory == null) {
            mSuggestionViewFactory = createSuggestionViewFactory();
        }
        return mSuggestionViewFactory;
    }

    protected SuggestionViewFactory createSuggestionViewFactory() {
        return new DefaultSuggestionViewFactory(getContext());
    }

    /**
     * Gets the Google source.
     * May only be called from the main thread.
     */
    public GoogleSource getGoogleSource() {
        checkThread();
        if (mGoogleSource == null) {
            mGoogleSource = createGoogleSource();
        }
        return mGoogleSource;
    }

    protected GoogleSource createGoogleSource() {
        return new GoogleSuggestClient(getContext(), getMainThreadHandler(),
                getIconLoaderExecutor(), getConfig());
    }

    /**
     * Gets Voice Search utilities.
     */
    public VoiceSearch getVoiceSearch() {
        checkThread();
        if (mVoiceSearch == null) {
            mVoiceSearch = createVoiceSearch();
        }
        return mVoiceSearch;
    }

    protected VoiceSearch createVoiceSearch() {
        return new VoiceSearch(getContext());
    }

    /**
     * Gets the event logger.
     * May only be called from the main thread.
     */
    public Logger getLogger() {
        checkThread();
        if (mLogger == null) {
            mLogger = createLogger();
        }
        return mLogger;
    }

    protected Logger createLogger() {
        return new EventLogLogger(getContext(), getConfig());
    }

    public SuggestionFormatter getSuggestionFormatter() {
        if (mSuggestionFormatter == null) {
            mSuggestionFormatter = createSuggestionFormatter();
        }
        return mSuggestionFormatter;
    }

    protected SuggestionFormatter createSuggestionFormatter() {
        return new LevenshteinSuggestionFormatter(getTextAppearanceFactory());
    }

    public TextAppearanceFactory getTextAppearanceFactory() {
        if (mTextAppearanceFactory == null) {
            mTextAppearanceFactory = createTextAppearanceFactory();
        }
        return mTextAppearanceFactory;
    }

    protected TextAppearanceFactory createTextAppearanceFactory() {
        return new TextAppearanceFactory(getContext());
    }

    public synchronized HttpHelper getHttpHelper() {
        if (mHttpHelper == null) {
            mHttpHelper = createHttpHelper();
        }
        return mHttpHelper;
    }

    protected HttpHelper createHttpHelper() {
        return new JavaNetHttpHelper(
                new JavaNetHttpHelper.PassThroughRewriter(),
                getConfig().getUserAgent());
    }

    public synchronized SearchBaseUrlHelper getSearchBaseUrlHelper() {
        if (mSearchBaseUrlHelper == null) {
            mSearchBaseUrlHelper = createSearchBaseUrlHelper();
        }

        return mSearchBaseUrlHelper;
    }

    protected SearchBaseUrlHelper createSearchBaseUrlHelper() {
        // This cast to ""SearchSettingsImpl"" is somewhat ugly.
        return new SearchBaseUrlHelper(getContext(), getHttpHelper(),
                getSettings(), ((SearchSettingsImpl)getSettings()).getSearchPreferences());
    }

    public Help getHelp() {
        // No point caching this, it's super cheap.
        return new Help(getContext(), getConfig());
    }
}
",False,78,2,4,4,33,5,33,L5
3,com.android.quicksearchbox.SearchSettings.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * Interface for search settings.
 *
 * NOTE: Currently, this is not used very widely, in most instances
 * implementers of this interface are passed around by class name.
 * Should this be deprecated ?
 */
public interface SearchSettings {

    public void upgradeSettingsIfNeeded();

    /**
     * Informs our listeners about the updated settings data.
     */
    public void broadcastSettingsChanged();

    public int getNextVoiceSearchHintIndex(int size);

    public void resetVoiceSearchHintFirstSeenTime();

    public boolean haveVoiceSearchHintsExpired(int currentVoiceSearchVersion);

    /**
     * Determines whether google.com should be used as the base path
     * for all searches (as opposed to using its country specific variants).
     */
    public boolean shouldUseGoogleCom();

    public void setUseGoogleCom(boolean useGoogleCom);

    public long getSearchBaseDomainApplyTime();

    public String getSearchBaseDomain();

    public void setSearchBaseDomain(String searchBaseUrl);
}
",False,79,3,3,5,35,5,5,L5
4,com.android.quicksearchbox.PackageIconLoader.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.CachedLater;
import com.android.quicksearchbox.util.NamedTask;
import com.android.quicksearchbox.util.NamedTaskExecutor;
import com.android.quicksearchbox.util.Now;
import com.android.quicksearchbox.util.NowOrLater;
import com.android.quicksearchbox.util.Util;

import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Handler;
import android.text.TextUtils;
import android.util.Log;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;

/**
 * Loads icons from other packages.
 *
 * Code partly stolen from {@link ContentResolver} and android.app.SuggestionsAdapter.
  */
public class PackageIconLoader implements IconLoader {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.PackageIconLoader"";

    private final Context mContext;

    private final String mPackageName;

    private Context mPackageContext;

    private final Handler mUiThread;

    private final NamedTaskExecutor mIconLoaderExecutor;

    /**
     * Creates a new icon loader.
     *
     * @param context The QSB application context.
     * @param packageName The name of the package from which the icons will be loaded.
     *        Resource IDs without an explicit package will be resolved against the package
     *        of this context.
     */
    public PackageIconLoader(Context context, String packageName, Handler uiThread,
            NamedTaskExecutor iconLoaderExecutor) {
        mContext = context;
        mPackageName = packageName;
        mUiThread = uiThread;
        mIconLoaderExecutor = iconLoaderExecutor;
    }

    private boolean ensurePackageContext() {
        if (mPackageContext == null) {
            try {
                mPackageContext = mContext.createPackageContext(mPackageName,
                        Context.CONTEXT_RESTRICTED);
            } catch (PackageManager.NameNotFoundException ex) {
                // This should only happen if the app has just be uninstalled
                Log.e(TAG, ""Application not found "" + mPackageName);
                return false;
            }
        }
        return true;
    }

    public NowOrLater<Drawable> getIcon(final String drawableId) {
        if (DBG) Log.d(TAG, ""getIcon("" + drawableId + "")"");
        if (TextUtils.isEmpty(drawableId) || ""0"".equals(drawableId)) {
            return new Now<Drawable>(null);
        }
        if (!ensurePackageContext()) {
            return new Now<Drawable>(null);
        }
        NowOrLater<Drawable> drawable;
        try {
            // First, see if it's just an integer
            int resourceId = Integer.parseInt(drawableId);
            // If so, find it by resource ID
            Drawable icon = mPackageContext.getResources().getDrawable(resourceId);
            drawable = new Now<Drawable>(icon);
        } catch (NumberFormatException nfe) {
            // It's not an integer, use it as a URI
            Uri uri = Uri.parse(drawableId);
            if (ContentResolver.SCHEME_ANDROID_RESOURCE.equals(uri.getScheme())) {
                // load all resources synchronously, to reduce UI flickering
                drawable = new Now<Drawable>(getDrawable(uri));
            } else {
                drawable = new IconLaterTask(uri);
            }
        } catch (Resources.NotFoundException nfe) {
            // It was an integer, but it couldn't be found, bail out
            Log.w(TAG, ""Icon resource not found: "" + drawableId);
            drawable = new Now<Drawable>(null);
        }
        return drawable;
    }

    public Uri getIconUri(String drawableId) {
        if (TextUtils.isEmpty(drawableId) || ""0"".equals(drawableId)) {
            return null;
        }
        if (!ensurePackageContext()) return null;
        try {
            int resourceId = Integer.parseInt(drawableId);
            return Util.getResourceUri(mPackageContext, resourceId);
        } catch (NumberFormatException nfe) {
            return Uri.parse(drawableId);
        }
    }

    /**
     * Gets a drawable by URI.
     *
     * @return A drawable, or {@code null} if the drawable could not be loaded.
     */
    private Drawable getDrawable(Uri uri) {
        try {
            String scheme = uri.getScheme();
            if (ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme)) {
                // Load drawables through Resources, to get the source density information
                OpenResourceIdResult r = getResourceId(uri);
                try {
                    return r.r.getDrawable(r.id);
                } catch (Resources.NotFoundException ex) {
                    throw new FileNotFoundException(""Resource does not exist: "" + uri);
                }
            } else {
                // Let the ContentResolver handle content and file URIs.
                InputStream stream = mPackageContext.getContentResolver().openInputStream(uri);
                if (stream == null) {
                    throw new FileNotFoundException(""Failed to open "" + uri);
                }
                try {
                    return Drawable.createFromStream(stream, null);
                } finally {
                    try {
                        stream.close();
                    } catch (IOException ex) {
                        Log.e(TAG, ""Error closing icon stream for "" + uri, ex);
                    }
                }
            }
        } catch (FileNotFoundException fnfe) {
            Log.w(TAG, ""Icon not found: "" + uri + "", "" + fnfe.getMessage());
            return null;
        }
    }

    /**
     * A resource identified by the {@link Resources} that contains it, and a resource id.
     */
    private class OpenResourceIdResult {
        public Resources r;
        public int id;
    }

    /**
     * Resolves an android.resource URI to a {@link Resources} and a resource id.
     */
    private OpenResourceIdResult getResourceId(Uri uri) throws FileNotFoundException {
        String authority = uri.getAuthority();
        Resources r;
        if (TextUtils.isEmpty(authority)) {
            throw new FileNotFoundException(""No authority: "" + uri);
        } else {
            try {
                r = mPackageContext.getPackageManager().getResourcesForApplication(authority);
            } catch (NameNotFoundException ex) {
                throw new FileNotFoundException(""Failed to get resources: "" + ex);
            }
        }
        List<String> path = uri.getPathSegments();
        if (path == null) {
            throw new FileNotFoundException(""No path: "" + uri);
        }
        int len = path.size();
        int id;
        if (len == 1) {
            try {
                id = Integer.parseInt(path.get(0));
            } catch (NumberFormatException e) {
                throw new FileNotFoundException(""Single path segment is not a resource ID: "" + uri);
            }
        } else if (len == 2) {
            id = r.getIdentifier(path.get(1), path.get(0), authority);
        } else {
            throw new FileNotFoundException(""More than two path segments: "" + uri);
        }
        if (id == 0) {
            throw new FileNotFoundException(""No resource found for: "" + uri);
        }
        OpenResourceIdResult res = new OpenResourceIdResult();
        res.r = r;
        res.id = id;
        return res;
    }

    private class IconLaterTask extends CachedLater<Drawable> implements NamedTask {
        private final Uri mUri;

        public IconLaterTask(Uri iconUri) {
            mUri = iconUri;
        }

        @Override
        protected void create() {
            mIconLoaderExecutor.execute(this);
        }

        @Override
        public void run() {
            final Drawable icon = getIcon();
            mUiThread.post(new Runnable(){
                public void run() {
                    store(icon);
                }});
        }

        @Override
        public String getName() {
            return mPackageName;
        }

        private Drawable getIcon() {
            try {
                return getDrawable(mUri);
            } catch (Throwable t) {
                // we're making a call into another package, which could throw any exception.
                // Make sure it doesn't crash QSB
                Log.e(TAG, ""Failed to load icon "" + mUri, t);
                return null;
            }
        }
    }
}
",True,19,6,5,1,2,2,2,L1
5,com.android.quicksearchbox.CursorBackedSuggestionCursor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.app.SearchManager;
import android.content.ComponentName;
import android.content.Intent;
import android.database.Cursor;
import android.database.DataSetObserver;
import android.net.Uri;
import android.util.Log;

public abstract class CursorBackedSuggestionCursor implements SuggestionCursor {

    private static final boolean DBG = false;
    protected static final String TAG = ""QSB.CursorBackedSuggestionCursor"";

    public static final String SUGGEST_COLUMN_LOG_TYPE = ""suggest_log_type"";

    private final String mUserQuery;

    /** The suggestions, or {@code null} if the suggestions query failed. */
    protected final Cursor mCursor;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_FORMAT} in @{link mCursor}. */
    private final int mFormatCol;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_TEXT_1} in @{link mCursor}. */
    private final int mText1Col;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_TEXT_2} in @{link mCursor}. */
    private final int mText2Col;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_TEXT_2_URL} in @{link mCursor}. */
    private final int mText2UrlCol;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_ICON_1} in @{link mCursor}. */
    private final int mIcon1Col;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_ICON_1} in @{link mCursor}. */
    private final int mIcon2Col;

    /** Column index of {@link SearchManager#SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING}
     * in @{link mCursor}.
     **/
    private final int mRefreshSpinnerCol;

    /** True if this result has been closed. */
    private boolean mClosed = false;

    public CursorBackedSuggestionCursor(String userQuery, Cursor cursor) {
        mUserQuery = userQuery;
        mCursor = cursor;
        mFormatCol = getColumnIndex(SearchManager.SUGGEST_COLUMN_FORMAT);
        mText1Col = getColumnIndex(SearchManager.SUGGEST_COLUMN_TEXT_1);
        mText2Col = getColumnIndex(SearchManager.SUGGEST_COLUMN_TEXT_2);
        mText2UrlCol = getColumnIndex(SearchManager.SUGGEST_COLUMN_TEXT_2_URL);
        mIcon1Col = getColumnIndex(SearchManager.SUGGEST_COLUMN_ICON_1);
        mIcon2Col = getColumnIndex(SearchManager.SUGGEST_COLUMN_ICON_2);
        mRefreshSpinnerCol = getColumnIndex(SearchManager.SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING);
    }

    public String getUserQuery() {
        return mUserQuery;
    }

    public abstract Source getSuggestionSource();

    public String getSuggestionLogType() {
        return getStringOrNull(SUGGEST_COLUMN_LOG_TYPE);
    }

    public void close() {
        if (DBG) Log.d(TAG, ""close()"");
        if (mClosed) {
            throw new IllegalStateException(""Double close()"");
        }
        mClosed = true;
        if (mCursor != null) {
            try {
                mCursor.close();
            } catch (RuntimeException ex) {
                // all operations on cross-process cursors can throw random exceptions
                Log.e(TAG, ""close() failed, "", ex);
            }
        }
    }

    @Override
    protected void finalize() {
        if (!mClosed) {
            Log.e(TAG, ""LEAK! Finalized without being closed: "" + toString());
        }
    }

    public int getCount() {
        if (mClosed) {
            throw new IllegalStateException(""getCount() after close()"");
        }
        if (mCursor == null) return 0;
        try {
            return mCursor.getCount();
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getCount() failed, "", ex);
            return 0;
        }
    }

    public void moveTo(int pos) {
        if (mClosed) {
            throw new IllegalStateException(""moveTo("" + pos + "") after close()"");
        }
        try {
            if (!mCursor.moveToPosition(pos)) {
                Log.e(TAG, ""moveToPosition("" + pos + "") failed, count="" + getCount());
            }
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""moveToPosition() failed, "", ex);
        }
    }

    public boolean moveToNext() {
        if (mClosed) {
            throw new IllegalStateException(""moveToNext() after close()"");
        }
        try {
            return mCursor.moveToNext();
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""moveToNext() failed, "", ex);
            return false;
        }
    }

    public int getPosition() {
        if (mClosed) {
            throw new IllegalStateException(""getPosition after close()"");
        }
        try {
            return mCursor.getPosition();
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getPosition() failed, "", ex);
            return -1;
        }
    }

    public String getShortcutId() {
        return getStringOrNull(SearchManager.SUGGEST_COLUMN_SHORTCUT_ID);
    }

    public String getSuggestionFormat() {
        return getStringOrNull(mFormatCol);
    }

    public String getSuggestionText1() {
        return getStringOrNull(mText1Col);
    }

    public String getSuggestionText2() {
        return getStringOrNull(mText2Col);
    }

    public String getSuggestionText2Url() {
        return getStringOrNull(mText2UrlCol);
    }

    public String getSuggestionIcon1() {
        return getStringOrNull(mIcon1Col);
    }

    public String getSuggestionIcon2() {
        return getStringOrNull(mIcon2Col);
    }

    public boolean isSpinnerWhileRefreshing() {
        return ""true"".equals(getStringOrNull(mRefreshSpinnerCol));
    }

    /**
     * Gets the intent action for the current suggestion.
     */
    public String getSuggestionIntentAction() {
        String action = getStringOrNull(SearchManager.SUGGEST_COLUMN_INTENT_ACTION);
        if (action != null) return action;
        return getSuggestionSource().getDefaultIntentAction();
    }

    public abstract ComponentName getSuggestionIntentComponent();

    /**
     * Gets the query for the current suggestion.
     */
    public String getSuggestionQuery() {
        return getStringOrNull(SearchManager.SUGGEST_COLUMN_QUERY);
    }

    public String getSuggestionIntentDataString() {
         // use specific data if supplied, or default data if supplied
         String data = getStringOrNull(SearchManager.SUGGEST_COLUMN_INTENT_DATA);
         if (data == null) {
             data = getSuggestionSource().getDefaultIntentData();
         }
         // then, if an ID was provided, append it.
         if (data != null) {
             String id = getStringOrNull(SearchManager.SUGGEST_COLUMN_INTENT_DATA_ID);
             if (id != null) {
                 data = data + ""/"" + Uri.encode(id);
             }
         }
         return data;
     }

    /**
     * Gets the intent extra data for the current suggestion.
     */
    public String getSuggestionIntentExtraData() {
        return getStringOrNull(SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA);
    }

    public boolean isWebSearchSuggestion() {
        return Intent.ACTION_WEB_SEARCH.equals(getSuggestionIntentAction());
    }

    /**
     * Gets the index of a column in {@link #mCursor} by name.
     *
     * @return The index, or {@code -1} if the column was not found.
     */
    protected int getColumnIndex(String colName) {
        if (mCursor == null) return -1;
        try {
            return mCursor.getColumnIndex(colName);
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getColumnIndex() failed, "", ex);
            return -1;
        }
    }

    /**
     * Gets the string value of a column in {@link #mCursor} by column index.
     *
     * @param col Column index.
     * @return The string value, or {@code null}.
     */
    protected String getStringOrNull(int col) {
        if (mCursor == null) return null;
        if (col == -1) {
            return null;
        }
        try {
            return mCursor.getString(col);
        } catch (RuntimeException ex) {
            // all operations on cross-process cursors can throw random exceptions
            Log.e(TAG, ""getString() failed, "", ex);
            return null;
        }
    }

    /**
     * Gets the string value of a column in {@link #mCursor} by column name.
     *
     * @param colName Column name.
     * @return The string value, or {@code null}.
     */
    protected String getStringOrNull(String colName) {
        int col = getColumnIndex(colName);
        return getStringOrNull(col);
    }

    public void registerDataSetObserver(DataSetObserver observer) {
        // We don't watch Cursor-backed SuggestionCursors for changes
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
        // We don't watch Cursor-backed SuggestionCursors for changes
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + ""["" + mUserQuery + ""]"";
    }

}
",True,24,5,6,2,3,3,2,L4
6,com.android.quicksearchbox.SearchWidgetProvider.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.common.Search;
import com.android.common.speech.Recognition;
import com.android.quicksearchbox.util.Util;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.SearchManager;
import android.appwidget.AppWidgetManager;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.graphics.Typeface;
import android.net.Uri;
import android.os.Bundle;
import android.os.SystemClock;
import android.speech.RecognizerIntent;
import android.text.Annotation;
import android.text.SpannableStringBuilder;
import android.text.TextUtils;
import android.text.style.StyleSpan;
import android.util.Log;
import android.view.View;
import android.widget.RemoteViews;

import java.util.ArrayList;
import java.util.Random;

/**
 * Search widget provider.
 *
 */
public class SearchWidgetProvider extends BroadcastReceiver {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SearchWidgetProvider"";

    /**
     * The {@link Search#SOURCE} value used when starting searches from the search widget.
     */
    private static final String WIDGET_SEARCH_SOURCE = ""launcher-widget"";

    @Override
    public void onReceive(Context context, Intent intent) {
        if (DBG) Log.d(TAG, ""onReceive("" + intent.toUri(0) + "")"");
        String action = intent.getAction();
        if (AppWidgetManager.ACTION_APPWIDGET_ENABLED.equals(action)) {
            // nothing needs doing
        } else if (AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
            updateSearchWidgets(context);
        } else {
            if (DBG) Log.d(TAG, ""Unhandled intent action="" + action);
        }
    }

    private static SearchWidgetState[] getSearchWidgetStates(Context context) {
        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
        int[] appWidgetIds = appWidgetManager.getAppWidgetIds(myComponentName(context));
        SearchWidgetState[] states = new SearchWidgetState[appWidgetIds.length];
        for (int i = 0; i<appWidgetIds.length; ++i) {
            states[i] = getSearchWidgetState(context, appWidgetIds[i]);
        }
        return states;
    }


    /**
     * Updates all search widgets.
     */
    public static void updateSearchWidgets(Context context) {
        if (DBG) Log.d(TAG, ""updateSearchWidgets"");
        SearchWidgetState[] states = getSearchWidgetStates(context);

        for (SearchWidgetState state : states) {
            state.updateWidget(context, AppWidgetManager.getInstance(context));
        }
    }

    /**
     * Gets the component name of this search widget provider.
     */
    private static ComponentName myComponentName(Context context) {
        String pkg = context.getPackageName();
        String cls = pkg + "".SearchWidgetProvider"";
        return new ComponentName(pkg, cls);
    }

    private static Intent createQsbActivityIntent(Context context, String action,
            Bundle widgetAppData) {
        Intent qsbIntent = new Intent(action);
        qsbIntent.setPackage(context.getPackageName());
        qsbIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                | Intent.FLAG_ACTIVITY_CLEAR_TOP
                | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
        qsbIntent.putExtra(SearchManager.APP_DATA, widgetAppData);
        return qsbIntent;
    }

    private static SearchWidgetState getSearchWidgetState(Context context, int appWidgetId) {
        if (DBG) Log.d(TAG, ""Creating appwidget state "" + appWidgetId);
        SearchWidgetState state = new SearchWidgetState(appWidgetId);

        Bundle widgetAppData = new Bundle();
        widgetAppData.putString(Search.SOURCE, WIDGET_SEARCH_SOURCE);

        // Text field click
        Intent qsbIntent = createQsbActivityIntent(
                context,
                SearchManager.INTENT_ACTION_GLOBAL_SEARCH,
                widgetAppData);
        state.setQueryTextViewIntent(qsbIntent);

        // Voice search button
        Intent voiceSearchIntent = getVoiceSearchIntent(context, widgetAppData);
        state.setVoiceSearchIntent(voiceSearchIntent);

        return state;
    }

    private static Intent getVoiceSearchIntent(Context context, Bundle widgetAppData) {
        VoiceSearch voiceSearch = QsbApplication.get(context).getVoiceSearch();
        return voiceSearch.createVoiceWebSearchIntent(widgetAppData);
    }

    private static class SearchWidgetState {
        private final int mAppWidgetId;
        private Intent mQueryTextViewIntent;
        private Intent mVoiceSearchIntent;

        public SearchWidgetState(int appWidgetId) {
            mAppWidgetId = appWidgetId;
        }

        public void setQueryTextViewIntent(Intent queryTextViewIntent) {
            mQueryTextViewIntent = queryTextViewIntent;
        }

        public void setVoiceSearchIntent(Intent voiceSearchIntent) {
            mVoiceSearchIntent = voiceSearchIntent;
        }

        public void updateWidget(Context context,AppWidgetManager appWidgetMgr) {
            if (DBG) Log.d(TAG, ""Updating appwidget "" + mAppWidgetId);
            RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.search_widget);

            setOnClickActivityIntent(context, views, R.id.search_widget_text,
                    mQueryTextViewIntent);
            // Voice Search button
            if (mVoiceSearchIntent != null) {
                setOnClickActivityIntent(context, views, R.id.search_widget_voice_btn,
                        mVoiceSearchIntent);
                views.setViewVisibility(R.id.search_widget_voice_btn, View.VISIBLE);
            } else {
                views.setViewVisibility(R.id.search_widget_voice_btn, View.GONE);
            }

            appWidgetMgr.updateAppWidget(mAppWidgetId, views);
        }

        private void setOnClickActivityIntent(Context context, RemoteViews views, int viewId,
                Intent intent) {
            PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);
            views.setOnClickPendingIntent(viewId, pendingIntent);
        }
    }

}
",True,84,0,0,5,52,1,8,L7
7,com.android.quicksearchbox.SuggestionPosition.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * A pointer to a suggestion in a {@link SuggestionCursor}.
 *
 */
public class SuggestionPosition extends AbstractSuggestionWrapper {

    private final SuggestionCursor mCursor;

    private final int mPosition;

    public SuggestionPosition(SuggestionCursor cursor) {
        this(cursor, cursor.getPosition());
    }

    public SuggestionPosition(SuggestionCursor cursor, int suggestionPos) {
        mCursor = cursor;
        mPosition = suggestionPos;
    }

    public SuggestionCursor getCursor() {
        return mCursor;
    }

    /**
     * Gets the suggestion cursor, moved to point to the right suggestion.
     */
    @Override
    protected Suggestion current() {
        mCursor.moveTo(mPosition);
        return mCursor;
    }

    public int getPosition() {
        return mPosition;
    }

    @Override
    public String toString() {
        return mCursor + "":"" + mPosition;
    }

}
",False,45,5,14,3,2,14,1,L2
8,com.android.quicksearchbox.Logger.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;



/**
 * Interface for logging implementations.
 */
public interface Logger {

    public static final int SEARCH_METHOD_BUTTON = 0;
    public static final int SEARCH_METHOD_KEYBOARD = 1;

    public static final int SUGGESTION_CLICK_TYPE_LAUNCH = 0;
    public static final int SUGGESTION_CLICK_TYPE_REFINE = 1;
    public static final int SUGGESTION_CLICK_TYPE_QUICK_CONTACT = 2;

    /**
     * Called when QSB has started.
     *
     * @param latency User-visible start-up latency in milliseconds.
     */
    void logStart(int onCreateLatency, int latency, String intentSource);

    /**
     * Called when a suggestion is clicked.
     *
     * @param suggestionId Suggestion ID; 0-based position of the suggestion in the UI if the list
     *      is flat.
     * @param suggestionCursor all the suggestions shown in the UI.
     * @param clickType One of the SUGGESTION_CLICK_TYPE constants.
     */
    void logSuggestionClick(long suggestionId, SuggestionCursor suggestionCursor,  int clickType);

    /**
     * The user launched a search.
     *
     * @param startMethod One of {@link #SEARCH_METHOD_BUTTON} or {@link #SEARCH_METHOD_KEYBOARD}.
     * @param numChars The number of characters in the query.
     */
    void logSearch(int startMethod, int numChars);

    /**
     * The user launched a voice search.
     */
    void logVoiceSearch();

    /**
     * The user left QSB without performing any action (click suggestions, search or voice search).
     *
     * @param suggestionCursor all the suggestions shown in the UI when the user left
     * @param numChars The number of characters in the query typed when the user left.
     */
    void logExit(SuggestionCursor suggestionCursor, int numChars);

    /**
     * Logs the latency of a suggestion query to a specific source.
     *
     * @param result The result of the query.
     */
    void logLatency(SourceResult result);

}
",False,25,5,5,3,3,4,3,L5
9,com.android.quicksearchbox.ListSuggestionCursorNoDuplicates.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.util.Log;

import java.util.HashSet;

/**
 * A SuggestionCursor that is backed by a list of SuggestionPosition objects
 * and doesn't allow duplicate suggestions.
 */
public class ListSuggestionCursorNoDuplicates extends ListSuggestionCursor {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.ListSuggestionCursorNoDuplicates"";

    private final HashSet<String> mSuggestionKeys;

    public ListSuggestionCursorNoDuplicates(String userQuery) {
        super(userQuery);
        mSuggestionKeys = new HashSet<String>();
    }

    @Override
    public boolean add(Suggestion suggestion) {
        String key = SuggestionUtils.getSuggestionKey(suggestion);
        if (mSuggestionKeys.add(key)) {
            return super.add(suggestion);
        } else {
            if (DBG) Log.d(TAG, ""Rejecting duplicate "" + key);
            return false;
        }
    }

}
",False,32,7,7,3,3,1,3,L4
10,com.android.quicksearchbox.SuggestionCursor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

import com.android.quicksearchbox.util.QuietlyCloseable;

import android.database.DataSetObserver;

import java.util.Collection;

/**
 * A sequence of suggestions, with a current position.
 */
public interface SuggestionCursor extends Suggestion, QuietlyCloseable {

    /**
     * Gets the query that the user typed to get this suggestion.
     */
    String getUserQuery();

    /**
     * Gets the number of suggestions in this result.
     *
     * @return The number of suggestions, or {@code 0} if this result represents a failed query.
     */
    int getCount();

    /**
     * Moves to a given suggestion.
     *
     * @param pos The position to move to.
     * @throws IndexOutOfBoundsException if {@code pos < 0} or {@code pos >= getCount()}.
     */
    void moveTo(int pos);

    /**
     * Moves to the next suggestion, if there is one.
     *
     * @return {@code false} if there is no next suggestion.
     */
    boolean moveToNext();

    /**
     * Gets the current position within the cursor.
     */
    int getPosition();

    /**
     * Frees any resources used by this cursor.
     */
    @Override
    void close();

    /**
     * Register an observer that is called when changes happen to this data set.
     *
     * @param observer gets notified when the data set changes.
     */
    void registerDataSetObserver(DataSetObserver observer);

    /**
     * Unregister an observer that has previously been registered with 
     * {@link #registerDataSetObserver(DataSetObserver)}
     *
     * @param observer the observer to unregister.
     */
    void unregisterDataSetObserver(DataSetObserver observer);

    /**
     * Return the extra columns present in this cursor, or null if none exist.
     */
    Collection<String> getExtraColumns();
}
",False,81,3,45,2,2,48,1,L0
11,com.android.quicksearchbox.EventLogLogger.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.content.Context;
import android.util.EventLog;

import java.util.Collection;
import java.util.List;
import java.util.Random;

/**
 * Logs events to {@link EventLog}.
 */
public class EventLogLogger implements Logger {

    private static final char LIST_SEPARATOR = '|';

    private final Context mContext;

    private final Config mConfig;

    private final String mPackageName;

    private final Random mRandom;

    public EventLogLogger(Context context, Config config) {
        mContext = context;
        mConfig = config;
        mPackageName = mContext.getPackageName();
        mRandom = new Random();
    }

    protected Context getContext() {
        return mContext;
    }

    protected int getVersionCode() {
        return QsbApplication.get(getContext()).getVersionCode();
    }

    protected Config getConfig() {
        return mConfig;
    }

    @Override
    public void logStart(int onCreateLatency, int latency, String intentSource) {
        // TODO: Add more info to startMethod
        String startMethod = intentSource;
        EventLogTags.writeQsbStart(mPackageName, getVersionCode(), startMethod,
                latency, null, null, onCreateLatency);
    }

    @Override
    public void logSuggestionClick(long id, SuggestionCursor suggestionCursor, int clickType) {
        String suggestions = getSuggestions(suggestionCursor);
        int numChars = suggestionCursor.getUserQuery().length();
        EventLogTags.writeQsbClick(id, suggestions, null, numChars,
                clickType);
    }

    @Override
    public void logSearch(int startMethod, int numChars) {
        EventLogTags.writeQsbSearch(null, startMethod, numChars);
    }

    @Override
    public void logVoiceSearch() {
        EventLogTags.writeQsbVoiceSearch(null);
    }

    @Override
    public void logExit(SuggestionCursor suggestionCursor, int numChars) {
        String suggestions = getSuggestions(suggestionCursor);
        EventLogTags.writeQsbExit(suggestions, numChars);
    }

    @Override
    public void logLatency(SourceResult result) {
    }

    private String getSuggestions(SuggestionCursor cursor) {
        StringBuilder sb = new StringBuilder();
        final int count = cursor == null ? 0 : cursor.getCount();
        for (int i = 0; i < count; i++) {
            if (i > 0) sb.append(LIST_SEPARATOR);
            cursor.moveTo(i);
            String source = cursor.getSuggestionSource().getName();
            String type = cursor.getSuggestionLogType();
            if (type == null) type = """";
            String shortcut = cursor.isSuggestionShortcut() ? ""shortcut"" : """";
            sb.append(source).append(':').append(type).append(':').append(shortcut);
        }
        return sb.toString();
    }

}
",True,25,5,5,3,6,1,6,L5
12,com.android.quicksearchbox.SuggestionsProviderImpl.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.os.Handler;
import android.util.Log;

import com.android.quicksearchbox.util.BatchingNamedTaskExecutor;
import com.android.quicksearchbox.util.Consumer;
import com.android.quicksearchbox.util.NamedTaskExecutor;
import com.android.quicksearchbox.util.NoOpConsumer;

/**
 * Suggestions provider implementation.
 *
 * The provider will only handle a single query at a time. If a new query comes
 * in, the old one is cancelled.
 */
public class SuggestionsProviderImpl implements SuggestionsProvider {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SuggestionsProviderImpl"";

    private final Config mConfig;

    private final NamedTaskExecutor mQueryExecutor;

    private final Handler mPublishThread;

    private final Logger mLogger;

    public SuggestionsProviderImpl(Config config,
            NamedTaskExecutor queryExecutor,
            Handler publishThread,
            Logger logger) {
        mConfig = config;
        mQueryExecutor = queryExecutor;
        mPublishThread = publishThread;
        mLogger = logger;
    }

    @Override
    public void close() {
    }

    @Override
    public Suggestions getSuggestions(String query, Source sourceToQuery) {
        if (DBG) Log.d(TAG, ""getSuggestions("" + query + "")"");
        final Suggestions suggestions = new Suggestions(query, sourceToQuery);
        Log.i(TAG, ""chars:"" + query.length() + "",source:"" + sourceToQuery);

        Consumer<SourceResult> receiver;
        if (shouldDisplayResults(query)) {
            receiver = new SuggestionCursorReceiver(suggestions);
        } else {
            receiver = new NoOpConsumer<SourceResult>();
            suggestions.done();
        }

        int maxResults = mConfig.getMaxResultsPerSource();
        QueryTask.startQuery(query, maxResults, sourceToQuery, mQueryExecutor,
                mPublishThread, receiver);

        return suggestions;
    }

    private boolean shouldDisplayResults(String query) {
        if (query.length() == 0 && !mConfig.showSuggestionsForZeroQuery()) {
            // Note that even though we don't display such results, it's
            // useful to run the query itself because it warms up the network
            // connection.
            return false;
        }
        return true;
    }


    private class SuggestionCursorReceiver implements Consumer<SourceResult> {
        private final Suggestions mSuggestions;

        public SuggestionCursorReceiver(Suggestions suggestions) {
            mSuggestions = suggestions;
        }

        @Override
        public boolean consume(SourceResult cursor) {
            if (DBG) {
                Log.d(TAG, ""SuggestionCursorReceiver.consume("" + cursor + "") corpus="" +
                        cursor.getSource() + "" count = "" + cursor.getCount());
            }
            // publish immediately
            if (DBG) Log.d(TAG, ""Publishing results"");
            mSuggestions.addResults(cursor);
            if (cursor != null && mLogger != null) {
                mLogger.logLatency(cursor);
            }
            return true;
        }

    }
}
",True,42,5,5,3,16,1,16,L5
13,com.android.quicksearchbox.AbstractSuggestionCursorWrapper.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox;

/**
 * A SuggestionCursor that delegates all calls to other suggestions.
 */
public abstract class AbstractSuggestionCursorWrapper extends AbstractSuggestionWrapper
        implements SuggestionCursor {

    private final String mUserQuery;

    public AbstractSuggestionCursorWrapper(String userQuery) {
        mUserQuery = userQuery;
    }

    public String getUserQuery() {
        return mUserQuery;
    }
}
",False,53,5,18,2,3,4,3,L1
14,com.android.quicksearchbox.Config.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.app.AlarmManager;
import android.content.Context;
import android.net.Uri;
import android.os.Process;
import android.util.Log;

import java.util.HashSet;

/**
 * Provides values for configurable parameters in all of QSB.
 *
 * All the methods in this class return fixed default values. Subclasses may
 * make these values server-side settable.
 *
 */
public class Config {

    private static final String TAG = ""QSB.Config"";
    private static final boolean DBG = false;

    protected static final long SECOND_MILLIS = 1000L;
    protected static final long MINUTE_MILLIS = 60L * SECOND_MILLIS;
    protected static final long DAY_MILLIS = 86400000L;

    private static final int NUM_PROMOTED_SOURCES = 3;
    private static final int MAX_RESULTS_PER_SOURCE = 50;
    private static final long SOURCE_TIMEOUT_MILLIS = 10000;

    private static final int QUERY_THREAD_PRIORITY =
            Process.THREAD_PRIORITY_BACKGROUND + Process.THREAD_PRIORITY_MORE_FAVORABLE;

    private static final long MAX_STAT_AGE_MILLIS = 30 * DAY_MILLIS;
    private static final int MIN_CLICKS_FOR_SOURCE_RANKING = 3;

    private static final int NUM_WEB_CORPUS_THREADS = 2;

    private static final int LATENCY_LOG_FREQUENCY = 1000;

    private static final long TYPING_SUGGESTIONS_UPDATE_DELAY_MILLIS = 100;
    private static final long PUBLISH_RESULT_DELAY_MILLIS = 200;

    private static final long VOICE_SEARCH_HINT_ACTIVE_PERIOD = 7L * DAY_MILLIS;

    private static final long VOICE_SEARCH_HINT_UPDATE_INTERVAL
            = AlarmManager.INTERVAL_FIFTEEN_MINUTES;

    private static final long VOICE_SEARCH_HINT_SHOW_PERIOD_MILLIS
            = AlarmManager.INTERVAL_HOUR * 2;

    private static final long VOICE_SEARCH_HINT_CHANGE_PERIOD = 2L * MINUTE_MILLIS;

    private static final long VOICE_SEARCH_HINT_VISIBLE_PERIOD = 6L * MINUTE_MILLIS;

    private static final int HTTP_CONNECT_TIMEOUT_MILLIS = 4000;
    private static final int HTTP_READ_TIMEOUT_MILLIS = 4000;

    private static final String USER_AGENT = ""Android/1.0"";

    private final Context mContext;
    private HashSet<String> mDefaultCorpora;
    private HashSet<String> mHiddenCorpora;
    private HashSet<String> mDefaultCorporaSuggestUris;

    /**
     * Creates a new config that uses hard-coded default values.
     */
    public Config(Context context) {
        mContext = context;
    }

    protected Context getContext() {
        return mContext;
    }

    /**
     * Releases any resources used by the configuration object.
     *
     * Default implementation does nothing.
     */
    public void close() {
    }

    private HashSet<String> loadResourceStringSet(int res) {
        HashSet<String> set = new HashSet<String>();
        String[] items = mContext.getResources().getStringArray(res);
        for (String item : items) {
            set.add(item);
        }
        return set;
    }

    /**
     * The number of promoted sources.
     */
    public int getNumPromotedSources() {
        return NUM_PROMOTED_SOURCES;
    }

    /**
     * The number of suggestions visible above the onscreen keyboard.
     */
    public int getNumSuggestionsAboveKeyboard() {
        // Get the list of default corpora from a resource, which allows vendor overlays.
        return mContext.getResources().getInteger(R.integer.num_suggestions_above_keyboard);
    }

    /**
     * The maximum number of suggestions to promote.
     */
    public int getMaxPromotedSuggestions() {
        return mContext.getResources().getInteger(R.integer.max_promoted_suggestions);
    }

    public int getMaxPromotedResults() {
        return mContext.getResources().getInteger(R.integer.max_promoted_results);
    }

    /**
     * The number of results to ask each source for.
     */
    public int getMaxResultsPerSource() {
        return MAX_RESULTS_PER_SOURCE;
    }

    /**
     * The maximum number of shortcuts to show for the web source in All mode.
     */
    public int getMaxShortcutsPerWebSource() {
        return mContext.getResources().getInteger(R.integer.max_shortcuts_per_web_source);
    }

    /**
     * The maximum number of shortcuts to show for each non-web source in All mode.
     */
    public int getMaxShortcutsPerNonWebSource() {
        return mContext.getResources().getInteger(R.integer.max_shortcuts_per_non_web_source);
    }

    /**
     * Gets the maximum number of shortcuts that will be shown from the given source.
     */
    public int getMaxShortcuts(String sourceName) {
        return getMaxShortcutsPerNonWebSource();
    }

    /**
     * The timeout for querying each source, in milliseconds.
     */
    public long getSourceTimeoutMillis() {
        return SOURCE_TIMEOUT_MILLIS;
    }

    /**
     * The priority of query threads.
     *
     * @return A thread priority, as defined in {@link Process}.
     */
    public int getQueryThreadPriority() {
        return QUERY_THREAD_PRIORITY;
    }

    /**
     * The maximum age of log data used for shortcuts.
     */
    public long getMaxStatAgeMillis(){
        return MAX_STAT_AGE_MILLIS;
    }

    /**
     * The minimum number of clicks needed to rank a source.
     */
    public int getMinClicksForSourceRanking(){
        return MIN_CLICKS_FOR_SOURCE_RANKING;
    }

    public int getNumWebCorpusThreads() {
        return NUM_WEB_CORPUS_THREADS;
    }

    /**
     * How often query latency should be logged.
     *
     * @return An integer in the range 0-1000. 0 means that no latency events
     *         should be logged. 1000 means that all latency events should be logged.
     */
    public int getLatencyLogFrequency() {
        return LATENCY_LOG_FREQUENCY;
    }

    /**
     * The delay in milliseconds before suggestions are updated while typing.
     * If a new character is typed before this timeout expires, the timeout is reset.
     */
    public long getTypingUpdateSuggestionsDelayMillis() {
        return TYPING_SUGGESTIONS_UPDATE_DELAY_MILLIS;
    }

    public boolean allowVoiceSearchHints() {
        return true;
    }

    /**
     * The period of time for which after installing voice search we should consider showing voice
     * search hints.
     *
     * @return The period in milliseconds.
     */
    public long getVoiceSearchHintActivePeriod() {
        return VOICE_SEARCH_HINT_ACTIVE_PERIOD;
    }

    /**
     * The time interval at which we should consider whether or not to show some voice search hints.
     *
     * @return The period in milliseconds.
     */
    public long getVoiceSearchHintUpdatePeriod() {
        return VOICE_SEARCH_HINT_UPDATE_INTERVAL;
    }

    /**
     * The time interval at which, on average, voice search hints are displayed.
     *
     * @return The period in milliseconds.
     */
    public long getVoiceSearchHintShowPeriod() {
        return VOICE_SEARCH_HINT_SHOW_PERIOD_MILLIS;
    }

    /**
     * The amount of time for which voice search hints are displayed in one go.
     *
     * @return The period in milliseconds.
     */
    public long getVoiceSearchHintVisibleTime() {
        return VOICE_SEARCH_HINT_VISIBLE_PERIOD;
    }

    /**
     * The period that we change voice search hints at while they're being displayed.
     *
     * @return The period in milliseconds.
     */
    public long getVoiceSearchHintChangePeriod() {
        return VOICE_SEARCH_HINT_CHANGE_PERIOD;
    }

    public boolean showSuggestionsForZeroQuery() {
        // Get the list of default corpora from a resource, which allows vendor overlays.
        return mContext.getResources().getBoolean(R.bool.show_zero_query_suggestions);
    }

    public boolean showShortcutsForZeroQuery() {
        // Get the list of default corpora from a resource, which allows vendor overlays.
        return mContext.getResources().getBoolean(R.bool.show_zero_query_shortcuts);
    }

    public boolean showScrollingSuggestions() {
        return mContext.getResources().getBoolean(R.bool.show_scrolling_suggestions);
    }

    public boolean showScrollingResults() {
        return mContext.getResources().getBoolean(R.bool.show_scrolling_results);
    }

    public Uri getHelpUrl(String activity) {
        return null;
    }

    public int getHttpConnectTimeout() {
        return HTTP_CONNECT_TIMEOUT_MILLIS;
    }

    public int getHttpReadTimeout() {
        return HTTP_READ_TIMEOUT_MILLIS;
    }

    public String getUserAgent() {
        return USER_AGENT;
    }
}
",False,22,5,10,0,0,10,0,L3
15,com.android.quicksearchbox.CachingIconLoader.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.CachedLater;
import com.android.quicksearchbox.util.Consumer;
import com.android.quicksearchbox.util.Now;
import com.android.quicksearchbox.util.NowOrLater;
import com.android.quicksearchbox.util.NowOrLaterWrapper;

import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.text.TextUtils;
import android.util.Log;

import java.util.WeakHashMap;

/**
 * Icon loader that caches the results of another icon loader.
 *
 */
public class CachingIconLoader implements IconLoader {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.CachingIconLoader"";

    private final IconLoader mWrapped;

    private final WeakHashMap<String, Entry> mIconCache;

    /**
     * Creates a new caching icon loader.
     *
     * @param wrapped IconLoader whose results will be cached.
     */
    public CachingIconLoader(IconLoader wrapped) {
        mWrapped = wrapped;
        mIconCache = new WeakHashMap<String, Entry>();
    }

    public NowOrLater<Drawable> getIcon(String drawableId) {
        if (DBG) Log.d(TAG, ""getIcon("" + drawableId + "")"");
        if (TextUtils.isEmpty(drawableId) || ""0"".equals(drawableId)) {
            return new Now<Drawable>(null);
        }
        Entry newEntry = null;
        NowOrLater<Drawable.ConstantState> drawableState;
        synchronized (this) {
            drawableState = queryCache(drawableId);
            if (drawableState == null) {
                newEntry = new Entry();
                storeInIconCache(drawableId, newEntry);
            }
        }
        if (drawableState != null) {
            return new NowOrLaterWrapper<Drawable.ConstantState, Drawable>(drawableState){
                @Override
                public Drawable get(Drawable.ConstantState value) {
                    return value == null ? null : value.newDrawable();
                }};
        }
        NowOrLater<Drawable> drawable = mWrapped.getIcon(drawableId);
        newEntry.set(drawable);
        storeInIconCache(drawableId, newEntry);
        return drawable;
    }

    public Uri getIconUri(String drawableId) {
        return mWrapped.getIconUri(drawableId);
    }

    private synchronized NowOrLater<Drawable.ConstantState> queryCache(String drawableId) {
        NowOrLater<Drawable.ConstantState> cached = mIconCache.get(drawableId);
        if (DBG) {
            if (cached != null) Log.d(TAG, ""Found icon in cache: "" + drawableId);
        }
        return cached;
    }

    private synchronized void storeInIconCache(String resourceUri, Entry drawable) {
        if (drawable != null) {
            mIconCache.put(resourceUri, drawable);
        }
    }

    private static class Entry extends CachedLater<Drawable.ConstantState>
            implements Consumer<Drawable>{
        private NowOrLater<Drawable> mDrawable;
        private boolean mGotDrawable;
        private boolean mCreateRequested;

        public Entry() {
        }

        public synchronized void set(NowOrLater<Drawable> drawable) {
            if (mGotDrawable) throw new IllegalStateException(""set() may only be called once."");
            mGotDrawable = true;
            mDrawable = drawable;
            if (mCreateRequested) {
                getLater();
            }
        }

        @Override
        protected synchronized void create() {
            if (!mCreateRequested) {
                mCreateRequested = true;
                if (mGotDrawable) {
                    getLater();
                }
            }
        }

        private void getLater() {
            NowOrLater<Drawable> drawable = mDrawable;
            mDrawable = null;
            drawable.getLater(this);
        }

        public boolean consume(Drawable value) {
            store(value == null ? null : value.getConstantState());
            return true;
        }
    }

}
",False,18,6,5,1,1,2,1,L1
16,com.android.quicksearchbox.SuggestionData.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.google.common.annotations.VisibleForTesting;

import android.content.ComponentName;
import android.content.Intent;


/**
 * Holds data for each suggest item including the display data and how to launch the result.
 * Used for passing from the provider to the suggest cursor.
 */
public class SuggestionData implements Suggestion {

    private final Source mSource;
    private String mFormat;
    private String mText1;
    private String mText2;
    private String mText2Url;
    private String mIcon1;
    private String mIcon2;
    private String mShortcutId;
    private boolean mSpinnerWhileRefreshing;
    private String mIntentAction;
    private String mIntentData;
    private String mIntentExtraData;
    private String mSuggestionQuery;
    private String mLogType;
    private boolean mIsShortcut;
    private boolean mIsHistory;
    private SuggestionExtras mExtras;

    public SuggestionData(Source source) {
        mSource = source;
    }

    public Source getSuggestionSource() {
        return mSource;
    }

    public String getSuggestionFormat() {
        return mFormat;
    }

    public String getSuggestionText1() {
        return mText1;
    }

    public String getSuggestionText2() {
        return mText2;
    }

    public String getSuggestionText2Url() {
        return mText2Url;
    }

    public String getSuggestionIcon1() {
        return mIcon1;
    }

    public String getSuggestionIcon2() {
        return mIcon2;
    }

    public boolean isSpinnerWhileRefreshing() {
        return mSpinnerWhileRefreshing;
    }

    public String getIntentExtraData() {
        return mIntentExtraData;
    }

    public String getShortcutId() {
        return mShortcutId;
    }

    public String getSuggestionIntentAction() {
        if (mIntentAction != null) return mIntentAction;
        return mSource.getDefaultIntentAction();
    }

    public ComponentName getSuggestionIntentComponent() {
        return mSource.getIntentComponent();
    }

    public String getSuggestionIntentDataString() {
        return mIntentData;
    }

    public String getSuggestionIntentExtraData() {
        return mIntentExtraData;
    }

    public String getSuggestionQuery() {
        return mSuggestionQuery;
    }

    public String getSuggestionLogType() {
        return mLogType;
    }

    public boolean isSuggestionShortcut() {
        return mIsShortcut;
    }

    public boolean isWebSearchSuggestion() {
        return Intent.ACTION_WEB_SEARCH.equals(getSuggestionIntentAction());
    }

    public boolean isHistorySuggestion() {
        return mIsHistory;
    }

    @VisibleForTesting
    public SuggestionData setFormat(String format) {
        mFormat = format;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setText1(String text1) {
        mText1 = text1;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setText2(String text2) {
        mText2 = text2;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setText2Url(String text2Url) {
        mText2Url = text2Url;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIcon1(String icon1) {
        mIcon1 = icon1;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIcon2(String icon2) {
        mIcon2 = icon2;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIntentAction(String intentAction) {
        mIntentAction = intentAction;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIntentData(String intentData) {
        mIntentData = intentData;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIntentExtraData(String intentExtraData) {
        mIntentExtraData = intentExtraData;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setSuggestionQuery(String suggestionQuery) {
        mSuggestionQuery = suggestionQuery;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setShortcutId(String shortcutId) {
        mShortcutId = shortcutId;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setSpinnerWhileRefreshing(boolean spinnerWhileRefreshing) {
        mSpinnerWhileRefreshing = spinnerWhileRefreshing;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setSuggestionLogType(String logType) {
        mLogType = logType;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIsShortcut(boolean isShortcut) {
        mIsShortcut = isShortcut;
        return this;
    }

    @VisibleForTesting
    public SuggestionData setIsHistory(boolean isHistory) {
        mIsHistory = isHistory;
        return this;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((mFormat == null) ? 0 : mFormat.hashCode());
        result = prime * result + ((mIcon1 == null) ? 0 : mIcon1.hashCode());
        result = prime * result + ((mIcon2 == null) ? 0 : mIcon2.hashCode());
        result = prime * result + ((mIntentAction == null) ? 0 : mIntentAction.hashCode());
        result = prime * result + ((mIntentData == null) ? 0 : mIntentData.hashCode());
        result = prime * result + ((mIntentExtraData == null) ? 0 : mIntentExtraData.hashCode());
        result = prime * result + ((mLogType == null) ? 0 : mLogType.hashCode());
        result = prime * result + ((mShortcutId == null) ? 0 : mShortcutId.hashCode());
        result = prime * result + ((mSource == null) ? 0 : mSource.hashCode());
        result = prime * result + (mSpinnerWhileRefreshing ? 1231 : 1237);
        result = prime * result + ((mSuggestionQuery == null) ? 0 : mSuggestionQuery.hashCode());
        result = prime * result + ((mText1 == null) ? 0 : mText1.hashCode());
        result = prime * result + ((mText2 == null) ? 0 : mText2.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        SuggestionData other = (SuggestionData)obj;
        if (mFormat == null) {
            if (other.mFormat != null)
                return false;
        } else if (!mFormat.equals(other.mFormat))
            return false;
        if (mIcon1 == null) {
            if (other.mIcon1 != null)
                return false;
        } else if (!mIcon1.equals(other.mIcon1))
            return false;
        if (mIcon2 == null) {
            if (other.mIcon2 != null)
                return false;
        } else if (!mIcon2.equals(other.mIcon2))
            return false;
        if (mIntentAction == null) {
            if (other.mIntentAction != null)
                return false;
        } else if (!mIntentAction.equals(other.mIntentAction))
            return false;
        if (mIntentData == null) {
            if (other.mIntentData != null)
                return false;
        } else if (!mIntentData.equals(other.mIntentData))
            return false;
        if (mIntentExtraData == null) {
            if (other.mIntentExtraData != null)
                return false;
        } else if (!mIntentExtraData.equals(other.mIntentExtraData))
            return false;
        if (mLogType == null) {
            if (other.mLogType != null)
                return false;
        } else if (!mLogType.equals(other.mLogType))
            return false;
        if (mShortcutId == null) {
            if (other.mShortcutId != null)
                return false;
        } else if (!mShortcutId.equals(other.mShortcutId))
            return false;
        if (mSource == null) {
            if (other.mSource != null)
                return false;
        } else if (!mSource.equals(other.mSource))
            return false;
        if (mSpinnerWhileRefreshing != other.mSpinnerWhileRefreshing)
            return false;
        if (mSuggestionQuery == null) {
            if (other.mSuggestionQuery != null)
                return false;
        } else if (!mSuggestionQuery.equals(other.mSuggestionQuery))
            return false;
        if (mText1 == null) {
            if (other.mText1 != null)
                return false;
        } else if (!mText1.equals(other.mText1))
            return false;
        if (mText2 == null) {
            if (other.mText2 != null)
                return false;
        } else if (!mText2.equals(other.mText2))
            return false;
        return true;
    }

    /**
     * Returns a string representation of the contents of this SuggestionData,
     * for debugging purposes.
     */
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder(""SuggestionData("");
        appendField(builder, ""source"", mSource.getName());
        appendField(builder, ""text1"", mText1);
        appendField(builder, ""intentAction"", mIntentAction);
        appendField(builder, ""intentData"", mIntentData);
        appendField(builder, ""query"", mSuggestionQuery);
        appendField(builder, ""shortcutid"", mShortcutId);
        appendField(builder, ""logtype"", mLogType);
        return builder.toString();
    }

    private void appendField(StringBuilder builder, String name, String value) {
        if (value != null) {
            builder.append("","").append(name).append(""="").append(value);
        }
    }

    @VisibleForTesting
    public void setExtras(SuggestionExtras extras) {
        mExtras = extras;
    }

    public SuggestionExtras getExtras() {
        return mExtras;
    }

}
",True,63,4,36,2,2,11,2,L1
17,com.android.quicksearchbox.Source.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.NowOrLater;

import android.content.ComponentName;
import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;

/**
 * Interface for suggestion sources.
 *
 */
public interface Source extends SuggestionCursorProvider<SourceResult> {

    /**
     * Gets the name activity that intents from this source are sent to.
     */
    ComponentName getIntentComponent();

    /**
     * Gets the suggestion URI for getting suggestions from this Source.
     */
    String getSuggestUri();

    /**
     * Gets the localized, human-readable label for this source.
     */
    CharSequence getLabel();

    /**
     * Gets the icon for this suggestion source.
     */
    Drawable getSourceIcon();

    /**
     * Gets the icon URI for this suggestion source.
     */
    Uri getSourceIconUri();

    /**
     * Gets an icon from this suggestion source.
     *
     * @param drawableId Resource ID or URI.
     */
    NowOrLater<Drawable> getIcon(String drawableId);

    /**
     * Gets the URI for an icon form this suggestion source.
     *
     * @param drawableId Resource ID or URI.
     */
    Uri getIconUri(String drawableId);

    /**
     * Gets the search hint text for this suggestion source.
     */
    CharSequence getHint();

    /**
     * Gets the description to use for this source in system search settings.
     */
    CharSequence getSettingsDescription();

    /**
     *
     *  Note: this does not guarantee that this source will be queried for queries of
     *  this length or longer, only that it will not be queried for anything shorter.
     *
     * @return The minimum number of characters needed to trigger this source.
     */
    int getQueryThreshold();

    /**
     * Indicates whether a source should be invoked for supersets of queries it has returned zero
     * results for in the past.  For example, if a source returned zero results for ""bo"", it would
     * be ignored for ""bob"".
     *
     * If set to <code>false</code>, this source will only be ignored for a single session; the next
     * time the search dialog is brought up, all sources will be queried.
     *
     * @return <code>true</code> if this source should be queried after returning no results.
     */
    boolean queryAfterZeroResults();

    boolean voiceSearchEnabled();

    /**
     * Whether this source should be included in the blended All mode. The source must
     * also be enabled to be included in All.
     */
    boolean includeInAll();

    Intent createSearchIntent(String query, Bundle appData);

    Intent createVoiceSearchIntent(Bundle appData);

    /**
     * Checks if the current process can read the suggestions from this source.
     */
    boolean canRead();

    /**
     * Gets suggestions from this source.
     *
     * @param query The user query.
     * @return The suggestion results.
     */
    @Override
    SourceResult getSuggestions(String query, int queryLimit);

    /**
     * Gets the default intent action for suggestions from this source.
     *
     * @return The default intent action, or {@code null}.
     */
    String getDefaultIntentAction();

    /**
     * Gets the default intent data for suggestions from this source.
     *
     * @return The default intent data, or {@code null}.
     */
    String getDefaultIntentData();

    /**
     * Gets the root source, if this source is a wrapper around another. Otherwise, returns this
     * source.
     */
    Source getRoot();

}
",False,78,4,32,1,3,34,3,L0
18,com.android.quicksearchbox.IconLoader.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.android.quicksearchbox.util.NowOrLater;

import android.content.ContentResolver;
import android.graphics.drawable.Drawable;
import android.net.Uri;

/**
 * Interface for icon loaders.
 *
 */
public interface IconLoader {

    /**
     * Gets a drawable given an ID.
     *
     * The ID could be just the string value of a resource id
     * (e.g., ""2130837524""), in which case we will try to retrieve a drawable from
     * the provider's resources. If the ID is not an integer, it is
     * treated as a Uri and opened with
     * {@link ContentResolver#openOutputStream(android.net.Uri, String)}.
     *
     * All resources and URIs are read using the suggestion provider's context.
     *
     * @return a {@link NowOrLater} for retrieving the icon. If the ID is not formatted as expected,
     *      or no drawable can be found for the provided value, the value from this will be null.
     *
     * @param drawableId a string like ""2130837524"",
     *        ""android.resource://com.android.alarmclock/2130837524"",
     *        or ""content://contacts/photos/253"".
     */
    NowOrLater<Drawable> getIcon(String drawableId);

    /**
     * Converts a drawable ID to a Uri that can be used from other packages.
     */
    Uri getIconUri(String drawableId);

}
",False,22,6,7,0,0,7,0,L0
19,com.android.quicksearchbox.ListSuggestionCursor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import com.google.common.annotations.VisibleForTesting;

import android.database.DataSetObservable;
import android.database.DataSetObserver;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;

/**
 * A SuggestionCursor that is backed by a list of Suggestions.
 */
public class ListSuggestionCursor extends AbstractSuggestionCursorWrapper {

    private static final int DEFAULT_CAPACITY = 16;

    private final DataSetObservable mDataSetObservable = new DataSetObservable();

    private final ArrayList<Entry> mSuggestions;

    private HashSet<String> mExtraColumns;

    private int mPos = 0;

    public ListSuggestionCursor(String userQuery) {
        this(userQuery, DEFAULT_CAPACITY);
    }

    @VisibleForTesting
    public ListSuggestionCursor(String userQuery, Suggestion...suggestions) {
        this(userQuery, suggestions.length);
        for (Suggestion suggestion : suggestions) {
            add(suggestion);
        }
    }

    public ListSuggestionCursor(String userQuery, int capacity) {
        super(userQuery);
        mSuggestions = new ArrayList<Entry>(capacity);
    }

    /**
     * Adds a suggestion from another suggestion cursor.
     *
     * @return {@code true} if the suggestion was added.
     */
    public boolean add(Suggestion suggestion) {
        mSuggestions.add(new Entry(suggestion));
        return true;
    }

    public void close() {
        mSuggestions.clear();
    }

    public int getPosition() {
        return mPos;
    }

    public void moveTo(int pos) {
        mPos = pos;
    }

    public boolean moveToNext() {
        int size = mSuggestions.size();
        if (mPos >= size) {
            // Already past the end
            return false;
        }
        mPos++;
        return mPos < size;
    }

    public void removeRow() {
        mSuggestions.remove(mPos);
    }

    public void replaceRow(Suggestion suggestion) {
        mSuggestions.set(mPos, new Entry(suggestion));
    }

    public int getCount() {
        return mSuggestions.size();
    }

    @Override
    protected Suggestion current() {
        return mSuggestions.get(mPos).get();
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + ""{["" + getUserQuery() + ""] "" + mSuggestions + ""}"";
    }

    /**
     * Register an observer that is called when changes happen to this data set.
     *
     * @param observer gets notified when the data set changes.
     */
    public void registerDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.registerObserver(observer);
    }

    /**
     * Unregister an observer that has previously been registered with 
     * {@link #registerDataSetObserver(DataSetObserver)}
     *
     * @param observer the observer to unregister.
     */
    public void unregisterDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.unregisterObserver(observer);
    }

    protected void notifyDataSetChanged() {
        mDataSetObservable.notifyChanged();
    }

    @Override
    public SuggestionExtras getExtras() {
        // override with caching to avoid re-parsing the extras
        return mSuggestions.get(mPos).getExtras();
    }

   public Collection<String> getExtraColumns() {
        if (mExtraColumns == null) {
            mExtraColumns = new HashSet<String>();
            for (Entry e : mSuggestions) {
                SuggestionExtras extras = e.getExtras();
                Collection<String> extraColumns = extras == null ? null
                        : extras.getExtraColumnNames();
                if (extraColumns != null) {
                    for (String column : extras.getExtraColumnNames()) {
                        mExtraColumns.add(column);
                    }
                }
            }
        }
        return mExtraColumns.isEmpty() ? null : mExtraColumns;
    }

    /**
     * This class exists purely to cache the suggestion extras.
     */
    private static class Entry {
        private final Suggestion mSuggestion;
        private SuggestionExtras mExtras;
        public Entry(Suggestion s) {
            mSuggestion = s;
        }
        public Suggestion get() {
            return mSuggestion;
        }
        public SuggestionExtras getExtras() {
            if (mExtras == null) {
                mExtras = mSuggestion.getExtras();
            }
            return mExtras;
        }
    }

}
",True,46,5,14,3,4,14,4,L2
20,com.android.quicksearchbox.LatencyTracker.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.os.SystemClock;

/**
 * Tracks latency in wall-clock time. Since {@link #getLatency} returns an {@code int},
 * latencies over 2^31 ms (~ 25 days) cannot be measured.
 * This class uses {@link SystemClock#uptimeMillis} which does not advance during deep sleep.
 */
public class LatencyTracker {

    /**
     * Start time, in milliseconds as returned by {@link SystemClock#uptimeMillis}.
     */
    private long mStartTime;

    /**
     * Creates a new latency tracker and sets the start time.
     */
    public LatencyTracker() {
        mStartTime = SystemClock.uptimeMillis();
    }

    /**
     * Resets the start time.
     */
    public void reset() {
        mStartTime = SystemClock.uptimeMillis();
    }

    /**
     * Gets the number of milliseconds since the object was created, or {@link #reset} was called.
     */
    public int getLatency() {
        long now = SystemClock.uptimeMillis();
        return (int) (now - mStartTime);
    }

}
",False,19,6,7,0,0,3,0,L4
21,com.android.quicksearchbox.SearchActivity.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.app.Activity;
import android.app.SearchManager;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Debug;
import android.os.Handler;
import android.text.TextUtils;
import android.util.Log;
import android.view.Menu;
import android.view.View;

import com.android.common.Search;
import com.android.quicksearchbox.ui.SearchActivityView;
import com.android.quicksearchbox.ui.SuggestionClickListener;
import com.android.quicksearchbox.ui.SuggestionsAdapter;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.CharMatcher;

import java.io.File;

/**
 * The main activity for Quick Search Box. Shows the search UI.
 *
 */
public class SearchActivity extends Activity {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SearchActivity"";

    private static final String SCHEME_CORPUS = ""qsb.corpus"";

    private static final String INTENT_EXTRA_TRACE_START_UP = ""trace_start_up"";

    // Keys for the saved instance state.
    private static final String INSTANCE_KEY_QUERY = ""query"";

    private static final String ACTIVITY_HELP_CONTEXT = ""search"";

    private boolean mTraceStartUp;
    // Measures time from for last onCreate()/onNewIntent() call.
    private LatencyTracker mStartLatencyTracker;
    // Measures time spent inside onCreate()
    private LatencyTracker mOnCreateTracker;
    private int mOnCreateLatency;
    // Whether QSB is starting. True between the calls to onCreate()/onNewIntent() and onResume().
    private boolean mStarting;
    // True if the user has taken some action, e.g. launching a search, voice search,
    // or suggestions, since QSB was last started.
    private boolean mTookAction;

    private SearchActivityView mSearchActivityView;

    private Source mSource;

    private Bundle mAppSearchData;

    private final Handler mHandler = new Handler();
    private final Runnable mUpdateSuggestionsTask = new Runnable() {
        @Override
        public void run() {
            updateSuggestions();
        }
    };

    private final Runnable mShowInputMethodTask = new Runnable() {
        @Override
        public void run() {
            mSearchActivityView.showInputMethodForQuery();
        }
    };

    private OnDestroyListener mDestroyListener;

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        mTraceStartUp = getIntent().hasExtra(INTENT_EXTRA_TRACE_START_UP);
        if (mTraceStartUp) {
            String traceFile = new File(getDir(""traces"", 0), ""qsb-start.trace"").getAbsolutePath();
            Log.i(TAG, ""Writing start-up trace to "" + traceFile);
            Debug.startMethodTracing(traceFile);
        }
        recordStartTime();
        if (DBG) Log.d(TAG, ""onCreate()"");
        super.onCreate(savedInstanceState);

        // This forces the HTTP request to check the users domain to be
        // sent as early as possible.
        QsbApplication.get(this).getSearchBaseUrlHelper();

        mSource = QsbApplication.get(this).getGoogleSource();

        mSearchActivityView = setupContentView();

        if (getConfig().showScrollingResults()) {
            mSearchActivityView.setMaxPromotedResults(getConfig().getMaxPromotedResults());
        } else {
            mSearchActivityView.limitResultsToViewHeight();
        }

        mSearchActivityView.setSearchClickListener(new SearchActivityView.SearchClickListener() {
            @Override
            public boolean onSearchClicked(int method) {
                return SearchActivity.this.onSearchClicked(method);
            }
        });

        mSearchActivityView.setQueryListener(new SearchActivityView.QueryListener() {
            @Override
            public void onQueryChanged() {
                updateSuggestionsBuffered();
            }
        });

        mSearchActivityView.setSuggestionClickListener(new ClickHandler());

        mSearchActivityView.setVoiceSearchButtonClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                onVoiceSearchClicked();
            }
        });

        View.OnClickListener finishOnClick = new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        };
        mSearchActivityView.setExitClickListener(finishOnClick);

        // First get setup from intent
        Intent intent = getIntent();
        setupFromIntent(intent);
        // Then restore any saved instance state
        restoreInstanceState(savedInstanceState);

        // Do this at the end, to avoid updating the list view when setSource()
        // is called.
        mSearchActivityView.start();

        recordOnCreateDone();
    }

    protected SearchActivityView setupContentView() {
        setContentView(R.layout.search_activity);
        return (SearchActivityView) findViewById(R.id.search_activity_view);
    }

    protected SearchActivityView getSearchActivityView() {
        return mSearchActivityView;
    }

    @Override
    protected void onNewIntent(Intent intent) {
        if (DBG) Log.d(TAG, ""onNewIntent()"");
        recordStartTime();
        setIntent(intent);
        setupFromIntent(intent);
    }

    private void recordStartTime() {
        mStartLatencyTracker = new LatencyTracker();
        mOnCreateTracker = new LatencyTracker();
        mStarting = true;
        mTookAction = false;
    }

    private void recordOnCreateDone() {
        mOnCreateLatency = mOnCreateTracker.getLatency();
    }

    protected void restoreInstanceState(Bundle savedInstanceState) {
        if (savedInstanceState == null) return;
        String query = savedInstanceState.getString(INSTANCE_KEY_QUERY);
        setQuery(query, false);
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        // We don't save appSearchData, since we always get the value
        // from the intent and the user can't change it.

        outState.putString(INSTANCE_KEY_QUERY, getQuery());
    }

    private void setupFromIntent(Intent intent) {
        if (DBG) Log.d(TAG, ""setupFromIntent("" + intent.toUri(0) + "")"");
        String corpusName = getCorpusNameFromUri(intent.getData());
        String query = intent.getStringExtra(SearchManager.QUERY);
        Bundle appSearchData = intent.getBundleExtra(SearchManager.APP_DATA);
        boolean selectAll = intent.getBooleanExtra(SearchManager.EXTRA_SELECT_QUERY, false);

        setQuery(query, selectAll);
        mAppSearchData = appSearchData;

    }

    private String getCorpusNameFromUri(Uri uri) {
        if (uri == null) return null;
        if (!SCHEME_CORPUS.equals(uri.getScheme())) return null;
        return uri.getAuthority();
    }

    private QsbApplication getQsbApplication() {
        return QsbApplication.get(this);
    }

    private Config getConfig() {
        return getQsbApplication().getConfig();
    }

    protected SearchSettings getSettings() {
        return getQsbApplication().getSettings();
    }

    private SuggestionsProvider getSuggestionsProvider() {
        return getQsbApplication().getSuggestionsProvider();
    }

    private Logger getLogger() {
        return getQsbApplication().getLogger();
    }

    @VisibleForTesting
    public void setOnDestroyListener(OnDestroyListener l) {
        mDestroyListener = l;
    }

    @Override
    protected void onDestroy() {
        if (DBG) Log.d(TAG, ""onDestroy()"");
        mSearchActivityView.destroy();
        super.onDestroy();
        if (mDestroyListener != null) {
            mDestroyListener.onDestroyed();
        }
    }

    @Override
    protected void onStop() {
        if (DBG) Log.d(TAG, ""onStop()"");
        if (!mTookAction) {
            // TODO: This gets logged when starting other activities, e.g. by opening the search
            // settings, or clicking a notification in the status bar.
            // TODO we should log both sets of suggestions in 2-pane mode
            getLogger().logExit(getCurrentSuggestions(), getQuery().length());
        }
        // Close all open suggestion cursors. The query will be redone in onResume()
        // if we come back to this activity.
        mSearchActivityView.clearSuggestions();
        mSearchActivityView.onStop();
        super.onStop();
    }

    @Override
    protected void onPause() {
        if (DBG) Log.d(TAG, ""onPause()"");
        mSearchActivityView.onPause();
        super.onPause();
    }

    @Override
    protected void onRestart() {
        if (DBG) Log.d(TAG, ""onRestart()"");
        super.onRestart();
    }

    @Override
    protected void onResume() {
        if (DBG) Log.d(TAG, ""onResume()"");
        super.onResume();
        updateSuggestionsBuffered();
        mSearchActivityView.onResume();
        if (mTraceStartUp) Debug.stopMethodTracing();
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        // Since the menu items are dynamic, we recreate the menu every time.
        menu.clear();
        createMenuItems(menu, true);
        return true;
    }

    public void createMenuItems(Menu menu, boolean showDisabled) {
        getQsbApplication().getHelp().addHelpMenuItem(menu, ACTIVITY_HELP_CONTEXT);
    }

    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        if (hasFocus) {
            // Launch the IME after a bit
            mHandler.postDelayed(mShowInputMethodTask, 0);
        }
    }

    protected String getQuery() {
        return mSearchActivityView.getQuery();
    }

    protected void setQuery(String query, boolean selectAll) {
        mSearchActivityView.setQuery(query, selectAll);
    }

    /**
     * @return true if a search was performed as a result of this click, false otherwise.
     */
    protected boolean onSearchClicked(int method) {
        String query = CharMatcher.whitespace().trimAndCollapseFrom(getQuery(), ' ');
        if (DBG) Log.d(TAG, ""Search clicked, query="" + query);

        // Don't do empty queries
        if (TextUtils.getTrimmedLength(query) == 0) return false;

        mTookAction = true;

        // Log search start
        getLogger().logSearch(method, query.length());

        // Start search
        startSearch(mSource, query);
        return true;
    }

    protected void startSearch(Source searchSource, String query) {
        Intent intent = searchSource.createSearchIntent(query, mAppSearchData);
        launchIntent(intent);
    }

    protected void onVoiceSearchClicked() {
        if (DBG) Log.d(TAG, ""Voice Search clicked"");

        mTookAction = true;

        // Log voice search start
        getLogger().logVoiceSearch();

        // Start voice search
        Intent intent = mSource.createVoiceSearchIntent(mAppSearchData);
        launchIntent(intent);
    }

    protected Source getSearchSource() {
        return mSource;
    }

    protected SuggestionCursor getCurrentSuggestions() {
        Suggestions suggestions = mSearchActivityView.getSuggestions();
        if (suggestions == null) {
            return null;
        }
        return suggestions.getResult();
    }

    protected SuggestionPosition getCurrentSuggestions(SuggestionsAdapter<?> adapter, long id) {
        SuggestionPosition pos = adapter.getSuggestion(id);
        if (pos == null) {
            return null;
        }
        SuggestionCursor suggestions = pos.getCursor();
        int position = pos.getPosition();
        if (suggestions == null) {
            return null;
        }
        int count = suggestions.getCount();
        if (position < 0 || position >= count) {
            Log.w(TAG, ""Invalid suggestion position "" + position + "", count = "" + count);
            return null;
        }
        suggestions.moveTo(position);
        return pos;
    }

    protected void launchIntent(Intent intent) {
        if (DBG) Log.d(TAG, ""launchIntent "" + intent);
        if (intent == null) {
            return;
        }
        try {
            startActivity(intent);
        } catch (RuntimeException ex) {
            // Since the intents for suggestions specified by suggestion providers,
            // guard against them not being handled, not allowed, etc.
            Log.e(TAG, ""Failed to start "" + intent.toUri(0), ex);
        }
    }

    private boolean launchSuggestion(SuggestionsAdapter<?> adapter, long id) {
        SuggestionPosition suggestion = getCurrentSuggestions(adapter, id);
        if (suggestion == null) return false;

        if (DBG) Log.d(TAG, ""Launching suggestion "" + id);
        mTookAction = true;

        // Log suggestion click
        getLogger().logSuggestionClick(id, suggestion.getCursor(),
                Logger.SUGGESTION_CLICK_TYPE_LAUNCH);

        // Launch intent
        launchSuggestion(suggestion.getCursor(), suggestion.getPosition());

        return true;
    }

    protected void launchSuggestion(SuggestionCursor suggestions, int position) {
        suggestions.moveTo(position);
        Intent intent = SuggestionUtils.getSuggestionIntent(suggestions, mAppSearchData);
        launchIntent(intent);
    }

    protected void refineSuggestion(SuggestionsAdapter<?> adapter, long id) {
        if (DBG) Log.d(TAG, ""query refine clicked, pos "" + id);
        SuggestionPosition suggestion = getCurrentSuggestions(adapter, id);
        if (suggestion == null) {
            return;
        }
        String query = suggestion.getSuggestionQuery();
        if (TextUtils.isEmpty(query)) {
            return;
        }

        // Log refine click
        getLogger().logSuggestionClick(id, suggestion.getCursor(),
                Logger.SUGGESTION_CLICK_TYPE_REFINE);

        // Put query + space in query text view
        String queryWithSpace = query + ' ';
        setQuery(queryWithSpace, false);
        updateSuggestions();
        mSearchActivityView.focusQueryTextView();
    }

    private void updateSuggestionsBuffered() {
        if (DBG) Log.d(TAG, ""updateSuggestionsBuffered()"");
        mHandler.removeCallbacks(mUpdateSuggestionsTask);
        long delay = getConfig().getTypingUpdateSuggestionsDelayMillis();
        mHandler.postDelayed(mUpdateSuggestionsTask, delay);
    }

    private void gotSuggestions(Suggestions suggestions) {
        if (mStarting) {
            mStarting = false;
            String source = getIntent().getStringExtra(Search.SOURCE);
            int latency = mStartLatencyTracker.getLatency();
            getLogger().logStart(mOnCreateLatency, latency, source);
            getQsbApplication().onStartupComplete();
        }
    }

    public void updateSuggestions() {
        if (DBG) Log.d(TAG, ""updateSuggestions()"");
        final String query = CharMatcher.whitespace().trimLeadingFrom(getQuery());
        updateSuggestions(query, mSource);
    }

    protected void updateSuggestions(String query, Source source) {
        if (DBG) Log.d(TAG, ""updateSuggestions(\"""" + query+""\"","" + source + "")"");
        Suggestions suggestions = getSuggestionsProvider().getSuggestions(
                query, source);

        // Log start latency if this is the first suggestions update
        gotSuggestions(suggestions);

        showSuggestions(suggestions);
    }

    protected void showSuggestions(Suggestions suggestions) {
        mSearchActivityView.setSuggestions(suggestions);
    }

    private class ClickHandler implements SuggestionClickListener {

        @Override
        public void onSuggestionClicked(SuggestionsAdapter<?> adapter, long id) {
            launchSuggestion(adapter, id);
        }

        @Override
        public void onSuggestionQueryRefineClicked(SuggestionsAdapter<?> adapter, long id) {
            refineSuggestion(adapter, id);
        }
    }

    public interface OnDestroyListener {
        void onDestroyed();
    }

}
",True,84,2,2,5,32,3,24,L6
22,com.android.quicksearchbox.SuggestionCursorWrapper.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.database.DataSetObserver;

import java.util.Collection;

/**
 * A suggestion cursor that delegates all methods to another SuggestionCursor.
 */
public class SuggestionCursorWrapper extends AbstractSuggestionCursorWrapper {

    private final SuggestionCursor mCursor;

    public SuggestionCursorWrapper(String userQuery, SuggestionCursor cursor) {
        super(userQuery);
        mCursor = cursor;
    }

    public void close() {
        if (mCursor != null) {
            mCursor.close();
        }
    }

    public int getCount() {
        return mCursor == null ? 0 : mCursor.getCount();
    }

    public int getPosition() {
        return mCursor == null ? 0 : mCursor.getPosition();
    }

    public void moveTo(int pos) {
        if (mCursor != null) {
            mCursor.moveTo(pos);
        }
    }

    public boolean moveToNext() {
        if (mCursor != null) {
            return mCursor.moveToNext();
        } else {
            return false;
        }
    }

    public void registerDataSetObserver(DataSetObserver observer) {
        if (mCursor != null) {
            mCursor.registerDataSetObserver(observer);
        }
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
        if (mCursor != null) {
            mCursor.unregisterDataSetObserver(observer);
        }
    }

    @Override
    protected SuggestionCursor current() {
        return mCursor;
    }

    public Collection<String> getExtraColumns() {
        return mCursor.getExtraColumns();
    }

}
",False,35,8,11,3,2,3,2,L2
23,com.android.quicksearchbox.SourceResult.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

/**
 * The result of getting suggestions from a single source.
 */
public interface SourceResult extends SuggestionCursor {

    Source getSource();

}
",False,32,5,12,2,2,6,2,L0
24,com.android.quicksearchbox.SuggestionCursorProvider.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;


/**
 * Interface for objects that can produce a SuggestionCursor given a query.
 */
public interface SuggestionCursorProvider<C extends SuggestionCursor> {

    /**
     * Gets the name of the provider. This is used for logging and
     * to execute tasks on the queue for the provider.
     */
    String getName();

    /**
     * Gets suggestions from the provider.
     *
     * @param query The user query.
     * @param queryLimit An advisory maximum number of results that the source should return.
     * @return The suggestion results. Must not be {@code null}.
     */
    C getSuggestions(String query, int queryLimit);
}
",False,66,4,32,3,1,22,1,L0
25,com.android.quicksearchbox.Suggestions.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox;

import android.database.DataSetObservable;
import android.database.DataSetObserver;
import android.util.Log;

/**
 * Collects all corpus results for a single query.
 */
public class Suggestions {
    private static final boolean DBG = false;
    private static final String TAG = ""QSB.Suggestions"";

    /** True if {@link Suggestions#close} has been called. */
    private boolean mClosed = false;
    protected final String mQuery;

    /**
     * The observers that want notifications of changes to the published suggestions.
     * This object may be accessed on any thread.
     */
    private final DataSetObservable mDataSetObservable = new DataSetObservable();

    private Source mSource;

    private SourceResult mResult;

    private int mRefCount = 0;

    private boolean mDone = false;

    public Suggestions(String query, Source source) {
        mQuery = query;
        mSource = source;
    }

    public void acquire() {
        mRefCount++;
    }

    public void release() {
        mRefCount--;
        if (mRefCount <= 0) {
            close();
        }
    }

    public Source getSource() {
        return mSource;
    }

    /**
     * Marks the suggestions set as complete, regardless of whether all corpora have
     * returned.
     */
    public void done() {
        mDone = true;
    }

    /**
     * Checks whether all sources have reported.
     * Must be called on the UI thread, or before this object is seen by the UI thread.
     */
    public boolean isDone() {
        return mDone || mResult != null;
    }

    /**
     * Adds a list of corpus results. Must be called on the UI thread, or before this
     * object is seen by the UI thread.
     */
    public void addResults(SourceResult result) {
        if (isClosed()) {
            result.close();
            return;
        }

        if (DBG) {
            Log.d(TAG, ""addResults[""+ hashCode() + ""] source:"" +
                    result.getSource().getName() + "" results:"" + result.getCount());
        }
        if (!mQuery.equals(result.getUserQuery())) {
          throw new IllegalArgumentException(""Got result for wrong query: ""
                + mQuery + "" != "" + result.getUserQuery());
        }
        mResult = result;
        notifyDataSetChanged();
    }

    /**
     * Registers an observer that will be notified when the reported results or
     * the done status changes.
     */
    public void registerDataSetObserver(DataSetObserver observer) {
        if (mClosed) {
            throw new IllegalStateException(""registerDataSetObserver() when closed"");
        }
        mDataSetObservable.registerObserver(observer);
    }


    /**
     * Unregisters an observer.
     */
    public void unregisterDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.unregisterObserver(observer);
    }

    /**
     * Calls {@link DataSetObserver#onChanged()} on all observers.
     */
    protected void notifyDataSetChanged() {
        if (DBG) Log.d(TAG, ""notifyDataSetChanged()"");
        mDataSetObservable.notifyChanged();
    }

    /**
     * Closes all the source results and unregisters all observers.
     */
    private void close() {
        if (DBG) Log.d(TAG, ""close() ["" + hashCode() + ""]"");
        if (mClosed) {
            throw new IllegalStateException(""Double close()"");
        }
        mClosed = true;
        mDataSetObservable.unregisterAll();
        if (mResult != null) {
            mResult.close();
        }
        mResult = null;
    }

    public boolean isClosed() {
        return mClosed;
    }

    @Override
    protected void finalize() {
        if (!mClosed) {
            Log.e(TAG, ""LEAK! Finalized without being closed: Suggestions["" + getQuery() + ""]"");
        }
    }

    public String getQuery() {
        return mQuery;
    }

    /**
     * Gets the list of corpus results reported so far. Do not modify or hang on to
     * the returned iterator.
     */
    public SourceResult getResult() {
        return mResult;
    }

    public SourceResult getWebResult() {
        return mResult;
    }

    /**
     * Gets the number of source results.
     * Must be called on the UI thread, or before this object is seen by the UI thread.
     */
    public int getResultCount() {
        if (isClosed()) {
            throw new IllegalStateException(""Called getSourceCount() when closed."");
        }
        return mResult == null ? 0 : mResult.getCount();
    }

    @Override
    public String toString() {
        return ""Suggestions@"" + hashCode() + ""{source="" + mSource
                + "",getResultCount()="" + getResultCount() + ""}"";
    }

}
",True,36,6,7,3,6,7,6,L4
26,com.android.quicksearchbox.google.GoogleSuggestionProvider.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.google;

import com.android.quicksearchbox.CursorBackedSourceResult;
import com.android.quicksearchbox.QsbApplication;
import com.android.quicksearchbox.Source;
import com.android.quicksearchbox.SourceResult;
import com.android.quicksearchbox.SuggestionCursorBackedCursor;

import android.app.SearchManager;
import android.content.ContentProvider;
import android.content.ContentValues;
import android.content.Context;
import android.content.UriMatcher;
import android.database.Cursor;
import android.net.Uri;
import android.util.Log;

/**
 * A suggestion provider which provides content from Genie, a service that offers
 * a superset of the content provided by Google Suggest.
 */
public class GoogleSuggestionProvider extends ContentProvider {
    private static final boolean DBG = false;
    private static final String TAG = ""QSB.GoogleSuggestionProvider"";

    // UriMatcher constants
    private static final int SEARCH_SUGGEST = 0;
    private static final int SEARCH_SHORTCUT = 1;

    private UriMatcher mUriMatcher;

    private GoogleSource mSource;

    @Override
    public boolean onCreate() {
        mSource = QsbApplication.get(getContext()).getGoogleSource();
        mUriMatcher = buildUriMatcher(getContext());
        return true;
    }

    /**
     * This will always return {@link SearchManager#SUGGEST_MIME_TYPE} as this
     * provider is purely to provide suggestions.
     */
    @Override
    public String getType(Uri uri) {
        return SearchManager.SUGGEST_MIME_TYPE;
    }

    private SourceResult emptyIfNull(SourceResult result, GoogleSource source, String query) {
        return result == null ? new CursorBackedSourceResult(source, query) : result;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection,
            String[] selectionArgs, String sortOrder) {

        if (DBG) Log.d(TAG, ""query uri="" + uri);
        int match = mUriMatcher.match(uri);

        if (match == SEARCH_SUGGEST) {
            String query = getQuery(uri);
            return new SuggestionCursorBackedCursor(
                    emptyIfNull(mSource.queryExternal(query), mSource, query));
        } else if (match == SEARCH_SHORTCUT) {
            String shortcutId = getQuery(uri);
            String extraData =
                uri.getQueryParameter(SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA);
            return new SuggestionCursorBackedCursor(mSource.refreshShortcut(shortcutId, extraData));
        } else {
            throw new IllegalArgumentException(""Unknown URI "" + uri);
        }
    }

    /**
     * Gets the search text from a uri.
     */
    private String getQuery(Uri uri) {
        if (uri.getPathSegments().size() > 1) {
            return uri.getLastPathSegment();
        } else {
            return """";
        }
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection,
            String[] selectionArgs) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        throw new UnsupportedOperationException();
    }

    private UriMatcher buildUriMatcher(Context context) {
        String authority = getAuthority(context);
        UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);
        matcher.addURI(authority, SearchManager.SUGGEST_URI_PATH_QUERY,
                SEARCH_SUGGEST);
        matcher.addURI(authority, SearchManager.SUGGEST_URI_PATH_QUERY + ""/*"",
                SEARCH_SUGGEST);
        matcher.addURI(authority, SearchManager.SUGGEST_URI_PATH_SHORTCUT,
                SEARCH_SHORTCUT);
        matcher.addURI(authority, SearchManager.SUGGEST_URI_PATH_SHORTCUT + ""/*"",
                SEARCH_SHORTCUT);
        return matcher;
    }

    protected String getAuthority(Context context) {
        return context.getPackageName() + "".google"";
    }

}
",False,1,0,0,0,0,0,0,I0
27,com.android.quicksearchbox.google.GoogleSearch.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.google;

import com.android.common.Search;
import com.android.quicksearchbox.QsbApplication;

import android.app.Activity;
import android.app.PendingIntent;
import android.app.SearchManager;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.location.Location;
import android.net.Uri;
import android.os.Bundle;
import android.provider.Browser;
import android.text.TextUtils;
import android.util.Log;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Locale;

/**
 * This class is purely here to get search queries and route them to
 * the global {@link Intent#ACTION_WEB_SEARCH}.
 */
public class GoogleSearch extends Activity {
    private static final String TAG = ""GoogleSearch"";
    private static final boolean DBG = false;

    // Used to figure out which domain to base search requests
    // on.
    private SearchBaseUrlHelper mSearchDomainHelper;

    // ""source"" parameter for Google search requests from unknown sources (e.g. apps). This will get
    // prefixed with the string 'android-' before being sent on the wire.
    final static String GOOGLE_SEARCH_SOURCE_UNKNOWN = ""unknown"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Intent intent = getIntent();
        String action = intent != null ? intent.getAction() : null;

        // This should probably be moved so as to
        // send out the request to /checksearchdomain as early as possible.
        mSearchDomainHelper = QsbApplication.get(this).getSearchBaseUrlHelper();

        if (Intent.ACTION_WEB_SEARCH.equals(action) || Intent.ACTION_SEARCH.equals(action)) {
            handleWebSearchIntent(intent);
        }

        finish();
    }

    /**
     * Construct the language code (hl= paramater) for the given locale.
     */
    public static String getLanguage(Locale locale) {
        String language = locale.getLanguage();
        StringBuilder hl = new StringBuilder(language);
        String country = locale.getCountry();

        if (!TextUtils.isEmpty(country) && useLangCountryHl(language, country)) {
            hl.append('-');
            hl.append(country);
        }

        if (DBG) Log.d(TAG, ""language "" + language + "", country "" + country + "" -> hl="" + hl);
        return hl.toString();
    }

    // TODO: This is a workaround for bug 3232296. When that is fixed, this method can be removed.
    private static boolean useLangCountryHl(String language, String country) {
        // lang-country is currently only supported for a small number of locales
        if (""en"".equals(language)) {
            return ""GB"".equals(country);
        } else if (""zh"".equals(language)) {
            return ""CN"".equals(country) || ""TW"".equals(country);
        } else if (""pt"".equals(language)) {
            return ""BR"".equals(country) || ""PT"".equals(country);
        } else {
            return false;
        }
    }

    private void handleWebSearchIntent(Intent intent) {
        Intent launchUriIntent = createLaunchUriIntentFromSearchIntent(intent);
        PendingIntent pending =
            intent.getParcelableExtra(SearchManager.EXTRA_WEB_SEARCH_PENDINGINTENT);
        if (pending == null || !launchPendingIntent(pending, launchUriIntent)) {
            launchIntent(launchUriIntent);
        }
    }

    private Intent createLaunchUriIntentFromSearchIntent(Intent intent) {
        String query = intent.getStringExtra(SearchManager.QUERY);
        if (TextUtils.isEmpty(query)) {
            Log.w(TAG, ""Got search intent with no query."");
            return null;
        }

        // If the caller specified a 'source' url parameter, use that and if not use default.
        Bundle appSearchData = intent.getBundleExtra(SearchManager.APP_DATA);
        String source = GOOGLE_SEARCH_SOURCE_UNKNOWN;
        if (appSearchData != null) {
            source = appSearchData.getString(Search.SOURCE);
        }
        
        // The browser can pass along an application id which it uses to figure out which
        // window to place a new search into. So if this exists, we'll pass it back to
        // the browser. Otherwise, add our own package name as the application id, so that
        // the browser can organize all searches launched from this provider together.
        String applicationId = intent.getStringExtra(Browser.EXTRA_APPLICATION_ID);
        if (applicationId == null) {
            applicationId = getPackageName();
        }

        try {
            String searchUri = mSearchDomainHelper.getSearchBaseUrl()
                    + ""&source=android-"" + source
                    + ""&q="" + URLEncoder.encode(query, ""UTF-8"");
            Intent launchUriIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(searchUri));
            launchUriIntent.putExtra(Browser.EXTRA_APPLICATION_ID, applicationId);
            launchUriIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            return launchUriIntent;
        } catch (UnsupportedEncodingException e) {
            Log.w(TAG, ""Error"", e);
            return null;
        }

    }

    private void launchIntent(Intent intent) {
        try {
            Log.i(TAG, ""Launching intent: "" + intent.toUri(0));
            startActivity(intent);
        } catch (ActivityNotFoundException ex) {
            Log.w(TAG, ""No activity found to handle: "" + intent);
        }
    }

    private boolean launchPendingIntent(PendingIntent pending, Intent fillIn) {
        try {
            pending.send(this, Activity.RESULT_OK, fillIn);
            return true;
        } catch (PendingIntent.CanceledException ex) {
            Log.i(TAG, ""Pending intent cancelled: "" + pending);
            return false;
        }
    }

}
",True,1,0,0,0,0,0,0,I0
28,com.android.quicksearchbox.util.Consumer.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

/**
 * Interface for data consumers.
 *
 * @param <A> The type of data to consume.
 */
public interface Consumer<A> {

    /**
     * Consumes a value.
     *
     * @param value The value to consume.
     * @return {@code true} if the value was accepted, {@code false} otherwise.
     */
    boolean consume(A value);

}
",False,21,5,7,0,0,3,0,L4
29,com.android.quicksearchbox.util.Util.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.net.Uri;
import android.util.Log;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * General utilities.
 */
public class Util {

    private static final String TAG = ""QSB.Util"";

    public static <A> Set<A> setOfFirstN(List<A> list, int n) {
        int end = Math.min(list.size(), n);
        HashSet<A> set = new HashSet<A>(end);
        for (int i = 0; i < end; i++) {
            set.add(list.get(i));
        }
        return set;
    }

    public static Uri getResourceUri(Context packageContext, int res) {
        try {
            Resources resources = packageContext.getResources();
            return getResourceUri(resources, packageContext.getPackageName(), res);
        } catch (Resources.NotFoundException e) {
            Log.e(TAG, ""Resource not found: "" + res + "" in "" + packageContext.getPackageName());
            return null;
        }
    }

    public static Uri getResourceUri(Context context, ApplicationInfo appInfo, int res) {
        try {
            Resources resources = context.getPackageManager().getResourcesForApplication(appInfo);
            return getResourceUri(resources, appInfo.packageName, res);
        } catch (PackageManager.NameNotFoundException e) {
            Log.e(TAG, ""Resources not found for "" + appInfo.packageName);
            return null;
        } catch (Resources.NotFoundException e) {
            Log.e(TAG, ""Resource not found: "" + res + "" in "" + appInfo.packageName);
            return null;
        }
    }

    private static Uri getResourceUri(Resources resources, String appPkg, int res)
            throws Resources.NotFoundException {
        String resPkg = resources.getResourcePackageName(res);
        String type = resources.getResourceTypeName(res);
        String name = resources.getResourceEntryName(res);
        return makeResourceUri(appPkg, resPkg, type, name);
    }

    private static Uri makeResourceUri(String appPkg, String resPkg, String type, String name) {
        Uri.Builder uriBuilder = new Uri.Builder();
        uriBuilder.scheme(ContentResolver.SCHEME_ANDROID_RESOURCE);
        uriBuilder.encodedAuthority(appPkg);
        uriBuilder.appendEncodedPath(type);
        if (!appPkg.equals(resPkg)) {
            uriBuilder.appendEncodedPath(resPkg + "":"" + name);
        } else {
            uriBuilder.appendEncodedPath(name);
        }
        return uriBuilder.build();
    }
}
",False,22,5,8,0,0,8,0,L0
30,com.android.quicksearchbox.util.PriorityThreadFactory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.os.Process;

import java.util.concurrent.ThreadFactory;

/**
 * A thread factory that creates threads with a given thread priority.
 */
public class PriorityThreadFactory implements ThreadFactory {

    private final int mPriority;

    /**
     * Creates a new thread factory.
     *
     * @param priority The thread priority of the threads created by this factory.
     *        For values, see {@link Process}.
     */
    public PriorityThreadFactory(int priority) {
        mPriority = priority;
    }

    public Thread newThread(Runnable r) {
        return new Thread(r) {
            @Override
            public void run() {
                Process.setThreadPriority(mPriority);
                super.run();
            }
        };
    }

}
",True,17,5,5,0,0,2,0,L0
31,com.android.quicksearchbox.util.BarrierConsumer.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import java.util.ArrayList;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * A consumer that consumes a fixed number of values. When the expected number of values
 * has been consumed, further values are rejected.
 */
public class BarrierConsumer<A> implements Consumer<A> {

    private final Lock mLock = new ReentrantLock();
    private final Condition mNotFull = mLock.newCondition();

    private final int mExpectedCount;

    // Set to null when getValues() returns.
    private ArrayList<A> mValues;

    /**
     * Constructs a new BarrierConsumer.
     *
     * @param expectedCount The number of values to consume.
     */
    public BarrierConsumer(int expectedCount) {
        mExpectedCount = expectedCount;
        mValues = new ArrayList<A>(expectedCount);
    }

    /**
     * Blocks until the expected number of results is available, or until the thread is
     * interrupted. This method should not be called multiple times.
     *
     * @return A list of values, never {@code null}.
     */
    public ArrayList<A> getValues() {
        mLock.lock();
        try {
            try {
                while (!isFull()) {
                    mNotFull.await();
                }
            } catch (InterruptedException ex) {
                // Return the values that we've gotten so far
            }
            ArrayList<A> values = mValues;
            mValues = null;  // mark that getValues() has returned
            return values;
        } finally {
            mLock.unlock();
        }
    }

    public boolean consume(A value) {
        mLock.lock();
        try {
            // Do nothing if getValues() has alrady returned,
            // or enough values have already been consumed
            if (mValues == null || isFull()) {
                return false;
            }
            mValues.add(value);
            if (isFull()) {
                // Wake up any thread waiting in getValues()
                mNotFull.signal();
            }
            return true;
        } finally {
            mLock.unlock();
        }
    }

    private boolean isFull() {
        return mValues.size() == mExpectedCount;
    }
}
",False,19,7,4,1,1,1,1,L4
32,com.android.quicksearchbox.util.NamedTaskExecutor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

/**
 * Runs tasks that have a name tag.
 */
public interface NamedTaskExecutor {

    /**
     * Schedules a task for execution. Implementations should not throw
     * {@link java.util.concurrent.RejectedExecutionException} if the task
     * cannot be run. They should drop it silently instead.
     */
    void execute(NamedTask task);

    /**
     * Stops any unstarted tasks from running. Implementations of this method must be
     * idempotent.
     */
    void cancelPendingTasks();

    /**
     * Shuts down this executor, freeing any resources that it owns. The executor
     * may not be used after calling this method. Implementations of this method must be
     * idempotent.
     */
    void close();

}
",False,30,5,10,1,1,10,1,L0
33,com.android.quicksearchbox.util.NamedTask.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

/**
 * A task that has a name.
 */
public interface NamedTask extends Runnable {

    String getName();

}
",False,31,5,8,0,0,8,0,L0
34,com.android.quicksearchbox.util.SQLiteTransaction.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.database.sqlite.SQLiteDatabase;

/**
 * Abstract helper base class for SQLite write transactions.
 */
public abstract class SQLiteTransaction {

    /**
     * Executes the statements that form the transaction.
     *
     * @param db A writable database.
     * @return {@code true} if the transaction should be committed.
     */
    protected abstract boolean performTransaction(SQLiteDatabase db);

    /**
     * Runs the transaction against the database. The results are committed if
     * {@link #performTransaction(SQLiteDatabase)} completes normally and returns {@code true}.
     */
    public void run(SQLiteDatabase db) {
        db.beginTransaction();
        try {
            if (performTransaction(db)) {
                db.setTransactionSuccessful();
            }
        } finally {
            db.endTransaction();
        }
    }
}
",False,18,6,5,0,0,1,0,L4
35,com.android.quicksearchbox.util.PerNameExecutor.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;


import java.util.HashMap;

/**
 * Uses a separate executor for each task name.
 */
public class PerNameExecutor implements NamedTaskExecutor {

    private final Factory<NamedTaskExecutor> mExecutorFactory;
    private HashMap<String, NamedTaskExecutor> mExecutors;

    /**
     * @param executorFactory Used to run the commands.
     */
    public PerNameExecutor(Factory<NamedTaskExecutor> executorFactory) {
        mExecutorFactory = executorFactory;
    }

    public synchronized void cancelPendingTasks() {
        if (mExecutors == null) return;
        for (NamedTaskExecutor executor : mExecutors.values()) {
            executor.cancelPendingTasks();
        }
    }

    public synchronized void close() {
        if (mExecutors == null) return;
        for (NamedTaskExecutor executor : mExecutors.values()) {
            executor.close();
        }
    }

    public synchronized void execute(NamedTask task) {
        if (mExecutors == null) {
            mExecutors = new HashMap<String, NamedTaskExecutor>();
        }
        String name = task.getName();
        NamedTaskExecutor executor = mExecutors.get(name);
        if (executor == null) {
            executor = mExecutorFactory.create();
            mExecutors.put(name, executor);
        }
        executor.execute(task);
    }

}
",False,20,5,5,1,3,2,3,L1
36,com.android.quicksearchbox.util.BatchingNamedTaskExecutor.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;


import android.util.Log;

import java.util.ArrayList;
import java.util.List;

/**
 * Executes NamedTasks in batches of a given size.  Tasks are queued until
 * executeNextBatch is called.
 */
public class BatchingNamedTaskExecutor implements NamedTaskExecutor {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.BatchingNamedTaskExecutor"";

    private final NamedTaskExecutor mExecutor;

    /** Queue of tasks waiting to be dispatched to mExecutor **/
    private final ArrayList<NamedTask> mQueuedTasks = new ArrayList<NamedTask>();

    /**
     * Creates a new BatchingSourceTaskExecutor.
     *
     * @param executor A SourceTaskExecutor for actually executing the tasks.
     */
    public BatchingNamedTaskExecutor(NamedTaskExecutor executor) {
        mExecutor = executor;
    }

    public void execute(NamedTask task) {
        synchronized (mQueuedTasks) {
            if (DBG) Log.d(TAG, ""Queuing "" + task);
            mQueuedTasks.add(task);
        }
    }

    private void dispatch(NamedTask task) {
        if (DBG) Log.d(TAG, ""Dispatching "" + task);
        mExecutor.execute(task);
    }

    /**
     * Instructs the executor to submit the next batch of results.
     * @param batchSize the maximum number of entries to execute.
     */
    public void executeNextBatch(int batchSize) {
        NamedTask[] batch = new NamedTask[0];
        synchronized (mQueuedTasks) {
            int count = Math.min(mQueuedTasks.size(), batchSize);
            List<NamedTask> nextTasks = mQueuedTasks.subList(0, count);
            batch = nextTasks.toArray(batch);
            nextTasks.clear();
            if (DBG) Log.d(TAG, ""Dispatching batch of "" + count);
        }

        for (NamedTask task : batch) {
            dispatch(task);
        }
    }

    /**
     * Cancel any unstarted tasks running in this executor.  This instance 
     * should not be re-used after calling this method.
     */
    public void cancelPendingTasks() {
        synchronized (mQueuedTasks) {
            mQueuedTasks.clear();
        }
    }

    public void close() {
        cancelPendingTasks();
        mExecutor.close();
    }
}
",False,19,6,5,1,2,1,2,L5
37,com.android.quicksearchbox.util.SingleThreadNamedTaskExecutor.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

import android.util.Log;

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;

/**
 * Executor that uses a single thread and an unbounded work queue.
 */
public class SingleThreadNamedTaskExecutor implements NamedTaskExecutor {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SingleThreadNamedTaskExecutor"";

    private final LinkedBlockingQueue<NamedTask> mQueue;
    private final Thread mWorker;
    private volatile boolean mClosed = false;

    public SingleThreadNamedTaskExecutor(ThreadFactory threadFactory) {
        mQueue = new LinkedBlockingQueue<NamedTask>();
        mWorker = threadFactory.newThread(new Worker());
        mWorker.start();
    }

    public void cancelPendingTasks() {
        if (DBG) Log.d(TAG, ""Cancelling "" + mQueue.size() + "" tasks: "" + mWorker.getName());
        if (mClosed) {
            throw new IllegalStateException(""cancelPendingTasks() after close()"");
        }
        mQueue.clear();
    }

    public void close() {
        mClosed = true;
        mWorker.interrupt();
        mQueue.clear();
    }

    public void execute(NamedTask task) {
        if (mClosed) {
            throw new IllegalStateException(""execute() after close()"");
        }
        mQueue.add(task);
    }

    private class Worker implements Runnable {
        public void run() {
            try {
                loop();
            } finally {
                if (!mClosed) Log.w(TAG, ""Worker exited before close"");
            }
        }

        private void loop() {
            Thread currentThread = Thread.currentThread();
            String threadName = currentThread.getName();
            while (!mClosed) {
                NamedTask task;
                try {
                    task = mQueue.take();
                } catch (InterruptedException ex) {
                    continue;
                }
                currentThread.setName(threadName + "" "" + task.getName());
                try {
                    if (DBG) Log.d(TAG, ""Running task "" + task.getName());
                    task.run();
                    if (DBG) Log.d(TAG, ""Task "" + task.getName() + "" complete"");
                } catch (RuntimeException ex) {
                    Log.e(TAG, ""Task "" + task.getName() + "" failed"", ex);
                }
            }
        }
    }

    public static Factory<NamedTaskExecutor> factory(final ThreadFactory threadFactory) {
        return new Factory<NamedTaskExecutor>() {
            public NamedTaskExecutor create() {
                return new SingleThreadNamedTaskExecutor(threadFactory);
            }
        };
    }

}
",True,20,5,5,1,3,2,3,L1
38,com.android.quicksearchbox.util.Factory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.util;

public interface Factory<A> {

    A create();

}
",False,21,5,7,0,0,5,0,L0
39,com.android.quicksearchbox.ui.SuggestionView.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Suggestion;

/**
 * Interface to be implemented by any view appearing in the list of suggestions.
 */
public interface SuggestionView {
    /**
     * Set the view's contents based on the given suggestion.
     */
    void bindAsSuggestion(Suggestion suggestion, String userQuery);

    /**
     * Binds this view to a list adapter.
     *
     * @param adapter The adapter of the list which the view is appearing in
     * @param position The position of this view with the list.
     */
    void bindAdapter(SuggestionsAdapter<?> adapter, long position);

}
",False,29,6,6,3,2,5,1,L1
40,com.android.quicksearchbox.ui.DelayingSuggestionsAdapter.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.SuggestionCursor;
import com.android.quicksearchbox.SuggestionPosition;
import com.android.quicksearchbox.Suggestions;

import android.database.DataSetObserver;
import android.util.Log;
import android.view.View.OnFocusChangeListener;

/**
 * A {@link SuggestionsListAdapter} that doesn't expose the new suggestions
 * until there are some results to show.
 */
public class DelayingSuggestionsAdapter<A> implements SuggestionsAdapter<A> {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.DelayingSuggestionsAdapter"";

    private DataSetObserver mPendingDataSetObserver;

    private Suggestions mPendingSuggestions;

    private final SuggestionsAdapterBase<A> mDelayedAdapter;

    public DelayingSuggestionsAdapter(SuggestionsAdapterBase<A> delayed) {
        mDelayedAdapter = delayed;
    }

    public void close() {
        setPendingSuggestions(null);
        mDelayedAdapter.close();
    }

    @Override
    public void setSuggestions(Suggestions suggestions) {
        if (suggestions == null) {
            mDelayedAdapter.setSuggestions(null);
            setPendingSuggestions(null);
            return;
        }
        if (shouldPublish(suggestions)) {
            if (DBG) Log.d(TAG, ""Publishing suggestions immediately: "" + suggestions);
            mDelayedAdapter.setSuggestions(suggestions);
            // Clear any old pending suggestions.
            setPendingSuggestions(null);
        } else {
            if (DBG) Log.d(TAG, ""Delaying suggestions publishing: "" + suggestions);
            setPendingSuggestions(suggestions);
        }
    }

    /**
     * Gets whether the given suggestions are non-empty for the selected source.
     */
    private boolean shouldPublish(Suggestions suggestions) {
        if (suggestions.isDone()) return true;
        SuggestionCursor cursor = suggestions.getResult();
        if (cursor != null && cursor.getCount() > 0) {
            return true;
        }
        return false;
    }

    private void setPendingSuggestions(Suggestions suggestions) {
        if (mPendingSuggestions == suggestions) {
            return;
        }
        if (mDelayedAdapter.isClosed()) {
            if (suggestions != null) {
                suggestions.release();
            }
            return;
        }
        if (mPendingDataSetObserver == null) {
            mPendingDataSetObserver = new PendingSuggestionsObserver();
        }
        if (mPendingSuggestions != null) {
            mPendingSuggestions.unregisterDataSetObserver(mPendingDataSetObserver);
            // Close old suggestions, but only if they are not also the current
            // suggestions.
            if (mPendingSuggestions != getSuggestions()) {
                mPendingSuggestions.release();
            }
        }
        mPendingSuggestions = suggestions;
        if (mPendingSuggestions != null) {
            mPendingSuggestions.registerDataSetObserver(mPendingDataSetObserver);
        }
    }

    protected void onPendingSuggestionsChanged() {
        if (DBG) {
            Log.d(TAG, ""onPendingSuggestionsChanged(), mPendingSuggestions=""
                    + mPendingSuggestions);
        }
        if (shouldPublish(mPendingSuggestions)) {
            if (DBG) Log.d(TAG, ""Suggestions now available, publishing: "" + mPendingSuggestions);
            mDelayedAdapter.setSuggestions(mPendingSuggestions);
            // The suggestions are no longer pending.
            setPendingSuggestions(null);
        }
    }

    private class PendingSuggestionsObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            onPendingSuggestionsChanged();
        }
    }

    @Override
    public A getListAdapter() {
        return mDelayedAdapter.getListAdapter();
    }

    public SuggestionCursor getCurrentPromotedSuggestions() {
        return mDelayedAdapter.getCurrentSuggestions();
    }

    @Override
    public Suggestions getSuggestions() {
        return mDelayedAdapter.getSuggestions();
    }

    @Override
    public SuggestionPosition getSuggestion(long suggestionId) {
        return mDelayedAdapter.getSuggestion(suggestionId);
    }

    @Override
    public void onSuggestionClicked(long suggestionId) {
        mDelayedAdapter.onSuggestionClicked(suggestionId);
    }

    @Override
    public void onSuggestionQueryRefineClicked(long suggestionId) {
        mDelayedAdapter.onSuggestionQueryRefineClicked(suggestionId);
    }

    @Override
    public void setOnFocusChangeListener(OnFocusChangeListener l) {
        mDelayedAdapter.setOnFocusChangeListener(l);
    }

    @Override
    public void setSuggestionClickListener(SuggestionClickListener listener) {
        mDelayedAdapter.setSuggestionClickListener(listener);
    }

    @Override
    public boolean isEmpty() {
        return mDelayedAdapter.isEmpty();
    }

}
",False,33,5,5,3,8,1,4,L5
41,com.android.quicksearchbox.ui.SuggestionViewFactory.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Suggestion;
import com.android.quicksearchbox.SuggestionCursor;

import android.view.View;
import android.view.ViewGroup;

import java.util.Collection;

/**
 * Factory interface for suggestion views.
 */
public interface SuggestionViewFactory {

    /**
     * Returns all the view types that are used by this factory. Each view type corresponds to a
     * specific layout that is used to display suggestions. The returned set must have at least one
     * item in it.
     *
     * View types must be unique across all suggestion view factories.
     */
    Collection<String> getSuggestionViewTypes();

    /**
     * Returns the view type to be used for displaying the given suggestion. This MUST correspond to
     * one of the view types returned by {@link #getSuggestionViewTypes()}.
     */
    String getViewType(Suggestion suggestion);

    /**
     * Gets a view corresponding to the current suggestion in the given cursor.
     *
     * @param convertView The old view to reuse, if possible. Note: You should check that this view
     *        is non-null and of an appropriate type before using. If it is not possible to convert
     *        this view to display the correct data, this method can create a new view.
     * @param parent The parent that this view will eventually be attached to
     * @return A View corresponding to the data within this suggestion.
     */
    View getView(SuggestionCursor suggestion, String userQuery, View convertView, ViewGroup parent);

    /**
     * Checks whether this factory can create views for the given suggestion.
     */
    boolean canCreateView(Suggestion suggestion);

}
",False,26,5,6,3,2,4,2,L5
42,com.android.quicksearchbox.ui.SuggestionsView.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import android.content.Context;
import android.util.AttributeSet;
import android.widget.ListAdapter;
import android.widget.ListView;

import com.android.quicksearchbox.SuggestionPosition;

/**
 * Holds a list of suggestions.
 */
public class SuggestionsView extends ListView implements SuggestionsListView<ListAdapter> {

    private static final boolean DBG = false;
    private static final String TAG = ""QSB.SuggestionsView"";

    private SuggestionsAdapter<ListAdapter> mSuggestionsAdapter;

    public SuggestionsView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    public void setSuggestionsAdapter(SuggestionsAdapter<ListAdapter> adapter) {
        super.setAdapter(adapter == null ? null : adapter.getListAdapter());
        mSuggestionsAdapter = adapter;
    }

    @Override
    public SuggestionsAdapter<ListAdapter> getSuggestionsAdapter() {
        return mSuggestionsAdapter;
    }

    @Override
    public void onFinishInflate() {
        super.onFinishInflate();
        setItemsCanFocus(true);
    }

    /**
     * Gets the position of the selected suggestion.
     *
     * @return A 0-based index, or {@code -1} if no suggestion is selected.
     */
    public int getSelectedPosition() {
        return getSelectedItemPosition();
    }

    /**
     * Gets the selected suggestion.
     *
     * @return {@code null} if no suggestion is selected.
     */
    public SuggestionPosition getSelectedSuggestion() {
        return (SuggestionPosition) getSelectedItem();
    }


}
",False,14,3,3,4,4,1,4,L6
43,com.android.quicksearchbox.ui.SuggestionClickListener.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

/**
 * Listener interface for clicks on suggestions.
 */
public interface SuggestionClickListener {

    /**
     * Called when a suggestion is clicked.
     *
     * @param adapter Adapter that contains the clicked suggestion.
     * @param suggestionId The ID of the suggestion clicked. If the suggestion list is flat, this
     *      will be the position within the list.
     */
    void onSuggestionClicked(SuggestionsAdapter<?> adapter, long suggestionId);

    /**
     * Called when the ""query refine"" button of a suggestion is clicked.
     *
     * @param adapter Adapter that contains the clicked suggestion.
     * @param suggestionId The ID of the suggestion clicked. If the suggestion list is flat, this
     *      will be the position within the list.
     */
    void onSuggestionQueryRefineClicked(SuggestionsAdapter<?> adapter, long suggestionId);
}
",False,7,3,3,0,0,2,0,L6
44,com.android.quicksearchbox.ui.SuggestionViewInflater.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.Suggestion;
import com.android.quicksearchbox.SuggestionCursor;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import java.util.Collection;
import java.util.Collections;

/**
 * Suggestion view factory that inflates views from XML.
 */
public class SuggestionViewInflater implements SuggestionViewFactory {

    private final String mViewType;
    private final Class<?> mViewClass;
    private final int mLayoutId;
    private final Context mContext;

    /**
     * @param viewType The unique type of views inflated by this factory
     * @param viewClass The expected type of view classes.
     * @param layoutId resource ID of layout to use.
     * @param context Context to use for inflating the views.
     */
    public SuggestionViewInflater(String viewType, Class<? extends SuggestionView> viewClass,
            int layoutId, Context context) {
        mViewType = viewType;
        mViewClass = viewClass;
        mLayoutId = layoutId;
        mContext = context;
    }

    protected LayoutInflater getInflater() {
        return (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }

    public Collection<String> getSuggestionViewTypes() {
        return Collections.singletonList(mViewType);
    }

    public View getView(SuggestionCursor suggestion, String userQuery,
            View convertView, ViewGroup parent) {
        if (convertView == null || !convertView.getClass().equals(mViewClass)) {
            int layoutId = mLayoutId;
            convertView = getInflater().inflate(layoutId, parent, false);
        }
        if (!(convertView instanceof SuggestionView)) {
            throw new IllegalArgumentException(""Not a SuggestionView: "" + convertView);
        }
        ((SuggestionView) convertView).bindAsSuggestion(suggestion, userQuery);
        return convertView;
    }

    public String getViewType(Suggestion suggestion) {
        return mViewType;
    }

    public boolean canCreateView(Suggestion suggestion) {
        return true;
    }

}
",True,22,5,5,3,3,1,3,L5
45,com.android.quicksearchbox.ui.SearchActivityView.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import android.content.Context;
import android.database.DataSetObserver;
import android.graphics.drawable.Drawable;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.AttributeSet;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.view.inputmethod.CompletionInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.AbsListView;
import android.widget.ImageButton;
import android.widget.ListAdapter;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.TextView.OnEditorActionListener;

import com.android.quicksearchbox.Logger;
import com.android.quicksearchbox.QsbApplication;
import com.android.quicksearchbox.R;
import com.android.quicksearchbox.SearchActivity;
import com.android.quicksearchbox.SourceResult;
import com.android.quicksearchbox.SuggestionCursor;
import com.android.quicksearchbox.Suggestions;
import com.android.quicksearchbox.VoiceSearch;

import java.util.ArrayList;
import java.util.Arrays;

public abstract class SearchActivityView extends RelativeLayout {
    protected static final boolean DBG = false;
    protected static final String TAG = ""QSB.SearchActivityView"";

    // The string used for privateImeOptions to identify to the IME that it should not show
    // a microphone button since one already exists in the search dialog.
    // TODO: This should move to android-common or something.
    private static final String IME_OPTION_NO_MICROPHONE = ""nm"";

    protected QueryTextView mQueryTextView;
    // True if the query was empty on the previous call to updateQuery()
    protected boolean mQueryWasEmpty = true;
    protected Drawable mQueryTextEmptyBg;
    protected Drawable mQueryTextNotEmptyBg;

    protected SuggestionsListView<ListAdapter> mSuggestionsView;
    protected SuggestionsAdapter<ListAdapter> mSuggestionsAdapter;

    protected ImageButton mSearchGoButton;
    protected ImageButton mVoiceSearchButton;

    protected ButtonsKeyListener mButtonsKeyListener;

    private boolean mUpdateSuggestions;

    private QueryListener mQueryListener;
    private SearchClickListener mSearchClickListener;
    protected View.OnClickListener mExitClickListener;

    public SearchActivityView(Context context) {
        super(context);
    }

    public SearchActivityView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public SearchActivityView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    @Override
    protected void onFinishInflate() {
        mQueryTextView = (QueryTextView) findViewById(R.id.search_src_text);

        mSuggestionsView = (SuggestionsView) findViewById(R.id.suggestions);
        mSuggestionsView.setOnScrollListener(new InputMethodCloser());
        mSuggestionsView.setOnKeyListener(new SuggestionsViewKeyListener());
        mSuggestionsView.setOnFocusChangeListener(new SuggestListFocusListener());

        mSuggestionsAdapter = createSuggestionsAdapter();
        // TODO: why do we need focus listeners both on the SuggestionsView and the individual
        // suggestions?
        mSuggestionsAdapter.setOnFocusChangeListener(new SuggestListFocusListener());

        mSearchGoButton = (ImageButton) findViewById(R.id.search_go_btn);
        mVoiceSearchButton = (ImageButton) findViewById(R.id.search_voice_btn);
        mVoiceSearchButton.setImageDrawable(getVoiceSearchIcon());

        mQueryTextView.addTextChangedListener(new SearchTextWatcher());
        mQueryTextView.setOnEditorActionListener(new QueryTextEditorActionListener());
        mQueryTextView.setOnFocusChangeListener(new QueryTextViewFocusListener());
        mQueryTextEmptyBg = mQueryTextView.getBackground();

        mSearchGoButton.setOnClickListener(new SearchGoButtonClickListener());

        mButtonsKeyListener = new ButtonsKeyListener();
        mSearchGoButton.setOnKeyListener(mButtonsKeyListener);
        mVoiceSearchButton.setOnKeyListener(mButtonsKeyListener);

        mUpdateSuggestions = true;
    }

    public abstract void onResume();

    public abstract void onStop();

    public void onPause() {
        // Override if necessary
    }

    public void start() {
        mSuggestionsAdapter.getListAdapter().registerDataSetObserver(new SuggestionsObserver());
        mSuggestionsView.setSuggestionsAdapter(mSuggestionsAdapter);
    }

    public void destroy() {
        mSuggestionsView.setSuggestionsAdapter(null);  // closes mSuggestionsAdapter
    }

    // TODO: Get rid of this. To make it more easily testable,
    // the SearchActivityView should not depend on QsbApplication.
    protected QsbApplication getQsbApplication() {
        return QsbApplication.get(getContext());
    }

    protected Drawable getVoiceSearchIcon() {
        return getResources().getDrawable(R.drawable.ic_btn_speak_now);
    }

    protected VoiceSearch getVoiceSearch() {
        return getQsbApplication().getVoiceSearch();
    }

    protected SuggestionsAdapter<ListAdapter> createSuggestionsAdapter() {
        return new DelayingSuggestionsAdapter<ListAdapter>(new SuggestionsListAdapter(
                getQsbApplication().getSuggestionViewFactory()));
    }

    public void setMaxPromotedResults(int maxPromoted) {
    }

    public void limitResultsToViewHeight() {
    }

    public void setQueryListener(QueryListener listener) {
        mQueryListener = listener;
    }

    public void setSearchClickListener(SearchClickListener listener) {
        mSearchClickListener = listener;
    }

    public void setVoiceSearchButtonClickListener(View.OnClickListener listener) {
        if (mVoiceSearchButton != null) {
            mVoiceSearchButton.setOnClickListener(listener);
        }
    }

    public void setSuggestionClickListener(final SuggestionClickListener listener) {
        mSuggestionsAdapter.setSuggestionClickListener(listener);
        mQueryTextView.setCommitCompletionListener(new QueryTextView.CommitCompletionListener() {
            @Override
            public void onCommitCompletion(int position) {
                mSuggestionsAdapter.onSuggestionClicked(position);
            }
        });
    }

    public void setExitClickListener(final View.OnClickListener listener) {
        mExitClickListener = listener;
    }

    public Suggestions getSuggestions() {
        return mSuggestionsAdapter.getSuggestions();
    }

    public SuggestionCursor getCurrentSuggestions() {
        return mSuggestionsAdapter.getSuggestions().getResult();
    }

    public void setSuggestions(Suggestions suggestions) {
        suggestions.acquire();
        mSuggestionsAdapter.setSuggestions(suggestions);
    }

    public void clearSuggestions() {
        mSuggestionsAdapter.setSuggestions(null);
    }

    public String getQuery() {
        CharSequence q = mQueryTextView.getText();
        return q == null ? """" : q.toString();
    }

    public boolean isQueryEmpty() {
        return TextUtils.isEmpty(getQuery());
    }

    /**
     * Sets the text in the query box. Does not update the suggestions.
     */
    public void setQuery(String query, boolean selectAll) {
        mUpdateSuggestions = false;
        mQueryTextView.setText(query);
        mQueryTextView.setTextSelection(selectAll);
        mUpdateSuggestions = true;
    }

    protected SearchActivity getActivity() {
        Context context = getContext();
        if (context instanceof SearchActivity) {
            return (SearchActivity) context;
        } else {
            return null;
        }
    }

    public void hideSuggestions() {
        mSuggestionsView.setVisibility(GONE);
    }

    public void showSuggestions() {
        mSuggestionsView.setVisibility(VISIBLE);
    }

    public void focusQueryTextView() {
        mQueryTextView.requestFocus();
    }

    protected void updateUi() {
        updateUi(isQueryEmpty());
    }

    protected void updateUi(boolean queryEmpty) {
        updateQueryTextView(queryEmpty);
        updateSearchGoButton(queryEmpty);
        updateVoiceSearchButton(queryEmpty);
    }

    protected void updateQueryTextView(boolean queryEmpty) {
        if (queryEmpty) {
            mQueryTextView.setBackgroundDrawable(mQueryTextEmptyBg);
            mQueryTextView.setHint(null);
        } else {
            mQueryTextView.setBackgroundResource(R.drawable.textfield_search);
        }
    }

    private void updateSearchGoButton(boolean queryEmpty) {
        if (queryEmpty) {
            mSearchGoButton.setVisibility(View.GONE);
        } else {
            mSearchGoButton.setVisibility(View.VISIBLE);
        }
    }

    protected void updateVoiceSearchButton(boolean queryEmpty) {
        if (shouldShowVoiceSearch(queryEmpty)
                && getVoiceSearch().shouldShowVoiceSearch()) {
            mVoiceSearchButton.setVisibility(View.VISIBLE);
            mQueryTextView.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
        } else {
            mVoiceSearchButton.setVisibility(View.GONE);
            mQueryTextView.setPrivateImeOptions(null);
        }
    }

    protected boolean shouldShowVoiceSearch(boolean queryEmpty) {
        return queryEmpty;
    }

    /**
     * Hides the input method.
     */
    protected void hideInputMethod() {
        InputMethodManager imm = (InputMethodManager)
                getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        if (imm != null) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
    }

    public abstract void considerHidingInputMethod();

    public void showInputMethodForQuery() {
        mQueryTextView.showInputMethod();
    }

    /**
     * Dismiss the activity if BACK is pressed when the search box is empty.
     */
    @Override
    public boolean dispatchKeyEventPreIme(KeyEvent event) {
        SearchActivity activity = getActivity();
        if (activity != null && event.getKeyCode() == KeyEvent.KEYCODE_BACK
                && isQueryEmpty()) {
            KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null) {
                if (event.getAction() == KeyEvent.ACTION_DOWN
                        && event.getRepeatCount() == 0) {
                    state.startTracking(event, this);
                    return true;
                } else if (event.getAction() == KeyEvent.ACTION_UP
                        && !event.isCanceled() && state.isTracking(event)) {
                    hideInputMethod();
                    activity.onBackPressed();
                    return true;
                }
            }
        }
        return super.dispatchKeyEventPreIme(event);
    }

    /**
     * If the input method is in fullscreen mode, and the selector corpus
     * is All or Web, use the web search suggestions as completions.
     */
    protected void updateInputMethodSuggestions() {
        InputMethodManager imm = (InputMethodManager)
                getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        if (imm == null || !imm.isFullscreenMode()) return;
        Suggestions suggestions = mSuggestionsAdapter.getSuggestions();
        if (suggestions == null) return;
        CompletionInfo[] completions = webSuggestionsToCompletions(suggestions);
        if (DBG) Log.d(TAG, ""displayCompletions("" + Arrays.toString(completions) + "")"");
        imm.displayCompletions(mQueryTextView, completions);
    }

    private CompletionInfo[] webSuggestionsToCompletions(Suggestions suggestions) {
        SourceResult cursor = suggestions.getWebResult();
        if (cursor == null) return null;
        int count = cursor.getCount();
        ArrayList<CompletionInfo> completions = new ArrayList<CompletionInfo>(count);
        for (int i = 0; i < count; i++) {
            cursor.moveTo(i);
            String text1 = cursor.getSuggestionText1();
            completions.add(new CompletionInfo(i, i, text1));
        }
        return completions.toArray(new CompletionInfo[completions.size()]);
    }

    protected void onSuggestionsChanged() {
        updateInputMethodSuggestions();
    }

    protected boolean onSuggestionKeyDown(SuggestionsAdapter<?> adapter,
            long suggestionId, int keyCode, KeyEvent event) {
        // Treat enter or search as a click
        if (       keyCode == KeyEvent.KEYCODE_ENTER
                || keyCode == KeyEvent.KEYCODE_SEARCH
                || keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
            if (adapter != null) {
                adapter.onSuggestionClicked(suggestionId);
                return true;
            } else {
                return false;
            }
        }

        return false;
    }

    protected boolean onSearchClicked(int method) {
        if (mSearchClickListener != null) {
            return mSearchClickListener.onSearchClicked(method);
        }
        return false;
    }

    /**
     * Filters the suggestions list when the search text changes.
     */
    private class SearchTextWatcher implements TextWatcher {
        @Override
        public void afterTextChanged(Editable s) {
            boolean empty = s.length() == 0;
            if (empty != mQueryWasEmpty) {
                mQueryWasEmpty = empty;
                updateUi(empty);
            }
            if (mUpdateSuggestions) {
                if (mQueryListener != null) {
                    mQueryListener.onQueryChanged();
                }
            }
        }

        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
        }

        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count) {
        }
    }

    /**
     * Handles key events on the suggestions list view.
     */
    protected class SuggestionsViewKeyListener implements View.OnKeyListener {
        @Override
        public boolean onKey(View v, int keyCode, KeyEvent event) {
            if (event.getAction() == KeyEvent.ACTION_DOWN
                    && v instanceof SuggestionsListView<?>) {
                SuggestionsListView<?> listView = (SuggestionsListView<?>) v;
                if (onSuggestionKeyDown(listView.getSuggestionsAdapter(), 
                        listView.getSelectedItemId(), keyCode, event)) {
                    return true;
                }
            }
            return forwardKeyToQueryTextView(keyCode, event);
        }
    }

    private class InputMethodCloser implements SuggestionsView.OnScrollListener {

        @Override
        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount,
                int totalItemCount) {
        }

        @Override
        public void onScrollStateChanged(AbsListView view, int scrollState) {
            considerHidingInputMethod();
        }
    }

    /**
     * Listens for clicks on the source selector.
     */
    private class SearchGoButtonClickListener implements View.OnClickListener {
        @Override
        public void onClick(View view) {
            onSearchClicked(Logger.SEARCH_METHOD_BUTTON);
        }
    }

    /**
     * This class handles enter key presses in the query text view.
     */
    private class QueryTextEditorActionListener implements OnEditorActionListener {
        @Override
        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
            boolean consumed = false;
            if (event != null) {
                if (event.getAction() == KeyEvent.ACTION_UP) {
                    consumed = onSearchClicked(Logger.SEARCH_METHOD_KEYBOARD);
                } else if (event.getAction() == KeyEvent.ACTION_DOWN) {
                    // we have to consume the down event so that we receive the up event too
                    consumed = true;
                }
            }
            if (DBG) Log.d(TAG, ""onEditorAction consumed="" + consumed);
            return consumed;
        }
    }

    /**
     * Handles key events on the search and voice search buttons,
     * by refocusing to EditText.
     */
    private class ButtonsKeyListener implements View.OnKeyListener {
        @Override
        public boolean onKey(View v, int keyCode, KeyEvent event) {
            return forwardKeyToQueryTextView(keyCode, event);
        }
    }

    private boolean forwardKeyToQueryTextView(int keyCode, KeyEvent event) {
        if (!event.isSystem() && shouldForwardToQueryTextView(keyCode)) {
            if (DBG) Log.d(TAG, ""Forwarding key to query box: "" + event);
            if (mQueryTextView.requestFocus()) {
                return mQueryTextView.dispatchKeyEvent(event);
            }
        }
        return false;
    }

    private boolean shouldForwardToQueryTextView(int keyCode) {
        switch (keyCode) {
            case KeyEvent.KEYCODE_DPAD_UP:
            case KeyEvent.KEYCODE_DPAD_DOWN:
            case KeyEvent.KEYCODE_DPAD_LEFT:
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            case KeyEvent.KEYCODE_DPAD_CENTER:
            case KeyEvent.KEYCODE_ENTER:
            case KeyEvent.KEYCODE_SEARCH:
                return false;
            default:
                return true;
        }
    }

    /**
     * Hides the input method when the suggestions get focus.
     */
    private class SuggestListFocusListener implements OnFocusChangeListener {
        @Override
        public void onFocusChange(View v, boolean focused) {
            if (DBG) Log.d(TAG, ""Suggestions focus change, now: "" + focused);
            if (focused) {
                considerHidingInputMethod();
            }
        }
    }

    private class QueryTextViewFocusListener implements OnFocusChangeListener {
        @Override
        public void onFocusChange(View v, boolean focused) {
            if (DBG) Log.d(TAG, ""Query focus change, now: "" + focused);
            if (focused) {
                // The query box got focus, show the input method
                showInputMethodForQuery();
            }
        }
    }

    protected class SuggestionsObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            onSuggestionsChanged();
        }
    }

    public interface QueryListener {
        void onQueryChanged();
    }

    public interface SearchClickListener {
        boolean onSearchClicked(int method);
    }

    private class CloseClickListener implements OnClickListener {
        @Override
        public void onClick(View v) {
            if (!isQueryEmpty()) {
                mQueryTextView.setText("""");
            } else {
                mExitClickListener.onClick(v);
            }
        }
    }
}
",True,1,0,0,0,0,0,0,I0
46,com.android.quicksearchbox.ui.CorpusView.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.R;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.util.AttributeSet;
import android.view.ViewDebug;
import android.widget.Checkable;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;


/**
 * A corpus in the corpus selection list.
 */
public class CorpusView extends RelativeLayout implements Checkable {

    private ImageView mIcon;
    private TextView mLabel;
    private boolean mChecked;

    private static final int[] CHECKED_STATE_SET = {
        android.R.attr.state_checked
    };

    public CorpusView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public CorpusView(Context context) {
        super(context);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mIcon = (ImageView) findViewById(R.id.source_icon);
        mLabel = (TextView) findViewById(R.id.source_label);
    }

    public void setLabel(CharSequence label) {
        mLabel.setText(label);
    }

    public void setIcon(Drawable icon) {
        mIcon.setImageDrawable(icon);
    }

    @Override
    @ViewDebug.ExportedProperty
    public boolean isChecked() {
        return mChecked;
    }

    @Override
    public void setChecked(boolean checked) {
        if (mChecked != checked) {
            mChecked = checked;
            refreshDrawableState();
        }
    }

    @Override
    public void toggle() {
        setChecked(!mChecked);
    }

    @Override
    protected int[] onCreateDrawableState(int extraSpace) {
        final int[] drawableState = super.onCreateDrawableState(extraSpace + 1);
        if (isChecked()) {
            mergeDrawableStates(drawableState, CHECKED_STATE_SET);
        }
        return drawableState;
    }

}
",False,19,6,5,0,0,3,0,L5
47,com.android.quicksearchbox.ui.DefaultSuggestionView.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.R;
import com.android.quicksearchbox.Source;
import com.android.quicksearchbox.Suggestion;
import com.android.quicksearchbox.util.Consumer;
import com.android.quicksearchbox.util.NowOrLater;

import android.content.Context;
import android.content.res.ColorStateList;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.text.Html;
import android.text.Spannable;
import android.text.SpannableString;
import android.text.TextUtils;
import android.text.style.TextAppearanceSpan;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;
import android.widget.ImageView;
import android.widget.TextView;

/**
 * View for the items in the suggestions list. This includes promoted suggestions,
 * sources, and suggestions under each source.
 */
public class DefaultSuggestionView extends BaseSuggestionView {

    private static final boolean DBG = false;

    private static final String VIEW_ID = ""default"";

    private final String TAG = ""QSB.DefaultSuggestionView"";

    private AsyncIcon mAsyncIcon1;
    private AsyncIcon mAsyncIcon2;

    public DefaultSuggestionView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    public DefaultSuggestionView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public DefaultSuggestionView(Context context) {
        super(context);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mText1 = (TextView) findViewById(R.id.text1);
        mText2 = (TextView) findViewById(R.id.text2);
        mAsyncIcon1 = new AsyncIcon(mIcon1) {
            // override default icon (when no other available) with default source icon
            @Override
            protected String getFallbackIconId(Source source) {
                return source.getSourceIconUri().toString();
            }
            @Override
            protected Drawable getFallbackIcon(Source source) {
                return source.getSourceIcon();
            }
        };
        mAsyncIcon2 = new AsyncIcon(mIcon2);
    }

    @Override
    public void bindAsSuggestion(Suggestion suggestion, String userQuery) {
        super.bindAsSuggestion(suggestion, userQuery);

        CharSequence text1 = formatText(suggestion.getSuggestionText1(), suggestion);
        CharSequence text2 = suggestion.getSuggestionText2Url();
        if (text2 != null) {
            text2 = formatUrl(text2);
        } else {
            text2 = formatText(suggestion.getSuggestionText2(), suggestion);
        }
        // If there is no text for the second line, allow the first line to be up to two lines
        if (TextUtils.isEmpty(text2)) {
            mText1.setSingleLine(false);
            mText1.setMaxLines(2);
            mText1.setEllipsize(TextUtils.TruncateAt.START);
        } else {
            mText1.setSingleLine(true);
            mText1.setMaxLines(1);
            mText1.setEllipsize(TextUtils.TruncateAt.MIDDLE);
        }
        setText1(text1);
        setText2(text2);
        mAsyncIcon1.set(suggestion.getSuggestionSource(), suggestion.getSuggestionIcon1());
        mAsyncIcon2.set(suggestion.getSuggestionSource(), suggestion.getSuggestionIcon2());

        if (DBG) {
            Log.d(TAG, ""bindAsSuggestion(), text1="" + text1 + "",text2="" + text2 + "",q='"" +
                    userQuery + "",fromHistory="" + isFromHistory(suggestion));
        }
    }

    private CharSequence formatUrl(CharSequence url) {
        SpannableString text = new SpannableString(url);
        ColorStateList colors = getResources().getColorStateList(R.color.url_text);
        text.setSpan(new TextAppearanceSpan(null, 0, 0, colors, null),
                0, url.length(),
                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        return text;
    }

    private CharSequence formatText(String str, Suggestion suggestion) {
        boolean isHtml = ""html"".equals(suggestion.getSuggestionFormat());
        if (isHtml && looksLikeHtml(str)) {
            return Html.fromHtml(str);
        } else {
            return str;
        }
    }

    private boolean looksLikeHtml(String str) {
        if (TextUtils.isEmpty(str)) return false;
        for (int i = str.length() - 1; i >= 0; i--) {
            char c = str.charAt(i);
            if (c == '>' || c == '&') return true;
        }
        return false;
    }

    /**
     * Sets the drawable in an image view, makes sure the view is only visible if there
     * is a drawable.
     */
    private static void setViewDrawable(ImageView v, Drawable drawable) {
        // Set the icon even if the drawable is null, since we need to clear any
        // previous icon.
        v.setImageDrawable(drawable);

        if (drawable == null) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);

            // This is a hack to get any animated drawables (like a 'working' spinner)
            // to animate. You have to setVisible true on an AnimationDrawable to get
            // it to start animating, but it must first have been false or else the
            // call to setVisible will be ineffective. We need to clear up the story
            // about animated drawables in the future, see http://b/1878430.
            drawable.setVisible(false, false);
            drawable.setVisible(true, false);
        }
    }

    private class AsyncIcon {
        private final ImageView mView;
        private String mCurrentId;
        private String mWantedId;

        public AsyncIcon(ImageView view) {
            mView = view;
        }

        public void set(final Source source, final String sourceIconId) {
            if (sourceIconId != null) {
                // The iconId can just be a package-relative resource ID, which may overlap with
                // other packages. Make sure it's globally unique.
                Uri iconUri = source.getIconUri(sourceIconId);
                final String uniqueIconId = iconUri == null ? null : iconUri.toString();
                mWantedId = uniqueIconId;
                if (!TextUtils.equals(mWantedId, mCurrentId)) {
                    if (DBG) Log.d(TAG, ""getting icon Id="" + uniqueIconId);
                    NowOrLater<Drawable> icon = source.getIcon(sourceIconId);
                    if (icon.haveNow()) {
                        if (DBG) Log.d(TAG, ""getIcon ready now"");
                        handleNewDrawable(icon.getNow(), uniqueIconId, source);
                    } else {
                        // make sure old icon is not visible while new one is loaded
                        if (DBG) Log.d(TAG , ""getIcon getting later"");
                        clearDrawable();
                        icon.getLater(new Consumer<Drawable>(){
                            @Override
                            public boolean consume(Drawable icon) {
                                if (DBG) {
                                    Log.d(TAG, ""IconConsumer.consume got id "" + uniqueIconId +
                                            "" want id "" + mWantedId);
                                }
                                // ensure we have not been re-bound since the request was made.
                                if (TextUtils.equals(uniqueIconId, mWantedId)) {
                                    handleNewDrawable(icon, uniqueIconId, source);
                                    return true;
                                }
                                return false;
                            }});
                    }
                }
            } else {
                mWantedId = null;
                handleNewDrawable(null, null, source);
            }
        }

        private void handleNewDrawable(Drawable icon, String id, Source source) {
            if (icon == null) {
                mWantedId = getFallbackIconId(source);
                if (TextUtils.equals(mWantedId, mCurrentId)) {
                    return;
                }
                icon = getFallbackIcon(source);
            }
            setDrawable(icon, id);
        }

        private void setDrawable(Drawable icon, String id) {
            mCurrentId = id;
            setViewDrawable(mView, icon);
        }

        private void clearDrawable() {
            mCurrentId = null;
            mView.setImageDrawable(null);
        }

        protected String getFallbackIconId(Source source) {
            return null;
        }

        protected Drawable getFallbackIcon(Source source) {
            return null;
        }

    }

    public static class Factory extends SuggestionViewInflater {
        public Factory(Context context) {
            super(VIEW_ID, DefaultSuggestionView.class, R.layout.suggestion, context);
        }
    }

}
",False,7,1,1,2,3,1,3,L7
48,com.android.quicksearchbox.ui.SuggestionsAdapter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.quicksearchbox.ui;

import com.android.quicksearchbox.SuggestionCursor;
import com.android.quicksearchbox.SuggestionPosition;
import com.android.quicksearchbox.Suggestions;

import android.view.View.OnFocusChangeListener;
import android.widget.ExpandableListAdapter;
import android.widget.ListAdapter;

/**
 * Interface for suggestions adapters.
 *
 * @param <A> the adapter class used by the UI, probably either {@link ListAdapter} or
 *      {@link ExpandableListAdapter}.
 */
public interface SuggestionsAdapter<A> {

    /**
     * Sets the listener to be notified of clicks on suggestions.
     */
    void setSuggestionClickListener(SuggestionClickListener listener);

    /**
     * Sets the listener to be notified of focus change events on suggestion views.
     */
    void setOnFocusChangeListener(OnFocusChangeListener l);

    /**
     * Sets the current suggestions.
     */
    void setSuggestions(Suggestions suggestions);

    /**
     * Indicates if there's any suggestions in this adapter.
     */
    boolean isEmpty();

    /**
     * Gets the current suggestions.
     */
    Suggestions getSuggestions();

    /**
     * Gets the cursor and position corresponding to the given suggestion ID.
     * @param suggestionId Suggestion ID.
     */
    SuggestionPosition getSuggestion(long suggestionId);

    /**
     * Handles a regular click on a suggestion.
     *
     * @param suggestionId The ID of the suggestion clicked. If the suggestion list is flat, this
     *      will be the position within the list.
     */
    void onSuggestionClicked(long suggestionId);

    /**
     * Handles a click on the query refinement button.
     *
     * @param suggestionId The ID of the suggestion clicked. If the suggestion list is flat, this
     *      will be the position within the list.
     */
    void onSuggestionQueryRefineClicked(long suggestionId);

    /**
     * Gets the adapter to be used by the UI view.
     */
    A getListAdapter();

}
",False,35,5,6,3,7,4,6,L5
