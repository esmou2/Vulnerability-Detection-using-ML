,file_path,source_code,is_vulnerable, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,com.android.browser.LogTag.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.util.EventLog;

public class LogTag {

    /**
     * Log when the user is adding a new bookmark.
     *
     * @param url the url of the new bookmark.
     * @param where the location from where the bookmark was added
     */
    public static void logBookmarkAdded(String url, String where) {
        EventLog.writeEvent(EventLogTags.BROWSER_BOOKMARK_ADDED, url + ""|""
            + where);
    }

    /**
     * Log when a page has finished loading with how much
     * time the browser used to load the page.
     *
     * Note that a redirect will restart the timer, so this time is not
     * always how long it takes for the user to load a page.
     *
     * @param url the url of that page that finished loading.
     * @param duration the time the browser spent loading the page.
     */
    public static void logPageFinishedLoading(String url, long duration) {
        EventLog.writeEvent(EventLogTags.BROWSER_PAGE_LOADED, url + ""|""
            + duration);
    }

    /**
     * log the time the user has spent on a webpage
     *
     * @param url the url of the page that is being logged (old page).
     * @param duration the time spent on the webpage.
     */
    public static void logTimeOnPage(String url, long duration) {
        EventLog.writeEvent(EventLogTags.BROWSER_TIMEONPAGE, url + ""|""
            + duration);
    }
}
",False,30,5,12,0,0,3,0,L1
1,com.android.browser.WebStorageSizeManager.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.os.StatFs;
import android.util.Log;
import android.webkit.WebStorage;

import java.io.File;
import java.util.Set;


/**
 * Package level class for managing the disk size consumed by the WebDatabase
 * and ApplicationCaches APIs (henceforth called Web storage).
 *
 * Currently, the situation on the WebKit side is as follows:
 *  - WebDatabase enforces a quota for each origin.
 *  - Session/LocalStorage do not enforce any disk limits.
 *  - ApplicationCaches enforces a maximum size for all origins.
 *
 * The WebStorageSizeManager maintains a global limit for the disk space
 * consumed by the WebDatabase and ApplicationCaches. As soon as WebKit will
 * have a limit for Session/LocalStorage, this class will manage the space used
 * by those APIs as well.
 *
 * The global limit is computed as a function of the size of the partition where
 * these APIs store their data (they must store it on the same partition for
 * this to work) and the size of the available space on that partition.
 * The global limit is not subject to user configuration but we do provide
 * a debug-only setting.
 * TODO(andreip): implement the debug setting.
 *
 * The size of the disk space used for Web storage is initially divided between
 * WebDatabase and ApplicationCaches as follows:
 *
 * 75% for WebDatabase
 * 25% for ApplicationCaches
 *
 * When an origin's database usage reaches its current quota, WebKit invokes
 * the following callback function:
 * - exceededDatabaseQuota(Frame* frame, const String& database_name);
 * Note that the default quota for a new origin is 0, so we will receive the
 * 'exceededDatabaseQuota' callback before a new origin gets the chance to
 * create its first database.
 *
 * When the total ApplicationCaches usage reaches its current quota, WebKit
 * invokes the following callback function:
 * - void reachedMaxAppCacheSize(int64_t spaceNeeded);
 *
 * The WebStorageSizeManager's main job is to respond to the above two callbacks
 * by inspecting the amount of unused Web storage quota (i.e. global limit -
 * sum of all other origins' quota) and deciding if a quota increase for the
 * out-of-space origin is allowed or not.
 *
 * The default quota for an origin is its estimated size. If we cannot satisfy
 * the estimated size, then WebCore will not create the database.
 * Quota increases are done in steps, where the increase step is
 * min(QUOTA_INCREASE_STEP, unused_quota).
 *
 * When all the Web storage space is used, the WebStorageSizeManager creates
 * a system notification that will guide the user to the WebSettings UI. There,
 * the user can free some of the Web storage space by deleting all the data used
 * by an origin.
 */
class WebStorageSizeManager {
    // Logging flags.
    private final static boolean LOGV_ENABLED = com.android.browser.Browser.LOGV_ENABLED;
    private final static boolean LOGD_ENABLED = com.android.browser.Browser.LOGD_ENABLED;
    private final static String LOGTAG = ""browser"";
    // The default quota value for an origin.
    public final static long ORIGIN_DEFAULT_QUOTA = 3 * 1024 * 1024;  // 3MB
    // The default value for quota increases.
    public final static long QUOTA_INCREASE_STEP = 1 * 1024 * 1024;  // 1MB
    // Extra padding space for appcache maximum size increases. This is needed
    // because WebKit sends us an estimate of the amount of space needed
    // but this estimate may, currently, be slightly less than what is actually
    // needed. We therefore add some 'padding'.
    // TODO(andreip): fix this in WebKit.
    public final static long APPCACHE_MAXSIZE_PADDING = 512 * 1024; // 512KB
    // The system status bar notification id.
    private final static int OUT_OF_SPACE_ID = 1;
    // The time of the last out of space notification
    private static long mLastOutOfSpaceNotificationTime = -1;
    // Delay between two notification in ms
    private final static long NOTIFICATION_INTERVAL = 5 * 60 * 1000;
    // Delay in ms used when resetting the notification time
    private final static long RESET_NOTIFICATION_INTERVAL = 3 * 1000;
    // The application context.
    private final Context mContext;
    // The global Web storage limit.
    private final long mGlobalLimit;
    // The maximum size of the application cache file.
    private long mAppCacheMaxSize;

    /**
     * Interface used by the WebStorageSizeManager to obtain information
     * about the underlying file system. This functionality is separated
     * into its own interface mainly for testing purposes.
     */
    public interface DiskInfo {
        /**
         * @return the size of the free space in the file system.
         */
        public long getFreeSpaceSizeBytes();

        /**
         * @return the total size of the file system.
         */
        public long getTotalSizeBytes();
    };

    private DiskInfo mDiskInfo;
    // For convenience, we provide a DiskInfo implementation that uses StatFs.
    public static class StatFsDiskInfo implements DiskInfo {
        private StatFs mFs;

        public StatFsDiskInfo(String path) {
            mFs = new StatFs(path);
        }

        public long getFreeSpaceSizeBytes() {
            return mFs.getAvailableBlocks() * mFs.getBlockSize();
        }

        public long getTotalSizeBytes() {
            return mFs.getBlockCount() * mFs.getBlockSize();
        }
    };

    /**
     * Interface used by the WebStorageSizeManager to obtain information
     * about the appcache file. This functionality is separated into its own
     * interface mainly for testing purposes.
     */
    public interface AppCacheInfo {
        /**
         * @return the current size of the appcache file.
         */
        public long getAppCacheSizeBytes();
    };

    // For convenience, we provide an AppCacheInfo implementation.
    public static class WebKitAppCacheInfo implements AppCacheInfo {
        // The name of the application cache file. Keep in sync with
        // WebCore/loader/appcache/ApplicationCacheStorage.cpp
        private final static String APPCACHE_FILE = ""ApplicationCache.db"";
        private String mAppCachePath;

        public WebKitAppCacheInfo(String path) {
            mAppCachePath = path;
        }

        public long getAppCacheSizeBytes() {
            File file = new File(mAppCachePath
                    + File.separator
                    + APPCACHE_FILE);
            return file.length();
        }
    };

    /**
     * Public ctor
     * @param ctx is the application context
     * @param diskInfo is the DiskInfo instance used to query the file system.
     * @param appCacheInfo is the AppCacheInfo used to query info about the
     * appcache file.
     */
    public WebStorageSizeManager(Context ctx, DiskInfo diskInfo,
            AppCacheInfo appCacheInfo) {
        mContext = ctx;
        mDiskInfo = diskInfo;
        mGlobalLimit = getGlobalLimit();
        // The initial max size of the app cache is either 25% of the global
        // limit or the current size of the app cache file, whichever is bigger.
        mAppCacheMaxSize = Math.max(mGlobalLimit / 4,
                appCacheInfo.getAppCacheSizeBytes());
    }

    /**
     * Returns the maximum size of the application cache.
     */
    public long getAppCacheMaxSize() {
        return mAppCacheMaxSize;
    }

    /**
     * The origin has exceeded its database quota.
     * @param url the URL that exceeded the quota
     * @param databaseIdentifier the identifier of the database on
     *     which the transaction that caused the quota overflow was run
     * @param currentQuota the current quota for the origin.
     * @param estimatedSize the estimated size of a new database, or 0 if
     *     this has been invoked in response to an existing database
     *     overflowing its quota.
     * @param totalUsedQuota is the sum of all origins' quota.
     * @param quotaUpdater The callback to run when a decision to allow or
     *     deny quota has been made. Don't forget to call this!
     */
    public void onExceededDatabaseQuota(String url,
        String databaseIdentifier, long currentQuota, long estimatedSize,
        long totalUsedQuota, WebStorage.QuotaUpdater quotaUpdater) {
        if(LOGV_ENABLED) {
            Log.v(LOGTAG,
                  ""Received onExceededDatabaseQuota for ""
                  + url
                  + "":""
                  + databaseIdentifier
                  + ""(current quota: ""
                  + currentQuota
                  + "", total used quota: ""
                  + totalUsedQuota
                  + "")"");
        }
        long totalUnusedQuota = mGlobalLimit - totalUsedQuota - mAppCacheMaxSize;

        if (totalUnusedQuota <= 0) {
            // There definitely isn't any more space. Fire notifications
            // if needed and exit.
            if (totalUsedQuota > 0) {
                // We only fire the notification if there are some other websites
                // using some of the quota. This avoids the degenerate case where
                // the first ever website to use Web storage tries to use more
                // data than it is actually available. In such a case, showing
                // the notification would not help at all since there is nothing
                // the user can do.
                scheduleOutOfSpaceNotification();
            }
            quotaUpdater.updateQuota(currentQuota);
            if(LOGV_ENABLED) {
                Log.v(LOGTAG, ""onExceededDatabaseQuota: out of space."");
            }
            return;
        }

        // We have some space inside mGlobalLimit.
        long newOriginQuota = currentQuota;
        if (newOriginQuota == 0) {
            // This is a new origin, give it the size it asked for if possible.
            // If we cannot satisfy the estimatedSize, we should return 0 as
            // returning a value less that what the site requested will lead
            // to webcore not creating the database.
            if (totalUnusedQuota >= estimatedSize) {
                newOriginQuota = estimatedSize;
            } else {
                if (LOGV_ENABLED) {
                    Log.v(LOGTAG,
                            ""onExceededDatabaseQuota: Unable to satisfy"" +
                            "" estimatedSize for the new database "" +
                            "" (estimatedSize: "" + estimatedSize +
                            "", unused quota: "" + totalUnusedQuota);
                }
                newOriginQuota = 0;
            }
        } else {
            // This is an origin we have seen before. It wants a quota
            // increase. There are two circumstances: either the origin
            // is creating a new database or it has overflowed an existing database.

            // Increase the quota. If estimatedSize == 0, then this is a quota overflow
            // rather than the creation of a new database.
            long quotaIncrease = estimatedSize == 0 ?
                    Math.min(QUOTA_INCREASE_STEP, totalUnusedQuota) :
                    estimatedSize;
            newOriginQuota += quotaIncrease;

            if (quotaIncrease > totalUnusedQuota) {
                // We can't fit, so deny quota.
                newOriginQuota = currentQuota;
            }
        }

        quotaUpdater.updateQuota(newOriginQuota);

        if(LOGV_ENABLED) {
            Log.v(LOGTAG, ""onExceededDatabaseQuota set new quota to ""
                    + newOriginQuota);
        }
    }

    /**
     * The Application Cache has exceeded its max size.
     * @param spaceNeeded is the amount of disk space that would be needed
     * in order for the last appcache operation to succeed.
     * @param totalUsedQuota is the sum of all origins' quota.
     * @param quotaUpdater A callback to inform the WebCore thread that a new
     * app cache size is available. This callback must always be executed at
     * some point to ensure that the sleeping WebCore thread is woken up.
     */
    public void onReachedMaxAppCacheSize(long spaceNeeded, long totalUsedQuota,
            WebStorage.QuotaUpdater quotaUpdater) {
        if(LOGV_ENABLED) {
            Log.v(LOGTAG, ""Received onReachedMaxAppCacheSize with spaceNeeded ""
                  + spaceNeeded + "" bytes."");
        }

        long totalUnusedQuota = mGlobalLimit - totalUsedQuota - mAppCacheMaxSize;

        if (totalUnusedQuota < spaceNeeded + APPCACHE_MAXSIZE_PADDING) {
            // There definitely isn't any more space. Fire notifications
            // if needed and exit.
            if (totalUsedQuota > 0) {
                // We only fire the notification if there are some other websites
                // using some of the quota. This avoids the degenerate case where
                // the first ever website to use Web storage tries to use more
                // data than it is actually available. In such a case, showing
                // the notification would not help at all since there is nothing
                // the user can do.
                scheduleOutOfSpaceNotification();
            }
            quotaUpdater.updateQuota(0);
            if(LOGV_ENABLED) {
                Log.v(LOGTAG, ""onReachedMaxAppCacheSize: out of space."");
            }
            return;
        }
        // There is enough space to accommodate spaceNeeded bytes.
        mAppCacheMaxSize += spaceNeeded + APPCACHE_MAXSIZE_PADDING;
        quotaUpdater.updateQuota(mAppCacheMaxSize);

        if(LOGV_ENABLED) {
            Log.v(LOGTAG, ""onReachedMaxAppCacheSize set new max size to ""
                    + mAppCacheMaxSize);
        }
    }

    // Reset the notification time; we use this iff the user
    // use clear all; we reset it to some time in the future instead
    // of just setting it to -1, as the clear all method is asynchronous
    static void resetLastOutOfSpaceNotificationTime() {
        mLastOutOfSpaceNotificationTime = System.currentTimeMillis() -
            NOTIFICATION_INTERVAL + RESET_NOTIFICATION_INTERVAL;
    }

    // Computes the global limit as a function of the size of the data
    // partition and the amount of free space on that partition.
    private long getGlobalLimit() {
        long freeSpace = mDiskInfo.getFreeSpaceSizeBytes();
        long fileSystemSize = mDiskInfo.getTotalSizeBytes();
        return calculateGlobalLimit(fileSystemSize, freeSpace);
    }

    /*package*/ static long calculateGlobalLimit(long fileSystemSizeBytes,
            long freeSpaceBytes) {
        if (fileSystemSizeBytes <= 0
                || freeSpaceBytes <= 0
                || freeSpaceBytes > fileSystemSizeBytes) {
            return 0;
        }

        long fileSystemSizeRatio =
            2 << ((int) Math.floor(Math.log10(
                    fileSystemSizeBytes / (1024 * 1024))));
        long maxSizeBytes = (long) Math.min(Math.floor(
                fileSystemSizeBytes / fileSystemSizeRatio),
                Math.floor(freeSpaceBytes / 2));
        // Round maxSizeBytes up to a multiple of 1024KB (but only if
        // maxSizeBytes > 1MB).
        long maxSizeStepBytes = 1024 * 1024;
        if (maxSizeBytes < maxSizeStepBytes) {
            return 0;
        }
        long roundingExtra = maxSizeBytes % maxSizeStepBytes == 0 ? 0 : 1;
        return (maxSizeStepBytes
                * ((maxSizeBytes / maxSizeStepBytes) + roundingExtra));
    }

    // Schedules a system notification that takes the user to the WebSettings
    // activity when clicked.
    private void scheduleOutOfSpaceNotification() {
        if(LOGV_ENABLED) {
            Log.v(LOGTAG, ""scheduleOutOfSpaceNotification called."");
        }
        if (mContext == null) {
            // mContext can be null if we're running unit tests.
            return;
        }
        if ((mLastOutOfSpaceNotificationTime == -1) ||
            (System.currentTimeMillis() - mLastOutOfSpaceNotificationTime > NOTIFICATION_INTERVAL)) {
            // setup the notification boilerplate.
            int icon = android.R.drawable.stat_sys_warning;
            CharSequence title = mContext.getString(
                    R.string.webstorage_outofspace_notification_title);
            CharSequence text = mContext.getString(
                    R.string.webstorage_outofspace_notification_text);
            long when = System.currentTimeMillis();
            Intent intent = new Intent(mContext, WebsiteSettingsActivity.class);
            PendingIntent contentIntent =
                PendingIntent.getActivity(mContext, 0, intent, 0);
            Notification notification = new Notification(icon, title, when);
            notification.setLatestEventInfo(mContext, title, text, contentIntent);
            notification.flags |= Notification.FLAG_AUTO_CANCEL;
            // Fire away.
            String ns = Context.NOTIFICATION_SERVICE;
            NotificationManager mgr =
                (NotificationManager) mContext.getSystemService(ns);
            if (mgr != null) {
                mLastOutOfSpaceNotificationTime = System.currentTimeMillis();
                mgr.notify(OUT_OF_SPACE_ID, notification);
            }
        }
    }
}
",False,35,1,2,5,19,4,1,L1
2,com.android.browser.BrowserHomepagePreference.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.app.AlertDialog;
import android.content.Context;
import android.os.Bundle;
import android.preference.EditTextPreference;
import android.widget.Button;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.util.AttributeSet;

public class BrowserHomepagePreference extends EditTextPreference {
    private String mCurrentPage;

    public BrowserHomepagePreference(Context context, AttributeSet attrs,
            int defStyle) {
        super(context, attrs, defStyle);
    }

    public BrowserHomepagePreference(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public BrowserHomepagePreference(Context context) {
        super(context);
    }

    @Override
    protected void onAddEditTextToDialogView(View dialogView,
            EditText editText) {
        super.onAddEditTextToDialogView(dialogView, editText);
        // Now the EditText has a parent.  Add a button to set to the current
        // page.
        ViewGroup parent = (ViewGroup) editText.getParent();
        Button button = new Button(getContext());
        button.setText(R.string.pref_use_current);
        button.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                getEditText().setText(mCurrentPage);
            }
        });
        if (parent instanceof LinearLayout) {
            ((LinearLayout) parent).setGravity(Gravity.CENTER_HORIZONTAL);
        }
        parent.addView(button, ViewGroup.LayoutParams.WRAP_CONTENT,
                ViewGroup.LayoutParams.WRAP_CONTENT);
    }

    @Override
    protected void onDialogClosed(boolean positiveResult) {
        if (positiveResult) {
            String url = getEditText().getText().toString();
            if (url.length() > 0
                    && !BrowserActivity.ACCEPTED_URI_SCHEMA.matcher(url)
                            .matches()) {
                int colon = url.indexOf(':');
                int space = url.indexOf(' ');
                if (colon == -1 && space == -1) {
                    // if no colon, no space, add ""http://"" to make it a url
                    getEditText().setText(""http://"" + url);
                } else {
                    // show an error dialog and change the positiveResult to
                    // false so that the bad url will not override the old url
                    new AlertDialog.Builder(this.getContext()).setMessage(
                            R.string.bookmark_url_not_valid).setPositiveButton(
                            R.string.ok, null).show();
                    positiveResult = false;
                }
            }
        }
        super.onDialogClosed(positiveResult);
    }

    /**
     * Set the current page of the browser.
     * @param currentPage This String will replace the text in the EditText
     *          when the user clicks the ""Use current page"" button.
     */
    /* package */ void setCurrentPage(String currentPage) {
        mCurrentPage = currentPage;
    }

    @Override
    protected void showDialog(Bundle state) {
        super.showDialog(state);
        // The dialog has its width set to wrap_content.  Change it to
        // match_parent so there is more room to type in a url.
        Window window = getDialog().getWindow();
        View decorView = window.getDecorView();
        WindowManager.LayoutParams params
                = (WindowManager.LayoutParams) decorView.getLayoutParams();
        params.width = ViewGroup.LayoutParams.MATCH_PARENT;
        window.getWindowManager().updateViewLayout(decorView, params);
    }
}
",False,33,0,0,4,19,1,1,L1
3,com.android.browser.Dots.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.Context;
import android.util.AttributeSet;
import android.view.Gravity;
import android.widget.ImageView;
import android.widget.LinearLayout;

import java.util.Map;

/**
 * Displays a series of dots.  The selected one is highlighted.
 * No animations yet.  Nothing fancy.
 */
class Dots extends LinearLayout {

    private static final int MAX_DOTS = 8;
    private int mSelected = -1;

    public Dots(Context context) {
        this(context, null);
    }

    public Dots(Context context, AttributeSet attrs) {
        super(context, attrs);

        setGravity(Gravity.CENTER);
        setPadding(0, 4, 0, 4);

        LayoutParams lp =
                new LayoutParams(LayoutParams.WRAP_CONTENT,
                                 LayoutParams.WRAP_CONTENT);

        for (int i = 0; i < MAX_DOTS; i++) {
            ImageView dotView = new ImageView(mContext);
            dotView.setImageResource(R.drawable.page_indicator_unselected2);
            addView(dotView, lp);
        }
    }

    /**
     * @param dotCount if less than 1 or greater than MAX_DOTS, Dots
     * disappears
     */
    public void setDotCount(int dotCount) {
        if (dotCount > 1 && dotCount <= MAX_DOTS) {
            setVisibility(VISIBLE);
            for (int i = 0; i < MAX_DOTS; i++) {
                getChildAt(i).setVisibility(i < dotCount? VISIBLE : GONE);
            }
        } else {
            setVisibility(GONE);
        }
    }

    public void setSelected(int index) {
        if (index < 0 || index >= MAX_DOTS) return;

        if (mSelected >= 0) {
            // Unselect old
            ((ImageView)getChildAt(mSelected)).setImageResource(
                    R.drawable.page_indicator_unselected2);
        }
        ((ImageView)getChildAt(index)).setImageResource(R.drawable.page_indicator);
        mSelected = index;
    }
}
",False,1,0,0,0,0,0,0,I0
4,com.android.browser.BrowserHistoryPage.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.app.Activity;
import android.app.ExpandableListActivity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Bundle;
import android.os.ServiceManager;
import android.provider.Browser;
import android.text.IClipboard;
import android.util.Log;
import android.view.ContextMenu;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewGroup.LayoutParams;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.ViewStub;
import android.webkit.WebIconDatabase.IconListener;
import android.widget.ExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.ExpandableListContextMenuInfo;
import android.widget.Toast;

/**
 * Activity for displaying the browser's history, divided into
 * days of viewing.
 */
public class BrowserHistoryPage extends ExpandableListActivity {
    private HistoryAdapter          mAdapter;
    private boolean                 mDisableNewWindow;
    private HistoryItem             mContextHeader;

    private final static String LOGTAG = ""browser"";

    // Implementation of WebIconDatabase.IconListener
    private class IconReceiver implements IconListener {
        public void onReceivedIcon(String url, Bitmap icon) {
            setListAdapter(mAdapter);
        }
    }
    // Instance of IconReceiver
    private final IconReceiver mIconReceiver = new IconReceiver();

    /**
     * Report back to the calling activity to load a site.
     * @param url   Site to load.
     * @param newWindow True if the URL should be loaded in a new window
     */
    private void loadUrl(String url, boolean newWindow) {
        Intent intent = new Intent().setAction(url);
        if (newWindow) {
            Bundle b = new Bundle();
            b.putBoolean(""new_window"", true);
            intent.putExtras(b);
        }
        setResultToParent(RESULT_OK, intent);
        finish();
    }
    
    private void copy(CharSequence text) {
        try {
            IClipboard clip = IClipboard.Stub.asInterface(ServiceManager.getService(""clipboard""));
            if (clip != null) {
                clip.setClipboardText(text);
            }
        } catch (android.os.RemoteException e) {
            Log.e(LOGTAG, ""Copy failed"", e);
        }
    }

    @Override
    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        setTitle(R.string.browser_history);

        final String whereClause = Browser.BookmarkColumns.VISITS + "" > 0""
                // In AddBookmarkPage, where we save new bookmarks, we add
                // three visits to newly created bookmarks, so that
                // bookmarks that have not been visited will show up in the
                // most visited, and higher in the goto search box.
                // However, this puts the site in the history, unless we
                // ignore sites with a DATE of 0, which the next line does.
                + "" AND "" + Browser.BookmarkColumns.DATE + "" > 0"";
        final String orderBy = Browser.BookmarkColumns.DATE + "" DESC"";

        Cursor cursor = managedQuery(
                Browser.BOOKMARKS_URI,
                Browser.HISTORY_PROJECTION,
                whereClause, null, orderBy);

        mAdapter = new HistoryAdapter(this, cursor,
                Browser.HISTORY_PROJECTION_DATE_INDEX);
        setListAdapter(mAdapter);
        final ExpandableListView list = getExpandableListView();
        list.setOnCreateContextMenuListener(this);
        View v = new ViewStub(this, R.layout.empty_history);
        addContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT,
                LayoutParams.MATCH_PARENT));
        list.setEmptyView(v);
        // Do not post the runnable if there is nothing in the list.
        if (list.getExpandableListAdapter().getGroupCount() > 0) {
            list.post(new Runnable() {
                public void run() {
                    // In case the history gets cleared before this event
                    // happens.
                    if (list.getExpandableListAdapter().getGroupCount() > 0) {
                        list.expandGroup(0);
                    }
                }
            });
        }
        mDisableNewWindow = getIntent().getBooleanExtra(""disable_new_window"",
                false);

        // Register to receive icons in case they haven't all been loaded.
        CombinedBookmarkHistoryActivity.getIconListenerSet()
                .addListener(mIconReceiver);

        Activity parent = getParent();
        if (null == parent
                || !(parent instanceof CombinedBookmarkHistoryActivity)) {
            throw new AssertionError(""history page can only be viewed as a tab""
                    + ""in CombinedBookmarkHistoryActivity"");
        }
        // initialize the result to canceled, so that if the user just presses
        // back then it will have the correct result
        setResultToParent(RESULT_CANCELED, null);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        CombinedBookmarkHistoryActivity.getIconListenerSet()
                .removeListener(mIconReceiver);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.history, menu);
        return true;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        menu.findItem(R.id.clear_history_menu_id).setVisible(Browser.canClearHistory(this.getContentResolver()));
        return true;
    }
    
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.clear_history_menu_id:
                Browser.clearHistory(getContentResolver());
                // BrowserHistoryPage is always a child of
                // CombinedBookmarkHistoryActivity
                ((CombinedBookmarkHistoryActivity) getParent())
                        .removeParentChildRelationShips();
                mAdapter.refreshData();
                return true;
                
            default:
                break;
        }  
        return super.onOptionsItemSelected(item);
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
            ContextMenuInfo menuInfo) {
        ExpandableListContextMenuInfo i = 
            (ExpandableListContextMenuInfo) menuInfo;
        // Do not allow a context menu to come up from the group views.
        if (!(i.targetView instanceof HistoryItem)) {
            return;
        }

        // Inflate the menu
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.historycontext, menu);

        HistoryItem historyItem = (HistoryItem) i.targetView;

        // Setup the header
        if (mContextHeader == null) {
            mContextHeader = new HistoryItem(this);
        } else if (mContextHeader.getParent() != null) {
            ((ViewGroup) mContextHeader.getParent()).removeView(mContextHeader);
        }
        historyItem.copyTo(mContextHeader);
        menu.setHeaderView(mContextHeader);

        // Only show open in new tab if it was not explicitly disabled
        if (mDisableNewWindow) {
            menu.findItem(R.id.new_window_context_menu_id).setVisible(false);
        }
        // For a bookmark, provide the option to remove it from bookmarks
        if (historyItem.isBookmark()) {
            MenuItem item = menu.findItem(R.id.save_to_bookmarks_menu_id);
            item.setTitle(R.string.remove_from_bookmarks);
        }
        // decide whether to show the share link option
        PackageManager pm = getPackageManager();
        Intent send = new Intent(Intent.ACTION_SEND);
        send.setType(""text/plain"");
        ResolveInfo ri = pm.resolveActivity(send, PackageManager.MATCH_DEFAULT_ONLY);
        menu.findItem(R.id.share_link_context_menu_id).setVisible(ri != null);
        
        super.onCreateContextMenu(menu, v, menuInfo);
    }
    
    @Override
    public boolean onContextItemSelected(MenuItem item) {
        ExpandableListContextMenuInfo i = 
            (ExpandableListContextMenuInfo) item.getMenuInfo();
        HistoryItem historyItem = (HistoryItem) i.targetView;
        String url = historyItem.getUrl();
        String title = historyItem.getName();
        switch (item.getItemId()) {
            case R.id.open_context_menu_id:
                loadUrl(url, false);
                return true;
            case R.id.new_window_context_menu_id:
                loadUrl(url, true);
                return true;
            case R.id.save_to_bookmarks_menu_id:
                if (historyItem.isBookmark()) {
                    Bookmarks.removeFromBookmarks(this, getContentResolver(),
                            url, title);
                } else {
                    Browser.saveBookmark(this, title, url);
                }
                return true;
            case R.id.share_link_context_menu_id:
                Browser.sendString(this, url,
                        getText(R.string.choosertitle_sharevia).toString());
                return true;
            case R.id.copy_url_context_menu_id:
                copy(url);
                return true;
            case R.id.delete_context_menu_id:
                Browser.deleteFromHistory(getContentResolver(), url);
                mAdapter.refreshData();
                return true;
            case R.id.homepage_context_menu_id:
                BrowserSettings.getInstance().setHomePage(this, url);
                Toast.makeText(this, R.string.homepage_set,
                    Toast.LENGTH_LONG).show();
                return true;
            default:
                break;
        }
        return super.onContextItemSelected(item);
    }
    
    @Override
    public boolean onChildClick(ExpandableListView parent, View v,
            int groupPosition, int childPosition, long id) {
        if (v instanceof HistoryItem) {
            loadUrl(((HistoryItem) v).getUrl(), false);
            return true;
        }
        return false;
    }

    // This Activity is always a sub-Activity of
    // CombinedBookmarkHistoryActivity. Therefore, we need to pass our
    // result code up to our parent.
    private void setResultToParent(int resultCode, Intent data) {
        ((CombinedBookmarkHistoryActivity) getParent()).setResultFromChild(
                resultCode, data);
    }

    private class HistoryAdapter extends DateSortedExpandableListAdapter {
        HistoryAdapter(Context context, Cursor cursor, int index) {
            super(context, cursor, index);
            
        }

        public View getChildView(int groupPosition, int childPosition, boolean isLastChild,
                View convertView, ViewGroup parent) {
            HistoryItem item;
            if (null == convertView || !(convertView instanceof HistoryItem)) {
                item = new HistoryItem(BrowserHistoryPage.this);
                // Add padding on the left so it will be indented from the
                // arrows on the group views.
                item.setPadding(item.getPaddingLeft() + 10,
                        item.getPaddingTop(),
                        item.getPaddingRight(),
                        item.getPaddingBottom());
            } else {
                item = (HistoryItem) convertView;
            }
            // Bail early if the Cursor is closed.
            if (!moveCursorToChildPosition(groupPosition, childPosition)) {
                return item;
            }
            item.setName(getString(Browser.HISTORY_PROJECTION_TITLE_INDEX));
            String url = getString(Browser.HISTORY_PROJECTION_URL_INDEX);
            item.setUrl(url);
            byte[] data = getBlob(Browser.HISTORY_PROJECTION_FAVICON_INDEX);
            if (data != null) {
                item.setFavicon(BitmapFactory.decodeByteArray(data, 0,
                        data.length));
            } else {
                item.setFavicon(CombinedBookmarkHistoryActivity
                        .getIconListenerSet().getFavicon(url));
            }
            item.setIsBookmark(1 ==
                    getInt(Browser.HISTORY_PROJECTION_BOOKMARK_INDEX));
            return item;
        }
    }
}
",False,35,0,0,4,17,0,6,L2
5,com.android.browser.BrowserBookmarksPage.java,"/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffXfermode;
import android.graphics.Rect;
import android.graphics.RectF;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.ServiceManager;
import android.provider.Browser;
import android.text.IClipboard;
import android.util.Log;
import android.view.ContextMenu;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.ContextMenu.ContextMenuInfo;
import android.webkit.WebIconDatabase.IconListener;
import android.widget.AdapterView;
import android.widget.GridView;
import android.widget.ListView;
import android.widget.Toast;

/*package*/ enum BookmarkViewMode { NONE, GRID, LIST }
/**
 *  View showing the user's bookmarks in the browser.
 */
public class BrowserBookmarksPage extends Activity implements
        View.OnCreateContextMenuListener {

    private BookmarkViewMode        mViewMode = BookmarkViewMode.NONE;
    private GridView                mGridPage;
    private ListView                mVerticalList;
    private BrowserBookmarksAdapter mBookmarksAdapter;
    private static final int        BOOKMARKS_SAVE = 1;
    private boolean                 mDisableNewWindow;
    private BookmarkItem            mContextHeader;
    private AddNewBookmark          mAddHeader;
    private boolean                 mCanceled = false;
    private boolean                 mCreateShortcut;
    private boolean                 mMostVisited;
    private View                    mEmptyView;
    private int                     mIconSize;
    // XXX: There is no public string defining this intent so if Home changes
    // the value, we have to update this string.
    private static final String     INSTALL_SHORTCUT =
            ""com.android.launcher.action.INSTALL_SHORTCUT"";

    private final static String LOGTAG = ""browser"";
    private final static String PREF_BOOKMARK_VIEW_MODE = ""pref_bookmark_view_mode"";
    private final static String PREF_MOST_VISITED_VIEW_MODE = ""pref_most_visited_view_mode"";

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        // It is possible that the view has been canceled when we get to
        // this point as back has a higher priority
        if (mCanceled) {
            return true;
        }
        AdapterView.AdapterContextMenuInfo i =
            (AdapterView.AdapterContextMenuInfo)item.getMenuInfo();
        // If we have no menu info, we can't tell which item was selected.
        if (i == null) {
            return true;
        }

        switch (item.getItemId()) {
        case R.id.new_context_menu_id:
            saveCurrentPage();
            break;
        case R.id.open_context_menu_id:
            loadUrl(i.position);
            break;
        case R.id.edit_context_menu_id:
            editBookmark(i.position);
            break;
        case R.id.shortcut_context_menu_id:
            final Intent send = createShortcutIntent(i.position);
            send.setAction(INSTALL_SHORTCUT);
            sendBroadcast(send);
            break;
        case R.id.delete_context_menu_id:
            if (mMostVisited) {
                Browser.deleteFromHistory(getContentResolver(),
                        getUrl(i.position));
                refreshList();
            } else {
                displayRemoveBookmarkDialog(i.position);
            }
            break;
        case R.id.new_window_context_menu_id:
            openInNewWindow(i.position);
            break;
        case R.id.share_link_context_menu_id:
            BrowserActivity.sharePage(BrowserBookmarksPage.this,
                    mBookmarksAdapter.getTitle(i.position), getUrl(i.position),
                    getFavicon(i.position),
                    mBookmarksAdapter.getScreenshot(i.position));
            break;
        case R.id.copy_url_context_menu_id:
            copy(getUrl(i.position));
            break;
        case R.id.homepage_context_menu_id:
            BrowserSettings.getInstance().setHomePage(this,
                    getUrl(i.position));
            Toast.makeText(this, R.string.homepage_set,
                    Toast.LENGTH_LONG).show();
            break;
        // Only for the Most visited page
        case R.id.save_to_bookmarks_menu_id:
            boolean isBookmark;
            String name;
            String url;
            if (mViewMode == BookmarkViewMode.GRID) {
                isBookmark = mBookmarksAdapter.getIsBookmark(i.position);
                name = mBookmarksAdapter.getTitle(i.position);
                url = mBookmarksAdapter.getUrl(i.position);
            } else {
                HistoryItem historyItem = ((HistoryItem) i.targetView);
                isBookmark = historyItem.isBookmark();
                name = historyItem.getName();
                url = historyItem.getUrl();
            }
            // If the site is bookmarked, the item becomes remove from
            // bookmarks.
            if (isBookmark) {
                Bookmarks.removeFromBookmarks(this, getContentResolver(), url, name);
            } else {
                Browser.saveBookmark(this, name, url);
            }
            break;
        default:
            return super.onContextItemSelected(item);
        }
        return true;
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
                ContextMenuInfo menuInfo) {
            AdapterView.AdapterContextMenuInfo i =
                    (AdapterView.AdapterContextMenuInfo) menuInfo;

            MenuInflater inflater = getMenuInflater();
            if (mMostVisited) {
                inflater.inflate(R.menu.historycontext, menu);
            } else {
                inflater.inflate(R.menu.bookmarkscontext, menu);
            }

            if (0 == i.position && !mMostVisited) {
                menu.setGroupVisible(R.id.CONTEXT_MENU, false);
                if (mAddHeader == null) {
                    mAddHeader = new AddNewBookmark(BrowserBookmarksPage.this);
                } else if (mAddHeader.getParent() != null) {
                    ((ViewGroup) mAddHeader.getParent()).
                            removeView(mAddHeader);
                }
                mAddHeader.setUrl(getIntent().getStringExtra(""url""));
                menu.setHeaderView(mAddHeader);
                return;
            }
            if (mMostVisited) {
                if ((mViewMode == BookmarkViewMode.LIST
                        && ((HistoryItem) i.targetView).isBookmark())
                        || mBookmarksAdapter.getIsBookmark(i.position)) {
                    MenuItem item = menu.findItem(
                            R.id.save_to_bookmarks_menu_id);
                    item.setTitle(R.string.remove_from_bookmarks);
                }
            } else {
                // The historycontext menu has no ADD_MENU group.
                menu.setGroupVisible(R.id.ADD_MENU, false);
            }
            if (mDisableNewWindow) {
                menu.findItem(R.id.new_window_context_menu_id).setVisible(
                        false);
            }
            if (mContextHeader == null) {
                mContextHeader = new BookmarkItem(BrowserBookmarksPage.this);
            } else if (mContextHeader.getParent() != null) {
                ((ViewGroup) mContextHeader.getParent()).
                        removeView(mContextHeader);
            }
            if (mViewMode == BookmarkViewMode.GRID) {
                mBookmarksAdapter.populateBookmarkItem(mContextHeader,
                        i.position);
            } else {
                BookmarkItem b = (BookmarkItem) i.targetView;
                b.copyTo(mContextHeader);
            }
            menu.setHeaderView(mContextHeader);
        }

    /**
     *  Create a new BrowserBookmarksPage.
     */
    @Override
    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);

        // Grab the app icon size as a resource.
        mIconSize = getResources().getDimensionPixelSize(
                android.R.dimen.app_icon_size);

        Intent intent = getIntent();
        if (Intent.ACTION_CREATE_SHORTCUT.equals(intent.getAction())) {
            mCreateShortcut = true;
        }
        mDisableNewWindow = intent.getBooleanExtra(""disable_new_window"",
                false);
        mMostVisited = intent.getBooleanExtra(""mostVisited"", false);

        if (mCreateShortcut) {
            setTitle(R.string.browser_bookmarks_page_bookmarks_text);
        }

        setContentView(R.layout.empty_history);
        mEmptyView = findViewById(R.id.empty_view);
        mEmptyView.setVisibility(View.GONE);

        SharedPreferences p = getPreferences(MODE_PRIVATE);

        // See if the user has set a preference for the view mode of their
        // bookmarks. Otherwise default to grid mode.
        BookmarkViewMode preference = BookmarkViewMode.NONE;
        if (mMostVisited) {
            // For the most visited page, only use list mode.
            preference = BookmarkViewMode.LIST;
        } else {
            preference = BookmarkViewMode.values()[p.getInt(
                    PREF_BOOKMARK_VIEW_MODE, BookmarkViewMode.GRID.ordinal())];
        }
        switchViewMode(preference);

        final boolean createShortcut = mCreateShortcut;
        final boolean mostVisited = mMostVisited;
        final String url = intent.getStringExtra(""url"");
        final String title = intent.getStringExtra(""title"");
        final Bitmap thumbnail =
                (Bitmap) intent.getParcelableExtra(""thumbnail"");
        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... unused) {
                BrowserBookmarksAdapter adapter = new BrowserBookmarksAdapter(
                        BrowserBookmarksPage.this,
                        url,
                        title,
                        thumbnail,
                        createShortcut,
                        mostVisited);
                mHandler.obtainMessage(ADAPTER_CREATED, adapter).sendToTarget();
                return null;
            }
        }.execute();
    }

    @Override
    protected void onDestroy() {
        mHandler.removeCallbacksAndMessages(null);
        super.onDestroy();
    }

    /**
     *  Set the ContentView to be either the grid of thumbnails or the vertical
     *  list.
     */
    private void switchViewMode(BookmarkViewMode viewMode) {
        if (mViewMode == viewMode) {
            return;
        }

        mViewMode = viewMode;

        // Update the preferences to make the new view mode sticky.
        Editor ed = getPreferences(MODE_PRIVATE).edit();
        if (mMostVisited) {
            ed.putInt(PREF_MOST_VISITED_VIEW_MODE, mViewMode.ordinal());
        } else {
            ed.putInt(PREF_BOOKMARK_VIEW_MODE, mViewMode.ordinal());
        }
        ed.apply();

        if (mBookmarksAdapter != null) {
            mBookmarksAdapter.switchViewMode(viewMode);
        }
        if (mViewMode == BookmarkViewMode.GRID) {
            if (mGridPage == null) {
                mGridPage = new GridView(this);
                if (mBookmarksAdapter != null) {
                    mGridPage.setAdapter(mBookmarksAdapter);
                }
                mGridPage.setOnItemClickListener(mListener);
                mGridPage.setNumColumns(GridView.AUTO_FIT);
                mGridPage.setColumnWidth(
                        BrowserActivity.getDesiredThumbnailWidth(this));
                mGridPage.setFocusable(true);
                mGridPage.setFocusableInTouchMode(true);
                mGridPage.setSelector(android.R.drawable.gallery_thumb);
                float density = getResources().getDisplayMetrics().density;
                mGridPage.setVerticalSpacing((int) (14 * density));
                mGridPage.setHorizontalSpacing((int) (8 * density));
                mGridPage.setStretchMode(GridView.STRETCH_SPACING);
                mGridPage.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);
                mGridPage.setDrawSelectorOnTop(true);
                if (mMostVisited) {
                    mGridPage.setEmptyView(mEmptyView);
                }
                if (!mCreateShortcut) {
                    mGridPage.setOnCreateContextMenuListener(this);
                }
            }
            addContentView(mGridPage, FULL_SCREEN_PARAMS);
            if (mVerticalList != null) {
                ViewGroup parent = (ViewGroup) mVerticalList.getParent();
                if (parent != null) {
                    parent.removeView(mVerticalList);
                }
            }
        } else {
            if (null == mVerticalList) {
                ListView listView = new ListView(this);
                if (mBookmarksAdapter != null) {
                    listView.setAdapter(mBookmarksAdapter);
                }
                listView.setDrawSelectorOnTop(false);
                listView.setVerticalScrollBarEnabled(true);
                listView.setOnItemClickListener(mListener);
                if (mMostVisited) {
                    listView.setEmptyView(mEmptyView);
                }
                if (!mCreateShortcut) {
                    listView.setOnCreateContextMenuListener(this);
                }
                mVerticalList = listView;
            }
            addContentView(mVerticalList, FULL_SCREEN_PARAMS);
            if (mGridPage != null) {
                ViewGroup parent = (ViewGroup) mGridPage.getParent();
                if (parent != null) {
                    parent.removeView(mGridPage);
                }
            }
        }
    }

    private static final ViewGroup.LayoutParams FULL_SCREEN_PARAMS
            = new ViewGroup.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT);

    private static final int SAVE_CURRENT_PAGE = 1000;
    private static final int ADAPTER_CREATED = 1001;
    private final Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case SAVE_CURRENT_PAGE:
                    saveCurrentPage();
                    break;
                case ADAPTER_CREATED:
                    mBookmarksAdapter = (BrowserBookmarksAdapter) msg.obj;
                    mBookmarksAdapter.switchViewMode(mViewMode);
                    if (mGridPage != null) {
                        mGridPage.setAdapter(mBookmarksAdapter);
                    }
                    if (mVerticalList != null) {
                        mVerticalList.setAdapter(mBookmarksAdapter);
                    }
                    // Add our own listener in case there are favicons that
                    // have yet to be loaded.
                    if (mMostVisited) {
                        IconListener listener = new IconListener() {
                            public void onReceivedIcon(String url,
                                    Bitmap icon) {
                                if (mGridPage != null) {
                                    mGridPage.setAdapter(mBookmarksAdapter);
                                }
                                if (mVerticalList != null) {
                                    mVerticalList.setAdapter(mBookmarksAdapter);
                                }
                            }
                        };
                        CombinedBookmarkHistoryActivity.getIconListenerSet()
                                .addListener(listener);
                    }
                    break;
            }
        }
    };

    private AdapterView.OnItemClickListener mListener = new AdapterView.OnItemClickListener() {
        public void onItemClick(AdapterView parent, View v, int position, long id) {
            // It is possible that the view has been canceled when we get to
            // this point as back has a higher priority
            if (mCanceled) {
                android.util.Log.e(LOGTAG, ""item clicked when dismissing"");
                return;
            }
            if (!mCreateShortcut) {
                if (0 == position && !mMostVisited) {
                    // XXX: Work-around for a framework issue.
                    mHandler.sendEmptyMessage(SAVE_CURRENT_PAGE);
                } else {
                    loadUrl(position);
                }
            } else {
                final Intent intent = createShortcutIntent(position);
                setResultToParent(RESULT_OK, intent);
                finish();
            }
        }
    };

    private Intent createShortcutIntent(int position) {
        String url = getUrl(position);
        String title = getBookmarkTitle(position);
        Bitmap touchIcon = getTouchIcon(position);

        final Intent i = new Intent();
        final Intent shortcutIntent = new Intent(Intent.ACTION_VIEW,
                Uri.parse(url));
        long urlHash = url.hashCode();
        long uniqueId = (urlHash << 32) | shortcutIntent.hashCode();
        shortcutIntent.putExtra(Browser.EXTRA_APPLICATION_ID,
                Long.toString(uniqueId));
        i.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
        i.putExtra(Intent.EXTRA_SHORTCUT_NAME, title);
        // Use the apple-touch-icon if available
        if (touchIcon != null) {
            // Make a copy so we can modify the pixels.  We can't use
            // createScaledBitmap or copy since they will preserve the config
            // and lose the ability to add alpha.
            Bitmap bm = Bitmap.createBitmap(mIconSize, mIconSize,
                    Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bm);
            Rect src = new Rect(0, 0, touchIcon.getWidth(),
                                touchIcon.getHeight());
            Rect dest = new Rect(0, 0, bm.getWidth(), bm.getHeight());

            // Paint used for scaling the bitmap and drawing the rounded rect.
            Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
            paint.setFilterBitmap(true);
            canvas.drawBitmap(touchIcon, src, dest, paint);

            // Construct a path from a round rect. This will allow drawing with
            // an inverse fill so we can punch a hole using the round rect.
            Path path = new Path();
            path.setFillType(Path.FillType.INVERSE_WINDING);
            RectF rect = new RectF(0, 0, bm.getWidth(), bm.getHeight());
            rect.inset(1, 1);
            path.addRoundRect(rect, 8f, 8f, Path.Direction.CW);

            // Reuse the paint and clear the outside of the rectangle.
            paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));
            canvas.drawPath(path, paint);

            i.putExtra(Intent.EXTRA_SHORTCUT_ICON, bm);
        } else {
            Bitmap favicon = getFavicon(position);
            if (favicon == null) {
                i.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE,
                        Intent.ShortcutIconResource.fromContext(
                                BrowserBookmarksPage.this,
                                R.drawable.ic_launcher_shortcut_browser_bookmark));
            } else {
                Bitmap icon = BitmapFactory.decodeResource(getResources(),
                        R.drawable.ic_launcher_shortcut_browser_bookmark_icon);

                // Make a copy of the regular icon so we can modify the pixels.
                Bitmap copy = icon.copy(Bitmap.Config.ARGB_8888, true);
                Canvas canvas = new Canvas(copy);

                // Make a Paint for the white background rectangle and for
                // filtering the favicon.
                Paint p = new Paint(Paint.ANTI_ALIAS_FLAG
                        | Paint.FILTER_BITMAP_FLAG);
                p.setStyle(Paint.Style.FILL_AND_STROKE);
                p.setColor(Color.WHITE);

                final float density =
                        getResources().getDisplayMetrics().density;
                // Create a rectangle that is slightly wider than the favicon
                final float iconSize = 16 * density; // 16x16 favicon
                final float padding = 2 * density; // white padding around icon
                final float rectSize = iconSize + 2 * padding;

                final Rect iconBounds =
                        new Rect(0, 0, icon.getWidth(), icon.getHeight());
                final float x = iconBounds.exactCenterX() - (rectSize / 2);
                // Note: Subtract 2 dip from the y position since the box is
                // slightly higher than center. Use padding since it is already
                // 2 * density.
                final float y = iconBounds.exactCenterY() - (rectSize / 2)
                        - padding;
                RectF r = new RectF(x, y, x + rectSize, y + rectSize);

                // Draw a white rounded rectangle behind the favicon
                canvas.drawRoundRect(r, 2, 2, p);

                // Draw the favicon in the same rectangle as the rounded
                // rectangle but inset by the padding
                // (results in a 16x16 favicon).
                r.inset(padding, padding);
                canvas.drawBitmap(favicon, null, r, p);
                i.putExtra(Intent.EXTRA_SHORTCUT_ICON, copy);
            }
        }
        // Do not allow duplicate items
        i.putExtra(""duplicate"", false);
        return i;
    }

    private void saveCurrentPage() {
        Intent i = new Intent(BrowserBookmarksPage.this,
                AddBookmarkPage.class);
        i.putExtras(getIntent());
        startActivityForResult(i, BOOKMARKS_SAVE);
    }

    private void loadUrl(int position) {
        Intent intent = (new Intent()).setAction(getUrl(position));
        setResultToParent(RESULT_OK, intent);
        finish();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        boolean result = super.onCreateOptionsMenu(menu);
        if (!mCreateShortcut && !mMostVisited) {
            MenuInflater inflater = getMenuInflater();
            inflater.inflate(R.menu.bookmarks, menu);
            return true;
        }
        return result;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        boolean result = super.onPrepareOptionsMenu(menu);
        if (mCreateShortcut || mMostVisited || mBookmarksAdapter == null
                || mBookmarksAdapter.getCount() == 0) {
            // No need to show the menu if there are no items.
            return result;
        }
        MenuItem switchItem = menu.findItem(R.id.switch_mode_menu_id);
        int titleResId;
        int iconResId;
        if (mViewMode == BookmarkViewMode.GRID) {
            titleResId = R.string.switch_to_list;
            iconResId = R.drawable.ic_menu_list;
        } else {
            titleResId = R.string.switch_to_thumbnails;
            iconResId = R.drawable.ic_menu_thumbnail;
        }
        switchItem.setTitle(titleResId);
        switchItem.setIcon(iconResId);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.new_context_menu_id:
            saveCurrentPage();
            break;

        case R.id.switch_mode_menu_id:
            if (mViewMode == BookmarkViewMode.GRID) {
                switchViewMode(BookmarkViewMode.LIST);
            } else {
                switchViewMode(BookmarkViewMode.GRID);
            }
            break;

        default:
            return super.onOptionsItemSelected(item);
        }
        return true;
    }

    private void openInNewWindow(int position) {
        Bundle b = new Bundle();
        b.putBoolean(""new_window"", true);
        setResultToParent(RESULT_OK,
                (new Intent()).setAction(getUrl(position)).putExtras(b));

        finish();
    }


    private void editBookmark(int position) {
        Intent intent = new Intent(BrowserBookmarksPage.this,
            AddBookmarkPage.class);
        intent.putExtra(""bookmark"", getRow(position));
        startActivityForResult(intent, BOOKMARKS_SAVE);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode,
                                    Intent data) {
        switch(requestCode) {
            case BOOKMARKS_SAVE:
                if (resultCode == RESULT_OK) {
                    Bundle extras;
                    if (data != null && (extras = data.getExtras()) != null) {
                        // If there are extras, then we need to save
                        // the edited bookmark. This is done in updateRow()
                        String title = extras.getString(""title"");
                        String url = extras.getString(""url"");
                        if (title != null && url != null) {
                            mBookmarksAdapter.updateRow(extras);
                        }
                    } else {
                        // extras == null then a new bookmark was added to
                        // the database.
                        refreshList();
                    }
                }
                break;
            default:
                break;
        }
    }

    private void displayRemoveBookmarkDialog(int position) {
        // Put up a dialog asking if the user really wants to
        // delete the bookmark
        final int deletePos = position;
        new AlertDialog.Builder(this)
                .setTitle(R.string.delete_bookmark)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setMessage(getText(R.string.delete_bookmark_warning).toString().replace(
                        ""%s"", getBookmarkTitle(deletePos)))
                .setPositiveButton(R.string.ok,
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int whichButton) {
                                deleteBookmark(deletePos);
                            }
                        })
                .setNegativeButton(R.string.cancel, null)
                .show();
    }

    /**
     *  Refresh the shown list after the database has changed.
     */
    private void refreshList() {
        if (mBookmarksAdapter == null) return;
        mBookmarksAdapter.refreshList();
    }

    /**
     *  Return a hashmap representing the currently highlighted row.
     */
    public Bundle getRow(int position) {
        return mBookmarksAdapter == null ? null
                : mBookmarksAdapter.getRow(position);
    }

    /**
     *  Return the url of the currently highlighted row.
     */
    public String getUrl(int position) {
        return mBookmarksAdapter == null ? null
                : mBookmarksAdapter.getUrl(position);
    }

    /**
     * Return the favicon of the currently highlighted row.
     */
    public Bitmap getFavicon(int position) {
        return mBookmarksAdapter == null ? null
                : mBookmarksAdapter.getFavicon(position);
    }

    private Bitmap getTouchIcon(int position) {
        return mBookmarksAdapter == null ? null
                : mBookmarksAdapter.getTouchIcon(position);
    }

    private void copy(CharSequence text) {
        try {
            IClipboard clip = IClipboard.Stub.asInterface(ServiceManager.getService(""clipboard""));
            if (clip != null) {
                clip.setClipboardText(text);
            }
        } catch (android.os.RemoteException e) {
            Log.e(LOGTAG, ""Copy failed"", e);
        }
    }

    public String getBookmarkTitle(int position) {
        return mBookmarksAdapter == null ? null
                : mBookmarksAdapter.getTitle(position);
    }

    /**
     *  Delete the currently highlighted row.
     */
    public void deleteBookmark(int position) {
        if (mBookmarksAdapter == null) return;
        mBookmarksAdapter.deleteRow(position);
    }

    @Override
    public void onBackPressed() {
        setResultToParent(RESULT_CANCELED, null);
        mCanceled = true;
        super.onBackPressed();
    }

    // This Activity is generally a sub-Activity of
    // CombinedBookmarkHistoryActivity. In that situation, we need to pass our
    // result code up to our parent. However, if someone calls this Activity
    // directly, then this has no parent, and it needs to set it on itself.
    private void setResultToParent(int resultCode, Intent data) {
        Activity parent = getParent();
        if (parent == null) {
            setResult(resultCode, data);
        } else {
            ((CombinedBookmarkHistoryActivity) parent).setResultFromChild(
                    resultCode, data);
        }
    }
}
",True,33,0,0,3,18,1,8,L1
6,com.android.browser.ActiveTabsPage.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.Context;
import android.graphics.Bitmap;
import android.os.Handler;
import android.util.AttributeSet;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.TextView;

public class ActiveTabsPage extends LinearLayout {
    private final BrowserActivity   mBrowserActivity;
    private final LayoutInflater    mFactory;
    private final TabControl        mControl;
    private final TabsListAdapter   mAdapter;
    private final ListView          mListView;

    public ActiveTabsPage(BrowserActivity context, TabControl control) {
        super(context);
        mBrowserActivity = context;
        mControl = control;
        mFactory = LayoutInflater.from(context);
        mFactory.inflate(R.layout.active_tabs, this);
        mListView = (ListView) findViewById(R.id.list);
        mAdapter = new TabsListAdapter();
        mListView.setAdapter(mAdapter);
        mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
                public void onItemClick(AdapterView<?> parent, View view,
                        int position, long id) {
                    if (mControl.canCreateNewTab()) {
                        position--;
                    }
                    boolean needToAttach = false;
                    if (position == -1) {
                        // Create a new tab
                        mBrowserActivity.openTabToHomePage();
                    } else {
                        // Open the corresponding tab
                        // If the tab is the current one, switchToTab will
                        // do nothing and return, so we need to make sure
                        // it gets attached back to its mContentView in
                        // removeActiveTabPage
                        needToAttach = !mBrowserActivity.switchToTab(position);
                    }
                    mBrowserActivity.removeActiveTabPage(needToAttach);
                }
        });
    }

    /**
     * Special class to hold the close drawable.  Its sole purpose is to allow
     * the parent to be pressed without being pressed itself.  This way the line
     * of a tab can be pressed, but the close button itself is not.
     */
    private static class CloseHolder extends ImageView {
        public CloseHolder(Context context, AttributeSet attrs) {
            super(context, attrs);
        }

        @Override
        public void setPressed(boolean pressed) {
            // If the parent is pressed, do not set to pressed.
            if (pressed && ((View) getParent()).isPressed()) {
                return;
            }
            super.setPressed(pressed);
        }
    }

    private class TabsListAdapter extends BaseAdapter {
        private boolean mNotified = true;
        private int mReturnedCount;
        private Handler mHandler = new Handler();

        public int getCount() {
            int count = mControl.getTabCount();
            if (mControl.canCreateNewTab()) {
                count++;
            }
            // XXX: This is a workaround to be more like a real adapter. Most
            // adapters call notifyDataSetChanged() whenever the internal data
            // has changed. Since TabControl is our internal data, we don't
            // know when that changes.
            //
            // Keep track of the last count we returned and whether we called
            // notifyDataSetChanged(). If we did not initiate a data set
            // change, and the count is different, send the notify and return
            // the old count.
            if (!mNotified && count != mReturnedCount) {
                notifyChange();
                return mReturnedCount;
            }
            mReturnedCount = count;
            mNotified = false;
            return count;
        }
        public Object getItem(int position) {
            return null;
        }
        public long getItemId(int position) {
            return position;
        }
        public int getViewTypeCount() {
            return 2;
        }
        public int getItemViewType(int position) {
            if (mControl.canCreateNewTab()) {
                position--;
            }
            // Do not recycle the ""add new tab"" item.
            return position == -1 ? IGNORE_ITEM_VIEW_TYPE : 1;
        }
        public View getView(int position, View convertView, ViewGroup parent) {
            final int tabCount = mControl.getTabCount();
            if (mControl.canCreateNewTab()) {
                position--;
            }

            if (convertView == null) {
                convertView = mFactory.inflate(position == -1 ?
                        R.layout.tab_view_add_tab : R.layout.tab_view, null);
            }

            if (position != -1) {
                TextView title =
                        (TextView) convertView.findViewById(R.id.title);
                TextView url = (TextView) convertView.findViewById(R.id.url);
                ImageView favicon =
                        (ImageView) convertView.findViewById(R.id.favicon);
                View close = convertView.findViewById(R.id.close);
                Tab tab = mControl.getTab(position);
                tab.populatePickerData();
                title.setText(tab.getTitle());
                url.setText(tab.getUrl());
                Bitmap icon = tab.getFavicon();
                if (icon != null) {
                    favicon.setImageBitmap(icon);
                } else {
                    favicon.setImageResource(R.drawable.app_web_browser_sm);
                }
                final int closePosition = position;
                close.setOnClickListener(new View.OnClickListener() {
                        public void onClick(View v) {
                            mBrowserActivity.closeTab(
                                    mControl.getTab(closePosition));
                            if (tabCount == 1) {
                                mBrowserActivity.openTabToHomePage();
                                mBrowserActivity.removeActiveTabPage(false);
                            } else {
                                mNotified = true;
                                notifyDataSetChanged();
                            }
                        }
                });
            }
            return convertView;
        }

        void notifyChange() {
            mHandler.post(new Runnable() {
                public void run() {
                    mNotified = true;
                    notifyDataSetChanged();
                }
            });
        }
    }
}
",False,33,0,0,4,20,1,3,L1
7,com.android.browser.WebsiteSettingsActivity.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.app.AlertDialog;
import android.app.ListActivity;
import android.content.Context;
import android.content.DialogInterface;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.os.Bundle;
import android.provider.Browser;
import android.util.Log;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.webkit.GeolocationPermissions;
import android.webkit.ValueCallback;
import android.webkit.WebIconDatabase;
import android.webkit.WebStorage;
import android.widget.ArrayAdapter;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ImageView;
import android.widget.TextView;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

/**
 * Manage the settings for an origin.
 * We use it to keep track of the 'HTML5' settings, i.e. database (webstorage)
 * and Geolocation.
 */
public class WebsiteSettingsActivity extends ListActivity {

    private String LOGTAG = ""WebsiteSettingsActivity"";
    private static String sMBStored = null;
    private SiteAdapter mAdapter = null;

    static class Site {
        private String mOrigin;
        private String mTitle;
        private Bitmap mIcon;
        private int mFeatures;

        // These constants provide the set of features that a site may support
        // They must be consecutive. To add a new feature, add a new FEATURE_XXX
        // variable with value equal to the current value of FEATURE_COUNT, then
        // increment FEATURE_COUNT.
        private final static int FEATURE_WEB_STORAGE = 0;
        private final static int FEATURE_GEOLOCATION = 1;
        // The number of features available.
        private final static int FEATURE_COUNT = 2;

        public Site(String origin) {
            mOrigin = origin;
            mTitle = null;
            mIcon = null;
            mFeatures = 0;
        }

        public void addFeature(int feature) {
            mFeatures |= (1 << feature);
        }

        public void removeFeature(int feature) {
            mFeatures &= ~(1 << feature);
        }

        public boolean hasFeature(int feature) {
            return (mFeatures & (1 << feature)) != 0;
        }

        /**
         * Gets the number of features supported by this site.
         */
        public int getFeatureCount() {
            int count = 0;
            for (int i = 0; i < FEATURE_COUNT; ++i) {
                count += hasFeature(i) ? 1 : 0;
            }
            return count;
        }

        /**
         * Gets the ID of the nth (zero-based) feature supported by this site.
         * The return value is a feature ID - one of the FEATURE_XXX values.
         * This is required to determine which feature is displayed at a given
         * position in the list of features for this site. This is used both
         * when populating the view and when responding to clicks on the list.
         */
        public int getFeatureByIndex(int n) {
            int j = -1;
            for (int i = 0; i < FEATURE_COUNT; ++i) {
                j += hasFeature(i) ? 1 : 0;
                if (j == n) {
                    return i;
                }
            }
            return -1;
        }

        public String getOrigin() {
            return mOrigin;
        }

        public void setTitle(String title) {
            mTitle = title;
        }

        public void setIcon(Bitmap icon) {
            mIcon = icon;
        }

        public Bitmap getIcon() {
            return mIcon;
        }

        public String getPrettyOrigin() {
            return mTitle == null ? null : hideHttp(mOrigin);
        }

        public String getPrettyTitle() {
            return mTitle == null ? hideHttp(mOrigin) : mTitle;
        }

        private String hideHttp(String str) {
            Uri uri = Uri.parse(str);
            return ""http"".equals(uri.getScheme()) ?  str.substring(7) : str;
        }
    }

    class SiteAdapter extends ArrayAdapter<Site>
            implements AdapterView.OnItemClickListener {
        private int mResource;
        private LayoutInflater mInflater;
        private Bitmap mDefaultIcon;
        private Bitmap mUsageEmptyIcon;
        private Bitmap mUsageLowIcon;
        private Bitmap mUsageHighIcon;
        private Bitmap mLocationAllowedIcon;
        private Bitmap mLocationDisallowedIcon;
        private Site mCurrentSite;

        public SiteAdapter(Context context, int rsc) {
            super(context, rsc);
            mResource = rsc;
            mInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            mDefaultIcon = BitmapFactory.decodeResource(getResources(),
                    R.drawable.app_web_browser_sm);
            mUsageEmptyIcon = BitmapFactory.decodeResource(getResources(),
                    R.drawable.ic_list_data_off);
            mUsageLowIcon = BitmapFactory.decodeResource(getResources(),
                    R.drawable.ic_list_data_small);
            mUsageHighIcon = BitmapFactory.decodeResource(getResources(),
                    R.drawable.ic_list_data_large);
            mLocationAllowedIcon = BitmapFactory.decodeResource(getResources(),
                    R.drawable.ic_list_gps_on);
            mLocationDisallowedIcon = BitmapFactory.decodeResource(getResources(),
                    R.drawable.ic_list_gps_denied);
            askForOrigins();
        }

        /**
         * Adds the specified feature to the site corresponding to supplied
         * origin in the map. Creates the site if it does not already exist.
         */
        private void addFeatureToSite(Map<String, Site> sites, String origin, int feature) {
            Site site = null;
            if (sites.containsKey(origin)) {
                site = (Site) sites.get(origin);
            } else {
                site = new Site(origin);
                sites.put(origin, site);
            }
            site.addFeature(feature);
        }

        public void askForOrigins() {
            // Get the list of origins we want to display.
            // All 'HTML 5 modules' (Database, Geolocation etc) form these
            // origin strings using WebCore::SecurityOrigin::toString(), so it's
            // safe to group origins here. Note that WebCore::SecurityOrigin
            // uses 0 (which is not printed) for the port if the port is the
            // default for the protocol. Eg http://www.google.com and
            // http://www.google.com:80 both record a port of 0 and hence
            // toString() == 'http://www.google.com' for both.

            WebStorage.getInstance().getOrigins(new ValueCallback<Map>() {
                public void onReceiveValue(Map origins) {
                    Map<String, Site> sites = new HashMap<String, Site>();
                    if (origins != null) {
                        Iterator<String> iter = origins.keySet().iterator();
                        while (iter.hasNext()) {
                            addFeatureToSite(sites, iter.next(), Site.FEATURE_WEB_STORAGE);
                        }
                    }
                    askForGeolocation(sites);
                }
            });
        }

        public void askForGeolocation(final Map<String, Site> sites) {
            GeolocationPermissions.getInstance().getOrigins(new ValueCallback<Set<String> >() {
                public void onReceiveValue(Set<String> origins) {
                    if (origins != null) {
                        Iterator<String> iter = origins.iterator();
                        while (iter.hasNext()) {
                            addFeatureToSite(sites, iter.next(), Site.FEATURE_GEOLOCATION);
                        }
                    }
                    populateIcons(sites);
                    populateOrigins(sites);
                }
            });
        }

        public void populateIcons(Map<String, Site> sites) {
            // Create a map from host to origin. This is used to add metadata
            // (title, icon) for this origin from the bookmarks DB.
            HashMap<String, Set<Site>> hosts = new HashMap<String, Set<Site>>();
            Set<Map.Entry<String, Site>> elements = sites.entrySet();
            Iterator<Map.Entry<String, Site>> originIter = elements.iterator();
            while (originIter.hasNext()) {
                Map.Entry<String, Site> entry = originIter.next();
                Site site = entry.getValue();
                String host = Uri.parse(entry.getKey()).getHost();
                Set<Site> hostSites = null;
                if (hosts.containsKey(host)) {
                    hostSites = (Set<Site>)hosts.get(host);
                } else {
                    hostSites = new HashSet<Site>();
                    hosts.put(host, hostSites);
                }
                hostSites.add(site);
            }

            // Check the bookmark DB. If we have data for a host used by any of
            // our origins, use it to set their title and favicon
            Cursor c = getContext().getContentResolver().query(Browser.BOOKMARKS_URI,
                    new String[] { Browser.BookmarkColumns.URL, Browser.BookmarkColumns.TITLE,
                    Browser.BookmarkColumns.FAVICON }, ""bookmark = 1"", null, null);

            if (c != null) {
                if (c.moveToFirst()) {
                    int urlIndex = c.getColumnIndex(Browser.BookmarkColumns.URL);
                    int titleIndex = c.getColumnIndex(Browser.BookmarkColumns.TITLE);
                    int faviconIndex = c.getColumnIndex(Browser.BookmarkColumns.FAVICON);
                    do {
                        String url = c.getString(urlIndex);
                        String host = Uri.parse(url).getHost();
                        if (hosts.containsKey(host)) {
                            String title = c.getString(titleIndex);
                            Bitmap bmp = null;
                            byte[] data = c.getBlob(faviconIndex);
                            if (data != null) {
                                bmp = BitmapFactory.decodeByteArray(data, 0, data.length);
                            }
                            Set matchingSites = (Set) hosts.get(host);
                            Iterator<Site> sitesIter = matchingSites.iterator();
                            while (sitesIter.hasNext()) {
                                Site site = sitesIter.next();
                                // We should only set the title if the bookmark is for the root
                                // (i.e. www.google.com), as website settings act on the origin
                                // as a whole rather than a single page under that origin. If the
                                // user has bookmarked a page under the root but *not* the root,
                                // then we risk displaying the title of that page which may or
                                // may not have any relevance to the origin.
                                if (url.equals(site.getOrigin()) ||
                                        (new String(site.getOrigin()+""/"")).equals(url)) {
                                    site.setTitle(title);
                                }
                                if (bmp != null) {
                                    site.setIcon(bmp);
                                }
                            }
                        }
                    } while (c.moveToNext());
                }
                c.close();
            }
        }


        public void populateOrigins(Map<String, Site> sites) {
            clear();

            // We can now simply populate our array with Site instances
            Set<Map.Entry<String, Site>> elements = sites.entrySet();
            Iterator<Map.Entry<String, Site>> entryIterator = elements.iterator();
            while (entryIterator.hasNext()) {
                Map.Entry<String, Site> entry = entryIterator.next();
                Site site = entry.getValue();
                add(site);
            }

            notifyDataSetChanged();

            if (getCount() == 0) {
                finish(); // we close the screen
            }
        }

        public int getCount() {
            if (mCurrentSite == null) {
                return super.getCount();
            }
            return mCurrentSite.getFeatureCount();
        }

        public String sizeValueToString(long bytes) {
            // We display the size in MB, to 1dp, rounding up to the next 0.1MB.
            // bytes should always be greater than zero.
            if (bytes <= 0) {
                Log.e(LOGTAG, ""sizeValueToString called with non-positive value: "" + bytes);
                return ""0"";
            }
            float megabytes = (float) bytes / (1024.0F * 1024.0F);
            int truncated = (int) Math.ceil(megabytes * 10.0F);
            float result = (float) (truncated / 10.0F);
            return String.valueOf(result);
        }

        /*
         * If we receive the back event and are displaying
         * site's settings, we want to go back to the main
         * list view. If not, we just do nothing (see
         * dispatchKeyEvent() below).
         */
        public boolean backKeyPressed() {
            if (mCurrentSite != null) {
                mCurrentSite = null;
                askForOrigins();
                return true;
            }
            return false;
        }

        /**
         * @hide
         * Utility function
         * Set the icon according to the usage
         */
        public void setIconForUsage(ImageView usageIcon, long usageInBytes) {
            float usageInMegabytes = (float) usageInBytes / (1024.0F * 1024.0F);
            // We set the correct icon:
            // 0 < empty < 0.1MB
            // 0.1MB < low < 5MB
            // 5MB < high
            if (usageInMegabytes <= 0.1) {
                usageIcon.setImageBitmap(mUsageEmptyIcon);
            } else if (usageInMegabytes > 0.1 && usageInMegabytes <= 5) {
                usageIcon.setImageBitmap(mUsageLowIcon);
            } else if (usageInMegabytes > 5) {
                usageIcon.setImageBitmap(mUsageHighIcon);
            }
        }

        public View getView(int position, View convertView, ViewGroup parent) {
            View view;
            final TextView title;
            final TextView subtitle;
            final ImageView icon;
            final ImageView usageIcon;
            final ImageView locationIcon;
            final ImageView featureIcon;

            if (convertView == null) {
                view = mInflater.inflate(mResource, parent, false);
            } else {
                view = convertView;
            }

            title = (TextView) view.findViewById(R.id.title);
            subtitle = (TextView) view.findViewById(R.id.subtitle);
            icon = (ImageView) view.findViewById(R.id.icon);
            featureIcon = (ImageView) view.findViewById(R.id.feature_icon);
            usageIcon = (ImageView) view.findViewById(R.id.usage_icon);
            locationIcon = (ImageView) view.findViewById(R.id.location_icon);
            usageIcon.setVisibility(View.GONE);
            locationIcon.setVisibility(View.GONE);

            if (mCurrentSite == null) {
                setTitle(getString(R.string.pref_extras_website_settings));

                Site site = getItem(position);
                title.setText(site.getPrettyTitle());
                String subtitleText = site.getPrettyOrigin();
                if (subtitleText != null) {
                    title.setMaxLines(1);
                    title.setSingleLine(true);
                    subtitle.setVisibility(View.VISIBLE);
                    subtitle.setText(subtitleText);
                } else {
                    subtitle.setVisibility(View.GONE);
                    title.setMaxLines(2);
                    title.setSingleLine(false);
                }

                icon.setVisibility(View.VISIBLE);
                usageIcon.setVisibility(View.INVISIBLE);
                locationIcon.setVisibility(View.INVISIBLE);
                featureIcon.setVisibility(View.GONE);
                Bitmap bmp = site.getIcon();
                if (bmp == null) {
                    bmp = mDefaultIcon;
                }
                icon.setImageBitmap(bmp);
                // We set the site as the view's tag,
                // so that we can get it in onItemClick()
                view.setTag(site);

                String origin = site.getOrigin();
                if (site.hasFeature(Site.FEATURE_WEB_STORAGE)) {
                    WebStorage.getInstance().getUsageForOrigin(origin, new ValueCallback<Long>() {
                        public void onReceiveValue(Long value) {
                            if (value != null) {
                                setIconForUsage(usageIcon, value.longValue());
                                usageIcon.setVisibility(View.VISIBLE);
                            }
                        }
                    });
                }

                if (site.hasFeature(Site.FEATURE_GEOLOCATION)) {
                    locationIcon.setVisibility(View.VISIBLE);
                    GeolocationPermissions.getInstance().getAllowed(origin, new ValueCallback<Boolean>() {
                        public void onReceiveValue(Boolean allowed) {
                            if (allowed != null) {
                                if (allowed.booleanValue()) {
                                    locationIcon.setImageBitmap(mLocationAllowedIcon);
                                } else {
                                    locationIcon.setImageBitmap(mLocationDisallowedIcon);
                                }
                            }
                        }
                    });
                }
            } else {
                icon.setVisibility(View.GONE);
                locationIcon.setVisibility(View.GONE);
                usageIcon.setVisibility(View.GONE);
                featureIcon.setVisibility(View.VISIBLE);
                setTitle(mCurrentSite.getPrettyTitle());
                String origin = mCurrentSite.getOrigin();
                switch (mCurrentSite.getFeatureByIndex(position)) {
                    case Site.FEATURE_WEB_STORAGE:
                        WebStorage.getInstance().getUsageForOrigin(origin, new ValueCallback<Long>() {
                            public void onReceiveValue(Long value) {
                                if (value != null) {
                                    String usage = sizeValueToString(value.longValue()) + "" "" + sMBStored;
                                    title.setText(R.string.webstorage_clear_data_title);
                                    subtitle.setText(usage);
                                    subtitle.setVisibility(View.VISIBLE);
                                    setIconForUsage(featureIcon, value.longValue());
                                }
                            }
                        });
                        break;
                    case Site.FEATURE_GEOLOCATION:
                        title.setText(R.string.geolocation_settings_page_title);
                        GeolocationPermissions.getInstance().getAllowed(origin, new ValueCallback<Boolean>() {
                            public void onReceiveValue(Boolean allowed) {
                                if (allowed != null) {
                                    if (allowed.booleanValue()) {
                                        subtitle.setText(R.string.geolocation_settings_page_summary_allowed);
                                        featureIcon.setImageBitmap(mLocationAllowedIcon);
                                    } else {
                                        subtitle.setText(R.string.geolocation_settings_page_summary_not_allowed);
                                        featureIcon.setImageBitmap(mLocationDisallowedIcon);
                                    }
                                    subtitle.setVisibility(View.VISIBLE);
                                }
                            }
                        });
                        break;
                }
            }

            return view;
        }

        public void onItemClick(AdapterView<?> parent,
                                View view,
                                int position,
                                long id) {
            if (mCurrentSite != null) {
                switch (mCurrentSite.getFeatureByIndex(position)) {
                    case Site.FEATURE_WEB_STORAGE:
                        new AlertDialog.Builder(getContext())
                            .setTitle(R.string.webstorage_clear_data_dialog_title)
                            .setMessage(R.string.webstorage_clear_data_dialog_message)
                            .setPositiveButton(R.string.webstorage_clear_data_dialog_ok_button,
                                               new AlertDialog.OnClickListener() {
                                public void onClick(DialogInterface dlg, int which) {
                                    WebStorage.getInstance().deleteOrigin(mCurrentSite.getOrigin());
                                    // If this site has no more features, then go back to the
                                    // origins list.
                                    mCurrentSite.removeFeature(Site.FEATURE_WEB_STORAGE);
                                    if (mCurrentSite.getFeatureCount() == 0) {
                                        mCurrentSite = null;
                                    }
                                    askForOrigins();
                                    notifyDataSetChanged();
                                }})
                            .setNegativeButton(R.string.webstorage_clear_data_dialog_cancel_button, null)
                            .setIcon(android.R.drawable.ic_dialog_alert)
                            .show();
                        break;
                    case Site.FEATURE_GEOLOCATION:
                        new AlertDialog.Builder(getContext())
                            .setTitle(R.string.geolocation_settings_page_dialog_title)
                            .setMessage(R.string.geolocation_settings_page_dialog_message)
                            .setPositiveButton(R.string.geolocation_settings_page_dialog_ok_button,
                                               new AlertDialog.OnClickListener() {
                                public void onClick(DialogInterface dlg, int which) {
                                    GeolocationPermissions.getInstance().clear(mCurrentSite.getOrigin());
                                    mCurrentSite.removeFeature(Site.FEATURE_GEOLOCATION);
                                    if (mCurrentSite.getFeatureCount() == 0) {
                                        mCurrentSite = null;
                                    }
                                    askForOrigins();
                                    notifyDataSetChanged();
                                }})
                            .setNegativeButton(R.string.geolocation_settings_page_dialog_cancel_button, null)
                            .setIcon(android.R.drawable.ic_dialog_alert)
                            .show();
                        break;
                }
            } else {
                mCurrentSite = (Site) view.getTag();
                notifyDataSetChanged();
            }
        }

        public Site currentSite() {
            return mCurrentSite;
        }
    }

    /**
     * Intercepts the back key to immediately notify
     * NativeDialog that we are done.
     */
    public boolean dispatchKeyEvent(KeyEvent event) {
        if ((event.getKeyCode() == KeyEvent.KEYCODE_BACK)
            && (event.getAction() == KeyEvent.ACTION_DOWN)) {
            if ((mAdapter != null) && (mAdapter.backKeyPressed())){
                return true; // event consumed
            }
        }
        return super.dispatchKeyEvent(event);
    }

    @Override
    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        if (sMBStored == null) {
            sMBStored = getString(R.string.webstorage_origin_summary_mb_stored);
        }
        mAdapter = new SiteAdapter(this, R.layout.website_settings_row);
        setListAdapter(mAdapter);
        getListView().setOnItemClickListener(mAdapter);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.websitesettings, menu);
        return true;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        // If we are not on the sites list (rather on the page for a specific site) or
        // we aren't listing any sites hide the clear all button (and hence the menu).
        return  mAdapter.currentSite() == null && mAdapter.getCount() > 0;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.website_settings_menu_clear_all:
                // Show the prompt to clear all origins of their data and geolocation permissions.
                new AlertDialog.Builder(this)
                        .setTitle(R.string.website_settings_clear_all_dialog_title)
                        .setMessage(R.string.website_settings_clear_all_dialog_message)
                        .setPositiveButton(R.string.website_settings_clear_all_dialog_ok_button,
                                new AlertDialog.OnClickListener() {
                                    public void onClick(DialogInterface dlg, int which) {
                                        WebStorage.getInstance().deleteAllData();
                                        GeolocationPermissions.getInstance().clearAll();
                                        WebStorageSizeManager.resetLastOutOfSpaceNotificationTime();
                                        mAdapter.askForOrigins();
                                        finish();
                                    }})
                        .setNegativeButton(R.string.website_settings_clear_all_dialog_cancel_button, null)
                        .setIcon(android.R.drawable.ic_dialog_alert)
                        .show();
                return true;
        }
        return false;
    }
}
",False,34,0,0,6,19,0,1,L2
8,com.android.browser.HistoryItem.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 
package com.android.browser;

import android.content.Context;
import android.graphics.Bitmap;
import android.provider.Browser;
import android.view.View;
import android.widget.CompoundButton;
import android.widget.ImageView;
import android.widget.TextView;

/**
 *  Layout representing a history item in the classic history viewer.
 */
/* package */ class HistoryItem extends BookmarkItem {

    private CompoundButton  mStar;      // Star for bookmarking
    private CompoundButton.OnCheckedChangeListener  mListener;
    /**
     *  Create a new HistoryItem.
     *  @param context  Context for this HistoryItem.
     */
    /* package */ HistoryItem(Context context) {
        super(context);

        mStar = (CompoundButton) findViewById(R.id.star);
        mStar.setVisibility(View.VISIBLE);
        mListener = new CompoundButton.OnCheckedChangeListener() {
            public void onCheckedChanged(CompoundButton buttonView,
                    boolean isChecked) {
                if (isChecked) {
                    Bookmarks.addBookmark(mContext,
                            mContext.getContentResolver(), mUrl, getName(), null, true);
                    LogTag.logBookmarkAdded(mUrl, ""history"");
                } else {
                    Bookmarks.removeFromBookmarks(mContext,
                            mContext.getContentResolver(), mUrl, getName());
                }
            }
        };
    }
    
    /* package */ void copyTo(HistoryItem item) {
        item.mTextView.setText(mTextView.getText());
        item.mUrlText.setText(mUrlText.getText());
        item.setIsBookmark(mStar.isChecked());
        item.mImageView.setImageDrawable(mImageView.getDrawable());
    }

    /**
     * Whether or not this item represents a bookmarked site
     */
    /* package */ boolean isBookmark() {
        return mStar.isChecked();
    }

    /**
     *  Set whether or not this represents a bookmark, and make sure the star
     *  behaves appropriately.
     */
    /* package */ void setIsBookmark(boolean isBookmark) {
        mStar.setOnCheckedChangeListener(null);
        mStar.setChecked(isBookmark);
        mStar.setOnCheckedChangeListener(mListener);
    }
}
",False,34,1,1,5,18,3,3,L1
9,com.android.browser.DateSortedExpandableListAdapter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.Context;
import android.database.ContentObserver;
import android.database.Cursor;
import android.database.DataSetObserver;
import android.os.Handler;
import android.provider.BaseColumns;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.webkit.DateSorter;
import android.widget.ExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.TextView;

import java.util.Vector;

/**
 * ExpandableListAdapter which separates data into categories based on date.
 * Used for History and Downloads.
 */
public class DateSortedExpandableListAdapter implements ExpandableListAdapter {
    // Array for each of our bins.  Each entry represents how many items are
    // in that bin.
    private int mItemMap[];
    // This is our GroupCount.  We will have at most DateSorter.DAY_COUNT
    // bins, less if the user has no items in one or more bins.
    private int mNumberOfBins;
    private Vector<DataSetObserver> mObservers;
    private Cursor mCursor;
    private DateSorter mDateSorter;
    private int mDateIndex;
    private int mIdIndex;
    private Context mContext;

    private class ChangeObserver extends ContentObserver {
        public ChangeObserver() {
            super(new Handler());
        }

        @Override
        public boolean deliverSelfNotifications() {
            return true;
        }

        @Override
        public void onChange(boolean selfChange) {
            refreshData();
        }
    }

    public DateSortedExpandableListAdapter(Context context, Cursor cursor,
            int dateIndex) {
        mContext = context;
        mDateSorter = new DateSorter(context);
        mObservers = new Vector<DataSetObserver>();
        mCursor = cursor;
        mIdIndex = cursor.getColumnIndexOrThrow(BaseColumns._ID);
        cursor.registerContentObserver(new ChangeObserver());
        mDateIndex = dateIndex;
        buildMap();
    }

    /**
     * Set up the bins for determining which items belong to which groups.
     */
    private void buildMap() {
        // The cursor is sorted by date
        // The ItemMap will store the number of items in each bin.
        int array[] = new int[DateSorter.DAY_COUNT];
        // Zero out the array.
        for (int j = 0; j < DateSorter.DAY_COUNT; j++) {
            array[j] = 0;
        }
        mNumberOfBins = 0;
        int dateIndex = -1;
        if (mCursor.moveToFirst() && mCursor.getCount() > 0) {
            while (!mCursor.isAfterLast()) {
                long date = getLong(mDateIndex);
                int index = mDateSorter.getIndex(date);
                if (index > dateIndex) {
                    mNumberOfBins++;
                    if (index == DateSorter.DAY_COUNT - 1) {
                        // We are already in the last bin, so it will
                        // include all the remaining items
                        array[index] = mCursor.getCount()
                                - mCursor.getPosition();
                        break;
                    }
                    dateIndex = index;
                }
                array[dateIndex]++;
                mCursor.moveToNext();
            }
        }
        mItemMap = array;
    }

    /**
     * Get the byte array at cursorIndex from the Cursor.  Assumes the Cursor
     * has already been moved to the correct position.  Along with
     * {@link #getInt} and {@link #getString}, these are provided so the client
     * does not need to access the Cursor directly
     * @param cursorIndex Index to query the Cursor.
     * @return corresponding byte array from the Cursor.
     */
    /* package */ byte[] getBlob(int cursorIndex) {
        return mCursor.getBlob(cursorIndex);
    }

    /* package */ Context getContext() {
        return mContext;
    }

    /**
     * Get the integer at cursorIndex from the Cursor.  Assumes the Cursor has
     * already been moved to the correct position.  Along with
     * {@link #getBlob} and {@link #getString}, these are provided so the client
     * does not need to access the Cursor directly
     * @param cursorIndex Index to query the Cursor.
     * @return corresponding integer from the Cursor.
     */
    /* package */ int getInt(int cursorIndex) {
        return mCursor.getInt(cursorIndex);
    }

    /**
     * Get the long at cursorIndex from the Cursor.  Assumes the Cursor has
     * already been moved to the correct position.
     */
    /* package */ long getLong(int cursorIndex) {
        return mCursor.getLong(cursorIndex);
    }

    /**
     * Get the String at cursorIndex from the Cursor.  Assumes the Cursor has
     * already been moved to the correct position.  Along with
     * {@link #getInt} and {@link #getInt}, these are provided so the client
     * does not need to access the Cursor directly
     * @param cursorIndex Index to query the Cursor.
     * @return corresponding String from the Cursor.
     */
    /* package */ String getString(int cursorIndex) {
        return mCursor.getString(cursorIndex);
    }

    /**
     * Determine which group an item belongs to.
     * @param childId ID of the child view in question.
     * @return int Group position of the containing group.
    /* package */ int groupFromChildId(long childId) {
        int group = -1;
        for (mCursor.moveToFirst(); !mCursor.isAfterLast();
                mCursor.moveToNext()) {
            if (getLong(mIdIndex) == childId) {
                int bin = mDateSorter.getIndex(getLong(mDateIndex));
                // bin is the same as the group if the number of bins is the
                // same as DateSorter
                if (mDateSorter.DAY_COUNT == mNumberOfBins) return bin;
                // There are some empty bins.  Find the corresponding group.
                group = 0;
                for (int i = 0; i < bin; i++) {
                    if (mItemMap[i] != 0) group++;
                }
                break;
            }
        }
        return group;
    }

    /**
     * Translates from a group position in the ExpandableList to a bin.  This is
     * necessary because some groups have no history items, so we do not include
     * those in the ExpandableList.
     * @param groupPosition Position in the ExpandableList's set of groups
     * @return The corresponding bin that holds that group.
     */
    private int groupPositionToBin(int groupPosition) {
        if (groupPosition < 0 || groupPosition >= DateSorter.DAY_COUNT) {
            throw new AssertionError(""group position out of range"");
        }
        if (DateSorter.DAY_COUNT == mNumberOfBins || 0 == mNumberOfBins) {
            // In the first case, we have exactly the same number of bins
            // as our maximum possible, so there is no need to do a
            // conversion
            // The second statement is in case this method gets called when
            // the array is empty, in which case the provided groupPosition
            // will do fine.
            return groupPosition;
        }
        int arrayPosition = -1;
        while (groupPosition > -1) {
            arrayPosition++;
            if (mItemMap[arrayPosition] != 0) {
                groupPosition--;
            }
        }
        return arrayPosition;
    }

    /**
     * Move the cursor to the position indicated.
     * @param packedPosition Position in packed position representation.
     * @return True on success, false otherwise.
     */
    boolean moveCursorToPackedChildPosition(long packedPosition) {
        if (ExpandableListView.getPackedPositionType(packedPosition) !=
                ExpandableListView.PACKED_POSITION_TYPE_CHILD) {
            return false;
        }
        int groupPosition = ExpandableListView.getPackedPositionGroup(
                packedPosition);
        int childPosition = ExpandableListView.getPackedPositionChild(
                packedPosition);
        return moveCursorToChildPosition(groupPosition, childPosition);
    }

    /**
     * Move the cursor the the position indicated.
     * @param groupPosition Index of the group containing the desired item.
     * @param childPosition Index of the item within the specified group.
     * @return boolean False if the cursor is closed, so the Cursor was not
     *      moved.  True on success.
     */
    /* package */ boolean moveCursorToChildPosition(int groupPosition,
            int childPosition) {
        if (mCursor.isClosed()) return false;
        groupPosition = groupPositionToBin(groupPosition);
        int index = childPosition;
        for (int i = 0; i < groupPosition; i++) {
            index += mItemMap[i];
        }
        return mCursor.moveToPosition(index);
    }

    /* package */ void refreshData() {
        if (mCursor.isClosed()) {
            return;
        }
        mCursor.requery();
        buildMap();
        for (DataSetObserver o : mObservers) {
            o.onChanged();
        }
    }

    public View getGroupView(int groupPosition, boolean isExpanded,
            View convertView, ViewGroup parent) {
        TextView item;
        if (null == convertView || !(convertView instanceof TextView)) {
            LayoutInflater factory = LayoutInflater.from(mContext);
            item = (TextView) factory.inflate(R.layout.history_header, null);
        } else {
            item = (TextView) convertView;
        }
        String label = mDateSorter.getLabel(groupPositionToBin(groupPosition));
        item.setText(label);
        return item;
    }

    public View getChildView(int groupPosition, int childPosition,
            boolean isLastChild, View convertView, ViewGroup parent) {
        return null;
    }

    public boolean areAllItemsEnabled() {
        return true;
    }

    public boolean isChildSelectable(int groupPosition, int childPosition) {
        return true;
    }

    public int getGroupCount() {
        return mNumberOfBins;
    }

    public int getChildrenCount(int groupPosition) {
        return mItemMap[groupPositionToBin(groupPosition)];
    }

    public Object getGroup(int groupPosition) {
        return null;
    }

    public Object getChild(int groupPosition, int childPosition) {
        return null;
    }

    public long getGroupId(int groupPosition) {
        return groupPosition;
    }

    public long getChildId(int groupPosition, int childPosition) {
        if (moveCursorToChildPosition(groupPosition, childPosition)) {
            return getLong(mIdIndex);
        }
        return 0;
    }

    public boolean hasStableIds() {
        return true;
    }

    public void registerDataSetObserver(DataSetObserver observer) {
        mObservers.add(observer);
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
        mObservers.remove(observer);
    }

    public void onGroupExpanded(int groupPosition) {
    }

    public void onGroupCollapsed(int groupPosition) {
    }

    public long getCombinedChildId(long groupId, long childId) {
        return childId;
    }

    public long getCombinedGroupId(long groupId) {
        return groupId;
    }

    public boolean isEmpty() {
        return mCursor.isClosed() || mCursor.getCount() == 0;
    }
}
",False,2,1,1,0,0,1,0,L2
10,com.android.browser.WebDialog.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.Context;
import android.view.View;
import android.view.animation.AnimationUtils;
import android.view.inputmethod.InputMethodManager;
import android.webkit.WebView;
import android.widget.LinearLayout;

/* package */ class WebDialog extends LinearLayout {
    protected WebView         mWebView;
    protected BrowserActivity mBrowserActivity;
    private boolean           mIsVisible;

    /* package */ WebDialog(BrowserActivity context) {
        super(context);
        mBrowserActivity = context;
    }

    /* dialogs that have cancel buttons can optionally share code by including a
     * view with an id of 'done'.
     */
    protected void addCancel() {
        View button = findViewById(R.id.done);
        if (button != null) button.setOnClickListener(mCancelListener);
    }

    private View.OnClickListener mCancelListener = new View.OnClickListener() {
        public void onClick(View v) {
            mBrowserActivity.closeDialogs();
        }
    };

    protected void dismiss() {
        startAnimation(AnimationUtils.loadAnimation(mBrowserActivity,
                R.anim.dialog_exit));
        mIsVisible = false;
    }

    /*
     * Remove the soft keyboard from the screen.
     */
    protected void hideSoftInput() {
        InputMethodManager imm = (InputMethodManager)
                mBrowserActivity.getSystemService(Context.INPUT_METHOD_SERVICE);
        imm.hideSoftInputFromWindow(mWebView.getWindowToken(), 0);
    }

    protected boolean isVisible() {
        return mIsVisible;
    }

    /* package */ void setWebView(WebView webview) {
        mWebView = webview;
    }

    protected void show() {
        startAnimation(AnimationUtils.loadAnimation(mBrowserActivity,
            R.anim.dialog_enter));
        mIsVisible = true;
    }

}
",False,33,0,0,4,18,4,1,L1
11,com.android.browser.BrowserBookmarksAdapter.java,"/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.database.ContentObserver;
import android.database.Cursor;
import android.database.DataSetObserver;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.provider.Browser;
import android.provider.Browser.BookmarkColumns;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.webkit.WebIconDatabase;
import android.webkit.WebView;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import java.io.ByteArrayOutputStream;

class BrowserBookmarksAdapter extends BaseAdapter {

    private String                  mCurrentPage;
    private String                  mCurrentTitle;
    private Bitmap                  mCurrentThumbnail;
    private Cursor                  mCursor;
    private int                     mCount;
    private BrowserBookmarksPage    mBookmarksPage;
    private ContentResolver         mContentResolver;
    private boolean                 mDataValid;
    private BookmarkViewMode        mViewMode;
    private boolean                 mMostVisited;
    private boolean                 mNeedsOffset;
    private int                     mExtraOffset;

    /**
     *  Create a new BrowserBookmarksAdapter.
     *  @param b        BrowserBookmarksPage that instantiated this.
     *                  Necessary so it will adjust its focus
     *                  appropriately after a search.
     */
    public BrowserBookmarksAdapter(BrowserBookmarksPage b, String curPage,
            String curTitle, Bitmap curThumbnail, boolean createShortcut,
            boolean mostVisited) {
        mNeedsOffset = !(createShortcut || mostVisited);
        mMostVisited = mostVisited;
        mExtraOffset = mNeedsOffset ? 1 : 0;
        mBookmarksPage = b;
        mCurrentPage = b.getResources().getString(R.string.current_page)
                + curPage;
        mCurrentTitle = curTitle;
        mCurrentThumbnail = curThumbnail;
        mContentResolver = b.getContentResolver();
        mViewMode = BookmarkViewMode.LIST;

        String whereClause;
        // FIXME: Should have a default sort order that the user selects.
        String orderBy = Browser.BookmarkColumns.VISITS + "" DESC"";
        if (mostVisited) {
            whereClause = Browser.BookmarkColumns.VISITS + "" != 0"";
        } else {
            whereClause = Browser.BookmarkColumns.BOOKMARK + "" = 1"";
        }
        mCursor = b.managedQuery(Browser.BOOKMARKS_URI,
                Browser.HISTORY_PROJECTION, whereClause, null, orderBy);
        mCursor.registerContentObserver(new ChangeObserver());
        mCursor.registerDataSetObserver(new MyDataSetObserver());

        mDataValid = true;
        notifyDataSetChanged();

        mCount = mCursor.getCount() + mExtraOffset;
    }
    
    /**
     *  Return a hashmap with one row's Title, Url, and favicon.
     *  @param position  Position in the list.
     *  @return Bundle  Stores title, url of row position, favicon, and id
     *                   for the url.  Return a blank map if position is out of
     *                   range.
     */
    public Bundle getRow(int position) {
        Bundle map = new Bundle();
        if (position < mExtraOffset || position >= mCount) {
            return map;
        }
        mCursor.moveToPosition(position- mExtraOffset);
        String url = mCursor.getString(Browser.HISTORY_PROJECTION_URL_INDEX);
        map.putString(Browser.BookmarkColumns.TITLE, 
                mCursor.getString(Browser.HISTORY_PROJECTION_TITLE_INDEX));
        map.putString(Browser.BookmarkColumns.URL, url);
        byte[] data = mCursor.getBlob(Browser.HISTORY_PROJECTION_FAVICON_INDEX);
        if (data != null) {
            map.putParcelable(Browser.BookmarkColumns.FAVICON,
                    BitmapFactory.decodeByteArray(data, 0, data.length));
        }
        map.putInt(""id"", mCursor.getInt(Browser.HISTORY_PROJECTION_ID_INDEX));
        return map;
    }

    /**
     *  Update a row in the database with new information. 
     *  Requeries the database if the information has changed.
     *  @param map  Bundle storing id, title and url of new information
     */
    public void updateRow(Bundle map) {

        // Find the record
        int id = map.getInt(""id"");
        int position = -1;
        for (mCursor.moveToFirst(); !mCursor.isAfterLast(); mCursor.moveToNext()) {
            if (mCursor.getInt(Browser.HISTORY_PROJECTION_ID_INDEX) == id) {
                position = mCursor.getPosition();
                break;
            }
        }
        if (position < 0) {
            return;
        }

        mCursor.moveToPosition(position);
        ContentValues values = new ContentValues();
        String title = map.getString(Browser.BookmarkColumns.TITLE);
        if (!title.equals(mCursor
                .getString(Browser.HISTORY_PROJECTION_TITLE_INDEX))) {
            values.put(Browser.BookmarkColumns.TITLE, title);
        }
        String url = map.getString(Browser.BookmarkColumns.URL);
        if (!url.equals(mCursor.
                getString(Browser.HISTORY_PROJECTION_URL_INDEX))) {
            values.put(Browser.BookmarkColumns.URL, url);
        }

        if (map.getBoolean(""invalidateThumbnail"") == true) {
            values.put(Browser.BookmarkColumns.THUMBNAIL, new byte[0]);
        }
        if (values.size() > 0
                && mContentResolver.update(Browser.BOOKMARKS_URI, values,
                        ""_id = "" + id, null) != -1) {
            refreshList();
        }
    }

    /**
     *  Delete a row from the database.  Requeries the database.  
     *  Does nothing if the provided position is out of range.
     *  @param position Position in the list.
     */
    public void deleteRow(int position) {
        if (position < mExtraOffset || position >= getCount()) {
            return;
        }
        mCursor.moveToPosition(position- mExtraOffset);
        String url = mCursor.getString(Browser.HISTORY_PROJECTION_URL_INDEX);
        String title = mCursor.getString(Browser.HISTORY_PROJECTION_TITLE_INDEX);
        Bookmarks.removeFromBookmarks(null, mContentResolver, url, title);
        refreshList();
    }
    
    /**
     *  Delete all bookmarks from the db. Requeries the database.  
     *  All bookmarks with become visited URLs or if never visited 
     *  are removed
     */
    public void deleteAllRows() {
        StringBuilder deleteIds = null;
        StringBuilder convertIds = null;
        
        for (mCursor.moveToFirst(); !mCursor.isAfterLast(); mCursor.moveToNext()) {
            String url = mCursor.getString(Browser.HISTORY_PROJECTION_URL_INDEX);
            WebIconDatabase.getInstance().releaseIconForPageUrl(url);
            int id = mCursor.getInt(Browser.HISTORY_PROJECTION_ID_INDEX);
            int numVisits = mCursor.getInt(Browser.HISTORY_PROJECTION_VISITS_INDEX);
            if (0 == numVisits) {
                if (deleteIds == null) {
                    deleteIds = new StringBuilder();
                    deleteIds.append(""( "");
                } else {
                    deleteIds.append("" OR ( "");
                }
                deleteIds.append(BookmarkColumns._ID);
                deleteIds.append("" = "");
                deleteIds.append(id);
                deleteIds.append("" )"");
            } else {
                // It is no longer a bookmark, but it is still a visited site.
                if (convertIds == null) {
                    convertIds = new StringBuilder();
                    convertIds.append(""( "");
                } else {
                    convertIds.append("" OR ( "");
                }
                convertIds.append(BookmarkColumns._ID);
                convertIds.append("" = "");
                convertIds.append(id);
                convertIds.append("" )"");
            }
        }
        
        if (deleteIds != null) {
            mContentResolver.delete(Browser.BOOKMARKS_URI, deleteIds.toString(), 
                null);
        }
        if (convertIds != null) {
            ContentValues values = new ContentValues();
            values.put(Browser.BookmarkColumns.BOOKMARK, 0);
            mContentResolver.update(Browser.BOOKMARKS_URI, values, 
                    convertIds.toString(), null);
        }
        refreshList();
    }

    /**
     *  Refresh list to recognize a change in the database.
     */
    public void refreshList() {
        mCursor.requery();
        mCount = mCursor.getCount() + mExtraOffset;
        notifyDataSetChanged();
    }

    /**
     * Update the bookmark's favicon. This is a convenience method for updating
     * a bookmark favicon for the originalUrl and url of the passed in WebView.
     * @param cr The ContentResolver to use.
     * @param originalUrl The original url before any redirects.
     * @param url The current url.
     * @param favicon The favicon bitmap to write to the db.
     */
    /* package */ static void updateBookmarkFavicon(final ContentResolver cr,
            final String originalUrl, final String url, final Bitmap favicon) {
        new AsyncTask<Void, Void, Void>() {
            protected Void doInBackground(Void... unused) {
                final Cursor c =
                        queryBookmarksForUrl(cr, originalUrl, url, true);
                if (c == null) {
                    return null;
                }
                if (c.moveToFirst()) {
                    ContentValues values = new ContentValues();
                    final ByteArrayOutputStream os =
                            new ByteArrayOutputStream();
                    favicon.compress(Bitmap.CompressFormat.PNG, 100, os);
                    values.put(Browser.BookmarkColumns.FAVICON,
                            os.toByteArray());
                    do {
                        cr.update(ContentUris.withAppendedId(
                                Browser.BOOKMARKS_URI, c.getInt(0)),
                                values, null, null);
                    } while (c.moveToNext());
                }
                c.close();
                return null;
            }
        }.execute();
    }

    /* package */ static Cursor queryBookmarksForUrl(ContentResolver cr,
            String originalUrl, String url, boolean onlyBookmarks) {
        if (cr == null || url == null) {
            return null;
        }

        // If originalUrl is null, just set it to url.
        if (originalUrl == null) {
            originalUrl = url;
        }

        // Look for both the original url and the actual url. This takes in to
        // account redirects.
        String originalUrlNoQuery = removeQuery(originalUrl);
        String urlNoQuery = removeQuery(url);
        originalUrl = originalUrlNoQuery + '?';
        url = urlNoQuery + '?';

        // Use NoQuery to search for the base url (i.e. if the url is
        // http://www.yahoo.com/?rs=1, search for http://www.yahoo.com)
        // Use url to match the base url with other queries (i.e. if the url is
        // http://www.google.com/m, search for
        // http://www.google.com/m?some_query)
        final String[] selArgs = new String[] {
            originalUrlNoQuery, urlNoQuery, originalUrl, url };
        String where = BookmarkColumns.URL + "" == ? OR ""
                + BookmarkColumns.URL + "" == ? OR ""
                + BookmarkColumns.URL + "" LIKE ? || '%' OR ""
                + BookmarkColumns.URL + "" LIKE ? || '%'"";
        if (onlyBookmarks) {
            where = ""("" + where + "") AND "" + BookmarkColumns.BOOKMARK + "" == 1"";
        }
        final String[] projection =
                new String[] { Browser.BookmarkColumns._ID };
        return cr.query(Browser.BOOKMARKS_URI, projection, where, selArgs,
                null);
    }

    // Strip the query from the given url.
    private static String removeQuery(String url) {
        if (url == null) {
            return null;
        }
        int query = url.indexOf('?');
        String noQuery = url;
        if (query != -1) {
            noQuery = url.substring(0, query);
        }
        return noQuery;
    }

    /**
     * How many items should be displayed in the list.
     * @return Count of items.
     */
    public int getCount() {
        if (mDataValid) {
            return mCount;
        } else {
            return 0;
        }
    }

    public boolean areAllItemsEnabled() {
        return true;
    }

    public boolean isEnabled(int position) {
        return true;
    }

    /**
     * Get the data associated with the specified position in the list.
     * @param position Index of the item whose data we want.
     * @return The data at the specified position.
     */
    public Object getItem(int position) {
        return null;
    }

    /**
     * Get the row id associated with the specified position in the list.
     * @param position Index of the item whose row id we want.
     * @return The id of the item at the specified position.
     */
    public long getItemId(int position) {
        return position;
    }

    /* package */ void switchViewMode(BookmarkViewMode viewMode) {
        mViewMode = viewMode;
    }

    /* package */ void populateBookmarkItem(BookmarkItem b, int position) {
        mCursor.moveToPosition(position - mExtraOffset);
        String url = mCursor.getString(Browser.HISTORY_PROJECTION_URL_INDEX);
        b.setUrl(url);
        b.setName(mCursor.getString(Browser.HISTORY_PROJECTION_TITLE_INDEX));
        byte[] data = mCursor.getBlob(Browser.HISTORY_PROJECTION_FAVICON_INDEX);
        Bitmap bitmap = null;
        if (data == null) {
            bitmap = CombinedBookmarkHistoryActivity.getIconListenerSet()
                    .getFavicon(url);
        } else {
            bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);
        }
        b.setFavicon(bitmap);
    }

    /**
     * Get a View that displays the data at the specified position
     * in the list.
     * @param position Index of the item whose view we want.
     * @return A View corresponding to the data at the specified position.
     */
    public View getView(int position, View convertView, ViewGroup parent) {
        if (!mDataValid) {
            throw new IllegalStateException(
                    ""this should only be called when the cursor is valid"");
        }
        if (position < 0 || position > mCount) {
            throw new AssertionError(
                    ""BrowserBookmarksAdapter tried to get a view out of range"");
        }
        if (mViewMode == BookmarkViewMode.GRID) {
            if (convertView == null || convertView instanceof AddNewBookmark
                    || convertView instanceof BookmarkItem) {
                LayoutInflater factory = LayoutInflater.from(mBookmarksPage);
                convertView
                        = factory.inflate(R.layout.bookmark_thumbnail, null);
            }
            View holder = convertView.findViewById(R.id.holder);
            ImageView thumb = (ImageView) convertView.findViewById(R.id.thumb);
            TextView tv = (TextView) convertView.findViewById(R.id.label);

            if (0 == position && mNeedsOffset) {
                // This is to create a bookmark for the current page.
                holder.setVisibility(View.VISIBLE);
                tv.setText(mCurrentTitle);

                if (mCurrentThumbnail != null) {
                    thumb.setImageBitmap(mCurrentThumbnail);
                } else {
                    thumb.setImageResource(
                            R.drawable.browser_thumbnail);
                }
                return convertView;
            }
            holder.setVisibility(View.GONE);
            mCursor.moveToPosition(position - mExtraOffset);
            tv.setText(mCursor.getString(
                    Browser.HISTORY_PROJECTION_TITLE_INDEX));
            Bitmap thumbnail = getScreenshot(position);
            if (thumbnail == null) {
                thumb.setImageResource(R.drawable.browser_thumbnail);
            } else {
                thumb.setImageBitmap(thumbnail);
            }

            return convertView;

        }
        if (position == 0 && mNeedsOffset) {
            AddNewBookmark b;
            if (convertView instanceof AddNewBookmark) {
                b = (AddNewBookmark) convertView;
            } else {
                b = new AddNewBookmark(mBookmarksPage);
            }
            b.setUrl(mCurrentPage);
            return b;
        }
        if (mMostVisited) {
            if (convertView == null || !(convertView instanceof HistoryItem)) {
                convertView = new HistoryItem(mBookmarksPage);
            }
        } else {
            if (convertView == null || !(convertView instanceof BookmarkItem)) {
                convertView = new BookmarkItem(mBookmarksPage);
            }
        }
        bind((BookmarkItem) convertView, position);
        if (mMostVisited) {
            ((HistoryItem) convertView).setIsBookmark(
                    getIsBookmark(position));
        }
        return convertView;
    }

    /**
     *  Return the title for this item in the list.
     */
    public String getTitle(int position) {
        return getString(Browser.HISTORY_PROJECTION_TITLE_INDEX, position);
    }

    /**
     *  Return the Url for this item in the list.
     */
    public String getUrl(int position) {
        return getString(Browser.HISTORY_PROJECTION_URL_INDEX, position);
    }

    /**
     * Return the screenshot for this item in the list.
     */
    public Bitmap getScreenshot(int position) {
        return getBitmap(Browser.HISTORY_PROJECTION_THUMBNAIL_INDEX, position);
    }

    /**
     * Return the favicon for this item in the list.
     */
    public Bitmap getFavicon(int position) {
        return getBitmap(Browser.HISTORY_PROJECTION_FAVICON_INDEX, position);
    }

    public Bitmap getTouchIcon(int position) {
        return getBitmap(Browser.HISTORY_PROJECTION_TOUCH_ICON_INDEX, position);
    }

    private Bitmap getBitmap(int cursorIndex, int position) {
        if (position < mExtraOffset || position > mCount) {
            return null;
        }
        mCursor.moveToPosition(position - mExtraOffset);
        byte[] data = mCursor.getBlob(cursorIndex);
        if (data == null) {
            return null;
        }
        return BitmapFactory.decodeByteArray(data, 0, data.length);
    }

    /**
     * Return whether or not this item represents a bookmarked site.
     */
    public boolean getIsBookmark(int position) {
        if (position < mExtraOffset || position > mCount) {
            return false;
        }
        mCursor.moveToPosition(position - mExtraOffset);
        return (1 == mCursor.getInt(Browser.HISTORY_PROJECTION_BOOKMARK_INDEX));
    }

    /**
     * Private helper function to return the title or url.
     */
    private String getString(int cursorIndex, int position) {
        if (position < mExtraOffset || position > mCount) {
            return """";
        }
        mCursor.moveToPosition(position- mExtraOffset);
        return mCursor.getString(cursorIndex);
    }

    private void bind(BookmarkItem b, int position) {
        mCursor.moveToPosition(position- mExtraOffset);

        b.setName(mCursor.getString(Browser.HISTORY_PROJECTION_TITLE_INDEX));
        String url = mCursor.getString(Browser.HISTORY_PROJECTION_URL_INDEX);
        b.setUrl(url);
        byte[] data = mCursor.getBlob(Browser.HISTORY_PROJECTION_FAVICON_INDEX);
        if (data != null) {
            b.setFavicon(BitmapFactory.decodeByteArray(data, 0, data.length));
        } else {
            b.setFavicon(CombinedBookmarkHistoryActivity.getIconListenerSet()
                    .getFavicon(url));
        }
    }

    private class ChangeObserver extends ContentObserver {
        public ChangeObserver() {
            super(new Handler(Looper.getMainLooper()));
        }

        @Override
        public boolean deliverSelfNotifications() {
            return true;
        }

        @Override
        public void onChange(boolean selfChange) {
            refreshList();
        }
    }
    
    private class MyDataSetObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            mDataValid = true;
            notifyDataSetChanged();
        }

        @Override
        public void onInvalidated() {
            mDataValid = false;
            notifyDataSetInvalidated();
        }
    }
}
",False,33,0,0,4,17,4,6,L1
12,com.android.browser.CombinedBookmarkHistoryActivity.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.app.Activity;
import android.app.TabActivity;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.os.AsyncTask;
import android.os.Bundle;
import android.provider.Browser;
import android.webkit.WebIconDatabase;
import android.webkit.WebIconDatabase.IconListener;
import android.widget.TabHost;

import java.util.HashMap;
import java.util.Vector;

public class CombinedBookmarkHistoryActivity extends TabActivity
        implements TabHost.OnTabChangeListener {
    /**
     * Used to inform BrowserActivity to remove the parent/child relationships
     * from all the tabs.
     */
    private String mExtraData;
    /**
     * Intent to be passed to calling Activity when finished.  Keep a pointer to
     * it locally so mExtraData can be added.
     */
    private Intent mResultData;
    /**
     * Result code to pass back to calling Activity when finished.
     */
    private int mResultCode;

    /* package */ static String BOOKMARKS_TAB = ""bookmark"";
    /* package */ static String VISITED_TAB = ""visited"";
    /* package */ static String HISTORY_TAB = ""history"";
    /* package */ static String STARTING_TAB = ""tab"";

    static class IconListenerSet implements IconListener {
        // Used to store favicons as we get them from the database
        // FIXME: We use a different method to get the Favicons in
        // BrowserBookmarksAdapter. They should probably be unified.
        private HashMap<String, Bitmap> mUrlsToIcons;
        private Vector<IconListener> mListeners;

        public IconListenerSet() {
            mUrlsToIcons = new HashMap<String, Bitmap>();
            mListeners = new Vector<IconListener>();
        }
        public void onReceivedIcon(String url, Bitmap icon) {
            mUrlsToIcons.put(url, icon);
            for (IconListener listener : mListeners) {
                listener.onReceivedIcon(url, icon);
            }
        }
        public void addListener(IconListener listener) {
            mListeners.add(listener);
        }
        public void removeListener(IconListener listener) {
            mListeners.remove(listener);
        }
        public Bitmap getFavicon(String url) {
            return (Bitmap) mUrlsToIcons.get(url);
        }
    }
    private static IconListenerSet sIconListenerSet;
    static IconListenerSet getIconListenerSet() {
        if (null == sIconListenerSet) {
            sIconListenerSet = new IconListenerSet();
        }
        return sIconListenerSet;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.tabs);

        setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);

        getTabHost().setOnTabChangedListener(this);

        Bundle extras = getIntent().getExtras();

        Intent bookmarksIntent = new Intent(this, BrowserBookmarksPage.class);
        if (extras != null) {
            bookmarksIntent.putExtras(extras);
        }
        createTab(bookmarksIntent, R.string.tab_bookmarks,
                R.drawable.browser_bookmark_tab, BOOKMARKS_TAB);

        Intent visitedIntent = new Intent(this, BrowserBookmarksPage.class);
        // Need to copy extras so the bookmarks activity and this one will be
        // different
        Bundle visitedExtras = extras == null ? new Bundle() : new Bundle(extras);
        visitedExtras.putBoolean(""mostVisited"", true);
        visitedIntent.putExtras(visitedExtras);
        createTab(visitedIntent, R.string.tab_most_visited,
                R.drawable.browser_visited_tab, VISITED_TAB);

        Intent historyIntent = new Intent(this, BrowserHistoryPage.class);
        String defaultTab = null;
        if (extras != null) {
            historyIntent.putExtras(extras);
            defaultTab = extras.getString(STARTING_TAB);
        }
        createTab(historyIntent, R.string.tab_history,
                R.drawable.browser_history_tab, HISTORY_TAB);

        if (defaultTab != null) {
            getTabHost().setCurrentTab(2);
        }

        // XXX: Must do this before launching the AsyncTask to avoid a
        // potential crash if the icon database has not been created.
        WebIconDatabase.getInstance();
        // Do this every time we launch the activity in case a new favicon was
        // added to the webkit db.
        (new AsyncTask<Void, Void, Void>() {
            public Void doInBackground(Void... v) {
                Browser.requestAllIcons(getContentResolver(),
                    Browser.BookmarkColumns.FAVICON + "" is NULL"",
                    getIconListenerSet());
                return null;
            }
        }).execute();
    }

    private void createTab(Intent intent, int labelResId, int iconResId,
            String tab) {
        Resources resources = getResources();
        TabHost tabHost = getTabHost();
        tabHost.addTab(tabHost.newTabSpec(tab).setIndicator(
                resources.getText(labelResId), resources.getDrawable(iconResId))
                .setContent(intent));
    }
    // Copied from DialTacts Activity
    /** {@inheritDoc} */
    public void onTabChanged(String tabId) {
        Activity activity = getLocalActivityManager().getActivity(tabId);
        if (activity != null) {
            activity.onWindowFocusChanged(true);
        }
    }

    /**
     * Store extra data in the Intent to return to the calling Activity to tell
     * it to clear the parent/child relationships from all tabs.
     */
    /* package */ void removeParentChildRelationShips() {
        mExtraData = BrowserSettings.PREF_CLEAR_HISTORY;
    }

    /**
     * Custom setResult() method so that the Intent can have extra data attached
     * if necessary.
     * @param resultCode Uses same codes as Activity.setResult
     * @param data Intent returned to onActivityResult.
     */
    /* package */ void setResultFromChild(int resultCode, Intent data) {
        mResultCode = resultCode;
        mResultData = data;
    }

    @Override
    public void finish() {
        if (mExtraData != null) {
            mResultCode = RESULT_OK;
            if (mResultData == null) mResultData = new Intent();
            mResultData.putExtra(Intent.EXTRA_TEXT, mExtraData);
        }
        setResult(mResultCode, mResultData);
        super.finish();
    }
}
",False,34,1,1,4,19,4,1,L1
13,com.android.browser.OpenDownloadReceiver.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.app.DownloadManager;
import android.content.ActivityNotFoundException;
import android.content.BroadcastReceiver;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.provider.Downloads;
import android.widget.Toast;

import java.io.File;

/**
 * This {@link BroadcastReceiver} handles clicks to notifications that
 * downloads from the browser are in progress/complete.  Clicking on an
 * in-progress or failed download will open the download manager.  Clicking on
 * a complete, successful download will open the file.
 */
public class OpenDownloadReceiver extends BroadcastReceiver {
    public void onReceive(Context context, Intent intent) {
        ContentResolver cr = context.getContentResolver();
        Uri data = intent.getData();
        Cursor cursor = null;
        try {
            cursor = cr.query(data,
                    new String[] { Downloads.Impl._ID, Downloads.Impl._DATA,
                    Downloads.Impl.COLUMN_MIME_TYPE, Downloads.COLUMN_STATUS },
                    null, null, null);
            if (cursor.moveToFirst()) {
                String filename = cursor.getString(1);
                String mimetype = cursor.getString(2);
                String action = intent.getAction();
                if (Downloads.ACTION_NOTIFICATION_CLICKED.equals(action)) {
                    int status = cursor.getInt(3);
                    if (Downloads.isStatusCompleted(status)
                            && Downloads.isStatusSuccess(status)) {
                        Intent launchIntent = new Intent(Intent.ACTION_VIEW);
                        Uri path = Uri.parse(filename);
                        // If there is no scheme, then it must be a file
                        if (path.getScheme() == null) {
                            path = Uri.fromFile(new File(filename));
                        }
                        launchIntent.setDataAndType(path, mimetype);
                        launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        try {
                            context.startActivity(launchIntent);
                        } catch (ActivityNotFoundException ex) {
                            Toast.makeText(context,
                                    R.string.download_no_application_title,
                                    Toast.LENGTH_LONG).show();
                        }
                    } else {
                        // Open the downloads page
                        Intent pageView = new Intent(
                                DownloadManager.ACTION_VIEW_DOWNLOADS);
                        pageView.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        context.startActivity(pageView);
                    }
                }
            }
        } finally {
            if (cursor != null) cursor.close();
        }
    }
}
",True,1,0,0,0,0,0,0,I0
14,com.android.browser.FetchUrlMimeType.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.ContentValues;
import android.net.Uri;
import android.net.http.AndroidHttpClient;

import org.apache.http.HttpResponse;
import org.apache.http.Header;
import org.apache.http.client.methods.HttpHead;

import java.io.IOException;

import android.os.AsyncTask;
import android.provider.Downloads;
import android.webkit.MimeTypeMap;
import android.webkit.URLUtil;

/**
 * This class is used to pull down the http headers of a given URL so that
 * we can analyse the mimetype and make any correction needed before we give
 * the URL to the download manager. The ContentValues class holds the
 * content that would be provided to the download manager, so that on
 * completion of checking the mimetype, we can issue the download to
 * the download manager.
 * This operation is needed when the user long-clicks on a link or image and
 * we don't know the mimetype. If the user just clicks on the link, we will
 * do the same steps of correcting the mimetype down in
 * android.os.webkit.LoadListener rather than handling it here.
 *
 */
class FetchUrlMimeType extends AsyncTask<ContentValues, String, String> {

    BrowserActivity mActivity;
    ContentValues mValues;

    public FetchUrlMimeType(BrowserActivity activity) {
        mActivity = activity;
    }

    @Override
    public String doInBackground(ContentValues... values) {
        mValues = values[0];

        // Check to make sure we have a URI to download
        String uri = mValues.getAsString(Downloads.Impl.COLUMN_URI);
        if (uri == null || uri.length() == 0) {
            return null;
        }

        // User agent is likely to be null, though the AndroidHttpClient
        // seems ok with that.
        AndroidHttpClient client = AndroidHttpClient.newInstance(
                mValues.getAsString(Downloads.Impl.COLUMN_USER_AGENT));
        HttpHead request = new HttpHead(uri);

        String cookie = mValues.getAsString(Downloads.Impl.COLUMN_COOKIE_DATA);
        if (cookie != null && cookie.length() > 0) {
            request.addHeader(""Cookie"", cookie);
        }

        String referer = mValues.getAsString(Downloads.Impl.COLUMN_REFERER);
        if (referer != null && referer.length() > 0) {
            request.addHeader(""Referer"", referer);
        }

        HttpResponse response;
        String mimeType = null;
        try {
            response = client.execute(request);
            // We could get a redirect here, but if we do lets let
            // the download manager take care of it, and thus trust that
            // the server sends the right mimetype
            if (response.getStatusLine().getStatusCode() == 200) {
                Header header = response.getFirstHeader(""Content-Type"");
                if (header != null) {
                    mimeType = header.getValue();
                    final int semicolonIndex = mimeType.indexOf(';');
                    if (semicolonIndex != -1) {
                        mimeType = mimeType.substring(0, semicolonIndex);
                    }
                }
            }
        } catch (IllegalArgumentException ex) {
            request.abort();
        } catch (IOException ex) {
            request.abort();
        } finally {
            client.close();
        }

        return mimeType;
    }

   @Override
    public void onPostExecute(String mimeType) {
       if (mimeType != null) {
           String url = mValues.getAsString(Downloads.Impl.COLUMN_URI);
           if (mimeType.equalsIgnoreCase(""text/plain"") ||
                   mimeType.equalsIgnoreCase(""application/octet-stream"")) {
               String newMimeType =
                       MimeTypeMap.getSingleton().getMimeTypeFromExtension(
                           MimeTypeMap.getFileExtensionFromUrl(url));
               if (newMimeType != null) {
                   mValues.put(Downloads.Impl.COLUMN_MIME_TYPE, newMimeType);
               }
           }
           String filename = URLUtil.guessFileName(url,
                   null, mimeType);
           mValues.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, filename);
       }

       // Start the download
       final Uri contentUri =
           mActivity.getContentResolver().insert(Downloads.Impl.CONTENT_URI, mValues);
    }

}
",False,33,0,0,4,18,1,1,L1
15,com.android.browser.BrowserActivity.java,"/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.DownloadManager;
import android.app.ProgressDialog;
import android.app.SearchManager;
import android.content.ActivityNotFoundException;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.ContentProvider;
import android.content.ContentProviderClient;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.database.Cursor;
import android.database.DatabaseUtils;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Picture;
import android.graphics.PixelFormat;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.net.WebAddress;
import android.net.http.SslCertificate;
import android.net.http.SslError;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Debug;
import android.os.Environment;
import android.os.Handler;
import android.os.Message;
import android.os.PowerManager;
import android.os.Process;
import android.os.ServiceManager;
import android.os.SystemClock;
import android.provider.Browser;
import android.provider.ContactsContract;
import android.provider.ContactsContract.Intents.Insert;
import android.provider.Downloads;
import android.provider.MediaStore;
import android.speech.RecognizerResultsIntent;
import android.text.IClipboard;
import android.text.TextUtils;
import android.text.format.DateFormat;
import android.util.AttributeSet;
import android.util.Log;
import android.util.Patterns;
import android.view.ContextMenu;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.MenuItem.OnMenuItemClickListener;
import android.webkit.CookieManager;
import android.webkit.CookieSyncManager;
import android.webkit.DownloadListener;
import android.webkit.HttpAuthHandler;
import android.webkit.PluginManager;
import android.webkit.SslErrorHandler;
import android.webkit.URLUtil;
import android.webkit.ValueCallback;
import android.webkit.WebChromeClient;
import android.webkit.WebHistoryItem;
import android.webkit.WebIconDatabase;
import android.webkit.WebView;
import android.widget.EditText;
import android.widget.FrameLayout;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;
import android.accounts.Account;
import android.accounts.AccountManager;
import android.accounts.AccountManagerFuture;
import android.accounts.AuthenticatorException;
import android.accounts.OperationCanceledException;
import android.accounts.AccountManagerCallback;

import com.android.browser.search.SearchEngine;
import com.android.common.Search;
import com.android.common.speech.LoggingEvents;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLEncoder;
import java.text.ParseException;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class BrowserActivity extends Activity
    implements View.OnCreateContextMenuListener, DownloadListener {

    /* Define some aliases to make these debugging flags easier to refer to.
     * This file imports android.provider.Browser, so we can't just refer to ""Browser.DEBUG"".
     */
    private final static boolean DEBUG = com.android.browser.Browser.DEBUG;
    private final static boolean LOGV_ENABLED = com.android.browser.Browser.LOGV_ENABLED;
    private final static boolean LOGD_ENABLED = com.android.browser.Browser.LOGD_ENABLED;

    private static class ClearThumbnails extends AsyncTask<File, Void, Void> {
        @Override
        public Void doInBackground(File... files) {
            if (files != null) {
                for (File f : files) {
                    if (!f.delete()) {
                      Log.e(LOGTAG, f.getPath() + "" was not deleted"");
                    }
                }
            }
            return null;
        }
    }

    /**
     * This layout holds everything you see below the status bar, including the
     * error console, the custom view container, and the webviews.
     */
    private FrameLayout mBrowserFrameLayout;

    @Override
    public void onCreate(Bundle icicle) {
        if (LOGV_ENABLED) {
            Log.v(LOGTAG, this + "" onStart"");
        }
        super.onCreate(icicle);
        // test the browser in OpenGL
        // requestWindowFeature(Window.FEATURE_OPENGL);

        // enable this to test the browser in 32bit
        if (false) {
            getWindow().setFormat(PixelFormat.RGBX_8888);
            BitmapFactory.setDefaultConfig(Bitmap.Config.ARGB_8888);
        }

        setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);

        mResolver = getContentResolver();

        // Keep a settings instance handy.
        mSettings = BrowserSettings.getInstance();

        // If this was a web search request, pass it on to the default web
        // search provider and finish this activity.
        if (handleWebSearchIntent(getIntent())) {
            finish();
            return;
        }

        mSecLockIcon = Resources.getSystem().getDrawable(
                android.R.drawable.ic_secure);
        mMixLockIcon = Resources.getSystem().getDrawable(
                android.R.drawable.ic_partial_secure);

        FrameLayout frameLayout = (FrameLayout) getWindow().getDecorView()
                .findViewById(com.android.internal.R.id.content);
        mBrowserFrameLayout = (FrameLayout) LayoutInflater.from(this)
                .inflate(R.layout.custom_screen, null);
        mContentView = (FrameLayout) mBrowserFrameLayout.findViewById(
                R.id.main_content);
        mErrorConsoleContainer = (LinearLayout) mBrowserFrameLayout
                .findViewById(R.id.error_console);
        mCustomViewContainer = (FrameLayout) mBrowserFrameLayout
                .findViewById(R.id.fullscreen_custom_content);
        frameLayout.addView(mBrowserFrameLayout, COVER_SCREEN_PARAMS);
        mTitleBar = new TitleBar(this);
        // mTitleBar will be always shown in the fully loaded mode
        mTitleBar.setProgress(100);
        mFakeTitleBar = new TitleBar(this);

        // Create the tab control and our initial tab
        mTabControl = new TabControl(this);

        // Open the icon database and retain all the bookmark urls for favicons
        retainIconsOnStartup();

        mSettings.setTabControl(mTabControl);

        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""Browser"");

        // Find out if the network is currently up.
        ConnectivityManager cm = (ConnectivityManager) getSystemService(
                Context.CONNECTIVITY_SERVICE);
        NetworkInfo info = cm.getActiveNetworkInfo();
        if (info != null) {
            mIsNetworkUp = info.isAvailable();
        }

        /* enables registration for changes in network status from
           http stack */
        mNetworkStateChangedFilter = new IntentFilter();
        mNetworkStateChangedFilter.addAction(
                ConnectivityManager.CONNECTIVITY_ACTION);
        mNetworkStateIntentReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    if (intent.getAction().equals(
                            ConnectivityManager.CONNECTIVITY_ACTION)) {

                        NetworkInfo info = intent.getParcelableExtra(
                                ConnectivityManager.EXTRA_NETWORK_INFO);
                        String typeName = info.getTypeName();
                        String subtypeName = info.getSubtypeName();
                        sendNetworkType(typeName.toLowerCase(),
                                (subtypeName != null ? subtypeName.toLowerCase() : """"));

                        onNetworkToggle(info.isAvailable());
                    }
                }
            };

        IntentFilter filter = new IntentFilter(Intent.ACTION_PACKAGE_ADDED);
        filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
        filter.addDataScheme(""package"");
        mPackageInstallationReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                final String action = intent.getAction();
                final String packageName = intent.getData()
                        .getSchemeSpecificPart();
                final boolean replacing = intent.getBooleanExtra(
                        Intent.EXTRA_REPLACING, false);
                if (Intent.ACTION_PACKAGE_REMOVED.equals(action) && replacing) {
                    // if it is replacing, refreshPlugins() when adding
                    return;
                }

                if (sGoogleApps.contains(packageName)) {
                    BrowserActivity.this.packageChanged(packageName,
                            Intent.ACTION_PACKAGE_ADDED.equals(action));
                }

                PackageManager pm = BrowserActivity.this.getPackageManager();
                PackageInfo pkgInfo = null;
                try {
                    pkgInfo = pm.getPackageInfo(packageName,
                            PackageManager.GET_PERMISSIONS);
                } catch (PackageManager.NameNotFoundException e) {
                    return;
                }
                if (pkgInfo != null) {
                    String permissions[] = pkgInfo.requestedPermissions;
                    if (permissions == null) {
                        return;
                    }
                    boolean permissionOk = false;
                    for (String permit : permissions) {
                        if (PluginManager.PLUGIN_PERMISSION.equals(permit)) {
                            permissionOk = true;
                            break;
                        }
                    }
                    if (permissionOk) {
                        PluginManager.getInstance(BrowserActivity.this)
                                .refreshPlugins(
                                        Intent.ACTION_PACKAGE_ADDED
                                                .equals(action));
                    }
                }
            }
        };
        registerReceiver(mPackageInstallationReceiver, filter);

        if (!mTabControl.restoreState(icicle)) {
            // clear up the thumbnail directory if we can't restore the state as
            // none of the files in the directory are referenced any more.
            new ClearThumbnails().execute(
                    mTabControl.getThumbnailDir().listFiles());
            // there is no quit on Android. But if we can't restore the state,
            // we can treat it as a new Browser, remove the old session cookies.
            CookieManager.getInstance().removeSessionCookie();
            final Intent intent = getIntent();
            final Bundle extra = intent.getExtras();
            // Create an initial tab.
            // If the intent is ACTION_VIEW and data is not null, the Browser is
            // invoked to view the content by another application. In this case,
            // the tab will be close when exit.
            UrlData urlData = getUrlDataFromIntent(intent);

            String action = intent.getAction();
            final Tab t = mTabControl.createNewTab(
                    (Intent.ACTION_VIEW.equals(action) &&
                    intent.getData() != null)
                    || RecognizerResultsIntent.ACTION_VOICE_SEARCH_RESULTS
                    .equals(action),
                    intent.getStringExtra(Browser.EXTRA_APPLICATION_ID), urlData.mUrl);
            mTabControl.setCurrentTab(t);
            attachTabToContentView(t);
            WebView webView = t.getWebView();
            if (extra != null) {
                int scale = extra.getInt(Browser.INITIAL_ZOOM_LEVEL, 0);
                if (scale > 0 && scale <= 1000) {
                    webView.setInitialScale(scale);
                }
            }

            if (urlData.isEmpty()) {
                loadUrl(webView, mSettings.getHomePage());
            } else {
                loadUrlDataIn(t, urlData);
            }
        } else {
            // TabControl.restoreState() will create a new tab even if
            // restoring the state fails.
            attachTabToContentView(mTabControl.getCurrentTab());
        }

        // Delete old thumbnails to save space
        File dir = mTabControl.getThumbnailDir();
        if (dir.exists()) {
            for (String child : dir.list()) {
                File f = new File(dir, child);
                f.delete();
            }
        }

        // Read JavaScript flags if it exists.
        String jsFlags = mSettings.getJsFlags();
        if (jsFlags.trim().length() != 0) {
            mTabControl.getCurrentWebView().setJsFlags(jsFlags);
        }
        // Work out which packages are installed on the system.
        getInstalledPackages();

        // Start watching the default geolocation permissions
        mSystemAllowGeolocationOrigins
                = new SystemAllowGeolocationOrigins(getApplicationContext());
        mSystemAllowGeolocationOrigins.start();
    }

    /**
     * Feed the previously stored results strings to the BrowserProvider so that
     * the SearchDialog will show them instead of the standard searches.
     * @param result String to show on the editable line of the SearchDialog.
     */
    /* package */ void showVoiceSearchResults(String result) {
        ContentProviderClient client = mResolver.acquireContentProviderClient(
                Browser.BOOKMARKS_URI);
        ContentProvider prov = client.getLocalContentProvider();
        BrowserProvider bp = (BrowserProvider) prov;
        bp.setQueryResults(mTabControl.getCurrentTab().getVoiceSearchResults());
        client.release();

        Bundle bundle = createGoogleSearchSourceBundle(
                GOOGLE_SEARCH_SOURCE_SEARCHKEY);
        bundle.putBoolean(SearchManager.CONTEXT_IS_VOICE, true);
        startSearch(result, false, bundle, false);
    }

    @Override
    protected void onNewIntent(Intent intent) {
        Tab current = mTabControl.getCurrentTab();
        // When a tab is closed on exit, the current tab index is set to -1.
        // Reset before proceed as Browser requires the current tab to be set.
        if (current == null) {
            // Try to reset the tab in case the index was incorrect.
            current = mTabControl.getTab(0);
            if (current == null) {
                // No tabs at all so just ignore this intent.
                return;
            }
            mTabControl.setCurrentTab(current);
            attachTabToContentView(current);
            resetTitleAndIcon(current.getWebView());
        }
        final String action = intent.getAction();
        final int flags = intent.getFlags();
        if (Intent.ACTION_MAIN.equals(action) ||
                (flags & Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) != 0) {
            // just resume the browser
            return;
        }
        // In case the SearchDialog is open.
        ((SearchManager) getSystemService(Context.SEARCH_SERVICE))
                .stopSearch();
        boolean activateVoiceSearch = RecognizerResultsIntent
                .ACTION_VOICE_SEARCH_RESULTS.equals(action);
        if (Intent.ACTION_VIEW.equals(action)
                || Intent.ACTION_SEARCH.equals(action)
                || MediaStore.INTENT_ACTION_MEDIA_SEARCH.equals(action)
                || Intent.ACTION_WEB_SEARCH.equals(action)
                || activateVoiceSearch) {
            if (current.isInVoiceSearchMode()) {
                String title = current.getVoiceDisplayTitle();
                if (title != null && title.equals(intent.getStringExtra(
                        SearchManager.QUERY))) {
                    // The user submitted the same search as the last voice
                    // search, so do nothing.
                    return;
                }
                if (Intent.ACTION_SEARCH.equals(action)
                        && current.voiceSearchSourceIsGoogle()) {
                    Intent logIntent = new Intent(
                            LoggingEvents.ACTION_LOG_EVENT);
                    logIntent.putExtra(LoggingEvents.EXTRA_EVENT,
                            LoggingEvents.VoiceSearch.QUERY_UPDATED);
                    logIntent.putExtra(
                            LoggingEvents.VoiceSearch.EXTRA_QUERY_UPDATED_VALUE,
                            intent.getDataString());
                    sendBroadcast(logIntent);
                    // Note, onPageStarted will revert the voice title bar
                    // When http://b/issue?id=2379215 is fixed, we should update
                    // the title bar here.
                }
            }
            // If this was a search request (e.g. search query directly typed into the address bar),
            // pass it on to the default web search provider.
            if (handleWebSearchIntent(intent)) {
                return;
            }

            UrlData urlData = getUrlDataFromIntent(intent);
            if (urlData.isEmpty()) {
                urlData = new UrlData(mSettings.getHomePage());
            }

            final String appId = intent
                    .getStringExtra(Browser.EXTRA_APPLICATION_ID);
            if ((Intent.ACTION_VIEW.equals(action)
                    // If a voice search has no appId, it means that it came
                    // from the browser.  In that case, reuse the current tab.
                    || (activateVoiceSearch && appId != null))
                    && !getPackageName().equals(appId)
                    && (flags & Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT) != 0) {
                Tab appTab = mTabControl.getTabFromId(appId);
                if (appTab != null) {
                    Log.i(LOGTAG, ""Reusing tab for "" + appId);
                    // Dismiss the subwindow if applicable.
                    dismissSubWindow(appTab);
                    // Since we might kill the WebView, remove it from the
                    // content view first.
                    removeTabFromContentView(appTab);
                    // Recreate the main WebView after destroying the old one.
                    // If the WebView has the same original url and is on that
                    // page, it can be reused.
                    boolean needsLoad =
                            mTabControl.recreateWebView(appTab, urlData);

                    if (current != appTab) {
                        switchToTab(mTabControl.getTabIndex(appTab));
                        if (needsLoad) {
                            loadUrlDataIn(appTab, urlData);
                        }
                    } else {
                        // If the tab was the current tab, we have to attach
                        // it to the view system again.
                        attachTabToContentView(appTab);
                        if (needsLoad) {
                            loadUrlDataIn(appTab, urlData);
                        }
                    }
                    return;
                } else {
                    // No matching application tab, try to find a regular tab
                    // with a matching url.
                    appTab = mTabControl.findUnusedTabWithUrl(urlData.mUrl);
                    if (appTab != null) {
                        if (current != appTab) {
                            switchToTab(mTabControl.getTabIndex(appTab));
                        }
                        // Otherwise, we are already viewing the correct tab.
                    } else {
                        // if FLAG_ACTIVITY_BROUGHT_TO_FRONT flag is on, the url
                        // will be opened in a new tab unless we have reached
                        // MAX_TABS. Then the url will be opened in the current
                        // tab. If a new tab is created, it will have ""true"" for
                        // exit on close.
                        openTabAndShow(urlData, true, appId);
                    }
                }
            } else {
                if (!urlData.isEmpty()
                        && urlData.mUrl.startsWith(""about:debug"")) {
                    if (""about:debug.dom"".equals(urlData.mUrl)) {
                        current.getWebView().dumpDomTree(false);
                    } else if (""about:debug.dom.file"".equals(urlData.mUrl)) {
                        current.getWebView().dumpDomTree(true);
                    } else if (""about:debug.render"".equals(urlData.mUrl)) {
                        current.getWebView().dumpRenderTree(false);
                    } else if (""about:debug.render.file"".equals(urlData.mUrl)) {
                        current.getWebView().dumpRenderTree(true);
                    } else if (""about:debug.display"".equals(urlData.mUrl)) {
                        current.getWebView().dumpDisplayTree();
                    } else if (urlData.mUrl.startsWith(""about:debug.drag"")) {
                        int index = urlData.mUrl.codePointAt(16) - '0';
                        if (index <= 0 || index > 9) {
                            current.getWebView().setDragTracker(null);
                        } else {
                            current.getWebView().setDragTracker(new MeshTracker(index));
                        }
                    } else {
                        mSettings.toggleDebugSettings();
                    }
                    return;
                }
                // Get rid of the subwindow if it exists
                dismissSubWindow(current);
                // If the current Tab is being used as an application tab,
                // remove the association, since the new Intent means that it is
                // no longer associated with that application.
                current.setAppId(null);
                loadUrlDataIn(current, urlData);
            }
        }
    }

    /**
     * Launches the default web search activity with the query parameters if the given intent's data
     * are identified as plain search terms and not URLs/shortcuts.
     * @return true if the intent was handled and web search activity was launched, false if not.
     */
    private boolean handleWebSearchIntent(Intent intent) {
        if (intent == null) return false;

        String url = null;
        final String action = intent.getAction();
        if (RecognizerResultsIntent.ACTION_VOICE_SEARCH_RESULTS.equals(
                action)) {
            return false;
        }
        if (Intent.ACTION_VIEW.equals(action)) {
            Uri data = intent.getData();
            if (data != null) url = data.toString();
        } else if (Intent.ACTION_SEARCH.equals(action)
                || MediaStore.INTENT_ACTION_MEDIA_SEARCH.equals(action)
                || Intent.ACTION_WEB_SEARCH.equals(action)) {
            url = intent.getStringExtra(SearchManager.QUERY);
        }
        return handleWebSearchRequest(url, intent.getBundleExtra(SearchManager.APP_DATA),
                intent.getStringExtra(SearchManager.EXTRA_DATA_KEY));
    }

    /**
     * Launches the default web search activity with the query parameters if the given url string
     * was identified as plain search terms and not URL/shortcut.
     * @return true if the request was handled and web search activity was launched, false if not.
     */
    private boolean handleWebSearchRequest(String inUrl, Bundle appData, String extraData) {
        if (inUrl == null) return false;

        // In general, we shouldn't modify URL from Intent.
        // But currently, we get the user-typed URL from search box as well.
        String url = fixUrl(inUrl).trim();

        // URLs are handled by the regular flow of control, so
        // return early.
        if (Patterns.WEB_URL.matcher(url).matches()
                || ACCEPTED_URI_SCHEMA.matcher(url).matches()) {
            return false;
        }

        final ContentResolver cr = mResolver;
        final String newUrl = url;
        new AsyncTask<Void, Void, Void>() {
            protected Void doInBackground(Void... unused) {
                Browser.updateVisitedHistory(cr, newUrl, false);
                Browser.addSearchUrl(cr, newUrl);
                return null;
            }
        }.execute();

        SearchEngine searchEngine = mSettings.getSearchEngine();
        if (searchEngine == null) return false;
        searchEngine.startSearch(this, url, appData, extraData);

        return true;
    }

    private UrlData getUrlDataFromIntent(Intent intent) {
        String url = """";
        Map<String, String> headers = null;
        if (intent != null) {
            final String action = intent.getAction();
            if (Intent.ACTION_VIEW.equals(action)) {
                url = smartUrlFilter(intent.getData());
                if (url != null && url.startsWith(""content:"")) {
                    /* Append mimetype so webview knows how to display */
                    String mimeType = intent.resolveType(getContentResolver());
                    if (mimeType != null) {
                        url += ""?"" + mimeType;
                    }
                }
                if (url != null && url.startsWith(""http"")) {
                    final Bundle pairs = intent
                            .getBundleExtra(Browser.EXTRA_HEADERS);
                    if (pairs != null && !pairs.isEmpty()) {
                        Iterator<String> iter = pairs.keySet().iterator();
                        headers = new HashMap<String, String>();
                        while (iter.hasNext()) {
                            String key = iter.next();
                            headers.put(key, pairs.getString(key));
                        }
                    }
                }
            } else if (Intent.ACTION_SEARCH.equals(action)
                    || MediaStore.INTENT_ACTION_MEDIA_SEARCH.equals(action)
                    || Intent.ACTION_WEB_SEARCH.equals(action)) {
                url = intent.getStringExtra(SearchManager.QUERY);
                if (url != null) {
                    mLastEnteredUrl = url;
                    // In general, we shouldn't modify URL from Intent.
                    // But currently, we get the user-typed URL from search box as well.
                    url = fixUrl(url);
                    url = smartUrlFilter(url);
                    final ContentResolver cr = mResolver;
                    final String newUrl = url;
                    new AsyncTask<Void, Void, Void>() {
                        protected Void doInBackground(Void... unused) {
                            Browser.updateVisitedHistory(cr, newUrl, false);
                            return null;
                        }
                    }.execute();
                    String searchSource = ""&source=android-"" + GOOGLE_SEARCH_SOURCE_SUGGEST + ""&"";
                    if (url.contains(searchSource)) {
                        String source = null;
                        final Bundle appData = intent.getBundleExtra(SearchManager.APP_DATA);
                        if (appData != null) {
                            source = appData.getString(Search.SOURCE);
                        }
                        if (TextUtils.isEmpty(source)) {
                            source = GOOGLE_SEARCH_SOURCE_UNKNOWN;
                        }
                        url = url.replace(searchSource, ""&source=android-""+source+""&"");
                    }
                }
            }
        }
        return new UrlData(url, headers, intent);
    }
    /* package */ void showVoiceTitleBar(String title) {
        mTitleBar.setInVoiceMode(true);
        mFakeTitleBar.setInVoiceMode(true);

        mTitleBar.setDisplayTitle(title);
        mFakeTitleBar.setDisplayTitle(title);
    }
    /* package */ void revertVoiceTitleBar() {
        mTitleBar.setInVoiceMode(false);
        mFakeTitleBar.setInVoiceMode(false);

        mTitleBar.setDisplayTitle(mUrl);
        mFakeTitleBar.setDisplayTitle(mUrl);
    }
    /* package */ static String fixUrl(String inUrl) {
        // FIXME: Converting the url to lower case
        // duplicates functionality in smartUrlFilter().
        // However, changing all current callers of fixUrl to
        // call smartUrlFilter in addition may have unwanted
        // consequences, and is deferred for now.
        int colon = inUrl.indexOf(':');
        boolean allLower = true;
        for (int index = 0; index < colon; index++) {
            char ch = inUrl.charAt(index);
            if (!Character.isLetter(ch)) {
                break;
            }
            allLower &= Character.isLowerCase(ch);
            if (index == colon - 1 && !allLower) {
                inUrl = inUrl.substring(0, colon).toLowerCase()
                        + inUrl.substring(colon);
            }
        }
        if (inUrl.startsWith(""http://"") || inUrl.startsWith(""https://""))
            return inUrl;
        if (inUrl.startsWith(""http:"") ||
                inUrl.startsWith(""https:"")) {
            if (inUrl.startsWith(""http:/"") || inUrl.startsWith(""https:/"")) {
                inUrl = inUrl.replaceFirst(""/"", ""//"");
            } else inUrl = inUrl.replaceFirst("":"", ""://"");
        }
        return inUrl;
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (LOGV_ENABLED) {
            Log.v(LOGTAG, ""BrowserActivity.onResume: this="" + this);
        }

        if (!mActivityInPause) {
            Log.e(LOGTAG, ""BrowserActivity is already resumed."");
            return;
        }

        mTabControl.resumeCurrentTab();
        mActivityInPause = false;
        resumeWebViewTimers();

        if (mWakeLock.isHeld()) {
            mHandler.removeMessages(RELEASE_WAKELOCK);
            mWakeLock.release();
        }

        registerReceiver(mNetworkStateIntentReceiver,
                         mNetworkStateChangedFilter);
        WebView.enablePlatformNotifications();
    }

    /**
     * Since the actual title bar is embedded in the WebView, and removing it
     * would change its appearance, use a different TitleBar to show overlayed
     * at the top of the screen, when the menu is open or the page is loading.
     */
    private TitleBar mFakeTitleBar;

    /**
     * Keeps track of whether the options menu is open.  This is important in
     * determining whether to show or hide the title bar overlay.
     */
    private boolean mOptionsMenuOpen;

    /**
     * Only meaningful when mOptionsMenuOpen is true.  This variable keeps track
     * of whether the configuration has changed.  The first onMenuOpened call
     * after a configuration change is simply a reopening of the same menu
     * (i.e. mIconView did not change).
     */
    private boolean mConfigChanged;

    /**
     * Whether or not the options menu is in its smaller, icon menu form.  When
     * true, we want the title bar overlay to be up.  When false, we do not.
     * Only meaningful if mOptionsMenuOpen is true.
     */
    private boolean mIconView;

    @Override
    public boolean onMenuOpened(int featureId, Menu menu) {
        if (Window.FEATURE_OPTIONS_PANEL == featureId) {
            if (mOptionsMenuOpen) {
                if (mConfigChanged) {
                    // We do not need to make any changes to the state of the
                    // title bar, since the only thing that happened was a
                    // change in orientation
                    mConfigChanged = false;
                } else {
                    if (mIconView) {
                        // Switching the menu to expanded view, so hide the
                        // title bar.
                        hideFakeTitleBar();
                        mIconView = false;
                    } else {
                        // Switching the menu back to icon view, so show the
                        // title bar once again.
                        showFakeTitleBar();
                        mIconView = true;
                    }
                }
            } else {
                // The options menu is closed, so open it, and show the title
                showFakeTitleBar();
                mOptionsMenuOpen = true;
                mConfigChanged = false;
                mIconView = true;
            }
        }
        return true;
    }

    private void showFakeTitleBar() {
        if (mFakeTitleBar.getParent() == null && mActiveTabsPage == null
                && !mActivityInPause) {
            WebView mainView = mTabControl.getCurrentWebView();
            // if there is no current WebView, don't show the faked title bar;
            if (mainView == null) {
                return;
            }
            // Do not need to check for null, since the current tab will have
            // at least a main WebView, or we would have returned above.
            if (dialogIsUp()) {
                // Do not show the fake title bar, which would cover up the
                // find or select dialog.
                return;
            }

            WindowManager manager
                    = (WindowManager) getSystemService(Context.WINDOW_SERVICE);

            // Add the title bar to the window manager so it can receive touches
            // while the menu is up
            WindowManager.LayoutParams params
                    = new WindowManager.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT,
                    WindowManager.LayoutParams.TYPE_APPLICATION,
                    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,
                    PixelFormat.TRANSLUCENT);
            params.gravity = Gravity.TOP;
            boolean atTop = mainView.getScrollY() == 0;
            params.windowAnimations = atTop ? 0 : R.style.TitleBar;
            manager.addView(mFakeTitleBar, params);
        }
    }

    @Override
    public void onOptionsMenuClosed(Menu menu) {
        mOptionsMenuOpen = false;
        if (!mInLoad) {
            hideFakeTitleBar();
        } else if (!mIconView) {
            // The page is currently loading, and we are in expanded mode, so
            // we were not showing the menu.  Show it once again.  It will be
            // removed when the page finishes.
            showFakeTitleBar();
        }
    }

    private void hideFakeTitleBar() {
        if (mFakeTitleBar.getParent() == null) return;
        WindowManager.LayoutParams params = (WindowManager.LayoutParams)
                mFakeTitleBar.getLayoutParams();
        WebView mainView = mTabControl.getCurrentWebView();
        // Although we decided whether or not to animate based on the current
        // scroll position, the scroll position may have changed since the
        // fake title bar was displayed.  Make sure it has the appropriate
        // animation/lack thereof before removing.
        params.windowAnimations = mainView != null && mainView.getScrollY() == 0
                ? 0 : R.style.TitleBar;
        WindowManager manager
                    = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
        manager.updateViewLayout(mFakeTitleBar, params);
        manager.removeView(mFakeTitleBar);
    }

    /**
     * Special method for the fake title bar to call when displaying its context
     * menu, since it is in its own Window, and its parent does not show a
     * context menu.
     */
    /* package */ void showTitleBarContextMenu() {
        if (null == mTitleBar.getParent()) {
            return;
        }
        openContextMenu(mTitleBar);
    }

    @Override
    public void onContextMenuClosed(Menu menu) {
        super.onContextMenuClosed(menu);
        if (mInLoad) {
            showFakeTitleBar();
        }
    }

    /**
     *  onSaveInstanceState(Bundle map)
     *  onSaveInstanceState is called right before onStop(). The map contains
     *  the saved state.
     */
    @Override
    protected void onSaveInstanceState(Bundle outState) {
        if (LOGV_ENABLED) {
            Log.v(LOGTAG, ""BrowserActivity.onSaveInstanceState: this="" + this);
        }
        // the default implementation requires each view to have an id. As the
        // browser handles the state itself and it doesn't use id for the views,
        // don't call the default implementation. Otherwise it will trigger the
        // warning like this, ""couldn't save which view has focus because the
        // focused view XXX has no id"".

        // Save all the tabs
        mTabControl.saveState(outState);
    }

    @Override
    protected void onPause() {
        super.onPause();

        if (mActivityInPause) {
            Log.e(LOGTAG, ""BrowserActivity is already paused."");
            return;
        }

        mTabControl.pauseCurrentTab();
        mActivityInPause = true;
        if (mTabControl.getCurrentIndex() >= 0 && !pauseWebViewTimers()) {
            mWakeLock.acquire();
            mHandler.sendMessageDelayed(mHandler
                    .obtainMessage(RELEASE_WAKELOCK), WAKELOCK_TIMEOUT);
        }

        // FIXME: This removes the active tabs page and resets the menu to
        // MAIN_MENU.  A better solution might be to do this work in onNewIntent
        // but then we would need to save it in onSaveInstanceState and restore
        // it in onCreate/onRestoreInstanceState
        if (mActiveTabsPage != null) {
            removeActiveTabPage(true);
        }

        cancelStopToast();

        // unregister network state listener
        unregisterReceiver(mNetworkStateIntentReceiver);
        WebView.disablePlatformNotifications();

        if (mCustomView != null) {
            mTabControl.getCurrentWebView().getWebChromeClient().onHideCustomView();
        }
    }

    @Override
    protected void onDestroy() {
        if (LOGV_ENABLED) {
            Log.v(LOGTAG, ""BrowserActivity.onDestroy: this="" + this);
        }
        super.onDestroy();

        if (mUploadMessage != null) {
            mUploadMessage.onReceiveValue(null);
            mUploadMessage = null;
        }

        if (mTabControl == null) return;

        // Remove the fake title bar if it is there
        hideFakeTitleBar();

        // Remove the current tab and sub window
        Tab t = mTabControl.getCurrentTab();
        if (t != null) {
            dismissSubWindow(t);
            removeTabFromContentView(t);
        }
        // Destroy all the tabs
        mTabControl.destroy();
        WebIconDatabase.getInstance().close();

        unregisterReceiver(mPackageInstallationReceiver);

        // Stop watching the default geolocation permissions
        mSystemAllowGeolocationOrigins.stop();
        mSystemAllowGeolocationOrigins = null;
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        mConfigChanged = true;
        super.onConfigurationChanged(newConfig);

        if (mPageInfoDialog != null) {
            mPageInfoDialog.dismiss();
            showPageInfo(
                mPageInfoView,
                mPageInfoFromShowSSLCertificateOnError);
        }
        if (mSSLCertificateDialog != null) {
            mSSLCertificateDialog.dismiss();
            showSSLCertificate(
                mSSLCertificateView);
        }
        if (mSSLCertificateOnErrorDialog != null) {
            mSSLCertificateOnErrorDialog.dismiss();
            showSSLCertificateOnError(
                mSSLCertificateOnErrorView,
                mSSLCertificateOnErrorHandler,
                mSSLCertificateOnErrorError);
        }
        if (mHttpAuthenticationDialog != null) {
            String title = ((TextView) mHttpAuthenticationDialog
                    .findViewById(com.android.internal.R.id.alertTitle)).getText()
                    .toString();
            String name = ((TextView) mHttpAuthenticationDialog
                    .findViewById(R.id.username_edit)).getText().toString();
            String password = ((TextView) mHttpAuthenticationDialog
                    .findViewById(R.id.password_edit)).getText().toString();
            int focusId = mHttpAuthenticationDialog.getCurrentFocus()
                    .getId();
            mHttpAuthenticationDialog.dismiss();
            showHttpAuthentication(mHttpAuthHandler, null, null, title,
                    name, password, focusId);
        }
    }

    @Override
    public void onLowMemory() {
        super.onLowMemory();
        mTabControl.freeMemory();
    }

    private void resumeWebViewTimers() {
        Tab tab = mTabControl.getCurrentTab();
        if (tab == null) return; // monkey can trigger this
        boolean inLoad = tab.inLoad();
        if ((!mActivityInPause && !inLoad) || (mActivityInPause && inLoad)) {
            CookieSyncManager.getInstance().startSync();
            WebView w = tab.getWebView();
            if (w != null) {
                w.resumeTimers();
            }
        }
    }

    private boolean pauseWebViewTimers() {
        Tab tab = mTabControl.getCurrentTab();
        boolean inLoad = tab.inLoad();
        if (mActivityInPause && !inLoad) {
            CookieSyncManager.getInstance().stopSync();
            WebView w = mTabControl.getCurrentWebView();
            if (w != null) {
                w.pauseTimers();
            }
            return true;
        } else {
            return false;
        }
    }

    // Open the icon database and retain all the icons for visited sites.
    private void retainIconsOnStartup() {
        final WebIconDatabase db = WebIconDatabase.getInstance();
        db.open(getDir(""icons"", 0).getPath());
        Cursor c = null;
        try {
            c = Browser.getAllBookmarks(mResolver);
            if (c.moveToFirst()) {
                int urlIndex = c.getColumnIndex(Browser.BookmarkColumns.URL);
                do {
                    String url = c.getString(urlIndex);
                    db.retainIconForPageUrl(url);
                } while (c.moveToNext());
            }
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, ""retainIconsOnStartup"", e);
        } finally {
            if (c!= null) c.close();
        }
    }

    // Helper method for getting the top window.
    WebView getTopWindow() {
        return mTabControl.getCurrentTopWebView();
    }

    TabControl getTabControl() {
        return mTabControl;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);

        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.browser, menu);
        mMenu = menu;
        updateInLoadMenuItems();
        return true;
    }

    /**
     * As the menu can be open when loading state changes
     * we must manually update the state of the stop/reload menu
     * item
     */
    private void updateInLoadMenuItems() {
        if (mMenu == null) {
            return;
        }
        MenuItem src = mInLoad ?
                mMenu.findItem(R.id.stop_menu_id):
                    mMenu.findItem(R.id.reload_menu_id);
        MenuItem dest = mMenu.findItem(R.id.stop_reload_menu_id);
        dest.setIcon(src.getIcon());
        dest.setTitle(src.getTitle());
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        // chording is not an issue with context menus, but we use the same
        // options selector, so set mCanChord to true so we can access them.
        mCanChord = true;
        int id = item.getItemId();
        boolean result = true;
        switch (id) {
            // For the context menu from the title bar
            case R.id.title_bar_copy_page_url:
                Tab currentTab = mTabControl.getCurrentTab();
                if (null == currentTab) {
                    result = false;
                    break;
                }
                WebView mainView = currentTab.getWebView();
                if (null == mainView) {
                    result = false;
                    break;
                }
                copy(mainView.getUrl());
                break;
            // -- Browser context menu
            case R.id.open_context_menu_id:
            case R.id.open_newtab_context_menu_id:
            case R.id.bookmark_context_menu_id:
            case R.id.save_link_context_menu_id:
            case R.id.share_link_context_menu_id:
            case R.id.copy_link_context_menu_id:
                final WebView webView = getTopWindow();
                if (null == webView) {
                    result = false;
                    break;
                }
                final HashMap hrefMap = new HashMap();
                hrefMap.put(""webview"", webView);
                final Message msg = mHandler.obtainMessage(
                        FOCUS_NODE_HREF, id, 0, hrefMap);
                webView.requestFocusNodeHref(msg);
                break;

            default:
                // For other context menus
                result = onOptionsItemSelected(item);
        }
        mCanChord = false;
        return result;
    }

    private Bundle createGoogleSearchSourceBundle(String source) {
        Bundle bundle = new Bundle();
        bundle.putString(Search.SOURCE, source);
        return bundle;
    }

    /* package */ void editUrl() {
        if (mOptionsMenuOpen) closeOptionsMenu();
        String url = (getTopWindow() == null) ? null : getTopWindow().getUrl();
        startSearch(mSettings.getHomePage().equals(url) ? null : url, true,
                null, false);
    }

    /**
     * Overriding this to insert a local information bundle
     */
    @Override
    public void startSearch(String initialQuery, boolean selectInitialQuery,
            Bundle appSearchData, boolean globalSearch) {
        if (appSearchData == null) {
            appSearchData = createGoogleSearchSourceBundle(GOOGLE_SEARCH_SOURCE_TYPE);
        }

        SearchEngine searchEngine = mSettings.getSearchEngine();
        if (searchEngine != null && !searchEngine.supportsVoiceSearch()) {
            appSearchData.putBoolean(SearchManager.DISABLE_VOICE_SEARCH, true);
        }

        super.startSearch(initialQuery, selectInitialQuery, appSearchData, globalSearch);
    }

    /**
     * Switch tabs.  Called by the TitleBarSet when sliding the title bar
     * results in changing tabs.
     * @param index Index of the tab to change to, as defined by
     *              mTabControl.getTabIndex(Tab t).
     * @return boolean True if we successfully switched to a different tab.  If
     *                 the indexth tab is null, or if that tab is the same as
     *                 the current one, return false.
     */
    /* package */ boolean switchToTab(int index) {
        Tab tab = mTabControl.getTab(index);
        Tab currentTab = mTabControl.getCurrentTab();
        if (tab == null || tab == currentTab) {
            return false;
        }
        if (currentTab != null) {
            // currentTab may be null if it was just removed.  In that case,
            // we do not need to remove it
            removeTabFromContentView(currentTab);
        }
        mTabControl.setCurrentTab(tab);
        attachTabToContentView(tab);
        resetTitleIconAndProgress();
        updateLockIconToLatest();
        return true;
    }

    /* package */ Tab openTabToHomePage() {
        return openTabAndShow(mSettings.getHomePage(), false, null);
    }

    /* package */ void closeCurrentWindow() {
        final Tab current = mTabControl.getCurrentTab();
        if (mTabControl.getTabCount() == 1) {
            // This is the last tab.  Open a new one, with the home
            // page and close the current one.
            openTabToHomePage();
            closeTab(current);
            return;
        }
        final Tab parent = current.getParentTab();
        int indexToShow = -1;
        if (parent != null) {
            indexToShow = mTabControl.getTabIndex(parent);
        } else {
            final int currentIndex = mTabControl.getCurrentIndex();
            // Try to move to the tab to the right
            indexToShow = currentIndex + 1;
            if (indexToShow > mTabControl.getTabCount() - 1) {
                // Try to move to the tab to the left
                indexToShow = currentIndex - 1;
            }
        }
        if (switchToTab(indexToShow)) {
            // Close window
            closeTab(current);
        }
    }

    private ActiveTabsPage mActiveTabsPage;

    /**
     * Remove the active tabs page.
     * @param needToAttach If true, the active tabs page did not attach a tab
     *                     to the content view, so we need to do that here.
     */
    /* package */ void removeActiveTabPage(boolean needToAttach) {
        mContentView.removeView(mActiveTabsPage);
        mActiveTabsPage = null;
        mMenuState = R.id.MAIN_MENU;
        if (needToAttach) {
            attachTabToContentView(mTabControl.getCurrentTab());
        }
        getTopWindow().requestFocus();
    }

    private WebView showDialog(WebDialog dialog) {
        Tab tab = mTabControl.getCurrentTab();
        if (tab.getSubWebView() == null) {
            // If the find or select is being performed on the main webview,
            // remove the embedded title bar.
            WebView mainView = tab.getWebView();
            if (mainView != null) {
                mainView.setEmbeddedTitleBar(null);
            }
        }
        hideFakeTitleBar();
        mMenuState = EMPTY_MENU;
        return tab.showDialog(dialog);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (!mCanChord) {
            // The user has already fired a shortcut with this hold down of the
            // menu key.
            return false;
        }
        if (null == getTopWindow()) {
            return false;
        }
        if (mMenuIsDown) {
            // The shortcut action consumes the MENU. Even if it is still down,
            // it won't trigger the next shortcut action. In the case of the
            // shortcut action triggering a new activity, like Bookmarks, we
            // won't get onKeyUp for MENU. So it is important to reset it here.
            mMenuIsDown = false;
        }
        switch (item.getItemId()) {
            // -- Main menu
            case R.id.new_tab_menu_id:
                openTabToHomePage();
                break;

            case R.id.goto_menu_id:
                editUrl();
                break;

            case R.id.bookmarks_menu_id:
                bookmarksOrHistoryPicker(false);
                break;

            case R.id.active_tabs_menu_id:
                mActiveTabsPage = new ActiveTabsPage(this, mTabControl);
                removeTabFromContentView(mTabControl.getCurrentTab());
                hideFakeTitleBar();
                mContentView.addView(mActiveTabsPage, COVER_SCREEN_PARAMS);
                mActiveTabsPage.requestFocus();
                mMenuState = EMPTY_MENU;
                break;

            case R.id.add_bookmark_menu_id:
                Intent i = new Intent(BrowserActivity.this,
                        AddBookmarkPage.class);
                WebView w = getTopWindow();
                i.putExtra(""url"", w.getUrl());
                i.putExtra(""title"", w.getTitle());
                i.putExtra(""touch_icon_url"", w.getTouchIconUrl());
                i.putExtra(""thumbnail"", createScreenshot(w));
                startActivity(i);
                break;

            case R.id.stop_reload_menu_id:
                if (mInLoad) {
                    stopLoading();
                } else {
                    getTopWindow().reload();
                }
                break;

            case R.id.back_menu_id:
                getTopWindow().goBack();
                break;

            case R.id.forward_menu_id:
                getTopWindow().goForward();
                break;

            case R.id.close_menu_id:
                // Close the subwindow if it exists.
                if (mTabControl.getCurrentSubWindow() != null) {
                    dismissSubWindow(mTabControl.getCurrentTab());
                    break;
                }
                closeCurrentWindow();
                break;

            case R.id.homepage_menu_id:
                Tab current = mTabControl.getCurrentTab();
                if (current != null) {
                    dismissSubWindow(current);
                    loadUrl(current.getWebView(), mSettings.getHomePage());
                }
                break;

            case R.id.preferences_menu_id:
                Intent intent = new Intent(this,
                        BrowserPreferencesPage.class);
                intent.putExtra(BrowserPreferencesPage.CURRENT_PAGE,
                        getTopWindow().getUrl());
                startActivityForResult(intent, PREFERENCES_PAGE);
                break;

            case R.id.find_menu_id:
                showFindDialog();
                break;

            case R.id.select_text_id:
                if (true) {
                    Tab currentTab = mTabControl.getCurrentTab();
                    if (currentTab != null) {
                        currentTab.getWebView().setUpSelect();
                    }
                } else {
                    showSelectDialog();
                }
                break;

            case R.id.page_info_menu_id:
                showPageInfo(mTabControl.getCurrentTab(), false);
                break;

            case R.id.classic_history_menu_id:
                bookmarksOrHistoryPicker(true);
                break;

            case R.id.title_bar_share_page_url:
            case R.id.share_page_menu_id:
                Tab currentTab = mTabControl.getCurrentTab();
                if (null == currentTab) {
                    mCanChord = false;
                    return false;
                }
                currentTab.populatePickerData();
                sharePage(this, currentTab.getTitle(),
                        currentTab.getUrl(), currentTab.getFavicon(),
                        createScreenshot(currentTab.getWebView()));
                break;

            case R.id.dump_nav_menu_id:
                getTopWindow().debugDump();
                break;

            case R.id.dump_counters_menu_id:
                getTopWindow().dumpV8Counters();
                break;

            case R.id.zoom_in_menu_id:
                getTopWindow().zoomIn();
                break;

            case R.id.zoom_out_menu_id:
                getTopWindow().zoomOut();
                break;

            case R.id.view_downloads_menu_id:
                viewDownloads();
                break;

            case R.id.window_one_menu_id:
            case R.id.window_two_menu_id:
            case R.id.window_three_menu_id:
            case R.id.window_four_menu_id:
            case R.id.window_five_menu_id:
            case R.id.window_six_menu_id:
            case R.id.window_seven_menu_id:
            case R.id.window_eight_menu_id:
                {
                    int menuid = item.getItemId();
                    for (int id = 0; id < WINDOW_SHORTCUT_ID_ARRAY.length; id++) {
                        if (WINDOW_SHORTCUT_ID_ARRAY[id] == menuid) {
                            Tab desiredTab = mTabControl.getTab(id);
                            if (desiredTab != null &&
                                    desiredTab != mTabControl.getCurrentTab()) {
                                switchToTab(id);
                            }
                            break;
                        }
                    }
                }
                break;

            default:
                if (!super.onOptionsItemSelected(item)) {
                    return false;
                }
                // Otherwise fall through.
        }
        mCanChord = false;
        return true;
    }

    private boolean dialogIsUp() {
        return null != mFindDialog && mFindDialog.isVisible() ||
            null != mSelectDialog && mSelectDialog.isVisible();
    }

    private boolean closeDialog(WebDialog dialog) {
        if (null == dialog || !dialog.isVisible()) return false;
        Tab currentTab = mTabControl.getCurrentTab();
        currentTab.closeDialog(dialog);
        dialog.dismiss();
        return true;
    }

    /*
     * Remove the find dialog or select dialog.
     */
    public void closeDialogs() {
        if (!(closeDialog(mFindDialog) || closeDialog(mSelectDialog))) return;
        // If the Find was being performed in the main WebView, replace the
        // embedded title bar.
        Tab currentTab = mTabControl.getCurrentTab();
        if (currentTab.getSubWebView() == null) {
            WebView mainView = currentTab.getWebView();
            if (mainView != null) {
                mainView.setEmbeddedTitleBar(mTitleBar);
            }
        }
        mMenuState = R.id.MAIN_MENU;
        if (mInLoad) {
            // The title bar was hidden, because otherwise it would cover up the
            // find or select dialog.  Now that the dialog has been removed,
            // show the fake title bar once again.
            showFakeTitleBar();
        }
    }

    public void showFindDialog() {
        if (null == mFindDialog) {
            mFindDialog = new FindDialog(this);
        }
        showDialog(mFindDialog).setFindIsUp(true);
    }

    public void setFindDialogText(String text) {
        mFindDialog.setText(text);
    }

    public void showSelectDialog() {
        if (null == mSelectDialog) {
            mSelectDialog = new SelectDialog(this);
        }
        showDialog(mSelectDialog).setUpSelect();
        mSelectDialog.hideSoftInput();
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        // This happens when the user begins to hold down the menu key, so
        // allow them to chord to get a shortcut.
        mCanChord = true;
        // Note: setVisible will decide whether an item is visible; while
        // setEnabled() will decide whether an item is enabled, which also means
        // whether the matching shortcut key will function.
        super.onPrepareOptionsMenu(menu);
        switch (mMenuState) {
            case EMPTY_MENU:
                if (mCurrentMenuState != mMenuState) {
                    menu.setGroupVisible(R.id.MAIN_MENU, false);
                    menu.setGroupEnabled(R.id.MAIN_MENU, false);
                    menu.setGroupEnabled(R.id.MAIN_SHORTCUT_MENU, false);
                }
                break;
            default:
                if (mCurrentMenuState != mMenuState) {
                    menu.setGroupVisible(R.id.MAIN_MENU, true);
                    menu.setGroupEnabled(R.id.MAIN_MENU, true);
                    menu.setGroupEnabled(R.id.MAIN_SHORTCUT_MENU, true);
                }
                final WebView w = getTopWindow();
                boolean canGoBack = false;
                boolean canGoForward = false;
                boolean isHome = false;
                if (w != null) {
                    canGoBack = w.canGoBack();
                    canGoForward = w.canGoForward();
                    isHome = mSettings.getHomePage().equals(w.getUrl());
                }
                final MenuItem back = menu.findItem(R.id.back_menu_id);
                back.setEnabled(canGoBack);

                final MenuItem home = menu.findItem(R.id.homepage_menu_id);
                home.setEnabled(!isHome);

                menu.findItem(R.id.forward_menu_id)
                        .setEnabled(canGoForward);

                menu.findItem(R.id.new_tab_menu_id).setEnabled(
                        mTabControl.canCreateNewTab());

                // decide whether to show the share link option
                PackageManager pm = getPackageManager();
                Intent send = new Intent(Intent.ACTION_SEND);
                send.setType(""text/plain"");
                ResolveInfo ri = pm.resolveActivity(send, PackageManager.MATCH_DEFAULT_ONLY);
                menu.findItem(R.id.share_page_menu_id).setVisible(ri != null);

                boolean isNavDump = mSettings.isNavDump();
                final MenuItem nav = menu.findItem(R.id.dump_nav_menu_id);
                nav.setVisible(isNavDump);
                nav.setEnabled(isNavDump);

                boolean showDebugSettings = mSettings.showDebugSettings();
                final MenuItem counter = menu.findItem(R.id.dump_counters_menu_id);
                counter.setVisible(showDebugSettings);
                counter.setEnabled(showDebugSettings);

                break;
        }
        mCurrentMenuState = mMenuState;
        return true;
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
            ContextMenuInfo menuInfo) {
        if (v instanceof TitleBar) {
            return;
        }
        WebView webview = (WebView) v;
        WebView.HitTestResult result = webview.getHitTestResult();
        if (result == null) {
            return;
        }

        int type = result.getType();
        if (type == WebView.HitTestResult.UNKNOWN_TYPE) {
            Log.w(LOGTAG,
                    ""We should not show context menu when nothing is touched"");
            return;
        }
        if (type == WebView.HitTestResult.EDIT_TEXT_TYPE) {
            // let TextView handles context menu
            return;
        }

        // Note, http://b/issue?id=1106666 is requesting that
        // an inflated menu can be used again. This is not available
        // yet, so inflate each time (yuk!)
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.browsercontext, menu);

        // Show the correct menu group
        String extra = result.getExtra();
        menu.setGroupVisible(R.id.PHONE_MENU,
                type == WebView.HitTestResult.PHONE_TYPE);
        menu.setGroupVisible(R.id.EMAIL_MENU,
                type == WebView.HitTestResult.EMAIL_TYPE);
        menu.setGroupVisible(R.id.GEO_MENU,
                type == WebView.HitTestResult.GEO_TYPE);
        menu.setGroupVisible(R.id.IMAGE_MENU,
                type == WebView.HitTestResult.IMAGE_TYPE
                || type == WebView.HitTestResult.SRC_IMAGE_ANCHOR_TYPE);
        menu.setGroupVisible(R.id.ANCHOR_MENU,
                type == WebView.HitTestResult.SRC_ANCHOR_TYPE
                || type == WebView.HitTestResult.SRC_IMAGE_ANCHOR_TYPE);

        // Setup custom handling depending on the type
        switch (type) {
            case WebView.HitTestResult.PHONE_TYPE:
                menu.setHeaderTitle(Uri.decode(extra));
                menu.findItem(R.id.dial_context_menu_id).setIntent(
                        new Intent(Intent.ACTION_VIEW, Uri
                                .parse(WebView.SCHEME_TEL + extra)));
                Intent addIntent = new Intent(Intent.ACTION_INSERT_OR_EDIT);
                addIntent.putExtra(Insert.PHONE, Uri.decode(extra));
                addIntent.setType(ContactsContract.Contacts.CONTENT_ITEM_TYPE);
                menu.findItem(R.id.add_contact_context_menu_id).setIntent(
                        addIntent);
                menu.findItem(R.id.copy_phone_context_menu_id).setOnMenuItemClickListener(
                        new Copy(extra));
                break;

            case WebView.HitTestResult.EMAIL_TYPE:
                menu.setHeaderTitle(extra);
                menu.findItem(R.id.email_context_menu_id).setIntent(
                        new Intent(Intent.ACTION_VIEW, Uri
                                .parse(WebView.SCHEME_MAILTO + extra)));
                menu.findItem(R.id.copy_mail_context_menu_id).setOnMenuItemClickListener(
                        new Copy(extra));
                break;

            case WebView.HitTestResult.GEO_TYPE:
                menu.setHeaderTitle(extra);
                menu.findItem(R.id.map_context_menu_id).setIntent(
                        new Intent(Intent.ACTION_VIEW, Uri
                                .parse(WebView.SCHEME_GEO
                                        + URLEncoder.encode(extra))));
                menu.findItem(R.id.copy_geo_context_menu_id).setOnMenuItemClickListener(
                        new Copy(extra));
                break;

            case WebView.HitTestResult.SRC_ANCHOR_TYPE:
            case WebView.HitTestResult.SRC_IMAGE_ANCHOR_TYPE:
                TextView titleView = (TextView) LayoutInflater.from(this)
                        .inflate(android.R.layout.browser_link_context_header,
                        null);
                titleView.setText(extra);
                menu.setHeaderView(titleView);
                // decide whether to show the open link in new tab option
                menu.findItem(R.id.open_newtab_context_menu_id).setVisible(
                        mTabControl.canCreateNewTab());
                menu.findItem(R.id.bookmark_context_menu_id).setVisible(
                        Bookmarks.urlHasAcceptableScheme(extra));
                PackageManager pm = getPackageManager();
                Intent send = new Intent(Intent.ACTION_SEND);
                send.setType(""text/plain"");
                ResolveInfo ri = pm.resolveActivity(send, PackageManager.MATCH_DEFAULT_ONLY);
                menu.findItem(R.id.share_link_context_menu_id).setVisible(ri != null);
                if (type == WebView.HitTestResult.SRC_ANCHOR_TYPE) {
                    break;
                }
                // otherwise fall through to handle image part
            case WebView.HitTestResult.IMAGE_TYPE:
                if (type == WebView.HitTestResult.IMAGE_TYPE) {
                    menu.setHeaderTitle(extra);
                }
                menu.findItem(R.id.view_image_context_menu_id).setIntent(
                        new Intent(Intent.ACTION_VIEW, Uri.parse(extra)));
                menu.findItem(R.id.download_context_menu_id).
                        setOnMenuItemClickListener(new Download(extra));
                menu.findItem(R.id.set_wallpaper_context_menu_id).
                        setOnMenuItemClickListener(new SetAsWallpaper(extra));
                break;

            default:
                Log.w(LOGTAG, ""We should not get here."");
                break;
        }
        hideFakeTitleBar();
    }

    // Attach the given tab to the content view.
    // this should only be called for the current tab.
    private void attachTabToContentView(Tab t) {
        // Attach the container that contains the main WebView and any other UI
        // associated with the tab.
        t.attachTabToContentView(mContentView);

        if (mShouldShowErrorConsole) {
            ErrorConsoleView errorConsole = t.getErrorConsole(true);
            if (errorConsole.numberOfErrors() == 0) {
                errorConsole.showConsole(ErrorConsoleView.SHOW_NONE);
            } else {
                errorConsole.showConsole(ErrorConsoleView.SHOW_MINIMIZED);
            }

            mErrorConsoleContainer.addView(errorConsole,
                    new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
                                                  ViewGroup.LayoutParams.WRAP_CONTENT));
        }

        WebView view = t.getWebView();
        view.setEmbeddedTitleBar(mTitleBar);
        if (t.isInVoiceSearchMode()) {
            showVoiceTitleBar(t.getVoiceDisplayTitle());
        } else {
            revertVoiceTitleBar();
        }
        // Request focus on the top window.
        t.getTopWindow().requestFocus();
    }

    // Attach a sub window to the main WebView of the given tab.
    void attachSubWindow(Tab t) {
        t.attachSubWindow(mContentView);
        getTopWindow().requestFocus();
    }

    // Remove the given tab from the content view.
    private void removeTabFromContentView(Tab t) {
        // Remove the container that contains the main WebView.
        t.removeTabFromContentView(mContentView);

        ErrorConsoleView errorConsole = t.getErrorConsole(false);
        if (errorConsole != null) {
            mErrorConsoleContainer.removeView(errorConsole);
        }

        WebView view = t.getWebView();
        if (view != null) {
            view.setEmbeddedTitleBar(null);
        }
    }

    // Remove the sub window if it exists. Also called by TabControl when the
    // user clicks the 'X' to dismiss a sub window.
    /* package */ void dismissSubWindow(Tab t) {
        t.removeSubWindow(mContentView);
        // dismiss the subwindow. This will destroy the WebView.
        t.dismissSubWindow();
        getTopWindow().requestFocus();
    }

    // A wrapper function of {@link #openTabAndShow(UrlData, boolean, String)}
    // that accepts url as string.
    private Tab openTabAndShow(String url, boolean closeOnExit, String appId) {
        return openTabAndShow(new UrlData(url), closeOnExit, appId);
    }

    // This method does a ton of stuff. It will attempt to create a new tab
    // if we haven't reached MAX_TABS. Otherwise it uses the current tab. If
    // url isn't null, it will load the given url.
    /* package */Tab openTabAndShow(UrlData urlData, boolean closeOnExit,
            String appId) {
        final Tab currentTab = mTabControl.getCurrentTab();
        if (mTabControl.canCreateNewTab()) {
            final Tab tab = mTabControl.createNewTab(closeOnExit, appId,
                    urlData.mUrl);
            WebView webview = tab.getWebView();
            // If the last tab was removed from the active tabs page, currentTab
            // will be null.
            if (currentTab != null) {
                removeTabFromContentView(currentTab);
            }
            // We must set the new tab as the current tab to reflect the old
            // animation behavior.
            mTabControl.setCurrentTab(tab);
            attachTabToContentView(tab);
            if (!urlData.isEmpty()) {
                loadUrlDataIn(tab, urlData);
            }
            return tab;
        } else {
            // Get rid of the subwindow if it exists
            dismissSubWindow(currentTab);
            if (!urlData.isEmpty()) {
                // Load the given url.
                loadUrlDataIn(currentTab, urlData);
            }
            return currentTab;
        }
    }

    private Tab openTab(String url) {
        if (mSettings.openInBackground()) {
            Tab t = mTabControl.createNewTab();
            if (t != null) {
                WebView view = t.getWebView();
                loadUrl(view, url);
            }
            return t;
        } else {
            return openTabAndShow(url, false, null);
        }
    }

    private class Copy implements OnMenuItemClickListener {
        private CharSequence mText;

        public boolean onMenuItemClick(MenuItem item) {
            copy(mText);
            return true;
        }

        public Copy(CharSequence toCopy) {
            mText = toCopy;
        }
    }

    private class Download implements OnMenuItemClickListener {
        private String mText;

        public boolean onMenuItemClick(MenuItem item) {
            onDownloadStartNoStream(mText, null, null, null, -1);
            return true;
        }

        public Download(String toDownload) {
            mText = toDownload;
        }
    }

    private class SetAsWallpaper extends Thread implements
            OnMenuItemClickListener, DialogInterface.OnCancelListener {
        private URL mUrl;
        private ProgressDialog mWallpaperProgress;
        private boolean mCanceled = false;

        public SetAsWallpaper(String url) {
            try {
                mUrl = new URL(url);
            } catch (MalformedURLException e) {
                mUrl = null;
            }
        }

        public void onCancel(DialogInterface dialog) {
            mCanceled = true;
        }

        public boolean onMenuItemClick(MenuItem item) {
            if (mUrl != null) {
                // The user may have tried to set a image with a large file size as their
                // background so it may take a few moments to perform the operation. Display
                // a progress spinner while it is working.
                mWallpaperProgress = new ProgressDialog(BrowserActivity.this);
                mWallpaperProgress.setIndeterminate(true);
                mWallpaperProgress.setMessage(getText(R.string.progress_dialog_setting_wallpaper));
                mWallpaperProgress.setCancelable(true);
                mWallpaperProgress.setOnCancelListener(this);
                mWallpaperProgress.show();
                start();
            }
            return true;
        }

        public void run() {
            Drawable oldWallpaper = BrowserActivity.this.getWallpaper();
            try {
                // TODO: This will cause the resource to be downloaded again, when we
                // should in most cases be able to grab it from the cache. To fix this
                // we should query WebCore to see if we can access a cached version and
                // instead open an input stream on that. This pattern could also be used
                // in the download manager where the same problem exists.
                InputStream inputstream = mUrl.openStream();
                if (inputstream != null) {
                    setWallpaper(inputstream);
                }
            } catch (IOException e) {
                Log.e(LOGTAG, ""Unable to set new wallpaper"");
                // Act as though the user canceled the operation so we try to
                // restore the old wallpaper.
                mCanceled = true;
            }

            if (mCanceled) {
                // Restore the old wallpaper if the user cancelled whilst we were setting
                // the new wallpaper.
                int width = oldWallpaper.getIntrinsicWidth();
                int height = oldWallpaper.getIntrinsicHeight();
                Bitmap bm = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565);
                Canvas canvas = new Canvas(bm);
                oldWallpaper.setBounds(0, 0, width, height);
                oldWallpaper.draw(canvas);
                try {
                    setWallpaper(bm);
                } catch (IOException e) {
                    Log.e(LOGTAG, ""Unable to restore old wallpaper."");
                }
                mCanceled = false;
            }

            if (mWallpaperProgress.isShowing()) {
                mWallpaperProgress.dismiss();
            }
        }
    }

    private void copy(CharSequence text) {
        try {
            IClipboard clip = IClipboard.Stub.asInterface(ServiceManager.getService(""clipboard""));
            if (clip != null) {
                clip.setClipboardText(text);
            }
        } catch (android.os.RemoteException e) {
            Log.e(LOGTAG, ""Copy failed"", e);
        }
    }

    /**
     * Resets the browser title-view to whatever it must be
     * (for example, if we had a loading error)
     * When we have a new page, we call resetTitle, when we
     * have to reset the titlebar to whatever it used to be
     * (for example, if the user chose to stop loading), we
     * call resetTitleAndRevertLockIcon.
     */
    /* package */ void resetTitleAndRevertLockIcon() {
        mTabControl.getCurrentTab().revertLockIcon();
        updateLockIconToLatest();
        resetTitleIconAndProgress();
    }

    /**
     * Reset the title, favicon, and progress.
     */
    private void resetTitleIconAndProgress() {
        WebView current = mTabControl.getCurrentWebView();
        if (current == null) {
            return;
        }
        resetTitleAndIcon(current);
        int progress = current.getProgress();
        current.getWebChromeClient().onProgressChanged(current, progress);
    }

    // Reset the title and the icon based on the given item.
    private void resetTitleAndIcon(WebView view) {
        WebHistoryItem item = view.copyBackForwardList().getCurrentItem();
        if (item != null) {
            setUrlTitle(item.getUrl(), item.getTitle());
            setFavicon(item.getFavicon());
        } else {
            setUrlTitle(null, null);
            setFavicon(null);
        }
    }

    /**
     * Sets a title composed of the URL and the title string.
     * @param url The URL of the site being loaded.
     * @param title The title of the site being loaded.
     */
    void setUrlTitle(String url, String title) {
        mUrl = url;
        mTitle = title;

        // If we are in voice search mode, the title has already been set.
        if (mTabControl.getCurrentTab().isInVoiceSearchMode()) return;
        mTitleBar.setDisplayTitle(url);
        mFakeTitleBar.setDisplayTitle(url);
    }

    /**
     * @param url The URL to build a title version of the URL from.
     * @return The title version of the URL or null if fails.
     * The title version of the URL can be either the URL hostname,
     * or the hostname with an ""https://"" prefix (for secure URLs),
     * or an empty string if, for example, the URL in question is a
     * file:// URL with no hostname.
     */
    /* package */ static String buildTitleUrl(String url) {
        String titleUrl = null;

        if (url != null) {
            try {
                // parse the url string
                URL urlObj = new URL(url);
                if (urlObj != null) {
                    titleUrl = """";

                    String protocol = urlObj.getProtocol();
                    String host = urlObj.getHost();

                    if (host != null && 0 < host.length()) {
                        titleUrl = host;
                        if (protocol != null) {
                            // if a secure site, add an ""https://"" prefix!
                            if (protocol.equalsIgnoreCase(""https"")) {
                                titleUrl = protocol + ""://"" + host;
                            }
                        }
                    }
                }
            } catch (MalformedURLException e) {}
        }

        return titleUrl;
    }

    // Set the favicon in the title bar.
    void setFavicon(Bitmap icon) {
        mTitleBar.setFavicon(icon);
        mFakeTitleBar.setFavicon(icon);
    }

    /**
     * Close the tab, remove its associated title bar, and adjust mTabControl's
     * current tab to a valid value.
     */
    /* package */ void closeTab(Tab t) {
        int currentIndex = mTabControl.getCurrentIndex();
        int removeIndex = mTabControl.getTabIndex(t);
        mTabControl.removeTab(t);
        if (currentIndex >= removeIndex && currentIndex != 0) {
            currentIndex--;
        }
        mTabControl.setCurrentTab(mTabControl.getTab(currentIndex));
        resetTitleIconAndProgress();
    }

    /* package */ void goBackOnePageOrQuit() {
        Tab current = mTabControl.getCurrentTab();
        if (current == null) {
            /*
             * Instead of finishing the activity, simply push this to the back
             * of the stack and let ActivityManager to choose the foreground
             * activity. As BrowserActivity is singleTask, it will be always the
             * root of the task. So we can use either true or false for
             * moveTaskToBack().
             */
            moveTaskToBack(true);
            return;
        }
        WebView w = current.getWebView();
        if (w.canGoBack()) {
            w.goBack();
        } else {
            // Check to see if we are closing a window that was created by
            // another window. If so, we switch back to that window.
            Tab parent = current.getParentTab();
            if (parent != null) {
                switchToTab(mTabControl.getTabIndex(parent));
                // Now we close the other tab
                closeTab(current);
            } else {
                if (current.closeOnExit()) {
                    // force the tab's inLoad() to be false as we are going to
                    // either finish the activity or remove the tab. This will
                    // ensure pauseWebViewTimers() taking action.
                    mTabControl.getCurrentTab().clearInLoad();
                    if (mTabControl.getTabCount() == 1) {
                        finish();
                        return;
                    }
                    // call pauseWebViewTimers() now, we won't be able to call
                    // it in onPause() as the WebView won't be valid.
                    // Temporarily change mActivityInPause to be true as
                    // pauseWebViewTimers() will do nothing if mActivityInPause
                    // is false.
                    boolean savedState = mActivityInPause;
                    if (savedState) {
                        Log.e(LOGTAG, ""BrowserActivity is already paused ""
                                + ""while handing goBackOnePageOrQuit."");
                    }
                    mActivityInPause = true;
                    pauseWebViewTimers();
                    mActivityInPause = savedState;
                    removeTabFromContentView(current);
                    mTabControl.removeTab(current);
                }
                /*
                 * Instead of finishing the activity, simply push this to the back
                 * of the stack and let ActivityManager to choose the foreground
                 * activity. As BrowserActivity is singleTask, it will be always the
                 * root of the task. So we can use either true or false for
                 * moveTaskToBack().
                 */
                moveTaskToBack(true);
            }
        }
    }

    boolean isMenuDown() {
        return mMenuIsDown;
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        // Even if MENU is already held down, we need to call to super to open
        // the IME on long press.
        if (KeyEvent.KEYCODE_MENU == keyCode) {
            mMenuIsDown = true;
            return super.onKeyDown(keyCode, event);
        }
        // The default key mode is DEFAULT_KEYS_SEARCH_LOCAL. As the MENU is
        // still down, we don't want to trigger the search. Pretend to consume
        // the key and do nothing.
        if (mMenuIsDown) return true;

        switch(keyCode) {
            case KeyEvent.KEYCODE_SPACE:
                // WebView/WebTextView handle the keys in the KeyDown. As
                // the Activity's shortcut keys are only handled when WebView
                // doesn't, have to do it in onKeyDown instead of onKeyUp.
                if (event.isShiftPressed()) {
                    getTopWindow().pageUp(false);
                } else {
                    getTopWindow().pageDown(false);
                }
                return true;
            case KeyEvent.KEYCODE_BACK:
                if (event.getRepeatCount() == 0) {
                    event.startTracking();
                    return true;
                } else if (mCustomView == null && mActiveTabsPage == null
                        && event.isLongPress()) {
                    bookmarksOrHistoryPicker(true);
                    return true;
                }
                break;
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_MENU:
                mMenuIsDown = false;
                break;
            case KeyEvent.KEYCODE_BACK:
                if (event.isTracking() && !event.isCanceled()) {
                    if (mCustomView != null) {
                        // if a custom view is showing, hide it
                        mTabControl.getCurrentWebView().getWebChromeClient()
                                .onHideCustomView();
                    } else if (mActiveTabsPage != null) {
                        // if tab page is showing, hide it
                        removeActiveTabPage(true);
                    } else {
                        WebView subwindow = mTabControl.getCurrentSubWindow();
                        if (subwindow != null) {
                            if (subwindow.canGoBack()) {
                                subwindow.goBack();
                            } else {
                                dismissSubWindow(mTabControl.getCurrentTab());
                            }
                        } else {
                            goBackOnePageOrQuit();
                        }
                    }
                    return true;
                }
                break;
        }
        return super.onKeyUp(keyCode, event);
    }

    /* package */ void stopLoading() {
        mDidStopLoad = true;
        resetTitleAndRevertLockIcon();
        WebView w = getTopWindow();
        w.stopLoading();
        // FIXME: before refactor, it is using mWebViewClient. So I keep the
        // same logic here. But for subwindow case, should we call into the main
        // WebView's onPageFinished as we never call its onPageStarted and if
        // the page finishes itself, we don't call onPageFinished.
        mTabControl.getCurrentWebView().getWebViewClient().onPageFinished(w,
                w.getUrl());

        cancelStopToast();
        mStopToast = Toast
                .makeText(this, R.string.stopping, Toast.LENGTH_SHORT);
        mStopToast.show();
    }

    boolean didUserStopLoading() {
        return mDidStopLoad;
    }

    private void cancelStopToast() {
        if (mStopToast != null) {
            mStopToast.cancel();
            mStopToast = null;
        }
    }

    // called by a UI or non-UI thread to post the message
    public void postMessage(int what, int arg1, int arg2, Object obj,
            long delayMillis) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(what, arg1, arg2,
                obj), delayMillis);
    }

    // called by a UI or non-UI thread to remove the message
    void removeMessages(int what, Object object) {
        mHandler.removeMessages(what, object);
    }

    // public message ids
    public final static int LOAD_URL                = 1001;
    public final static int STOP_LOAD               = 1002;

    // Message Ids
    private static final int FOCUS_NODE_HREF         = 102;
    private static final int RELEASE_WAKELOCK        = 107;

    static final int UPDATE_BOOKMARK_THUMBNAIL       = 108;

    // Private handler for handling javascript and saving passwords
    private Handler mHandler = new Handler() {

        public void handleMessage(Message msg) {
            switch (msg.what) {
                case FOCUS_NODE_HREF:
                {
                    String url = (String) msg.getData().get(""url"");
                    String title = (String) msg.getData().get(""title"");
                    if (url == null || url.length() == 0) {
                        break;
                    }
                    HashMap focusNodeMap = (HashMap) msg.obj;
                    WebView view = (WebView) focusNodeMap.get(""webview"");
                    // Only apply the action if the top window did not change.
                    if (getTopWindow() != view) {
                        break;
                    }
                    switch (msg.arg1) {
                        case R.id.open_context_menu_id:
                        case R.id.view_image_context_menu_id:
                            loadUrlFromContext(getTopWindow(), url);
                            break;
                        case R.id.open_newtab_context_menu_id:
                            final Tab parent = mTabControl.getCurrentTab();
                            final Tab newTab = openTab(url);
                            if (newTab != parent) {
                                parent.addChildTab(newTab);
                            }
                            break;
                        case R.id.bookmark_context_menu_id:
                            Intent intent = new Intent(BrowserActivity.this,
                                    AddBookmarkPage.class);
                            intent.putExtra(""url"", url);
                            intent.putExtra(""title"", title);
                            startActivity(intent);
                            break;
                        case R.id.share_link_context_menu_id:
                            // See if this site has been visited before
                            StringBuilder sb = new StringBuilder(
                                    Browser.BookmarkColumns.URL + "" = "");
                            DatabaseUtils.appendEscapedSQLString(sb, url);
                            Cursor c = mResolver.query(Browser.BOOKMARKS_URI,
                                    Browser.HISTORY_PROJECTION,
                                    sb.toString(),
                                    null,
                                    null);
                            if (c.moveToFirst()) {
                                // The site has been visited before, so grab the
                                // info from the database.
                                Bitmap favicon = null;
                                Bitmap thumbnail = null;
                                String linkTitle = c.getString(Browser.
                                        HISTORY_PROJECTION_TITLE_INDEX);
                                byte[] data = c.getBlob(Browser.
                                        HISTORY_PROJECTION_FAVICON_INDEX);
                                if (data != null) {
                                    favicon = BitmapFactory.decodeByteArray(
                                            data, 0, data.length);
                                }
                                data = c.getBlob(Browser.
                                        HISTORY_PROJECTION_THUMBNAIL_INDEX);
                                if (data != null) {
                                    thumbnail = BitmapFactory.decodeByteArray(
                                            data, 0, data.length);
                                }
                                sharePage(BrowserActivity.this,
                                        linkTitle, url, favicon, thumbnail);
                            } else {
                                Browser.sendString(BrowserActivity.this, url,
                                        getString(
                                        R.string.choosertitle_sharevia));
                            }
                            break;
                        case R.id.copy_link_context_menu_id:
                            copy(url);
                            break;
                        case R.id.save_link_context_menu_id:
                        case R.id.download_context_menu_id:
                            onDownloadStartNoStream(url, null, null, null, -1);
                            break;
                    }
                    break;
                }

                case LOAD_URL:
                    loadUrlFromContext(getTopWindow(), (String) msg.obj);
                    break;

                case STOP_LOAD:
                    stopLoading();
                    break;

                case RELEASE_WAKELOCK:
                    if (mWakeLock.isHeld()) {
                        mWakeLock.release();
                        // if we reach here, Browser should be still in the
                        // background loading after WAKELOCK_TIMEOUT (5-min).
                        // To avoid burning the battery, stop loading.
                        mTabControl.stopAllLoading();
                    }
                    break;

                case UPDATE_BOOKMARK_THUMBNAIL:
                    WebView view = (WebView) msg.obj;
                    if (view != null) {
                        updateScreenshot(view);
                    }
                    break;
            }
        }
    };

    /**
     * Share a page, providing the title, url, favicon, and a screenshot.  Uses
     * an {@link Intent} to launch the Activity chooser.
     * @param c Context used to launch a new Activity.
     * @param title Title of the page.  Stored in the Intent with
     *          {@link Intent#EXTRA_SUBJECT}
     * @param url URL of the page.  Stored in the Intent with
     *          {@link Intent#EXTRA_TEXT}
     * @param favicon Bitmap of the favicon for the page.  Stored in the Intent
     *          with {@link Browser#EXTRA_SHARE_FAVICON}
     * @param screenshot Bitmap of a screenshot of the page.  Stored in the
     *          Intent with {@link Browser#EXTRA_SHARE_SCREENSHOT}
     */
    public static final void sharePage(Context c, String title, String url,
            Bitmap favicon, Bitmap screenshot) {
        Intent send = new Intent(Intent.ACTION_SEND);
        send.setType(""text/plain"");
        send.putExtra(Intent.EXTRA_TEXT, url);
        send.putExtra(Intent.EXTRA_SUBJECT, title);
        send.putExtra(Browser.EXTRA_SHARE_FAVICON, favicon);
        send.putExtra(Browser.EXTRA_SHARE_SCREENSHOT, screenshot);
        try {
            c.startActivity(Intent.createChooser(send, c.getString(
                    R.string.choosertitle_sharevia)));
        } catch(android.content.ActivityNotFoundException ex) {
            // if no app handles it, do nothing
        }
    }

    private void updateScreenshot(WebView view) {
        // If this is a bookmarked site, add a screenshot to the database.
        // FIXME: When should we update?  Every time?
        // FIXME: Would like to make sure there is actually something to
        // draw, but the API for that (WebViewCore.pictureReady()) is not
        // currently accessible here.

        final Bitmap bm = createScreenshot(view);
        if (bm == null) {
            return;
        }

        final ContentResolver cr = getContentResolver();
        final String url = view.getUrl();
        final String originalUrl = view.getOriginalUrl();

        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... unused) {
                Cursor c = null;
                try {
                    c = BrowserBookmarksAdapter.queryBookmarksForUrl(
                            cr, originalUrl, url, true);
                    if (c != null) {
                        if (c.moveToFirst()) {
                            ContentValues values = new ContentValues();
                            final ByteArrayOutputStream os
                                    = new ByteArrayOutputStream();
                            bm.compress(Bitmap.CompressFormat.PNG, 100, os);
                            values.put(Browser.BookmarkColumns.THUMBNAIL,
                                    os.toByteArray());
                            do {
                                cr.update(ContentUris.withAppendedId(
                                        Browser.BOOKMARKS_URI, c.getInt(0)),
                                        values, null, null);
                            } while (c.moveToNext());
                        }
                    }
                } catch (IllegalStateException e) {
                    // Ignore
                } finally {
                    if (c != null) c.close();
                }
                return null;
            }
        }.execute();
    }

    /**
     * Values for the size of the thumbnail created when taking a screenshot.
     * Lazily initialized.  Instead of using these directly, use
     * getDesiredThumbnailWidth() or getDesiredThumbnailHeight().
     */
    private static int THUMBNAIL_WIDTH = 0;
    private static int THUMBNAIL_HEIGHT = 0;

    /**
     * Return the desired width for thumbnail screenshots, which are stored in
     * the database, and used on the bookmarks screen.
     * @param context Context for finding out the density of the screen.
     * @return int desired width for thumbnail screenshot.
     */
    /* package */ static int getDesiredThumbnailWidth(Context context) {
        if (THUMBNAIL_WIDTH == 0) {
            float density = context.getResources().getDisplayMetrics().density;
            THUMBNAIL_WIDTH = (int) (90 * density);
            THUMBNAIL_HEIGHT = (int) (80 * density);
        }
        return THUMBNAIL_WIDTH;
    }

    /**
     * Return the desired height for thumbnail screenshots, which are stored in
     * the database, and used on the bookmarks screen.
     * @param context Context for finding out the density of the screen.
     * @return int desired height for thumbnail screenshot.
     */
    /* package */ static int getDesiredThumbnailHeight(Context context) {
        // To ensure that they are both initialized.
        getDesiredThumbnailWidth(context);
        return THUMBNAIL_HEIGHT;
    }

    private Bitmap createScreenshot(WebView view) {
        Picture thumbnail = view.capturePicture();
        if (thumbnail == null) {
            return null;
        }
        Bitmap bm = Bitmap.createBitmap(getDesiredThumbnailWidth(this),
                getDesiredThumbnailHeight(this), Bitmap.Config.RGB_565);
        Canvas canvas = new Canvas(bm);
        // May need to tweak these values to determine what is the
        // best scale factor
        int thumbnailWidth = thumbnail.getWidth();
        int thumbnailHeight = thumbnail.getHeight();
        float scaleFactorX = 1.0f;
        float scaleFactorY = 1.0f;
        if (thumbnailWidth > 0) {
            scaleFactorX = (float) getDesiredThumbnailWidth(this) /
                    (float)thumbnailWidth;
        } else {
            return null;
        }

        if (view.getWidth() > view.getHeight() &&
                thumbnailHeight < view.getHeight() && thumbnailHeight > 0) {
            // If the device is in landscape and the page is shorter
            // than the height of the view, stretch the thumbnail to fill the
            // space.
            scaleFactorY = (float) getDesiredThumbnailHeight(this) /
                    (float)thumbnailHeight;
        } else {
            // In the portrait case, this looks nice.
            scaleFactorY = scaleFactorX;
        }

        canvas.scale(scaleFactorX, scaleFactorY);

        thumbnail.draw(canvas);
        return bm;
    }

    // -------------------------------------------------------------------------
    // Helper function for WebViewClient.
    //-------------------------------------------------------------------------

    // Use in overrideUrlLoading
    /* package */ final static String SCHEME_WTAI = ""wtai://wp/"";
    /* package */ final static String SCHEME_WTAI_MC = ""wtai://wp/mc;"";
    /* package */ final static String SCHEME_WTAI_SD = ""wtai://wp/sd;"";
    /* package */ final static String SCHEME_WTAI_AP = ""wtai://wp/ap;"";

    // Keep this initial progress in sync with initialProgressValue (* 100)
    // in ProgressTracker.cpp
    private final static int INITIAL_PROGRESS = 10;

    void onPageStarted(WebView view, String url, Bitmap favicon) {
        // when BrowserActivity just starts, onPageStarted may be called before
        // onResume as it is triggered from onCreate. Call resumeWebViewTimers
        // to start the timer. As we won't switch tabs while an activity is in
        // pause state, we can ensure calling resume and pause in pair.
        if (mActivityInPause) resumeWebViewTimers();

        resetLockIcon(url);
        setUrlTitle(url, null);
        setFavicon(favicon);
        // Show some progress so that the user knows the page is beginning to
        // load
        onProgressChanged(view, INITIAL_PROGRESS);
        mDidStopLoad = false;
        if (!mIsNetworkUp) createAndShowNetworkDialog();
        closeDialogs();
        if (mSettings.isTracing()) {
            String host;
            try {
                WebAddress uri = new WebAddress(url);
                host = uri.mHost;
            } catch (android.net.ParseException ex) {
                host = ""browser"";
            }
            host = host.replace('.', '_');
            host += "".trace"";
            mInTrace = true;
            Debug.startMethodTracing(host, 20 * 1024 * 1024);
        }

        // Performance probe
        if (false) {
            mStart = SystemClock.uptimeMillis();
            mProcessStart = Process.getElapsedCpuTime();
            long[] sysCpu = new long[7];
            if (Process.readProcFile(""/proc/stat"", SYSTEM_CPU_FORMAT, null,
                    sysCpu, null)) {
                mUserStart = sysCpu[0] + sysCpu[1];
                mSystemStart = sysCpu[2];
                mIdleStart = sysCpu[3];
                mIrqStart = sysCpu[4] + sysCpu[5] + sysCpu[6];
            }
            mUiStart = SystemClock.currentThreadTimeMillis();
        }
    }

    void onPageFinished(WebView view, String url) {
        // Reset the title and icon in case we stopped a provisional load.
        resetTitleAndIcon(view);
        // Update the lock icon image only once we are done loading
        updateLockIconToLatest();
        // pause the WebView timer and release the wake lock if it is finished
        // while BrowserActivity is in pause state.
        if (mActivityInPause && pauseWebViewTimers()) {
            if (mWakeLock.isHeld()) {
                mHandler.removeMessages(RELEASE_WAKELOCK);
                mWakeLock.release();
            }
        }

        // Performance probe
        if (false) {
            long[] sysCpu = new long[7];
            if (Process.readProcFile(""/proc/stat"", SYSTEM_CPU_FORMAT, null,
                    sysCpu, null)) {
                String uiInfo = ""UI thread used ""
                        + (SystemClock.currentThreadTimeMillis() - mUiStart)
                        + "" ms"";
                if (LOGD_ENABLED) {
                    Log.d(LOGTAG, uiInfo);
                }
                //The string that gets written to the log
                String performanceString = ""It took total ""
                        + (SystemClock.uptimeMillis() - mStart)
                        + "" ms clock time to load the page.""
                        + ""\nbrowser process used ""
                        + (Process.getElapsedCpuTime() - mProcessStart)
                        + "" ms, user processes used ""
                        + (sysCpu[0] + sysCpu[1] - mUserStart) * 10
                        + "" ms, kernel used ""
                        + (sysCpu[2] - mSystemStart) * 10
                        + "" ms, idle took "" + (sysCpu[3] - mIdleStart) * 10
                        + "" ms and irq took ""
                        + (sysCpu[4] + sysCpu[5] + sysCpu[6] - mIrqStart)
                        * 10 + "" ms, "" + uiInfo;
                if (LOGD_ENABLED) {
                    Log.d(LOGTAG, performanceString + ""\nWebpage: "" + url);
                }
                if (url != null) {
                    // strip the url to maintain consistency
                    String newUrl = new String(url);
                    if (newUrl.startsWith(""http://www."")) {
                        newUrl = newUrl.substring(11);
                    } else if (newUrl.startsWith(""http://"")) {
                        newUrl = newUrl.substring(7);
                    } else if (newUrl.startsWith(""https://www."")) {
                        newUrl = newUrl.substring(12);
                    } else if (newUrl.startsWith(""https://"")) {
                        newUrl = newUrl.substring(8);
                    }
                    if (LOGD_ENABLED) {
                        Log.d(LOGTAG, newUrl + "" loaded"");
                    }
                }
            }
         }

        if (mInTrace) {
            mInTrace = false;
            Debug.stopMethodTracing();
        }
    }

    boolean shouldOverrideUrlLoading(WebView view, String url) {
        if (url.startsWith(SCHEME_WTAI)) {
            // wtai://wp/mc;number
            // number=string(phone-number)
            if (url.startsWith(SCHEME_WTAI_MC)) {
                Intent intent = new Intent(Intent.ACTION_VIEW,
                        Uri.parse(WebView.SCHEME_TEL +
                        url.substring(SCHEME_WTAI_MC.length())));
                startActivity(intent);
                return true;
            }
            // wtai://wp/sd;dtmf
            // dtmf=string(dialstring)
            if (url.startsWith(SCHEME_WTAI_SD)) {
                // TODO: only send when there is active voice connection
                return false;
            }
            // wtai://wp/ap;number;name
            // number=string(phone-number)
            // name=string
            if (url.startsWith(SCHEME_WTAI_AP)) {
                // TODO
                return false;
            }
        }

        // The ""about:"" schemes are internal to the browser; don't want these to
        // be dispatched to other apps.
        if (url.startsWith(""about:"")) {
            return false;
        }

        Intent intent;
        // perform generic parsing of the URI to turn it into an Intent.
        try {
            intent = Intent.parseUri(url, Intent.URI_INTENT_SCHEME);
        } catch (URISyntaxException ex) {
            Log.w(""Browser"", ""Bad URI "" + url + "": "" + ex.getMessage());
            return false;
        }

        // check whether the intent can be resolved. If not, we will see
        // whether we can download it from the Market.
        if (getPackageManager().resolveActivity(intent, 0) == null) {
            String packagename = intent.getPackage();
            if (packagename != null) {
                intent = new Intent(Intent.ACTION_VIEW, Uri
                        .parse(""market://search?q=pname:"" + packagename));
                intent.addCategory(Intent.CATEGORY_BROWSABLE);
                startActivity(intent);
                return true;
            } else {
                return false;
            }
        }

        // sanitize the Intent, ensuring web pages can not bypass browser
        // security (only access to BROWSABLE activities).
        intent.addCategory(Intent.CATEGORY_BROWSABLE);
        intent.setComponent(null);
        try {
            if (startActivityIfNeeded(intent, -1)) {
                return true;
            }
        } catch (ActivityNotFoundException ex) {
            // ignore the error. If no application can handle the URL,
            // eg about:blank, assume the browser can handle it.
        }

        if (mMenuIsDown) {
            openTab(url);
            closeOptionsMenu();
            return true;
        }
        return false;
    }

    // -------------------------------------------------------------------------
    // Helper function for WebChromeClient
    // -------------------------------------------------------------------------

    void onProgressChanged(WebView view, int newProgress) {
        mFakeTitleBar.setProgress(newProgress);

        if (newProgress == 100) {
            // onProgressChanged() may continue to be called after the main
            // frame has finished loading, as any remaining sub frames continue
            // to load. We'll only get called once though with newProgress as
            // 100 when everything is loaded. (onPageFinished is called once
            // when the main frame completes loading regardless of the state of
            // any sub frames so calls to onProgressChanges may continue after
            // onPageFinished has executed)
            if (mInLoad) {
                mInLoad = false;
                updateInLoadMenuItems();
                // If the options menu is open, leave the title bar
                if (!mOptionsMenuOpen || !mIconView) {
                    hideFakeTitleBar();
                }
            }
        } else {
            if (!mInLoad) {
                // onPageFinished may have already been called but a subframe is
                // still loading and updating the progress. Reset mInLoad and
                // update the menu items.
                mInLoad = true;
                updateInLoadMenuItems();
            }
            // When the page first begins to load, the Activity may still be
            // paused, in which case showFakeTitleBar will do nothing.  Call
            // again as the page continues to load so that it will be shown.
            // (Calling it will the fake title bar is already showing will also
            // do nothing.
            if (!mOptionsMenuOpen || mIconView) {
                // This page has begun to load, so show the title bar
                showFakeTitleBar();
            }
        }
    }

    void onShowCustomView(View view, WebChromeClient.CustomViewCallback callback) {
        // if a view already exists then immediately terminate the new one
        if (mCustomView != null) {
            callback.onCustomViewHidden();
            return;
        }

        // Add the custom view to its container.
        mCustomViewContainer.addView(view, COVER_SCREEN_GRAVITY_CENTER);
        mCustomView = view;
        mCustomViewCallback = callback;
        // Save the menu state and set it to empty while the custom
        // view is showing.
        mOldMenuState = mMenuState;
        mMenuState = EMPTY_MENU;
        // Hide the content view.
        mContentView.setVisibility(View.GONE);
        // Finally show the custom view container.
        setStatusBarVisibility(false);
        mCustomViewContainer.setVisibility(View.VISIBLE);
        mCustomViewContainer.bringToFront();
    }

    void onHideCustomView() {
        if (mCustomView == null)
            return;
        // Hide the custom view.
        mCustomView.setVisibility(View.GONE);
        // Remove the custom view from its container.
        mCustomViewContainer.removeView(mCustomView);
        mCustomView = null;
        // Reset the old menu state.
        mMenuState = mOldMenuState;
        mOldMenuState = EMPTY_MENU;
        mCustomViewContainer.setVisibility(View.GONE);
        mCustomViewCallback.onCustomViewHidden();
        // Show the content view.
        setStatusBarVisibility(true);
        mContentView.setVisibility(View.VISIBLE);
    }

    Bitmap getDefaultVideoPoster() {
        if (mDefaultVideoPoster == null) {
            mDefaultVideoPoster = BitmapFactory.decodeResource(
                    getResources(), R.drawable.default_video_poster);
        }
        return mDefaultVideoPoster;
    }

    View getVideoLoadingProgressView() {
        if (mVideoProgressView == null) {
            LayoutInflater inflater = LayoutInflater.from(BrowserActivity.this);
            mVideoProgressView = inflater.inflate(
                    R.layout.video_loading_progress, null);
        }
        return mVideoProgressView;
    }

    /*
     * The Object used to inform the WebView of the file to upload.
     */
    private ValueCallback<Uri> mUploadMessage;

    void openFileChooser(ValueCallback<Uri> uploadMsg) {
        if (mUploadMessage != null) return;
        mUploadMessage = uploadMsg;
        Intent i = new Intent(Intent.ACTION_GET_CONTENT);
        i.addCategory(Intent.CATEGORY_OPENABLE);
        i.setType(""*/*"");
        BrowserActivity.this.startActivityForResult(Intent.createChooser(i,
                getString(R.string.choose_upload)), FILE_SELECTED);
    }

    // -------------------------------------------------------------------------
    // Implement functions for DownloadListener
    // -------------------------------------------------------------------------

    /**
     * Notify the host application a download should be done, or that
     * the data should be streamed if a streaming viewer is available.
     * @param url The full url to the content that should be downloaded
     * @param contentDisposition Content-disposition http header, if
     *                           present.
     * @param mimetype The mimetype of the content reported by the server
     * @param contentLength The file size reported by the server
     */
    public void onDownloadStart(String url, String userAgent,
            String contentDisposition, String mimetype, long contentLength) {
        // if we're dealing wih A/V content that's not explicitly marked
        //     for download, check if it's streamable.
        if (contentDisposition == null
                || !contentDisposition.regionMatches(
                        true, 0, ""attachment"", 0, 10)) {
            // query the package manager to see if there's a registered handler
            //     that matches.
            Intent intent = new Intent(Intent.ACTION_VIEW);
            intent.setDataAndType(Uri.parse(url), mimetype);
            ResolveInfo info = getPackageManager().resolveActivity(intent,
                    PackageManager.MATCH_DEFAULT_ONLY);
            if (info != null) {
                ComponentName myName = getComponentName();
                // If we resolved to ourselves, we don't want to attempt to
                // load the url only to try and download it again.
                if (!myName.getPackageName().equals(
                        info.activityInfo.packageName)
                        || !myName.getClassName().equals(
                                info.activityInfo.name)) {
                    // someone (other than us) knows how to handle this mime
                    // type with this scheme, don't download.
                    try {
                        startActivity(intent);
                        return;
                    } catch (ActivityNotFoundException ex) {
                        if (LOGD_ENABLED) {
                            Log.d(LOGTAG, ""activity not found for "" + mimetype
                                    + "" over "" + Uri.parse(url).getScheme(),
                                    ex);
                        }
                        // Best behavior is to fall back to a download in this
                        // case
                    }
                }
            }
        }
        onDownloadStartNoStream(url, userAgent, contentDisposition, mimetype, contentLength);
    }

    // This is to work around the fact that java.net.URI throws Exceptions
    // instead of just encoding URL's properly
    // Helper method for onDownloadStartNoStream
    private static String encodePath(String path) {
        char[] chars = path.toCharArray();

        boolean needed = false;
        for (char c : chars) {
            if (c == '[' || c == ']') {
                needed = true;
                break;
            }
        }
        if (needed == false) {
            return path;
        }

        StringBuilder sb = new StringBuilder("""");
        for (char c : chars) {
            if (c == '[' || c == ']') {
                sb.append('%');
                sb.append(Integer.toHexString(c));
            } else {
                sb.append(c);
            }
        }

        return sb.toString();
    }

    /**
     * Notify the host application a download should be done, even if there
     * is a streaming viewer available for thise type.
     * @param url The full url to the content that should be downloaded
     * @param contentDisposition Content-disposition http header, if
     *                           present.
     * @param mimetype The mimetype of the content reported by the server
     * @param contentLength The file size reported by the server
     */
    /*package */ void onDownloadStartNoStream(String url, String userAgent,
            String contentDisposition, String mimetype, long contentLength) {

        String filename = URLUtil.guessFileName(url,
                contentDisposition, mimetype);

        // Check to see if we have an SDCard
        String status = Environment.getExternalStorageState();
        if (!status.equals(Environment.MEDIA_MOUNTED)) {
            int title;
            String msg;

            // Check to see if the SDCard is busy, same as the music app
            if (status.equals(Environment.MEDIA_SHARED)) {
                msg = getString(R.string.download_sdcard_busy_dlg_msg);
                title = R.string.download_sdcard_busy_dlg_title;
            } else {
                msg = getString(R.string.download_no_sdcard_dlg_msg, filename);
                title = R.string.download_no_sdcard_dlg_title;
            }

            new AlertDialog.Builder(this)
                .setTitle(title)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setMessage(msg)
                .setPositiveButton(R.string.ok, null)
                .show();
            return;
        }

        // java.net.URI is a lot stricter than KURL so we have to encode some
        // extra characters. Fix for b 2538060 and b 1634719
        WebAddress webAddress;
        try {
            webAddress = new WebAddress(url);
            webAddress.mPath = encodePath(webAddress.mPath);
        } catch (Exception e) {
            // This only happens for very bad urls, we want to chatch the
            // exception here
            Log.e(LOGTAG, ""Exception trying to parse url:"" + url);
            return;
        }

        // XXX: Have to use the old url since the cookies were stored using the
        // old percent-encoded url.
        String cookies = CookieManager.getInstance().getCookie(url);

        ContentValues values = new ContentValues();
        values.put(Downloads.Impl.COLUMN_URI, webAddress.toString());
        values.put(Downloads.Impl.COLUMN_COOKIE_DATA, cookies);
        values.put(Downloads.Impl.COLUMN_USER_AGENT, userAgent);
        values.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,
                getPackageName());
        values.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS,
                OpenDownloadReceiver.class.getCanonicalName());
        values.put(Downloads.Impl.COLUMN_VISIBILITY,
                Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);
        values.put(Downloads.Impl.COLUMN_MIME_TYPE, mimetype);
        values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, filename);
        values.put(Downloads.Impl.COLUMN_DESCRIPTION, webAddress.mHost);
        if (contentLength > 0) {
            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, contentLength);
        }
        if (mimetype == null) {
            // We must have long pressed on a link or image to download it. We
            // are not sure of the mimetype in this case, so do a head request
            new FetchUrlMimeType(this).execute(values);
        } else {
            final Uri contentUri =
                    getContentResolver().insert(Downloads.Impl.CONTENT_URI, values);
        }
        Toast.makeText(this, R.string.download_pending, Toast.LENGTH_SHORT)
                .show();
    }

    // -------------------------------------------------------------------------

    /**
     * Resets the lock icon. This method is called when we start a new load and
     * know the url to be loaded.
     */
    private void resetLockIcon(String url) {
        // Save the lock-icon state (we revert to it if the load gets cancelled)
        mTabControl.getCurrentTab().resetLockIcon(url);
        updateLockIconImage(LOCK_ICON_UNSECURE);
    }

    /**
     * Update the lock icon to correspond to our latest state.
     */
    private void updateLockIconToLatest() {
        updateLockIconImage(mTabControl.getCurrentTab().getLockIconType());
    }

    /**
     * Updates the lock-icon image in the title-bar.
     */
    private void updateLockIconImage(int lockIconType) {
        Drawable d = null;
        if (lockIconType == LOCK_ICON_SECURE) {
            d = mSecLockIcon;
        } else if (lockIconType == LOCK_ICON_MIXED) {
            d = mMixLockIcon;
        }
        mTitleBar.setLock(d);
        mFakeTitleBar.setLock(d);
    }

    /**
     * Displays a page-info dialog.
     * @param tab The tab to show info about
     * @param fromShowSSLCertificateOnError The flag that indicates whether
     * this dialog was opened from the SSL-certificate-on-error dialog or
     * not. This is important, since we need to know whether to return to
     * the parent dialog or simply dismiss.
     */
    private void showPageInfo(final Tab tab,
                              final boolean fromShowSSLCertificateOnError) {
        final LayoutInflater factory = LayoutInflater
                .from(this);

        final View pageInfoView = factory.inflate(R.layout.page_info, null);

        final WebView view = tab.getWebView();

        String url = null;
        String title = null;

        if (view == null) {
            url = tab.getUrl();
            title = tab.getTitle();
        } else if (view == mTabControl.getCurrentWebView()) {
             // Use the cached title and url if this is the current WebView
            url = mUrl;
            title = mTitle;
        } else {
            url = view.getUrl();
            title = view.getTitle();
        }

        if (url == null) {
            url = """";
        }
        if (title == null) {
            title = """";
        }

        ((TextView) pageInfoView.findViewById(R.id.address)).setText(url);
        ((TextView) pageInfoView.findViewById(R.id.title)).setText(title);

        mPageInfoView = tab;
        mPageInfoFromShowSSLCertificateOnError = fromShowSSLCertificateOnError;

        AlertDialog.Builder alertDialogBuilder =
            new AlertDialog.Builder(this)
            .setTitle(R.string.page_info).setIcon(android.R.drawable.ic_dialog_info)
            .setView(pageInfoView)
            .setPositiveButton(
                R.string.ok,
                new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog,
                                        int whichButton) {
                        mPageInfoDialog = null;
                        mPageInfoView = null;

                        // if we came here from the SSL error dialog
                        if (fromShowSSLCertificateOnError) {
                            // go back to the SSL error dialog
                            showSSLCertificateOnError(
                                mSSLCertificateOnErrorView,
                                mSSLCertificateOnErrorHandler,
                                mSSLCertificateOnErrorError);
                        }
                    }
                })
            .setOnCancelListener(
                new DialogInterface.OnCancelListener() {
                    public void onCancel(DialogInterface dialog) {
                        mPageInfoDialog = null;
                        mPageInfoView = null;

                        // if we came here from the SSL error dialog
                        if (fromShowSSLCertificateOnError) {
                            // go back to the SSL error dialog
                            showSSLCertificateOnError(
                                mSSLCertificateOnErrorView,
                                mSSLCertificateOnErrorHandler,
                                mSSLCertificateOnErrorError);
                        }
                    }
                });

        // if we have a main top-level page SSL certificate set or a certificate
        // error
        if (fromShowSSLCertificateOnError ||
                (view != null && view.getCertificate() != null)) {
            // add a 'View Certificate' button
            alertDialogBuilder.setNeutralButton(
                R.string.view_certificate,
                new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog,
                                        int whichButton) {
                        mPageInfoDialog = null;
                        mPageInfoView = null;

                        // if we came here from the SSL error dialog
                        if (fromShowSSLCertificateOnError) {
                            // go back to the SSL error dialog
                            showSSLCertificateOnError(
                                mSSLCertificateOnErrorView,
                                mSSLCertificateOnErrorHandler,
                                mSSLCertificateOnErrorError);
                        } else {
                            // otherwise, display the top-most certificate from
                            // the chain
                            if (view.getCertificate() != null) {
                                showSSLCertificate(tab);
                            }
                        }
                    }
                });
        }

        mPageInfoDialog = alertDialogBuilder.show();
    }

       /**
     * Displays the main top-level page SSL certificate dialog
     * (accessible from the Page-Info dialog).
     * @param tab The tab to show certificate for.
     */
    private void showSSLCertificate(final Tab tab) {
        final View certificateView =
                inflateCertificateView(tab.getWebView().getCertificate());
        if (certificateView == null) {
            return;
        }

        LayoutInflater factory = LayoutInflater.from(this);

        final LinearLayout placeholder =
                (LinearLayout)certificateView.findViewById(R.id.placeholder);

        LinearLayout ll = (LinearLayout) factory.inflate(
            R.layout.ssl_success, placeholder);
        ((TextView)ll.findViewById(R.id.success))
            .setText(R.string.ssl_certificate_is_valid);

        mSSLCertificateView = tab;
        mSSLCertificateDialog =
            new AlertDialog.Builder(this)
                .setTitle(R.string.ssl_certificate).setIcon(
                    R.drawable.ic_dialog_browser_certificate_secure)
                .setView(certificateView)
                .setPositiveButton(R.string.ok,
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog,
                                    int whichButton) {
                                mSSLCertificateDialog = null;
                                mSSLCertificateView = null;

                                showPageInfo(tab, false);
                            }
                        })
                .setOnCancelListener(
                        new DialogInterface.OnCancelListener() {
                            public void onCancel(DialogInterface dialog) {
                                mSSLCertificateDialog = null;
                                mSSLCertificateView = null;

                                showPageInfo(tab, false);
                            }
                        })
                .show();
    }

    /**
     * Displays the SSL error certificate dialog.
     * @param view The target web-view.
     * @param handler The SSL error handler responsible for cancelling the
     * connection that resulted in an SSL error or proceeding per user request.
     * @param error The SSL error object.
     */
    void showSSLCertificateOnError(
        final WebView view, final SslErrorHandler handler, final SslError error) {

        final View certificateView =
            inflateCertificateView(error.getCertificate());
        if (certificateView == null) {
            return;
        }

        LayoutInflater factory = LayoutInflater.from(this);

        final LinearLayout placeholder =
                (LinearLayout)certificateView.findViewById(R.id.placeholder);

        if (error.hasError(SslError.SSL_UNTRUSTED)) {
            LinearLayout ll = (LinearLayout)factory
                .inflate(R.layout.ssl_warning, placeholder);
            ((TextView)ll.findViewById(R.id.warning))
                .setText(R.string.ssl_untrusted);
        }

        if (error.hasError(SslError.SSL_IDMISMATCH)) {
            LinearLayout ll = (LinearLayout)factory
                .inflate(R.layout.ssl_warning, placeholder);
            ((TextView)ll.findViewById(R.id.warning))
                .setText(R.string.ssl_mismatch);
        }

        if (error.hasError(SslError.SSL_EXPIRED)) {
            LinearLayout ll = (LinearLayout)factory
                .inflate(R.layout.ssl_warning, placeholder);
            ((TextView)ll.findViewById(R.id.warning))
                .setText(R.string.ssl_expired);
        }

        if (error.hasError(SslError.SSL_NOTYETVALID)) {
            LinearLayout ll = (LinearLayout)factory
                .inflate(R.layout.ssl_warning, placeholder);
            ((TextView)ll.findViewById(R.id.warning))
                .setText(R.string.ssl_not_yet_valid);
        }

        mSSLCertificateOnErrorHandler = handler;
        mSSLCertificateOnErrorView = view;
        mSSLCertificateOnErrorError = error;
        mSSLCertificateOnErrorDialog =
            new AlertDialog.Builder(this)
                .setTitle(R.string.ssl_certificate).setIcon(
                    R.drawable.ic_dialog_browser_certificate_partially_secure)
                .setView(certificateView)
                .setPositiveButton(R.string.ok,
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog,
                                    int whichButton) {
                                mSSLCertificateOnErrorDialog = null;
                                mSSLCertificateOnErrorView = null;
                                mSSLCertificateOnErrorHandler = null;
                                mSSLCertificateOnErrorError = null;

                                view.getWebViewClient().onReceivedSslError(
                                                view, handler, error);
                            }
                        })
                 .setNeutralButton(R.string.page_info_view,
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog,
                                    int whichButton) {
                                mSSLCertificateOnErrorDialog = null;

                                // do not clear the dialog state: we will
                                // need to show the dialog again once the
                                // user is done exploring the page-info details

                                showPageInfo(mTabControl.getTabFromView(view),
                                        true);
                            }
                        })
                .setOnCancelListener(
                        new DialogInterface.OnCancelListener() {
                            public void onCancel(DialogInterface dialog) {
                                mSSLCertificateOnErrorDialog = null;
                                mSSLCertificateOnErrorView = null;
                                mSSLCertificateOnErrorHandler = null;
                                mSSLCertificateOnErrorError = null;

                                view.getWebViewClient().onReceivedSslError(
                                                view, handler, error);
                            }
                        })
                .show();
    }

    /**
     * Inflates the SSL certificate view (helper method).
     * @param certificate The SSL certificate.
     * @return The resultant certificate view with issued-to, issued-by,
     * issued-on, expires-on, and possibly other fields set.
     * If the input certificate is null, returns null.
     */
    private View inflateCertificateView(SslCertificate certificate) {
        if (certificate == null) {
            return null;
        }

        LayoutInflater factory = LayoutInflater.from(this);

        View certificateView = factory.inflate(
            R.layout.ssl_certificate, null);

        // issued to:
        SslCertificate.DName issuedTo = certificate.getIssuedTo();
        if (issuedTo != null) {
            ((TextView) certificateView.findViewById(R.id.to_common))
                .setText(issuedTo.getCName());
            ((TextView) certificateView.findViewById(R.id.to_org))
                .setText(issuedTo.getOName());
            ((TextView) certificateView.findViewById(R.id.to_org_unit))
                .setText(issuedTo.getUName());
        }

        // issued by:
        SslCertificate.DName issuedBy = certificate.getIssuedBy();
        if (issuedBy != null) {
            ((TextView) certificateView.findViewById(R.id.by_common))
                .setText(issuedBy.getCName());
            ((TextView) certificateView.findViewById(R.id.by_org))
                .setText(issuedBy.getOName());
            ((TextView) certificateView.findViewById(R.id.by_org_unit))
                .setText(issuedBy.getUName());
        }

        // issued on:
        String issuedOn = formatCertificateDate(
            certificate.getValidNotBeforeDate());
        ((TextView) certificateView.findViewById(R.id.issued_on))
            .setText(issuedOn);

        // expires on:
        String expiresOn = formatCertificateDate(
            certificate.getValidNotAfterDate());
        ((TextView) certificateView.findViewById(R.id.expires_on))
            .setText(expiresOn);

        return certificateView;
    }

    /**
     * Formats the certificate date to a properly localized date string.
     * @return Properly localized version of the certificate date string and
     * the """" if it fails to localize.
     */
    private String formatCertificateDate(Date certificateDate) {
      if (certificateDate == null) {
          return """";
      }
      String formattedDate = DateFormat.getDateFormat(this).format(certificateDate);
      if (formattedDate == null) {
          return """";
      }
      return formattedDate;
    }

    /**
     * Displays an http-authentication dialog.
     */
    void showHttpAuthentication(final HttpAuthHandler handler,
            final String host, final String realm, final String title,
            final String name, final String password, int focusId) {
        LayoutInflater factory = LayoutInflater.from(this);
        final View v = factory
                .inflate(R.layout.http_authentication, null);
        if (name != null) {
            ((EditText) v.findViewById(R.id.username_edit)).setText(name);
        }
        if (password != null) {
            ((EditText) v.findViewById(R.id.password_edit)).setText(password);
        }

        String titleText = title;
        if (titleText == null) {
            titleText = getText(R.string.sign_in_to).toString().replace(
                    ""%s1"", host).replace(""%s2"", realm);
        }

        mHttpAuthHandler = handler;
        AlertDialog dialog = new AlertDialog.Builder(this)
                .setTitle(titleText)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setView(v)
                .setPositiveButton(R.string.action,
                        new DialogInterface.OnClickListener() {
                             public void onClick(DialogInterface dialog,
                                     int whichButton) {
                                String nm = ((EditText) v
                                        .findViewById(R.id.username_edit))
                                        .getText().toString();
                                String pw = ((EditText) v
                                        .findViewById(R.id.password_edit))
                                        .getText().toString();
                                BrowserActivity.this.setHttpAuthUsernamePassword
                                        (host, realm, nm, pw);
                                handler.proceed(nm, pw);
                                mHttpAuthenticationDialog = null;
                                mHttpAuthHandler = null;
                            }})
                .setNegativeButton(R.string.cancel,
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog,
                                    int whichButton) {
                                handler.cancel();
                                BrowserActivity.this.resetTitleAndRevertLockIcon();
                                mHttpAuthenticationDialog = null;
                                mHttpAuthHandler = null;
                            }})
                .setOnCancelListener(new DialogInterface.OnCancelListener() {
                        public void onCancel(DialogInterface dialog) {
                            handler.cancel();
                            BrowserActivity.this.resetTitleAndRevertLockIcon();
                            mHttpAuthenticationDialog = null;
                            mHttpAuthHandler = null;
                        }})
                .create();
        // Make the IME appear when the dialog is displayed if applicable.
        dialog.getWindow().setSoftInputMode(
                WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
        dialog.show();
        if (focusId != 0) {
            dialog.findViewById(focusId).requestFocus();
        } else {
            v.findViewById(R.id.username_edit).requestFocus();
        }
        mHttpAuthenticationDialog = dialog;
    }

    public int getProgress() {
        WebView w = mTabControl.getCurrentWebView();
        if (w != null) {
            return w.getProgress();
        } else {
            return 100;
        }
    }

    /**
     * Set HTTP authentication password.
     *
     * @param host The host for the password
     * @param realm The realm for the password
     * @param username The username for the password. If it is null, it means
     *            password can't be saved.
     * @param password The password
     */
    public void setHttpAuthUsernamePassword(String host, String realm,
                                            String username,
                                            String password) {
        WebView w = getTopWindow();
        if (w != null) {
            w.setHttpAuthUsernamePassword(host, realm, username, password);
        }
    }

    /**
     * connectivity manager says net has come or gone... inform the user
     * @param up true if net has come up, false if net has gone down
     */
    public void onNetworkToggle(boolean up) {
        if (up == mIsNetworkUp) {
            return;
        } else if (up) {
            mIsNetworkUp = true;
            if (mAlertDialog != null) {
                mAlertDialog.cancel();
                mAlertDialog = null;
            }
        } else {
            mIsNetworkUp = false;
            if (mInLoad) {
                createAndShowNetworkDialog();
           }
        }
        WebView w = mTabControl.getCurrentWebView();
        if (w != null) {
            w.setNetworkAvailable(up);
        }
    }

    boolean isNetworkUp() {
        return mIsNetworkUp;
    }

    // This method shows the network dialog alerting the user that the net is
    // down. It will only show the dialog if mAlertDialog is null.
    private void createAndShowNetworkDialog() {
        if (mAlertDialog == null) {
            mAlertDialog = new AlertDialog.Builder(this)
                    .setTitle(R.string.loadSuspendedTitle)
                    .setMessage(R.string.loadSuspended)
                    .setPositiveButton(R.string.ok, null)
                    .show();
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode,
                                    Intent intent) {
        if (getTopWindow() == null) return;

        switch (requestCode) {
            case COMBO_PAGE:
                if (resultCode == RESULT_OK && intent != null) {
                    String data = intent.getAction();
                    Bundle extras = intent.getExtras();
                    if (extras != null && extras.getBoolean(""new_window"", false)) {
                        openTab(data);
                    } else {
                        final Tab currentTab =
                                mTabControl.getCurrentTab();
                        dismissSubWindow(currentTab);
                        if (data != null && data.length() != 0) {
                            loadUrl(getTopWindow(), data);
                        }
                    }
                }
                // Deliberately fall through to PREFERENCES_PAGE, since the
                // same extra may be attached to the COMBO_PAGE
            case PREFERENCES_PAGE:
                if (resultCode == RESULT_OK && intent != null) {
                    String action = intent.getStringExtra(Intent.EXTRA_TEXT);
                    if (BrowserSettings.PREF_CLEAR_HISTORY.equals(action)) {
                        mTabControl.removeParentChildRelationShips();
                    }
                }
                break;
            // Choose a file from the file picker.
            case FILE_SELECTED:
                if (null == mUploadMessage) break;
                Uri result = intent == null || resultCode != RESULT_OK ? null
                        : intent.getData();
                mUploadMessage.onReceiveValue(result);
                mUploadMessage = null;
                break;
            default:
                break;
        }
        getTopWindow().requestFocus();
    }

    /*
     * This method is called as a result of the user selecting the options
     * menu to see the download window. It shows the download window on top of
     * the current window.
     */
    private void viewDownloads() {
        Intent intent = new Intent(DownloadManager.ACTION_VIEW_DOWNLOADS);
        startActivity(intent);
    }

    /**
     * Open the Go page.
     * @param startWithHistory If true, open starting on the history tab.
     *                         Otherwise, start with the bookmarks tab.
     */
    /* package */ void bookmarksOrHistoryPicker(boolean startWithHistory) {
        WebView current = mTabControl.getCurrentWebView();
        if (current == null) {
            return;
        }
        Intent intent = new Intent(this,
                CombinedBookmarkHistoryActivity.class);
        String title = current.getTitle();
        String url = current.getUrl();
        Bitmap thumbnail = createScreenshot(current);

        // Just in case the user opens bookmarks before a page finishes loading
        // so the current history item, and therefore the page, is null.
        if (null == url) {
            url = mLastEnteredUrl;
            // This can happen.
            if (null == url) {
                url = mSettings.getHomePage();
            }
        }
        // In case the web page has not yet received its associated title.
        if (title == null) {
            title = url;
        }
        intent.putExtra(""title"", title);
        intent.putExtra(""url"", url);
        intent.putExtra(""thumbnail"", thumbnail);
        // Disable opening in a new window if we have maxed out the windows
        intent.putExtra(""disable_new_window"", !mTabControl.canCreateNewTab());
        intent.putExtra(""touch_icon_url"", current.getTouchIconUrl());
        if (startWithHistory) {
            intent.putExtra(CombinedBookmarkHistoryActivity.STARTING_TAB,
                    CombinedBookmarkHistoryActivity.HISTORY_TAB);
        }
        startActivityForResult(intent, COMBO_PAGE);
    }

    // Called when loading from context menu or LOAD_URL message
    private void loadUrlFromContext(WebView view, String url) {
        // In case the user enters nothing.
        if (url != null && url.length() != 0 && view != null) {
            url = smartUrlFilter(url);
            if (!view.getWebViewClient().shouldOverrideUrlLoading(view, url)) {
                loadUrl(view, url);
            }
        }
    }

    /**
     * Load the URL into the given WebView and update the title bar
     * to reflect the new load.  Call this instead of WebView.loadUrl
     * directly.
     * @param view The WebView used to load url.
     * @param url The URL to load.
     */
    private void loadUrl(WebView view, String url) {
        updateTitleBarForNewLoad(view, url);
        view.loadUrl(url);
    }

    /**
     * Load UrlData into a Tab and update the title bar to reflect the new
     * load.  Call this instead of UrlData.loadIn directly.
     * @param t The Tab used to load.
     * @param data The UrlData being loaded.
     */
    private void loadUrlDataIn(Tab t, UrlData data) {
        updateTitleBarForNewLoad(t.getWebView(), data.mUrl);
        data.loadIn(t);
    }

    /**
     * If the WebView is the top window, update the title bar to reflect
     * loading the new URL.  i.e. set its text, clear the favicon (which
     * will be set once the page begins loading), and set the progress to
     * INITIAL_PROGRESS to show that the page has begun to load. Called
     * by loadUrl and loadUrlDataIn.
     * @param view The WebView that is starting a load.
     * @param url The URL that is being loaded.
     */
    private void updateTitleBarForNewLoad(WebView view, String url) {
        if (view == getTopWindow()) {
            setUrlTitle(url, null);
            setFavicon(null);
            onProgressChanged(view, INITIAL_PROGRESS);
        }
    }

    private String smartUrlFilter(Uri inUri) {
        if (inUri != null) {
            return smartUrlFilter(inUri.toString());
        }
        return null;
    }

    protected static final Pattern ACCEPTED_URI_SCHEMA = Pattern.compile(
            ""(?i)"" + // switch on case insensitive matching
            ""("" +    // begin group for schema
            ""(?:http|https|file):\\/\\/"" +
            ""|(?:inline|data|about|content|javascript):"" +
            "")"" +
            ""(.*)"" );

    /**
     * Attempts to determine whether user input is a URL or search
     * terms.  Anything with a space is passed to search.
     *
     * Converts to lowercase any mistakenly uppercased schema (i.e.,
     * ""Http://"" converts to ""http://""
     *
     * @return Original or modified URL
     *
     */
    String smartUrlFilter(String url) {

        String inUrl = url.trim();
        boolean hasSpace = inUrl.indexOf(' ') != -1;

        Matcher matcher = ACCEPTED_URI_SCHEMA.matcher(inUrl);
        if (matcher.matches()) {
            // force scheme to lowercase
            String scheme = matcher.group(1);
            String lcScheme = scheme.toLowerCase();
            if (!lcScheme.equals(scheme)) {
                inUrl = lcScheme + matcher.group(2);
            }
            if (hasSpace) {
                inUrl = inUrl.replace("" "", ""%20"");
            }
            return inUrl;
        }
        if (!hasSpace) {
            if (Patterns.WEB_URL.matcher(inUrl).matches()) {
                return URLUtil.guessUrl(inUrl);
            }
        }

        // FIXME: Is this the correct place to add to searches?
        // what if someone else calls this function?

        Browser.addSearchUrl(mResolver, inUrl);
        return URLUtil.composeSearchUrl(inUrl, QuickSearch_G, QUERY_PLACE_HOLDER);
    }

    /* package */ void setShouldShowErrorConsole(boolean flag) {
        if (flag == mShouldShowErrorConsole) {
            // Nothing to do.
            return;
        }
        Tab t = mTabControl.getCurrentTab();
        if (t == null) {
            // There is no current tab so we cannot toggle the error console
            return;
        }

        mShouldShowErrorConsole = flag;

        ErrorConsoleView errorConsole = t.getErrorConsole(true);

        if (flag) {
            // Setting the show state of the console will cause it's the layout to be inflated.
            if (errorConsole.numberOfErrors() > 0) {
                errorConsole.showConsole(ErrorConsoleView.SHOW_MINIMIZED);
            } else {
                errorConsole.showConsole(ErrorConsoleView.SHOW_NONE);
            }

            // Now we can add it to the main view.
            mErrorConsoleContainer.addView(errorConsole,
                    new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
                                                  ViewGroup.LayoutParams.WRAP_CONTENT));
        } else {
            mErrorConsoleContainer.removeView(errorConsole);
        }

    }

    boolean shouldShowErrorConsole() {
        return mShouldShowErrorConsole;
    }

    private void setStatusBarVisibility(boolean visible) {
        int flag = visible ? 0 : WindowManager.LayoutParams.FLAG_FULLSCREEN;
        getWindow().setFlags(flag, WindowManager.LayoutParams.FLAG_FULLSCREEN);
    }


    private void sendNetworkType(String type, String subtype) {
        WebView w = mTabControl.getCurrentWebView();
        if (w != null) {
            w.setNetworkType(type, subtype);
        }
    }

    private void packageChanged(String packageName, boolean wasAdded) {
        WebView w = mTabControl.getCurrentWebView();
        if (w == null) {
            return;
        }

        if (wasAdded) {
            w.addPackageName(packageName);
        } else {
            w.removePackageName(packageName);
        }
    }

    private void addPackageNames(Set<String> packageNames) {
        WebView w = mTabControl.getCurrentWebView();
        if (w == null) {
            return;
        }

        w.addPackageNames(packageNames);
    }

    private void getInstalledPackages() {
        AsyncTask<Void, Void, Set<String> > task =
            new AsyncTask<Void, Void, Set<String> >() {
            protected Set<String> doInBackground(Void... unused) {
                Set<String> installedPackages = new HashSet<String>();
                PackageManager pm = BrowserActivity.this.getPackageManager();
                if (pm != null) {
                    List<PackageInfo> packages = pm.getInstalledPackages(0);
                    for (PackageInfo p : packages) {
                        if (BrowserActivity.this.sGoogleApps.contains(p.packageName)) {
                            installedPackages.add(p.packageName);
                        }
                    }
                }

                return installedPackages;
            }

            // Executes on the UI thread
            protected void onPostExecute(Set<String> installedPackages) {
                addPackageNames(installedPackages);
            }
        };
        task.execute();
    }

    final static int LOCK_ICON_UNSECURE = 0;
    final static int LOCK_ICON_SECURE   = 1;
    final static int LOCK_ICON_MIXED    = 2;

    private BrowserSettings mSettings;
    private TabControl      mTabControl;
    private ContentResolver mResolver;
    private FrameLayout     mContentView;
    private View            mCustomView;
    private FrameLayout     mCustomViewContainer;
    private WebChromeClient.CustomViewCallback mCustomViewCallback;

    // FIXME, temp address onPrepareMenu performance problem. When we move everything out of
    // view, we should rewrite this.
    private int mCurrentMenuState = 0;
    private int mMenuState = R.id.MAIN_MENU;
    private int mOldMenuState = EMPTY_MENU;
    private static final int EMPTY_MENU = -1;
    private Menu mMenu;

    private FindDialog mFindDialog;
    private SelectDialog mSelectDialog;
    // Used to prevent chording to result in firing two shortcuts immediately
    // one after another.  Fixes bug 1211714.
    boolean mCanChord;

    private boolean mInLoad;
    private boolean mIsNetworkUp;
    private boolean mDidStopLoad;

    /* package */ boolean mActivityInPause = true;

    private boolean mMenuIsDown;

    private static boolean mInTrace;

    // Performance probe
    private static final int[] SYSTEM_CPU_FORMAT = new int[] {
            Process.PROC_SPACE_TERM | Process.PROC_COMBINE,
            Process.PROC_SPACE_TERM | Process.PROC_OUT_LONG, // 1: user time
            Process.PROC_SPACE_TERM | Process.PROC_OUT_LONG, // 2: nice time
            Process.PROC_SPACE_TERM | Process.PROC_OUT_LONG, // 3: sys time
            Process.PROC_SPACE_TERM | Process.PROC_OUT_LONG, // 4: idle time
            Process.PROC_SPACE_TERM | Process.PROC_OUT_LONG, // 5: iowait time
            Process.PROC_SPACE_TERM | Process.PROC_OUT_LONG, // 6: irq time
            Process.PROC_SPACE_TERM | Process.PROC_OUT_LONG  // 7: softirq time
    };

    private long mStart;
    private long mProcessStart;
    private long mUserStart;
    private long mSystemStart;
    private long mIdleStart;
    private long mIrqStart;

    private long mUiStart;

    private Drawable    mMixLockIcon;
    private Drawable    mSecLockIcon;

    /* hold a ref so we can auto-cancel if necessary */
    private AlertDialog mAlertDialog;

    // The up-to-date URL and title (these can be different from those stored
    // in WebView, since it takes some time for the information in WebView to
    // get updated)
    private String mUrl;
    private String mTitle;

    // As PageInfo has different style for landscape / portrait, we have
    // to re-open it when configuration changed
    private AlertDialog mPageInfoDialog;
    private Tab mPageInfoView;
    // If the Page-Info dialog is launched from the SSL-certificate-on-error
    // dialog, we should not just dismiss it, but should get back to the
    // SSL-certificate-on-error dialog. This flag is used to store this state
    private boolean mPageInfoFromShowSSLCertificateOnError;

    // as SSLCertificateOnError has different style for landscape / portrait,
    // we have to re-open it when configuration changed
    private AlertDialog mSSLCertificateOnErrorDialog;
    private WebView mSSLCertificateOnErrorView;
    private SslErrorHandler mSSLCertificateOnErrorHandler;
    private SslError mSSLCertificateOnErrorError;

    // as SSLCertificate has different style for landscape / portrait, we
    // have to re-open it when configuration changed
    private AlertDialog mSSLCertificateDialog;
    private Tab mSSLCertificateView;

    // as HttpAuthentication has different style for landscape / portrait, we
    // have to re-open it when configuration changed
    private AlertDialog mHttpAuthenticationDialog;
    private HttpAuthHandler mHttpAuthHandler;

    /*package*/ static final FrameLayout.LayoutParams COVER_SCREEN_PARAMS =
                                            new FrameLayout.LayoutParams(
                                            ViewGroup.LayoutParams.MATCH_PARENT,
                                            ViewGroup.LayoutParams.MATCH_PARENT);
    /*package*/ static final FrameLayout.LayoutParams COVER_SCREEN_GRAVITY_CENTER =
                                            new FrameLayout.LayoutParams(
                                            ViewGroup.LayoutParams.MATCH_PARENT,
                                            ViewGroup.LayoutParams.MATCH_PARENT,
                                            Gravity.CENTER);
    // Google search
    final static String QuickSearch_G = ""http://www.google.com/m?q=%s"";

    final static String QUERY_PLACE_HOLDER = ""%s"";

    // ""source"" parameter for Google search through search key
    final static String GOOGLE_SEARCH_SOURCE_SEARCHKEY = ""browser-key"";
    // ""source"" parameter for Google search through goto menu
    final static String GOOGLE_SEARCH_SOURCE_GOTO = ""browser-goto"";
    // ""source"" parameter for Google search through simplily type
    final static String GOOGLE_SEARCH_SOURCE_TYPE = ""browser-type"";
    // ""source"" parameter for Google search suggested by the browser
    final static String GOOGLE_SEARCH_SOURCE_SUGGEST = ""browser-suggest"";
    // ""source"" parameter for Google search from unknown source
    final static String GOOGLE_SEARCH_SOURCE_UNKNOWN = ""unknown"";

    private final static String LOGTAG = ""browser"";

    private String mLastEnteredUrl;

    private PowerManager.WakeLock mWakeLock;
    private final static int WAKELOCK_TIMEOUT = 5 * 60 * 1000; // 5 minutes

    private Toast mStopToast;

    private TitleBar mTitleBar;

    private LinearLayout mErrorConsoleContainer = null;
    private boolean mShouldShowErrorConsole = false;

    // As the ids are dynamically created, we can't guarantee that they will
    // be in sequence, so this static array maps ids to a window number.
    final static private int[] WINDOW_SHORTCUT_ID_ARRAY =
    { R.id.window_one_menu_id, R.id.window_two_menu_id, R.id.window_three_menu_id,
      R.id.window_four_menu_id, R.id.window_five_menu_id, R.id.window_six_menu_id,
      R.id.window_seven_menu_id, R.id.window_eight_menu_id };

    // monitor platform changes
    private IntentFilter mNetworkStateChangedFilter;
    private BroadcastReceiver mNetworkStateIntentReceiver;

    private BroadcastReceiver mPackageInstallationReceiver;

    private SystemAllowGeolocationOrigins mSystemAllowGeolocationOrigins;

    // activity requestCode
    final static int COMBO_PAGE                 = 1;
    final static int PREFERENCES_PAGE           = 3;
    final static int FILE_SELECTED              = 4;

    // the default <video> poster
    private Bitmap mDefaultVideoPoster;
    // the video progress view
    private View mVideoProgressView;

    // The Google packages we monitor for the navigator.isApplicationInstalled()
    // API. Add as needed.
    private static Set<String> sGoogleApps;
    static {
        sGoogleApps = new HashSet<String>();
        sGoogleApps.add(""com.google.android.youtube"");
    }

    /**
     * A UrlData class to abstract how the content will be set to WebView.
     * This base class uses loadUrl to show the content.
     */
    /* package */ static class UrlData {
        final String mUrl;
        final Map<String, String> mHeaders;
        final Intent mVoiceIntent;

        UrlData(String url) {
            this.mUrl = url;
            this.mHeaders = null;
            this.mVoiceIntent = null;
        }

        UrlData(String url, Map<String, String> headers, Intent intent) {
            this.mUrl = url;
            this.mHeaders = headers;
            if (RecognizerResultsIntent.ACTION_VOICE_SEARCH_RESULTS
                    .equals(intent.getAction())) {
                this.mVoiceIntent = intent;
            } else {
                this.mVoiceIntent = null;
            }
        }

        boolean isEmpty() {
            return mVoiceIntent == null && (mUrl == null || mUrl.length() == 0);
        }

        /**
         * Load this UrlData into the given Tab.  Use loadUrlDataIn to update
         * the title bar as well.
         */
        public void loadIn(Tab t) {
            if (mVoiceIntent != null) {
                t.activateVoiceSearchMode(mVoiceIntent);
            } else {
                t.getWebView().loadUrl(mUrl, mHeaders);
            }
        }
    };

    /* package */ static final UrlData EMPTY_URL_DATA = new UrlData(null);
}
",True,37,2,3,3,19,14,19,L1
16,com.android.browser.Tab.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Vector;

import android.app.AlertDialog;
import android.app.SearchManager;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.Intent;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.graphics.Bitmap;
import android.net.Uri;
import android.net.http.SslError;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Message;
import android.os.SystemClock;
import android.provider.Browser;
import android.speech.RecognizerResultsIntent;
import android.util.Log;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewStub;
import android.view.View.OnClickListener;
import android.webkit.ConsoleMessage;
import android.webkit.CookieSyncManager;
import android.webkit.DownloadListener;
import android.webkit.GeolocationPermissions;
import android.webkit.HttpAuthHandler;
import android.webkit.SslErrorHandler;
import android.webkit.URLUtil;
import android.webkit.ValueCallback;
import android.webkit.WebBackForwardList;
import android.webkit.WebBackForwardListClient;
import android.webkit.WebChromeClient;
import android.webkit.WebHistoryItem;
import android.webkit.WebIconDatabase;
import android.webkit.WebStorage;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.FrameLayout;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.android.common.speech.LoggingEvents;

/**
 * Class for maintaining Tabs with a main WebView and a subwindow.
 */
class Tab {
    // Log Tag
    private static final String LOGTAG = ""Tab"";
    // Special case the logtag for messages for the Console to make it easier to
    // filter them and match the logtag used for these messages in older versions
    // of the browser.
    private static final String CONSOLE_LOGTAG = ""browser"";

    // The Geolocation permissions prompt
    private GeolocationPermissionsPrompt mGeolocationPermissionsPrompt;
    // Main WebView wrapper
    private LinearLayout mContainer;
    // Main WebView
    private WebView mMainView;
    // Subwindow container
    private View mSubViewContainer;
    // Subwindow WebView
    private WebView mSubView;
    // Saved bundle for when we are running low on memory. It contains the
    // information needed to restore the WebView if the user goes back to the
    // tab.
    private Bundle mSavedState;
    // Data used when displaying the tab in the picker.
    private PickerData mPickerData;
    // Parent Tab. This is the Tab that created this Tab, or null if the Tab was
    // created by the UI
    private Tab mParentTab;
    // Tab that constructed by this Tab. This is used when this Tab is
    // destroyed, it clears all mParentTab values in the children.
    private Vector<Tab> mChildTabs;
    // If true, the tab will be removed when back out of the first page.
    private boolean mCloseOnExit;
    // If true, the tab is in the foreground of the current activity.
    private boolean mInForeground;
    // If true, the tab is in loading state.
    private boolean mInLoad;
    // The time the load started, used to find load page time
    private long mLoadStartTime;
    // Application identifier used to find tabs that another application wants
    // to reuse.
    private String mAppId;
    // Keep the original url around to avoid killing the old WebView if the url
    // has not changed.
    private String mOriginalUrl;
    // Error console for the tab
    private ErrorConsoleView mErrorConsole;
    // the lock icon type and previous lock icon type for the tab
    private int mLockIconType;
    private int mPrevLockIconType;
    // Inflation service for making subwindows.
    private final LayoutInflater mInflateService;
    // The BrowserActivity which owners the Tab
    private final BrowserActivity mActivity;
    // The listener that gets invoked when a download is started from the
    // mMainView
    private final DownloadListener mDownloadListener;
    // Listener used to know when we move forward or back in the history list.
    private final WebBackForwardListClient mWebBackForwardListClient;

    // AsyncTask for downloading touch icons
    DownloadTouchIcon mTouchIconLoader;

    // Extra saved information for displaying the tab in the picker.
    private static class PickerData {
        String  mUrl;
        String  mTitle;
        Bitmap  mFavicon;
    }

    // Used for saving and restoring each Tab
    static final String WEBVIEW = ""webview"";
    static final String NUMTABS = ""numTabs"";
    static final String CURRTAB = ""currentTab"";
    static final String CURRURL = ""currentUrl"";
    static final String CURRTITLE = ""currentTitle"";
    static final String CLOSEONEXIT = ""closeonexit"";
    static final String PARENTTAB = ""parentTab"";
    static final String APPID = ""appid"";
    static final String ORIGINALURL = ""originalUrl"";

    // -------------------------------------------------------------------------

    /**
     * Private information regarding the latest voice search.  If the Tab is not
     * in voice search mode, this will be null.
     */
    private VoiceSearchData mVoiceSearchData;
    /**
     * Remove voice search mode from this tab.
     */
    public void revertVoiceSearchMode() {
        if (mVoiceSearchData != null) {
            mVoiceSearchData = null;
            if (mInForeground) {
                mActivity.revertVoiceTitleBar();
            }
        }
    }
    /**
     * Return whether the tab is in voice search mode.
     */
    public boolean isInVoiceSearchMode() {
        return mVoiceSearchData != null;
    }
    /**
     * Return true if the Tab is in voice search mode and the voice search
     * Intent came with a String identifying that Google provided the Intent.
     */
    public boolean voiceSearchSourceIsGoogle() {
        return mVoiceSearchData != null && mVoiceSearchData.mSourceIsGoogle;
    }
    /**
     * Get the title to display for the current voice search page.  If the Tab
     * is not in voice search mode, return null.
     */
    public String getVoiceDisplayTitle() {
        if (mVoiceSearchData == null) return null;
        return mVoiceSearchData.mLastVoiceSearchTitle;
    }
    /**
     * Get the latest array of voice search results, to be passed to the
     * BrowserProvider.  If the Tab is not in voice search mode, return null.
     */
    public ArrayList<String> getVoiceSearchResults() {
        if (mVoiceSearchData == null) return null;
        return mVoiceSearchData.mVoiceSearchResults;
    }
    /**
     * Activate voice search mode.
     * @param intent Intent which has the results to use, or an index into the
     *      results when reusing the old results.
     */
    /* package */ void activateVoiceSearchMode(Intent intent) {
        int index = 0;
        ArrayList<String> results = intent.getStringArrayListExtra(
                    RecognizerResultsIntent.EXTRA_VOICE_SEARCH_RESULT_STRINGS);
        if (results != null) {
            ArrayList<String> urls = intent.getStringArrayListExtra(
                        RecognizerResultsIntent.EXTRA_VOICE_SEARCH_RESULT_URLS);
            ArrayList<String> htmls = intent.getStringArrayListExtra(
                        RecognizerResultsIntent.EXTRA_VOICE_SEARCH_RESULT_HTML);
            ArrayList<String> baseUrls = intent.getStringArrayListExtra(
                        RecognizerResultsIntent
                        .EXTRA_VOICE_SEARCH_RESULT_HTML_BASE_URLS);
            // This tab is now entering voice search mode for the first time, or
            // a new voice search was done.
            int size = results.size();
            if (urls == null || size != urls.size()) {
                throw new AssertionError(""improper extras passed in Intent"");
            }
            if (htmls == null || htmls.size() != size || baseUrls == null ||
                    (baseUrls.size() != size && baseUrls.size() != 1)) {
                // If either of these arrays are empty/incorrectly sized, ignore
                // them.
                htmls = null;
                baseUrls = null;
            }
            mVoiceSearchData = new VoiceSearchData(results, urls, htmls,
                    baseUrls);
            mVoiceSearchData.mHeaders = intent.getParcelableArrayListExtra(
                    RecognizerResultsIntent
                    .EXTRA_VOICE_SEARCH_RESULT_HTTP_HEADERS);
            mVoiceSearchData.mSourceIsGoogle = intent.getBooleanExtra(
                    VoiceSearchData.SOURCE_IS_GOOGLE, false);
            mVoiceSearchData.mVoiceSearchIntent = new Intent(intent);
        }
        String extraData = intent.getStringExtra(
                SearchManager.EXTRA_DATA_KEY);
        if (extraData != null) {
            index = Integer.parseInt(extraData);
            if (index >= mVoiceSearchData.mVoiceSearchResults.size()) {
                throw new AssertionError(""index must be less than ""
                        + ""size of mVoiceSearchResults"");
            }
            if (mVoiceSearchData.mSourceIsGoogle) {
                Intent logIntent = new Intent(
                        LoggingEvents.ACTION_LOG_EVENT);
                logIntent.putExtra(LoggingEvents.EXTRA_EVENT,
                        LoggingEvents.VoiceSearch.N_BEST_CHOOSE);
                logIntent.putExtra(
                        LoggingEvents.VoiceSearch.EXTRA_N_BEST_CHOOSE_INDEX,
                        index);
                mActivity.sendBroadcast(logIntent);
            }
            if (mVoiceSearchData.mVoiceSearchIntent != null) {
                // Copy the Intent, so that each history item will have its own
                // Intent, with different (or none) extra data.
                Intent latest = new Intent(mVoiceSearchData.mVoiceSearchIntent);
                latest.putExtra(SearchManager.EXTRA_DATA_KEY, extraData);
                mVoiceSearchData.mVoiceSearchIntent = latest;
            }
        }
        mVoiceSearchData.mLastVoiceSearchTitle
                = mVoiceSearchData.mVoiceSearchResults.get(index);
        if (mInForeground) {
            mActivity.showVoiceTitleBar(mVoiceSearchData.mLastVoiceSearchTitle);
        }
        if (mVoiceSearchData.mVoiceSearchHtmls != null) {
            // When index was found it was already ensured that it was valid
            String uriString = mVoiceSearchData.mVoiceSearchHtmls.get(index);
            if (uriString != null) {
                Uri dataUri = Uri.parse(uriString);
                if (RecognizerResultsIntent.URI_SCHEME_INLINE.equals(
                        dataUri.getScheme())) {
                    // If there is only one base URL, use it.  If there are
                    // more, there will be one for each index, so use the base
                    // URL corresponding to the index.
                    String baseUrl = mVoiceSearchData.mVoiceSearchBaseUrls.get(
                            mVoiceSearchData.mVoiceSearchBaseUrls.size() > 1 ?
                            index : 0);
                    mVoiceSearchData.mLastVoiceSearchUrl = baseUrl;
                    mMainView.loadDataWithBaseURL(baseUrl,
                            uriString.substring(RecognizerResultsIntent
                            .URI_SCHEME_INLINE.length() + 1), ""text/html"",
                            ""utf-8"", baseUrl);
                    return;
                }
            }
        }
        mVoiceSearchData.mLastVoiceSearchUrl
                = mVoiceSearchData.mVoiceSearchUrls.get(index);
        if (null == mVoiceSearchData.mLastVoiceSearchUrl) {
            mVoiceSearchData.mLastVoiceSearchUrl = mActivity.smartUrlFilter(
                    mVoiceSearchData.mLastVoiceSearchTitle);
        }
        Map<String, String> headers = null;
        if (mVoiceSearchData.mHeaders != null) {
            int bundleIndex = mVoiceSearchData.mHeaders.size() == 1 ? 0
                    : index;
            Bundle bundle = mVoiceSearchData.mHeaders.get(bundleIndex);
            if (bundle != null && !bundle.isEmpty()) {
                Iterator<String> iter = bundle.keySet().iterator();
                headers = new HashMap<String, String>();
                while (iter.hasNext()) {
                    String key = iter.next();
                    headers.put(key, bundle.getString(key));
                }
            }
        }
        mMainView.loadUrl(mVoiceSearchData.mLastVoiceSearchUrl, headers);
    }
    /* package */ static class VoiceSearchData {
        public VoiceSearchData(ArrayList<String> results,
                ArrayList<String> urls, ArrayList<String> htmls,
                ArrayList<String> baseUrls) {
            mVoiceSearchResults = results;
            mVoiceSearchUrls = urls;
            mVoiceSearchHtmls = htmls;
            mVoiceSearchBaseUrls = baseUrls;
        }
        /*
         * ArrayList of suggestions to be displayed when opening the
         * SearchManager
         */
        public ArrayList<String> mVoiceSearchResults;
        /*
         * ArrayList of urls, associated with the suggestions in
         * mVoiceSearchResults.
         */
        public ArrayList<String> mVoiceSearchUrls;
        /*
         * ArrayList holding content to load for each item in
         * mVoiceSearchResults.
         */
        public ArrayList<String> mVoiceSearchHtmls;
        /*
         * ArrayList holding base urls for the items in mVoiceSearchResults.
         * If non null, this will either have the same size as
         * mVoiceSearchResults or have a size of 1, in which case all will use
         * the same base url
         */
        public ArrayList<String> mVoiceSearchBaseUrls;
        /*
         * The last url provided by voice search.  Used for comparison to see if
         * we are going to a page by some method besides voice search.
         */
        public String mLastVoiceSearchUrl;
        /**
         * The last title used for voice search.  Needed to update the title bar
         * when switching tabs.
         */
        public String mLastVoiceSearchTitle;
        /**
         * Whether the Intent which turned on voice search mode contained the
         * String signifying that Google was the source.
         */
        public boolean mSourceIsGoogle;
        /**
         * List of headers to be passed into the WebView containing location
         * information
         */
        public ArrayList<Bundle> mHeaders;
        /**
         * The Intent used to invoke voice search.  Placed on the
         * WebHistoryItem so that when coming back to a previous voice search
         * page we can again activate voice search.
         */
        public Intent mVoiceSearchIntent;
        /**
         * String used to identify Google as the source of voice search.
         */
        public static String SOURCE_IS_GOOGLE
                = ""android.speech.extras.SOURCE_IS_GOOGLE"";
    }

    // Container class for the next error dialog that needs to be displayed
    private class ErrorDialog {
        public final int mTitle;
        public final String mDescription;
        public final int mError;
        ErrorDialog(int title, String desc, int error) {
            mTitle = title;
            mDescription = desc;
            mError = error;
        }
    };

    private void processNextError() {
        if (mQueuedErrors == null) {
            return;
        }
        // The first one is currently displayed so just remove it.
        mQueuedErrors.removeFirst();
        if (mQueuedErrors.size() == 0) {
            mQueuedErrors = null;
            return;
        }
        showError(mQueuedErrors.getFirst());
    }

    private DialogInterface.OnDismissListener mDialogListener =
            new DialogInterface.OnDismissListener() {
                public void onDismiss(DialogInterface d) {
                    processNextError();
                }
            };
    private LinkedList<ErrorDialog> mQueuedErrors;

    private void queueError(int err, String desc) {
        if (mQueuedErrors == null) {
            mQueuedErrors = new LinkedList<ErrorDialog>();
        }
        for (ErrorDialog d : mQueuedErrors) {
            if (d.mError == err) {
                // Already saw a similar error, ignore the new one.
                return;
            }
        }
        ErrorDialog errDialog = new ErrorDialog(
                err == WebViewClient.ERROR_FILE_NOT_FOUND ?
                R.string.browserFrameFileErrorLabel :
                R.string.browserFrameNetworkErrorLabel,
                desc, err);
        mQueuedErrors.addLast(errDialog);

        // Show the dialog now if the queue was empty and it is in foreground
        if (mQueuedErrors.size() == 1 && mInForeground) {
            showError(errDialog);
        }
    }

    private void showError(ErrorDialog errDialog) {
        if (mInForeground) {
            AlertDialog d = new AlertDialog.Builder(mActivity)
                    .setTitle(errDialog.mTitle)
                    .setMessage(errDialog.mDescription)
                    .setPositiveButton(R.string.ok, null)
                    .create();
            d.setOnDismissListener(mDialogListener);
            d.show();
        }
    }

    // -------------------------------------------------------------------------
    // WebViewClient implementation for the main WebView
    // -------------------------------------------------------------------------

    private final WebViewClient mWebViewClient = new WebViewClient() {
        private Message mDontResend;
        private Message mResend;
        @Override
        public void onPageStarted(WebView view, String url, Bitmap favicon) {
            mInLoad = true;
            mLoadStartTime = SystemClock.uptimeMillis();
            if (mVoiceSearchData != null
                    && !url.equals(mVoiceSearchData.mLastVoiceSearchUrl)) {
                if (mVoiceSearchData.mSourceIsGoogle) {
                    Intent i = new Intent(LoggingEvents.ACTION_LOG_EVENT);
                    i.putExtra(LoggingEvents.EXTRA_FLUSH, true);
                    mActivity.sendBroadcast(i);
                }
                revertVoiceSearchMode();
            }

            // We've started to load a new page. If there was a pending message
            // to save a screenshot then we will now take the new page and save
            // an incorrect screenshot. Therefore, remove any pending thumbnail
            // messages from the queue.
            mActivity.removeMessages(BrowserActivity.UPDATE_BOOKMARK_THUMBNAIL,
                    view);

            // If we start a touch icon load and then load a new page, we don't
            // want to cancel the current touch icon loader. But, we do want to
            // create a new one when the touch icon url is known.
            if (mTouchIconLoader != null) {
                mTouchIconLoader.mTab = null;
                mTouchIconLoader = null;
            }

            // reset the error console
            if (mErrorConsole != null) {
                mErrorConsole.clearErrorMessages();
                if (mActivity.shouldShowErrorConsole()) {
                    mErrorConsole.showConsole(ErrorConsoleView.SHOW_NONE);
                }
            }

            // update the bookmark database for favicon
            if (favicon != null) {
                BrowserBookmarksAdapter.updateBookmarkFavicon(mActivity
                        .getContentResolver(), null, url, favicon);
            }

            // reset sync timer to avoid sync starts during loading a page
            CookieSyncManager.getInstance().resetSync();

            if (!mActivity.isNetworkUp()) {
                view.setNetworkAvailable(false);
            }

            // finally update the UI in the activity if it is in the foreground
            if (mInForeground) {
                mActivity.onPageStarted(view, url, favicon);
            }
        }

        @Override
        public void onPageFinished(WebView view, String url) {
            LogTag.logPageFinishedLoading(
                    url, SystemClock.uptimeMillis() - mLoadStartTime);
            mInLoad = false;

            if (mInForeground && !mActivity.didUserStopLoading()
                    || !mInForeground) {
                // Only update the bookmark screenshot if the user did not
                // cancel the load early.
                mActivity.postMessage(
                        BrowserActivity.UPDATE_BOOKMARK_THUMBNAIL, 0, 0, view,
                        500);
            }

            // finally update the UI in the activity if it is in the foreground
            if (mInForeground) {
                mActivity.onPageFinished(view, url);
            }
        }

        // return true if want to hijack the url to let another app to handle it
        @Override
        public boolean shouldOverrideUrlLoading(WebView view, String url) {
            if (voiceSearchSourceIsGoogle()) {
                // This method is called when the user clicks on a link.
                // VoiceSearchMode is turned off when the user leaves the
                // Google results page, so at this point the user must be on
                // that page.  If the user clicked a link on that page, assume
                // that the voice search was effective, and broadcast an Intent
                // so a receiver can take note of that fact.
                Intent logIntent = new Intent(LoggingEvents.ACTION_LOG_EVENT);
                logIntent.putExtra(LoggingEvents.EXTRA_EVENT,
                        LoggingEvents.VoiceSearch.RESULT_CLICKED);
                mActivity.sendBroadcast(logIntent);
            }
            if (mInForeground) {
                return mActivity.shouldOverrideUrlLoading(view, url);
            } else {
                return false;
            }
        }

        /**
         * Updates the lock icon. This method is called when we discover another
         * resource to be loaded for this page (for example, javascript). While
         * we update the icon type, we do not update the lock icon itself until
         * we are done loading, it is slightly more secure this way.
         */
        @Override
        public void onLoadResource(WebView view, String url) {
            if (url != null && url.length() > 0) {
                // It is only if the page claims to be secure that we may have
                // to update the lock:
                if (mLockIconType == BrowserActivity.LOCK_ICON_SECURE) {
                    // If NOT a 'safe' url, change the lock to mixed content!
                    if (!(URLUtil.isHttpsUrl(url) || URLUtil.isDataUrl(url)
                            || URLUtil.isAboutUrl(url))) {
                        mLockIconType = BrowserActivity.LOCK_ICON_MIXED;
                    }
                }
            }
        }

        /**
         * Show a dialog informing the user of the network error reported by
         * WebCore if it is in the foreground.
         */
        @Override
        public void onReceivedError(WebView view, int errorCode,
                String description, String failingUrl) {
            if (errorCode != WebViewClient.ERROR_HOST_LOOKUP &&
                    errorCode != WebViewClient.ERROR_CONNECT &&
                    errorCode != WebViewClient.ERROR_BAD_URL &&
                    errorCode != WebViewClient.ERROR_UNSUPPORTED_SCHEME &&
                    errorCode != WebViewClient.ERROR_FILE) {
                queueError(errorCode, description);
            }
            Log.e(LOGTAG, ""onReceivedError "" + errorCode + "" "" + failingUrl
                    + "" "" + description);

            // We need to reset the title after an error if it is in foreground.
            if (mInForeground) {
                mActivity.resetTitleAndRevertLockIcon();
            }
        }

        /**
         * Check with the user if it is ok to resend POST data as the page they
         * are trying to navigate to is the result of a POST.
         */
        @Override
        public void onFormResubmission(WebView view, final Message dontResend,
                                       final Message resend) {
            if (!mInForeground) {
                dontResend.sendToTarget();
                return;
            }
            if (mDontResend != null) {
                Log.w(LOGTAG, ""onFormResubmission should not be called again ""
                        + ""while dialog is still up"");
                dontResend.sendToTarget();
                return;
            }
            mDontResend = dontResend;
            mResend = resend;
            new AlertDialog.Builder(mActivity).setTitle(
                    R.string.browserFrameFormResubmitLabel).setMessage(
                    R.string.browserFrameFormResubmitMessage)
                    .setPositiveButton(R.string.ok,
                            new DialogInterface.OnClickListener() {
                                public void onClick(DialogInterface dialog,
                                        int which) {
                                    if (mResend != null) {
                                        mResend.sendToTarget();
                                        mResend = null;
                                        mDontResend = null;
                                    }
                                }
                            }).setNegativeButton(R.string.cancel,
                            new DialogInterface.OnClickListener() {
                                public void onClick(DialogInterface dialog,
                                        int which) {
                                    if (mDontResend != null) {
                                        mDontResend.sendToTarget();
                                        mResend = null;
                                        mDontResend = null;
                                    }
                                }
                            }).setOnCancelListener(new OnCancelListener() {
                        public void onCancel(DialogInterface dialog) {
                            if (mDontResend != null) {
                                mDontResend.sendToTarget();
                                mResend = null;
                                mDontResend = null;
                            }
                        }
                    }).show();
        }

        /**
         * Insert the url into the visited history database.
         * @param url The url to be inserted.
         * @param isReload True if this url is being reloaded.
         * FIXME: Not sure what to do when reloading the page.
         */
        @Override
        public void doUpdateVisitedHistory(WebView view, String url,
                boolean isReload) {
            if (url.regionMatches(true, 0, ""about:"", 0, 6)) {
                return;
            }
            // remove ""client"" before updating it to the history so that it wont
            // show up in the auto-complete list.
            int index = url.indexOf(""client=ms-"");
            if (index > 0 && url.contains("".google."")) {
                int end = url.indexOf('&', index);
                if (end > 0) {
                    url = url.substring(0, index)
                            .concat(url.substring(end + 1));
                } else {
                    // the url.charAt(index-1) should be either '?' or '&'
                    url = url.substring(0, index-1);
                }
            }
            final ContentResolver cr = mActivity.getContentResolver();
            final String newUrl = url;
            new AsyncTask<Void, Void, Void>() {
                protected Void doInBackground(Void... unused) {
                    Browser.updateVisitedHistory(cr, newUrl, true);
                    return null;
                }
            }.execute();
            WebIconDatabase.getInstance().retainIconForPageUrl(url);
        }

        /**
         * Displays SSL error(s) dialog to the user.
         */
        @Override
        public void onReceivedSslError(final WebView view,
                final SslErrorHandler handler, final SslError error) {
            if (!mInForeground) {
                handler.cancel();
                return;
            }
            if (BrowserSettings.getInstance().showSecurityWarnings()) {
                final LayoutInflater factory =
                    LayoutInflater.from(mActivity);
                final View warningsView =
                    factory.inflate(R.layout.ssl_warnings, null);
                final LinearLayout placeholder =
                    (LinearLayout)warningsView.findViewById(R.id.placeholder);

                if (error.hasError(SslError.SSL_UNTRUSTED)) {
                    LinearLayout ll = (LinearLayout)factory
                        .inflate(R.layout.ssl_warning, null);
                    ((TextView)ll.findViewById(R.id.warning))
                        .setText(R.string.ssl_untrusted);
                    placeholder.addView(ll);
                }

                if (error.hasError(SslError.SSL_IDMISMATCH)) {
                    LinearLayout ll = (LinearLayout)factory
                        .inflate(R.layout.ssl_warning, null);
                    ((TextView)ll.findViewById(R.id.warning))
                        .setText(R.string.ssl_mismatch);
                    placeholder.addView(ll);
                }

                if (error.hasError(SslError.SSL_EXPIRED)) {
                    LinearLayout ll = (LinearLayout)factory
                        .inflate(R.layout.ssl_warning, null);
                    ((TextView)ll.findViewById(R.id.warning))
                        .setText(R.string.ssl_expired);
                    placeholder.addView(ll);
                }

                if (error.hasError(SslError.SSL_NOTYETVALID)) {
                    LinearLayout ll = (LinearLayout)factory
                        .inflate(R.layout.ssl_warning, null);
                    ((TextView)ll.findViewById(R.id.warning))
                        .setText(R.string.ssl_not_yet_valid);
                    placeholder.addView(ll);
                }

                new AlertDialog.Builder(mActivity).setTitle(
                        R.string.security_warning).setIcon(
                        android.R.drawable.ic_dialog_alert).setView(
                        warningsView).setPositiveButton(R.string.ssl_continue,
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog,
                                    int whichButton) {
                                handler.proceed();
                            }
                        }).setNeutralButton(R.string.view_certificate,
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog,
                                    int whichButton) {
                                mActivity.showSSLCertificateOnError(view,
                                        handler, error);
                            }
                        }).setNegativeButton(R.string.cancel,
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog,
                                    int whichButton) {
                                handler.cancel();
                                mActivity.resetTitleAndRevertLockIcon();
                            }
                        }).setOnCancelListener(
                        new DialogInterface.OnCancelListener() {
                            public void onCancel(DialogInterface dialog) {
                                handler.cancel();
                                mActivity.resetTitleAndRevertLockIcon();
                            }
                        }).show();
            } else {
                handler.proceed();
            }
        }

        /**
         * Handles an HTTP authentication request.
         *
         * @param handler The authentication handler
         * @param host The host
         * @param realm The realm
         */
        @Override
        public void onReceivedHttpAuthRequest(WebView view,
                final HttpAuthHandler handler, final String host,
                final String realm) {
            String username = null;
            String password = null;

            boolean reuseHttpAuthUsernamePassword = handler
                    .useHttpAuthUsernamePassword();

            if (reuseHttpAuthUsernamePassword && view != null) {
                String[] credentials = view.getHttpAuthUsernamePassword(
                        host, realm);
                if (credentials != null && credentials.length == 2) {
                    username = credentials[0];
                    password = credentials[1];
                }
            }

            if (username != null && password != null) {
                handler.proceed(username, password);
            } else {
                if (mInForeground) {
                    mActivity.showHttpAuthentication(handler, host, realm,
                            null, null, null, 0);
                } else {
                    handler.cancel();
                }
            }
        }

        @Override
        public boolean shouldOverrideKeyEvent(WebView view, KeyEvent event) {
            if (!mInForeground) {
                return false;
            }
            if (mActivity.isMenuDown()) {
                // only check shortcut key when MENU is held
                return mActivity.getWindow().isShortcutKey(event.getKeyCode(),
                        event);
            } else {
                return false;
            }
        }

        @Override
        public void onUnhandledKeyEvent(WebView view, KeyEvent event) {
            if (!mInForeground || mActivity.mActivityInPause) {
                return;
            }
            if (event.isDown()) {
                mActivity.onKeyDown(event.getKeyCode(), event);
            } else {
                mActivity.onKeyUp(event.getKeyCode(), event);
            }
        }
    };

    // -------------------------------------------------------------------------
    // WebChromeClient implementation for the main WebView
    // -------------------------------------------------------------------------

    private final WebChromeClient mWebChromeClient = new WebChromeClient() {
        // Helper method to create a new tab or sub window.
        private void createWindow(final boolean dialog, final Message msg) {
            WebView.WebViewTransport transport =
                    (WebView.WebViewTransport) msg.obj;
            if (dialog) {
                createSubWindow();
                mActivity.attachSubWindow(Tab.this);
                transport.setWebView(mSubView);
            } else {
                final Tab newTab = mActivity.openTabAndShow(
                        BrowserActivity.EMPTY_URL_DATA, false, null);
                if (newTab != Tab.this) {
                    Tab.this.addChildTab(newTab);
                }
                transport.setWebView(newTab.getWebView());
            }
            msg.sendToTarget();
        }

        @Override
        public boolean onCreateWindow(WebView view, final boolean dialog,
                final boolean userGesture, final Message resultMsg) {
            // only allow new window or sub window for the foreground case
            if (!mInForeground) {
                return false;
            }
            // Short-circuit if we can't create any more tabs or sub windows.
            if (dialog && mSubView != null) {
                new AlertDialog.Builder(mActivity)
                        .setTitle(R.string.too_many_subwindows_dialog_title)
                        .setIcon(android.R.drawable.ic_dialog_alert)
                        .setMessage(R.string.too_many_subwindows_dialog_message)
                        .setPositiveButton(R.string.ok, null)
                        .show();
                return false;
            } else if (!mActivity.getTabControl().canCreateNewTab()) {
                new AlertDialog.Builder(mActivity)
                        .setTitle(R.string.too_many_windows_dialog_title)
                        .setIcon(android.R.drawable.ic_dialog_alert)
                        .setMessage(R.string.too_many_windows_dialog_message)
                        .setPositiveButton(R.string.ok, null)
                        .show();
                return false;
            }

            // Short-circuit if this was a user gesture.
            if (userGesture) {
                createWindow(dialog, resultMsg);
                return true;
            }

            // Allow the popup and create the appropriate window.
            final AlertDialog.OnClickListener allowListener =
                    new AlertDialog.OnClickListener() {
                        public void onClick(DialogInterface d,
                                int which) {
                            createWindow(dialog, resultMsg);
                        }
                    };

            // Block the popup by returning a null WebView.
            final AlertDialog.OnClickListener blockListener =
                    new AlertDialog.OnClickListener() {
                        public void onClick(DialogInterface d, int which) {
                            resultMsg.sendToTarget();
                        }
                    };

            // Build a confirmation dialog to display to the user.
            final AlertDialog d =
                    new AlertDialog.Builder(mActivity)
                    .setTitle(R.string.attention)
                    .setIcon(android.R.drawable.ic_dialog_alert)
                    .setMessage(R.string.popup_window_attempt)
                    .setPositiveButton(R.string.allow, allowListener)
                    .setNegativeButton(R.string.block, blockListener)
                    .setCancelable(false)
                    .create();

            // Show the confirmation dialog.
            d.show();
            return true;
        }

        @Override
        public void onRequestFocus(WebView view) {
            if (!mInForeground) {
                mActivity.switchToTab(mActivity.getTabControl().getTabIndex(
                        Tab.this));
            }
        }

        @Override
        public void onCloseWindow(WebView window) {
            if (mParentTab != null) {
                // JavaScript can only close popup window.
                if (mInForeground) {
                    mActivity.switchToTab(mActivity.getTabControl()
                            .getTabIndex(mParentTab));
                }
                mActivity.closeTab(Tab.this);
            }
        }

        @Override
        public void onProgressChanged(WebView view, int newProgress) {
            if (newProgress == 100) {
                // sync cookies and cache promptly here.
                CookieSyncManager.getInstance().sync();
            }
            if (mInForeground) {
                mActivity.onProgressChanged(view, newProgress);
            }
        }

        @Override
        public void onReceivedTitle(WebView view, final String title) {
            final String pageUrl = view.getUrl();
            if (mInForeground) {
                // here, if url is null, we want to reset the title
                mActivity.setUrlTitle(pageUrl, title);
            }
            if (pageUrl == null || pageUrl.length()
                    >= SQLiteDatabase.SQLITE_MAX_LIKE_PATTERN_LENGTH) {
                return;
            }
            new AsyncTask<Void, Void, Void>() {
                protected Void doInBackground(Void... unused) {
                    // See if we can find the current url in our history
                    // database and add the new title to it.
                    String url = pageUrl;
                    if (url.startsWith(""http://www."")) {
                        url = url.substring(11);
                    } else if (url.startsWith(""http://"")) {
                        url = url.substring(4);
                    }
                    // Escape wildcards for LIKE operator.
                    url = url.replace(""\\"", ""\\\\"").replace(""%"", ""\\%"")
                            .replace(""_"", ""\\_"");
                    Cursor c = null;
                    try {
                        final ContentResolver cr
                                = mActivity.getContentResolver();
                        url = ""%"" + url;
                        String [] selArgs = new String[] { url };
                        String where = Browser.BookmarkColumns.URL
                                + "" LIKE ? ESCAPE '\\' AND ""
                                + Browser.BookmarkColumns.BOOKMARK + "" = 0"";
                        c = cr.query(Browser.BOOKMARKS_URI, new String[]
                                { Browser.BookmarkColumns._ID }, where, selArgs,
                                null);
                        if (c.moveToFirst()) {
                            // Current implementation of database only has one
                            // entry per url.
                            ContentValues map = new ContentValues();
                            map.put(Browser.BookmarkColumns.TITLE, title);
                            String[] projection = new String[]
                                    { Integer.valueOf(c.getInt(0)).toString() };
                            cr.update(Browser.BOOKMARKS_URI, map, ""_id = ?"",
                                    projection);
                        }
                    } catch (IllegalStateException e) {
                        Log.e(LOGTAG, ""Tab onReceived title"", e);
                    } catch (SQLiteException ex) {
                        Log.e(LOGTAG,
                                ""onReceivedTitle() caught SQLiteException: "",
                                ex);
                    } finally {
                        if (c != null) c.close();
                    }
                    return null;
                }
            }.execute();
        }

        @Override
        public void onReceivedIcon(WebView view, Bitmap icon) {
            if (icon != null) {
                BrowserBookmarksAdapter.updateBookmarkFavicon(mActivity
                        .getContentResolver(), view.getOriginalUrl(), view
                        .getUrl(), icon);
            }
            if (mInForeground) {
                mActivity.setFavicon(icon);
            }
        }

        @Override
        public void onReceivedTouchIconUrl(WebView view, String url,
                boolean precomposed) {
            final ContentResolver cr = mActivity.getContentResolver();
            // Let precomposed icons take precedence over non-composed
            // icons.
            if (precomposed && mTouchIconLoader != null) {
                mTouchIconLoader.cancel(false);
                mTouchIconLoader = null;
            }
            // Have only one async task at a time.
            if (mTouchIconLoader == null) {
                mTouchIconLoader = new DownloadTouchIcon(Tab.this, cr, view);
                mTouchIconLoader.execute(url);
            }
        }

        @Override
        public void onSelectionDone(WebView view) {
            if (mInForeground) mActivity.closeDialogs();
        }

        @Override
        public void onSelectionStart(WebView view) {
            if (false && mInForeground) mActivity.showSelectDialog();
        }

        @Override
        public void onShowCustomView(View view,
                WebChromeClient.CustomViewCallback callback) {
            if (mInForeground) mActivity.onShowCustomView(view, callback);
        }

        @Override
        public void onHideCustomView() {
            if (mInForeground) mActivity.onHideCustomView();
        }

        /**
         * The origin has exceeded its database quota.
         * @param url the URL that exceeded the quota
         * @param databaseIdentifier the identifier of the database on which the
         *            transaction that caused the quota overflow was run
         * @param currentQuota the current quota for the origin.
         * @param estimatedSize the estimated size of the database.
         * @param totalUsedQuota is the sum of all origins' quota.
         * @param quotaUpdater The callback to run when a decision to allow or
         *            deny quota has been made. Don't forget to call this!
         */
        @Override
        public void onExceededDatabaseQuota(String url,
            String databaseIdentifier, long currentQuota, long estimatedSize,
            long totalUsedQuota, WebStorage.QuotaUpdater quotaUpdater) {
            BrowserSettings.getInstance().getWebStorageSizeManager()
                    .onExceededDatabaseQuota(url, databaseIdentifier,
                            currentQuota, estimatedSize, totalUsedQuota,
                            quotaUpdater);
        }

        /**
         * The Application Cache has exceeded its max size.
         * @param spaceNeeded is the amount of disk space that would be needed
         *            in order for the last appcache operation to succeed.
         * @param totalUsedQuota is the sum of all origins' quota.
         * @param quotaUpdater A callback to inform the WebCore thread that a
         *            new app cache size is available. This callback must always
         *            be executed at some point to ensure that the sleeping
         *            WebCore thread is woken up.
         */
        @Override
        public void onReachedMaxAppCacheSize(long spaceNeeded,
                long totalUsedQuota, WebStorage.QuotaUpdater quotaUpdater) {
            BrowserSettings.getInstance().getWebStorageSizeManager()
                    .onReachedMaxAppCacheSize(spaceNeeded, totalUsedQuota,
                            quotaUpdater);
        }

        /**
         * Instructs the browser to show a prompt to ask the user to set the
         * Geolocation permission state for the specified origin.
         * @param origin The origin for which Geolocation permissions are
         *     requested.
         * @param callback The callback to call once the user has set the
         *     Geolocation permission state.
         */
        @Override
        public void onGeolocationPermissionsShowPrompt(String origin,
                GeolocationPermissions.Callback callback) {
            if (mInForeground) {
                getGeolocationPermissionsPrompt().show(origin, callback);
            }
        }

        /**
         * Instructs the browser to hide the Geolocation permissions prompt.
         */
        @Override
        public void onGeolocationPermissionsHidePrompt() {
            if (mInForeground && mGeolocationPermissionsPrompt != null) {
                mGeolocationPermissionsPrompt.hide();
            }
        }

        /* Adds a JavaScript error message to the system log and if the JS
         * console is enabled in the about:debug options, to that console
         * also.
         * @param consoleMessage the message object.
         */
        @Override
        public boolean onConsoleMessage(ConsoleMessage consoleMessage) {
            if (mInForeground) {
                // call getErrorConsole(true) so it will create one if needed
                ErrorConsoleView errorConsole = getErrorConsole(true);
                errorConsole.addErrorMessage(consoleMessage);
                if (mActivity.shouldShowErrorConsole()
                        && errorConsole.getShowState() != ErrorConsoleView.SHOW_MAXIMIZED) {
                    errorConsole.showConsole(ErrorConsoleView.SHOW_MINIMIZED);
                }
            }

            String message = ""Console: "" + consoleMessage.message() + "" ""
                    + consoleMessage.sourceId() +  "":""
                    + consoleMessage.lineNumber();

            switch (consoleMessage.messageLevel()) {
                case TIP:
                    Log.v(CONSOLE_LOGTAG, message);
                    break;
                case LOG:
                    Log.i(CONSOLE_LOGTAG, message);
                    break;
                case WARNING:
                    Log.w(CONSOLE_LOGTAG, message);
                    break;
                case ERROR:
                    Log.e(CONSOLE_LOGTAG, message);
                    break;
                case DEBUG:
                    Log.d(CONSOLE_LOGTAG, message);
                    break;
            }

            return true;
        }

        /**
         * Ask the browser for an icon to represent a <video> element.
         * This icon will be used if the Web page did not specify a poster attribute.
         * @return Bitmap The icon or null if no such icon is available.
         */
        @Override
        public Bitmap getDefaultVideoPoster() {
            if (mInForeground) {
                return mActivity.getDefaultVideoPoster();
            }
            return null;
        }

        /**
         * Ask the host application for a custom progress view to show while
         * a <video> is loading.
         * @return View The progress view.
         */
        @Override
        public View getVideoLoadingProgressView() {
            if (mInForeground) {
                return mActivity.getVideoLoadingProgressView();
            }
            return null;
        }

        @Override
        public void openFileChooser(ValueCallback<Uri> uploadMsg) {
            if (mInForeground) {
                mActivity.openFileChooser(uploadMsg);
            } else {
                uploadMsg.onReceiveValue(null);
            }
        }

        /**
         * Deliver a list of already-visited URLs
         */
        @Override
        public void getVisitedHistory(final ValueCallback<String[]> callback) {
            AsyncTask<Void, Void, String[]> task = new AsyncTask<Void, Void, String[]>() {
                public String[] doInBackground(Void... unused) {
                    return Browser.getVisitedHistory(mActivity
                            .getContentResolver());
                }
                public void onPostExecute(String[] result) {
                    callback.onReceiveValue(result);
                };
            };
            task.execute();
        };
    };

    // -------------------------------------------------------------------------
    // WebViewClient implementation for the sub window
    // -------------------------------------------------------------------------

    // Subclass of WebViewClient used in subwindows to notify the main
    // WebViewClient of certain WebView activities.
    private static class SubWindowClient extends WebViewClient {
        // The main WebViewClient.
        private final WebViewClient mClient;
        private final BrowserActivity mBrowserActivity;

        SubWindowClient(WebViewClient client, BrowserActivity activity) {
            mClient = client;
            mBrowserActivity = activity;
        }
        @Override
        public void onPageStarted(WebView view, String url, Bitmap favicon) {
            // Unlike the others, do not call mClient's version, which would
            // change the progress bar.  However, we do want to remove the
            // find or select dialog.
            mBrowserActivity.closeDialogs();
        }
        @Override
        public void doUpdateVisitedHistory(WebView view, String url,
                boolean isReload) {
            mClient.doUpdateVisitedHistory(view, url, isReload);
        }
        @Override
        public boolean shouldOverrideUrlLoading(WebView view, String url) {
            return mClient.shouldOverrideUrlLoading(view, url);
        }
        @Override
        public void onReceivedSslError(WebView view, SslErrorHandler handler,
                SslError error) {
            mClient.onReceivedSslError(view, handler, error);
        }
        @Override
        public void onReceivedHttpAuthRequest(WebView view,
                HttpAuthHandler handler, String host, String realm) {
            mClient.onReceivedHttpAuthRequest(view, handler, host, realm);
        }
        @Override
        public void onFormResubmission(WebView view, Message dontResend,
                Message resend) {
            mClient.onFormResubmission(view, dontResend, resend);
        }
        @Override
        public void onReceivedError(WebView view, int errorCode,
                String description, String failingUrl) {
            mClient.onReceivedError(view, errorCode, description, failingUrl);
        }
        @Override
        public boolean shouldOverrideKeyEvent(WebView view,
                android.view.KeyEvent event) {
            return mClient.shouldOverrideKeyEvent(view, event);
        }
        @Override
        public void onUnhandledKeyEvent(WebView view,
                android.view.KeyEvent event) {
            mClient.onUnhandledKeyEvent(view, event);
        }
    }

    // -------------------------------------------------------------------------
    // WebChromeClient implementation for the sub window
    // -------------------------------------------------------------------------

    private class SubWindowChromeClient extends WebChromeClient {
        // The main WebChromeClient.
        private final WebChromeClient mClient;

        SubWindowChromeClient(WebChromeClient client) {
            mClient = client;
        }
        @Override
        public void onProgressChanged(WebView view, int newProgress) {
            mClient.onProgressChanged(view, newProgress);
        }
        @Override
        public boolean onCreateWindow(WebView view, boolean dialog,
                boolean userGesture, android.os.Message resultMsg) {
            return mClient.onCreateWindow(view, dialog, userGesture, resultMsg);
        }
        @Override
        public void onCloseWindow(WebView window) {
            if (window != mSubView) {
                Log.e(LOGTAG, ""Can't close the window"");
            }
            mActivity.dismissSubWindow(Tab.this);
        }
    }

    // -------------------------------------------------------------------------

    // Construct a new tab
    Tab(BrowserActivity activity, WebView w, boolean closeOnExit, String appId,
            String url) {
        mActivity = activity;
        mCloseOnExit = closeOnExit;
        mAppId = appId;
        mOriginalUrl = url;
        mLockIconType = BrowserActivity.LOCK_ICON_UNSECURE;
        mPrevLockIconType = BrowserActivity.LOCK_ICON_UNSECURE;
        mInLoad = false;
        mInForeground = false;

        mInflateService = LayoutInflater.from(activity);

        // The tab consists of a container view, which contains the main
        // WebView, as well as any other UI elements associated with the tab.
        mContainer = (LinearLayout) mInflateService.inflate(R.layout.tab, null);

        mDownloadListener = new DownloadListener() {
            public void onDownloadStart(String url, String userAgent,
                    String contentDisposition, String mimetype,
                    long contentLength) {
                mActivity.onDownloadStart(url, userAgent, contentDisposition,
                        mimetype, contentLength);
                if (mMainView.copyBackForwardList().getSize() == 0) {
                    // This Tab was opened for the sole purpose of downloading a
                    // file. Remove it.
                    if (mActivity.getTabControl().getCurrentWebView()
                            == mMainView) {
                        // In this case, the Tab is still on top.
                        mActivity.goBackOnePageOrQuit();
                    } else {
                        // In this case, it is not.
                        mActivity.closeTab(Tab.this);
                    }
                }
            }
        };
        mWebBackForwardListClient = new WebBackForwardListClient() {
            @Override
            public void onNewHistoryItem(WebHistoryItem item) {
                if (isInVoiceSearchMode()) {
                    item.setCustomData(mVoiceSearchData.mVoiceSearchIntent);
                }
            }
            @Override
            public void onIndexChanged(WebHistoryItem item, int index) {
                Object data = item.getCustomData();
                if (data != null && data instanceof Intent) {
                    activateVoiceSearchMode((Intent) data);
                }
            }
        };

        setWebView(w);
    }

    /**
     * Sets the WebView for this tab, correctly removing the old WebView from
     * the container view.
     */
    void setWebView(WebView w) {
        if (mMainView == w) {
            return;
        }
        // If the WebView is changing, the page will be reloaded, so any ongoing
        // Geolocation permission requests are void.
        if (mGeolocationPermissionsPrompt != null) {
            mGeolocationPermissionsPrompt.hide();
        }

        // Just remove the old one.
        FrameLayout wrapper =
                (FrameLayout) mContainer.findViewById(R.id.webview_wrapper);
        wrapper.removeView(mMainView);

        // set the new one
        mMainView = w;
        // attach the WebViewClient, WebChromeClient and DownloadListener
        if (mMainView != null) {
            mMainView.setWebViewClient(mWebViewClient);
            mMainView.setWebChromeClient(mWebChromeClient);
            // Attach DownloadManager so that downloads can start in an active
            // or a non-active window. This can happen when going to a site that
            // does a redirect after a period of time. The user could have
            // switched to another tab while waiting for the download to start.
            mMainView.setDownloadListener(mDownloadListener);
            mMainView.setWebBackForwardListClient(mWebBackForwardListClient);
        }
    }

    /**
     * Destroy the tab's main WebView and subWindow if any
     */
    void destroy() {
        if (mMainView != null) {
            dismissSubWindow();
            BrowserSettings.getInstance().deleteObserver(mMainView.getSettings());
            // save the WebView to call destroy() after detach it from the tab
            WebView webView = mMainView;
            setWebView(null);
            webView.destroy();
        }
    }

    /**
     * Remove the tab from the parent
     */
    void removeFromTree() {
        // detach the children
        if (mChildTabs != null) {
            for(Tab t : mChildTabs) {
                t.setParentTab(null);
            }
        }
        // remove itself from the parent list
        if (mParentTab != null) {
            mParentTab.mChildTabs.remove(this);
        }
    }

    /**
     * Create a new subwindow unless a subwindow already exists.
     * @return True if a new subwindow was created. False if one already exists.
     */
    boolean createSubWindow() {
        if (mSubView == null) {
            mActivity.closeDialogs();
            mSubViewContainer = mInflateService.inflate(
                    R.layout.browser_subwindow, null);
            mSubView = (WebView) mSubViewContainer.findViewById(R.id.webview);
            mSubView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_OVERLAY);
            // use trackball directly
            mSubView.setMapTrackballToArrowKeys(false);
            // Enable the built-in zoom
            mSubView.getSettings().setBuiltInZoomControls(true);
            mSubView.setWebViewClient(new SubWindowClient(mWebViewClient,
                    mActivity));
            mSubView.setWebChromeClient(new SubWindowChromeClient(
                    mWebChromeClient));
            // Set a different DownloadListener for the mSubView, since it will
            // just need to dismiss the mSubView, rather than close the Tab
            mSubView.setDownloadListener(new DownloadListener() {
                public void onDownloadStart(String url, String userAgent,
                        String contentDisposition, String mimetype,
                        long contentLength) {
                    mActivity.onDownloadStart(url, userAgent,
                            contentDisposition, mimetype, contentLength);
                    if (mSubView.copyBackForwardList().getSize() == 0) {
                        // This subwindow was opened for the sole purpose of
                        // downloading a file. Remove it.
                        mActivity.dismissSubWindow(Tab.this);
                    }
                }
            });
            mSubView.setOnCreateContextMenuListener(mActivity);
            final BrowserSettings s = BrowserSettings.getInstance();
            s.addObserver(mSubView.getSettings()).update(s, null);
            final ImageButton cancel = (ImageButton) mSubViewContainer
                    .findViewById(R.id.subwindow_close);
            cancel.setOnClickListener(new OnClickListener() {
                public void onClick(View v) {
                    mSubView.getWebChromeClient().onCloseWindow(mSubView);
                }
            });
            return true;
        }
        return false;
    }

    /**
     * Dismiss the subWindow for the tab.
     */
    void dismissSubWindow() {
        if (mSubView != null) {
            mActivity.closeDialogs();
            BrowserSettings.getInstance().deleteObserver(
                    mSubView.getSettings());
            mSubView.destroy();
            mSubView = null;
            mSubViewContainer = null;
        }
    }

    /**
     * Attach the sub window to the content view.
     */
    void attachSubWindow(ViewGroup content) {
        if (mSubView != null) {
            content.addView(mSubViewContainer,
                    BrowserActivity.COVER_SCREEN_PARAMS);
        }
    }

    /**
     * Remove the sub window from the content view.
     */
    void removeSubWindow(ViewGroup content) {
        if (mSubView != null) {
            content.removeView(mSubViewContainer);
            mActivity.closeDialogs();
        }
    }

    /**
     * This method attaches both the WebView and any sub window to the
     * given content view.
     */
    void attachTabToContentView(ViewGroup content) {
        if (mMainView == null) {
            return;
        }

        // Attach the WebView to the container and then attach the
        // container to the content view.
        FrameLayout wrapper =
                (FrameLayout) mContainer.findViewById(R.id.webview_wrapper);
        ViewGroup parent = (ViewGroup) mMainView.getParent();
        if (parent != wrapper) {
            if (parent != null) {
                Log.w(LOGTAG, ""mMainView already has a parent in""
                        + "" attachTabToContentView!"");
                parent.removeView(mMainView);
            }
            wrapper.addView(mMainView);
        } else {
            Log.w(LOGTAG, ""mMainView is already attached to wrapper in""
                    + "" attachTabToContentView!"");
        }
        parent = (ViewGroup) mContainer.getParent();
        if (parent != content) {
            if (parent != null) {
                Log.w(LOGTAG, ""mContainer already has a parent in""
                        + "" attachTabToContentView!"");
                parent.removeView(mContainer);
            }
            content.addView(mContainer, BrowserActivity.COVER_SCREEN_PARAMS);
        } else {
            Log.w(LOGTAG, ""mContainer is already attached to content in""
                    + "" attachTabToContentView!"");
        }
        attachSubWindow(content);
    }

    /**
     * Remove the WebView and any sub window from the given content view.
     */
    void removeTabFromContentView(ViewGroup content) {
        if (mMainView == null) {
            return;
        }

        // Remove the container from the content and then remove the
        // WebView from the container. This will trigger a focus change
        // needed by WebView.
        FrameLayout wrapper =
                (FrameLayout) mContainer.findViewById(R.id.webview_wrapper);
        wrapper.removeView(mMainView);
        content.removeView(mContainer);
        mActivity.closeDialogs();
        removeSubWindow(content);
    }

    /**
     * Set the parent tab of this tab.
     */
    void setParentTab(Tab parent) {
        mParentTab = parent;
        // This tab may have been freed due to low memory. If that is the case,
        // the parent tab index is already saved. If we are changing that index
        // (most likely due to removing the parent tab) we must update the
        // parent tab index in the saved Bundle.
        if (mSavedState != null) {
            if (parent == null) {
                mSavedState.remove(PARENTTAB);
            } else {
                mSavedState.putInt(PARENTTAB, mActivity.getTabControl()
                        .getTabIndex(parent));
            }
        }
    }

    /**
     * When a Tab is created through the content of another Tab, then we
     * associate the Tabs.
     * @param child the Tab that was created from this Tab
     */
    void addChildTab(Tab child) {
        if (mChildTabs == null) {
            mChildTabs = new Vector<Tab>();
        }
        mChildTabs.add(child);
        child.setParentTab(this);
    }

    Vector<Tab> getChildTabs() {
        return mChildTabs;
    }

    void resume() {
        if (mMainView != null) {
            mMainView.onResume();
            if (mSubView != null) {
                mSubView.onResume();
            }
        }
    }

    void pause() {
        if (mMainView != null) {
            mMainView.onPause();
            if (mSubView != null) {
                mSubView.onPause();
            }
        }
    }

    void putInForeground() {
        mInForeground = true;
        resume();
        mMainView.setOnCreateContextMenuListener(mActivity);
        if (mSubView != null) {
            mSubView.setOnCreateContextMenuListener(mActivity);
        }
        // Show the pending error dialog if the queue is not empty
        if (mQueuedErrors != null && mQueuedErrors.size() >  0) {
            showError(mQueuedErrors.getFirst());
        }
    }

    void putInBackground() {
        mInForeground = false;
        pause();
        mMainView.setOnCreateContextMenuListener(null);
        if (mSubView != null) {
            mSubView.setOnCreateContextMenuListener(null);
        }
    }

    /**
     * Return the top window of this tab; either the subwindow if it is not
     * null or the main window.
     * @return The top window of this tab.
     */
    WebView getTopWindow() {
        if (mSubView != null) {
            return mSubView;
        }
        return mMainView;
    }

    /**
     * Return the main window of this tab. Note: if a tab is freed in the
     * background, this can return null. It is only guaranteed to be
     * non-null for the current tab.
     * @return The main WebView of this tab.
     */
    WebView getWebView() {
        return mMainView;
    }

    /**
     * Return the subwindow of this tab or null if there is no subwindow.
     * @return The subwindow of this tab or null.
     */
    WebView getSubWebView() {
        return mSubView;
    }

    /**
     * @return The geolocation permissions prompt for this tab.
     */
    GeolocationPermissionsPrompt getGeolocationPermissionsPrompt() {
        if (mGeolocationPermissionsPrompt == null) {
            ViewStub stub = (ViewStub) mContainer
                    .findViewById(R.id.geolocation_permissions_prompt);
            mGeolocationPermissionsPrompt = (GeolocationPermissionsPrompt) stub
                    .inflate();
            mGeolocationPermissionsPrompt.init();
        }
        return mGeolocationPermissionsPrompt;
    }

    /**
     * @return The application id string
     */
    String getAppId() {
        return mAppId;
    }

    /**
     * Set the application id string
     * @param id
     */
    void setAppId(String id) {
        mAppId = id;
    }

    /**
     * @return The original url associated with this Tab
     */
    String getOriginalUrl() {
        return mOriginalUrl;
    }

    /**
     * Set the original url associated with this tab
     */
    void setOriginalUrl(String url) {
        mOriginalUrl = url;
    }

    /**
     * Get the url of this tab. Valid after calling populatePickerData, but
     * before calling wipePickerData, or if the webview has been destroyed.
     * @return The WebView's url or null.
     */
    String getUrl() {
        if (mPickerData != null) {
            return mPickerData.mUrl;
        }
        return null;
    }

    /**
     * Get the title of this tab. Valid after calling populatePickerData, but
     * before calling wipePickerData, or if the webview has been destroyed. If
     * the url has no title, use the url instead.
     * @return The WebView's title (or url) or null.
     */
    String getTitle() {
        if (mPickerData != null) {
            return mPickerData.mTitle;
        }
        return null;
    }

    /**
     * Get the favicon of this tab. Valid after calling populatePickerData, but
     * before calling wipePickerData, or if the webview has been destroyed.
     * @return The WebView's favicon or null.
     */
    Bitmap getFavicon() {
        if (mPickerData != null) {
            return mPickerData.mFavicon;
        }
        return null;
    }

    /**
     * Return the tab's error console. Creates the console if createIfNEcessary
     * is true and we haven't already created the console.
     * @param createIfNecessary Flag to indicate if the console should be
     *            created if it has not been already.
     * @return The tab's error console, or null if one has not been created and
     *         createIfNecessary is false.
     */
    ErrorConsoleView getErrorConsole(boolean createIfNecessary) {
        if (createIfNecessary && mErrorConsole == null) {
            mErrorConsole = new ErrorConsoleView(mActivity);
            mErrorConsole.setWebView(mMainView);
        }
        return mErrorConsole;
    }

    /**
     * If this Tab was created through another Tab, then this method returns
     * that Tab.
     * @return the Tab parent or null
     */
    public Tab getParentTab() {
        return mParentTab;
    }

    /**
     * Return whether this tab should be closed when it is backing out of the
     * first page.
     * @return TRUE if this tab should be closed when exit.
     */
    boolean closeOnExit() {
        return mCloseOnExit;
    }

    /**
     * Saves the current lock-icon state before resetting the lock icon. If we
     * have an error, we may need to roll back to the previous state.
     */
    void resetLockIcon(String url) {
        mPrevLockIconType = mLockIconType;
        mLockIconType = BrowserActivity.LOCK_ICON_UNSECURE;
        if (URLUtil.isHttpsUrl(url)) {
            mLockIconType = BrowserActivity.LOCK_ICON_SECURE;
        }
    }

    /**
     * Reverts the lock-icon state to the last saved state, for example, if we
     * had an error, and need to cancel the load.
     */
    void revertLockIcon() {
        mLockIconType = mPrevLockIconType;
    }

    /**
     * @return The tab's lock icon type.
     */
    int getLockIconType() {
        return mLockIconType;
    }

    /**
     * @return TRUE if onPageStarted is called while onPageFinished is not
     *         called yet.
     */
    boolean inLoad() {
        return mInLoad;
    }

    // force mInLoad to be false. This should only be called before closing the
    // tab to ensure BrowserActivity's pauseWebViewTimers() is called correctly.
    void clearInLoad() {
        mInLoad = false;
    }

    void populatePickerData() {
        if (mMainView == null) {
            populatePickerDataFromSavedState();
            return;
        }

        // FIXME: The only place we cared about subwindow was for
        // bookmarking (i.e. not when saving state). Was this deliberate?
        final WebBackForwardList list = mMainView.copyBackForwardList();
        final WebHistoryItem item = list != null ? list.getCurrentItem() : null;
        populatePickerData(item);
    }

    // Populate the picker data using the given history item and the current top
    // WebView.
    private void populatePickerData(WebHistoryItem item) {
        mPickerData = new PickerData();
        if (item != null) {
            mPickerData.mUrl = item.getUrl();
            mPickerData.mTitle = item.getTitle();
            mPickerData.mFavicon = item.getFavicon();
            if (mPickerData.mTitle == null) {
                mPickerData.mTitle = mPickerData.mUrl;
            }
        }
    }

    // Create the PickerData and populate it using the saved state of the tab.
    void populatePickerDataFromSavedState() {
        if (mSavedState == null) {
            return;
        }
        mPickerData = new PickerData();
        mPickerData.mUrl = mSavedState.getString(CURRURL);
        mPickerData.mTitle = mSavedState.getString(CURRTITLE);
    }

    void clearPickerData() {
        mPickerData = null;
    }

    /**
     * Get the saved state bundle.
     * @return
     */
    Bundle getSavedState() {
        return mSavedState;
    }

    /**
     * Set the saved state.
     */
    void setSavedState(Bundle state) {
        mSavedState = state;
    }

    /**
     * @return TRUE if succeed in saving the state.
     */
    boolean saveState() {
        // If the WebView is null it means we ran low on memory and we already
        // stored the saved state in mSavedState.
        if (mMainView == null) {
            return mSavedState != null;
        }

        mSavedState = new Bundle();
        final WebBackForwardList list = mMainView.saveState(mSavedState);

        // Store some extra info for displaying the tab in the picker.
        final WebHistoryItem item = list != null ? list.getCurrentItem() : null;
        populatePickerData(item);

        if (mPickerData.mUrl != null) {
            mSavedState.putString(CURRURL, mPickerData.mUrl);
        }
        if (mPickerData.mTitle != null) {
            mSavedState.putString(CURRTITLE, mPickerData.mTitle);
        }
        mSavedState.putBoolean(CLOSEONEXIT, mCloseOnExit);
        if (mAppId != null) {
            mSavedState.putString(APPID, mAppId);
        }
        if (mOriginalUrl != null) {
            mSavedState.putString(ORIGINALURL, mOriginalUrl);
        }
        // Remember the parent tab so the relationship can be restored.
        if (mParentTab != null) {
            mSavedState.putInt(PARENTTAB, mActivity.getTabControl().getTabIndex(
                    mParentTab));
        }
        return true;
    }

    /*
     * Restore the state of the tab.
     */
    boolean restoreState(Bundle b) {
        if (b == null) {
            return false;
        }
        // Restore the internal state even if the WebView fails to restore.
        // This will maintain the app id, original url and close-on-exit values.
        mSavedState = null;
        mPickerData = null;
        mCloseOnExit = b.getBoolean(CLOSEONEXIT);
        mAppId = b.getString(APPID);
        mOriginalUrl = b.getString(ORIGINALURL);

        final WebBackForwardList list = mMainView.restoreState(b);
        if (list == null) {
            return false;
        }
        return true;
    }

    /*
     * Opens the find and select text dialogs.  Called by BrowserActivity.
     */
    WebView showDialog(WebDialog dialog) {
        LinearLayout container;
        WebView view;
        if (mSubView != null) {
            view = mSubView;
            container = (LinearLayout) mSubViewContainer.findViewById(
                    R.id.inner_container);
        } else {
            view = mMainView;
            container = mContainer;
        }
        dialog.show();
        container.addView(dialog, 0, new LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT));
        dialog.setWebView(view);
        return view;
    }

    /*
     * Close the find or select dialog. Called by BrowserActivity.closeDialog.
     */
    void closeDialog(WebDialog dialog) {
        // The dialog may be attached to the subwindow.  Ensure that the
        // correct parent has it removed.
        LinearLayout parent = (LinearLayout) dialog.getParent();
        if (parent != null) parent.removeView(dialog);
    }
}
",True,36,2,2,3,18,8,10,L1
17,com.android.browser.SelectDialog.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.provider.Browser;
import android.view.LayoutInflater;
import android.view.View;

/* package */ class SelectDialog extends WebDialog {
    private View mCopyButton;
    private View mSelectAllButton;
    private View mShareButton;
    private View mFindButton;

    SelectDialog(BrowserActivity context) {
        super(context);
        LayoutInflater factory = LayoutInflater.from(context);
        factory.inflate(R.layout.browser_select, this);
        addCancel();

        mCopyButton = findViewById(R.id.copy);
        mCopyButton.setOnClickListener(mCopyListener);
        mSelectAllButton = findViewById(R.id.select_all);
        mSelectAllButton.setOnClickListener(mSelectAllListener);
        mShareButton = findViewById(R.id.share);
        mShareButton.setOnClickListener(mShareListener);
        mFindButton = findViewById(R.id.find);
        mFindButton.setOnClickListener(mFindListener);
    }

    private View.OnClickListener mCopyListener = new View.OnClickListener() {
        public void onClick(View v) {
            mWebView.copySelection();
            mBrowserActivity.closeDialogs();
        }
    };

    private View.OnClickListener mSelectAllListener = new View.OnClickListener() {
        public void onClick(View v) {
            mWebView.selectAll();
        }
    };

    private View.OnClickListener mShareListener = new View.OnClickListener() {
        public void onClick(View v) {
            String selection = mWebView.getSelection();
            Browser.sendString(mBrowserActivity, selection);
            mBrowserActivity.closeDialogs();
        }
    };

    private View.OnClickListener mFindListener = new View.OnClickListener() {
        public void onClick(View v) {
            String selection = mWebView.getSelection();
            mBrowserActivity.closeDialogs();
            mBrowserActivity.showFindDialog();
            mBrowserActivity.setFindDialogText(selection);
        }
    };

    /**
     * Called by BrowserActivity.closeDialog.  Start the animation to hide
     * the dialog, and inform the WebView that the dialog is being dismissed.
     */
    @Override
    public void dismiss() {
        super.dismiss();
        mWebView.notifySelectDialogDismissed();
    }

}
",False,33,0,0,4,17,1,2,L1
18,com.android.browser.BookmarkSearch.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;

/**
 * This activity is never started from the browser. Its purpose is to provide bookmark suggestions
 * to global search (through its searchable meta-data), and to handle the intents produced
 * by clicking such suggestions.
 */
public class BookmarkSearch extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Intent intent = getIntent();
        if (intent != null) {
            String action = intent.getAction();
            if (Intent.ACTION_VIEW.equals(action)) {
                intent.setClass(this, BrowserActivity.class);
                startActivity(intent);
            }
        }
        finish();
    }

}
",True,1,0,0,0,0,0,0,I0
19,com.android.browser.BrowserProvider.java,"/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import com.android.browser.search.SearchEngine;

import android.app.SearchManager;
import android.app.backup.BackupManager;
import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.UriMatcher;
import android.database.AbstractCursor;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.net.Uri;
import android.os.Process;
import android.preference.PreferenceManager;
import android.provider.Browser;
import android.provider.Browser.BookmarkColumns;
import android.speech.RecognizerResultsIntent;
import android.text.TextUtils;
import android.util.Log;
import android.util.Patterns;

import java.io.File;
import java.io.FilenameFilter;
import java.util.ArrayList;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public class BrowserProvider extends ContentProvider {

    private SQLiteOpenHelper mOpenHelper;
    private BackupManager mBackupManager;
    private static final String sDatabaseName = ""browser.db"";
    private static final String TAG = ""BrowserProvider"";
    private static final String ORDER_BY = ""visits DESC, date DESC"";

    private static final String PICASA_URL = ""http://picasaweb.google.com/m/"" +
            ""viewer?source=androidclient"";

    private static final String[] TABLE_NAMES = new String[] {
        ""bookmarks"", ""searches""
    };
    private static final String[] SUGGEST_PROJECTION = new String[] {
            ""_id"", ""url"", ""title"", ""bookmark"", ""user_entered""
    };
    private static final String SUGGEST_SELECTION =
            ""(url LIKE ? OR url LIKE ? OR url LIKE ? OR url LIKE ?""
                + "" OR title LIKE ?) AND (bookmark = 1 OR user_entered = 1)"";
    private String[] SUGGEST_ARGS = new String[5];

    // shared suggestion array index, make sure to match COLUMNS
    private static final int SUGGEST_COLUMN_INTENT_ACTION_ID = 1;
    private static final int SUGGEST_COLUMN_INTENT_DATA_ID = 2;
    private static final int SUGGEST_COLUMN_TEXT_1_ID = 3;
    private static final int SUGGEST_COLUMN_TEXT_2_ID = 4;
    private static final int SUGGEST_COLUMN_TEXT_2_URL_ID = 5;
    private static final int SUGGEST_COLUMN_ICON_1_ID = 6;
    private static final int SUGGEST_COLUMN_ICON_2_ID = 7;
    private static final int SUGGEST_COLUMN_QUERY_ID = 8;
    private static final int SUGGEST_COLUMN_INTENT_EXTRA_DATA = 9;

    // shared suggestion columns
    private static final String[] COLUMNS = new String[] {
            ""_id"",
            SearchManager.SUGGEST_COLUMN_INTENT_ACTION,
            SearchManager.SUGGEST_COLUMN_INTENT_DATA,
            SearchManager.SUGGEST_COLUMN_TEXT_1,
            SearchManager.SUGGEST_COLUMN_TEXT_2,
            SearchManager.SUGGEST_COLUMN_TEXT_2_URL,
            SearchManager.SUGGEST_COLUMN_ICON_1,
            SearchManager.SUGGEST_COLUMN_ICON_2,
            SearchManager.SUGGEST_COLUMN_QUERY,
            SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA};

    private static final int MAX_SUGGESTION_SHORT_ENTRIES = 3;
    private static final int MAX_SUGGESTION_LONG_ENTRIES = 6;
    private static final String MAX_SUGGESTION_LONG_ENTRIES_STRING =
            Integer.valueOf(MAX_SUGGESTION_LONG_ENTRIES).toString();

    // make sure that these match the index of TABLE_NAMES
    private static final int URI_MATCH_BOOKMARKS = 0;
    private static final int URI_MATCH_SEARCHES = 1;
    // (id % 10) should match the table name index
    private static final int URI_MATCH_BOOKMARKS_ID = 10;
    private static final int URI_MATCH_SEARCHES_ID = 11;
    //
    private static final int URI_MATCH_SUGGEST = 20;
    private static final int URI_MATCH_BOOKMARKS_SUGGEST = 21;

    private static final UriMatcher URI_MATCHER;

    static {
        URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
        URI_MATCHER.addURI(""browser"", TABLE_NAMES[URI_MATCH_BOOKMARKS],
                URI_MATCH_BOOKMARKS);
        URI_MATCHER.addURI(""browser"", TABLE_NAMES[URI_MATCH_BOOKMARKS] + ""/#"",
                URI_MATCH_BOOKMARKS_ID);
        URI_MATCHER.addURI(""browser"", TABLE_NAMES[URI_MATCH_SEARCHES],
                URI_MATCH_SEARCHES);
        URI_MATCHER.addURI(""browser"", TABLE_NAMES[URI_MATCH_SEARCHES] + ""/#"",
                URI_MATCH_SEARCHES_ID);
        URI_MATCHER.addURI(""browser"", SearchManager.SUGGEST_URI_PATH_QUERY,
                URI_MATCH_SUGGEST);
        URI_MATCHER.addURI(""browser"",
                TABLE_NAMES[URI_MATCH_BOOKMARKS] + ""/"" + SearchManager.SUGGEST_URI_PATH_QUERY,
                URI_MATCH_BOOKMARKS_SUGGEST);
    }

    // 1 -> 2 add cache table
    // 2 -> 3 update history table
    // 3 -> 4 add passwords table
    // 4 -> 5 add settings table
    // 5 -> 6 ?
    // 6 -> 7 ?
    // 7 -> 8 drop proxy table
    // 8 -> 9 drop settings table
    // 9 -> 10 add form_urls and form_data
    // 10 -> 11 add searches table
    // 11 -> 12 modify cache table
    // 12 -> 13 modify cache table
    // 13 -> 14 correspond with Google Bookmarks schema
    // 14 -> 15 move couple of tables to either browser private database or webview database
    // 15 -> 17 Set it up for the SearchManager
    // 17 -> 18 Added favicon in bookmarks table for Home shortcuts
    // 18 -> 19 Remove labels table
    // 19 -> 20 Added thumbnail
    // 20 -> 21 Added touch_icon
    // 21 -> 22 Remove ""clientid""
    // 22 -> 23 Added user_entered
    private static final int DATABASE_VERSION = 23;

    // Regular expression which matches http://, followed by some stuff, followed by
    // optionally a trailing slash, all matched as separate groups.
    private static final Pattern STRIP_URL_PATTERN = Pattern.compile(""^(http://)(.*?)(/$)?"");

    private BrowserSettings mSettings;

    public BrowserProvider() {
    }

    // XXX: This is a major hack to remove our dependency on gsf constants and
    // its content provider. http://b/issue?id=2425179
    static String getClientId(ContentResolver cr) {
        String ret = ""android-google"";
        Cursor c = null;
        try {
            c = cr.query(Uri.parse(""content://com.google.settings/partner""),
                    new String[] { ""value"" }, ""name='client_id'"", null, null);
            if (c != null && c.moveToNext()) {
                ret = c.getString(0);
            }
        } catch (RuntimeException ex) {
            // fall through to return the default
        } finally {
            if (c != null) {
                c.close();
            }
        }
        return ret;
    }

    private static CharSequence replaceSystemPropertyInString(Context context, CharSequence srcString) {
        StringBuffer sb = new StringBuffer();
        int lastCharLoc = 0;

        final String client_id = getClientId(context.getContentResolver());

        for (int i = 0; i < srcString.length(); ++i) {
            char c = srcString.charAt(i);
            if (c == '{') {
                sb.append(srcString.subSequence(lastCharLoc, i));
                lastCharLoc = i;
          inner:
                for (int j = i; j < srcString.length(); ++j) {
                    char k = srcString.charAt(j);
                    if (k == '}') {
                        String propertyKeyValue = srcString.subSequence(i + 1, j).toString();
                        if (propertyKeyValue.equals(""CLIENT_ID"")) {
                            sb.append(client_id);
                        } else {
                            sb.append(""unknown"");
                        }
                        lastCharLoc = j + 1;
                        i = j;
                        break inner;
                    }
                }
            }
        }
        if (srcString.length() - lastCharLoc > 0) {
            // Put on the tail, if there is one
            sb.append(srcString.subSequence(lastCharLoc, srcString.length()));
        }
        return sb;
    }

    private static class DatabaseHelper extends SQLiteOpenHelper {
        private Context mContext;

        public DatabaseHelper(Context context) {
            super(context, sDatabaseName, null, DATABASE_VERSION);
            mContext = context;
        }

        @Override
        public void onCreate(SQLiteDatabase db) {
            db.execSQL(""CREATE TABLE bookmarks ("" +
                    ""_id INTEGER PRIMARY KEY,"" +
                    ""title TEXT,"" +
                    ""url TEXT,"" +
                    ""visits INTEGER,"" +
                    ""date LONG,"" +
                    ""created LONG,"" +
                    ""description TEXT,"" +
                    ""bookmark INTEGER,"" +
                    ""favicon BLOB DEFAULT NULL,"" +
                    ""thumbnail BLOB DEFAULT NULL,"" +
                    ""touch_icon BLOB DEFAULT NULL,"" +
                    ""user_entered INTEGER"" +
                    "");"");

            final CharSequence[] bookmarks = mContext.getResources()
                    .getTextArray(R.array.bookmarks);
            int size = bookmarks.length;
            try {
                for (int i = 0; i < size; i = i + 2) {
                    CharSequence bookmarkDestination = replaceSystemPropertyInString(mContext, bookmarks[i + 1]);
                    db.execSQL(""INSERT INTO bookmarks (title, url, visits, "" +
                            ""date, created, bookmark)"" + "" VALUES('"" +
                            bookmarks[i] + ""', '"" + bookmarkDestination +
                            ""', 0, 0, 0, 1);"");
                }
            } catch (ArrayIndexOutOfBoundsException e) {
            }

            db.execSQL(""CREATE TABLE searches ("" +
                    ""_id INTEGER PRIMARY KEY,"" +
                    ""search TEXT,"" +
                    ""date LONG"" +
                    "");"");
        }

        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
            Log.w(TAG, ""Upgrading database from version "" + oldVersion + "" to ""
                    + newVersion);
            if (oldVersion == 18) {
                db.execSQL(""DROP TABLE IF EXISTS labels"");
            }
            if (oldVersion <= 19) {
                db.execSQL(""ALTER TABLE bookmarks ADD COLUMN thumbnail BLOB DEFAULT NULL;"");
            }
            if (oldVersion < 21) {
                db.execSQL(""ALTER TABLE bookmarks ADD COLUMN touch_icon BLOB DEFAULT NULL;"");
            }
            if (oldVersion < 22) {
                db.execSQL(""DELETE FROM bookmarks WHERE (bookmark = 0 AND url LIKE \""%.google.%client=ms-%\"")"");
                removeGears();
            }
            if (oldVersion < 23) {
                db.execSQL(""ALTER TABLE bookmarks ADD COLUMN user_entered INTEGER;"");
            } else {
                db.execSQL(""DROP TABLE IF EXISTS bookmarks"");
                db.execSQL(""DROP TABLE IF EXISTS searches"");
                onCreate(db);
            }
        }

        private void removeGears() {
            new Thread() {
                @Override
                public void run() {
                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                    String browserDataDirString = mContext.getApplicationInfo().dataDir;
                    final String appPluginsDirString = ""app_plugins"";
                    final String gearsPrefix = ""gears"";
                    File appPluginsDir = new File(browserDataDirString + File.separator
                            + appPluginsDirString);
                    if (!appPluginsDir.exists()) {
                        return;
                    }
                    // Delete the Gears plugin files
                    File[] gearsFiles = appPluginsDir.listFiles(new FilenameFilter() {
                        public boolean accept(File dir, String filename) {
                            return filename.startsWith(gearsPrefix);
                        }
                    });
                    for (int i = 0; i < gearsFiles.length; ++i) {
                        if (gearsFiles[i].isDirectory()) {
                            deleteDirectory(gearsFiles[i]);
                        } else {
                            gearsFiles[i].delete();
                        }
                    }
                    // Delete the Gears data files
                    File gearsDataDir = new File(browserDataDirString + File.separator
                            + gearsPrefix);
                    if (!gearsDataDir.exists()) {
                        return;
                    }
                    deleteDirectory(gearsDataDir);
                }

                private void deleteDirectory(File currentDir) {
                    File[] files = currentDir.listFiles();
                    for (int i = 0; i < files.length; ++i) {
                        if (files[i].isDirectory()) {
                            deleteDirectory(files[i]);
                        }
                        files[i].delete();
                    }
                    currentDir.delete();
                }
            }.start();
        }
    }

    @Override
    public boolean onCreate() {
        final Context context = getContext();
        mOpenHelper = new DatabaseHelper(context);
        mBackupManager = new BackupManager(context);
        // we added ""picasa web album"" into default bookmarks for version 19.
        // To avoid erasing the bookmark table, we added it explicitly for
        // version 18 and 19 as in the other cases, we will erase the table.
        if (DATABASE_VERSION == 18 || DATABASE_VERSION == 19) {
            SharedPreferences p = PreferenceManager
                    .getDefaultSharedPreferences(context);
            boolean fix = p.getBoolean(""fix_picasa"", true);
            if (fix) {
                fixPicasaBookmark();
                Editor ed = p.edit();
                ed.putBoolean(""fix_picasa"", false);
                ed.apply();
            }
        }
        mSettings = BrowserSettings.getInstance();
        return true;
    }

    private void fixPicasaBookmark() {
        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
        Cursor cursor = db.rawQuery(""SELECT _id FROM bookmarks WHERE "" +
                ""bookmark = 1 AND url = ?"", new String[] { PICASA_URL });
        try {
            if (!cursor.moveToFirst()) {
                // set ""created"" so that it will be on the top of the list
                db.execSQL(""INSERT INTO bookmarks (title, url, visits, "" +
                        ""date, created, bookmark)"" + "" VALUES('"" +
                        getContext().getString(R.string.picasa) + ""', '""
                        + PICASA_URL + ""', 0, 0, "" + new Date().getTime()
                        + "", 1);"");
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }

    /*
     * Subclass AbstractCursor so we can combine multiple Cursors and add
     * ""Search the web"".
     * Here are the rules.
     * 1. We only have MAX_SUGGESTION_LONG_ENTRIES in the list plus
     *      ""Search the web"";
     * 2. If bookmark/history entries has a match, ""Search the web"" shows up at
     *      the second place. Otherwise, ""Search the web"" shows up at the first
     *      place.
     */
    private class MySuggestionCursor extends AbstractCursor {
        private Cursor  mHistoryCursor;
        private Cursor  mSuggestCursor;
        private int     mHistoryCount;
        private int     mSuggestionCount;
        private boolean mIncludeWebSearch;
        private String  mString;
        private int     mSuggestText1Id;
        private int     mSuggestText2Id;
        private int     mSuggestText2UrlId;
        private int     mSuggestQueryId;
        private int     mSuggestIntentExtraDataId;

        public MySuggestionCursor(Cursor hc, Cursor sc, String string) {
            mHistoryCursor = hc;
            mSuggestCursor = sc;
            mHistoryCount = hc.getCount();
            mSuggestionCount = sc != null ? sc.getCount() : 0;
            if (mSuggestionCount > (MAX_SUGGESTION_LONG_ENTRIES - mHistoryCount)) {
                mSuggestionCount = MAX_SUGGESTION_LONG_ENTRIES - mHistoryCount;
            }
            mString = string;
            mIncludeWebSearch = string.length() > 0;

            // Some web suggest providers only give suggestions and have no description string for
            // items. The order of the result columns may be different as well. So retrieve the
            // column indices for the fields we need now and check before using below.
            if (mSuggestCursor == null) {
                mSuggestText1Id = -1;
                mSuggestText2Id = -1;
                mSuggestText2UrlId = -1;
                mSuggestQueryId = -1;
                mSuggestIntentExtraDataId = -1;
            } else {
                mSuggestText1Id = mSuggestCursor.getColumnIndex(
                                SearchManager.SUGGEST_COLUMN_TEXT_1);
                mSuggestText2Id = mSuggestCursor.getColumnIndex(
                                SearchManager.SUGGEST_COLUMN_TEXT_2);
                mSuggestText2UrlId = mSuggestCursor.getColumnIndex(
                        SearchManager.SUGGEST_COLUMN_TEXT_2_URL);
                mSuggestQueryId = mSuggestCursor.getColumnIndex(
                                SearchManager.SUGGEST_COLUMN_QUERY);
                mSuggestIntentExtraDataId = mSuggestCursor.getColumnIndex(
                                SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA);
            }
        }

        @Override
        public boolean onMove(int oldPosition, int newPosition) {
            if (mHistoryCursor == null) {
                return false;
            }
            if (mIncludeWebSearch) {
                if (mHistoryCount == 0 && newPosition == 0) {
                    return true;
                } else if (mHistoryCount > 0) {
                    if (newPosition == 0) {
                        mHistoryCursor.moveToPosition(0);
                        return true;
                    } else if (newPosition == 1) {
                        return true;
                    }
                }
                newPosition--;
            }
            if (mHistoryCount > newPosition) {
                mHistoryCursor.moveToPosition(newPosition);
            } else {
                mSuggestCursor.moveToPosition(newPosition - mHistoryCount);
            }
            return true;
        }

        @Override
        public int getCount() {
            if (mIncludeWebSearch) {
                return mHistoryCount + mSuggestionCount + 1;
            } else {
                return mHistoryCount + mSuggestionCount;
            }
        }

        @Override
        public String[] getColumnNames() {
            return COLUMNS;
        }

        @Override
        public String getString(int columnIndex) {
            if ((mPos != -1 && mHistoryCursor != null)) {
                int type = -1; // 0: web search; 1: history; 2: suggestion
                if (mIncludeWebSearch) {
                    if (mHistoryCount == 0 && mPos == 0) {
                        type = 0;
                    } else if (mHistoryCount > 0) {
                        if (mPos == 0) {
                            type = 1;
                        } else if (mPos == 1) {
                            type = 0;
                        }
                    }
                    if (type == -1) type = (mPos - 1) < mHistoryCount ? 1 : 2;
                } else {
                    type = mPos < mHistoryCount ? 1 : 2;
                }

                switch(columnIndex) {
                    case SUGGEST_COLUMN_INTENT_ACTION_ID:
                        if (type == 1) {
                            return Intent.ACTION_VIEW;
                        } else {
                            return Intent.ACTION_SEARCH;
                        }

                    case SUGGEST_COLUMN_INTENT_DATA_ID:
                        if (type == 1) {
                            return mHistoryCursor.getString(1);
                        } else {
                            return null;
                        }

                    case SUGGEST_COLUMN_TEXT_1_ID:
                        if (type == 0) {
                            return mString;
                        } else if (type == 1) {
                            return getHistoryTitle();
                        } else {
                            if (mSuggestText1Id == -1) return null;
                            return mSuggestCursor.getString(mSuggestText1Id);
                        }

                    case SUGGEST_COLUMN_TEXT_2_ID:
                        if (type == 0) {
                            return getContext().getString(R.string.search_the_web);
                        } else if (type == 1) {
                            return null;  // Use TEXT_2_URL instead
                        } else {
                            if (mSuggestText2Id == -1) return null;
                            return mSuggestCursor.getString(mSuggestText2Id);
                        }

                    case SUGGEST_COLUMN_TEXT_2_URL_ID:
                        if (type == 0) {
                            return null;
                        } else if (type == 1) {
                            return getHistoryUrl();
                        } else {
                            if (mSuggestText2UrlId == -1) return null;
                            return mSuggestCursor.getString(mSuggestText2UrlId);
                        }

                    case SUGGEST_COLUMN_ICON_1_ID:
                        if (type == 1) {
                            if (mHistoryCursor.getInt(3) == 1) {
                                return Integer.valueOf(
                                        R.drawable.ic_search_category_bookmark)
                                        .toString();
                            } else {
                                return Integer.valueOf(
                                        R.drawable.ic_search_category_history)
                                        .toString();
                            }
                        } else {
                            return Integer.valueOf(
                                    R.drawable.ic_search_category_suggest)
                                    .toString();
                        }

                    case SUGGEST_COLUMN_ICON_2_ID:
                        return ""0"";

                    case SUGGEST_COLUMN_QUERY_ID:
                        if (type == 0) {
                            return mString;
                        } else if (type == 1) {
                            // Return the url in the intent query column. This is ignored
                            // within the browser because our searchable is set to
                            // android:searchMode=""queryRewriteFromData"", but it is used by
                            // global search for query rewriting.
                            return mHistoryCursor.getString(1);
                        } else {
                            if (mSuggestQueryId == -1) return null;
                            return mSuggestCursor.getString(mSuggestQueryId);
                        }

                    case SUGGEST_COLUMN_INTENT_EXTRA_DATA:
                        if (type == 0) {
                            return null;
                        } else if (type == 1) {
                            return null;
                        } else {
                            if (mSuggestIntentExtraDataId == -1) return null;
                            return mSuggestCursor.getString(mSuggestIntentExtraDataId);
                        }
                }
            }
            return null;
        }

        @Override
        public double getDouble(int column) {
            throw new UnsupportedOperationException();
        }

        @Override
        public float getFloat(int column) {
            throw new UnsupportedOperationException();
        }

        @Override
        public int getInt(int column) {
            throw new UnsupportedOperationException();
        }

        @Override
        public long getLong(int column) {
            if ((mPos != -1) && column == 0) {
                return mPos;        // use row# as the _Id
            }
            throw new UnsupportedOperationException();
        }

        @Override
        public short getShort(int column) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean isNull(int column) {
            throw new UnsupportedOperationException();
        }

        // TODO Temporary change, finalize after jq's changes go in
        public void deactivate() {
            if (mHistoryCursor != null) {
                mHistoryCursor.deactivate();
            }
            if (mSuggestCursor != null) {
                mSuggestCursor.deactivate();
            }
            super.deactivate();
        }

        public boolean requery() {
            return (mHistoryCursor != null ? mHistoryCursor.requery() : false) |
                    (mSuggestCursor != null ? mSuggestCursor.requery() : false);
        }

        // TODO Temporary change, finalize after jq's changes go in
        public void close() {
            super.close();
            if (mHistoryCursor != null) {
                mHistoryCursor.close();
                mHistoryCursor = null;
            }
            if (mSuggestCursor != null) {
                mSuggestCursor.close();
                mSuggestCursor = null;
            }
        }

        /**
         * Provides the title (text line 1) for a browser suggestion, which should be the
         * webpage title. If the webpage title is empty, returns the stripped url instead.
         *
         * @return the title string to use
         */
        private String getHistoryTitle() {
            String title = mHistoryCursor.getString(2 /* webpage title */);
            if (TextUtils.isEmpty(title) || TextUtils.getTrimmedLength(title) == 0) {
                title = stripUrl(mHistoryCursor.getString(1 /* url */));
            }
            return title;
        }

        /**
         * Provides the subtitle (text line 2) for a browser suggestion, which should be the
         * webpage url. If the webpage title is empty, then the url should go in the title
         * instead, and the subtitle should be empty, so this would return null.
         *
         * @return the subtitle string to use, or null if none
         */
        private String getHistoryUrl() {
            String title = mHistoryCursor.getString(2 /* webpage title */);
            if (TextUtils.isEmpty(title) || TextUtils.getTrimmedLength(title) == 0) {
                return null;
            } else {
                return stripUrl(mHistoryCursor.getString(1 /* url */));
            }
        }

    }

    private static class ResultsCursor extends AbstractCursor {
        // Array indices for RESULTS_COLUMNS
        private static final int RESULT_ACTION_ID = 1;
        private static final int RESULT_DATA_ID = 2;
        private static final int RESULT_TEXT_ID = 3;
        private static final int RESULT_ICON_ID = 4;
        private static final int RESULT_EXTRA_ID = 5;

        private static final String[] RESULTS_COLUMNS = new String[] {
                ""_id"",
                SearchManager.SUGGEST_COLUMN_INTENT_ACTION,
                SearchManager.SUGGEST_COLUMN_INTENT_DATA,
                SearchManager.SUGGEST_COLUMN_TEXT_1,
                SearchManager.SUGGEST_COLUMN_ICON_1,
                SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA
        };
        private final ArrayList<String> mResults;
        public ResultsCursor(ArrayList<String> results) {
            mResults = results;
        }
        public int getCount() { return mResults.size(); }

        public String[] getColumnNames() {
            return RESULTS_COLUMNS;
        }

        public String getString(int column) {
            switch (column) {
                case RESULT_ACTION_ID:
                    return RecognizerResultsIntent.ACTION_VOICE_SEARCH_RESULTS;
                case RESULT_TEXT_ID:
                // The data is used when the phone is in landscape mode.  We
                // still want to show the result string.
                case RESULT_DATA_ID:
                    return mResults.get(mPos);
                case RESULT_EXTRA_ID:
                    // The Intent's extra data will store the index into
                    // mResults so the BrowserActivity will know which result to
                    // use.
                    return Integer.toString(mPos);
                case RESULT_ICON_ID:
                    return Integer.valueOf(R.drawable.magnifying_glass)
                            .toString();
                default:
                    return null;
            }
        }
        public short getShort(int column) {
            throw new UnsupportedOperationException();
        }
        public int getInt(int column) {
            throw new UnsupportedOperationException();
        }
        public long getLong(int column) {
            if ((mPos != -1) && column == 0) {
                return mPos;        // use row# as the _id
            }
            throw new UnsupportedOperationException();
        }
        public float getFloat(int column) {
            throw new UnsupportedOperationException();
        }
        public double getDouble(int column) {
            throw new UnsupportedOperationException();
        }
        public boolean isNull(int column) {
            throw new UnsupportedOperationException();
        }
    }

    private ResultsCursor mResultsCursor;

    /**
     * Provide a set of results to be returned to query, intended to be used
     * by the SearchDialog when the BrowserActivity is in voice search mode.
     * @param results Strings to display in the dropdown from the SearchDialog
     */
    /* package */ void setQueryResults(ArrayList<String> results) {
        if (results == null) {
            mResultsCursor = null;
        } else {
            mResultsCursor = new ResultsCursor(results);
        }
    }

    @Override
    public Cursor query(Uri url, String[] projectionIn, String selection,
            String[] selectionArgs, String sortOrder)
            throws IllegalStateException {
        int match = URI_MATCHER.match(url);
        if (match == -1) {
            throw new IllegalArgumentException(""Unknown URL"");
        }
        if (match == URI_MATCH_SUGGEST && mResultsCursor != null) {
            Cursor results = mResultsCursor;
            mResultsCursor = null;
            return results;
        }
        SQLiteDatabase db = mOpenHelper.getReadableDatabase();

        if (match == URI_MATCH_SUGGEST || match == URI_MATCH_BOOKMARKS_SUGGEST) {
            String suggestSelection;
            String [] myArgs;
            if (selectionArgs[0] == null || selectionArgs[0].equals("""")) {
                suggestSelection = null;
                myArgs = null;
            } else {
                String like = selectionArgs[0] + ""%"";
                if (selectionArgs[0].startsWith(""http"")
                        || selectionArgs[0].startsWith(""file"")) {
                    myArgs = new String[1];
                    myArgs[0] = like;
                    suggestSelection = selection;
                } else {
                    SUGGEST_ARGS[0] = ""http://"" + like;
                    SUGGEST_ARGS[1] = ""http://www."" + like;
                    SUGGEST_ARGS[2] = ""https://"" + like;
                    SUGGEST_ARGS[3] = ""https://www."" + like;
                    // To match against titles.
                    SUGGEST_ARGS[4] = like;
                    myArgs = SUGGEST_ARGS;
                    suggestSelection = SUGGEST_SELECTION;
                }
            }

            Cursor c = db.query(TABLE_NAMES[URI_MATCH_BOOKMARKS],
                    SUGGEST_PROJECTION, suggestSelection, myArgs, null, null,
                    ORDER_BY, MAX_SUGGESTION_LONG_ENTRIES_STRING);

            if (match == URI_MATCH_BOOKMARKS_SUGGEST
                    || Patterns.WEB_URL.matcher(selectionArgs[0]).matches()) {
                return new MySuggestionCursor(c, null, """");
            } else {
                // get search suggestions if there is still space in the list
                if (myArgs != null && myArgs.length > 1
                        && c.getCount() < (MAX_SUGGESTION_SHORT_ENTRIES - 1)) {
                    SearchEngine searchEngine = mSettings.getSearchEngine();
                    if (searchEngine != null && searchEngine.supportsSuggestions()) {
                        Cursor sc = searchEngine.getSuggestions(getContext(), selectionArgs[0]);
                        return new MySuggestionCursor(c, sc, selectionArgs[0]);
                    }
                }
                return new MySuggestionCursor(c, null, selectionArgs[0]);
            }
        }

        String[] projection = null;
        if (projectionIn != null && projectionIn.length > 0) {
            projection = new String[projectionIn.length + 1];
            System.arraycopy(projectionIn, 0, projection, 0, projectionIn.length);
            projection[projectionIn.length] = ""_id AS _id"";
        }

        StringBuilder whereClause = new StringBuilder(256);
        if (match == URI_MATCH_BOOKMARKS_ID || match == URI_MATCH_SEARCHES_ID) {
            whereClause.append(""(_id = "").append(url.getPathSegments().get(1))
                    .append("")"");
        }

        // Tack on the user's selection, if present
        if (selection != null && selection.length() > 0) {
            if (whereClause.length() > 0) {
                whereClause.append("" AND "");
            }

            whereClause.append('(');
            whereClause.append(selection);
            whereClause.append(')');
        }
        Cursor c = db.query(TABLE_NAMES[match % 10], projection,
                whereClause.toString(), selectionArgs, null, null, sortOrder,
                null);
        c.setNotificationUri(getContext().getContentResolver(), url);
        return c;
    }

    @Override
    public String getType(Uri url) {
        int match = URI_MATCHER.match(url);
        switch (match) {
            case URI_MATCH_BOOKMARKS:
                return ""vnd.android.cursor.dir/bookmark"";

            case URI_MATCH_BOOKMARKS_ID:
                return ""vnd.android.cursor.item/bookmark"";

            case URI_MATCH_SEARCHES:
                return ""vnd.android.cursor.dir/searches"";

            case URI_MATCH_SEARCHES_ID:
                return ""vnd.android.cursor.item/searches"";

            case URI_MATCH_SUGGEST:
                return SearchManager.SUGGEST_MIME_TYPE;

            default:
                throw new IllegalArgumentException(""Unknown URL"");
        }
    }

    @Override
    public Uri insert(Uri url, ContentValues initialValues) {
        boolean isBookmarkTable = false;
        SQLiteDatabase db = mOpenHelper.getWritableDatabase();

        int match = URI_MATCHER.match(url);
        Uri uri = null;
        switch (match) {
            case URI_MATCH_BOOKMARKS: {
                // Insert into the bookmarks table
                long rowID = db.insert(TABLE_NAMES[URI_MATCH_BOOKMARKS], ""url"",
                        initialValues);
                if (rowID > 0) {
                    uri = ContentUris.withAppendedId(Browser.BOOKMARKS_URI,
                            rowID);
                }
                isBookmarkTable = true;
                break;
            }

            case URI_MATCH_SEARCHES: {
                // Insert into the searches table
                long rowID = db.insert(TABLE_NAMES[URI_MATCH_SEARCHES], ""url"",
                        initialValues);
                if (rowID > 0) {
                    uri = ContentUris.withAppendedId(Browser.SEARCHES_URI,
                            rowID);
                }
                break;
            }

            default:
                throw new IllegalArgumentException(""Unknown URL"");
        }

        if (uri == null) {
            throw new IllegalArgumentException(""Unknown URL"");
        }
        getContext().getContentResolver().notifyChange(uri, null);

        // Back up the new bookmark set if we just inserted one.
        // A row created when bookmarks are added from scratch will have
        // bookmark=1 in the initial value set.
        if (isBookmarkTable
                && initialValues.containsKey(BookmarkColumns.BOOKMARK)
                && initialValues.getAsInteger(BookmarkColumns.BOOKMARK) != 0) {
            mBackupManager.dataChanged();
        }
        return uri;
    }

    @Override
    public int delete(Uri url, String where, String[] whereArgs) {
        SQLiteDatabase db = mOpenHelper.getWritableDatabase();

        int match = URI_MATCHER.match(url);
        if (match == -1 || match == URI_MATCH_SUGGEST) {
            throw new IllegalArgumentException(""Unknown URL"");
        }

        // need to know whether it's the bookmarks table for a couple of reasons
        boolean isBookmarkTable = (match == URI_MATCH_BOOKMARKS_ID);
        String id = null;

        if (isBookmarkTable || match == URI_MATCH_SEARCHES_ID) {
            StringBuilder sb = new StringBuilder();
            if (where != null && where.length() > 0) {
                sb.append(""( "");
                sb.append(where);
                sb.append("" ) AND "");
            }
            id = url.getPathSegments().get(1);
            sb.append(""_id = "");
            sb.append(id);
            where = sb.toString();
        }

        ContentResolver cr = getContext().getContentResolver();

        // we'lll need to back up the bookmark set if we are about to delete one
        if (isBookmarkTable) {
            Cursor cursor = cr.query(Browser.BOOKMARKS_URI,
                    new String[] { BookmarkColumns.BOOKMARK },
                    ""_id = "" + id, null, null);
            if (cursor.moveToNext()) {
                if (cursor.getInt(0) != 0) {
                    // yep, this record is a bookmark
                    mBackupManager.dataChanged();
                }
            }
            cursor.close();
        }

        int count = db.delete(TABLE_NAMES[match % 10], where, whereArgs);
        cr.notifyChange(url, null);
        return count;
    }

    @Override
    public int update(Uri url, ContentValues values, String where,
            String[] whereArgs) {
        SQLiteDatabase db = mOpenHelper.getWritableDatabase();

        int match = URI_MATCHER.match(url);
        if (match == -1 || match == URI_MATCH_SUGGEST) {
            throw new IllegalArgumentException(""Unknown URL"");
        }

        if (match == URI_MATCH_BOOKMARKS_ID || match == URI_MATCH_SEARCHES_ID) {
            StringBuilder sb = new StringBuilder();
            if (where != null && where.length() > 0) {
                sb.append(""( "");
                sb.append(where);
                sb.append("" ) AND "");
            }
            String id = url.getPathSegments().get(1);
            sb.append(""_id = "");
            sb.append(id);
            where = sb.toString();
        }

        ContentResolver cr = getContext().getContentResolver();

        // Not all bookmark-table updates should be backed up.  Look to see
        // whether we changed the title, url, or ""is a bookmark"" state, and
        // request a backup if so.
        if (match == URI_MATCH_BOOKMARKS_ID || match == URI_MATCH_BOOKMARKS) {
            boolean changingBookmarks = false;
            // Alterations to the bookmark field inherently change the bookmark
            // set, so we don't need to query the record; we know a priori that
            // we will need to back up this change.
            if (values.containsKey(BookmarkColumns.BOOKMARK)) {
                changingBookmarks = true;
            } else if ((values.containsKey(BookmarkColumns.TITLE)
                     || values.containsKey(BookmarkColumns.URL))
                     && values.containsKey(BookmarkColumns._ID)) {
                // If a title or URL has been changed, check to see if it is to
                // a bookmark.  The ID should have been included in the update,
                // so use it.
                Cursor cursor = cr.query(Browser.BOOKMARKS_URI,
                        new String[] { BookmarkColumns.BOOKMARK },
                        BookmarkColumns._ID + "" = ""
                        + values.getAsString(BookmarkColumns._ID), null, null);
                if (cursor.moveToNext()) {
                    changingBookmarks = (cursor.getInt(0) != 0);
                }
                cursor.close();
            }

            // if this *is* a bookmark row we're altering, we need to back it up.
            if (changingBookmarks) {
                mBackupManager.dataChanged();
            }
        }

        int ret = db.update(TABLE_NAMES[match % 10], values, where, whereArgs);
        cr.notifyChange(url, null);
        return ret;
    }

    /**
     * Strips the provided url of preceding ""http://"" and any trailing ""/"". Does not
     * strip ""https://"". If the provided string cannot be stripped, the original string
     * is returned.
     *
     * TODO: Put this in TextUtils to be used by other packages doing something similar.
     *
     * @param url a url to strip, like ""http://www.google.com/""
     * @return a stripped url like ""www.google.com"", or the original string if it could
     *         not be stripped
     */
    private static String stripUrl(String url) {
        if (url == null) return null;
        Matcher m = STRIP_URL_PATTERN.matcher(url);
        if (m.matches() && m.groupCount() == 3) {
            return m.group(2);
        } else {
            return url;
        }
    }

}
",True,33,0,0,4,20,2,2,L1
20,com.android.browser.BookmarkItem.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.Context;
import android.graphics.Bitmap;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

/**
 *  Custom layout for an item representing a bookmark in the browser.
 */
class BookmarkItem extends LinearLayout {

    protected TextView    mTextView;
    protected TextView    mUrlText;
    protected ImageView   mImageView;
    protected String      mUrl;
    protected String      mTitle;

    /**
     *  Instantiate a bookmark item, including a default favicon.
     *
     *  @param context  The application context for the item.
     */
    BookmarkItem(Context context) {
        super(context);

        LayoutInflater factory = LayoutInflater.from(context);
        factory.inflate(R.layout.history_item, this);
        mTextView = (TextView) findViewById(R.id.title);
        mUrlText = (TextView) findViewById(R.id.url);
        mImageView = (ImageView) findViewById(R.id.favicon);
        View star = findViewById(R.id.star);
        star.setVisibility(View.GONE);
    }

    /**
     *  Copy this BookmarkItem to item.
     *  @param item BookmarkItem to receive the info from this BookmarkItem.
     */
    /* package */ void copyTo(BookmarkItem item) {
        item.mTextView.setText(mTextView.getText());
        item.mUrlText.setText(mUrlText.getText());
        item.mImageView.setImageDrawable(mImageView.getDrawable());
    }

    /**
     * Return the name assigned to this bookmark item.
     */
    /* package */ String getName() {
        return mTitle;
    }

    /**
     * Return the TextView which holds the name of this bookmark item.
     */
    /* package */ TextView getNameTextView() {
        return mTextView;
    }

    /* package */ String getUrl() {
        return mUrl;
    }

    /**
     *  Set the favicon for this item.
     *
     *  @param b    The new bitmap for this item.
     *              If it is null, will use the default.
     */
    /* package */ void setFavicon(Bitmap b) {
        if (b != null) {
            mImageView.setImageBitmap(b);
        } else {
            mImageView.setImageResource(R.drawable.app_web_browser_sm);
        }
    }

    /**
     *  Set the new name for the bookmark item.
     *
     *  @param name The new name for the bookmark item.
     */
    /* package */ void setName(String name) {
        if (name == null) {
            return;
        }

        mTitle = name;

        if (name.length() > BrowserSettings.MAX_TEXTVIEW_LEN) {
            name = name.substring(0, BrowserSettings.MAX_TEXTVIEW_LEN);
        }

        mTextView.setText(name);
    }
    
    /**
     *  Set the new url for the bookmark item.
     *  @param url  The new url for the bookmark item.
     */
    /* package */ void setUrl(String url) {
        if (url == null) {
            return;
        }

        mUrl = url;

        if (url.length() > BrowserSettings.MAX_TEXTVIEW_LEN) {
            url = url.substring(0, BrowserSettings.MAX_TEXTVIEW_LEN);
        }

        mUrlText.setText(url);
    }
}
",False,34,1,1,4,20,4,1,L1
21,com.android.browser.BrowserPreferencesPage.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.preference.EditTextPreference;
import android.preference.Preference;
import android.preference.PreferenceActivity;
import android.preference.PreferenceScreen;
import android.webkit.GeolocationPermissions;
import android.webkit.ValueCallback;
import android.webkit.WebStorage;

import java.util.Map;
import java.util.Set;

public class BrowserPreferencesPage extends PreferenceActivity
        implements Preference.OnPreferenceChangeListener {

    private String LOGTAG = ""BrowserPreferencesPage"";
    /* package */ static final String CURRENT_PAGE = ""currentPage"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Load the XML preferences file
        addPreferencesFromResource(R.xml.browser_preferences);

        Preference e = findPreference(BrowserSettings.PREF_HOMEPAGE);
        e.setOnPreferenceChangeListener(this);
        e.setSummary(getPreferenceScreen().getSharedPreferences()
                .getString(BrowserSettings.PREF_HOMEPAGE, null));
        ((BrowserHomepagePreference) e).setCurrentPage(
                getIntent().getStringExtra(CURRENT_PAGE));
        
        e = findPreference(BrowserSettings.PREF_EXTRAS_RESET_DEFAULTS);
        e.setOnPreferenceChangeListener(this);
        
        e = findPreference(BrowserSettings.PREF_TEXT_SIZE);
        e.setOnPreferenceChangeListener(this);
        e.setSummary(getVisualTextSizeName(
                getPreferenceScreen().getSharedPreferences()
                .getString(BrowserSettings.PREF_TEXT_SIZE, null)) );
        
        e = findPreference(BrowserSettings.PREF_DEFAULT_ZOOM);
        e.setOnPreferenceChangeListener(this);
        e.setSummary(getVisualDefaultZoomName(
                getPreferenceScreen().getSharedPreferences()
                .getString(BrowserSettings.PREF_DEFAULT_ZOOM, null)) );

        e = findPreference(BrowserSettings.PREF_DEFAULT_TEXT_ENCODING);
        e.setOnPreferenceChangeListener(this);

        e = findPreference(BrowserSettings.PREF_CLEAR_HISTORY);
        e.setOnPreferenceChangeListener(this);

        if (BrowserSettings.getInstance().showDebugSettings()) {
            addPreferencesFromResource(R.xml.debug_preferences);
        }

        PreferenceScreen websiteSettings = (PreferenceScreen)
            findPreference(BrowserSettings.PREF_WEBSITE_SETTINGS);
        Intent intent = new Intent(this, WebsiteSettingsActivity.class);
        websiteSettings.setIntent(intent);
    }

    /*
     * We need to set the PreferenceScreen state in onResume(), as the number of
     * origins with active features (WebStorage, Geolocation etc) could have
     * changed after calling the WebsiteSettingsActivity.
     */
    @Override
    protected void onResume() {
        super.onResume();
        final PreferenceScreen websiteSettings = (PreferenceScreen)
            findPreference(BrowserSettings.PREF_WEBSITE_SETTINGS);
        websiteSettings.setEnabled(false);
        WebStorage.getInstance().getOrigins(new ValueCallback<Map>() {
            public void onReceiveValue(Map webStorageOrigins) {
                if ((webStorageOrigins != null) && !webStorageOrigins.isEmpty()) {
                    websiteSettings.setEnabled(true);
                }
            }
        });
        GeolocationPermissions.getInstance().getOrigins(new ValueCallback<Set<String> >() {
            public void onReceiveValue(Set<String> geolocationOrigins) {
                if ((geolocationOrigins != null) && !geolocationOrigins.isEmpty()) {
                    websiteSettings.setEnabled(true);
                }
            }
        });
    }

    @Override
    protected void onPause() {
        super.onPause();

        // sync the shared preferences back to BrowserSettings
        BrowserSettings.getInstance().syncSharedPreferences(
                getApplicationContext(),
                getPreferenceScreen().getSharedPreferences());
    }

    public boolean onPreferenceChange(Preference pref, Object objValue) {
        if (pref.getKey().equals(BrowserSettings.PREF_EXTRAS_RESET_DEFAULTS)) {
            Boolean value = (Boolean) objValue;
            if (value.booleanValue() == true) {
                finish();
            }
        } else if (pref.getKey().equals(BrowserSettings.PREF_HOMEPAGE)) {
            String value = (String) objValue;
            boolean needUpdate = value.indexOf(' ') != -1;
            if (needUpdate) {
                value = value.trim().replace("" "", ""%20"");
            }
            if (value.length() != 0 && Uri.parse(value).getScheme() == null) {
                value = ""http://"" + value;
                needUpdate = true;
            }
            // Set the summary value.
            pref.setSummary(value);
            if (needUpdate) {
                // Update through the EditText control as it has a cached copy
                // of the string and it will handle persisting the value
                ((EditTextPreference) pref).setText(value);

                // as we update the value above, we need to return false
                // here so that setText() is not called by EditTextPref
                // with the old value.
                return false;
            } else {
                return true;
            }
        } else if (pref.getKey().equals(BrowserSettings.PREF_TEXT_SIZE)) {
            pref.setSummary(getVisualTextSizeName((String) objValue));
            return true;
        } else if (pref.getKey().equals(BrowserSettings.PREF_DEFAULT_ZOOM)) {
            pref.setSummary(getVisualDefaultZoomName((String) objValue));
            return true;
        } else if (pref.getKey().equals(
                BrowserSettings.PREF_DEFAULT_TEXT_ENCODING)) {
            pref.setSummary((String) objValue);
            return true;
        } else if (pref.getKey().equals(BrowserSettings.PREF_CLEAR_HISTORY)
                && ((Boolean) objValue).booleanValue() == true) {
            // Need to tell the browser to remove the parent/child relationship
            // between tabs
            setResult(RESULT_OK, (new Intent()).putExtra(Intent.EXTRA_TEXT,
                    pref.getKey()));
            return true;
        }
        
        return false;
    }

    private CharSequence getVisualTextSizeName(String enumName) {
        CharSequence[] visualNames = getResources().getTextArray(
                R.array.pref_text_size_choices);
        CharSequence[] enumNames = getResources().getTextArray(
                R.array.pref_text_size_values);

        // Sanity check
        if (visualNames.length != enumNames.length) {
            return """";
        }

        for (int i = 0; i < enumNames.length; i++) {
            if (enumNames[i].equals(enumName)) {
                return visualNames[i];
            }
        }

        return """";
    }

    private CharSequence getVisualDefaultZoomName(String enumName) {
        CharSequence[] visualNames = getResources().getTextArray(
                R.array.pref_default_zoom_choices);
        CharSequence[] enumNames = getResources().getTextArray(
                R.array.pref_default_zoom_values);

        // Sanity check
        if (visualNames.length != enumNames.length) {
            return """";
        }

        for (int i = 0; i < enumNames.length; i++) {
            if (enumNames[i].equals(enumName)) {
                return visualNames[i];
            }
        }

        return """";
    }
}
",True,33,0,0,4,19,1,2,L1
22,com.android.browser.BrowserSettings.java,"
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import com.android.browser.search.SearchEngine;
import com.android.browser.search.SearchEngines;

import android.app.ActivityManager;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.ActivityInfo;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.database.ContentObserver;
import android.os.Handler;
import android.preference.PreferenceActivity;
import android.preference.PreferenceScreen;
import android.provider.Settings;
import android.util.Log;
import android.webkit.CookieManager;
import android.webkit.GeolocationPermissions;
import android.webkit.ValueCallback;
import android.webkit.WebView;
import android.webkit.WebViewDatabase;
import android.webkit.WebIconDatabase;
import android.webkit.WebSettings;
import android.webkit.WebStorage;
import android.preference.PreferenceManager;
import android.provider.Browser;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.Observable;

/*
 * Package level class for storing various WebView and Browser settings. To use
 * this class:
 * BrowserSettings s = BrowserSettings.getInstance();
 * s.addObserver(webView.getSettings());
 * s.loadFromDb(context); // Only needed on app startup
 * s.javaScriptEnabled = true;
 * ... // set any other settings
 * s.update(); // this will update all the observers
 *
 * To remove an observer:
 * s.deleteObserver(webView.getSettings());
 */
class BrowserSettings extends Observable {

    // Private variables for settings
    // NOTE: these defaults need to be kept in sync with the XML
    // until the performance of PreferenceManager.setDefaultValues()
    // is improved.
    // Note: boolean variables are set inside reset function.
    private boolean loadsImagesAutomatically;
    private boolean javaScriptEnabled;
    private WebSettings.PluginState pluginState;
    private boolean javaScriptCanOpenWindowsAutomatically;
    private boolean showSecurityWarnings;
    private boolean rememberPasswords;
    private boolean saveFormData;
    private boolean openInBackground;
    private String defaultTextEncodingName;
    private String homeUrl = """";
    private SearchEngine searchEngine;
    private boolean autoFitPage;
    private boolean landscapeOnly;
    private boolean loadsPageInOverviewMode;
    private boolean showDebugSettings;
    // HTML5 API flags
    private boolean appCacheEnabled;
    private boolean databaseEnabled;
    private boolean domStorageEnabled;
    private boolean geolocationEnabled;
    private boolean workersEnabled;  // only affects V8. JSC does not have a similar setting
    // HTML5 API configuration params
    private long appCacheMaxSize = Long.MAX_VALUE;
    private String appCachePath;  // default value set in loadFromDb().
    private String databasePath; // default value set in loadFromDb()
    private String geolocationDatabasePath; // default value set in loadFromDb()
    private WebStorageSizeManager webStorageSizeManager;

    private String jsFlags = """";

    private final static String TAG = ""BrowserSettings"";

    // Development settings
    public WebSettings.LayoutAlgorithm layoutAlgorithm =
        WebSettings.LayoutAlgorithm.NARROW_COLUMNS;
    private boolean useWideViewPort = true;
    private int userAgent = 0;
    private boolean tracing = false;
    private boolean lightTouch = false;
    private boolean navDump = false;

    // By default the error console is shown once the user navigates to about:debug.
    // The setting can be then toggled from the settings menu.
    private boolean showConsole = true;

    // Private preconfigured values
    private static int minimumFontSize = 8;
    private static int minimumLogicalFontSize = 8;
    private static int defaultFontSize = 16;
    private static int defaultFixedFontSize = 13;
    private static WebSettings.TextSize textSize =
        WebSettings.TextSize.NORMAL;
    private static WebSettings.ZoomDensity zoomDensity =
        WebSettings.ZoomDensity.MEDIUM;
    private static int pageCacheCapacity;

    // Preference keys that are used outside this class
    public final static String PREF_CLEAR_CACHE = ""privacy_clear_cache"";
    public final static String PREF_CLEAR_COOKIES = ""privacy_clear_cookies"";
    public final static String PREF_CLEAR_HISTORY = ""privacy_clear_history"";
    public final static String PREF_HOMEPAGE = ""homepage"";
    public final static String PREF_SEARCH_ENGINE = ""search_engine"";
    public final static String PREF_CLEAR_FORM_DATA =
            ""privacy_clear_form_data"";
    public final static String PREF_CLEAR_PASSWORDS =
            ""privacy_clear_passwords"";
    public final static String PREF_EXTRAS_RESET_DEFAULTS =
            ""reset_default_preferences"";
    public final static String PREF_DEBUG_SETTINGS = ""debug_menu"";
    public final static String PREF_WEBSITE_SETTINGS = ""website_settings"";
    public final static String PREF_TEXT_SIZE = ""text_size"";
    public final static String PREF_DEFAULT_ZOOM = ""default_zoom"";
    public final static String PREF_DEFAULT_TEXT_ENCODING =
            ""default_text_encoding"";
    public final static String PREF_CLEAR_GEOLOCATION_ACCESS =
            ""privacy_clear_geolocation_access"";

    private static final String DESKTOP_USERAGENT = ""Mozilla/5.0 (Macintosh; "" +
            ""U; Intel Mac OS X 10_6_3; en-us) AppleWebKit/533.16 (KHTML, "" +
            ""like Gecko) Version/5.0 Safari/533.16"";

    private static final String IPHONE_USERAGENT = ""Mozilla/5.0 (iPhone; U; "" +
            ""CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 "" +
            ""(KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7"";

    private static final String IPAD_USERAGENT = ""Mozilla/5.0 (iPad; U; "" +
            ""CPU OS 3_2 like Mac OS X; en-us) AppleWebKit/531.21.10 "" +
            ""(KHTML, like Gecko) Version/4.0.4 Mobile/7B367 Safari/531.21.10"";

    private static final String FROYO_USERAGENT = ""Mozilla/5.0 (Linux; U; "" +
            ""Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 "" +
            ""(KHTML, like Gecko) Version/4.0 Mobile Safari/533.1"";

    // Value to truncate strings when adding them to a TextView within
    // a ListView
    public final static int MAX_TEXTVIEW_LEN = 80;

    private TabControl mTabControl;

    // Single instance of the BrowserSettings for use in the Browser app.
    private static BrowserSettings sSingleton;

    // Private map of WebSettings to Observer objects used when deleting an
    // observer.
    private HashMap<WebSettings,Observer> mWebSettingsToObservers =
        new HashMap<WebSettings,Observer>();

    /*
     * An observer wrapper for updating a WebSettings object with the new
     * settings after a call to BrowserSettings.update().
     */
    static class Observer implements java.util.Observer {
        // Private WebSettings object that will be updated.
        private WebSettings mSettings;

        Observer(WebSettings w) {
            mSettings = w;
        }

        public void update(Observable o, Object arg) {
            BrowserSettings b = (BrowserSettings)o;
            WebSettings s = mSettings;

            s.setLayoutAlgorithm(b.layoutAlgorithm);
            if (b.userAgent == 0) {
                // use the default ua string
                s.setUserAgentString(null);
            } else if (b.userAgent == 1) {
                s.setUserAgentString(DESKTOP_USERAGENT);
            } else if (b.userAgent == 2) {
                s.setUserAgentString(IPHONE_USERAGENT);
            } else if (b.userAgent == 3) {
                s.setUserAgentString(IPAD_USERAGENT);
            } else if (b.userAgent == 4) {
                s.setUserAgentString(FROYO_USERAGENT);
            }
            s.setUseWideViewPort(b.useWideViewPort);
            s.setLoadsImagesAutomatically(b.loadsImagesAutomatically);
            s.setJavaScriptEnabled(b.javaScriptEnabled);
            s.setPluginState(b.pluginState);
            s.setJavaScriptCanOpenWindowsAutomatically(
                    b.javaScriptCanOpenWindowsAutomatically);
            s.setDefaultTextEncodingName(b.defaultTextEncodingName);
            s.setMinimumFontSize(b.minimumFontSize);
            s.setMinimumLogicalFontSize(b.minimumLogicalFontSize);
            s.setDefaultFontSize(b.defaultFontSize);
            s.setDefaultFixedFontSize(b.defaultFixedFontSize);
            s.setNavDump(b.navDump);
            s.setTextSize(b.textSize);
            s.setDefaultZoom(b.zoomDensity);
            s.setLightTouchEnabled(b.lightTouch);
            s.setSaveFormData(b.saveFormData);
            s.setSavePassword(b.rememberPasswords);
            s.setLoadWithOverviewMode(b.loadsPageInOverviewMode);
            s.setPageCacheCapacity(pageCacheCapacity);

            // WebView inside Browser doesn't want initial focus to be set.
            s.setNeedInitialFocus(false);
            // Browser supports multiple windows
            s.setSupportMultipleWindows(true);

            // HTML5 API flags
            s.setAppCacheEnabled(b.appCacheEnabled);
            s.setDatabaseEnabled(b.databaseEnabled);
            s.setDomStorageEnabled(b.domStorageEnabled);
            s.setWorkersEnabled(b.workersEnabled);  // This only affects V8.
            s.setGeolocationEnabled(b.geolocationEnabled);

            // HTML5 configuration parameters.
            s.setAppCacheMaxSize(b.appCacheMaxSize);
            s.setAppCachePath(b.appCachePath);
            s.setDatabasePath(b.databasePath);
            s.setGeolocationDatabasePath(b.geolocationDatabasePath);

            b.updateTabControlSettings();
        }
    }

    /**
     * Load settings from the browser app's database.
     * NOTE: Strings used for the preferences must match those specified
     * in the browser_preferences.xml
     * @param ctx A Context object used to query the browser's settings
     *            database. If the database exists, the saved settings will be
     *            stored in this BrowserSettings object. This will update all
     *            observers of this object.
     */
    public void loadFromDb(final Context ctx) {
        SharedPreferences p =
                PreferenceManager.getDefaultSharedPreferences(ctx);
        // Set the default value for the Application Caches path.
        appCachePath = ctx.getDir(""appcache"", 0).getPath();
        // Determine the maximum size of the application cache.
        webStorageSizeManager = new WebStorageSizeManager(
                ctx,
                new WebStorageSizeManager.StatFsDiskInfo(appCachePath),
                new WebStorageSizeManager.WebKitAppCacheInfo(appCachePath));
        appCacheMaxSize = webStorageSizeManager.getAppCacheMaxSize();
        // Set the default value for the Database path.
        databasePath = ctx.getDir(""databases"", 0).getPath();
        // Set the default value for the Geolocation database path.
        geolocationDatabasePath = ctx.getDir(""geolocation"", 0).getPath();

        if (p.getString(PREF_HOMEPAGE, """") == """") {
            // No home page preferences is set, set it to default.
            setHomePage(ctx, getFactoryResetHomeUrl(ctx));
        }

        // the cost of one cached page is ~3M (measured using nytimes.com). For
        // low end devices, we only cache one page. For high end devices, we try
        // to cache more pages, currently choose 5.
        ActivityManager am = (ActivityManager) ctx
                .getSystemService(Context.ACTIVITY_SERVICE);
        if (am.getMemoryClass() > 16) {
            pageCacheCapacity = 5;
        } else {
            pageCacheCapacity = 1;
        }

    // Load the defaults from the xml
        // This call is TOO SLOW, need to manually keep the defaults
        // in sync
        //PreferenceManager.setDefaultValues(ctx, R.xml.browser_preferences);
        syncSharedPreferences(ctx, p);
    }

    /* package */ void syncSharedPreferences(Context ctx, SharedPreferences p) {

        homeUrl =
            p.getString(PREF_HOMEPAGE, homeUrl);
        String searchEngineName = p.getString(PREF_SEARCH_ENGINE,
                SearchEngine.GOOGLE);
        if (searchEngine == null || !searchEngine.getName().equals(searchEngineName)) {
            if (searchEngine != null) {
                if (searchEngine.supportsVoiceSearch()) {
                    // One or more tabs could have been in voice search mode.
                    // Clear it, since the new SearchEngine may not support
                    // it, or may handle it differently.
                    for (int i = 0; i < mTabControl.getTabCount(); i++) {
                        mTabControl.getTab(i).revertVoiceSearchMode();
                    }
                }
                searchEngine.close();
            }
            searchEngine = SearchEngines.get(ctx, searchEngineName);
        }
        Log.i(TAG, ""Selected search engine: "" + searchEngine);

        loadsImagesAutomatically = p.getBoolean(""load_images"",
                loadsImagesAutomatically);
        javaScriptEnabled = p.getBoolean(""enable_javascript"",
                javaScriptEnabled);
        pluginState = WebSettings.PluginState.valueOf(
                p.getString(""plugin_state"", pluginState.name()));
        javaScriptCanOpenWindowsAutomatically = !p.getBoolean(
            ""block_popup_windows"",
            !javaScriptCanOpenWindowsAutomatically);
        showSecurityWarnings = p.getBoolean(""show_security_warnings"",
                showSecurityWarnings);
        rememberPasswords = p.getBoolean(""remember_passwords"",
                rememberPasswords);
        saveFormData = p.getBoolean(""save_formdata"",
                saveFormData);
        boolean accept_cookies = p.getBoolean(""accept_cookies"",
                CookieManager.getInstance().acceptCookie());
        CookieManager.getInstance().setAcceptCookie(accept_cookies);
        openInBackground = p.getBoolean(""open_in_background"", openInBackground);
        textSize = WebSettings.TextSize.valueOf(
                p.getString(PREF_TEXT_SIZE, textSize.name()));
        zoomDensity = WebSettings.ZoomDensity.valueOf(
                p.getString(PREF_DEFAULT_ZOOM, zoomDensity.name()));
        autoFitPage = p.getBoolean(""autofit_pages"", autoFitPage);
        loadsPageInOverviewMode = p.getBoolean(""load_page"",
                loadsPageInOverviewMode);
        boolean landscapeOnlyTemp =
                p.getBoolean(""landscape_only"", landscapeOnly);
        if (landscapeOnlyTemp != landscapeOnly) {
            landscapeOnly = landscapeOnlyTemp;
        }
        useWideViewPort = true; // use wide view port for either setting
        if (autoFitPage) {
            layoutAlgorithm = WebSettings.LayoutAlgorithm.NARROW_COLUMNS;
        } else {
            layoutAlgorithm = WebSettings.LayoutAlgorithm.NORMAL;
        }
        defaultTextEncodingName =
                p.getString(PREF_DEFAULT_TEXT_ENCODING,
                        defaultTextEncodingName);

        showDebugSettings =
                p.getBoolean(PREF_DEBUG_SETTINGS, showDebugSettings);
        // Debug menu items have precidence if the menu is visible
        if (showDebugSettings) {
            boolean small_screen = p.getBoolean(""small_screen"",
                    layoutAlgorithm ==
                    WebSettings.LayoutAlgorithm.SINGLE_COLUMN);
            if (small_screen) {
                layoutAlgorithm = WebSettings.LayoutAlgorithm.SINGLE_COLUMN;
            } else {
                boolean normal_layout = p.getBoolean(""normal_layout"",
                        layoutAlgorithm == WebSettings.LayoutAlgorithm.NORMAL);
                if (normal_layout) {
                    layoutAlgorithm = WebSettings.LayoutAlgorithm.NORMAL;
                } else {
                    layoutAlgorithm =
                            WebSettings.LayoutAlgorithm.NARROW_COLUMNS;
                }
            }
            useWideViewPort = p.getBoolean(""wide_viewport"", useWideViewPort);
            tracing = p.getBoolean(""enable_tracing"", tracing);
            lightTouch = p.getBoolean(""enable_light_touch"", lightTouch);
            navDump = p.getBoolean(""enable_nav_dump"", navDump);
            userAgent = Integer.parseInt(p.getString(""user_agent"", ""0""));
        }
        // JS flags is loaded from DB even if showDebugSettings is false,
        // so that it can be set once and be effective all the time.
        jsFlags = p.getString(""js_engine_flags"", """");

        // Read the setting for showing/hiding the JS Console always so that should the
        // user enable debug settings, we already know if we should show the console.
        // The user will never see the console unless they navigate to about:debug,
        // regardless of the setting we read here. This setting is only used after debug
        // is enabled.
        showConsole = p.getBoolean(""javascript_console"", showConsole);

        // HTML5 API flags
        appCacheEnabled = p.getBoolean(""enable_appcache"", appCacheEnabled);
        databaseEnabled = p.getBoolean(""enable_database"", databaseEnabled);
        domStorageEnabled = p.getBoolean(""enable_domstorage"", domStorageEnabled);
        geolocationEnabled = p.getBoolean(""enable_geolocation"", geolocationEnabled);
        workersEnabled = p.getBoolean(""enable_workers"", workersEnabled);

        update();
    }

    public String getHomePage() {
        return homeUrl;
    }

    public SearchEngine getSearchEngine() {
        return searchEngine;
    }

    public String getJsFlags() {
        return jsFlags;
    }

    public WebStorageSizeManager getWebStorageSizeManager() {
        return webStorageSizeManager;
    }

    public void setHomePage(Context context, String url) {
        Editor ed = PreferenceManager.
                getDefaultSharedPreferences(context).edit();
        ed.putString(PREF_HOMEPAGE, url);
        ed.apply();
        homeUrl = url;
    }

    public WebSettings.TextSize getTextSize() {
        return textSize;
    }

    public WebSettings.ZoomDensity getDefaultZoom() {
        return zoomDensity;
    }

    public boolean openInBackground() {
        return openInBackground;
    }

    public boolean showSecurityWarnings() {
        return showSecurityWarnings;
    }

    public boolean isTracing() {
        return tracing;
    }

    public boolean isLightTouch() {
        return lightTouch;
    }

    public boolean isNavDump() {
        return navDump;
    }

    public boolean showDebugSettings() {
        return showDebugSettings;
    }

    public void toggleDebugSettings() {
        showDebugSettings = !showDebugSettings;
        navDump = showDebugSettings;
        update();
    }

    /**
     * Add a WebSettings object to the list of observers that will be updated
     * when update() is called.
     *
     * @param s A WebSettings object that is strictly tied to the life of a
     *            WebView.
     */
    public Observer addObserver(WebSettings s) {
        Observer old = mWebSettingsToObservers.get(s);
        if (old != null) {
            super.deleteObserver(old);
        }
        Observer o = new Observer(s);
        mWebSettingsToObservers.put(s, o);
        super.addObserver(o);
        return o;
    }

    /**
     * Delete the given WebSettings observer from the list of observers.
     * @param s The WebSettings object to be deleted.
     */
    public void deleteObserver(WebSettings s) {
        Observer o = mWebSettingsToObservers.get(s);
        if (o != null) {
            mWebSettingsToObservers.remove(s);
            super.deleteObserver(o);
        }
    }

    /*
     * Package level method for obtaining a single app instance of the
     * BrowserSettings.
     */
    /*package*/ static BrowserSettings getInstance() {
        if (sSingleton == null ) {
            sSingleton = new BrowserSettings();
        }
        return sSingleton;
    }

    /*
     * Package level method for associating the BrowserSettings with TabControl
     */
    /* package */void setTabControl(TabControl tabControl) {
        mTabControl = tabControl;
        updateTabControlSettings();
    }

    /*
     * Update all the observers of the object.
     */
    /*package*/ void update() {
        setChanged();
        notifyObservers();
    }

    /*package*/ void clearCache(Context context) {
        WebIconDatabase.getInstance().removeAllIcons();
        if (mTabControl != null) {
            WebView current = mTabControl.getCurrentWebView();
            if (current != null) {
                current.clearCache(true);
            }
        }
    }

    /*package*/ void clearCookies(Context context) {
        CookieManager.getInstance().removeAllCookie();
    }

    /* package */void clearHistory(Context context) {
        ContentResolver resolver = context.getContentResolver();
        Browser.clearHistory(resolver);
        Browser.clearSearches(resolver);
    }

    /* package */ void clearFormData(Context context) {
        WebViewDatabase.getInstance(context).clearFormData();
        if (mTabControl != null) {
            WebView currentTopView = mTabControl.getCurrentTopWebView();
            if (currentTopView != null) {
                currentTopView.clearFormData();
            }
        }
    }

    /*package*/ void clearPasswords(Context context) {
        WebViewDatabase db = WebViewDatabase.getInstance(context);
        db.clearUsernamePassword();
        db.clearHttpAuthUsernamePassword();
    }

    private void updateTabControlSettings() {
        // Enable/disable the error console.
        mTabControl.getBrowserActivity().setShouldShowErrorConsole(
            showDebugSettings && showConsole);
        mTabControl.getBrowserActivity().setRequestedOrientation(
            landscapeOnly ? ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
            : ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    }

    private void maybeDisableWebsiteSettings(Context context) {
        PreferenceActivity activity = (PreferenceActivity) context;
        final PreferenceScreen screen = (PreferenceScreen)
            activity.findPreference(BrowserSettings.PREF_WEBSITE_SETTINGS);
        screen.setEnabled(false);
        WebStorage.getInstance().getOrigins(new ValueCallback<Map>() {
            public void onReceiveValue(Map webStorageOrigins) {
                if ((webStorageOrigins != null) && !webStorageOrigins.isEmpty()) {
                    screen.setEnabled(true);
                }
            }
        });

        GeolocationPermissions.getInstance().getOrigins(new ValueCallback<Set<String> >() {
            public void onReceiveValue(Set<String> geolocationOrigins) {
                if ((geolocationOrigins != null) && !geolocationOrigins.isEmpty()) {
                    screen.setEnabled(true);
                }
            }
        });
    }

    /*package*/ void clearDatabases(Context context) {
        WebStorage.getInstance().deleteAllData();
        maybeDisableWebsiteSettings(context);
    }

    /*package*/ void clearLocationAccess(Context context) {
        GeolocationPermissions.getInstance().clearAll();
        maybeDisableWebsiteSettings(context);
    }

    /*package*/ void resetDefaultPreferences(Context ctx) {
        reset();
        SharedPreferences p =
            PreferenceManager.getDefaultSharedPreferences(ctx);
        p.edit().clear().apply();
        PreferenceManager.setDefaultValues(ctx, R.xml.browser_preferences,
                true);
        // reset homeUrl
        setHomePage(ctx, getFactoryResetHomeUrl(ctx));
        // reset appcache max size
        appCacheMaxSize = webStorageSizeManager.getAppCacheMaxSize();
    }

    private String getFactoryResetHomeUrl(Context context) {
        String url = context.getResources().getString(R.string.homepage_base);
        if (url.indexOf(""{CID}"") != -1) {
            url = url.replace(""{CID}"",
                    BrowserProvider.getClientId(context.getContentResolver()));
        }
        return url;
    }

    // Private constructor that does nothing.
    private BrowserSettings() {
        reset();
    }

    private void reset() {
        // Private variables for settings
        // NOTE: these defaults need to be kept in sync with the XML
        // until the performance of PreferenceManager.setDefaultValues()
        // is improved.
        loadsImagesAutomatically = true;
        javaScriptEnabled = true;
        pluginState = WebSettings.PluginState.ON;
        javaScriptCanOpenWindowsAutomatically = false;
        showSecurityWarnings = true;
        rememberPasswords = true;
        saveFormData = true;
        openInBackground = false;
        autoFitPage = true;
        landscapeOnly = false;
        loadsPageInOverviewMode = true;
        showDebugSettings = false;
        // HTML5 API flags
        appCacheEnabled = true;
        databaseEnabled = true;
        domStorageEnabled = true;
        geolocationEnabled = true;
        workersEnabled = true;  // only affects V8. JSC does not have a similar setting
    }
}
",True,35,1,2,3,20,11,7,L1
23,com.android.browser.FindDialog.java,"/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.Context;
import android.text.Editable;
import android.text.Selection;
import android.text.Spannable;
import android.text.TextWatcher;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.AnimationUtils;
import android.view.inputmethod.InputMethodManager;
import android.webkit.WebView;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.TextView;

/* package */ class FindDialog extends WebDialog implements TextWatcher {
    private TextView        mMatches;
    
    // Views with which the user can interact.
    private EditText        mEditText;
    private View            mNextButton;
    private View            mPrevButton;
    private View            mMatchesView;

    // When the dialog is opened up with old text, enter needs to be pressed
    // (or the text needs to be changed) before WebView.findAll can be called.
    // Once it has been called, enter should move to the next match.
    private boolean         mMatchesFound;
    private int             mNumberOfMatches;

    private View.OnClickListener mFindListener = new View.OnClickListener() {
        public void onClick(View v) {
            findNext();
        }
    };

    private View.OnClickListener mFindPreviousListener  =
            new View.OnClickListener() {
        public void onClick(View v) {
            if (mWebView == null) {
                throw new AssertionError(""No WebView for FindDialog::onClick"");
            }
            mWebView.findNext(false);
            updateMatchesString();
            hideSoftInput();
        }
    };

    private void disableButtons() {
        mPrevButton.setEnabled(false);
        mNextButton.setEnabled(false);
        mPrevButton.setFocusable(false);
        mNextButton.setFocusable(false);
    }

    /* package */ FindDialog(BrowserActivity context) {
        super(context);

        LayoutInflater factory = LayoutInflater.from(context);
        factory.inflate(R.layout.browser_find, this);

        addCancel();
        mEditText = (EditText) findViewById(R.id.edit);
        
        View button = findViewById(R.id.next);
        button.setOnClickListener(mFindListener);
        mNextButton = button;
        
        button = findViewById(R.id.previous);
        button.setOnClickListener(mFindPreviousListener);
        mPrevButton = button;
        
        mMatches = (TextView) findViewById(R.id.matches);
        mMatchesView = findViewById(R.id.matches_view);
        disableButtons();

    }

    /**
     * Called by BrowserActivity.closeDialog.  Start the animation to hide
     * the dialog, inform the WebView that the dialog is being dismissed,
     * and hide the soft keyboard.
     */
    public void dismiss() {
        super.dismiss();
        mWebView.notifyFindDialogDismissed();
        hideSoftInput();
    }

    @Override
    public boolean dispatchKeyEventPreIme(KeyEvent event) {
        if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
            KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null) {
                int action = event.getAction();
                if (KeyEvent.ACTION_DOWN == action
                        && event.getRepeatCount() == 0) {
                    state.startTracking(event, this);
                    return true;
                } else if (KeyEvent.ACTION_UP == action
                        && !event.isCanceled() && state.isTracking(event)) {
                    mBrowserActivity.closeDialogs();
                    return true;
                }
            }
        }
        return super.dispatchKeyEventPreIme(event);
    }

    @Override
    public boolean dispatchKeyEvent(KeyEvent event) {
        int keyCode = event.getKeyCode();
        if (event.getAction() == KeyEvent.ACTION_UP) {
            if (keyCode == KeyEvent.KEYCODE_ENTER
                    && mEditText.hasFocus()) {
                if (mMatchesFound) {
                    findNext();
                } else {
                    findAll();
                    // Set the selection to the end.
                    Spannable span = (Spannable) mEditText.getText();
                    Selection.setSelection(span, span.length());
                }
                return true;
            }
        }
        return super.dispatchKeyEvent(event);
    }

    private void findNext() {
        if (mWebView == null) {
            throw new AssertionError(""No WebView for FindDialog::findNext"");
        }
        mWebView.findNext(true);
        updateMatchesString();
        hideSoftInput();
    }

    public void show() {
        super.show();
        // In case the matches view is showing from a previous search
        mMatchesView.setVisibility(View.INVISIBLE);
        mMatchesFound = false;
        // This text is only here to ensure that mMatches has a height.
        mMatches.setText(""0"");
        mEditText.requestFocus();
        Spannable span = (Spannable) mEditText.getText();
        int length = span.length();
        Selection.setSelection(span, 0, length);
        span.setSpan(this, 0, length, Spannable.SPAN_INCLUSIVE_INCLUSIVE);
        disableButtons();
        InputMethodManager imm = (InputMethodManager)
                mBrowserActivity.getSystemService(Context.INPUT_METHOD_SERVICE);
        imm.showSoftInput(mEditText, 0);
    }
    
    // TextWatcher methods
    public void beforeTextChanged(CharSequence s, 
                                  int start, 
                                  int count, 
                                  int after) {
    }
    
    public void onTextChanged(CharSequence s,  
                              int start, 
                              int before, 
                              int count) {
        findAll();
    }

    private void findAll() {
        if (mWebView == null) {
            throw new AssertionError(
                    ""No WebView for FindDialog::findAll"");
        }
        CharSequence find = mEditText.getText();
        if (0 == find.length()) {
            disableButtons();
            mWebView.clearMatches();
            mMatchesView.setVisibility(View.INVISIBLE);
        } else {
            mMatchesView.setVisibility(View.VISIBLE);
            int found = mWebView.findAll(find.toString());
            mMatchesFound = true;
            setMatchesFound(found);
            if (found < 2) {
                disableButtons();
                if (found == 0) {
                    // Cannot use getQuantityString, which ignores the ""zero""
                    // quantity.
                    // FIXME: is this fix is beyond the scope
                    // of adding touch selection to gingerbread?
                    // mMatches.setText(mBrowserActivity.getResources().getString(
                    //        R.string.no_matches));
                }
            } else {
                mPrevButton.setFocusable(true);
                mNextButton.setFocusable(true);
                mPrevButton.setEnabled(true);
                mNextButton.setEnabled(true);
            }
        }
    }

    private void setMatchesFound(int found) {
        mNumberOfMatches = found;
        updateMatchesString();
    }

    public void setText(String text) {
        mEditText.setText(text);
        findAll();
    }

    private void updateMatchesString() {
        // Note: updateMatchesString is only called by methods that have already
        // checked mWebView for null.
        String template = mBrowserActivity.getResources().
                getQuantityString(R.plurals.matches_found, mNumberOfMatches,
                mWebView.findIndex() + 1, mNumberOfMatches);

        mMatches.setText(template);
    }

    public void afterTextChanged(Editable s) {
    }
}
",False,33,0,0,4,17,1,2,L1
24,com.android.browser.ErrorConsoleView.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.Context;
import android.database.DataSetObserver;
import android.graphics.Color;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.View.OnClickListener;
import android.webkit.ConsoleMessage;
import android.webkit.WebView;
import android.widget.Button;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.TwoLineListItem;

import java.util.Vector;

/* package */ class ErrorConsoleView extends LinearLayout {

    /**
     * Define some constants to describe the visibility of the error console.
     */
    public static final int SHOW_MINIMIZED = 0;
    public static final int SHOW_MAXIMIZED = 1;
    public static final int SHOW_NONE      = 2;

    private TextView mConsoleHeader;
    private ErrorConsoleListView mErrorList;
    private LinearLayout mEvalJsViewGroup;
    private EditText mEvalEditText;
    private Button mEvalButton;
    private WebView mWebView;
    private int mCurrentShowState = SHOW_NONE;

    private boolean mSetupComplete = false;

    // Before we've been asked to display the console, cache any messages that should
    // be added to the console. Then when we do display the console, add them to the view
    // then.
    private Vector<ConsoleMessage> mErrorMessageCache;

    public ErrorConsoleView(Context context) {
        super(context);
    }

    public ErrorConsoleView(Context context, AttributeSet attributes) {
        super(context, attributes);
    }

    private void commonSetupIfNeeded() {
        if (mSetupComplete) {
            return;
        }

        LayoutInflater inflater = (LayoutInflater) getContext().getSystemService(
                Context.LAYOUT_INFLATER_SERVICE);
        inflater.inflate(R.layout.error_console, this);

        // Get references to each ui element.
        mConsoleHeader = (TextView) findViewById(R.id.error_console_header_id);
        mErrorList = (ErrorConsoleListView) findViewById(R.id.error_console_list_id);
        mEvalJsViewGroup = (LinearLayout) findViewById(R.id.error_console_eval_view_group_id);
        mEvalEditText = (EditText) findViewById(R.id.error_console_eval_text_id);
        mEvalButton = (Button) findViewById(R.id.error_console_eval_button_id);

        mEvalButton.setOnClickListener(new OnClickListener() {
            public void onClick(View v) {
                // Send the javascript to be evaluated to webkit as a javascript: url
                // TODO: Can we expose access to webkit's JS interpreter here and evaluate it that
                // way? Note that this is called on the UI thread so we will need to post a message
                // to the WebCore thread to implement this.
                if (mWebView != null) {
                    mWebView.loadUrl(""javascript:"" + mEvalEditText.getText());
                }

                mEvalEditText.setText("""");
            }
        });

        // Make clicking on the console title bar min/maximse it.
        mConsoleHeader.setOnClickListener(new OnClickListener() {
            public void onClick(View v) {
                if (mCurrentShowState == SHOW_MINIMIZED) {
                    showConsole(SHOW_MAXIMIZED);
                } else {
                    showConsole(SHOW_MINIMIZED);
                }
            }
        });

        // Add any cached messages to the list now that we've assembled the view.
        if (mErrorMessageCache != null) {
            for (ConsoleMessage msg : mErrorMessageCache) {
                mErrorList.addErrorMessage(msg);
            }
            mErrorMessageCache.clear();
        }

        mSetupComplete = true;
    }

    /**
     * Adds a message to the set of messages the console uses.
     */
    public void addErrorMessage(ConsoleMessage consoleMessage) {
        if (mSetupComplete) {
            mErrorList.addErrorMessage(consoleMessage);
        } else {
            if (mErrorMessageCache == null) {
                mErrorMessageCache = new Vector<ConsoleMessage>();
            }
            mErrorMessageCache.add(consoleMessage);
        }
    }

    /**
     * Removes all error messages from the console.
     */
    public void clearErrorMessages() {
        if (mSetupComplete) {
            mErrorList.clearErrorMessages();
        } else if (mErrorMessageCache != null) {
            mErrorMessageCache.clear();
        }
    }

    /**
     * Returns the current number of errors displayed in the console.
     */
    public int numberOfErrors() {
        if (mSetupComplete) {
            return mErrorList.getCount();
        } else {
            return (mErrorMessageCache == null) ? 0 : mErrorMessageCache.size();
        }
    }

    /**
     * Sets the webview that this console is associated with. Currently this is used so
     * we can call into webkit to evaluate JS expressions in the console.
     */
    public void setWebView(WebView webview) {
        mWebView = webview;
    }

    /**
     * Sets the visibility state of the console.
     */
    public void showConsole(int show_state) {
        commonSetupIfNeeded();
        switch (show_state) {
            case SHOW_MINIMIZED:
                mConsoleHeader.setVisibility(View.VISIBLE);
                mConsoleHeader.setText(R.string.error_console_header_text_minimized);
                mErrorList.setVisibility(View.GONE);
                mEvalJsViewGroup.setVisibility(View.GONE);
                break;

            case SHOW_MAXIMIZED:
                mConsoleHeader.setVisibility(View.VISIBLE);
                mConsoleHeader.setText(R.string.error_console_header_text_maximized);
                mErrorList.setVisibility(View.VISIBLE);
                mEvalJsViewGroup.setVisibility(View.VISIBLE);
                break;

            case SHOW_NONE:
                mConsoleHeader.setVisibility(View.GONE);
                mErrorList.setVisibility(View.GONE);
                mEvalJsViewGroup.setVisibility(View.GONE);
                break;
        }
        mCurrentShowState = show_state;
    }

    /**
     * Returns the current visibility state of the console.
     */
    public int getShowState() {
        if (mSetupComplete) {
            return mCurrentShowState;
        } else {
            return SHOW_NONE;
        }
    }

    /**
     * This class extends ListView to implement the View that will actually display the set of
     * errors encountered on the current page.
     */
    private static class ErrorConsoleListView extends ListView {
        // An adapter for this View that contains a list of error messages.
        private ErrorConsoleMessageList mConsoleMessages;

        public ErrorConsoleListView(Context context, AttributeSet attributes) {
            super(context, attributes);
            mConsoleMessages = new ErrorConsoleMessageList(context);
            setAdapter(mConsoleMessages);
        }

        public void addErrorMessage(ConsoleMessage consoleMessage) {
            mConsoleMessages.add(consoleMessage);
            setSelection(mConsoleMessages.getCount());
        }

        public void clearErrorMessages() {
            mConsoleMessages.clear();
        }

        /**
         * This class is an adapter for ErrorConsoleListView that contains the error console
         * message data.
         */
        private static class ErrorConsoleMessageList extends android.widget.BaseAdapter
                implements android.widget.ListAdapter {

            private Vector<ConsoleMessage> mMessages;
            private LayoutInflater mInflater;

            public ErrorConsoleMessageList(Context context) {
                mMessages = new Vector<ConsoleMessage>();
                mInflater = (LayoutInflater)context.getSystemService(
                        Context.LAYOUT_INFLATER_SERVICE);
            }

            /**
             * Add a new message to the list and update the View.
             */
            public void add(ConsoleMessage consoleMessage) {
                mMessages.add(consoleMessage);
                notifyDataSetChanged();
            }

            /**
             * Remove all messages from the list and update the view.
             */
            public void clear() {
                mMessages.clear();
                notifyDataSetChanged();
            }

            @Override
            public boolean areAllItemsEnabled() {
                return false;
            }

            @Override
            public boolean isEnabled(int position) {
                return false;
            }

            public long getItemId(int position) {
                return position;
            }

            public Object getItem(int position) {
                return mMessages.get(position);
            }

            public int getCount() {
                return mMessages.size();
            }

            @Override
            public boolean hasStableIds() {
                return true;
            }

            /**
             * Constructs a TwoLineListItem for the error at position.
             */
            public View getView(int position, View convertView, ViewGroup parent) {
                View view;
                ConsoleMessage error = mMessages.get(position);

                if (error == null) {
                    return null;
                }

                if (convertView == null) {
                    view = mInflater.inflate(android.R.layout.two_line_list_item, parent, false);
                } else {
                    view = convertView;
                }

                TextView headline = (TextView) view.findViewById(android.R.id.text1);
                TextView subText = (TextView) view.findViewById(android.R.id.text2);
                headline.setText(error.sourceId() + "":"" + error.lineNumber());
                subText.setText(error.message());
                switch (error.messageLevel()) {
                    case ERROR:
                        subText.setTextColor(Color.RED);
                        break;
                    case WARNING:
                        // Orange
                        subText.setTextColor(Color.rgb(255,192,0));
                        break;
                    case TIP:
                        subText.setTextColor(Color.BLUE);
                        break;
                    default:
                        subText.setTextColor(Color.LTGRAY);
                        break;
                }
                return view;
            }

        }
    }
}
",False,30,5,14,0,0,2,0,L1
25,com.android.browser.AddNewBookmark.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.Context;
import android.view.LayoutInflater;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

/**
 *  Custom layout for an item representing a bookmark in the browser.
 */
 // FIXME: Remove BrowserBookmarkItem
class AddNewBookmark extends LinearLayout {

    private TextView    mTextView;
    private TextView    mUrlText;
    private ImageView   mImageView;

    /**
     *  Instantiate a bookmark item, including a default favicon.
     *
     *  @param context  The application context for the item.
     */
    AddNewBookmark(Context context) {
        super(context);

        setWillNotDraw(false);
        LayoutInflater factory = LayoutInflater.from(context);
        factory.inflate(R.layout.add_new_bookmark, this);
        mTextView = (TextView) findViewById(R.id.title);
        mUrlText = (TextView) findViewById(R.id.url);
        mImageView = (ImageView) findViewById(R.id.favicon);
    }

    /**
     *  Set the new url for the bookmark item.
     *  @param url  The new url for the bookmark item.
     */
    /* package */ void setUrl(String url) {
        mUrlText.setText(url);
    }
}
",False,30,6,12,0,0,2,0,L1
26,com.android.browser.TitleBar.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.Rect;
import android.graphics.drawable.Animatable;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.graphics.drawable.PaintDrawable;
import android.os.Handler;
import android.os.Message;
import android.speech.RecognizerIntent;
import android.text.SpannableString;
import android.text.Spanned;
import android.text.TextUtils;
import android.text.style.ImageSpan;
import android.util.DisplayMetrics;
import android.util.TypedValue;
import android.view.ContextMenu;
import android.view.LayoutInflater;
import android.view.MenuInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.android.common.speech.LoggingEvents;

/**
 * This class represents a title bar for a particular ""tab"" or ""window"" in the
 * browser.
 */
public class TitleBar extends LinearLayout {
    private TextView        mTitle;
    private Drawable        mCloseDrawable;
    private ImageView       mRtButton;
    private Drawable        mCircularProgress;
    private ProgressBar     mHorizontalProgress;
    private ImageView       mFavicon;
    private ImageView       mLockIcon;
    private ImageView       mStopButton;
    private Drawable        mBookmarkDrawable;
    private Drawable        mVoiceDrawable;
    private boolean         mInLoad;
    private BrowserActivity mBrowserActivity;
    private Drawable        mGenericFavicon;
    private int             mIconDimension;
    private View            mTitleBg;
    private MyHandler       mHandler;
    private Intent          mVoiceSearchIntent;
    private boolean         mInVoiceMode;
    private Drawable        mVoiceModeBackground;
    private Drawable        mNormalBackground;
    private Drawable        mLoadingBackground;
    private ImageSpan       mArcsSpan;
    private int             mLeftMargin;
    private int             mRightMargin;

    private static int LONG_PRESS = 1;

    public TitleBar(BrowserActivity context) {
        super(context, null);
        mHandler = new MyHandler();
        LayoutInflater factory = LayoutInflater.from(context);
        factory.inflate(R.layout.title_bar, this);
        mBrowserActivity = context;

        mTitle = (TextView) findViewById(R.id.title);
        mTitle.setCompoundDrawablePadding(5);

        mTitleBg = findViewById(R.id.title_bg);
        mLockIcon = (ImageView) findViewById(R.id.lock);
        mFavicon = (ImageView) findViewById(R.id.favicon);
        mStopButton = (ImageView) findViewById(R.id.stop);

        mRtButton = (ImageView) findViewById(R.id.rt_btn);
        Resources resources = context.getResources();
        mCircularProgress = (Drawable) resources.getDrawable(
                com.android.internal.R.drawable.search_spinner);
        DisplayMetrics metrics = resources.getDisplayMetrics();
        mLeftMargin = (int) TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP, 8f, metrics);
        mRightMargin = (int) TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP, 6f, metrics);
        mIconDimension = (int) TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP, 20f, metrics);
        mCircularProgress.setBounds(0, 0, mIconDimension, mIconDimension);
        mHorizontalProgress = (ProgressBar) findViewById(
                R.id.progress_horizontal);
        mGenericFavicon = context.getResources().getDrawable(
                R.drawable.app_web_browser_sm);
        mVoiceSearchIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
        mVoiceSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,
                RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);
        // This extra tells voice search not to send the application id in its
        // results intent - http://b/2546173
        //
        // TODO: Make a constant for this extra.
        mVoiceSearchIntent.putExtra(""android.speech.extras.SEND_APPLICATION_ID_EXTRA"", false);
        PackageManager pm = context.getPackageManager();
        ResolveInfo ri = pm.resolveActivity(mVoiceSearchIntent,
                PackageManager.MATCH_DEFAULT_ONLY);
        if (ri == null) {
            mVoiceSearchIntent = null;
        } else {
            mVoiceDrawable = resources.getDrawable(
                    android.R.drawable.ic_btn_speak_now);
        }
        mBookmarkDrawable = mRtButton.getDrawable();
        mVoiceModeBackground = resources.getDrawable(
                R.drawable.title_voice);
        mNormalBackground = mTitleBg.getBackground();
        mLoadingBackground = resources.getDrawable(R.drawable.title_loading);
        mArcsSpan = new ImageSpan(context, R.drawable.arcs,
                ImageSpan.ALIGN_BASELINE);
    }

    private class MyHandler extends Handler {
        public void handleMessage(Message msg) {
            if (msg.what == LONG_PRESS) {
                // Prevent the normal action from happening by setting the title
                // bar's state to false.
                mTitleBg.setPressed(false);
                // Need to call a special method on BrowserActivity for when the
                // fake title bar is up, because its ViewGroup does not show a
                // context menu.
                mBrowserActivity.showTitleBarContextMenu();
            }
        }
    };

    @Override
    public void createContextMenu(ContextMenu menu) {
        MenuInflater inflater = mBrowserActivity.getMenuInflater();
        inflater.inflate(R.menu.title_context, menu);
        mBrowserActivity.onCreateContextMenu(menu, this, null);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        ImageView button = mInLoad ? mStopButton : mRtButton;
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                // Make all touches hit either the textfield or the button,
                // depending on which side of the right edge of the textfield
                // they hit.
                if ((int) event.getX() > mTitleBg.getRight()) {
                    button.setPressed(true);
                } else {
                    mTitleBg.setPressed(true);
                    mHandler.sendMessageDelayed(mHandler.obtainMessage(
                            LONG_PRESS),
                            ViewConfiguration.getLongPressTimeout());
                }
                break;
            case MotionEvent.ACTION_MOVE:
                int slop = ViewConfiguration.get(mBrowserActivity)
                        .getScaledTouchSlop();
                if ((int) event.getY() > getHeight() + slop) {
                    // We only trigger the actions in ACTION_UP if one or the
                    // other is pressed.  Since the user moved off the title
                    // bar, mark both as not pressed.
                    mTitleBg.setPressed(false);
                    button.setPressed(false);
                    mHandler.removeMessages(LONG_PRESS);
                    break;
                }
                int x = (int) event.getX();
                int titleRight = mTitleBg.getRight();
                if (mTitleBg.isPressed() && x > titleRight + slop) {
                    mTitleBg.setPressed(false);
                    mHandler.removeMessages(LONG_PRESS);
                } else if (button.isPressed() && x < titleRight - slop) {
                    button.setPressed(false);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                button.setPressed(false);
                mTitleBg.setPressed(false);
                mHandler.removeMessages(LONG_PRESS);
                break;
            case MotionEvent.ACTION_UP:
                if (button.isPressed()) {
                    if (mInVoiceMode) {
                        if (mBrowserActivity.getTabControl().getCurrentTab()
                                .voiceSearchSourceIsGoogle()) {
                            Intent i = new Intent(
                                    LoggingEvents.ACTION_LOG_EVENT);
                            i.putExtra(LoggingEvents.EXTRA_EVENT,
                                    LoggingEvents.VoiceSearch.RETRY);
                            mBrowserActivity.sendBroadcast(i);
                        }
                        mBrowserActivity.startActivity(mVoiceSearchIntent);
                    } else if (mInLoad) {
                        mBrowserActivity.stopLoading();
                    } else {
                        mBrowserActivity.bookmarksOrHistoryPicker(false);
                    }
                    button.setPressed(false);
                } else if (mTitleBg.isPressed()) {
                    mHandler.removeMessages(LONG_PRESS);
                    if (mInVoiceMode) {
                        if (mBrowserActivity.getTabControl().getCurrentTab()
                                .voiceSearchSourceIsGoogle()) {
                            Intent i = new Intent(
                                    LoggingEvents.ACTION_LOG_EVENT);
                            i.putExtra(LoggingEvents.EXTRA_EVENT,
                                    LoggingEvents.VoiceSearch.N_BEST_REVEAL);
                            mBrowserActivity.sendBroadcast(i);
                        }
                        mBrowserActivity.showVoiceSearchResults(
                                mTitle.getText().toString().trim());
                    } else {
                        mBrowserActivity.editUrl();
                    }
                    mTitleBg.setPressed(false);
                }
                break;
            default:
                break;
        }
        return true;
    }

    /**
     * Set a new Bitmap for the Favicon.
     */
    /* package */ void setFavicon(Bitmap icon) {
        Drawable[] array = new Drawable[3];
        array[0] = new PaintDrawable(Color.BLACK);
        PaintDrawable p = new PaintDrawable(Color.WHITE);
        array[1] = p;
        if (icon == null) {
            array[2] = mGenericFavicon;
        } else {
            array[2] = new BitmapDrawable(icon);
        }
        LayerDrawable d = new LayerDrawable(array);
        d.setLayerInset(1, 1, 1, 1, 1);
        d.setLayerInset(2, 2, 2, 2, 2);
        mFavicon.setImageDrawable(d);
    }

    /**
     * Change the TitleBar to or from voice mode.  If there is no package to
     * handle voice search, the TitleBar cannot be set to voice mode.
     */
    /* package */ void setInVoiceMode(boolean inVoiceMode) {
        if (mInVoiceMode == inVoiceMode) return;
        mInVoiceMode = inVoiceMode && mVoiceSearchIntent != null;
        Drawable titleDrawable;
        if (mInVoiceMode) {
            mRtButton.setImageDrawable(mVoiceDrawable);
            titleDrawable = mVoiceModeBackground;
            mTitle.setEllipsize(null);
            mRtButton.setVisibility(View.VISIBLE);
            mStopButton.setVisibility(View.GONE);
            mTitleBg.setBackgroundDrawable(titleDrawable);
            mTitleBg.setPadding(mLeftMargin, mTitleBg.getPaddingTop(),
                    mRightMargin, mTitleBg.getPaddingBottom());
        } else {
            if (mInLoad) {
                titleDrawable = mLoadingBackground;
                mRtButton.setVisibility(View.GONE);
                mStopButton.setVisibility(View.VISIBLE);
            } else {
                titleDrawable = mNormalBackground;
                mRtButton.setVisibility(View.VISIBLE);
                mStopButton.setVisibility(View.GONE);
                mRtButton.setImageDrawable(mBookmarkDrawable);
            }
            mTitle.setEllipsize(TextUtils.TruncateAt.END);
            mTitleBg.setBackgroundDrawable(titleDrawable);
            mTitleBg.setPadding(mLeftMargin, 0, mRightMargin, 0);
        }
        mTitle.setSingleLine(!mInVoiceMode);
    }

    /**
     * Set the Drawable for the lock icon, or null to hide it.
     */
    /* package */ void setLock(Drawable d) {
        if (null == d) {
            mLockIcon.setVisibility(View.GONE);
        } else {
            mLockIcon.setImageDrawable(d);
            mLockIcon.setVisibility(View.VISIBLE);
        }
    }

    /**
     * Update the progress, from 0 to 100.
     */
    /* package */ void setProgress(int newProgress) {
        if (newProgress >= mHorizontalProgress.getMax()) {
            mTitle.setCompoundDrawables(null, null, null, null);
            ((Animatable) mCircularProgress).stop();
            mHorizontalProgress.setVisibility(View.INVISIBLE);
            if (!mInVoiceMode) {
                mRtButton.setImageDrawable(mBookmarkDrawable);
                mRtButton.setVisibility(View.VISIBLE);
                mStopButton.setVisibility(View.GONE);
                mTitleBg.setBackgroundDrawable(mNormalBackground);
                mTitleBg.setPadding(mLeftMargin, 0, mRightMargin, 0);
            }
            mInLoad = false;
        } else {
            mHorizontalProgress.setProgress(newProgress);
            if (!mInLoad && getWindowToken() != null) {
                // checking the window token lets us be sure that we
                // are attached to a window before starting the animation,
                // preventing a potential race condition
                // (fix for bug http://b/2115736)
                mTitle.setCompoundDrawables(null, null, mCircularProgress,
                        null);
                ((Animatable) mCircularProgress).start();
                mHorizontalProgress.setVisibility(View.VISIBLE);
                if (!mInVoiceMode) {
                    mTitleBg.setBackgroundDrawable(mLoadingBackground);
                    mTitleBg.setPadding(mLeftMargin, 0, mRightMargin, 0);
                    mRtButton.setVisibility(View.GONE);
                    mStopButton.setVisibility(View.VISIBLE);
                }
                mInLoad = true;
            }
        }
    }

    /**
     * Update the text displayed in the title bar.
     * @param title String to display.  If null, the loading string will be
     *      shown.
     */
    /* package */ void setDisplayTitle(String title) {
        if (title == null) {
            mTitle.setText(R.string.title_bar_loading);
        } else {
            if (mInVoiceMode) {
                // Add two spaces.  The second one will be replaced with an
                // image, and the first one will put space between it and the
                // text
                SpannableString spannable = new SpannableString(title + ""  "");
                int end = spannable.length();
                spannable.setSpan(mArcsSpan, end - 1, end,
                        Spanned.SPAN_MARK_POINT);
                mTitle.setText(spannable);
            } else {
                mTitle.setText(title);
            }
        }
    }

    /* package */ void setToTabPicker() {
        mTitle.setText(R.string.tab_picker_title);
        setFavicon(null);
        setLock(null);
        mHorizontalProgress.setVisibility(View.GONE);
    }
}
",True,33,0,0,4,20,1,3,L1
27,com.android.browser.SystemAllowGeolocationOrigins.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.Context;
import android.content.SharedPreferences;
import android.database.ContentObserver;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Handler;
import android.preference.PreferenceManager;
import android.provider.Settings;
import android.text.TextUtils;
import android.webkit.GeolocationPermissions;
import android.webkit.ValueCallback;

import java.util.HashSet;
import java.util.Set;

/**
 * Manages the interaction between the secure system setting for default geolocation
 * permissions and the browser.
 */
class SystemAllowGeolocationOrigins {

    // Preference key for the value of the system setting last read by the browser
    private final static String LAST_READ_ALLOW_GEOLOCATION_ORIGINS =
            ""last_read_allow_geolocation_origins"";

    // The application context
    private final Context mContext;

    // The observer used to listen to the system setting.
    private final SettingObserver mSettingObserver;

    public SystemAllowGeolocationOrigins(Context context) {
        mContext = context;
        mSettingObserver = new SettingObserver();
    }

    /**
     * Checks whether the setting has changed and installs an observer to listen for
     * future changes. Must be called on the application main thread.
     */
    public void start() {
        // Register to receive notifications when the system settings change.
        Uri uri = Settings.Secure.getUriFor(Settings.Secure.ALLOWED_GEOLOCATION_ORIGINS);
        mContext.getContentResolver().registerContentObserver(uri, false, mSettingObserver);

        // Read and apply the setting if needed.
        maybeApplySettingAsync();
    }

    /**
     * Stops the manager.
     */
    public void stop() {
        mContext.getContentResolver().unregisterContentObserver(mSettingObserver);
    }

    void maybeApplySettingAsync() {
        new AsyncTask<Void,Void,Void>() {
            @Override
            protected Void doInBackground(Void... params) {
                maybeApplySetting();
                return null;
            }
        }.execute();
    }

    /**
     * Checks to see if the system setting has changed and if so,
     * updates the Geolocation permissions accordingly.
     */
    private void maybeApplySetting() {
        // Get the new value
        String newSetting = getSystemSetting();

        // Get the last read value
        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(mContext);
        String lastReadSetting =
                preferences.getString(LAST_READ_ALLOW_GEOLOCATION_ORIGINS, """");

        // If the new value is the same as the last one we read, we're done.
        if (TextUtils.equals(lastReadSetting, newSetting)) {
            return;
        }

        // Save the new value as the last read value
        preferences.edit()
                .putString(LAST_READ_ALLOW_GEOLOCATION_ORIGINS, newSetting)
                .apply();

        Set<String> oldOrigins = parseAllowGeolocationOrigins(lastReadSetting);
        Set<String> newOrigins = parseAllowGeolocationOrigins(newSetting);
        Set<String> addedOrigins = setMinus(newOrigins, oldOrigins);
        Set<String> removedOrigins = setMinus(oldOrigins, newOrigins);

        // Remove the origins in the last read value
        removeOrigins(removedOrigins);

        // Add the origins in the new value
        addOrigins(addedOrigins);
    }

    /**
     * Parses the value of the default geolocation permissions setting.
     *
     * @param setting A space-separated list of origins.
     * @return A mutable set of origins.
     */
    private static HashSet<String> parseAllowGeolocationOrigins(String setting) {
        HashSet<String> origins = new HashSet<String>();
        if (!TextUtils.isEmpty(setting)) {
            for (String origin : setting.split(""\\s+"")) {
                if (!TextUtils.isEmpty(origin)) {
                    origins.add(origin);
                }
            }
        }
        return origins;
    }

    /**
     * Gets the difference between two sets. Does not modify any of the arguments.
     *
     * @return A set containing all elements in {@code x} that are not in {@code y}.
     */
    private <A> Set<A> setMinus(Set<A> x, Set<A> y) {
        HashSet<A> z = new HashSet<A>(x.size());
        for (A a : x) {
            if (!y.contains(a)) {
                z.add(a);
            }
        }
        return z;
    }

    /**
     * Gets the current system setting for default allowed geolocation origins.
     *
     * @return The default allowed origins. Returns {@code """"} if not set.
     */
    private String getSystemSetting() {
        String value = Settings.Secure.getString(mContext.getContentResolver(),
                Settings.Secure.ALLOWED_GEOLOCATION_ORIGINS);
        return value == null ? """" : value;
    }

    /**
     * Adds geolocation permissions for the given origins.
     */
    private void addOrigins(Set<String> origins) {
        for (String origin : origins) {
            GeolocationPermissions.getInstance().allow(origin);
        }
    }

    /**
     * Removes geolocation permissions for the given origins, if they are allowed.
     * If they are denied or not set, nothing is done.
     */
    private void removeOrigins(Set<String> origins) {
        for (final String origin : origins) {
            GeolocationPermissions.getInstance().getAllowed(origin, new ValueCallback<Boolean>() {
                public void onReceiveValue(Boolean value) {
                    if (value != null && value.booleanValue()) {
                        GeolocationPermissions.getInstance().clear(origin);
                    }
                }
            });
        }
    }

    /**
     * Listens for changes to the system setting.
     */
    private class SettingObserver extends ContentObserver {

        SettingObserver() {
            super(new Handler());
        }

        @Override
        public void onChange(boolean selfChange) {
            maybeApplySettingAsync();
        }
    }

}
",False,30,5,14,0,0,1,0,L1
28,com.android.browser.MeshTracker.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.graphics.Bitmap;
import android.graphics.utils.BoundaryPatch;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.webkit.WebView;

/*package*/ class MeshTracker extends WebView.DragTracker {

    private static class Mesh {
        private int mWhich;
        private int mRows;
        private int mCols;
        private BoundaryPatch mPatch = new BoundaryPatch();
        private float[] mCubics = new float[24];
        private float[] mOrig = new float[24];
        private float mStretchX, mStretchY;

        Mesh(int which, int rows, int cols) {
            mWhich = which;
            mRows = rows;
            mCols = cols;
        }

        private void rebuildPatch() {
            mPatch.setCubicBoundary(mCubics, 0, mRows, mCols);
        }

        private void setSize(float w, float h) {
            float[] pts = mCubics;
            float x1 = w*0.3333f;
            float y1 = h*0.3333f;
            float x2 = w*0.6667f;
            float y2 = h*0.6667f;
            pts[0*2+0] = 0;  pts[0*2+1] = 0;
            pts[1*2+0] = x1; pts[1*2+1] = 0;
            pts[2*2+0] = x2; pts[2*2+1] = 0;

            pts[3*2+0] = w; pts[3*2+1] = 0;
            pts[4*2+0] = w; pts[4*2+1] = y1;
            pts[5*2+0] = w; pts[5*2+1] = y2;

            pts[6*2+0] = w; pts[6*2+1] = h;
            pts[7*2+0] = x2; pts[7*2+1] = h;
            pts[8*2+0] = x1; pts[8*2+1] = h;

            pts[9*2+0] = 0;  pts[9*2+1] = h;
            pts[10*2+0] = 0; pts[10*2+1] = y2;
            pts[11*2+0] = 0; pts[11*2+1] = y1;

            System.arraycopy(pts, 0, mOrig, 0, 24);

            // recall our stretcher
            setStretch(mStretchX, mStretchY);
        }

        public void setBitmap(Bitmap bm) {
            mPatch.setTexture(bm);
            setSize(bm.getWidth(), bm.getHeight());
        }

        // first experimental behavior
        private void doit1(float dx, float dy) {
            final float scale = 0.75f;  // temper how far we actually move
            dx *= scale;
            dy *= scale;

            int index;
            if (dx < 0) {
                index = 10;
            } else {
                index = 4;
            }
            mCubics[index*2 + 0] = mOrig[index*2 + 0] + dx;
            mCubics[index*2 + 2] = mOrig[index*2 + 2] + dx;

            if (dy < 0) {
                index = 1;
            } else {
                index = 7;
            }
            mCubics[index*2 + 1] = mOrig[index*2 + 1] + dy;
            mCubics[index*2 + 3] = mOrig[index*2 + 3] + dy;
        }

        private void doit2(float dx, float dy) {
            final float scale = 0.35f;  // temper how far we actually move
            dx *= scale;
            dy *= scale;
            final float cornerScale = 0.25f;

            int index;
            if (dx < 0) {
                index = 4;
            } else {
                index = 10;
            }
            mCubics[index*2 + 0] = mOrig[index*2 + 0] + dx;
            mCubics[index*2 + 2] = mOrig[index*2 + 2] + dx;
            // corners
            index -= 1;
            mCubics[index*2 + 0] = mOrig[index*2 + 0] + dx * cornerScale;
            index = (index + 3) % 12; // next corner
            mCubics[index*2 + 0] = mOrig[index*2 + 0] + dx * cornerScale;

            if (dy < 0) {
                index = 7;
            } else {
                index = 1;
            }
            mCubics[index*2 + 1] = mOrig[index*2 + 1] + dy;
            mCubics[index*2 + 3] = mOrig[index*2 + 3] + dy;
            // corners
            index -= 1;
            mCubics[index*2 + 1] = mOrig[index*2 + 1] + dy * cornerScale;
            index = (index + 3) % 12; // next corner
            mCubics[index*2 + 1] = mOrig[index*2 + 1] + dy * cornerScale;
        }

        public void setStretch(float dx, float dy) {
            mStretchX = dx;
            mStretchY = dy;
            switch (mWhich) {
                case 1:
                    doit1(dx, dy);
                    break;
                case 2:
                    doit2(dx, dy);
                    break;
            }
            rebuildPatch();
        }

        public void draw(Canvas canvas) {
            mPatch.draw(canvas);
        }
    }

    private Mesh mMesh;
    private Bitmap mBitmap;
    private int mWhich;
    private Paint mBGPaint;

    public MeshTracker(int which) {
        mWhich = which;
    }

    public void setBGPaint(Paint paint) {
        mBGPaint = paint;
    }

    @Override public void onStartDrag(float x, float y) {
        mMesh = new Mesh(mWhich, 16, 16);
    }

    @Override public void onBitmapChange(Bitmap bm) {
        mBitmap = bm;
        mMesh.setBitmap(bm);
    }

    @Override public boolean onStretchChange(float sx, float sy) {
        mMesh.setStretch(-sx, -sy);
        return true;
    }

    @Override public void onStopDrag() {
        mMesh = null;
    }

    @Override public void onDraw(Canvas canvas) {
        if (mWhich == 2) {
            if (mBGPaint != null) {
                canvas.drawPaint(mBGPaint);
            } else {
                canvas.drawColor(0xFF000000);
            }
        }
        mMesh.draw(canvas);
    }
}

",False,30,5,13,0,0,2,0,L1
29,com.android.browser.BrowserBackupAgent.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import java.io.IOException;

import android.app.backup.BackupAgent;
import android.app.backup.BackupDataInput;
import android.app.backup.BackupDataOutput;
import android.database.Cursor;
import android.os.ParcelFileDescriptor;
import android.provider.Browser;
import android.provider.Browser.BookmarkColumns;
import android.util.Log;

import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.ArrayList;
import java.util.zip.CRC32;

/**
 * Settings backup agent for the Android browser.  Currently the only thing
 * stored is the set of bookmarks.  It's okay if I/O exceptions are thrown
 * out of the agent; the calling code handles it and the backup operation
 * simply fails.
 *
 * @hide
 */
public class BrowserBackupAgent extends BackupAgent {
    static final String TAG = ""BrowserBackupAgent"";
    static final boolean DEBUG = false;

    static final String BOOKMARK_KEY = ""_bookmarks_"";
    /** this version num MUST be incremented if the flattened-file schema ever changes */
    static final int BACKUP_AGENT_VERSION = 0;

    /**
     * In order to determine whether the bookmark set has changed since the
     * last time we did a backup, we store the following bits of info in the
     * state file after a backup:
     *
     * 1. the size of the flattened bookmark file
     * 2. the CRC32 of that file
     * 3. the agent version number [relevant following an OTA]
     *
     * After we flatten the bookmarks file here in onBackup, we compare its
     * metrics with the values from the saved state.  If they match, it means
     * the bookmarks didn't really change and we don't need to send the data.
     * (If they don't match, of course, then they've changed and we do indeed
     * send the new flattened file to be backed up.)
     */
    @Override
    public void onBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
            ParcelFileDescriptor newState) throws IOException {
        long savedFileSize = -1;
        long savedCrc = -1;
        int savedVersion = -1;

        // Extract the previous bookmark file size & CRC from the saved state
        DataInputStream in = new DataInputStream(
                new FileInputStream(oldState.getFileDescriptor()));
        try {
            savedFileSize = in.readLong();
            savedCrc = in.readLong();
            savedVersion = in.readInt();
        } catch (EOFException e) {
            // It means we had no previous state; that's fine
        } finally {
            if (in != null) {
                in.close();
            }
        }

        // Build a flattened representation of the bookmarks table
        File tmpfile = File.createTempFile(""bkp"", null, getCacheDir());
        try {
            FileOutputStream outfstream = new FileOutputStream(tmpfile);
            long newCrc = buildBookmarkFile(outfstream);
            outfstream.close();

            // Any changes since the last backup?
            if ((savedVersion != BACKUP_AGENT_VERSION)
                    || (newCrc != savedCrc)
                    || (tmpfile.length() != savedFileSize)) {
                // Different checksum or different size, so we need to back it up
                copyFileToBackup(BOOKMARK_KEY, tmpfile, data);
            }

            // Record our backup state and we're done
            writeBackupState(tmpfile.length(), newCrc, newState);
        } finally {
            // Make sure to tidy up when we're done
            tmpfile.delete();
        }
    }

    /**
     * Restore from backup -- reads in the flattened bookmark file as supplied from
     * the backup service, parses that out, and rebuilds the bookmarks table in the
     * browser database from it.
     */
    @Override
    public void onRestore(BackupDataInput data, int appVersionCode,
            ParcelFileDescriptor newState) throws IOException {
        long crc = -1;
        File tmpfile = File.createTempFile(""rst"", null, getFilesDir());
        try {
            while (data.readNextHeader()) {
                if (BOOKMARK_KEY.equals(data.getKey())) {
                    // Read the flattened bookmark data into a temp file
                    crc = copyBackupToFile(data, tmpfile, data.getDataSize());

                    FileInputStream infstream = new FileInputStream(tmpfile);
                    DataInputStream in = new DataInputStream(infstream);

                    try {
                        int count = in.readInt();
                        ArrayList<Bookmark> bookmarks = new ArrayList<Bookmark>(count);

                        // Read all the bookmarks, then process later -- if we can't read
                        // all the data successfully, we don't touch the bookmarks table
                        for (int i = 0; i < count; i++) {
                            Bookmark mark = new Bookmark();
                            mark.url = in.readUTF();
                            mark.visits = in.readInt();
                            mark.date = in.readLong();
                            mark.created = in.readLong();
                            mark.title = in.readUTF();
                            bookmarks.add(mark);
                        }

                        // Okay, we have all the bookmarks -- now see if we need to add
                        // them to the browser's database
                        int N = bookmarks.size();
                        int nUnique = 0;
                        if (DEBUG) Log.v(TAG, ""Restoring "" + N + "" bookmarks"");
                        String[] urlCol = new String[] { BookmarkColumns.URL };
                        for (int i = 0; i < N; i++) {
                            Bookmark mark = bookmarks.get(i);

                            // Does this URL exist in the bookmark table?
                            Cursor cursor = getContentResolver().query(Browser.BOOKMARKS_URI,
                                    urlCol,  BookmarkColumns.URL + "" == '"" + mark.url + ""' AND "" +
                                    BookmarkColumns.BOOKMARK + "" == 1 "", null, null);
                            // if not, insert it
                            if (cursor.getCount() <= 0) {
                                if (DEBUG) Log.v(TAG, ""Did not see url: "" + mark.url);
                                // Right now we do not reconstruct the db entry in its
                                // entirety; we just add a new bookmark with the same data
                                Bookmarks.addBookmark(null, getContentResolver(),
                                        mark.url, mark.title, null, false);
                                nUnique++;
                            } else {
                                if (DEBUG) Log.v(TAG, ""Skipping extant url: "" + mark.url);
                            }
                            cursor.close();
                        }
                        Log.i(TAG, ""Restored "" + nUnique + "" of "" + N + "" bookmarks"");
                    } catch (IOException ioe) {
                        Log.w(TAG, ""Bad backup data; not restoring"");
                        crc = -1;
                    } finally {
                        if (in != null) {
                            in.close();
                        }
                    }
                }

                // Last, write the state we just restored from so we can discern
                // changes whenever we get invoked for backup in the future
                writeBackupState(tmpfile.length(), crc, newState);
            }
        } finally {
            // Whatever happens, delete the temp file
            tmpfile.delete();
        }
    }

    static class Bookmark {
        public String url;
        public int visits;
        public long date;
        public long created;
        public String title;
    }
    /*
     * Utility functions
     */

    // Flatten the bookmarks table into the given file, calculating its CRC in the process
    private long buildBookmarkFile(FileOutputStream outfstream) throws IOException {
        CRC32 crc = new CRC32();
        ByteArrayOutputStream bufstream = new ByteArrayOutputStream(512);
        DataOutputStream bout = new DataOutputStream(bufstream);

        Cursor cursor = getContentResolver().query(Browser.BOOKMARKS_URI,
                new String[] { BookmarkColumns.URL, BookmarkColumns.VISITS,
                BookmarkColumns.DATE, BookmarkColumns.CREATED,
                BookmarkColumns.TITLE },
                BookmarkColumns.BOOKMARK + "" == 1 "", null, null);

        // The first thing in the file is the row count...
        int count = cursor.getCount();
        if (DEBUG) Log.v(TAG, ""Backing up "" + count + "" bookmarks"");
        bout.writeInt(count);
        byte[] record = bufstream.toByteArray();
        crc.update(record);
        outfstream.write(record);

        // ... followed by the data for each row
        for (int i = 0; i < count; i++) {
            cursor.moveToNext();

            String url = cursor.getString(0);
            int visits = cursor.getInt(1);
            long date = cursor.getLong(2);
            long created = cursor.getLong(3);
            String title = cursor.getString(4);

            // construct the flattened record in a byte array
            bufstream.reset();
            bout.writeUTF(url);
            bout.writeInt(visits);
            bout.writeLong(date);
            bout.writeLong(created);
            bout.writeUTF(title);

            // Update the CRC and write the record to the temp file
            record = bufstream.toByteArray();
            crc.update(record);
            outfstream.write(record);

            if (DEBUG) Log.v(TAG, ""   wrote url "" + url);
        }

        cursor.close();
        return crc.getValue();
    }

    // Write the file to backup as a single record under the given key
    private void copyFileToBackup(String key, File file, BackupDataOutput data)
            throws IOException {
        final int CHUNK = 8192;
        byte[] buf = new byte[CHUNK];

        int toCopy = (int) file.length();
        data.writeEntityHeader(key, toCopy);

        FileInputStream in = new FileInputStream(file);
        try {
            int nRead;
            while (toCopy > 0) {
                nRead = in.read(buf, 0, CHUNK);
                data.writeEntityData(buf, nRead);
                toCopy -= nRead;
            }
        } finally {
            if (in != null) {
                in.close();
            }
        }
    }

    // Read the given file from backup to a file, calculating a CRC32 along the way
    private long copyBackupToFile(BackupDataInput data, File file, int toRead)
            throws IOException {
        final int CHUNK = 8192;
        byte[] buf = new byte[CHUNK];
        CRC32 crc = new CRC32();
        FileOutputStream out = new FileOutputStream(file);

        try {
            while (toRead > 0) {
                int numRead = data.readEntityData(buf, 0, CHUNK);
                crc.update(buf, 0, numRead);
                out.write(buf, 0, numRead);
                toRead -= numRead;
            }
        } finally {
            if (out != null) {
                out.close();
            }
        }
        return crc.getValue();
    }

    // Write the given metrics to the new state file
    private void writeBackupState(long fileSize, long crc, ParcelFileDescriptor stateFile)
            throws IOException {
        DataOutputStream out = new DataOutputStream(
                new FileOutputStream(stateFile.getFileDescriptor()));
        try {
            out.writeLong(fileSize);
            out.writeLong(crc);
            out.writeInt(BACKUP_AGENT_VERSION);
        } finally {
            if (out != null) {
                out.close();
            }
        }
    }
}
",True,2,0,0,1,1,0,1,L2
30,com.android.browser.BrowserYesNoPreference.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import com.android.internal.preference.YesNoPreference;

import android.content.Context;
import android.util.AttributeSet;

class BrowserYesNoPreference extends YesNoPreference {

    // This is the constructor called by the inflater
    public BrowserYesNoPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected void onDialogClosed(boolean positiveResult) {
        super.onDialogClosed(positiveResult);

        if (positiveResult) {
            setEnabled(false);

            Context context = getContext();
            if (BrowserSettings.PREF_CLEAR_CACHE.equals(getKey())) {
                BrowserSettings.getInstance().clearCache(context);
                BrowserSettings.getInstance().clearDatabases(context);
            } else if (BrowserSettings.PREF_CLEAR_COOKIES.equals(getKey())) {
                BrowserSettings.getInstance().clearCookies(context);
            } else if (BrowserSettings.PREF_CLEAR_HISTORY.equals(getKey())) {
                BrowserSettings.getInstance().clearHistory(context);
            } else if (BrowserSettings.PREF_CLEAR_FORM_DATA.equals(getKey())) {
                BrowserSettings.getInstance().clearFormData(context);
            } else if (BrowserSettings.PREF_CLEAR_PASSWORDS.equals(getKey())) {
                BrowserSettings.getInstance().clearPasswords(context);
            } else if (BrowserSettings.PREF_EXTRAS_RESET_DEFAULTS.equals(
                    getKey())) {
                BrowserSettings.getInstance().resetDefaultPreferences(context);
                setEnabled(true);
            } else if (BrowserSettings.PREF_CLEAR_GEOLOCATION_ACCESS.equals(
                    getKey())) {
                BrowserSettings.getInstance().clearLocationAccess(context);
            }
        }
    }
}
",False,34,0,0,4,20,0,1,L2
31,com.android.browser.GeolocationPermissionsPrompt.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.util.AttributeSet;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.webkit.WebView;
import android.webkit.GeolocationPermissions;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

public class GeolocationPermissionsPrompt extends LinearLayout {
    private LinearLayout mInner;
    private TextView mMessage;
    private Button mShareButton;
    private Button mDontShareButton;
    private CheckBox mRemember;
    private GeolocationPermissions.Callback mCallback;
    private String mOrigin;

    public GeolocationPermissionsPrompt(Context context) {
        this(context, null);
    }

    public GeolocationPermissionsPrompt(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    void init() {
        mInner = (LinearLayout) findViewById(R.id.inner);
        mMessage = (TextView) findViewById(R.id.message);
        mShareButton = (Button) findViewById(R.id.share_button);
        mDontShareButton = (Button) findViewById(R.id.dont_share_button);
        mRemember = (CheckBox) findViewById(R.id.remember);

        final GeolocationPermissionsPrompt me = this;
        mShareButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                me.handleButtonClick(true);
            }
        });
        mDontShareButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                me.handleButtonClick(false);
            }
        });
    }

    /**
     * Shows the prompt for the given origin. When the user clicks on one of
     * the buttons, the supplied callback is be called.
     */
    public void show(String origin, GeolocationPermissions.Callback callback) {
        mOrigin = origin;
        mCallback = callback;
        Uri uri = Uri.parse(mOrigin);
        setMessage(""http"".equals(uri.getScheme()) ?  mOrigin.substring(7) : mOrigin);
        // The checkbox should always be intially checked.
        mRemember.setChecked(true);
        showDialog(true);
    }

    /**
     * Hides the prompt.
     */
    public void hide() {
        showDialog(false);
    }

    /**
     * Handles a click on one the buttons by invoking the callback.
     */
    private void handleButtonClick(boolean allow) {
        showDialog(false);

        boolean remember = mRemember.isChecked();
        if (remember) {
            Toast toast = Toast.makeText(
                    getContext(),
                    allow ? R.string.geolocation_permissions_prompt_toast_allowed :
                            R.string.geolocation_permissions_prompt_toast_disallowed,
                    Toast.LENGTH_LONG);
            toast.setGravity(Gravity.BOTTOM, 0, 0);
            toast.show();
        }

        mCallback.invoke(mOrigin, allow, remember);
    }

    /**
     * Sets the prompt's message.
     */
    private void setMessage(CharSequence origin) {
        mMessage.setText(String.format(
            getResources().getString(R.string.geolocation_permissions_prompt_message),
            origin));
    }

    /**
     * Shows or hides the prompt.
     */
    private void showDialog(boolean shown) {
        mInner.setVisibility(shown ? View.VISIBLE : View.GONE);
    }
}
",False,30,5,15,0,0,1,0,L1
32,com.android.browser.Browser.java,"/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.util.Log;

import android.app.Application;
import android.content.Intent;
import android.webkit.CookieManager;
import android.webkit.CookieSyncManager;

import dalvik.system.VMRuntime;

public class Browser extends Application { 

    private final static String LOGTAG = ""browser"";

    // Set to true to enable extra debugging.
    final static boolean DEBUG = false;
    
    // Set to true to enable verbose logging.
    final static boolean LOGV_ENABLED = DEBUG;

    // Set to true to enable extra debug logging.
    final static boolean LOGD_ENABLED = true;

    /**
     * Specifies a heap utilization ratio that works better
     * for the browser than the default ratio does.
     */
    private final static float TARGET_HEAP_UTILIZATION = 0.75f;

    public Browser() {
    }

    public void onCreate() {
        if (LOGV_ENABLED)
            Log.v(LOGTAG, ""Browser.onCreate: this="" + this);
        // Fix heap utilization for better heap size characteristics.
        VMRuntime.getRuntime().setTargetHeapUtilization(
                TARGET_HEAP_UTILIZATION);
        // create CookieSyncManager with current Context
        CookieSyncManager.createInstance(this);
        // remove all expired cookies
        CookieManager.getInstance().removeExpiredCookie();
        BrowserSettings.getInstance().loadFromDb(this);
    }

    static Intent createBrowserViewIntent() {
        Intent intent = new Intent(Intent.ACTION_WEB_SEARCH);
        return intent;
    }
}

",False,33,0,0,4,19,2,1,L1
33,com.android.browser.TabControl.java,"/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.BitmapShader;
import android.graphics.Paint;
import android.graphics.Shader;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.webkit.WebBackForwardList;
import android.webkit.WebView;

import java.io.File;
import java.util.ArrayList;
import java.util.Vector;

class TabControl {
    // Log Tag
    private static final String LOGTAG = ""TabControl"";
    // Maximum number of tabs.
    private static final int MAX_TABS = 8;
    // Private array of WebViews that are used as tabs.
    private ArrayList<Tab> mTabs = new ArrayList<Tab>(MAX_TABS);
    // Queue of most recently viewed tabs.
    private ArrayList<Tab> mTabQueue = new ArrayList<Tab>(MAX_TABS);
    // Current position in mTabs.
    private int mCurrentTab = -1;
    // A private instance of BrowserActivity to interface with when adding and
    // switching between tabs.
    private final BrowserActivity mActivity;
    // Directory to store thumbnails for each WebView.
    private final File mThumbnailDir;

    /**
     * Construct a new TabControl object that interfaces with the given
     * BrowserActivity instance.
     * @param activity A BrowserActivity instance that TabControl will interface
     *                 with.
     */
    TabControl(BrowserActivity activity) {
        mActivity = activity;
        mThumbnailDir = activity.getDir(""thumbnails"", 0);
    }

    File getThumbnailDir() {
        return mThumbnailDir;
    }

    BrowserActivity getBrowserActivity() {
        return mActivity;
    }

    /**
     * Return the current tab's main WebView. This will always return the main
     * WebView for a given tab and not a subwindow.
     * @return The current tab's WebView.
     */
    WebView getCurrentWebView() {
        Tab t = getTab(mCurrentTab);
        if (t == null) {
            return null;
        }
        return t.getWebView();
    }

    /**
     * Return the current tab's top-level WebView. This can return a subwindow
     * if one exists.
     * @return The top-level WebView of the current tab.
     */
    WebView getCurrentTopWebView() {
        Tab t = getTab(mCurrentTab);
        if (t == null) {
            return null;
        }
        return t.getTopWindow();
    }

    /**
     * Return the current tab's subwindow if it exists.
     * @return The subwindow of the current tab or null if it doesn't exist.
     */
    WebView getCurrentSubWindow() {
        Tab t = getTab(mCurrentTab);
        if (t == null) {
            return null;
        }
        return t.getSubWebView();
    }

    /**
     * Return the tab at the specified index.
     * @return The Tab for the specified index or null if the tab does not
     *         exist.
     */
    Tab getTab(int index) {
        if (index >= 0 && index < mTabs.size()) {
            return mTabs.get(index);
        }
        return null;
    }

    /**
     * Return the current tab.
     * @return The current tab.
     */
    Tab getCurrentTab() {
        return getTab(mCurrentTab);
    }

    /**
     * Return the current tab index.
     * @return The current tab index
     */
    int getCurrentIndex() {
        return mCurrentTab;
    }
    
    /**
     * Given a Tab, find it's index
     * @param Tab to find
     * @return index of Tab or -1 if not found
     */
    int getTabIndex(Tab tab) {
        if (tab == null) {
            return -1;
        }
        return mTabs.indexOf(tab);
    }

    boolean canCreateNewTab() {
        return MAX_TABS != mTabs.size();
    }

    /**
     * Create a new tab.
     * @return The newly createTab or null if we have reached the maximum
     *         number of open tabs.
     */
    Tab createNewTab(boolean closeOnExit, String appId, String url) {
        int size = mTabs.size();
        // Return false if we have maxed out on tabs
        if (MAX_TABS == size) {
            return null;
        }
        final WebView w = createNewWebView();

        // Create a new tab and add it to the tab list
        Tab t = new Tab(mActivity, w, closeOnExit, appId, url);
        mTabs.add(t);
        // Initially put the tab in the background.
        t.putInBackground();
        return t;
    }

    /**
     * Create a new tab with default values for closeOnExit(false),
     * appId(null), and url(null).
     */
    Tab createNewTab() {
        return createNewTab(false, null, null);
    }

    /**
     * Remove the parent child relationships from all tabs.
     */
    void removeParentChildRelationShips() {
        for (Tab tab : mTabs) {
            tab.removeFromTree();
        }
    }

    /**
     * Remove the tab from the list. If the tab is the current tab shown, the
     * last created tab will be shown.
     * @param t The tab to be removed.
     */
    boolean removeTab(Tab t) {
        if (t == null) {
            return false;
        }

        // Grab the current tab before modifying the list.
        Tab current = getCurrentTab();

        // Remove t from our list of tabs.
        mTabs.remove(t);

        // Put the tab in the background only if it is the current one.
        if (current == t) {
            t.putInBackground();
            mCurrentTab = -1;
        } else {
            // If a tab that is earlier in the list gets removed, the current
            // index no longer points to the correct tab.
            mCurrentTab = getTabIndex(current);
        }

        // destroy the tab
        t.destroy();
        // clear it's references to parent and children
        t.removeFromTree();

        // The tab indices have shifted, update all the saved state so we point
        // to the correct index.
        for (Tab tab : mTabs) {
            Vector<Tab> children = tab.getChildTabs();
            if (children != null) {
                for (Tab child : children) {
                    child.setParentTab(tab);
                }
            }
        }

        // Remove it from the queue of viewed tabs.
        mTabQueue.remove(t);
        return true;
    }

    /**
     * Destroy all the tabs and subwindows
     */
    void destroy() {
        for (Tab t : mTabs) {
            t.destroy();
        }
        mTabs.clear();
        mTabQueue.clear();
    }

    /**
     * Returns the number of tabs created.
     * @return The number of tabs created.
     */
    int getTabCount() {
        return mTabs.size();
    }


    /**
     * Save the state of all the Tabs.
     * @param outState The Bundle to save the state to.
     */
    void saveState(Bundle outState) {
        final int numTabs = getTabCount();
        outState.putInt(Tab.NUMTABS, numTabs);
        final int index = getCurrentIndex();
        outState.putInt(Tab.CURRTAB, (index >= 0 && index < numTabs) ? index : 0);
        for (int i = 0; i < numTabs; i++) {
            final Tab t = getTab(i);
            if (t.saveState()) {
                outState.putBundle(Tab.WEBVIEW + i, t.getSavedState());
            }
        }
    }

    /**
     * Restore the state of all the tabs.
     * @param inState The saved state of all the tabs.
     * @return True if there were previous tabs that were restored. False if
     *         there was no saved state or restoring the state failed.
     */
    boolean restoreState(Bundle inState) {
        final int numTabs = (inState == null)
                ? -1 : inState.getInt(Tab.NUMTABS, -1);
        if (numTabs == -1) {
            return false;
        } else {
            final int currentTab = inState.getInt(Tab.CURRTAB, -1);
            for (int i = 0; i < numTabs; i++) {
                if (i == currentTab) {
                    Tab t = createNewTab();
                    // Me must set the current tab before restoring the state
                    // so that all the client classes are set.
                    setCurrentTab(t);
                    if (!t.restoreState(inState.getBundle(Tab.WEBVIEW + i))) {
                        Log.w(LOGTAG, ""Fail in restoreState, load home page."");
                        t.getWebView().loadUrl(BrowserSettings.getInstance()
                                .getHomePage());
                    }
                } else {
                    // Create a new tab and don't restore the state yet, add it
                    // to the tab list
                    Tab t = new Tab(mActivity, null, false, null, null);
                    Bundle state = inState.getBundle(Tab.WEBVIEW + i);
                    if (state != null) {
                        t.setSavedState(state);
                        t.populatePickerDataFromSavedState();
                        // Need to maintain the app id and original url so we
                        // can possibly reuse this tab.
                        t.setAppId(state.getString(Tab.APPID));
                        t.setOriginalUrl(state.getString(Tab.ORIGINALURL));
                    }
                    mTabs.add(t);
                    // added the tab to the front as they are not current
                    mTabQueue.add(0, t);
                }
            }
            // Rebuild the tree of tabs. Do this after all tabs have been
            // created/restored so that the parent tab exists.
            for (int i = 0; i < numTabs; i++) {
                final Bundle b = inState.getBundle(Tab.WEBVIEW + i);
                final Tab t = getTab(i);
                if (b != null && t != null) {
                    final int parentIndex = b.getInt(Tab.PARENTTAB, -1);
                    if (parentIndex != -1) {
                        final Tab parent = getTab(parentIndex);
                        if (parent != null) {
                            parent.addChildTab(t);
                        }
                    }
                }
            }
        }
        return true;
    }

    /**
     * Free the memory in this order, 1) free the background tabs; 2) free the
     * WebView cache;
     */
    void freeMemory() {
        if (getTabCount() == 0) return;

        // free the least frequently used background tabs
        Vector<Tab> tabs = getHalfLeastUsedTabs(getCurrentTab());
        if (tabs.size() > 0) {
            Log.w(LOGTAG, ""Free "" + tabs.size() + "" tabs in the browser"");
            for (Tab t : tabs) {
                // store the WebView's state.
                t.saveState();
                // destroy the tab
                t.destroy();
            }
            return;
        }

        // free the WebView's unused memory (this includes the cache)
        Log.w(LOGTAG, ""Free WebView's unused memory and cache"");
        WebView view = getCurrentWebView();
        if (view != null) {
            view.freeMemory();
        }
    }

    private Vector<Tab> getHalfLeastUsedTabs(Tab current) {
        Vector<Tab> tabsToGo = new Vector<Tab>();

        // Don't do anything if we only have 1 tab or if the current tab is
        // null.
        if (getTabCount() == 1 || current == null) {
            return tabsToGo;
        }

        if (mTabQueue.size() == 0) {
            return tabsToGo;
        }

        // Rip through the queue starting at the beginning and tear down half of
        // available tabs which are not the current tab or the parent of the
        // current tab.
        int openTabCount = 0;
        for (Tab t : mTabQueue) {
            if (t != null && t.getWebView() != null) {
                openTabCount++;
                if (t != current && t != current.getParentTab()) {
                    tabsToGo.add(t);
                }
            }
        }

        openTabCount /= 2;
        if (tabsToGo.size() > openTabCount) {
            tabsToGo.setSize(openTabCount);
        }

        return tabsToGo;
    }

    /**
     * Show the tab that contains the given WebView.
     * @param view The WebView used to find the tab.
     */
    Tab getTabFromView(WebView view) {
        final int size = getTabCount();
        for (int i = 0; i < size; i++) {
            final Tab t = getTab(i);
            if (t.getSubWebView() == view || t.getWebView() == view) {
                return t;
            }
        }
        return null;
    }

    /**
     * Return the tab with the matching application id.
     * @param id The application identifier.
     */
    Tab getTabFromId(String id) {
        if (id == null) {
            return null;
        }
        final int size = getTabCount();
        for (int i = 0; i < size; i++) {
            final Tab t = getTab(i);
            if (id.equals(t.getAppId())) {
                return t;
            }
        }
        return null;
    }

    /**
     * Stop loading in all opened WebView including subWindows.
     */
    void stopAllLoading() {
        final int size = getTabCount();
        for (int i = 0; i < size; i++) {
            final Tab t = getTab(i);
            final WebView webview = t.getWebView();
            if (webview != null) {
                webview.stopLoading();
            }
            final WebView subview = t.getSubWebView();
            if (subview != null) {
                webview.stopLoading();
            }
        }
    }

    // This method checks if a non-app tab (one created within the browser)
    // matches the given url.
    private boolean tabMatchesUrl(Tab t, String url) {
        if (t.getAppId() != null) {
            return false;
        }
        WebView webview = t.getWebView();
        if (webview == null) {
            return false;
        } else if (url.equals(webview.getUrl())
                || url.equals(webview.getOriginalUrl())) {
            return true;
        }
        return false;
    }

    /**
     * Return the tab that has no app id associated with it and the url of the
     * tab matches the given url.
     * @param url The url to search for.
     */
    Tab findUnusedTabWithUrl(String url) {
        if (url == null) {
            return null;
        }
        // Check the current tab first.
        Tab t = getCurrentTab();
        if (t != null && tabMatchesUrl(t, url)) {
            return t;
        }
        // Now check all the rest.
        final int size = getTabCount();
        for (int i = 0; i < size; i++) {
            t = getTab(i);
            if (tabMatchesUrl(t, url)) {
                return t;
            }
        }
        return null;
    }

    /**
     * Recreate the main WebView of the given tab. Returns true if the WebView
     * requires a load, whether it was due to the fact that it was deleted, or
     * it is because it was a voice search.
     */
    boolean recreateWebView(Tab t, BrowserActivity.UrlData urlData) {
        final String url = urlData.mUrl;
        final WebView w = t.getWebView();
        if (w != null) {
            if (url != null && url.equals(t.getOriginalUrl())
                    // Treat a voice intent as though it is a different URL,
                    // since it most likely is.
                    && urlData.mVoiceIntent == null) {
                // The original url matches the current url. Just go back to the
                // first history item so we can load it faster than if we
                // rebuilt the WebView.
                final WebBackForwardList list = w.copyBackForwardList();
                if (list != null) {
                    w.goBackOrForward(-list.getCurrentIndex());
                    w.clearHistory(); // maintains the current page.
                    return false;
                }
            }
            t.destroy();
        }
        // Create a new WebView. If this tab is the current tab, we need to put
        // back all the clients so force it to be the current tab.
        t.setWebView(createNewWebView());
        if (getCurrentTab() == t) {
            setCurrentTab(t, true);
        }
        // Clear the saved state and picker data
        t.setSavedState(null);
        t.clearPickerData();
        // Save the new url in order to avoid deleting the WebView.
        t.setOriginalUrl(url);
        return true;
    }

    /**
     * Creates a new WebView and registers it with the global settings.
     */
    private WebView createNewWebView() {
        // Create a new WebView
        WebView w = new WebView(mActivity);
        w.setScrollbarFadingEnabled(true);
        w.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_OVERLAY);
        w.setMapTrackballToArrowKeys(false); // use trackball directly
        // Enable the built-in zoom
        w.getSettings().setBuiltInZoomControls(true);
        // Add this WebView to the settings observer list and update the
        // settings
        final BrowserSettings s = BrowserSettings.getInstance();
        s.addObserver(w.getSettings()).update(s, null);

        // pick a default
        if (false) {
            MeshTracker mt = new MeshTracker(2);
            Paint paint = new Paint();
            Bitmap bm = BitmapFactory.decodeResource(mActivity.getResources(),
                                         R.drawable.pattern_carbon_fiber_dark);
            paint.setShader(new BitmapShader(bm, Shader.TileMode.REPEAT,
                                             Shader.TileMode.REPEAT));
            mt.setBGPaint(paint);
            w.setDragTracker(mt);
        }
        return w;
    }

    /**
     * Put the current tab in the background and set newTab as the current tab.
     * @param newTab The new tab. If newTab is null, the current tab is not
     *               set.
     */
    boolean setCurrentTab(Tab newTab) {
        return setCurrentTab(newTab, false);
    }

    void pauseCurrentTab() {
        Tab t = getCurrentTab();
        if (t != null) {
            t.pause();
        }
    }

    void resumeCurrentTab() {
        Tab t = getCurrentTab();
        if (t != null) {
            t.resume();
        }
    }

    /**
     * If force is true, this method skips the check for newTab == current.
     */
    private boolean setCurrentTab(Tab newTab, boolean force) {
        Tab current = getTab(mCurrentTab);
        if (current == newTab && !force) {
            return true;
        }
        if (current != null) {
            current.putInBackground();
            mCurrentTab = -1;
        }
        if (newTab == null) {
            return false;
        }

        // Move the newTab to the end of the queue
        int index = mTabQueue.indexOf(newTab);
        if (index != -1) {
            mTabQueue.remove(index);
        }
        mTabQueue.add(newTab);

        // Display the new current tab
        mCurrentTab = mTabs.indexOf(newTab);
        WebView mainView = newTab.getWebView();
        boolean needRestore = (mainView == null);
        if (needRestore) {
            // Same work as in createNewTab() except don't do new Tab()
            mainView = createNewWebView();
            newTab.setWebView(mainView);
        }
        newTab.putInForeground();
        if (needRestore) {
            // Have to finish setCurrentTab work before calling restoreState
            if (!newTab.restoreState(newTab.getSavedState())) {
                mainView.loadUrl(BrowserSettings.getInstance().getHomePage());
            }
        }
        return true;
    }
}
",True,36,2,2,3,20,7,4,L1
34,com.android.browser.Bookmarks.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.net.Uri;
import android.provider.Browser;
import android.util.Log;
import android.webkit.WebIconDatabase;
import android.widget.Toast;

import java.io.ByteArrayOutputStream;
import java.util.Date;

/**
 *  This class is purely to have a common place for adding/deleting bookmarks.
 */
/* package */ class Bookmarks {
    // We only want the user to be able to bookmark content that
    // the browser can handle directly.
    private static final String acceptableBookmarkSchemes[] = {
            ""http:"",
            ""https:"",
            ""about:"",
            ""data:"",
            ""javascript:"",
            ""file:"",
            ""content:""
    };

    private final static String LOGTAG = ""Bookmarks"";
    /**
     *  Add a bookmark to the database.
     *  @param context Context of the calling Activity.  This is used to make
     *          Toast confirming that the bookmark has been added.  If the
     *          caller provides null, the Toast will not be shown.
     *  @param cr The ContentResolver being used to add the bookmark to the db.
     *  @param url URL of the website to be bookmarked.
     *  @param name Provided name for the bookmark.
     *  @param thumbnail A thumbnail for the bookmark.
     *  @param retainIcon Whether to retain the page's icon in the icon database.
     *          This will usually be <code>true</code> except when bookmarks are
     *          added by a settings restore agent.
     */
    /* package */ static void addBookmark(Context context,
            ContentResolver cr, String url, String name,
            Bitmap thumbnail, boolean retainIcon) {
        // Want to append to the beginning of the list
        long creationTime = new Date().getTime();
        ContentValues map = new ContentValues();
        Cursor cursor = null;
        try {
            cursor = Browser.getVisitedLike(cr, url);
            if (cursor.moveToFirst() && cursor.getInt(
                    Browser.HISTORY_PROJECTION_BOOKMARK_INDEX) == 0) {
                // This means we have been to this site but not bookmarked
                // it, so convert the history item to a bookmark
                map.put(Browser.BookmarkColumns.CREATED, creationTime);
                map.put(Browser.BookmarkColumns.TITLE, name);
                map.put(Browser.BookmarkColumns.BOOKMARK, 1);
                map.put(Browser.BookmarkColumns.THUMBNAIL,
                        bitmapToBytes(thumbnail));
                cr.update(Browser.BOOKMARKS_URI, map,
                        ""_id = "" + cursor.getInt(0), null);
            } else {
                int count = cursor.getCount();
                boolean matchedTitle = false;
                for (int i = 0; i < count; i++) {
                    // One or more bookmarks already exist for this site.
                    // Check the names of each
                    cursor.moveToPosition(i);
                    if (cursor.getString(Browser.HISTORY_PROJECTION_TITLE_INDEX)
                            .equals(name)) {
                        // The old bookmark has the same name.
                        // Update its creation time.
                        map.put(Browser.BookmarkColumns.CREATED,
                                creationTime);
                        cr.update(Browser.BOOKMARKS_URI, map,
                                ""_id = "" + cursor.getInt(0), null);
                        matchedTitle = true;
                        break;
                    }
                }
                if (!matchedTitle) {
                    // Adding a bookmark for a site the user has visited,
                    // or a new bookmark (with a different name) for a site
                    // the user has visited
                    map.put(Browser.BookmarkColumns.TITLE, name);
                    map.put(Browser.BookmarkColumns.URL, url);
                    map.put(Browser.BookmarkColumns.CREATED, creationTime);
                    map.put(Browser.BookmarkColumns.BOOKMARK, 1);
                    map.put(Browser.BookmarkColumns.DATE, 0);
                    map.put(Browser.BookmarkColumns.THUMBNAIL,
                            bitmapToBytes(thumbnail));
                    int visits = 0;
                    if (count > 0) {
                        // The user has already bookmarked, and possibly
                        // visited this site.  However, they are creating
                        // a new bookmark with the same url but a different
                        // name.  The new bookmark should have the same
                        // number of visits as the already created bookmark.
                        visits = cursor.getInt(
                                Browser.HISTORY_PROJECTION_VISITS_INDEX);
                    }
                    // Bookmark starts with 3 extra visits so that it will
                    // bubble up in the most visited and goto search box
                    map.put(Browser.BookmarkColumns.VISITS, visits + 3);
                    cr.insert(Browser.BOOKMARKS_URI, map);
                }
            }
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, ""addBookmark"", e);
        } finally {
            if (cursor != null) cursor.close();
        }
        if (retainIcon) {
            WebIconDatabase.getInstance().retainIconForPageUrl(url);
        }
        if (context != null) {
            Toast.makeText(context, R.string.added_to_bookmarks,
                    Toast.LENGTH_LONG).show();
        }
    }

    /**
     *  Remove a bookmark from the database.  If the url is a visited site, it
     *  will remain in the database, but only as a history item, and not as a
     *  bookmarked site.
     *  @param context Context of the calling Activity.  This is used to make
     *          Toast confirming that the bookmark has been removed.  If the
     *          caller provides null, the Toast will not be shown.
     *  @param cr The ContentResolver being used to remove the bookmark.
     *  @param url URL of the website to be removed.
     */
    /* package */ static void removeFromBookmarks(Context context,
            ContentResolver cr, String url, String title) {
        Cursor cursor = null;
        try {
            cursor = cr.query(
                    Browser.BOOKMARKS_URI,
                    Browser.HISTORY_PROJECTION,
                    ""url = ? AND title = ?"",
                    new String[] { url, title },
                    null);
            boolean first = cursor.moveToFirst();
            // Should be in the database no matter what
            if (!first) {
                throw new AssertionError(""URL is not in the database! "" + url
                        + "" "" + title);
            }
            // Remove from bookmarks
            WebIconDatabase.getInstance().releaseIconForPageUrl(url);
            Uri uri = ContentUris.withAppendedId(Browser.BOOKMARKS_URI,
                    cursor.getInt(Browser.HISTORY_PROJECTION_ID_INDEX));
            int numVisits = cursor.getInt(
                    Browser.HISTORY_PROJECTION_VISITS_INDEX);
            if (0 == numVisits) {
                cr.delete(uri, null, null);
            } else {
                // It is no longer a bookmark, but it is still a visited
                // site.
                ContentValues values = new ContentValues();
                values.put(Browser.BookmarkColumns.BOOKMARK, 0);
                try {
                    cr.update(uri, values, null, null);
                } catch (IllegalStateException e) {
                    Log.e(""removeFromBookmarks"", ""no database!"");
                }
            }
            if (context != null) {
                Toast.makeText(context, R.string.removed_from_bookmarks,
                        Toast.LENGTH_LONG).show();
            }
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, ""removeFromBookmarks"", e);
        } finally {
            if (cursor != null) cursor.close();
        }
    }

    private static byte[] bitmapToBytes(Bitmap bm) {
        if (bm == null) {
            return null;
        }

        final ByteArrayOutputStream os = new ByteArrayOutputStream();
        bm.compress(Bitmap.CompressFormat.PNG, 100, os);
        return os.toByteArray();
    }

    /* package */ static boolean urlHasAcceptableScheme(String url) {
        if (url == null) {
            return false;
        }

        for (int i = 0; i < acceptableBookmarkSchemes.length; i++) {
            if (url.startsWith(acceptableBookmarkSchemes[i])) {
                return true;
            }
        }
        return false;
    }
}
",False,31,5,13,0,0,7,0,L0
35,com.android.browser.AddBookmarkPage.java,"/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.app.Activity;
import android.content.ContentResolver;
import android.content.Intent;
import android.content.res.Resources;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.net.ParseException;
import android.net.WebAddress;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.provider.Browser;
import android.view.View;
import android.view.Window;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Date;

public class AddBookmarkPage extends Activity {

    private final String LOGTAG = ""Bookmarks"";

    private EditText    mTitle;
    private EditText    mAddress;
    private TextView    mButton;
    private View        mCancelButton;
    private boolean     mEditingExisting;
    private Bundle      mMap;
    private String      mTouchIconUrl;
    private Bitmap      mThumbnail;
    private String      mOriginalUrl;

    // Message IDs
    private static final int SAVE_BOOKMARK = 100;

    private Handler mHandler;

    private View.OnClickListener mSaveBookmark = new View.OnClickListener() {
        public void onClick(View v) {
            if (save()) {
                finish();
            }
        }
    };

    private View.OnClickListener mCancel = new View.OnClickListener() {
        public void onClick(View v) {
            finish();
        }
    };

    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        requestWindowFeature(Window.FEATURE_LEFT_ICON);
        setContentView(R.layout.browser_add_bookmark);
        setTitle(R.string.save_to_bookmarks);
        getWindow().setFeatureDrawableResource(Window.FEATURE_LEFT_ICON, R.drawable.ic_list_bookmark);
        
        String title = null;
        String url = null;
        mMap = getIntent().getExtras();
        if (mMap != null) {
            Bundle b = mMap.getBundle(""bookmark"");
            if (b != null) {
                mMap = b;
                mEditingExisting = true;
                setTitle(R.string.edit_bookmark);
            }
            title = mMap.getString(""title"");
            url = mOriginalUrl = mMap.getString(""url"");
            mTouchIconUrl = mMap.getString(""touch_icon_url"");
            mThumbnail = (Bitmap) mMap.getParcelable(""thumbnail"");
        }

        mTitle = (EditText) findViewById(R.id.title);
        mTitle.setText(title);
        mAddress = (EditText) findViewById(R.id.address);
        mAddress.setText(url);

        View.OnClickListener accept = mSaveBookmark;
        mButton = (TextView) findViewById(R.id.OK);
        mButton.setOnClickListener(accept);

        mCancelButton = findViewById(R.id.cancel);
        mCancelButton.setOnClickListener(mCancel);
        
        if (!getWindow().getDecorView().isInTouchMode()) {
            mButton.requestFocus();
        }
    }

    /**
     * Runnable to save a bookmark, so it can be performed in its own thread.
     */
    private class SaveBookmarkRunnable implements Runnable {
        private Message mMessage;
        public SaveBookmarkRunnable(Message msg) {
            mMessage = msg;
        }
        public void run() {
            // Unbundle bookmark data.
            Bundle bundle = mMessage.getData();
            String title = bundle.getString(""title"");
            String url = bundle.getString(""url"");
            boolean invalidateThumbnail = bundle.getBoolean(
                    ""invalidateThumbnail"");
            Bitmap thumbnail = invalidateThumbnail ? null
                    : (Bitmap) bundle.getParcelable(""thumbnail"");
            String touchIconUrl = bundle.getString(""touchIconUrl"");

            // Save to the bookmarks DB.
            try {
                final ContentResolver cr = getContentResolver();
                Bookmarks.addBookmark(null, cr, url, title, thumbnail, true);
                if (touchIconUrl != null) {
                    new DownloadTouchIcon(cr, url).execute(mTouchIconUrl);
                }
                mMessage.arg1 = 1;
            } catch (IllegalStateException e) {
                mMessage.arg1 = 0;
            }
            mMessage.sendToTarget();
        }
    }

    private void createHandler() {
        if (mHandler == null) {
            mHandler = new Handler() {
                @Override
                public void handleMessage(Message msg) {
                    switch (msg.what) {
                        case SAVE_BOOKMARK:
                            if (1 == msg.arg1) {
                                Toast.makeText(AddBookmarkPage.this, R.string.bookmark_saved,
                                        Toast.LENGTH_LONG).show();
                            } else {
                                Toast.makeText(AddBookmarkPage.this, R.string.bookmark_not_saved,
                                        Toast.LENGTH_LONG).show();
                            }
                            break;
                    }
                }
            };
        }
    }

    /**
     * Parse the data entered in the dialog and post a message to update the bookmarks database.
     */
    boolean save() {
        createHandler();

        String title = mTitle.getText().toString().trim();
        String unfilteredUrl = 
                BrowserActivity.fixUrl(mAddress.getText().toString());
        boolean emptyTitle = title.length() == 0;
        boolean emptyUrl = unfilteredUrl.trim().length() == 0;
        Resources r = getResources();
        if (emptyTitle || emptyUrl) {
            if (emptyTitle) {
                mTitle.setError(r.getText(R.string.bookmark_needs_title));
            }
            if (emptyUrl) {
                mAddress.setError(r.getText(R.string.bookmark_needs_url));
            }
            return false;
        }
        String url = unfilteredUrl.trim();
        try {
            // We allow bookmarks with a javascript: scheme, but these will in most cases
            // fail URI parsing, so don't try it if that's the kind of bookmark we have.

            if (!url.toLowerCase().startsWith(""javascript:"")) {
                URI uriObj = new URI(url);
                String scheme = uriObj.getScheme();
                if (!Bookmarks.urlHasAcceptableScheme(url)) {
                    // If the scheme was non-null, let the user know that we
                    // can't save their bookmark. If it was null, we'll assume
                    // they meant http when we parse it in the WebAddress class.
                    if (scheme != null) {
                        mAddress.setError(r.getText(R.string.bookmark_cannot_save_url));
                        return false;
                    }
                    WebAddress address;
                    try {
                        address = new WebAddress(unfilteredUrl);
                    } catch (ParseException e) {
                        throw new URISyntaxException("""", """");
                    }
                    if (address.mHost.length() == 0) {
                        throw new URISyntaxException("""", """");
                    }
                    url = address.toString();
                }
            }
        } catch (URISyntaxException e) {
            mAddress.setError(r.getText(R.string.bookmark_url_not_valid));
            return false;
        }

        if (mEditingExisting) {
            mMap.putString(""title"", title);
            mMap.putString(""url"", url);
            mMap.putBoolean(""invalidateThumbnail"", !url.equals(mOriginalUrl));
            setResult(RESULT_OK, (new Intent()).setAction(
                    getIntent().toString()).putExtras(mMap));
        } else {
            // Post a message to write to the DB.
            Bundle bundle = new Bundle();
            bundle.putString(""title"", title);
            bundle.putString(""url"", url);
            bundle.putParcelable(""thumbnail"", mThumbnail);
            bundle.putBoolean(""invalidateThumbnail"", !url.equals(mOriginalUrl));
            bundle.putString(""touchIconUrl"", mTouchIconUrl);
            Message msg = Message.obtain(mHandler, SAVE_BOOKMARK);
            msg.setData(bundle);
            // Start a new thread so as to not slow down the UI
            Thread t = new Thread(new SaveBookmarkRunnable(msg));
            t.start();
            setResult(RESULT_OK);
            LogTag.logBookmarkAdded(url, ""bookmarkview"");
        }
        return true;
    }
}
",True,34,0,0,4,18,0,4,L2
36,com.android.browser.DownloadTouchIcon.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser;

import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.http.AndroidHttpClient;
import android.os.AsyncTask;
import android.provider.Browser;
import android.webkit.WebView;


import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.params.HttpClientParams;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

class DownloadTouchIcon extends AsyncTask<String, Void, Void> {
    private final ContentResolver mContentResolver;
    private Cursor mCursor;
    private final String mOriginalUrl;
    private final String mUrl;
    private final String mUserAgent;
    /* package */ Tab mTab;

    public DownloadTouchIcon(Tab tab, ContentResolver cr, WebView view) {
        mTab = tab;
        mContentResolver = cr;
        // Store these in case they change.
        mOriginalUrl = view.getOriginalUrl();
        mUrl = view.getUrl();
        mUserAgent = view.getSettings().getUserAgentString();
    }

    public DownloadTouchIcon(ContentResolver cr, String url) {
        mTab = null;
        mContentResolver = cr;
        mOriginalUrl = null;
        mUrl = url;
        mUserAgent = null;
    }

    @Override
    public Void doInBackground(String... values) {
        mCursor = BrowserBookmarksAdapter.queryBookmarksForUrl(mContentResolver,
                mOriginalUrl, mUrl, true);
        if (mCursor != null && mCursor.getCount() > 0) {
            String url = values[0];

            AndroidHttpClient client = AndroidHttpClient.newInstance(
                    mUserAgent);
            HttpGet request = new HttpGet(url);

            // Follow redirects
            HttpClientParams.setRedirecting(client.getParams(), true);

            try {
                HttpResponse response = client.execute(request);

                if (response.getStatusLine().getStatusCode() == 200) {
                    HttpEntity entity = response.getEntity();
                    if (entity != null) {
                        InputStream content = entity.getContent();
                        if (content != null) {
                            Bitmap icon = BitmapFactory.decodeStream(
                                    content, null, null);
                            storeIcon(icon);
                        }
                    }
                }
            } catch (IllegalArgumentException ex) {
                request.abort();
            } catch (IOException ex) {
                request.abort();
            } finally {
                client.close();
            }
        }
        if (mCursor != null) {
            mCursor.close();
        }
        return null;
    }

    @Override
    protected void onCancelled() {
        if (mCursor != null) {
            mCursor.close();
        }
    }

    private void storeIcon(Bitmap icon) {
        // Do this first in case the download failed.
        if (mTab != null) {
            // Remove the touch icon loader from the BrowserActivity.
            mTab.mTouchIconLoader = null;
        }

        if (icon == null || mCursor == null || isCancelled()) {
            return;
        }

        final ByteArrayOutputStream os = new ByteArrayOutputStream();
        icon.compress(Bitmap.CompressFormat.PNG, 100, os);
        ContentValues values = new ContentValues();
        values.put(Browser.BookmarkColumns.TOUCH_ICON,
                os.toByteArray());

        if (mCursor.moveToFirst()) {
            do {
                mContentResolver.update(ContentUris.withAppendedId(
                        Browser.BOOKMARKS_URI, mCursor.getInt(0)),
                        values, null, null);
            } while (mCursor.moveToNext());
        }
    }
}
",False,34,1,1,4,14,2,2,L1
37,com.android.browser.search.SearchEngineInfo.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.browser.search;

import android.content.Context;
import android.content.res.Resources;
import android.text.TextUtils;
import android.util.Log;

import java.net.URLEncoder;
import java.util.Arrays;
import java.util.Locale;

/**
 * Loads and holds data for a given web search engine.
 */
public class SearchEngineInfo {

    private static String TAG = ""SearchEngineInfo"";

    // The fields of a search engine data array, defined in the same order as they appear in the
    // all_search_engines.xml file.
    // If you are adding/removing to this list, remember to update NUM_FIELDS below.
    private static final int FIELD_LABEL = 0;
    private static final int FIELD_KEYWORD = 1;
    private static final int FIELD_FAVICON_URI = 2;
    private static final int FIELD_SEARCH_URI = 3;
    private static final int FIELD_ENCODING = 4;
    private static final int FIELD_SUGGEST_URI = 5;
    private static final int NUM_FIELDS = 6;

    // The OpenSearch URI template parameters that we support.
    private static final String PARAMETER_LANGUAGE = ""{language}"";
    private static final String PARAMETER_SEARCH_TERMS = ""{searchTerms}"";
    private static final String PARAMETER_INPUT_ENCODING = ""{inputEncoding}"";

    private final String mName;

    // The array of strings defining this search engine. The array values are in the same order as
    // the above enumeration definition.
    private final String[] mSearchEngineData;

    /**
     * @throws IllegalArgumentException If the name does not refer to a valid search engine
     */
    public SearchEngineInfo(Context context, String name) throws IllegalArgumentException {
        mName = name;

        Resources res = context.getResources();
        int id_data = res.getIdentifier(name, ""array"", context.getPackageName());
        mSearchEngineData = res.getStringArray(id_data);

        if (mSearchEngineData == null) {
            throw new IllegalArgumentException(""No data found for "" + name);
        }
        if (mSearchEngineData.length != NUM_FIELDS) {
                throw new IllegalArgumentException(
                        name + "" has invalid number of fields - "" + mSearchEngineData.length);
        }
        if (TextUtils.isEmpty(mSearchEngineData[FIELD_SEARCH_URI])) {
            throw new IllegalArgumentException(name + "" has an empty search URI"");
        }

        // Add the current language/country information to the URIs.
        Locale locale = context.getResources().getConfiguration().locale;
        StringBuilder language = new StringBuilder(locale.getLanguage());
        if (!TextUtils.isEmpty(locale.getCountry())) {
            language.append('-');
            language.append(locale.getCountry());
        }

        String language_str = language.toString();
        mSearchEngineData[FIELD_SEARCH_URI] =
                mSearchEngineData[FIELD_SEARCH_URI].replace(PARAMETER_LANGUAGE, language_str);
        mSearchEngineData[FIELD_SUGGEST_URI] =
                mSearchEngineData[FIELD_SUGGEST_URI].replace(PARAMETER_LANGUAGE, language_str);

        // Default to UTF-8 if not specified.
        String enc = mSearchEngineData[FIELD_ENCODING];
        if (TextUtils.isEmpty(enc)) {
            enc = ""UTF-8"";
            mSearchEngineData[FIELD_ENCODING] = enc;
        }

        // Add the input encoding method to the URI.
        mSearchEngineData[FIELD_SEARCH_URI] =
                mSearchEngineData[FIELD_SEARCH_URI].replace(PARAMETER_INPUT_ENCODING, enc);
        mSearchEngineData[FIELD_SUGGEST_URI] =
                mSearchEngineData[FIELD_SUGGEST_URI].replace(PARAMETER_INPUT_ENCODING, enc);
    }

    public String getName() {
        return mName;
    }

    public String getLabel() {
        return mSearchEngineData[FIELD_LABEL];
    }

    /**
     * Returns the URI for launching a web search with the given query (or null if there was no
     * data available for this search engine).
     */
    public String getSearchUriForQuery(String query) {
        return getFormattedUri(searchUri(), query);
    }

    /**
     * Returns the URI for retrieving web search suggestions for the given query (or null if there
     * was no data available for this search engine).
     */
    public String getSuggestUriForQuery(String query) {
        return getFormattedUri(suggestUri(), query);
    }

    public boolean supportsSuggestions() {
        return !TextUtils.isEmpty(suggestUri());
    }

    public String faviconUri() {
        return mSearchEngineData[FIELD_FAVICON_URI];
    }

    private String suggestUri() {
        return mSearchEngineData[FIELD_SUGGEST_URI];
    }

    private String searchUri() {
        return mSearchEngineData[FIELD_SEARCH_URI];
    }

    /**
     * Formats a launchable uri out of the template uri by replacing the template parameters with
     * actual values.
     */
    private String getFormattedUri(String templateUri, String query) {
        if (TextUtils.isEmpty(templateUri)) {
            return null;
        }

        // Encode the query terms in the requested encoding (and fallback to UTF-8 if not).
        String enc = mSearchEngineData[FIELD_ENCODING];
        try {
            return templateUri.replace(PARAMETER_SEARCH_TERMS, URLEncoder.encode(query, enc));
        } catch (java.io.UnsupportedEncodingException e) {
            Log.e(TAG, ""Exception occured when encoding query "" + query + "" to "" + enc);
            return null;
        }
    }

    @Override
    public String toString() {
        return ""SearchEngineInfo{"" + Arrays.toString(mSearchEngineData) + ""}"";
    }

}
",False,33,5,14,0,0,3,0,L0
38,com.android.browser.search.SearchEnginePreference.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.browser.search;

import com.android.browser.R;

import android.app.SearchManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.preference.ListPreference;
import android.util.AttributeSet;
import android.util.Log;

import java.util.ArrayList;

class SearchEnginePreference extends ListPreference {

    private static final String TAG = ""SearchEnginePreference"";

    public SearchEnginePreference(Context context, AttributeSet attrs) {
        super(context, attrs);

        ArrayList<CharSequence> entryValues = new ArrayList<CharSequence>();
        ArrayList<CharSequence> entries = new ArrayList<CharSequence>();

        SearchEngine defaultSearchEngine = SearchEngines.getDefaultSearchEngine(context);
        String defaultSearchEngineName = null;
        if (defaultSearchEngine != null) {
            defaultSearchEngineName = defaultSearchEngine.getName();
            entryValues.add(defaultSearchEngineName);
            entries.add(defaultSearchEngine.getLabel());
        }
        for (SearchEngineInfo searchEngineInfo : SearchEngines.getSearchEngineInfos(context)) {
            String name = searchEngineInfo.getName();
            // Skip entry with same name as default provider
            if (!name.equals(defaultSearchEngineName)) {
                entryValues.add(name);
                entries.add(searchEngineInfo.getLabel());
            }
        }

        setEntryValues(entryValues.toArray(new CharSequence[entryValues.size()]));
        setEntries(entries.toArray(new CharSequence[entries.size()]));
    }

}
",False,6,0,0,2,3,0,3,L2
39,com.android.browser.search.OpenSearchSearchEngine.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.browser.search;

import com.android.browser.R;

import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.params.HttpParams;
import org.apache.http.util.EntityUtils;
import org.json.JSONArray;
import org.json.JSONException;

import android.app.SearchManager;
import android.content.Context;
import android.content.Intent;
import android.database.AbstractCursor;
import android.database.Cursor;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.net.http.AndroidHttpClient;
import android.os.Bundle;
import android.provider.Browser;
import android.text.TextUtils;
import android.util.Log;

import java.io.IOException;

/**
 * Provides search suggestions, if any, for a given web search provider.
 */
public class OpenSearchSearchEngine implements SearchEngine {

    private static final String TAG = ""OpenSearchSearchEngine"";

    private static final String USER_AGENT = ""Android/1.0"";
    private static final int HTTP_TIMEOUT_MS = 1000;

    // TODO: this should be defined somewhere
    private static final String HTTP_TIMEOUT = ""http.connection-manager.timeout"";

    // Indices of the columns in the below arrays.
    private static final int COLUMN_INDEX_ID = 0;
    private static final int COLUMN_INDEX_QUERY = 1;
    private static final int COLUMN_INDEX_ICON = 2;
    private static final int COLUMN_INDEX_TEXT_1 = 3;
    private static final int COLUMN_INDEX_TEXT_2 = 4;

    // The suggestion columns used. If you are adding a new entry to these arrays make sure to
    // update the list of indices declared above.
    private static final String[] COLUMNS = new String[] {
        ""_id"",
        SearchManager.SUGGEST_COLUMN_QUERY,
        SearchManager.SUGGEST_COLUMN_ICON_1,
        SearchManager.SUGGEST_COLUMN_TEXT_1,
        SearchManager.SUGGEST_COLUMN_TEXT_2,
    };

    private static final String[] COLUMNS_WITHOUT_DESCRIPTION = new String[] {
        ""_id"",
        SearchManager.SUGGEST_COLUMN_QUERY,
        SearchManager.SUGGEST_COLUMN_ICON_1,
        SearchManager.SUGGEST_COLUMN_TEXT_1,
    };

    private final SearchEngineInfo mSearchEngineInfo;

    private final AndroidHttpClient mHttpClient;

    public OpenSearchSearchEngine(Context context, SearchEngineInfo searchEngineInfo) {
        mSearchEngineInfo = searchEngineInfo;
        mHttpClient = AndroidHttpClient.newInstance(USER_AGENT);
        HttpParams params = mHttpClient.getParams();
        params.setLongParameter(HTTP_TIMEOUT, HTTP_TIMEOUT_MS);
    }

    public String getName() {
        return mSearchEngineInfo.getName();
    }

    public CharSequence getLabel() {
        return mSearchEngineInfo.getLabel();
    }

    public void startSearch(Context context, String query, Bundle appData, String extraData) {
        String uri = mSearchEngineInfo.getSearchUriForQuery(query);
        if (uri == null) {
            Log.e(TAG, ""Unable to get search URI for "" + mSearchEngineInfo);
        } else {
            Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(uri));
            // Make sure the intent goes to the Browser itself
            intent.setPackage(context.getPackageName());
            intent.addCategory(Intent.CATEGORY_DEFAULT);
            intent.putExtra(SearchManager.QUERY, query);
            if (appData != null) {
                intent.putExtra(SearchManager.APP_DATA, appData);
            }
            if (extraData != null) {
                intent.putExtra(SearchManager.EXTRA_DATA_KEY, extraData);
            }
            intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName());
            context.startActivity(intent);
        }
    }

    /**
     * Queries for a given search term and returns a cursor containing
     * suggestions ordered by best match.
     */
    public Cursor getSuggestions(Context context, String query) {
        if (TextUtils.isEmpty(query)) {
            return null;
        }
        if (!isNetworkConnected(context)) {
            Log.i(TAG, ""Not connected to network."");
            return null;
        }

        String suggestUri = mSearchEngineInfo.getSuggestUriForQuery(query);
        if (TextUtils.isEmpty(suggestUri)) {
            // No suggest URI available for this engine
            return null;
        }

        try {
            String content = readUrl(suggestUri);
            if (content == null) return null;
            /* The data format is a JSON array with items being regular strings or JSON arrays
             * themselves. We are interested in the second and third elements, both of which
             * should be JSON arrays. The second element/array contains the suggestions and the
             * third element contains the descriptions. Some search engines don't support
             * suggestion descriptions so the third element is optional.
             */
            JSONArray results = new JSONArray(content);
            JSONArray suggestions = results.getJSONArray(1);
            JSONArray descriptions = null;
            if (results.length() > 2) {
                descriptions = results.getJSONArray(2);
                // Some search engines given an empty array ""[]"" for descriptions instead of
                // not including it in the response.
                if (descriptions.length() == 0) {
                    descriptions = null;
                }
            }
            return new SuggestionsCursor(suggestions, descriptions);
        } catch (JSONException e) {
            Log.w(TAG, ""Error"", e);
        }
        return null;
    }

    /**
     * Executes a GET request and returns the response content.
     *
     * @param url Request URI.
     * @return The response content. This is the empty string if the response
     *         contained no content.
     */
    public String readUrl(String url) {
        try {
            HttpGet method = new HttpGet(url);
            HttpResponse response = mHttpClient.execute(method);
            if (response.getStatusLine().getStatusCode() == 200) {
                return EntityUtils.toString(response.getEntity());
            } else {
                Log.i(TAG, ""Suggestion request failed"");
                return null;
            }
        } catch (IOException e) {
            Log.w(TAG, ""Error"", e);
            return null;
        }
    }

    public boolean supportsSuggestions() {
        return mSearchEngineInfo.supportsSuggestions();
    }

    public void close() {
        mHttpClient.close();
    }

    public boolean supportsVoiceSearch() {
        return getName().equals(SearchEngine.GOOGLE);
    }

    private boolean isNetworkConnected(Context context) {
        NetworkInfo networkInfo = getActiveNetworkInfo(context);
        return networkInfo != null && networkInfo.isConnected();
    }

    private NetworkInfo getActiveNetworkInfo(Context context) {
        ConnectivityManager connectivity =
                (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        if (connectivity == null) {
            return null;
        }
        return connectivity.getActiveNetworkInfo();
    }

    private static class SuggestionsCursor extends AbstractCursor {

        private final JSONArray mSuggestions;

        private final JSONArray mDescriptions;

        public SuggestionsCursor(JSONArray suggestions, JSONArray descriptions) {
            mSuggestions = suggestions;
            mDescriptions = descriptions;
        }

        @Override
        public int getCount() {
            return mSuggestions.length();
        }

        @Override
        public String[] getColumnNames() {
            return (mDescriptions != null ? COLUMNS : COLUMNS_WITHOUT_DESCRIPTION);
        }

        @Override
        public String getString(int column) {
            if (mPos != -1) {
                if ((column == COLUMN_INDEX_QUERY) || (column == COLUMN_INDEX_TEXT_1)) {
                    try {
                        return mSuggestions.getString(mPos);
                    } catch (JSONException e) {
                        Log.w(TAG, ""Error"", e);
                    }
                } else if (column == COLUMN_INDEX_TEXT_2) {
                    try {
                        return mDescriptions.getString(mPos);
                    } catch (JSONException e) {
                        Log.w(TAG, ""Error"", e);
                    }
                } else if (column == COLUMN_INDEX_ICON) {
                    return String.valueOf(R.drawable.magnifying_glass);
                }
            }
            return null;
        }

        @Override
        public double getDouble(int column) {
            throw new UnsupportedOperationException();
        }

        @Override
        public float getFloat(int column) {
            throw new UnsupportedOperationException();
        }

        @Override
        public int getInt(int column) {
            throw new UnsupportedOperationException();
        }

        @Override
        public long getLong(int column) {
            if (column == COLUMN_INDEX_ID) {
                return mPos;        // use row# as the _Id
            }
            throw new UnsupportedOperationException();
        }

        @Override
        public short getShort(int column) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean isNull(int column) {
            throw new UnsupportedOperationException();
        }
    }

    @Override
    public String toString() {
        return ""OpenSearchSearchEngine{"" + mSearchEngineInfo + ""}"";
    }

}
",False,34,5,14,1,2,1,2,L0
40,com.android.browser.search.SearchEngines.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.browser.search;

import com.android.browser.R;

import android.app.SearchManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.text.TextUtils;
import android.util.Log;

import java.util.ArrayList;
import java.util.List;

public class SearchEngines {

    private static final String TAG = ""SearchEngines"";

    public static SearchEngine getDefaultSearchEngine(Context context) {
        return DefaultSearchEngine.create(context);
    }

    public static List<SearchEngineInfo> getSearchEngineInfos(Context context) {
        ArrayList<SearchEngineInfo> searchEngineInfos = new ArrayList<SearchEngineInfo>();
        Resources res = context.getResources();
        String[] searchEngines = res.getStringArray(R.array.search_engines);
        for (int i = 0; i < searchEngines.length; i++) {
            String name = searchEngines[i];
            SearchEngineInfo info = new SearchEngineInfo(context, name);
            searchEngineInfos.add(info);
        }
        return searchEngineInfos;
    }

    public static SearchEngine get(Context context, String name) {
        // TODO: cache
        SearchEngine defaultSearchEngine = getDefaultSearchEngine(context);
        if (TextUtils.isEmpty(name)
                || (defaultSearchEngine != null && name.equals(defaultSearchEngine.getName()))) {
            return defaultSearchEngine;
        }
        SearchEngineInfo searchEngineInfo = getSearchEngineInfo(context, name);
        if (searchEngineInfo == null) return defaultSearchEngine;
        return new OpenSearchSearchEngine(context, searchEngineInfo);
    }

    private static SearchEngineInfo getSearchEngineInfo(Context context, String name) {
        try {
            return new SearchEngineInfo(context, name);
        } catch (IllegalArgumentException exception) {
            Log.e(TAG, ""Cannot load search engine "" + name, exception);
            return null;
        }
    }

}
",False,35,4,14,1,4,2,4,L0
41,com.android.browser.search.SearchEngine.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.browser.search;

import android.content.Context;
import android.database.Cursor;
import android.os.Bundle;

/**
 * Interface for search engines.
 */
public interface SearchEngine {

    // Used if the search engine is Google
    static final String GOOGLE = ""google"";

    /**
     * Gets the unique name of this search engine.
     */
    public String getName();

    /**
     * Gets the human-readable name of this search engine.
     */
    public CharSequence getLabel();

    /**
     * Starts a search.
     */
    public void startSearch(Context context, String query, Bundle appData, String extraData);

    /**
     * Gets search suggestions.
     */
    public Cursor getSuggestions(Context context, String query);

    /**
     * Checks whether this search engine supports search suggestions.
     */
    public boolean supportsSuggestions();

    /**
     * Closes this search engine.
     */
    public void close();

    /**
     * Checks whether this search engine supports voice search.
     */
    public boolean supportsVoiceSearch();
}
",False,34,4,19,0,0,7,0,L0
42,com.android.browser.search.DefaultSearchEngine.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.browser.search;

import android.app.SearchManager;
import android.app.SearchableInfo;
import android.content.ActivityNotFoundException;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.os.Bundle;
import android.provider.Browser;
import android.text.TextUtils;
import android.util.Log;

public class DefaultSearchEngine implements SearchEngine {

    private static final String TAG = ""DefaultSearchEngine"";

    private final SearchableInfo mSearchable;

    private final CharSequence mLabel;

    private DefaultSearchEngine(Context context, SearchableInfo searchable) {
        mSearchable = searchable;
        mLabel = loadLabel(context, mSearchable.getSearchActivity());
    }

    public static DefaultSearchEngine create(Context context) {
        SearchManager searchManager =
                (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
        ComponentName name = searchManager.getWebSearchActivity();
        if (name == null) return null;
        SearchableInfo searchable = searchManager.getSearchableInfo(name);
        if (searchable == null) return null;
        return new DefaultSearchEngine(context, searchable);
    }

    private CharSequence loadLabel(Context context, ComponentName activityName) {
        PackageManager pm = context.getPackageManager();
        try {
            ActivityInfo ai = pm.getActivityInfo(activityName, 0);
            return ai.loadLabel(pm);
        } catch (PackageManager.NameNotFoundException ex) {
            Log.e(TAG, ""Web search activity not found: "" + activityName);
            return null;
        }
    }

    public String getName() {
        String packageName = mSearchable.getSearchActivity().getPackageName();
        // Use ""google"" as name to avoid showing Google twice (app + OpenSearch)
        if (""com.google.android.googlequicksearchbox"".equals(packageName)) {
            return SearchEngine.GOOGLE;
        } else if (""com.android.quicksearchbox"".equals(packageName)) {
            return SearchEngine.GOOGLE;
        } else {
            return packageName;
        }
    }

    public CharSequence getLabel() {
        return mLabel;
    }

    public void startSearch(Context context, String query, Bundle appData, String extraData) {
        try {
            Intent intent = new Intent(Intent.ACTION_WEB_SEARCH);
            intent.setComponent(mSearchable.getSearchActivity());
            intent.addCategory(Intent.CATEGORY_DEFAULT);
            intent.putExtra(SearchManager.QUERY, query);
            if (appData != null) {
                intent.putExtra(SearchManager.APP_DATA, appData);
            }
            if (extraData != null) {
                intent.putExtra(SearchManager.EXTRA_DATA_KEY, extraData);
            }
            intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName());
            context.startActivity(intent);
        } catch (ActivityNotFoundException ex) {
            Log.e(TAG, ""Web search activity not found: "" + mSearchable.getSearchActivity());
        }
    }

    public Cursor getSuggestions(Context context, String query) {
        SearchManager searchManager =
                (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
        return searchManager.getSuggestions(mSearchable, query);
    }

    public boolean supportsSuggestions() {
        return !TextUtils.isEmpty(mSearchable.getSuggestAuthority());
    }

    public void close() {
    }

    public boolean supportsVoiceSearch() {
        return getName().equals(SearchEngine.GOOGLE);
    }

    @Override
    public String toString() {
        return ""ActivitySearchEngine{"" + mSearchable + ""}"";
    }

}
",False,33,5,14,1,1,1,1,L0
43,com.android.browser.widget.BookmarkWidgetProvider.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser.widget;

import android.app.PendingIntent;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.Context;
import android.content.Intent;
import android.util.Log;

/**
 * Widget that shows a preview of the user's bookmarks.
 */
public class BookmarkWidgetProvider extends AppWidgetProvider {

    static final String TAG = ""BookmarkWidgetProvider"";

    @Override
    public void onUpdate(Context context, AppWidgetManager mngr, int[] ids) {
        context.startService(new Intent(BookmarkWidgetService.UPDATE, null,
                    context, BookmarkWidgetService.class));
    }

    @Override
    public void onEnabled(Context context) {
        context.startService(new Intent(context, BookmarkWidgetService.class));
    }

    @Override
    public void onDisabled(Context context) {
        context.stopService(new Intent(context, BookmarkWidgetService.class));
    }
}

",False,2,0,0,1,1,0,1,L2
44,com.android.browser.widget.BookmarkWidgetService.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.browser.widget;

import android.app.PendingIntent;
import android.app.Service;
import android.appwidget.AppWidgetManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.os.ParcelFileDescriptor;
import android.provider.Browser;
import android.provider.Browser.BookmarkColumns;
import android.service.urlrenderer.UrlRenderer;
import android.service.urlrenderer.UrlRendererService;
import android.util.Log;
import android.view.View;
import android.widget.RemoteViews;

import com.android.browser.R;

import java.io.InputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

public class BookmarkWidgetService extends Service
        implements UrlRenderer.Callback {

    private static final String TAG = ""BookmarkWidgetService"";

    /** Force the bookmarks to be re-renderer. */
    public static final String UPDATE = ""com.android.browser.widget.UPDATE"";

    /** Change the widget to the next bookmark. */
    private static final String NEXT = ""com.android.browser.widget.NEXT"";

    /** Change the widget to the previous bookmark. */
    private static final String PREV = ""com.android.browser.widget.PREV"";

    /** Id of the current item displayed in the widget. */
    private static final String EXTRA_ID =
            ""com.android.browser.widget.extra.ID"";

    // XXX: Remove these magic numbers once the dimensions of the widget can be
    // queried.
    private static final int WIDTH = 306;
    private static final int HEIGHT = 386;

    // Limit the number of connection attempts.
    private static final int MAX_SERVICE_RETRY_COUNT = 5;

    // No id specified.
    private static final int NO_ID = -1;

    private static final int MSG_UPDATE = 0;
    private final Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_UPDATE:
                    if (mRenderer != null) {
                        queryCursorAndRender();
                    } else {
                        if (++mServiceRetryCount <= MAX_SERVICE_RETRY_COUNT) {
                            // Service is not connected, try again in a second.
                            mHandler.sendEmptyMessageDelayed(MSG_UPDATE, 1000);
                        }
                    }
                    break;
                default:
                    break;
            }
        }
    };

    private final ServiceConnection mConnection = new ServiceConnection() {
        public void onServiceConnected(ComponentName className,
                IBinder service) {
            mRenderer = new UrlRenderer(service);
        }

        public void onServiceDisconnected(ComponentName className) {
            mRenderer = null;
        }
    };

    // Id -> information map storing db ids and their result.
    private final HashMap<Integer, RenderResult> mIdsToResults =
            new HashMap<Integer, RenderResult>();

    // List of ids in order
    private final ArrayList<Integer> mIdList = new ArrayList<Integer>();

    // Map of urls to ids for when a url is complete.
    private final HashMap<String, Integer> mUrlsToIds =
            new HashMap<String, Integer>();

    // The current id used by the widget during an update.
    private int mCurrentId = NO_ID;
    // Class that contacts the service on the phone to render bookmarks.
    private UrlRenderer mRenderer;
    // Number of service retries. Stop trying to connect after
    // MAX_SERVICE_RETRY_COUNT
    private int mServiceRetryCount;

    @Override
    public void onCreate() {
        bindService(new Intent(UrlRendererService.SERVICE_INTERFACE),
                mConnection, Context.BIND_AUTO_CREATE);
    }

    @Override
    public void onDestroy() {
        unbindService(mConnection);
    }

    @Override
    public android.os.IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        final String action = intent.getAction();
        if (UPDATE.equals(action)) {
            mHandler.sendEmptyMessage(MSG_UPDATE);
        } else if (PREV.equals(action) && mIdList.size() > 1) {
            int prev = getPreviousId(intent);
            if (prev == NO_ID) {
                Log.d(TAG, ""Could not determine previous id"");
                return START_NOT_STICKY;
            }
            RenderResult res = mIdsToResults.get(prev);
            if (res != null) {
                updateWidget(res);
            }
        } else if (NEXT.equals(action) && mIdList.size() > 1) {
            int next = getNextId(intent);
            if (next == NO_ID) {
                Log.d(TAG, ""Could not determine next id"");
                return START_NOT_STICKY;
            }
            RenderResult res = mIdsToResults.get(next);
            if (res != null) {
                updateWidget(res);
            }
        }
        return START_STICKY;
    }

    private int getPreviousId(Intent intent) {
        int listSize = mIdList.size();
        // If the list contains 1 or fewer entries, return NO_ID so that the
        // widget does not update.
        if (listSize <= 1) {
            return NO_ID;
        }

        int curr = intent.getIntExtra(EXTRA_ID, NO_ID);
        if (curr == NO_ID) {
            return NO_ID;
        }

        // Check if the current id is the beginning of the list so we can skip
        // iterating through.
        if (mIdList.get(0) == curr) {
            return mIdList.get(listSize - 1);
        }

        // Search for the current id and remember the previous id.
        int prev = NO_ID;
        for (int id : mIdList) {
            if (id == curr) {
                break;
            }
            prev = id;
        }
        return prev;
    }

    private int getNextId(Intent intent) {
        int listSize = mIdList.size();
        // If the list contains 1 or fewer entries, return NO_ID so that the
        // widget does not update.
        if (listSize <= 1) {
            return NO_ID;
        }

        int curr = intent.getIntExtra(EXTRA_ID, NO_ID);
        if (curr == NO_ID) {
            return NO_ID;
        }

        // Check if the current id is at the end of the list so we can skip
        // iterating through.
        if (mIdList.get(listSize - 1) == curr) {
            return mIdList.get(0);
        }

        // Iterate through the ids. i is set to the current index + 1.
        int i = 1;
        for (int id : mIdList) {
            if (id == curr) {
                break;
            }
            i++;
        }
        return mIdList.get(i);
    }

    private void updateWidget(RenderResult res) {
        RemoteViews views = new RemoteViews(getPackageName(),
                R.layout.bookmarkwidget);

        Intent prev = new Intent(PREV, null, this, BookmarkWidgetService.class);
        prev.putExtra(EXTRA_ID, res.mId);
        views.setOnClickPendingIntent(R.id.previous,
                PendingIntent.getService(this, 0, prev,
                    PendingIntent.FLAG_CANCEL_CURRENT));

        Intent next = new Intent(NEXT, null, this, BookmarkWidgetService.class);
        next.putExtra(EXTRA_ID, res.mId);
        views.setOnClickPendingIntent(R.id.next,
                PendingIntent.getService(this, 0, next,
                    PendingIntent.FLAG_CANCEL_CURRENT));

        // Set the title of the bookmark. Use the url as a backup.
        String displayTitle = res.mTitle;
        if (displayTitle == null) {
            displayTitle = res.mUrl;
        }
        views.setTextViewText(R.id.title, displayTitle);

        // Set the image or revert to the progress indicator.
        if (res.mBitmap != null) {
            views.setImageViewBitmap(R.id.image, res.mBitmap);
            views.setViewVisibility(R.id.image, View.VISIBLE);
            views.setViewVisibility(R.id.progress, View.GONE);
        } else {
            views.setViewVisibility(R.id.progress, View.VISIBLE);
            views.setViewVisibility(R.id.image, View.GONE);
        }

        // Update the current id.
        mCurrentId = res.mId;

        AppWidgetManager.getInstance(this).updateAppWidget(
                new ComponentName(this, BookmarkWidgetProvider.class),
                views);
    }

    // Default WHERE clause is all bookmarks.
    private static final String QUERY_WHERE =
            BookmarkColumns.BOOKMARK + "" == 1"";
    private static final String[] PROJECTION = new String[] {
            BookmarkColumns._ID, BookmarkColumns.TITLE, BookmarkColumns.URL };

    // Class containing the rendering information for a specific bookmark.
    private static class RenderResult {
        final int    mId;
        final String mTitle;
        final String mUrl;
        Bitmap       mBitmap;

        RenderResult(int id, String title, String url) {
            mId = id;
            mTitle = title;
            mUrl = url;
        }
    }

    private void queryCursorAndRender() {
        // Clear the ordered list of ids and the map of ids to bitmaps.
        mIdList.clear();
        mIdsToResults.clear();

        // Look up all the bookmarks
        Cursor c = getContentResolver().query(Browser.BOOKMARKS_URI, PROJECTION,
                QUERY_WHERE, null, null);
        if (c != null) {
            if (c.moveToFirst()) {
                ArrayList<String> urls = new ArrayList<String>(c.getCount());
                boolean sawCurrentId = false;
                do {
                    int id = c.getInt(0);
                    String title = c.getString(1);
                    String url = c.getString(2);

                    // Linear list of ids to obtain the previous and next.
                    mIdList.add(id);

                    // Map the url to its db id for lookup when complete.
                    mUrlsToIds.put(url, id);

                    // Is this the current id?
                    if (mCurrentId == id) {
                        sawCurrentId = true;
                    }

                    // Store the current information to at least display the
                    // title.
                    RenderResult res = new RenderResult(id, title, url);
                    mIdsToResults.put(id, res);

                    // Add the url to our list to render.
                    urls.add(url);
                } while (c.moveToNext());

                // Request a rendering of the urls. XXX: Hard-coded dimensions
                // until the view's orientation and size can be determined. Or
                // in the future the image will be a picture that can be
                // scaled/zoomed arbitrarily.
                mRenderer.render(urls, WIDTH, HEIGHT, this);

                // Set the current id to the very first id if we did not see
                // the current id in the list (the bookmark could have been
                // deleted or this is the first update).
                if (!sawCurrentId) {
                    mCurrentId = mIdList.get(0);
                }
            }
            c.close();
        }
    }

    // UrlRenderer.Callback implementation
    public void complete(String url, ParcelFileDescriptor result) {
        int id = mUrlsToIds.get(url);
        if (id == NO_ID) {
            Log.d(TAG, ""No matching id found during completion of ""
                    + url);
            return;
        }

        RenderResult res = mIdsToResults.get(id);
        if (res == null) {
            Log.d(TAG, ""No result found during completion of ""
                    + url);
            return;
        }

        // Set the result.
        if (result != null) {
            InputStream input =
                    new ParcelFileDescriptor.AutoCloseInputStream(result);
            Bitmap orig = BitmapFactory.decodeStream(input, null, null);
            // XXX: Hard-coded scaled bitmap until I can query the image
            // dimensions.
            res.mBitmap = Bitmap.createScaledBitmap(orig, WIDTH, HEIGHT, true);
            try {
                input.close();
            } catch (IOException e) {
                // oh well...
            }
        }

        // If we are currently looking at the bookmark that just finished,
        // update the widget.
        if (mCurrentId == id) {
            updateWidget(res);
        }
    }
}
",True,2,1,1,0,0,1,0,L2
