,file_path,source_code,is_vulnerable, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,com.keepassdroid.IconPickerActivity.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.BaseAdapter;
import android.widget.GridView;
import android.widget.ImageView;
import android.widget.TextView;

import com.android.keepass.R;
import com.keepassdroid.icons.Icons;

public class IconPickerActivity extends LockCloseActivity
{
	public static final String KEY_ICON_ID = ""icon_id"";

	public static void Launch(Activity act)
	{
		Intent i = new Intent(act, IconPickerActivity.class);
		act.startActivityForResult(i, 0);
	}

   @Override
   public void onCreate(Bundle savedInstanceState)
   {
   	super.onCreate(savedInstanceState);
   	setContentView(R.layout.icon_picker);

   	GridView currIconGridView = (GridView)findViewById(R.id.IconGridView);
   	currIconGridView.setAdapter(new ImageAdapter(this));

   	currIconGridView.setOnItemClickListener(new OnItemClickListener()
   	{
			public void onItemClick(AdapterView<?> parent, View v, int position, long id)
			{
				final Intent intent = new Intent();
				
				intent.putExtra(KEY_ICON_ID, position);
				setResult(EntryEditActivity.RESULT_OK_ICON_PICKER, intent);
				
				finish();
			}
   	});
   }
   
   public class ImageAdapter extends BaseAdapter
   {
   	Context mContext;

   	public ImageAdapter(Context c)
   	{
   		mContext = c;
   	}
   	
   	public int getCount()
   	{
   		/* Return number of KeePass icons */
   		return Icons.count();
   	}
   	
   	public Object getItem(int position)
		{
			return null;
		}

		public long getItemId(int position)
		{
			return 0;
		}
   	
   	public View getView(int position, View convertView, ViewGroup parent)
   	{
   		View currView;
   		if(convertView == null)
   		{
   			LayoutInflater li = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE); 
   			currView = li.inflate(R.layout.icon, null);
   		}
   		else
   		{
   			currView = convertView;
   		}
   		
   		TextView tv = (TextView) currView.findViewById(R.id.icon_text);
   		tv.setText("""" + position);
   		ImageView iv = (ImageView) currView.findViewById(R.id.icon_image);
   		iv.setImageResource(Icons.iconToResId(position));
 
   		return currView;
   	}
   }
}
",False,242,0,0,12,43,2,3,L8
1,com.keepassdroid.LockCloseActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import com.android.keepass.KeePass;
import com.keepassdroid.app.App;

public class LockCloseActivity extends LockingActivity {

	@Override
	protected void onResume() {
		super.onResume();

		checkShutdown();
	}
	
	private void checkShutdown() {
		if ( App.isShutdown() && App.getDB().Loaded() ) {
			setResult(KeePass.EXIT_LOCK);
			finish();
		}
		
	}

}
",False,242,0,0,11,43,4,4,L8
2,com.keepassdroid.GroupBaseActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;


import android.content.ActivityNotFoundException;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Bundle;
import android.os.Handler;
import android.preference.PreferenceManager;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import com.android.keepass.KeePass;
import com.android.keepass.R;
import com.keepassdroid.app.App;
import com.keepassdroid.database.PwGroup;
import com.keepassdroid.database.edit.OnFinish;
import com.keepassdroid.settings.AppSettingsActivity;
import com.keepassdroid.utils.Util;
import com.keepassdroid.view.ClickView;
import com.keepassdroid.view.GroupViewOnlyView;

public abstract class GroupBaseActivity extends LockCloseListActivity {
	public static final String KEY_ENTRY = ""entry"";
	public static final String KEY_MODE = ""mode"";
	
	protected static final int MENU_DONATE = Menu.FIRST;
	protected static final int MENU_LOCK = Menu.FIRST + 1;
	protected static final int MENU_SEARCH = Menu.FIRST + 2;
	protected static final int MENU_CHANGE_MASTER_KEY = Menu.FIRST + 3;
	protected static final int MENU_APP_SETTINGS = Menu.FIRST + 4;
	protected static final int MENU_SORT = Menu.FIRST + 5;
	
	private SharedPreferences prefs;
	
	protected PwGroup mGroup;

	@Override
	protected void onResume() {
		super.onResume();
		
		refreshIfDirty();
	}
	
	public void refreshIfDirty() {
		Database db = App.getDB();
		if ( db.dirty.contains(mGroup) ) {
			db.dirty.remove(mGroup);
			BaseAdapter adapter = (BaseAdapter) getListAdapter();
			adapter.notifyDataSetChanged();
			
		}
	}

	@Override
	protected void onListItemClick(ListView l, View v, int position, long id) {
		super.onListItemClick(l, v, position, id);

		ListAdapter adapt = getListAdapter();
		ClickView cv = (ClickView) adapt.getView(position, null, null);
		cv.onClick();
		
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		
		// Likely the app has been killed exit the activity 
		if ( ! App.getDB().Loaded() ) {
			finish();
			return;
		}
		
		prefs = PreferenceManager.getDefaultSharedPreferences(this);



		setContentView(new GroupViewOnlyView(this));
		setResult(KeePass.EXIT_NORMAL);

		styleScrollBars();
		
	}
	
	protected void styleScrollBars() {
		ListView lv = getListView();
		lv.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);
		lv.setTextFilterEnabled(true);
		
	}
	
	protected void setGroupTitle() {
		if ( mGroup != null ) {
			String name = mGroup.getName();
			if ( name != null && name.length() > 0 ) {
				TextView tv = (TextView) findViewById(R.id.group_name);
				if ( tv != null ) {
					tv.setText(name);
				}
			} else {
				TextView tv = (TextView) findViewById(R.id.group_name);
				if ( tv != null ) {
					tv.setText(getText(R.string.root));
				}
				
			}
		}
	}
	
	protected void setGroupIcon() {
		if (mGroup != null) {
			ImageView iv = (ImageView) findViewById(R.id.icon);
			App.getDB().drawFactory.assignDrawableTo(iv, getResources(), mGroup.getIcon());
		}
	}
	
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		
		menu.add(0, MENU_DONATE, 0, R.string.menu_donate);
		menu.findItem(MENU_DONATE).setIcon(android.R.drawable.ic_menu_share);

		menu.add(0, MENU_LOCK, 0, R.string.menu_lock);
		menu.findItem(MENU_LOCK).setIcon(android.R.drawable.ic_lock_lock);
		
		menu.add(0, MENU_SEARCH, 0, R.string.menu_search);
		menu.findItem(MENU_SEARCH).setIcon(android.R.drawable.ic_menu_search);
		
		menu.add(0, MENU_APP_SETTINGS, 0, R.string.menu_app_settings);
		menu.findItem(MENU_APP_SETTINGS).setIcon(android.R.drawable.ic_menu_preferences);
		
		menu.add(0, MENU_CHANGE_MASTER_KEY, 0, R.string.menu_change_key);
		menu.findItem(MENU_CHANGE_MASTER_KEY).setIcon(android.R.drawable.ic_menu_manage);

		menu.add(0, MENU_SORT, 0, R.string.sort_name);
		menu.findItem(MENU_SORT).setIcon(android.R.drawable.ic_menu_sort_by_size);
		
		return true;
	}

	private void setSortMenuText(Menu menu) {
		boolean sortByName = prefs.getBoolean(getString(R.string.sort_key), getResources().getBoolean(R.bool.sort_default));
		
		int resId;
		if ( sortByName ) {
			resId = R.string.sort_db;
		} else {
			resId = R.string.sort_name;
		}
			
			
		menu.findItem(MENU_SORT).setTitle(resId);

	}
	
	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		if ( ! super.onPrepareOptionsMenu(menu) ) {
			return false;
		}
		
		setSortMenuText(menu);
		
		return true;
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch ( item.getItemId() ) {
		case MENU_DONATE:
			try {
				Util.gotoUrl(this, R.string.donate_url);
			} catch (ActivityNotFoundException e) {
				Toast.makeText(this, R.string.error_failed_to_launch_link, Toast.LENGTH_LONG).show();
				return false;
			}
			
			return true;
		case MENU_LOCK:
			App.setShutdown();
			setResult(KeePass.EXIT_LOCK);
			finish();
			return true;
		
		case MENU_SEARCH:
			onSearchRequested();
			return true;
			
		case MENU_APP_SETTINGS:
			AppSettingsActivity.Launch(this);
			return true;

		case MENU_CHANGE_MASTER_KEY:
			setPassword();
			return true;
			
		case MENU_SORT:
			toggleSort();
			return true;

		}
		
		return super.onOptionsItemSelected(item);
	}
	
	private void toggleSort() {
		// Toggle setting
		String sortKey = getString(R.string.sort_key);
		boolean sortByName = prefs.getBoolean(sortKey, getResources().getBoolean(R.bool.sort_default));
		Editor editor = prefs.edit();
		editor.putBoolean(sortKey, ! sortByName);
		editor.commit();
		
		// Mark all groups as dirty now to refresh them on load
		Database db = App.getDB();
		db.markAllGroupsAsDirty();
		// We'll manually refresh this group so we can remove it
		db.dirty.remove(mGroup);
		
		// Tell the adapter to refresh it's list
		BaseAdapter adapter = (BaseAdapter) getListAdapter();
		adapter.notifyDataSetChanged();
		
	}

	private void setPassword() {
		SetPasswordDialog dialog = new SetPasswordDialog(this);
		
		dialog.show();
	}
	
	public class RefreshTask extends OnFinish {
		public RefreshTask(Handler handler) {
			super(handler);
		}

		@Override
		public void run() {
			if ( mSuccess) {
				refreshIfDirty();
			} else {
				displayMessage(GroupBaseActivity.this);
			}
		}
	}
	
	public class AfterDeleteGroup extends OnFinish {
		public AfterDeleteGroup(Handler handler) {
			super(handler);
		}

		@Override
		public void run() {
			if ( mSuccess) {
				refreshIfDirty();
			} else {
				mHandler.post(new UIToastTask(GroupBaseActivity.this, ""Unrecoverable error: "" + mMessage));
				App.setShutdown();
				finish();
			}
		}

	}
	
}
",False,245,1,3,11,43,10,13,L8
3,com.keepassdroid.LockingClosePreferenceActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import com.android.keepass.KeePass;
import com.keepassdroid.app.App;

public class LockingClosePreferenceActivity extends LockingPreferenceActivity {

	@Override
	protected void onResume() {
		super.onResume();

		checkShutdown();
	}
	
	private void checkShutdown() {
		if ( App.isShutdown() && App.getDB().Loaded() ) {
			setResult(KeePass.EXIT_LOCK);
			finish();
		}
		
	}

}
",False,242,0,0,11,43,1,4,L8
4,com.keepassdroid.GroupActivityV4.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import java.util.UUID;

import android.content.Intent;
import android.view.Menu;

import com.android.keepass.R;
import com.keepassdroid.database.PwGroupId;
import com.keepassdroid.database.PwGroupIdV4;

public class GroupActivityV4 extends GroupActivity {

	@Override
	protected PwGroupId retrieveGroupId(Intent i) {
		String uuid = i.getStringExtra(KEY_ENTRY);
		
		if ( uuid == null || uuid.length() == 0 ) {
			return null;
		}
		
		return new PwGroupIdV4(UUID.fromString(uuid));
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		
		menu.add(0, MENU_DONATE, 0, R.string.menu_donate);
		menu.findItem(MENU_DONATE).setIcon(android.R.drawable.ic_menu_share);

		menu.add(0, MENU_LOCK, 0, R.string.menu_lock);
		menu.findItem(MENU_LOCK).setIcon(android.R.drawable.ic_lock_lock);
	
		menu.add(0, MENU_SEARCH, 0, R.string.menu_search);
		menu.findItem(MENU_SEARCH).setIcon(android.R.drawable.ic_menu_search);
		
		menu.add(0, MENU_APP_SETTINGS, 0, R.string.menu_app_settings);
		menu.findItem(MENU_APP_SETTINGS).setIcon(android.R.drawable.ic_menu_preferences);
		
		/*
		menu.add(0, MENU_CHANGE_MASTER_KEY, 0, R.string.menu_change_key);
		menu.findItem(MENU_CHANGE_MASTER_KEY).setIcon(android.R.drawable.ic_menu_manage);
		*/
		
		menu.add(0, MENU_SORT, 0, R.string.sort_name);
		menu.findItem(MENU_SORT).setIcon(android.R.drawable.ic_menu_sort_by_size);
		
		return true;

	}

	@Override
	protected void setupButtons() {
		addGroupEnabled = false;
		addEntryEnabled = false;
	}

}
",False,243,0,0,12,43,0,4,L9
5,com.keepassdroid.CancelDialog.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import android.app.Dialog;
import android.content.Context;

public class CancelDialog extends Dialog {

	private boolean mCanceled = false; 
	
	public CancelDialog(Context context) {
		super(context);
	}
	
	public boolean canceled() {
		return mCanceled;
	}

	@Override
	public void cancel() {
		super.cancel();
		mCanceled = true;
	}
}
",False,27,5,11,0,0,1,0,L8
6,com.keepassdroid.EntryActivityV4.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import com.android.keepass.R;


public class EntryActivityV4 extends EntryActivity {

	@Override
	protected void setEntryView() {
		setContentView(R.layout.entry_view_v4);
	}

	@Override
	protected void setupEditButtons() {
		// No edit buttons yet
	}


}
",False,243,0,0,12,43,0,1,L9
7,com.keepassdroid.LockingListActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import android.app.ListActivity;

import com.keepassdroid.app.App;
import com.keepassdroid.timers.Timeout;

public class LockingListActivity extends ListActivity {
	@Override
	protected void onPause() {
		super.onPause();
		if ( App.getDB().Loaded() ) {
			Timeout.start(this);
		}
	}

	@Override
	protected void onResume() {
		super.onResume();

		if ( App.getDB().Loaded() ) {
			Timeout.cancel(this);
		}
	}
}
",False,218,7,10,11,43,1,3,L8
8,com.keepassdroid.Database.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import android.content.Context;

import com.keepassdroid.database.PwDatabase;
import com.keepassdroid.database.PwDatabaseV3;
import com.keepassdroid.database.PwEntry;
import com.keepassdroid.database.PwGroup;
import com.keepassdroid.database.PwGroupId;
import com.keepassdroid.database.exception.InvalidDBException;
import com.keepassdroid.database.exception.PwDbOutputException;
import com.keepassdroid.database.load.Importer;
import com.keepassdroid.database.load.ImporterFactory;
import com.keepassdroid.database.save.PwDbOutput;
import com.keepassdroid.icons.DrawableFactory;
import com.keepassdroid.search.SearchDbHelper;

/**
 * @author bpellin
 */
public class Database {
	public Map<PwGroupId, PwGroup> groups = new HashMap<PwGroupId, PwGroup>();
	public Map<UUID, PwEntry> entries = new HashMap<UUID, PwEntry>();
	public Set<PwGroup> dirty = new HashSet<PwGroup>();
	public PwGroup root;
	public PwDatabase pm;
	public String mFilename;
	public SearchDbHelper searchHelper;
	public boolean indexBuilt = false;
	
	public DrawableFactory drawFactory = new DrawableFactory();
	
	private boolean loaded = false;
	
	public boolean Loaded() {
		return loaded;
	}
	
	public void setLoaded() {
		loaded = true;
	}
	
	public void LoadData(Context ctx, InputStream is, String password, String keyfile) throws IOException, InvalidDBException {
		LoadData(ctx, is, password, keyfile, new UpdateStatus(), !Importer.DEBUG);
	}

	public void LoadData(Context ctx, String filename, String password, String keyfile) throws IOException, FileNotFoundException, InvalidDBException {
		LoadData(ctx, filename, password, keyfile, new UpdateStatus(), !Importer.DEBUG);
	}
	
	public void LoadData(Context ctx, String filename, String password, String keyfile, UpdateStatus status) throws IOException, FileNotFoundException, InvalidDBException {
		LoadData(ctx, filename, password, keyfile, status, !Importer.DEBUG);
	}
	
	public void LoadData(Context ctx, String filename, String password, String keyfile, UpdateStatus status, boolean debug) throws IOException, FileNotFoundException, InvalidDBException {
		FileInputStream fis;
		fis = new FileInputStream(filename);
		
		LoadData(ctx, fis, password, keyfile, status, debug);
	
		mFilename = filename;
	}

	public void LoadData(Context ctx, InputStream is, String password, String keyfile, boolean debug) throws IOException, InvalidDBException {
		LoadData(ctx, is, password, keyfile, new UpdateStatus(), debug);
	}

	public void LoadData(Context ctx, InputStream is, String password, String keyfile, UpdateStatus status, boolean debug) throws IOException, InvalidDBException {

		BufferedInputStream bis = new BufferedInputStream(is);
		
		if ( ! bis.markSupported() ) {
			throw new IOException(""Input stream does not support mark."");
		}
		
		// We'll end up reading 8 bytes to identify the header. Might as well use two extra.
		bis.mark(10);
		
		Importer imp = ImporterFactory.createImporter(bis, debug);

		bis.reset();  // Return to the start
		
		pm = imp.openDatabase(bis, password, keyfile, status);
		if ( pm != null ) {
			root = pm.rootGroup;
			populateGlobals(root);
		}
		
		loaded = true;
	}
	
	
	/** Build the search index from the current database
	 * @param ctx (this should be an App context not an activity constant to avoid leaks)
	 */
	public void buildSearchIndex(Context ctx) {

		searchHelper = new SearchDbHelper(ctx);
		
		initSearch();
		
		searchHelper.open();
		searchHelper.insertEntry(pm.getEntries());
		searchHelper.close();
		
		indexBuilt = true;
	}
	
	public PwGroup Search(String str) {
		searchHelper.open();
		PwGroup group = searchHelper.search(this, str);
		searchHelper.close();
		
		return group;
		
	}
	
	public void SaveData() throws IOException, PwDbOutputException {
		SaveData(mFilename);
	}
	
	public void SaveData(String filename) throws IOException, PwDbOutputException {
		File tempFile = new File(filename + "".tmp"");
		FileOutputStream fos = new FileOutputStream(tempFile);
		//BufferedOutputStream bos = new BufferedOutputStream(fos);
		
		//PwDbV3Output pmo = new PwDbV3Output(pm, bos, App.getCalendar());
		PwDbOutput pmo = PwDbOutput.getInstance(pm, fos);
		pmo.output();
		//bos.flush();
		//bos.close();
		fos.close();
		
		File orig = new File(filename);
		orig.delete();
		
		if ( ! tempFile.renameTo(orig) ) {
			throw new IOException(""Failed to store database."");
		}
		
		mFilename = filename;
		
	}
	
	private void populateGlobals(PwGroup currentGroup) {

		List<PwGroup> childGroups = currentGroup.childGroups;
		List<PwEntry> childEntries = currentGroup.childEntries;
		
		for (int i = 0; i < childEntries.size(); i++ ) {
			PwEntry cur = childEntries.get(i);
			entries.put(cur.getUUID(), cur);
		}
		
		for (int i = 0; i < childGroups.size(); i++ ) {
			PwGroup cur = childGroups.get(i);
			groups.put(cur.getId(), cur);
			populateGlobals(cur);
		}
	}
	
	public void clear() {
		initSearch();
		
		indexBuilt = false;
		groups.clear();
		entries.clear();
		dirty.clear();
		drawFactory.clear();
		
		root = null;
		pm = null;
		mFilename = null;
		loaded = false;
	}
	
	public void initSearch() {
		if ( searchHelper != null ) {
			searchHelper.open();
			searchHelper.clear();
			searchHelper.close();
		}
	}
	
	public void markAllGroupsAsDirty() {
		for ( PwGroup group : pm.getGroups() ) {
			dirty.add(group);
		}
		
		// TODO: This should probably be abstracted out
		// The root group in v3 is not an 'official' group
		if ( pm instanceof PwDatabaseV3 ) {
			dirty.add(root);		
		}
	}
	
	
}
",True,234,3,30,10,43,33,13,L6
9,com.keepassdroid.PwListAdapter.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import android.content.SharedPreferences;
import android.preference.PreferenceManager;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;

import com.android.keepass.R;
import com.keepassdroid.database.PwEntry;
import com.keepassdroid.database.PwGroup;
import com.keepassdroid.view.PwEntryView;
import com.keepassdroid.view.PwGroupView;

public class PwListAdapter extends BaseAdapter {

	private GroupBaseActivity mAct;
	private PwGroup mGroup;
	private List<PwGroup> groupsForViewing;
	private List<PwEntry> entriesForViewing;
	private Comparator<PwEntry> entryComp = new PwEntry.EntryNameComparator();
	private Comparator<PwGroup> groupComp = new PwGroup.GroupNameComparator();
	private SharedPreferences prefs;
	
	public PwListAdapter(GroupBaseActivity act, PwGroup group) {
		mAct = act;
		mGroup = group;
		prefs = PreferenceManager.getDefaultSharedPreferences(act);
		
		filterAndSort();
		
	}
	
	@Override
	public void notifyDataSetChanged() {
		super.notifyDataSetChanged();
		
		filterAndSort();
	}

	@Override
	public void notifyDataSetInvalidated() {
		super.notifyDataSetInvalidated();
		
		filterAndSort();
	}

	private void filterAndSort() {
		entriesForViewing = new ArrayList<PwEntry>();
		
		for (int i = 0; i < mGroup.childEntries.size(); i++) {
			PwEntry entry = mGroup.childEntries.get(i);
			if ( ! entry.isMetaStream() ) {
				entriesForViewing.add(entry);
			}
		}
		
		boolean sortLists = prefs.getBoolean(mAct.getString(R.string.sort_key),	mAct.getResources().getBoolean(R.bool.sort_default)); 
		if ( sortLists ) {
			groupsForViewing = new ArrayList<PwGroup>(mGroup.childGroups);
			
			Collections.sort(entriesForViewing, entryComp);
			Collections.sort(groupsForViewing, groupComp);
		} else {
			groupsForViewing = mGroup.childGroups;
		}
	}
	
	public int getCount() {
		
		return groupsForViewing.size() + entriesForViewing.size();
	}

	public Object getItem(int position) {
		return position;
	}

	public long getItemId(int position) {
		return position;
	}

	public View getView(int position, View convertView, ViewGroup parent) {
		int size = groupsForViewing.size();
		
		if ( position < size ) { 
			return createGroupView(position, convertView);
		} else {
			return createEntryView(position - size, convertView);
		}
	}

	private View createGroupView(int position, View convertView) {
		PwGroupView gv;

		PwGroup group = groupsForViewing.get(position);
		gv = PwGroupView.getInstance(mAct, group);

		return gv;
	}

	private PwEntryView createEntryView(int position, View convertView) {
		PwEntryView ev;

		ev = PwEntryView.getInstance(mAct, entriesForViewing.get(position), position);

		return ev;
	}

}
",False,243,1,1,12,43,2,5,L8
10,com.keepassdroid.GeneratePasswordActivity.java,"/*
 * Copyright 2010 Tolga Onbay, Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.Toast;

import com.android.keepass.KeePass;
import com.android.keepass.R;
import com.keepassdroid.password.PasswordGenerator;

public class GeneratePasswordActivity extends LockCloseActivity {
	private static final int[] BUTTON_IDS = new int [] {R.id.btn_length6, R.id.btn_length8, R.id.btn_length12, R.id.btn_length16};
	
	public static void Launch(Activity act) {
		Intent i = new Intent(act, GeneratePasswordActivity.class);
		
		act.startActivityForResult(i, 0);
	}
	
	private OnClickListener lengthButtonsListener = new OnClickListener() {
	    public void onClick(View v) {
	    	Button button = (Button) v;
	    	
	    	EditText editText = (EditText) findViewById(R.id.length);
	    	editText.setText(button.getText());
	    }
	};
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.generate_password);
		setResult(KeePass.EXIT_NORMAL);
		
		for (int id : BUTTON_IDS) {
        	Button button = (Button) findViewById(id);
        	button.setOnClickListener(lengthButtonsListener);
		}
		
		Button genPassButton = (Button) findViewById(R.id.generate_password_button);
        genPassButton.setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				String password = generatePassword();
				
				EditText txtPassword = (EditText) findViewById(R.id.password);
				txtPassword.setText(password);
			}
		});
        
        Button acceptButton = (Button) findViewById(R.id.accept_button);
        acceptButton.setOnClickListener(new OnClickListener() {
			
			public void onClick(View v) {
				EditText password = (EditText) findViewById(R.id.password);
				
				Intent intent = new Intent();
				intent.putExtra(""com.keepassdroid.password.generated_password"", password.getText().toString());
				
				setResult(EntryEditActivity.RESULT_OK_PASSWORD_GENERATOR, intent);
				
				finish();
			}
		});
        
        Button cancelButton = (Button) findViewById(R.id.cancel_button);
        cancelButton.setOnClickListener(new OnClickListener() {
			
			public void onClick(View v) {
				setResult(RESULT_CANCELED);
				
				finish();
			}
		});
	}
	
    public String generatePassword() {
    	String password = """";
    	
    	try {
    		int length = new Integer(((EditText) findViewById(R.id.length)).getText().toString());
    		
    		((CheckBox) findViewById(R.id.cb_uppercase)).isChecked();
        	
        	PasswordGenerator generator = new PasswordGenerator(this);
       	
	    	password = generator.generatePassword(length,
	    			((CheckBox) findViewById(R.id.cb_uppercase)).isChecked(),
	    			((CheckBox) findViewById(R.id.cb_lowercase)).isChecked(),
	    			((CheckBox) findViewById(R.id.cb_digits)).isChecked(),
	    			((CheckBox) findViewById(R.id.cb_minus)).isChecked(),
	    			((CheckBox) findViewById(R.id.cb_underline)).isChecked(),
	    			((CheckBox) findViewById(R.id.cb_space)).isChecked(),
	    			((CheckBox) findViewById(R.id.cb_specials)).isChecked(),
	    			((CheckBox) findViewById(R.id.cb_brackets)).isChecked());
    	} catch (NumberFormatException e) {
    		Toast.makeText(this, R.string.error_wrong_length, Toast.LENGTH_LONG).show();
		} catch (IllegalArgumentException e) {
			Toast.makeText(this, e.getMessage(), Toast.LENGTH_LONG).show();
		}
    	
    	return password;
    }
}
",True,242,0,0,12,43,1,4,L8
11,com.keepassdroid.LockCloseListActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import com.android.keepass.KeePass;
import com.keepassdroid.app.App;

public class LockCloseListActivity extends LockingListActivity {

	@Override
	protected void onResume() {
		super.onResume();

		checkShutdown();
	}

	private void checkShutdown() {
		if ( App.isShutdown() && App.getDB().Loaded() ) {
			setResult(KeePass.EXIT_LOCK);
			finish();
		}
		
	}
}
",False,242,0,0,11,43,1,4,L8
12,com.keepassdroid.GroupEditActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.TextView;
import android.widget.Toast;

import com.android.keepass.R;
import com.keepassdroid.database.PwGroup;
import com.keepassdroid.database.PwGroupV3;
import com.keepassdroid.icons.Icons;

public class GroupEditActivity extends Activity
{
	public static final String KEY_PARENT = ""parent"";
	public static final String KEY_NAME = ""name"";
	public static final String KEY_ICON_ID = ""icon_id"";
	
	private int mSelectedIconID;
	
	public static void Launch(Activity act, PwGroup pw)
	{
		if ( !(pw instanceof PwGroupV3) )
		{
			throw new RuntimeException(""Not yet implemented."");
		}

		Intent i = new Intent(act, GroupEditActivity.class);

		PwGroupV3 parent = (PwGroupV3) pw;
		i.putExtra(KEY_PARENT, parent.groupId);
		
		act.startActivityForResult(i, 0);
	}
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.group_edit);
		setTitle(R.string.add_group_title);
		
		ImageButton iconButton = (ImageButton) findViewById(R.id.icon_button);
		iconButton.setOnClickListener(new View.OnClickListener()
		{
			public void onClick(View v)
			{
				IconPickerActivity.Launch(GroupEditActivity.this);
			}
		});
		
		Button okButton = (Button) findViewById(R.id.ok);
		okButton.setOnClickListener(new View.OnClickListener()
		{
			public void onClick(View v)
			{
				TextView nameField = (TextView) findViewById(R.id.group_name);
				String name = nameField.getText().toString();
				
				if ( name.length() > 0 )
				{
					final Intent intent = new Intent();
					
					intent.putExtra(KEY_NAME, name);
					intent.putExtra(KEY_ICON_ID, mSelectedIconID);
					setResult(Activity.RESULT_OK, intent);
					
					finish();
				} 
				else
				{
					Toast.makeText(GroupEditActivity.this, R.string.error_no_name, Toast.LENGTH_LONG).show();
				}
			}
		});

		Button cancel = (Button) findViewById(R.id.cancel);
		cancel.setOnClickListener(new View.OnClickListener()
		{
			public void onClick(View v)
			{
				final Intent intent = new Intent();
				setResult(Activity.RESULT_CANCELED, intent);

				finish();
			}
		});
	}
	
	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data)
	{
		switch (resultCode)
		{
			case EntryEditActivity.RESULT_OK_ICON_PICKER:
				mSelectedIconID = data.getExtras().getInt(IconPickerActivity.KEY_ICON_ID);
				ImageButton currIconButton = (ImageButton) findViewById(R.id.icon_button);
				currIconButton.setImageResource(Icons.iconToResId(mSelectedIconID));
				break;

			case Activity.RESULT_CANCELED:
			default:
				break;
		}
	}
}
",False,242,0,0,12,43,1,5,L8
13,com.keepassdroid.UIToastTask.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import android.content.Context;
import android.widget.Toast;

public class UIToastTask implements Runnable {

	private String mText;
	private Context mCtx;
	
	public UIToastTask(Context ctx, int resId) {
		mCtx = ctx;
		mText = ctx.getString(resId);
	}

	public UIToastTask(Context ctx, String text) {
		mCtx = ctx;
		mText = text;
	}

	public void run() {
		Toast.makeText(mCtx, mText, Toast.LENGTH_LONG).show();
		
	}
	
	

}
",False,26,6,11,0,0,2,0,L8
14,com.keepassdroid.LockingActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import android.app.Activity;

import com.keepassdroid.app.App;
import com.keepassdroid.timers.Timeout;

public class LockingActivity extends Activity {

	@Override
	protected void onPause() {
		super.onPause();
		if ( App.getDB().Loaded() ) {
			Timeout.start(this);
		}
	}

	@Override
	protected void onResume() {
		super.onResume();

		if ( App.getDB().Loaded() ) {
			Timeout.cancel(this);
		}
	}
}
",False,218,6,7,11,43,2,3,L8
15,com.keepassdroid.ProgressTask.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import android.app.ProgressDialog;
import android.content.Context;
import android.os.Handler;

import com.android.keepass.R;
import com.keepassdroid.database.edit.OnFinish;
import com.keepassdroid.database.edit.RunnableOnFinish;

/** Designed to Pop up a progress dialog, run a thread in the background, 
 *  run cleanup in the current thread, close the dialog.  Without blocking 
 *  the current thread.
 *  
 * @author bpellin
 *
 */
public class ProgressTask implements Runnable {
	private Context mCtx;
	private Handler mHandler;
	private RunnableOnFinish mTask;
	private ProgressDialog mPd;
	
	public ProgressTask(Context ctx, RunnableOnFinish task, int messageId) {
		mCtx = ctx;
		mTask = task;
		mHandler = new Handler();
		
		// Show process dialog
		mPd = new ProgressDialog(mCtx);
		mPd.setTitle(ctx.getText(R.string.progress_title));
		mPd.setMessage(ctx.getText(messageId));

		// Set code to run when this is finished
		mTask.setStatus(new UpdateStatus(ctx, mHandler, mPd));
		mTask.mFinish = new AfterTask(task.mFinish, mHandler);
		
	}
	
	public void run() {
		// Show process dialog
		mPd.show();
		
			
		// Start Thread to Run task
		Thread t = new Thread(mTask);
		t.start();
		
	}
	
	private class AfterTask extends OnFinish {
		
		public AfterTask(OnFinish finish, Handler handler) {
			super(finish, handler);
		}

		@Override
		public void run() {
			super.run();
			
			// Remove the progress dialog
			mHandler.post(new CloseProcessDialog());
			
		}
		
	}
	
	private class CloseProcessDialog implements Runnable {

		public void run() {
			mPd.dismiss();
		}
		
	}
	
}
",True,31,4,9,1,3,9,3,L7
16,com.keepassdroid.EntryActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import java.text.DateFormat;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;

import android.app.Activity;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.ActivityNotFoundException;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.os.Handler;
import android.preference.PreferenceManager;
import android.text.method.PasswordTransformationMethod;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.TableLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.android.keepass.KeePass;
import com.android.keepass.R;
import com.keepassdroid.app.App;
import com.keepassdroid.database.PwEntry;
import com.keepassdroid.database.PwEntryV3;
import com.keepassdroid.database.PwEntryV4;
import com.keepassdroid.intents.Intents;
import com.keepassdroid.utils.Types;
import com.keepassdroid.utils.Util;

public class EntryActivity extends LockCloseActivity {
	public static final String KEY_ENTRY = ""entry"";
	public static final String KEY_REFRESH_POS = ""refresh_pos"";

	private static final int MENU_DONATE = Menu.FIRST;
	private static final int MENU_PASS = Menu.FIRST + 1;
	private static final int MENU_GOTO_URL = Menu.FIRST + 2;
	private static final int MENU_COPY_USER = Menu.FIRST + 3;
	private static final int MENU_COPY_PASS = Menu.FIRST + 4;
	private static final int MENU_LOCK = Menu.FIRST + 5; 
	
	public static final int NOTIFY_USERNAME = 1;
	public static final int NOTIFY_PASSWORD = 2;
	
	@SuppressWarnings(""unused"")
	private static final int COL_LABEL = 0;
	private static final int COL_DATA = 1;
	
	public static void Launch(Activity act, PwEntry pw, int pos) {
		Intent i;
		
		if ( pw instanceof PwEntryV4 ) {
			i = new Intent(act, EntryActivityV4.class);
		} else {
			i = new Intent(act, EntryActivity.class);
		}
		
		i.putExtra(KEY_ENTRY, Types.UUIDtoBytes(pw.getUUID()));
		i.putExtra(KEY_REFRESH_POS, pos);
		
		act.startActivityForResult(i,0);
	}
	
	private PwEntry mEntry;
	private Timer mTimer = new Timer();
	private boolean mShowPassword;
	private int mPos;
	private NotificationManager mNM;
	private BroadcastReceiver mIntentReceiver;
	
	protected void setEntryView() {
		setContentView(R.layout.entry_view);
	}
	
	protected void setupEditButtons() {
		Button edit = (Button) findViewById(R.id.entry_edit);
		edit.setOnClickListener(new View.OnClickListener() {

			public void onClick(View v) {
				EntryEditActivity.Launch(EntryActivity.this, mEntry);
			}
			
		});
		
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		Database db = App.getDB();
		// Likely the app has been killed exit the activity 
		if ( ! db.Loaded() ) {
			finish();
			return;
		}

		setEntryView();
		setResult(KeePass.EXIT_NORMAL);

		Intent i = getIntent();
		UUID uuid = Types.bytestoUUID(i.getByteArrayExtra(KEY_ENTRY));
		mPos = i.getIntExtra(KEY_REFRESH_POS, -1);
		assert(uuid != null);
		
		mEntry = db.entries.get(uuid);
		
		// Update last access time.
		mEntry.stampLastAccess();
		
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
		mShowPassword = ! prefs.getBoolean(getString(R.string.maskpass_key), getResources().getBoolean(R.bool.maskpass_default));
		fillData();

		View scroll = findViewById(R.id.entry_scroll);
		scroll.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);
		
		TableLayout table = (TableLayout) findViewById(R.id.entry_table);
		table.setColumnShrinkable(COL_DATA, true);
		
		setupEditButtons();
		
		// Notification Manager
		mNM = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
		
		if ( mEntry.getPassword().length() > 0 ) {
			// only show notification if password is available
			Notification password = getNotification(Intents.COPY_PASSWORD, R.string.copy_password);
			mNM.notify(NOTIFY_PASSWORD, password);
		}
		
		if ( mEntry.getUsername().length() > 0 ) {
			// only show notification if username is available
			Notification username = getNotification(Intents.COPY_USERNAME, R.string.copy_username);
			mNM.notify(NOTIFY_USERNAME, username);
		}
			
		mIntentReceiver = new BroadcastReceiver() {
			
			@Override
			public void onReceive(Context context, Intent intent) {
				String action = intent.getAction();

				if ( action.equals(Intents.COPY_USERNAME) ) {
					String username = mEntry.getUsername();
					if ( username.length() > 0 ) {
						timeoutCopyToClipboard(username);
					}
				} else if ( action.equals(Intents.COPY_PASSWORD) ) {
					String password = new String(mEntry.getPassword());
					if ( password.length() > 0 ) {
						timeoutCopyToClipboard(new String(mEntry.getPassword()));
					}
				}
			}
		};
		
		IntentFilter filter = new IntentFilter();
		filter.addAction(Intents.COPY_USERNAME);
		filter.addAction(Intents.COPY_PASSWORD);
		registerReceiver(mIntentReceiver, filter);
	}
	
	@Override
	protected void onDestroy() {
		// These members might never get initialized if the app timed out
		if ( mIntentReceiver != null ) {
			unregisterReceiver(mIntentReceiver);
		}
		
		if ( mNM != null ) {
			mNM.cancelAll();
		}
		
		super.onDestroy();
	}

	private Notification getNotification(String intentText, int descResId) {
		String desc = getString(descResId);
		Notification notify = new Notification(R.drawable.notify, desc, System.currentTimeMillis());
		
		Intent intent = new Intent(intentText);
		PendingIntent pending = PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);
		
		notify.setLatestEventInfo(this, getString(R.string.app_name), desc, pending);
		
		return notify;
	}
	
	private void fillData() {
		ImageView iv = (ImageView) findViewById(R.id.entry_icon);
		App.getDB().drawFactory.assignDrawableTo(iv, getResources(), mEntry.getIcon());

		populateText(R.id.entry_title, mEntry.getTitle());
		populateText(R.id.entry_user_name, mEntry.getUsername());
		populateText(R.id.entry_url, mEntry.getUrl());
		populateText(R.id.entry_password, mEntry.getPassword());
		setPasswordStyle();
		
		DateFormat df = DateFormat.getInstance();
		populateText(R.id.entry_created, df.format(mEntry.getCreate()));
		populateText(R.id.entry_modified, df.format(mEntry.getMod()));
		populateText(R.id.entry_accessed, df.format(mEntry.getAccess()));
		
		Date expires = mEntry.getExpire();
		if ( PwEntryV3.IsNever(expires) ) {
			populateText(R.id.entry_expires, R.string.never);
		} else {
			populateText(R.id.entry_expires, df.format(expires));
		}
		populateText(R.id.entry_comment, mEntry.getNotes());

	}
	
	private void populateText(int viewId, int resId) {
		TextView tv = (TextView) findViewById(viewId);
		tv.setText(resId);
	}

	private void populateText(int viewId, String text) {
		TextView tv = (TextView) findViewById(viewId);
		tv.setText(text);
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		super.onActivityResult(requestCode, resultCode, data);
		if ( resultCode == KeePass.EXIT_REFRESH || resultCode == KeePass.EXIT_REFRESH_TITLE ) {
			fillData();
			if ( resultCode == KeePass.EXIT_REFRESH_TITLE ) {
				Intent ret = new Intent();
				ret.putExtra(KEY_REFRESH_POS, mPos);
				setResult(KeePass.EXIT_REFRESH, ret);
			}
		}
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		
		menu.add(0, MENU_DONATE, 0, R.string.menu_donate);
		menu.findItem(MENU_DONATE).setIcon(android.R.drawable.ic_menu_share);
		
		if ( mShowPassword ) {
			menu.add(0, MENU_PASS, 0, R.string.menu_hide_password);
		} else {
			menu.add(0, MENU_PASS, 0, R.string.show_password);
		}
		menu.findItem(MENU_PASS).setIcon(android.R.drawable.ic_menu_view);
		menu.add(0, MENU_GOTO_URL, 0, R.string.menu_url);
		menu.findItem(MENU_GOTO_URL).setIcon(android.R.drawable.ic_menu_upload);
		if ( mEntry.getUrl().length() == 0 ) {
			// disable button if url is not available
			menu.findItem(MENU_GOTO_URL).setEnabled(false);
		}
		menu.add(0, MENU_COPY_USER, 0, R.string.menu_copy_user);
		menu.findItem(MENU_COPY_USER).setIcon(android.R.drawable.ic_menu_set_as);
		if ( mEntry.getUsername().length() == 0 ) {
			// disable button if username is not available
			menu.findItem(MENU_COPY_USER).setEnabled(false);
		}
		menu.add(0, MENU_COPY_PASS, 0, R.string.menu_copy_pass);
		menu.findItem(MENU_COPY_PASS).setIcon(android.R.drawable.ic_menu_agenda);
		if ( mEntry.getPassword().length() == 0 ) {
			// disable button if password is not available
			menu.findItem(MENU_COPY_PASS).setEnabled(false);
		}
		menu.add(0, MENU_LOCK, 0, R.string.menu_lock);
		menu.findItem(MENU_LOCK).setIcon(android.R.drawable.ic_lock_lock);
		
		return true;
	}
	
	private void setPasswordStyle() {
		TextView password = (TextView) findViewById(R.id.entry_password);

		if ( mShowPassword ) {
			password.setTransformationMethod(null);
		} else {
			password.setTransformationMethod(PasswordTransformationMethod.getInstance());
		}
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch ( item.getItemId() ) {
		case MENU_DONATE:
			try {
				Util.gotoUrl(this, R.string.donate_url);
			} catch (ActivityNotFoundException e) {
				Toast.makeText(this, R.string.error_failed_to_launch_link, Toast.LENGTH_LONG).show();
				return false;
			}
			
			return true;
		case MENU_PASS:
			if ( mShowPassword ) {
				item.setTitle(R.string.show_password);
				mShowPassword = false;
			} else {
				item.setTitle(R.string.menu_hide_password);
				mShowPassword = true;
			}
			setPasswordStyle();

			return true;
			
		case MENU_GOTO_URL:
			String url;
			url = mEntry.getUrl();
			
			// Default http:// if no protocol specified
			if ( ! url.contains(""://"") ) {
				url = ""http://"" + url;
			}
			
			try {
				Util.gotoUrl(this, url);
			} catch (ActivityNotFoundException e) {
				Toast.makeText(this, R.string.no_url_handler, Toast.LENGTH_LONG).show();
			}
			return true;
			
		case MENU_COPY_USER:
			timeoutCopyToClipboard(mEntry.getUsername());
			return true;
			
		case MENU_COPY_PASS:
			timeoutCopyToClipboard(new String(mEntry.getPassword()));
			return true;
			
		case MENU_LOCK:
			App.setShutdown();
			setResult(KeePass.EXIT_LOCK);
			finish();
			return true;
		}
		
		return super.onOptionsItemSelected(item);
	}
	
	private void timeoutCopyToClipboard(String text) {
		Util.copyToClipboard(this, text);
		
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
		String sClipClear = prefs.getString(getString(R.string.clipboard_timeout_key), getString(R.string.clipboard_timeout_default));
		
		long clipClearTime = Long.parseLong(sClipClear);
		
		if ( clipClearTime > 0 ) {
			mTimer.schedule(new ClearClipboardTask(this, text), clipClearTime);
		}
	}
	

	// Setup to allow the toast to happen in the foreground
	final Handler uiThreadCallback = new Handler();

	// Task which clears the clipboard, and sends a toast to the foreground.
	private class ClearClipboardTask extends TimerTask {
		
		private final String mClearText;
		private final Context mCtx;
		
		ClearClipboardTask(Context ctx, String clearText) {
			mClearText = clearText;
			mCtx = ctx;
		}
		
		@Override
		public void run() {
			String currentClip = Util.getClipboard(mCtx);
			
			if ( currentClip.equals(mClearText) ) {
				Util.copyToClipboard(mCtx, """");
				uiThreadCallback.post(new UIToastTask(mCtx, R.string.ClearClipboard));
			}
		}
	}
}
",True,243,1,1,11,43,2,12,L8
17,com.keepassdroid.GroupActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.ContextMenu;
import android.view.MenuItem;
import android.view.View;
import android.view.ContextMenu.ContextMenuInfo;
import android.widget.Button;
import android.widget.AdapterView.AdapterContextMenuInfo;

import com.android.keepass.KeePass;
import com.android.keepass.R;
import com.keepassdroid.app.App;
import com.keepassdroid.database.PwDatabase;
import com.keepassdroid.database.PwDatabaseV3;
import com.keepassdroid.database.PwDatabaseV4;
import com.keepassdroid.database.PwGroup;
import com.keepassdroid.database.PwGroupId;
import com.keepassdroid.database.PwGroupV3;
import com.keepassdroid.database.PwGroupV4;
import com.keepassdroid.database.edit.AddGroup;
import com.keepassdroid.view.ClickView;
import com.keepassdroid.view.GroupAddEntryView;
import com.keepassdroid.view.GroupRootView;
import com.keepassdroid.view.GroupViewOnlyView;

public abstract class GroupActivity extends GroupBaseActivity {
	
	public static final int UNINIT = -1;
	
	protected boolean addGroupEnabled = false;
	protected boolean addEntryEnabled = false;
	
	private static final String TAG = ""Group Activity:"";
	
	public static void Launch(Activity act) {
		Launch(act, null);
	}
	
	public static void Launch(Activity act, PwGroup group) {
		Intent i;
		
		// Need to use PwDatabase since group may be null
		PwDatabase db = App.getDB().pm;
		if ( db instanceof PwDatabaseV3 ) {
			i = new Intent(act, GroupActivityV3.class);
		
			if ( group != null ) {
				PwGroupV3 g = (PwGroupV3) group;
				i.putExtra(KEY_ENTRY, g.groupId);
			}
		} else if ( db instanceof PwDatabaseV4 ) {
			i = new Intent(act, GroupActivityV4.class);
			
			if ( group != null ) {
				PwGroupV4 g = (PwGroupV4) group;
				i.putExtra(KEY_ENTRY, g.uuid.toString());
			}
		} else {
			// Reached if db is null
			Log.d(TAG, ""Tried to launch with null db"");
			return;
		}
		
		act.startActivityForResult(i,0);
	}
	
	protected abstract PwGroupId retrieveGroupId(Intent i);
	
	protected abstract void setupButtons();
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		
		if ( isFinishing() ) {
			return;
		}
		
		setResult(KeePass.EXIT_NORMAL);
		
		Log.w(TAG, ""Creating group view"");
		Intent intent = getIntent();
		
		PwGroupId id = retrieveGroupId(intent);
		
		Database db = App.getDB();
		if ( id == null ) {
			mGroup = db.root;
		} else {
			mGroup = db.groups.get(id);
		}
		
		Log.w(TAG, ""Retrieved group"");
		if ( mGroup == null ) {
			Log.w(TAG, ""Group was null"");
			return;
		}
		
		setupButtons();

		if ( addGroupEnabled && addEntryEnabled ) {
			setContentView(new GroupAddEntryView(this));
		} else if ( addGroupEnabled ) {
			setContentView(new GroupRootView(this));
		} else if ( addEntryEnabled ) {
			throw new RuntimeException(""This mode is not supported."");
		} else {
			setContentView(new GroupViewOnlyView(this));
		}
		Log.w(TAG, ""Set view"");

		if ( addGroupEnabled ) {
			// Add Group button
			Button addGroup = (Button) findViewById(R.id.add_group);
			addGroup.setOnClickListener(new View.OnClickListener() {

				public void onClick(View v) {
					GroupEditActivity.Launch(GroupActivity.this, mGroup);
				}
			});
		}
		
		if ( addEntryEnabled ) {
			// Add Entry button
			Button addEntry = (Button) findViewById(R.id.add_entry);
			addEntry.setOnClickListener(new View.OnClickListener() {
	
				public void onClick(View v) {
					EntryEditActivity.Launch(GroupActivity.this, mGroup);
				}
			});
		}
		
		setGroupTitle();
		setGroupIcon();

		setListAdapter(new PwListAdapter(this, mGroup));
		registerForContextMenu(getListView());
		Log.w(TAG, ""Finished creating group"");

	}

	@Override
	public void onCreateContextMenu(ContextMenu menu, View v,
			ContextMenuInfo menuInfo) {
		
		AdapterContextMenuInfo acmi = (AdapterContextMenuInfo) menuInfo;
		ClickView cv = (ClickView) acmi.targetView;
		cv.onCreateMenu(menu, menuInfo);
	}
	
	
	
	@Override
	public boolean onContextItemSelected(MenuItem item) {
		AdapterContextMenuInfo acmi = (AdapterContextMenuInfo) item.getMenuInfo();
		ClickView cv = (ClickView) acmi.targetView;
		
		return cv.onContextItemSelected(item);
	}
	
	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data)
	{
		switch (resultCode)
		{
			case Activity.RESULT_OK:
				String GroupName = data.getExtras().getString(GroupEditActivity.KEY_NAME);
				int GroupIconID = data.getExtras().getInt(GroupEditActivity.KEY_ICON_ID);
				GroupActivity act = GroupActivity.this;
				Handler handler = new Handler();
				AddGroup task = AddGroup.getInstance(App.getDB(), GroupName, GroupIconID, mGroup, act.new RefreshTask(handler), false);
				ProgressTask pt = new ProgressTask(act, task, R.string.saving_database);
				pt.run();
				break;

			case Activity.RESULT_CANCELED:
			default:
				break;
		}
	}
}
",True,244,1,2,11,44,5,19,L8
18,com.keepassdroid.PasswordActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import java.io.File;
import java.io.FileNotFoundException;
import java.net.URLDecoder;

import android.app.Activity;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.preference.PreferenceManager;
import android.text.method.PasswordTransformationMethod;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.TextView;
import android.widget.Toast;
import android.widget.CompoundButton.OnCheckedChangeListener;

import com.android.keepass.KeePass;
import com.android.keepass.R;
import com.keepassdroid.app.App;
import com.keepassdroid.compat.BackupManagerCompat;
import com.keepassdroid.database.edit.LoadDB;
import com.keepassdroid.database.edit.OnFinish;
import com.keepassdroid.fileselect.BrowserDialog;
import com.keepassdroid.fileselect.FileDbHelper;
import com.keepassdroid.intents.Intents;
import com.keepassdroid.settings.AppSettingsActivity;
import com.keepassdroid.utils.Interaction;
import com.keepassdroid.utils.Util;

public class PasswordActivity extends LockingActivity {

	private static final int MENU_ABOUT = Menu.FIRST;
	private static final int MENU_APP_SETTINGS = Menu.FIRST + 1;
	
	public static final String KEY_DEFAULT_FILENAME = ""defaultFileName"";
	private static final String KEY_FILENAME = ""fileName"";
	private static final String KEY_KEYFILE = ""keyFile"";
	private static final String VIEW_INTENT = ""android.intent.action.VIEW"";
	
	private static final int FILE_BROWSE = 256;

	private String mFileName;
	private String mKeyFile;
	private boolean mRememberKeyfile;
	SharedPreferences prefs;
	
	public static void Launch(Activity act, String fileName) throws FileNotFoundException {
		Launch(act,fileName,"""");
	}
	
	public static void Launch(Activity act, String fileName, String keyFile) throws FileNotFoundException {
		File dbFile = new File(fileName);
		if ( ! dbFile.exists() ) {
			throw new FileNotFoundException();
		}
		
		Intent i = new Intent(act, PasswordActivity.class);
		i.putExtra(KEY_FILENAME, fileName);
		i.putExtra(KEY_KEYFILE, keyFile);
		
		act.startActivityForResult(i, 0);
		
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		super.onActivityResult(requestCode, resultCode, data);
		
		switch (requestCode) {
		
		case KeePass.EXIT_LOCK:
			setResult(KeePass.EXIT_LOCK);
			finish();
			App.getDB().clear(); 
			break;
		case FILE_BROWSE:
			if (resultCode == RESULT_OK) {
				String filename = data.getDataString();
				if (filename != null) {
					if (filename.startsWith(""file://"")) {
						filename = filename.substring(7);
					}
					
					EditText fn = (EditText) findViewById(R.id.pass_keyfile);
					fn.setText(filename);
				}
			}
			break;
		}
		
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
	
		Intent i = getIntent();
		String action = i.getAction();
		
		if ( action != null && action.equals(VIEW_INTENT) ) {
			mFileName = i.getDataString();
			
			if ( ! mFileName.substring(0, 7).equals(""file://"") ) {
				Toast.makeText(this, R.string.error_can_not_handle_uri, Toast.LENGTH_LONG).show();
				finish();
				return;
			}
			
			mFileName = URLDecoder.decode(mFileName.substring(7, mFileName.length()));
						
			if ( mFileName.length() == 0 ) {
				// No file name
				Toast.makeText(this, R.string.FileNotFound, Toast.LENGTH_LONG).show();
				finish();
				return;
			}
			
			File dbFile = new File(mFileName);
			if ( ! dbFile.exists() ) {
				// File does not exist
				Toast.makeText(this, R.string.FileNotFound, Toast.LENGTH_LONG).show();
				finish();
				return;
			}
			
			mKeyFile = getKeyFile(mFileName);
			
		} else {
			mFileName = i.getStringExtra(KEY_FILENAME);
			mKeyFile = i.getStringExtra(KEY_KEYFILE);
		}
		
		prefs = PreferenceManager.getDefaultSharedPreferences(this);
		setContentView(R.layout.password);
		populateView();

		Button confirmButton = (Button) findViewById(R.id.pass_ok);
		confirmButton.setOnClickListener(new OkClickHandler());
		
		CheckBox checkBox = (CheckBox) findViewById(R.id.show_password);
		// Show or hide password
		checkBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			public void onCheckedChanged(CompoundButton buttonView,
					boolean isChecked) {
				TextView password = (TextView) findViewById(R.id.password);

				if ( isChecked ) {
					password.setTransformationMethod(null);
				} else {
					password.setTransformationMethod(PasswordTransformationMethod.getInstance());
				}
			}
			
		});
		
		CheckBox defaultCheck = (CheckBox) findViewById(R.id.default_database);
		defaultCheck.setOnCheckedChangeListener(new DefaultCheckChange());
		
		ImageButton browse = (ImageButton) findViewById(R.id.browse_button);
		browse.setOnClickListener(new View.OnClickListener() {
			
			public void onClick(View v) {
				if (Interaction.isIntentAvailable(PasswordActivity.this, Intents.FILE_BROWSE)) {
					Intent i = new Intent(Intents.FILE_BROWSE);
					
					if (mFileName.length() > 0) {
						File keyfile = new File(mFileName);
						File parent = keyfile.getParentFile();
						if (parent != null) {
							i.setData(Uri.parse(""file://"" + parent.getAbsolutePath()));
						}
					}
					
					startActivityForResult(i, FILE_BROWSE);
				} else {
					BrowserDialog diag = new BrowserDialog(PasswordActivity.this);
					diag.show();
				}
					
			}
		});
		
		retrieveSettings();
	}
	
	private void retrieveSettings() {
		mRememberKeyfile = prefs.getBoolean(getString(R.string.keyfile_key), getResources().getBoolean(R.bool.keyfile_default));
		
		String defaultFilename = prefs.getString(KEY_DEFAULT_FILENAME, """");
		if (mFileName.length() > 0 && mFileName.equals(defaultFilename)) {
			CheckBox checkbox = (CheckBox) findViewById(R.id.default_database);
			checkbox.setChecked(true);
			
			
		}
	}
	
	private String getKeyFile(String filename) {
		if ( mRememberKeyfile ) {
			FileDbHelper dbHelp = App.fileDbHelper;
			
			String keyfile = dbHelp.getFileByName(filename);
			
			return keyfile;
		} else {
			return """";
		}
	}
	
	private void populateView() {
		setEditText(R.id.filename, mFileName);
		
		setEditText(R.id.pass_keyfile, mKeyFile);
	}
	
	@Override
	protected void onResume() {
		super.onResume();
		
		// Clear password on Database state
		setEditText(R.id.password, """");
	}

	/*
	private void errorMessage(CharSequence text)
	{
		Toast.makeText(this, text, Toast.LENGTH_LONG).show();
	}
	*/
	
	private void errorMessage(int resId)
	{
		Toast.makeText(this, resId, Toast.LENGTH_LONG).show();
	}
	
	private class DefaultCheckChange implements CompoundButton.OnCheckedChangeListener {
		
		@Override
		public void onCheckedChanged(CompoundButton buttonView,
				boolean isChecked) {
			
			String newDefaultFileName;
			
			if (isChecked) {
				newDefaultFileName = mFileName;
			} else {
				newDefaultFileName = """";
			}
			
			SharedPreferences.Editor editor = prefs.edit();
			editor.putString(KEY_DEFAULT_FILENAME, newDefaultFileName);
			editor.commit();
			
			BackupManagerCompat backupManager = new BackupManagerCompat(PasswordActivity.this);
			backupManager.dataChanged();
			
		}
		
	}
	
	private class OkClickHandler implements View.OnClickListener {
		
		public void onClick(View view) {
			String pass = getEditText(R.id.password);
			String key = getEditText(R.id.pass_keyfile);
			if ( pass.length() == 0 && key.length() == 0 ) {
				errorMessage(R.string.error_nopass);
				return;
			}
			
			String fileName = getEditText(R.id.filename);
			
			
			// Clear before we load
			Database db = App.getDB();
			db.clear();
			
			// Clear the shutdown flag
			App.clearShutdown();
			
			Handler handler = new Handler();
			LoadDB task = new LoadDB(db, PasswordActivity.this, fileName, pass, key, new AfterLoad(handler));
			ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database);
			pt.run();
		}			
	}
	
	private String getEditText(int resId) {
		return Util.getEditText(this, resId);
	}
	
	private void setEditText(int resId, String str) {
		TextView te =  (TextView) findViewById(resId);
		assert(te == null);
		
		if (te != null) {
			te.setText(str);
		}
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		
		menu.add(0, MENU_APP_SETTINGS, 0, R.string.menu_app_settings);
		menu.findItem(MENU_APP_SETTINGS).setIcon(android.R.drawable.ic_menu_preferences);
		
		menu.add(0, MENU_ABOUT, 0, R.string.menu_about);
		menu.findItem(MENU_ABOUT).setIcon(android.R.drawable.ic_menu_help);
		
		return true;
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch ( item.getItemId() ) {
		case MENU_ABOUT:
			AboutDialog dialog = new AboutDialog(this);
			dialog.show();
			return true;
			
		case MENU_APP_SETTINGS:
			AppSettingsActivity.Launch(this);
			return true;
		}
		
		return super.onOptionsItemSelected(item);
	}

	private final class AfterLoad extends OnFinish {
		
		public AfterLoad(Handler handler) {
			super(handler);
		}

		@Override
		public void run() {
			if ( mSuccess ) {
				GroupActivity.Launch(PasswordActivity.this);
			} else {
				displayMessage(PasswordActivity.this);
			}
		}
	}
	
}
",True,242,0,0,11,43,1,16,L8
19,com.keepassdroid.SetPasswordDialog.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import com.android.keepass.R;
import com.keepassdroid.app.App;
import com.keepassdroid.database.edit.FileOnFinish;
import com.keepassdroid.database.edit.OnFinish;
import com.keepassdroid.database.edit.SetPassword;

public class SetPasswordDialog extends CancelDialog {

	private byte[] masterKey;
	private String mKeyfile;
	private FileOnFinish mFinish;
		
	public SetPasswordDialog(Context context) {
		super(context);
	}
	
	public SetPasswordDialog(Context context, FileOnFinish finish) {
		super(context);
		
		mFinish = finish;
	}
	
	public byte[] getKey() {
		return masterKey;
	}
	
	public String keyfile() {
		return mKeyfile;
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.set_password);
		
		setTitle(R.string.password_title);
		
		// Ok button
		Button okButton = (Button) findViewById(R.id.ok);
		okButton.setOnClickListener(new View.OnClickListener() {
			
			public void onClick(View v) {
				TextView passView = (TextView) findViewById(R.id.pass_password);
				String pass = passView.getText().toString();
				TextView passConfView = (TextView) findViewById(R.id.pass_conf_password);
				String confpass = passConfView.getText().toString();
				
				// Verify that passwords match
				if ( ! pass.equals(confpass) ) {
					// Passwords do not match
					Toast.makeText(getContext(), R.string.error_pass_match, Toast.LENGTH_LONG).show();
					return;
				}
				
				TextView keyfileView = (TextView) findViewById(R.id.pass_keyfile);
				String keyfile = keyfileView.getText().toString();
				mKeyfile = keyfile;
				
				// Verify that a password or keyfile is set
				if ( pass.length() == 0 && keyfile.length() == 0 ) {
					Toast.makeText(getContext(), R.string.error_nopass, Toast.LENGTH_LONG).show();
					return;
					
				}
				
				SetPassword sp = new SetPassword(App.getDB(), pass, keyfile, new AfterSave(mFinish, new Handler()));
				ProgressTask pt = new ProgressTask(getContext(), sp, R.string.saving_database);
				pt.run();
			}
			
		});
		
		// Cancel button
		Button cancel = (Button) findViewById(R.id.cancel);
		cancel.setOnClickListener(new View.OnClickListener() {
			
			public void onClick(View v) {
				cancel();
				if ( mFinish != null ) {
					mFinish.run();
				}
			}
		});
	}

	private class AfterSave extends OnFinish {
		private FileOnFinish mFinish;
		
		public AfterSave(FileOnFinish finish, Handler handler) {
			super(finish, handler);
			mFinish = finish;
		}

		@Override
		public void run() {
			if ( mSuccess ) {
				if ( mFinish != null ) {
					mFinish.setFilename(mKeyfile);
				}
				dismiss();
			} else {
				displayMessage(getContext());
			}
			
			super.run();
		}

	}

}
",True,222,4,11,12,43,2,6,L8
20,com.keepassdroid.LockingPreferenceActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import com.keepassdroid.app.App;
import com.keepassdroid.timers.Timeout;

import android.preference.PreferenceActivity;

public class LockingPreferenceActivity extends PreferenceActivity {

	@Override
	protected void onPause() {
		super.onPause();
		if ( App.getDB().Loaded() ) {
			Timeout.start(this);
		}
	}

	@Override
	protected void onResume() {
		super.onResume();

		if ( App.getDB().Loaded() ) {
			Timeout.cancel(this);
		}
	}
}
",False,218,6,11,11,43,1,3,L8
21,com.keepassdroid.UpdateStatus.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import android.app.ProgressDialog;
import android.content.Context;
import android.os.Handler;

public class UpdateStatus {
	private ProgressDialog mPD;
	private Context mCtx;
	private Handler mHandler;
	
	public UpdateStatus() {
		
	}
	
	public UpdateStatus(Context ctx, Handler handler, ProgressDialog pd) {
		mCtx = ctx;
		mPD = pd;
		mHandler = handler;
	}
	
	public void updateMessage(int resId) {
		if ( mCtx != null && mPD != null && mHandler != null ) {
			mHandler.post(new UpdateMessage(resId));
		}
	}
	
	private class UpdateMessage implements Runnable {
		private int mResId;
		
		public UpdateMessage(int resId) {
			mResId = resId;
		}
		
		public void run() {
			mPD.setMessage(mCtx.getString(mResId));
		}
		
	}
}
",False,71,4,42,0,0,6,0,L5
22,com.keepassdroid.AboutDialog.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import android.app.Dialog;
import android.content.Context;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;

import com.android.keepass.R;

public class AboutDialog extends Dialog {
	
	public AboutDialog(Context context) {
		super(context);
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.about);
		setTitle(R.string.app_name);
		
		Button okButton = (Button) findViewById(R.id.about_button);
		okButton.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
				dismiss();
			}
		});
	}

}
",False,26,5,12,0,0,2,0,L8
23,com.keepassdroid.GroupActivityV3.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import android.content.Intent;

import com.keepassdroid.app.App;
import com.keepassdroid.database.PwGroupIdV3;

public class GroupActivityV3 extends GroupActivity {

	@Override
	protected PwGroupIdV3 retrieveGroupId(Intent i) {
		int id = i.getIntExtra(KEY_ENTRY, -1);
		
		if ( id == -1 ) {
			return null;
		}
		
		return new PwGroupIdV3(id);
	}

	@Override
	protected void setupButtons() {
		if ( mGroup == App.getDB().root ) {
			addGroupEnabled = true;
		} else {
			addGroupEnabled = true;
			addEntryEnabled = true;
		}
	}

}
",False,243,0,0,11,43,0,5,L9
24,com.keepassdroid.EntryEditActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid;

import java.io.UnsupportedEncodingException;
import java.util.Calendar;
import java.util.Date;
import java.util.UUID;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.text.method.PasswordTransformationMethod;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.TextView;
import android.widget.Toast;

import com.android.keepass.KeePass;
import com.android.keepass.R;
import com.keepassdroid.app.App;
import com.keepassdroid.database.PwDate;
import com.keepassdroid.database.PwEntry;
import com.keepassdroid.database.PwEntryV3;
import com.keepassdroid.database.PwGroup;
import com.keepassdroid.database.PwGroupV3;
import com.keepassdroid.database.edit.AddEntry;
import com.keepassdroid.database.edit.OnFinish;
import com.keepassdroid.database.edit.RunnableOnFinish;
import com.keepassdroid.database.edit.UpdateEntry;
import com.keepassdroid.icons.Icons;
import com.keepassdroid.utils.Types;
import com.keepassdroid.utils.Util;

public class EntryEditActivity extends LockCloseActivity {
	public static final String KEY_ENTRY = ""entry"";
	public static final String KEY_PARENT = ""parent"";

	private static final int MENU_DONATE = Menu.FIRST;
	private static final int MENU_PASS = Menu.FIRST + 1;
	
	public static final int RESULT_OK_ICON_PICKER = 1000;
	public static final int RESULT_OK_PASSWORD_GENERATOR = RESULT_OK_ICON_PICKER + 1;

	private PwEntryV3 mEntry;
	private boolean mShowPassword = false;
	private boolean mIsNew;
	private int mSelectedIconID = -1;
	
	public static void Launch(Activity act, PwEntry pw) {
		if ( !(pw instanceof PwEntryV3) ) {
			throw new RuntimeException(""Not yet implemented."");
		}
		
		Intent i = new Intent(act, EntryEditActivity.class);
		
		i.putExtra(KEY_ENTRY, Types.UUIDtoBytes(pw.getUUID()));
		
		act.startActivityForResult(i, 0);
	}
	
	public static void Launch(Activity act, PwGroup pw) {
		if ( !(pw instanceof PwGroupV3) ) {
			throw new RuntimeException(""Not yet implemented."");
		}

		Intent i = new Intent(act, EntryEditActivity.class);
		
		PwGroupV3 parent = (PwGroupV3) pw;
		i.putExtra(KEY_PARENT, parent.groupId);
		
		act.startActivityForResult(i, 0);
	}
	
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.entry_edit);
		setResult(KeePass.EXIT_NORMAL);
		
		// Likely the app has been killed exit the activity
		Database db = App.getDB();
		if ( ! db.Loaded() ) {
			finish();
			return;
		}

		Intent i = getIntent();
		byte[] uuidBytes = i.getByteArrayExtra(KEY_ENTRY);

		if ( uuidBytes == null ) {
			int groupId = i.getIntExtra(KEY_PARENT, -1);

			mEntry = new PwEntryV3(db, groupId);
			mIsNew = true;
			
		} else {
			UUID uuid = Types.bytestoUUID(uuidBytes);
			assert(uuid != null);

			mEntry = (PwEntryV3) db.entries.get(uuid);
			mIsNew = false;
			
			fillData();
		} 
	
		View scrollView = findViewById(R.id.entry_scroll);
		scrollView.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);

		ImageButton iconButton = (ImageButton) findViewById(R.id.icon_button);
		iconButton.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
				IconPickerActivity.Launch(EntryEditActivity.this);
			}
		});

		// Generate password button
		Button generatePassword = (Button) findViewById(R.id.generate_button);
		generatePassword.setOnClickListener(new OnClickListener() {
			
			public void onClick(View v) {
				//EntryEditActivity.Launch(EntryActivity.this, mEntry);
				GeneratePasswordActivity.Launch(EntryEditActivity.this);
			}
		});
		

		
		// Save button
		Button save = (Button) findViewById(R.id.entry_save);
		save.setOnClickListener(new View.OnClickListener() {

			public void onClick(View v) {
				EntryEditActivity act = EntryEditActivity.this;
				
				// Require title
				String title = Util.getEditText(act, R.id.entry_title);
				if ( title.length() == 0 ) {
					Toast.makeText(act, R.string.error_title_required, Toast.LENGTH_LONG).show();
					return;
				}
				
				// Validate password
				String pass = Util.getEditText(act, R.id.entry_password);
				String conf = Util.getEditText(act, R.id.entry_confpassword);
				if ( ! pass.equals(conf) ) {
					Toast.makeText(act, R.string.error_pass_match, Toast.LENGTH_LONG).show();
					return;
				}
				
				PwEntryV3 newEntry = new PwEntryV3();
				
				newEntry.binaryDesc = mEntry.binaryDesc;
				newEntry.groupId = mEntry.groupId;

				if (mSelectedIconID == -1) {
					if (mIsNew) {
						newEntry.icon = App.getDB().pm.iconFactory.getIcon(0);
					} else {
						// Keep previous icon, if no new one was selected
						newEntry.icon = mEntry.icon;
					}
				}
				else {
					newEntry.icon = App.getDB().pm.iconFactory.getIcon(mSelectedIconID);
				}

				newEntry.parent = mEntry.parent;
				newEntry.tCreation = mEntry.tCreation;
				newEntry.tExpire = mEntry.tExpire;
				newEntry.setUUID(mEntry.getUUID());
				
				Date now = Calendar.getInstance().getTime(); 
				newEntry.tLastAccess = new PwDate(now);
				newEntry.tLastMod = new PwDate(now);
				
				byte[] binaryData = mEntry.getBinaryData();
				if ( binaryData != null ) {
					newEntry.setBinaryData(binaryData, 0, binaryData.length);
				}

				newEntry.title = Util.getEditText(act, R.id.entry_title);
				newEntry.url = Util.getEditText(act, R.id.entry_url);
				newEntry.username = Util.getEditText(act, R.id.entry_user_name);
				newEntry.additional = Util.getEditText(act, R.id.entry_comment);
				byte[] password;
				try {
					password = pass.getBytes(""UTF-8"");
				} catch (UnsupportedEncodingException e) {
					assert false;
					password = pass.getBytes();
				}
				newEntry.setPassword(password, 0, password.length);

				if ( newEntry.title.equals(mEntry.title) ) {
					setResult(KeePass.EXIT_REFRESH);
				} else {
					setResult(KeePass.EXIT_REFRESH_TITLE);
				}
				
				RunnableOnFinish task;
				OnFinish onFinish = act.new AfterSave(new Handler());
				
				if ( mIsNew ) {
					task = AddEntry.getInstance(App.getDB(), newEntry, onFinish);
				} else {
					task = new UpdateEntry(App.getDB(), mEntry, newEntry, onFinish);
				}
				ProgressTask pt = new ProgressTask(act, task, R.string.saving_database);
				pt.run();
			}
			
		});
		
		// Cancel button
		Button cancel = (Button) findViewById(R.id.entry_cancel);
		cancel.setOnClickListener(new View.OnClickListener() {

			public void onClick(View v) {
				finish();
				
			}
			
		});
		
	}
	
	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data)
	{
		switch (resultCode)
		{
			case RESULT_OK_ICON_PICKER:
				mSelectedIconID = data.getExtras().getInt(IconPickerActivity.KEY_ICON_ID);
				ImageButton currIconButton = (ImageButton) findViewById(R.id.icon_button);
				currIconButton.setImageResource(Icons.iconToResId(mSelectedIconID));
				break;
				
			case RESULT_OK_PASSWORD_GENERATOR:
				String generatedPassword = data.getStringExtra(""com.keepassdroid.password.generated_password"");
				EditText password = (EditText) findViewById(R.id.entry_password);
				EditText confPassword = (EditText) findViewById(R.id.entry_confpassword);
				
				password.setText(generatedPassword);
				confPassword.setText(generatedPassword);

				break;
			case Activity.RESULT_CANCELED:
			default:
				break;
		}
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		
		menu.add(0, MENU_DONATE, 0, R.string.menu_donate);
		menu.findItem(MENU_DONATE).setIcon(android.R.drawable.ic_menu_share);

		menu.add(0, MENU_PASS, 0, R.string.show_password);
		menu.findItem(MENU_PASS).setIcon(android.R.drawable.ic_menu_view);
		
		return true;
	}
	
	public boolean onOptionsItemSelected(MenuItem item) {
		switch ( item.getItemId() ) {
		case MENU_DONATE:
			try {
				Util.gotoUrl(this, R.string.donate_url);
			} catch (ActivityNotFoundException e) {
				Toast.makeText(this, R.string.error_failed_to_launch_link, Toast.LENGTH_LONG).show();
				return false;
			}
			
			return true;
		case MENU_PASS:
			if ( mShowPassword ) {
				item.setTitle(R.string.menu_hide_password);
				mShowPassword = false;
			} else {
				item.setTitle(R.string.show_password);
				mShowPassword = true;
			}
			setPasswordStyle();
			return true;
		}
		
		return super.onOptionsItemSelected(item);
	}
	
	private void setPasswordStyle() {
		TextView password = (TextView) findViewById(R.id.entry_password);
		TextView confpassword = (TextView) findViewById(R.id.entry_confpassword);

		if ( mShowPassword ) {
			password.setTransformationMethod(null);
			confpassword.setTransformationMethod(null);

		} else {
			PasswordTransformationMethod ptm = PasswordTransformationMethod.getInstance();
			password.setTransformationMethod(ptm);
			confpassword.setTransformationMethod(ptm);
		}
	}

	private void fillData() {
		ImageButton currIconButton = (ImageButton) findViewById(R.id.icon_button);
		App.getDB().drawFactory.assignDrawableTo(currIconButton, getResources(), mEntry.getIcon());
		
		populateText(R.id.entry_title, mEntry.title);
		populateText(R.id.entry_user_name, mEntry.getUsername());
		populateText(R.id.entry_url, mEntry.url);
		
		String password = new String(mEntry.getPassword());
		populateText(R.id.entry_password, password);
		populateText(R.id.entry_confpassword, password);
		setPasswordStyle();

		populateText(R.id.entry_comment, mEntry.additional);
	}

	private void populateText(int viewId, String text) {
		TextView tv = (TextView) findViewById(viewId);
		tv.setText(text);
	}
	
	private final class AfterSave extends OnFinish {

		public AfterSave(Handler handler) {
			super(handler);
		}

		@Override
		public void run() {
			if ( mSuccess ) {
				finish();
			} else {
				displayMessage(EntryEditActivity.this);
			}
		}
		
	}

}
",True,242,0,0,11,43,3,22,L8
25,com.keepassdroid.icons.DrawableFactory.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.icons;

import java.util.Map;
import java.util.UUID;
import java.util.WeakHashMap;

import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.Drawable;
import android.widget.ImageView;

import com.android.keepass.R;
import com.keepassdroid.compat.BitmapDrawableCompat;
import com.keepassdroid.database.PwIcon;
import com.keepassdroid.database.PwIconCustom;
import com.keepassdroid.database.PwIconStandard;

public class DrawableFactory {
	private static Drawable blank = null;
	private Map<UUID, Drawable> customIconMap = new WeakHashMap<UUID, Drawable>();
	private Map<Integer, Drawable> standardIconMap = new WeakHashMap<Integer, Drawable>();
	
	public void assignDrawableTo(ImageView iv, Resources res, PwIcon icon) {
		Drawable draw = getIconDrawable(res, icon);
		iv.setImageDrawable(draw);
	}
	
	private Drawable getIconDrawable(Resources res, PwIcon icon) {
		if (icon instanceof PwIconStandard) {
			return getIconDrawable(res, (PwIconStandard) icon);
		} else {
			return getIconDrawable(res, (PwIconCustom) icon);
		}
	}

	private void initBlank(Resources res) {
		if (blank==null) {
			blank = res.getDrawable(R.drawable.ic99_blank);
		}
	}
	
	public Drawable getIconDrawable(Resources res, PwIconStandard icon) {
		int resId = Icons.iconToResId(icon.iconId);
		
		Drawable draw = standardIconMap.get(resId);
		if (draw == null) {
			draw = res.getDrawable(resId);
			standardIconMap.put(resId, draw);
		}
		
		return draw;
	}

	public Drawable getIconDrawable(Resources res, PwIconCustom icon) {
		initBlank(res);
		if (icon == null) {
			return blank;
		}
		
		Drawable draw = customIconMap.get(icon.uuid);
		
		if (draw == null) {
			if (icon.imageData == null) {
				return blank;
			}
			
			Bitmap bitmap = BitmapFactory.decodeByteArray(icon.imageData, 0, icon.imageData.length);
			
			// Could not understand custom icon
			if (bitmap == null) {
				return blank;
			}
			
			draw = BitmapDrawableCompat.getBitmapDrawable(res, bitmap);
			customIconMap.put(icon.uuid, draw);
		}
		
		return draw;
	}
	
	public void clear() {
		standardIconMap.clear();
		customIconMap.clear();
	}
	
}
",False,94,5,36,6,11,6,5,L6
26,com.keepassdroid.icons.Icons.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.icons;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

import com.android.keepass.R;


public class Icons {
	private static Map<Integer, Integer> icons = null;
	
	private static void buildList() {
		if (icons == null) {
			icons = new HashMap<Integer, Integer>();
			
			Class<com.android.keepass.R.drawable> c = com.android.keepass.R.drawable.class;
			
			Field[] fields = c.getFields();
			
			for (int i = 0; i < fields.length; i++) {
				String fieldName = fields[i].getName();
				if (fieldName.matches(""ic\\d{2}.*"")) {
					String sNum = fieldName.substring(2, 4);
					int num = Integer.parseInt(sNum);
					if (num > 69) {
						continue;
					}
					
					int resId;
					try {
						resId = fields[i].getInt(null);
					} catch (Exception e) {
						continue;
					}
					
					icons.put(num, resId);
				}
			}
		}	
	}
	
	public static int iconToResId(int iconId) {
		buildList();
		
		Integer resId = icons.get(iconId);
		
		if (resId == null) {
			return R.drawable.ic99_blank;
		}
		
		return resId;
	}
	
	public static int count() {
		buildList();
		
		return icons.size();
	}

}
",True,67,6,33,0,0,4,0,L6
27,com.keepassdroid.view.GroupAddEntryView.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.view;

import android.content.Context;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.widget.RelativeLayout;

import com.android.keepass.R;

public class GroupAddEntryView extends RelativeLayout {

	public GroupAddEntryView(Context context) {
		super(context);
		
		inflate(context);
	}
	
	public GroupAddEntryView(Context context, AttributeSet attrs) {
		super(context, attrs);
		
		inflate(context);
	}
	
	private void inflate(Context context) {
		LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		inflater.inflate(R.layout.group_add_entry, this);
		
	}


}
",False,26,6,8,0,0,1,0,L8
28,com.keepassdroid.view.FileNameView.java,"package com.keepassdroid.view;

import android.content.Context;
import android.os.Environment;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.android.keepass.R;

public class FileNameView extends RelativeLayout {

	public FileNameView(Context context) {
		super(context);
		
		inflate(context);
	}

	public FileNameView(Context context, AttributeSet attrs) {
		super(context, attrs);
		
		inflate(context);
	}
	

	
	private void inflate(Context context) {
		LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		inflater.inflate(R.layout.file_selection_filename, this);
	}
	
	public void updateExternalStorageWarning() {
		int warning = -1;
		String state = Environment.getExternalStorageState();
		if (state.equals(Environment.MEDIA_MOUNTED_READ_ONLY)) {
			warning = R.string.warning_read_only;
		} else if (!state.equals(Environment.MEDIA_MOUNTED)) {
			warning = R.string.warning_unmounted;
		}
		
		TextView tv = (TextView) findViewById(R.id.label_warning);
		TextView label = (TextView) findViewById(R.id.label_open_by_filename);
		RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
		
		if (warning != -1) {
			tv.setText(warning);
			tv.setVisibility(VISIBLE);
			
			lp.addRule(RelativeLayout.BELOW, R.id.label_warning);
		} else {
			tv.setVisibility(INVISIBLE);
		}
		
		label.setLayoutParams(lp);
	}
}
",False,26,5,12,0,0,1,0,L8
29,com.keepassdroid.view.GroupHeaderView.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.view;

import android.content.Context;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.widget.RelativeLayout;

import com.android.keepass.R;

public class GroupHeaderView extends RelativeLayout {

	public GroupHeaderView(Context context) {
		super(context);
		
		inflate(context);
	}
	
	public GroupHeaderView(Context context, AttributeSet attrs) {
		super(context, attrs);
		
		inflate(context);
	}
	
	private void inflate(Context context) {
		LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		inflater.inflate(R.layout.group_header, this);
		
	}


}
",False,1,0,0,0,0,0,0,I0
30,com.keepassdroid.view.GroupEmptyView.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.view;

import android.content.Context;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.widget.RelativeLayout;

import com.android.keepass.R;

public class GroupEmptyView extends RelativeLayout {

	public GroupEmptyView(Context context) {
		super(context);
		
		inflate(context);
	}
	
	public GroupEmptyView(Context context, AttributeSet attrs) {
		super(context, attrs);
		
		inflate(context);
	}
	
	private void inflate(Context context) {
		LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		inflater.inflate(R.layout.group_empty, this);
		
	}


}
",False,2,1,1,0,0,1,0,L9
31,com.keepassdroid.view.GroupViewOnlyView.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.view;

import android.content.Context;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.RelativeLayout;

import com.android.keepass.R;

public class GroupViewOnlyView extends RelativeLayout {

	public GroupViewOnlyView(Context context) {
		super(context);
		
		inflate(context);
	}
	
	public GroupViewOnlyView(Context context, AttributeSet attrs) {
		super(context, attrs);
		
		inflate(context);
	}
	
	private void inflate(Context context) {
		LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		inflater.inflate(R.layout.group_add_entry, this);

		// Hide the buttons
		View addGroup = findViewById(R.id.add_group);
		addGroup.setVisibility(INVISIBLE);
		
		View addEntry = findViewById(R.id.add_entry);
		addEntry.setVisibility(INVISIBLE);
		
		View divider2 = findViewById(R.id.divider2);
		divider2.setVisibility(INVISIBLE);
		
		View list = findViewById(android.R.id.list);
		LayoutParams lp = (RelativeLayout.LayoutParams) list.getLayoutParams();
		lp.addRule(ALIGN_PARENT_BOTTOM, TRUE);
		
		
	}


}
",False,26,5,10,0,0,3,0,L8
32,com.keepassdroid.view.ClickView.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.view;

import android.content.Context;
import android.view.ContextMenu;
import android.view.MenuItem;
import android.view.ContextMenu.ContextMenuInfo;
import android.widget.LinearLayout;

public abstract class ClickView extends LinearLayout {

	public ClickView(Context context) {
		super(context);
	}
	
	abstract public void onClick();
	
	abstract public void onCreateMenu(ContextMenu menu, ContextMenuInfo menuInfo);
	
	abstract public boolean onContextItemSelected(MenuItem item);
}
",False,26,5,9,0,0,4,0,L8
33,com.keepassdroid.view.PwGroupViewV3.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.view;

import android.os.Handler;
import android.view.ContextMenu;
import android.view.MenuItem;
import android.view.ContextMenu.ContextMenuInfo;

import com.android.keepass.R;
import com.keepassdroid.GroupBaseActivity;
import com.keepassdroid.ProgressTask;
import com.keepassdroid.app.App;
import com.keepassdroid.database.PwGroup;
import com.keepassdroid.database.edit.DeleteGroup;

public class PwGroupViewV3 extends PwGroupView {

	private static final int MENU_DELETE = MENU_OPEN + 1;

	protected PwGroupViewV3(GroupBaseActivity act, PwGroup pw) {
		super(act, pw);
	}

	@Override
	public void onCreateMenu(ContextMenu menu, ContextMenuInfo menuInfo) {
		super.onCreateMenu(menu, menuInfo);
		
		menu.add(0, MENU_DELETE, 0, R.string.menu_delete);

	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		if ( ! super.onContextItemSelected(item) ) {
			switch ( item.getItemId() ) {
			case MENU_DELETE:
				Handler handler = new Handler();
				DeleteGroup task = new DeleteGroup(App.getDB(), mPw, mAct, mAct.new AfterDeleteGroup(handler));
				ProgressTask pt = new ProgressTask(mAct, task, R.string.saving_database);
				pt.run();
				return true;
			}

		}
		
		return false;
	}

}
",True,242,0,0,12,43,1,6,L8
34,com.keepassdroid.view.PwEntryViewV3.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.view;

import android.os.Handler;
import android.view.ContextMenu;
import android.view.MenuItem;
import android.view.ContextMenu.ContextMenuInfo;

import com.android.keepass.R;
import com.keepassdroid.GroupBaseActivity;
import com.keepassdroid.ProgressTask;
import com.keepassdroid.app.App;
import com.keepassdroid.database.PwEntry;
import com.keepassdroid.database.edit.DeleteEntry;

public class PwEntryViewV3 extends PwEntryView {

	private static final int MENU_DELETE = MENU_OPEN + 1;

	protected PwEntryViewV3(GroupBaseActivity act, PwEntry pw, int pos) {
		super(act, pw, pos);
	}
	
	private void deleteEntry() {
		Handler handler = new Handler();
		DeleteEntry task = new DeleteEntry(App.getDB(), mPw, mAct.new RefreshTask(handler));
		ProgressTask pt = new ProgressTask(mAct, task, R.string.saving_database);
		pt.run();
		
	}

	@Override
	public void onCreateMenu(ContextMenu menu, ContextMenuInfo menuInfo) {
		super.onCreateMenu(menu, menuInfo);
		
		menu.add(0, MENU_DELETE, 0, R.string.menu_delete);

	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		if ( ! super.onContextItemSelected(item) ) {
			switch ( item.getItemId() ) {
			case MENU_DELETE:
				deleteEntry();
				return true;
			}
			
		}
		
		return false;
	}



}
",True,242,0,0,12,43,1,6,L8
35,com.keepassdroid.view.PwEntryView.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.view;


import android.view.ContextMenu;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ContextMenu.ContextMenuInfo;
import android.widget.ImageView;
import android.widget.TextView;

import com.android.keepass.R;
import com.keepassdroid.EntryActivity;
import com.keepassdroid.GroupBaseActivity;
import com.keepassdroid.app.App;
import com.keepassdroid.database.PwEntry;
import com.keepassdroid.database.PwEntryV3;
import com.keepassdroid.settings.PrefsUtil;

public class PwEntryView extends ClickView {

	protected GroupBaseActivity mAct;
	protected PwEntry mPw;
	private TextView mTv;
	private int mPos;
	
	protected static final int MENU_OPEN = Menu.FIRST;
	
	public static PwEntryView getInstance(GroupBaseActivity act, PwEntry pw, int pos) {
		if ( pw instanceof PwEntryV3 ) {
			return new PwEntryViewV3(act, (PwEntryV3) pw, pos);
		} else {
			return new PwEntryView(act, pw, pos);
		}
	}
	
	protected PwEntryView(GroupBaseActivity act, PwEntry pw, int pos) {
		super(act);
		mAct = act;
		mPw = pw;
		mPos = pos;
		
		View ev = View.inflate(mAct, R.layout.entry_list_entry, null);
		
		ImageView iv = (ImageView) ev.findViewById(R.id.entry_icon);
		App.getDB().drawFactory.assignDrawableTo(iv, getResources(), pw.getIcon());
		
		TextView tv = (TextView) ev.findViewById(R.id.entry_text);
		tv.setText(mPw.getDisplayTitle());
		tv.setTextSize(PrefsUtil.getListTextSize(act));
		
		mTv = tv;
		
		LayoutParams lp = new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
		
		addView(ev, lp);

	}
	
	public void refreshTitle() {
		mTv.setText(mPw.getDisplayTitle());
	}
	
	public void onClick() {
		launchEntry();
	}
		
	private void launchEntry() {
		EntryActivity.Launch(mAct, mPw, mPos);
		
	}
	
	@Override
	public void onCreateMenu(ContextMenu menu, ContextMenuInfo menuInfo) {
		menu.add(0, MENU_OPEN, 0, R.string.menu_open);
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		switch ( item.getItemId() ) {
		
		case MENU_OPEN:
			launchEntry();
			return true;
			
		default:
			return false;
		}
	}
	
	
}
",False,242,0,0,11,43,2,10,L8
36,com.keepassdroid.view.PwGroupView.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.view;


import android.view.ContextMenu;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ContextMenu.ContextMenuInfo;
import android.widget.ImageView;
import android.widget.TextView;

import com.android.keepass.R;
import com.keepassdroid.GroupActivity;
import com.keepassdroid.GroupBaseActivity;
import com.keepassdroid.app.App;
import com.keepassdroid.database.PwGroup;
import com.keepassdroid.database.PwGroupV3;
import com.keepassdroid.settings.PrefsUtil;


public class PwGroupView extends ClickView {
	
	protected PwGroup mPw;
	protected GroupBaseActivity mAct;

	protected static final int MENU_OPEN = Menu.FIRST;
	
	public static PwGroupView getInstance(GroupBaseActivity act, PwGroup pw) {
		if ( pw instanceof PwGroupV3 ) {
			return new PwGroupViewV3(act, pw);
		} else {
			return new PwGroupView(act, pw);
		}
	}
	
	protected PwGroupView(GroupBaseActivity act, PwGroup pw) {
		super(act);
		mAct = act;
		mPw = pw;
		
		View gv = View.inflate(act, R.layout.group_list_entry, null);
		
		ImageView iv = (ImageView) gv.findViewById(R.id.group_icon);
		App.getDB().drawFactory.assignDrawableTo(iv, getResources(), pw.getIcon());
		
		TextView tv = (TextView) gv.findViewById(R.id.group_text);
		tv.setText(pw.getName());
		float size = PrefsUtil.getListTextSize(act); 
		tv.setTextSize(size);
		
		TextView label = (TextView) gv.findViewById(R.id.group_label);
		label.setTextSize(size-8);
		
		LayoutParams lp = new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
		
		addView(gv, lp);
		
	}

	public void onClick() {
		launchGroup();
	}
	
	private void launchGroup() {
		GroupActivity.Launch(mAct, mPw);
	}

	@Override
	public void onCreateMenu(ContextMenu menu, ContextMenuInfo menuInfo) {
		menu.add(0, MENU_OPEN, 0, R.string.menu_open);
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		switch ( item.getItemId() ) {
			
		case MENU_OPEN:
			launchGroup();
			return true;
		
		default:
			return false;
		}
	}

}",False,242,0,0,11,43,2,10,L8
37,com.keepassdroid.view.GroupRootView.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.view;

import android.content.Context;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.widget.Button;
import android.widget.RelativeLayout;

import com.android.keepass.R;

public class GroupRootView extends RelativeLayout {

	public GroupRootView(Context context) {
		super(context);
		
		inflate(context);
	}
	
	public GroupRootView(Context context, AttributeSet attrs) {
		super(context, attrs);
		
		inflate(context);
	}
	
	private void inflate(Context context) {
		LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		inflater.inflate(R.layout.group_add_entry, this);
		
		Button addEntry = (Button) findViewById(R.id.add_entry);
		addEntry.setVisibility(INVISIBLE);
		
	}


}
",False,26,6,8,0,0,1,0,L8
38,com.keepassdroid.backup.SettingsBackupAgent.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.backup;

import android.app.backup.BackupAgentHelper;
import android.app.backup.SharedPreferencesBackupHelper;

public class SettingsBackupAgent extends BackupAgentHelper {
	
	private static final String PREFS_BACKUP_KEY = ""prefs"";
	
	@Override
	public void onCreate() {
		String defaultPrefs = this.getPackageName() + ""_preferences"";
		
		SharedPreferencesBackupHelper prefHelper = new SharedPreferencesBackupHelper(this, defaultPrefs);
		addHelper(PREFS_BACKUP_KEY, prefHelper);
	}

}
",False,1,0,0,0,0,0,0,I0
39,com.keepassdroid.compat.BackupManagerCompat.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.compat;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

import android.content.Context;


public class BackupManagerCompat {
	@SuppressWarnings(""unchecked"")
	private static Class classBackupManager;
	@SuppressWarnings(""unchecked"")
	private static Constructor constructorBackupManager;
	private static Method dataChanged;
	
	private Object backupManager;
	
	static {
		try {
			classBackupManager = Class.forName(""android.app.backup.BackupManager"");
			constructorBackupManager = classBackupManager.getConstructor(Context.class);
			dataChanged = classBackupManager.getMethod(""dataChanged"", (Class[]) null);
		} catch (Exception e) {
			// Do nothing, class does not exist
		}
	}
	
	public BackupManagerCompat(Context ctx) {
		if (constructorBackupManager != null) {
			try {
				backupManager = constructorBackupManager.newInstance(ctx);
			} catch (Exception e) {
				// Do nothing
			}
		}
	}
	
	public void dataChanged() {
		if (backupManager != null && dataChanged != null) {
			try {
				dataChanged.invoke(backupManager, (Object[]) null);
			} catch (Exception e) {
				// Do nothing
			}
		}
	}

}
",True,26,5,11,0,0,2,0,L8
40,com.keepassdroid.compat.BitmapDrawableCompat.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.compat;

import java.lang.reflect.Constructor;

import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;

// This compatiblity hack can go away when support for Android 1.5 api level 3 is dropped
public class BitmapDrawableCompat {
	private static Constructor<BitmapDrawable> constResBitmap;
	
	static {
		try {
			constResBitmap = BitmapDrawable.class.getConstructor(Resources.class, Bitmap.class);
			// This constructor is support in this api version
		} catch (Exception e) {
			// This constructor is not supported
		}
	}
	
	public static BitmapDrawable getBitmapDrawable(Resources res, Bitmap bitmap) {
		if (constResBitmap != null) {
			try {
				return constResBitmap.newInstance(res, bitmap);
			} catch (Exception e) {
				// Do nothing, fall through to the safe constructor
			}
		}
		
		return new BitmapDrawable(bitmap);
	}

}
",True,67,6,36,0,0,1,0,L6
41,com.keepassdroid.search.SearchResults.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.search;

import android.app.SearchManager;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;

import com.android.keepass.KeePass;
import com.android.keepass.R;
import com.keepassdroid.Database;
import com.keepassdroid.GroupBaseActivity;
import com.keepassdroid.ProgressTask;
import com.keepassdroid.PwListAdapter;
import com.keepassdroid.app.App;
import com.keepassdroid.database.edit.BuildIndex;
import com.keepassdroid.database.edit.OnFinish;
import com.keepassdroid.view.GroupEmptyView;
import com.keepassdroid.view.GroupViewOnlyView;

public class SearchResults extends GroupBaseActivity {
	
	private Database mDb;
	//private String mQuery;
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		
		if ( isFinishing() ) {
			return;
		}
		
		setResult(KeePass.EXIT_NORMAL);
		
		mDb = App.getDB();
		
		// Likely the app has been killed exit the activity 
		if ( ! mDb.Loaded() ) {
			finish();
		}

		performSearch(getSearchStr(getIntent()));
		
	}
	
	private void performSearch(String query) {
		if ( mDb.indexBuilt ) {
			query(query);
		} else {
			PerformSearch task = new PerformSearch(query, new Handler());
			ProgressTask pt = new ProgressTask(this, new BuildIndex(mDb, this, task), R.string.building_search_idx);
			pt.run();
			
		}
		
	}
	
	private void query(String query) {
		mGroup = mDb.Search(query);

		if ( mGroup == null || mGroup.childEntries.size() < 1 ) {
			setContentView(new GroupEmptyView(this));
		} else {
			setContentView(new GroupViewOnlyView(this));
		}
		
		setGroupTitle();
		
		setListAdapter(new PwListAdapter(this, mGroup));
	}
	
	/*
	@Override
	protected void onNewIntent(Intent intent) {
		super.onNewIntent(intent);
		
		mQuery = getSearchStr(intent);
		performSearch();
		//mGroup = processSearchIntent(intent);
		//assert(mGroup != null);
	}
	*/

	private String getSearchStr(Intent queryIntent) {
        // get and process search query here
        final String queryAction = queryIntent.getAction();
        if ( Intent.ACTION_SEARCH.equals(queryAction) ) {
        	return queryIntent.getStringExtra(SearchManager.QUERY);
        }
        
        return """";
		
	}
	
	/*
	private PwGroupV3 processSearchIntent(Intent queryIntent) {
        // get and process search query here
        final String queryAction = queryIntent.getAction();
        if ( Intent.ACTION_SEARCH.equals(queryAction) ) {
        	final String queryString = queryIntent.getStringExtra(SearchManager.QUERY);
        
			return mDb.Search(queryString);
        }
        
        return null;
		
	}
	*/
	
	private class PerformSearch extends OnFinish {
		
		private String mQuery;
		
		public PerformSearch(String query, Handler handler) {
			super(handler);
			
			mQuery = query;
		}
		
		@Override
		public void run() {
			query(mQuery);
		}
		
	}
}
",True,245,0,0,11,43,0,11,L9
42,com.keepassdroid.search.SearchDbHelper.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.search;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

import com.keepassdroid.Database;
import com.keepassdroid.database.PwDatabaseV3;
import com.keepassdroid.database.PwDatabaseV4;
import com.keepassdroid.database.PwEntry;
import com.keepassdroid.database.PwGroup;
import com.keepassdroid.database.PwGroupV3;
import com.keepassdroid.database.PwGroupV4;

public class SearchDbHelper {
	private static final String DATABASE_NAME = ""search"";
	private static final String SEARCH_TABLE = ""entries"";
	private static final int DATABASE_VERSION = 1;
	
	private static final String KEY_UUID = ""uuid"";
	private static final String KEY_TITLE = ""title"";
	private static final String KEY_URL = ""url"";
	private static final String KEY_COMMENT = ""comment"";

	private static final String DATABASE_CREATE = 
		""create virtual table "" + SEARCH_TABLE + "" using FTS3( "" 
		+ KEY_UUID + "", ""
		+ KEY_TITLE + "", "" 
		+ KEY_URL + "", ""
		+ KEY_COMMENT + "");"";
	
	private static final String PRAGMA_NO_SYNCHRONOUS = ""pragma synchronous = off;"";
	
	private final Context mCtx;
	private DatabaseHelper mDbHelper;
	private SQLiteDatabase mDb;
	
	private static class DatabaseHelper extends SQLiteOpenHelper {
		
		DatabaseHelper(Context ctx) {
			super(ctx, DATABASE_NAME, null, DATABASE_VERSION);
		}

		@Override
		public void onCreate(SQLiteDatabase db) {
			db.execSQL(DATABASE_CREATE);
		}

		@Override
		public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
			// Only one database version so far
		}
		
	}
	
	public SearchDbHelper(Context ctx) {
		mCtx = ctx;
	}
	
	public SearchDbHelper open() throws SQLException {
		mDbHelper = new DatabaseHelper(mCtx);
		mDb = mDbHelper.getWritableDatabase();
		mDb.execSQL(PRAGMA_NO_SYNCHRONOUS);
		return this;
	}
	
	public void close() {
		mDb.close();
	}

	public void clear() {
		mDb.delete(SEARCH_TABLE, null, null);
	}

	private ContentValues buildNewEntryContent(PwEntry entry) {

		ContentValues cv = new ContentValues();
		UUID uuid = entry.getUUID();
		String uuidStr = uuid.toString();
		
		cv.put(KEY_UUID, uuidStr);
		cv.put(KEY_TITLE, entry.getTitle());
		cv.put(KEY_URL, entry.getUrl());
		cv.put(KEY_COMMENT, entry.getNotes());
		
		return cv;
	}
	
	public void insertEntry(PwEntry entry) {
		ContentValues cv = buildNewEntryContent(entry);
		mDb.insert(SEARCH_TABLE, null, cv);
	}
	
	public void insertEntry(List<? extends PwEntry> entries) {
		mDb.beginTransaction();

		try {
			for (int i=0; i < entries.size(); i++) {
				insertEntry(entries.get(i));
			}
			mDb.setTransactionSuccessful();
		} finally {
			mDb.endTransaction();
		}
	}
	
	public void updateEntry(PwEntry entry) {
		ContentValues cv = buildNewEntryContent(entry);
		String uuidStr = cv.getAsString(KEY_UUID);
		
		mDb.update(SEARCH_TABLE, cv, KEY_UUID + "" = ?"", new String[] {uuidStr});
	}
	
	public void deleteEntry(PwEntry entry) {
		UUID uuid = entry.getUUID();
		String uuidStr = uuid.toString();
		
		mDb.delete(SEARCH_TABLE, KEY_UUID + "" = ?"", new String[] {uuidStr});
	}
	
	public PwGroup search(Database db, String qStr) {
		Cursor cursor;
		String queryWithWildCard = addWildCard(qStr);
		cursor = mDb.query(true, SEARCH_TABLE, new String[] {KEY_UUID}, SEARCH_TABLE + "" match ?"", new String[] {queryWithWildCard}, null, null, null, null);

		PwGroup group;
		if ( db.pm instanceof PwDatabaseV3 ) {
			group = new PwGroupV3();
		} else if ( db.pm instanceof PwDatabaseV4 ) {
			group = new PwGroupV4();
		} else {
			Log.d(""SearchDbHelper"", ""Tried to search with unknown db"");
			return null;
		}
		group.name = ""Search results"";
		group.childEntries = new ArrayList<PwEntry>();
		
		cursor.moveToFirst();
		while ( ! cursor.isAfterLast() ) {
			String sUUID = cursor.getString(0);
			UUID uuid = UUID.fromString(sUUID);
			Log.d(""TAG"", uuid.toString()); 
			PwEntry entry = (PwEntry) db.entries.get(uuid);
			group.childEntries.add(entry);
			
			cursor.moveToNext();
		}
		
		cursor.close();
		
		return group;
	}

	private String addWildCard(String qStr) {
		String result = new String(qStr);
		if (qStr.endsWith(""\"""") || qStr.endsWith(""*"")) {
			// Do Nothing
		}
		else if (qStr.endsWith(""%"")){
			result = result.substring(0, result.length()-1);
		}
		result = result + ""*"";
		return result;
	}
	
}
",False,217,8,5,11,43,5,7,L6
43,com.keepassdroid.utils.Util.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.utils;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.text.ClipboardManager;
import android.widget.TextView;

public class Util {
	public static String getClipboard(Context context) {
		ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
		return clipboard.getText().toString();
	}
	
	public static void copyToClipboard(Context context, String text) {
		ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
		clipboard.setText(text);
	}
	
	public static void gotoUrl(Context context, String url) throws ActivityNotFoundException {
		if ( url != null && url.length() > 0 ) {
			Uri uri = Uri.parse(url);
			context.startActivity(new Intent(Intent.ACTION_VIEW, uri));
		}
	}
	
	public static void gotoUrl(Context context, int resId) throws ActivityNotFoundException {
		gotoUrl(context, context.getString(resId));
	}

	public static String getEditText(Activity act, int resId) {
		TextView te =  (TextView) act.findViewById(resId);
		assert(te == null);
		
		if (te != null) {
			return te.getText().toString();
		} else {
			return """";
		}
	}
	
	public static void setEditText(Activity act, int resId, String str) {
		TextView te =  (TextView) act.findViewById(resId);
		assert(te == null);
		
		if (te != null) {
			te.setText(str);
		}
	}

	
	
}
",False,27,4,15,0,0,6,0,L8
44,com.keepassdroid.utils.Interaction.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.utils;

import java.util.List;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;

public class Interaction {
	/**
	 * Indicates whether the specified action can be used as an intent. This
	 * method queries the package manager for installed packages that can
	 * respond to an intent with the specified action. If no suitable package is
	 * found, this method returns false.
	 *
	 * @param context The application's environment.
	 * @param action The Intent action to check for availability.
	 *
	 * @return True if an Intent with the specified action can be sent and
	 *         responded to, false otherwise.
	 */
	public static boolean isIntentAvailable(Context context, String action) {
	    final PackageManager packageManager = context.getPackageManager();
	    final Intent intent = new Intent(action);
	    List<ResolveInfo> list =
	            packageManager.queryIntentActivities(intent,
	                    PackageManager.MATCH_DEFAULT_ONLY);
	    return list.size() > 0;
	}
}
",False,26,5,12,0,0,2,0,L8
45,com.keepassdroid.utils.Types.java,"/*
KeePass for J2ME

Copyright 2007 Naomaru Itoi <nao@phoneid.org>

This file was derived from 

Java clone of KeePass - A KeePass file viewer for Java
Copyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

package com.keepassdroid.utils;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.UUID;

import com.keepassdroid.stream.LEDataOutputStream;


/**
 * Tools for slicing and dicing Java and KeePass data types.
 * 
 * @author Bill Zwicky <wrzwicky@pobox.com>
 */
public class Types {
	
	public static byte[] writeInt(int val) {
	  byte[] buf = new byte[4];
	  LEDataOutputStream.writeInt(val, buf, 0);

	  return buf;
  }

  /**
   * Read an unsigned 16-bit value.
   * 
   * @param buf
   * @param offset
   * @return
   */
  public static int readShort( byte[] buf, int offset ) {
    return (buf[offset + 0] & 0xFF) + ((buf[offset + 1] & 0xFF) << 8);
  }
  
  public static int readShort(InputStream is) throws IOException {
	  byte[] buf = new byte[2];
	  
	  is.read(buf, 0, 2);
	  
	  return readShort(buf, 0); 
  }
  
  /** Write an unsigned 16-bit value
   * 
   * @param val
   * @param buf
   * @param offset
   */
  public static void writeShort(int val, byte[] buf, int offset) {
	  buf[offset + 0] = (byte)(val & 0x00FF);
	  buf[offset + 1] = (byte)((val & 0xFF00) >> 8);
  }

  public static byte[] writeShort(int val) {
	  byte[] buf = new byte[2];
	  
	  writeShort(val, buf, 0);
	  
	  return buf;
  }
                     
  /** Read an unsigned byte */
  public static int readUByte( byte[] buf, int offset ) {
    return ((int)buf[offset] & 0xFF);
  }

  /** Write an unsigned byte
   * 
   * @param val
   * @param buf
   * @param offset
   */
  public static void writeUByte(int val, byte[] buf, int offset) {
	  buf[offset] = (byte)(val & 0xFF);
  }
  
  public static byte writeUByte(int val) {
	  byte[] buf = new byte[1];
	  
	  writeUByte(val, buf, 0);
	  
	  return buf[0];
  }

  /**
   * Return len of null-terminated string (i.e. distance to null)
   * within a byte buffer.
   * 
   * @param buf
   * @param offset
   * @return
   */
  public static int strlen( byte[] buf, int offset ) {
    int len = 0;
    while( buf[offset + len] != 0 )
      len++;
    return len;
  }



  /**
   * Copy a sequence of bytes into a new array.
   * 
   * @param b - source array
   * @param offset - first byte
   * @param len - number of bytes
   * @return new byte[len]
   */
  public static byte[] extract( byte[] b, int offset, int len ) {
    byte[] b2 = new byte[len];
    System.arraycopy( b, offset, b2, 0, len );
    return b2;
  }
  
  
  private static final byte[] CRLFbuf = { 0x0D, 0x0A };
  private static final String CRLF = new String(CRLFbuf);
  private static final String SEP = System.getProperty(""line.separator"");
  private static final boolean REPLACE = ! SEP.equals(CRLF);
  
  public static String readCString(byte[] buf, int offset) throws UnsupportedEncodingException {
	  String jstring = new String(buf, offset, strlen(buf, offset), ""UTF-8"");
	  
	  if ( REPLACE ) {
		  jstring = jstring.replace(CRLF, SEP);
	  }
	  
	  return jstring;
  }

  public static int writeCString(String str, OutputStream os) throws IOException {
	  if ( str == null ) {
		  // Write out a null character
		  os.write(writeInt(1));
		  os.write(0x00);
		  return 0;
	  }
	  
	  if ( REPLACE ) {
		  str = str.replace(SEP, CRLF);
	  }
	  
	  byte[] initial = str.getBytes(""UTF-8"");
	  
	  int length = initial.length+1;
	  os.write(writeInt(length));
	  os.write(initial);
	  os.write(0x00);
	  
	  return length;
  }
    
  public static UUID bytestoUUID(byte[] buf) {
	  return bytestoUUID(buf, 0);
  }
  
  public static UUID bytestoUUID(byte[] buf, int offset) {
	  long lsb = 0;
	  for (int i = 15; i >= 8; i--) {
		  lsb = (lsb << 8) | (buf[i + offset] & 0xff);
	  }
	  
	  long msb = 0;
	  for (int i = 7; i >= 0; i--) {
		  msb = (msb << 8) | (buf[i + offset] & 0xff);
	  }

	  return new UUID(msb, lsb);

  }
  
  public static byte[] UUIDtoBytes(UUID uuid) {
	  byte[] buf = new byte[16];
	  
	  LEDataOutputStream.writeLong(uuid.getMostSignificantBits(), buf, 0);
	  LEDataOutputStream.writeLong(uuid.getLeastSignificantBits(), buf, 8);
	  
	  return buf;
  }
  
}
",True,73,6,26,1,1,13,1,L0
46,com.keepassdroid.crypto.CipherFactory.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.crypto;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.UUID;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import com.keepassdroid.utils.Types;


public class CipherFactory {
	
	public static Cipher getInstance(String transformation) throws NoSuchAlgorithmException, NoSuchPaddingException {
		return getInstance(transformation, false);
	}
	
	public static Cipher getInstance(String transformation, boolean androidOverride) throws NoSuchAlgorithmException, NoSuchPaddingException {
		// Return the native AES if it is possible
		if ( (! androidOverride) && hasNativeImplementation(transformation) && NativeLib.loaded() ) {
			return Cipher.getInstance(transformation, new AESProvider());
		} else {
		try {
				return Cipher.getInstance(transformation, new BouncyCastleProvider());
			} catch (NoSuchAlgorithmException e) {
				// Do nothing, fall through
			} catch (NoSuchPaddingException e) {
				// Do nothing, fall through
			}
			return Cipher.getInstance(transformation);
		}
	}
	
	private static boolean hasNativeImplementation(String transformation) {
		return transformation.equals(""AES/CBC/PKCS5Padding"");
	}
	
	
	public static final UUID AES_CIPHER = Types.bytestoUUID(
			new byte[]{(byte)0x31, (byte)0xC1, (byte)0xF2, (byte)0xE6, (byte)0xBF, (byte)0x71, (byte)0x43, (byte)0x50,
					   (byte)0xBE, (byte)0x58, (byte)0x05, (byte)0x21, (byte)0x6A, (byte)0xFC, 0x5A, (byte)0xFF 
	});
	
	
	/** Generate appropriate cipher based on KeePass 2.x UUID's
	 * @param uuid
	 * @return
	 * @throws NoSuchPaddingException 
	 * @throws NoSuchAlgorithmException 
	 * @throws InvalidAlgorithmParameterException 
	 * @throws InvalidKeyException 
	 */
	public static Cipher getInstance(UUID uuid, byte[] key, byte[] IV) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
		if ( uuid.equals(AES_CIPHER) ) {
			Cipher cipher = CipherFactory.getInstance(""AES/CBC/PKCS5Padding""); 
			
			cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, ""AES""), new IvParameterSpec(IV));
			
			return cipher;
		}
		
		throw new NoSuchAlgorithmException(""UUID unrecognized."");
	}
}
",True,194,6,33,7,43,5,4,L4
47,com.keepassdroid.crypto.AESProvider.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.crypto;

import java.security.Provider;

public final class AESProvider extends Provider {

	/**
	 * 
	 */
	private static final long serialVersionUID = -3846349284296062658L;

	public AESProvider() {
		super(""AESProvider"", 1.0, """");
		put(""Cipher.AES"",com.keepassdroid.crypto.NativeAESCipherSpi.class.getName());
	}

}
",False,72,7,33,2,1,1,1,L4
48,com.keepassdroid.crypto.PwStreamCipherFactory.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.crypto;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import org.bouncycastle.crypto.StreamCipher;
import org.bouncycastle.crypto.engines.Salsa20Engine;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;

import com.keepassdroid.database.CrsAlgorithm;

public class PwStreamCipherFactory {
	public static StreamCipher getInstance(CrsAlgorithm alg, byte[] key) {
		if ( alg == CrsAlgorithm.Salsa20 ) {
			return getSalsa20(key);
			
		} else {
			return null;
		}
	}
	
	
	private static final byte[] SALSA_IV = new byte[]{ (byte)0xE8, 0x30, 0x09, 0x4B,
            (byte)0x97, 0x20, 0x5D, 0x2A };
	
	private static StreamCipher getSalsa20(byte[] key) {
		// Build stream cipher key
		MessageDigest md;
		try {
			md = MessageDigest.getInstance(""SHA-256"");
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
			throw new RuntimeException(""SHA 256 not supported"");
		}
		byte[] key32 = md.digest(key);
		
		KeyParameter keyParam = new KeyParameter(key32);
		ParametersWithIV ivParam = new ParametersWithIV(keyParam, SALSA_IV);
		
		StreamCipher cipher = new Salsa20Engine();
		cipher.init(true, ivParam);
		
		return cipher;
	}
}
",True,77,6,33,3,5,1,5,L5
49,com.keepassdroid.crypto.NativeLib.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.crypto;

public class NativeLib {
	private static boolean isLoaded = false;
	private static boolean loadSuccess = false;
	
	public static boolean loaded() {
		return init();
	}
	
	public static boolean init() {
		if ( ! isLoaded ) {
			try {
				System.loadLibrary(""final-key"");
			} catch ( UnsatisfiedLinkError e) {
				return false;
			}
			isLoaded = true;
			loadSuccess = true;
		}
		
		return loadSuccess;
		
	}

}
",True,85,7,36,0,0,3,0,L0
50,com.keepassdroid.crypto.NativeAESCipherSpi.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.crypto;

import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.InvalidParameterSpecException;
import java.util.HashMap;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.CipherSpi;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.IvParameterSpec;

import android.util.Log;

public class NativeAESCipherSpi extends CipherSpi {
	
	private static boolean mIsStaticInit = false;
	private static HashMap<PhantomReference<NativeAESCipherSpi>, Long> mCleanup = new HashMap<PhantomReference<NativeAESCipherSpi>, Long>();
	private static ReferenceQueue<NativeAESCipherSpi> mQueue = new ReferenceQueue<NativeAESCipherSpi>();
	
	private final int AES_BLOCK_SIZE = 16;
	private byte[] mIV;
	
	private boolean mIsInited = false;
	private boolean mEncrypting = false;
	private long mCtxPtr;
	
	private int mBuffered;
	private boolean mPadding = false;
	
	private static void staticInit() {
		mIsStaticInit = true;
		
		// Start the cipher context cleanup thread to run forever
		(new Thread(new Cleanup())).start();
	}
	
	private static void addToCleanupQueue(NativeAESCipherSpi ref, long ptr) {
		Log.d(""KeepassDroid"", ""queued cipher context: "" + ptr);
		mCleanup.put(new PhantomReference<NativeAESCipherSpi>(ref, mQueue), ptr);
	}
	
	/** Work with the garbage collector to clean up openssl memory when the cipher
	 *  context is garbage collected.
	 * @author bpellin
	 *
	 */
	private static class Cleanup implements Runnable {

		public void run() {
			while (true) {
				try {
					Reference<? extends NativeAESCipherSpi> ref = mQueue.remove();
					
					long ctx = mCleanup.remove(ref);
					nativeCleanup(ctx);
					Log.d(""KeePassDroid"", ""Cleaned up cipher context: "" + ctx);
					
				} catch (InterruptedException e) {
					// Do nothing, but resume looping if mQueue.remove is interrupted
				}
			}
		}
		
	}
	
	private static native void nativeCleanup(long ctxPtr);

	public NativeAESCipherSpi() {
		if ( ! mIsStaticInit ) {
			staticInit();
		}
	}

	
	@Override
	protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen)
			throws IllegalBlockSizeException, BadPaddingException {
		int maxSize = engineGetOutputSize(inputLen);
		byte[] output = new byte[maxSize];
		
		int finalSize = doFinal(input, inputOffset, inputLen, output, 0);
		
		if ( maxSize == finalSize ) {
			return output;
		} else {
			// TODO: Special doFinal to avoid this copy
			byte[] exact = new byte[finalSize];
			System.arraycopy(output, 0, exact, 0, finalSize);
			return exact;
		}
	}

	@Override
	protected int engineDoFinal(byte[] input, int inputOffset, int inputLen,
			byte[] output, int outputOffset) throws ShortBufferException,
			IllegalBlockSizeException, BadPaddingException {
		
		int result = doFinal(input, inputOffset, inputLen, output, outputOffset);
		
		if ( result == -1 ) {
			throw new ShortBufferException();
		}
		
		return result;
	}
	
	private int doFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) {
		
		int outputSize = engineGetOutputSize(inputLen);
		
		int updateAmt =	nativeUpdate(mCtxPtr, input, inputOffset, inputLen, output, outputOffset, outputSize);
		
		int finalAmt = nativeDoFinal(mCtxPtr, output, outputOffset + updateAmt, outputSize - updateAmt); 
		
		int out = updateAmt + finalAmt;
		
		mBuffered = 0;
		
		return out;
	}
	
	private native int nativeDoFinal(long ctxPtr, byte[] output, int outputOffest, int outputSize);

	@Override
	protected int engineGetBlockSize() {
		return AES_BLOCK_SIZE;
	}

	@Override
	protected byte[] engineGetIV() {
		return mIV;
	}

	@Override
	protected int engineGetOutputSize(int inputLen) {
		int totalLen = mBuffered + inputLen;

		/*
		if ( ! mPadding || ! mEncrypting ) {
			return totalLen;
		}
		*/
		
		int padLen = AES_BLOCK_SIZE - (totalLen % AES_BLOCK_SIZE);

		// TODO: Round up to nearest full block (there's probably a better way to do this)
		return totalLen + padLen;
	}

	@Override
	protected AlgorithmParameters engineGetParameters() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected void engineInit(int opmode, Key key, SecureRandom random)
			throws InvalidKeyException {

		byte[] ivArray = new byte[16];
		random.nextBytes(ivArray);
		
		init(opmode, key, new IvParameterSpec(ivArray));
	}

	@Override
	protected void engineInit(int opmode, Key key,
			AlgorithmParameterSpec params, SecureRandom random)
			throws InvalidKeyException, InvalidAlgorithmParameterException {
		
		IvParameterSpec ivparam;
		
		if ( params instanceof IvParameterSpec ) {
			ivparam = (IvParameterSpec) params;
		} else {
			throw new InvalidAlgorithmParameterException(""params must be an IvParameterSpec."");
		}
		
		init(opmode, key, ivparam);
	}
	

	@Override
	protected void engineInit(int opmode, Key key, AlgorithmParameters params,
			SecureRandom random) throws InvalidKeyException,
			InvalidAlgorithmParameterException {
		
		try {
			engineInit(opmode, key, params.getParameterSpec(AlgorithmParameterSpec.class), random);
		} catch (InvalidParameterSpecException e) {
			throw new InvalidAlgorithmParameterException(e);
		}

	}

	private void init(int opmode, Key key, IvParameterSpec params) {
		if ( mIsInited ) {
			// Do not allow multiple inits
			assert(true);
			throw new RuntimeException(""Don't allow multiple inits"");
		} else {
			NativeLib.init();
			mIsInited = true;
		}
		
		mIV = params.getIV();
		mEncrypting = opmode == Cipher.ENCRYPT_MODE;
		mBuffered = 0;
		mCtxPtr = nativeInit(mEncrypting, key.getEncoded(), mIV, mPadding);
		addToCleanupQueue(this, mCtxPtr);
	}
	
	private native long nativeInit(boolean encrypt, byte[] key, byte[] iv, boolean mPadding);
	
	@Override
	protected void engineSetMode(String mode) throws NoSuchAlgorithmException {
		if ( ! mode.equals(""CBC"") ) {
			throw new NoSuchAlgorithmException(""This only supports CBC mode"");
		}
	}

	@Override
	protected void engineSetPadding(String padding)
			throws NoSuchPaddingException {
		
		if ( ! mIsInited ) {
			NativeLib.init();
		}
		
		if ( padding.length() == 0 ) {
			return;
		}

		if ( ! padding.equals(""PKCS5Padding"") ) {
			throw new NoSuchPaddingException(""Only supports PKCS5Padding."");
		}
			
		mPadding = true;

	}
	
	@Override
	protected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) {
		int maxSize = engineGetOutputSize(inputLen);
		byte output[] = new byte[maxSize];
		
		int updateSize = update(input, inputOffset, inputLen, output, 0);
		
		if ( updateSize == maxSize ) {
			return output;
		} else {
			// TODO: We could optimize update for this case to avoid this extra copy
			byte[] exact = new byte[updateSize];
			System.arraycopy(output, 0, exact, 0, updateSize);
			return exact;
		}
		
	}

	@Override
	protected int engineUpdate(byte[] input, int inputOffset, int inputLen,
			byte[] output, int outputOffset) throws ShortBufferException {
		
		int result = update(input, inputOffset, inputLen, output, outputOffset);
		
		if ( result == -1 ) {
			throw new ShortBufferException(""Insufficient buffer."");
		}
		
		return result;
		
	}
	
	int update(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) {
		int outputSize = engineGetOutputSize(inputLen);
		
		int out = nativeUpdate(mCtxPtr, input, inputOffset, inputLen, output, outputOffset, outputSize);
		
		mBuffered = (mBuffered + ((inputLen - out))) % AES_BLOCK_SIZE;
		
		return out;
		
		
	}
	
	private native int nativeUpdate(long ctxPtr, byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset, int outputSize);
	
}",True,72,8,33,1,1,1,1,L4
51,com.keepassdroid.crypto.BouncyCastleProvider.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.crypto;

import java.security.Provider;

public class BouncyCastleProvider extends Provider {
	/**
	 * 
	 */
	private static final long serialVersionUID = -6705090615178002994L;

	public BouncyCastleProvider() {
		super(""BouncyCastleProvider"", 1.0, """");

		put(""Cipher.TWOFISH"", org.bouncycastle.jce.provider.JCEBlockCipher.Twofish.class.getName());
	}

}
",False,189,7,33,6,43,1,1,L4
52,com.keepassdroid.crypto.finalkey.FinalKeyFactory.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.crypto.finalkey;

public class FinalKeyFactory {
	public static FinalKey createFinalKey() {
		return createFinalKey(false);
	}
	
	public static FinalKey createFinalKey(boolean androidOverride) {
		// Prefer the native final key implementation
		if ( ! androidOverride && NativeFinalKey.availble() ) {
			return new NativeFinalKey();
		} else {
			// Fall back on the android crypto implementation
			return new AndroidFinalKey();
		}
	}
}
",False,82,5,41,2,3,1,3,L2
53,com.keepassdroid.crypto.finalkey.FinalKey.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.crypto.finalkey;

import java.io.IOException;

public abstract class FinalKey {
	public abstract byte[] transformMasterKey(byte[] seed, byte[] key, int rounds) throws IOException;
}
",False,82,5,41,0,0,4,0,L1
54,com.keepassdroid.crypto.finalkey.AndroidFinalKey.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.crypto.finalkey;

import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.SecretKeySpec;

public class AndroidFinalKey extends FinalKey {

	@Override
	public byte[] transformMasterKey(byte[] pKeySeed, byte[] pKey, int rounds) throws IOException {
		Cipher cipher;
		try {
			cipher = Cipher.getInstance(""AES/ECB/NoPadding"");
		} catch (NoSuchAlgorithmException e) {
			throw new IOException(""NoSuchAlgorithm: "" + e.getMessage());
		} catch (NoSuchPaddingException e) {
			throw new IOException(""NoSuchPadding: "" + e.getMessage());
		}

		try {
			cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(pKeySeed, ""AES""));
		} catch (InvalidKeyException e) {
			throw new IOException(""InvalidPasswordException: "" + e.getMessage());
		}

		// Encrypt key rounds times
		byte[] newKey = new byte[pKey.length];
		System.arraycopy(pKey, 0, newKey, 0, pKey.length);
		byte[] destKey = new byte[pKey.length];
		for (int i = 0; i < rounds; i++) {
			try {
				cipher.update(newKey, 0, newKey.length, destKey, 0);
				System.arraycopy(destKey, 0, newKey, 0, newKey.length);

			} catch (ShortBufferException e) {
				throw new IOException(""Short buffer: "" + e.getMessage());
			}
		}

		// Hash the key
		MessageDigest md = null;
		try {
			md = MessageDigest.getInstance(""SHA-256"");
		} catch (NoSuchAlgorithmException e) {
			assert true;
			throw new IOException(""SHA-256 not implemented here: "" + e.getMessage());
		}

		md.update(newKey);
		return md.digest();
	}

}
",False,81,6,41,1,1,2,1,L1
55,com.keepassdroid.crypto.finalkey.NativeFinalKey.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.crypto.finalkey;

import java.io.IOException;

import com.keepassdroid.crypto.NativeLib;


public class NativeFinalKey extends FinalKey {
	
	public static boolean availble() {
		return NativeLib.init();
	}

	@Override
	public byte[] transformMasterKey(byte[] seed, byte[] key, int rounds) throws IOException {
		NativeLib.init();
		
		return nativeTransformMasterKey(seed, key, rounds);

	}
	
	private static native byte[] nativeTransformMasterKey(byte[] seed, byte[] key, int rounds);

	// For testing
	public static byte[] reflect(byte[] key) {
		NativeLib.init();
		
		return nativeReflect(key);
	}
	
	private static native byte[] nativeReflect(byte[] key);
	

}
",True,82,6,41,1,2,2,2,L1
56,com.keepassdroid.stream.RandomFileOutputStream.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.stream;

import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;

public class RandomFileOutputStream extends OutputStream {

	RandomAccessFile mFile;
	
	RandomFileOutputStream(RandomAccessFile file) {
		mFile = file;
	}
	
	@Override
	public void close() throws IOException {
		super.close();
		
		mFile.close();		
	}

	@Override
	public void write(byte[] buffer, int offset, int count) throws IOException {
		super.write(buffer, offset, count);
		
		mFile.write(buffer, offset, count);
	}

	@Override
	public void write(byte[] buffer) throws IOException {
		super.write(buffer);
		
		mFile.write(buffer);
	}

	@Override
	public void write(int oneByte) throws IOException {
		mFile.write(oneByte);
	}
	
	public void seek(long pos) throws IOException {
		mFile.seek(pos);
	}

}
",True,1,0,0,0,0,0,0,I0
57,com.keepassdroid.stream.NullOutputStream.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.stream;

import java.io.IOException;
import java.io.OutputStream;

public class NullOutputStream extends OutputStream {

	@Override
	public void close() throws IOException {
		super.close();
	}

	@Override
	public void flush() throws IOException {
		super.flush();
	}

	@Override
	public void write(byte[] buffer, int offset, int count) throws IOException {
		super.write(buffer, offset, count);
	}

	@Override
	public void write(byte[] buffer) throws IOException {
		super.write(buffer);
	}

	@Override
	public void write(int oneByte) throws IOException {
	}

}
",True,78,5,38,0,0,4,0,L2
58,com.keepassdroid.stream.HashedBlockInputStream.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.stream;

import java.io.IOException;
import java.io.InputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;


public class HashedBlockInputStream extends InputStream {
	
	private final static int HASH_SIZE = 32;

	private LEDataInputStream baseStream;
	private int bufferPos = 0;
	private byte[] buffer = new byte[0];
	private long bufferIndex = 0;
	private boolean atEnd = false;
	
	
	@Override
	public int read(byte[] b) throws IOException {
		return read(b, 0, b.length);
	}

	public HashedBlockInputStream(InputStream is) {
		baseStream = new LEDataInputStream(is);
	}
	
	@Override
	public int read(byte[] b, int offset, int length) throws IOException {
		if ( atEnd ) return -1;
		
		int remaining = length;
		
		while ( remaining > 0 ) {
			if ( bufferPos == buffer.length ) {
				// Get more from the source into the buffer
				if ( ! ReadHashedBlock() ) {
					return length - remaining;
				}
				
			}

			// Copy from buffer out
			int copyLen = Math.min(buffer.length - bufferPos, remaining);
			
			System.arraycopy(buffer, bufferPos, b, offset, copyLen);
			
			offset += copyLen;
			bufferPos += copyLen;
			
			remaining -= copyLen;
		}
		
		return length;
	}

	/**
	 * @return false, when the end of the source stream is reached 
	 * @throws IOException 
	 */
	private boolean ReadHashedBlock() throws IOException {
		if ( atEnd ) return false;
		
		bufferPos = 0;
		
		long index = baseStream.readUInt();
		if ( index != bufferIndex ) {
			throw new IOException(""Invalid data format"");
		}
		bufferIndex++;
		
		byte[] storedHash = baseStream.readBytes(32);
		if ( storedHash == null || storedHash.length != HASH_SIZE) {
			throw new IOException(""Invalid data format"");
		}
		
		int bufferSize = LEDataInputStream.readInt(baseStream);
		if ( bufferSize < 0 ) {
			throw new IOException(""Invalid data format"");
		}
		
		if ( bufferSize == 0 ) {
			for (int hash = 0; hash < HASH_SIZE; hash++) {
				if ( storedHash[hash] != 0 ) {
					throw new IOException(""Invalid data format"");
				}
			}
				
			atEnd = true;
			buffer = new byte[0];
			return false;
		}
		
		buffer = baseStream.readBytes(bufferSize);
		if ( buffer == null || buffer.length != bufferSize ) {
			throw new IOException(""Invalid data format"");
		}
		
		MessageDigest md = null;
		try {
			md = MessageDigest.getInstance(""SHA-256"");
		} catch (NoSuchAlgorithmException e) {
			throw new IOException(""SHA-256 not implemented here."");
		}
		
		byte[] computedHash = md.digest(buffer);
		if ( computedHash == null || computedHash.length != HASH_SIZE ) {
			throw new IOException(""Hash wrong size"");
		}
		
		if ( ! Arrays.equals(storedHash, computedHash) ) {
			throw new IOException(""Hashes didn't match."");
		}

		return true;
	}

	@Override
	public long skip(long n) throws IOException {
		return 0;
	}

	@Override
	public int read() throws IOException {
		if ( atEnd ) return -1;
		
		if ( bufferPos == buffer.length ) {
			if ( ! ReadHashedBlock() ) return -1;
		}
		
		int output = buffer[bufferPos];
		bufferPos++;
		
		return output;
	}

	@Override
	public void close() throws IOException {
		baseStream.close();
	}

}
",False,70,6,33,1,1,2,1,L0
59,com.keepassdroid.stream.BetterCipherInputStream.java,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the ""License""); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an ""AS IS"" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.keepassdroid.stream;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;

import javax.crypto.Cipher;
import javax.crypto.NullCipher;

/**
 * This class wraps an {@code InputStream} and a cipher so that {@code read()}
 * methods return data that are read from the underlying {@code InputStream} and
 * processed by the cipher.
 * <p>
 * The cipher must be initialized for the requested operation before being used
 * by a {@code BetterCipherInputStream}. For example, if a cipher initialized for
 * decryption is used with a {@code BetterCipherInputStream}, the {@code
 * BetterCipherInputStream} tries to read the data an decrypt them before returning.
 */
public class BetterCipherInputStream extends FilterInputStream {

    private final Cipher cipher;
    private static final int I_DEFAULT_BUFFER_SIZE = 8 * 1024;
    private final byte[] i_buffer;
    private int index; // index of the bytes to return from o_buffer
    private byte[] o_buffer;
    private boolean finished;

    /**
     * Creates a new {@code BetterCipherInputStream} instance for an {@code
     * InputStream} and a cipher.
     *
     * @param is
     *            the input stream to read data from.
     * @param c
     *            the cipher to process the data with.
     */
    public BetterCipherInputStream(InputStream is, Cipher c) {
    	this(is, c, I_DEFAULT_BUFFER_SIZE);
    }

    /**
     * Creates a new {@code BetterCipherInputStream} instance for an {@code
     * InputStream} and a cipher.
     *
     * @param is
     *            the input stream to read data from.
     * @param c
     *            the cipher to process the data with.
     * @param bufferSize
     *            size to buffer output from the cipher
     */
    public BetterCipherInputStream(InputStream is, Cipher c, int bufferSize) {
        super(is);
        this.cipher = c;
        i_buffer = new byte[bufferSize];
    }

    /**
     * Creates a new {@code BetterCipherInputStream} instance for an {@code
     * InputStream} without a cipher.
     * <p>
     * A {@code NullCipher} is created and used to process the data.
     *
     * @param is
     *            the input stream to read data from.
     */
    protected BetterCipherInputStream(InputStream is) {
        this(is, new NullCipher());
    }

    /**
     * Reads the next byte from this cipher input stream.
     *
     * @return the next byte, or {@code -1} if the end of the stream is reached.
     * @throws IOException
     *             if an error occurs.
     */
    @Override
    public int read() throws IOException {
        if (finished) {
            return ((o_buffer == null) || (index == o_buffer.length))
                            ? -1
                            : o_buffer[index++] & 0xFF;
        }
        if ((o_buffer != null) && (index < o_buffer.length)) {
            return o_buffer[index++] & 0xFF;
        }
        index = 0;
        o_buffer = null;
        int num_read;
        while (o_buffer == null) {
            if ((num_read = in.read(i_buffer)) == -1) {
                try {
                    o_buffer = cipher.doFinal();
                } catch (Exception e) {
                    throw new IOException(e.getMessage());
                }
                finished = true;
                break;
            }
            o_buffer = cipher.update(i_buffer, 0, num_read);
        }
        return read();
    }

    /**
     * Reads the next {@code b.length} bytes from this input stream into buffer
     * {@code b}.
     *
     * @param b
     *            the buffer to be filled with data.
     * @return the number of bytes filled into buffer {@code b}, or {@code -1}
     *         if the end of the stream is reached.
     * @throws IOException
     *             if an error occurs.
     */
    @Override
    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }

    /**
     * Reads the next {@code len} bytes from this input stream into buffer
     * {@code b} starting at offset {@code off}.
     * <p>
     * if {@code b} is {@code null}, the next {@code len} bytes are read and
     * discarded.
     *
     * @param b
     *            the buffer to be filled with data.
     * @param off
     *            the offset to start in the buffer.
     * @param len
     *            the maximum number of bytes to read.
     * @return the number of bytes filled into buffer {@code b}, or {@code -1}
     *         of the of the stream is reached.
     * @throws IOException
     *             if an error occurs.
     * @throws NullPointerException
     *             if the underlying input stream is {@code null}.
     */
    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        if (in == null) {
            throw new NullPointerException(""Underlying input stream is null"");
        }

        int read_b;
        int i;
        for (i=0; i<len; i++) {
            if ((read_b = read()) == -1) {
                return (i == 0) ? -1 : i;
            }
            if (b != null) {
                b[off+i] = (byte) read_b;
            }
        }
        return i;
    }

    /**
     * Skips up to n bytes from this input stream.
     * <p>
     * The number of bytes skipped depends on the result of a call to
     * {@link BetterCipherInputStream#available() available}. The smaller of n and the
     * result are the number of bytes being skipped.
     *
     * @param n
     *            the number of bytes that should be skipped.
     * @return the number of bytes actually skipped.
     * @throws IOException
     *             if an error occurs
     */
    @Override
    public long skip(long n) throws IOException {
        long i = 0;
        int available = available();
        if (available < n) {
            n = available;
        }
        while ((i < n) && (read() != -1)) {
            i++;
        }
        return i;
    }

    /**
     * Returns the number of bytes available without blocking.
     *
     * @return the number of bytes available, currently zero.
     * @throws IOException
     *             if an error occurs
     */
    @Override
    public int available() throws IOException {
        return 0;
    }

    /**
     * Closes this {@code BetterCipherInputStream}, also closes the underlying input
     * stream and call {@code doFinal} on the cipher object.
     *
     * @throws IOException
     *             if an error occurs.
     */
    @Override
    public void close() throws IOException {
        in.close();
        try {
            cipher.doFinal();
        } catch (GeneralSecurityException ignore) {
            //do like RI does
        }

    }

    /**
     * Returns whether this input stream supports {@code mark} and
     * {@code reset}, which it does not.
     *
     * @return false, since this input stream does not support {@code mark} and
     *         {@code reset}.
     */
    @Override
    public boolean markSupported() {
        return false;
    }
}",True,68,6,33,0,0,1,0,L5
60,com.keepassdroid.stream.LEDataOutputStream.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.stream;

import java.io.IOException;
import java.io.OutputStream;

import com.keepassdroid.utils.Types;

/** Little Endian version of the DataOutputStream
 * @author bpellin
 *
 */
public class LEDataOutputStream extends OutputStream {

	private OutputStream baseStream; 
	
	public LEDataOutputStream(OutputStream out) {
		baseStream = out;
	}
	
	public void writeUInt(long uint) throws IOException {
		baseStream.write(Types.writeInt((int) uint));
	}

	@Override
	public void close() throws IOException {
		baseStream.close();
	}

	@Override
	public void flush() throws IOException {
		baseStream.flush();
	}

	@Override
	public void write(byte[] buffer, int offset, int count) throws IOException {
		baseStream.write(buffer, offset, count);
	}

	@Override
	public void write(byte[] buffer) throws IOException {
		baseStream.write(buffer);
	}

	@Override
	public void write(int oneByte) throws IOException {
		baseStream.write(oneByte);
	}
	
	public void writeLong(long val) throws IOException {
		byte[] buf = new byte[8];
		
		writeLong(val, buf, 0);
		baseStream.write(buf);
	}
	
	public void writeInt(int val) throws IOException {
		byte[] buf = new byte[4];
		writeInt(val, buf, 0);
		
		baseStream.write(buf);
	}

	/**
	   * Write a 32-bit value.
	   * 
	   * @param val
	   * @param buf
	   * @param offset
	   */
	  public static void writeInt( int val, byte[] buf, int offset ) {
	    buf[offset + 0] = (byte)(val & 0xFF);
	    buf[offset + 1] = (byte)((val >>> 8) & 0xFF);
	    buf[offset + 2] = (byte)((val >>> 16) & 0xFF);
	    buf[offset + 3] = (byte)((val >>> 24) & 0xFF);
	  }

	public static void writeLong( long val, byte[] buf, int offset ) {
		buf[offset + 0] = (byte)(val & 0xFF);
		buf[offset + 1] = (byte)((val >>> 8) & 0xFF);
		buf[offset + 2] = (byte)((val >>> 16) & 0xFF);
		buf[offset + 3] = (byte)((val >>> 24) & 0xFF);
		buf[offset + 4] = (byte)((val >>> 32) & 0xFF);
		buf[offset + 5] = (byte)((val >>> 40) & 0xFF);
		buf[offset + 6] = (byte)((val >>> 48) & 0xFF);
		buf[offset + 7] = (byte)((val >>> 56) & 0xFF);
	}

}
",True,69,6,33,1,1,4,1,L0
61,com.keepassdroid.stream.HashedBlockOutputStream.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.stream;

import java.io.IOException;
import java.io.OutputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class HashedBlockOutputStream extends OutputStream {

	private final static int DEFAULT_BUFFER_SIZE = 1024 * 1024; 
	
	private LEDataOutputStream baseStream;
	private int bufferPos = 0;
	private byte[] buffer;
	private long bufferIndex = 0;
	
	public HashedBlockOutputStream(OutputStream os) {
		init(os, DEFAULT_BUFFER_SIZE);
	}
	
	public HashedBlockOutputStream(OutputStream os, int bufferSize) {
		if ( bufferSize <= 0 ) {
			bufferSize = DEFAULT_BUFFER_SIZE;
		}
		
		init(os, bufferSize);
	}
	
	private void init(OutputStream os, int bufferSize) {
		baseStream = new LEDataOutputStream(os);
		buffer = new byte[bufferSize];
		
	}

	@Override
	public void write(int oneByte) throws IOException {
		byte[] buf = new byte[1];
		write(buf, 0, 1);
	}

	@Override
	public void close() throws IOException {
		if ( bufferPos != 0 ) {
			// Write remaining buffered amount
			WriteHashedBlock();
		}
		
		// Write terminating block
		WriteHashedBlock();
		
		flush();
		baseStream.close();
	}

	@Override
	public void flush() throws IOException {
		baseStream.flush();
	}

	@Override
	public void write(byte[] b, int offset, int count) throws IOException {
		while ( count > 0 ) {
			if ( bufferPos == buffer.length ) {
				WriteHashedBlock();
			}
			
			int copyLen = Math.min(buffer.length - bufferPos, count);
			
			System.arraycopy(b, offset, buffer, bufferPos, copyLen);
			
			offset += copyLen;
			bufferPos += copyLen;
			
			count -= copyLen;
		}
	}

	private void WriteHashedBlock() throws IOException {
		baseStream.writeUInt(bufferIndex);
		bufferIndex++;
		
		if ( bufferPos > 0 ) {
			MessageDigest md = null;
			try {
				md = MessageDigest.getInstance(""SHA-256"");
			} catch (NoSuchAlgorithmException e) {
				throw new IOException(""SHA-256 not implemented here."");
			}
			
			byte[] hash;
			md.update(buffer, 0, bufferPos);
			hash = md.digest();
			/*
			if ( bufferPos == buffer.length) {
				hash = md.digest(buffer);
			} else {
				byte[] b = new byte[bufferPos];
				System.arraycopy(buffer, 0, b, 0, bufferPos);
				hash = md.digest(b);
			}
			*/
			
			baseStream.write(hash);

		} else {
			// Write 32-bits of zeros
			baseStream.writeLong(0L);
			baseStream.writeLong(0L);
			baseStream.writeLong(0L);
			baseStream.writeLong(0L);
		}
		
		baseStream.writeInt(bufferPos);
		
		if ( bufferPos > 0 ) {
			baseStream.write(buffer, 0, bufferPos);
		}
		
		bufferPos = 0;
		
	}

	@Override
	public void write(byte[] buffer) throws IOException {
		write(buffer, 0, buffer.length);
	}

}
",True,4,1,1,2,1,1,1,L9
62,com.keepassdroid.stream.LEDataInputStream.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.stream;

import java.io.IOException;
import java.io.InputStream;


/** Little endian version of the DataInputStream
 * @author bpellin
 *
 */
public class LEDataInputStream extends InputStream {

	public static final long INT_TO_LONG_MASK = 0xffffffffL;
	
	private InputStream baseStream;

	public LEDataInputStream(InputStream in) {
		baseStream = in;
	}
	
	/** Read a 32-bit value and return it as a long, so that it can
	 *  be interpreted as an unsigned integer.
	 * @return
	 * @throws IOException
	 */
	public long readUInt() throws IOException {
		return readUInt(baseStream);
	}
	
	public int readInt() throws IOException {
		return readInt(baseStream);
	}
	
	public long readLong() throws IOException {
		byte[] buf = readBytes(8);
		
		return readLong(buf, 0);
	}
	
	@Override
	public int available() throws IOException {
		return baseStream.available();
	}

	@Override
	public void close() throws IOException {
		baseStream.close();
	}

	@Override
	public void mark(int readlimit) {
		baseStream.mark(readlimit);
	}

	@Override
	public boolean markSupported() {
		return baseStream.markSupported();
	}

	@Override
	public int read() throws IOException {
		return baseStream.read();
	}

	@Override
	public int read(byte[] b, int offset, int length) throws IOException {
		return baseStream.read(b, offset, length);
	}

	@Override
	public int read(byte[] b) throws IOException {
		// TODO Auto-generated method stub
		return super.read(b);
	}

	@Override
	public synchronized void reset() throws IOException {
		baseStream.reset();
	}

	@Override
	public long skip(long n) throws IOException {
		return baseStream.skip(n);
	}

	public byte[] readBytes(int length) throws IOException {
		byte[] buf = new byte[length];
		
		int count = 0;
		while ( count < length ) {
			int read = read(buf, count, length - count);
			
			// Reached end
			if ( read == -1 ) {
				// Stop early
				byte[] early = new byte[count];
				System.arraycopy(buf, 0, early, 0, count);
				return early;
			}
			
			count += read;
		}
		
		return buf;
	}

	public static long readLong( byte buf[], int offset ) {
		return ((long)buf[offset + 0] & 0xFF) + (((long)buf[offset + 1] & 0xFF) << 8) 
		+ (((long)buf[offset + 2] & 0xFF) << 16) + (((long)buf[offset + 3] & 0xFF) << 24) 
		+ (((long)buf[offset + 4] & 0xFF) << 32) + (((long)buf[offset + 5] & 0xFF) << 40) 
		+ (((long)buf[offset + 6] & 0xFF) << 48) + (((long)buf[offset + 7] & 0xFF) << 56);
	}

	public static long readUInt( byte buf[], int offset ) {
		  return (readInt(buf, offset) & INT_TO_LONG_MASK);
	  }

	public static int readInt(InputStream is) throws IOException {
		  byte[] buf = new byte[4];
	
		  is.read(buf, 0, 4);
		  
		  return readInt(buf, 0);
	  }

	public static long readUInt(InputStream is) throws IOException {
		  return (readInt(is) & INT_TO_LONG_MASK);
	  }

	/**
	   * Read a 32-bit value.
	   * 
	   * @param buf
	   * @param offset
	   * @return
	   */
	  public static int readInt( byte buf[], int offset ) {
	    return (buf[offset + 0] & 0xFF) + ((buf[offset + 1] & 0xFF) << 8) + ((buf[offset + 2] & 0xFF) << 16)
	           + ((buf[offset + 3] & 0xFF) << 24);
	  }

}
",True,73,5,36,0,0,7,0,L0
63,com.keepassdroid.timers.Timeout.java,"package com.keepassdroid.timers;

import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.preference.PreferenceManager;
import android.util.Log;

import com.android.keepass.R;
import com.keepassdroid.intents.Intents;
import com.keepassdroid.services.TimeoutService;

public class Timeout {
	private static final int REQUEST_ID = 0;
	private static final long DEFAULT_TIMEOUT = 5 * 60 * 1000;  // 5 minutes
	private static String TAG = ""KeePass Timeout"";

	private static PendingIntent buildIntent(Context ctx) {
		Intent intent = new Intent(Intents.TIMEOUT);
		PendingIntent sender = PendingIntent.getBroadcast(ctx, REQUEST_ID, intent, PendingIntent.FLAG_CANCEL_CURRENT);

		return sender;
	}
	
	public static void start(Context ctx) {


		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);
		String sTimeout = prefs.getString(ctx.getString(R.string.app_timeout_key), ctx.getString(R.string.clipboard_timeout_default));
		
		long timeout;
		try {
			timeout = Long.parseLong(sTimeout);
		} catch (NumberFormatException e) {
			timeout = DEFAULT_TIMEOUT;
		}
		
		if ( timeout == -1 ) {
			// No timeout don't start timeout service
			return;
		}
		
		ctx.startService(new Intent(ctx, TimeoutService.class));

		long triggerTime = System.currentTimeMillis() + timeout;
		AlarmManager am = (AlarmManager) ctx.getSystemService(Context.ALARM_SERVICE);
		
		Log.d(TAG, ""Timeout start"");
		am.set(AlarmManager.RTC, triggerTime, buildIntent(ctx));
	}
	
	public static void cancel(Context ctx) {
		AlarmManager am = (AlarmManager) ctx.getSystemService(Context.ALARM_SERVICE);
		
		Log.d(TAG, ""Timeout cancel"");
		am.cancel(buildIntent(ctx));
		
		ctx.stopService(new Intent(ctx, TimeoutService.class));

	}

}
",False,220,5,13,13,43,3,2,L8
64,com.keepassdroid.services.TimeoutService.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.services;

import android.app.NotificationManager;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Binder;
import android.os.IBinder;
import android.util.Log;

import com.keepassdroid.app.App;
import com.keepassdroid.intents.Intents;

public class TimeoutService extends Service {
	private static final String TAG = ""KeePassDroid Timer""; 
	private BroadcastReceiver mIntentReceiver;
	
	@Override
	public void onCreate() {
		super.onCreate();
		
		mIntentReceiver = new BroadcastReceiver() {
			@Override
			public void onReceive(Context context, Intent intent) {
				String action = intent.getAction();
				
				if ( action.equals(Intents.TIMEOUT) ) {
					timeout(context);
				}
			}
		};
		
		IntentFilter filter = new IntentFilter();
		filter.addAction(Intents.TIMEOUT);
		registerReceiver(mIntentReceiver, filter);
		
	}
	
	@Override
	public void onStart(Intent intent, int startId) {
		super.onStart(intent, startId);
		
		Log.d(TAG, ""Timeout service started"");
	}

	private void timeout(Context context) {
		Log.d(TAG, ""Timeout"");
		App.setShutdown();
		
		NotificationManager nm = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
		nm.cancelAll();
		
		stopSelf();
	}
	
	@Override
	public void onDestroy() {
		super.onDestroy();

		Log.d(TAG, ""Timeout service stopped"");
	
		unregisterReceiver(mIntentReceiver);
	}

	public class TimeoutBinder extends Binder {
		public TimeoutService getService() {
			return TimeoutService.this;
		}
	}
	
	private final IBinder mBinder = new TimeoutBinder();
	
	@Override
	public IBinder onBind(Intent intent) {
		return mBinder;
	}
	
}
",False,220,6,13,12,43,1,2,L8
65,com.keepassdroid.database.PwGroupIdV3.java,"package com.keepassdroid.database;

public class PwGroupIdV3 extends PwGroupId {

	private int id;
	
	public PwGroupIdV3(int i) {
		id = i;
	}
	
	@Override
	public boolean equals(Object compare) {
		if ( ! (compare instanceof PwGroupIdV3) ) {
			return false;
		}
		
		PwGroupIdV3 cmp = (PwGroupIdV3) compare;
		return id == cmp.id;
	}

	@Override
	public int hashCode() {
		Integer i = new Integer(id);
		return i.hashCode();
	}
	
	public int getId() {
		return id;
	}
	

}
",False,67,5,32,1,1,4,1,L6
66,com.keepassdroid.database.PwIconFactory.java,"package com.keepassdroid.database;

import java.util.Map;
import java.util.UUID;
import java.util.WeakHashMap;

public class PwIconFactory {
	private Map<Integer, PwIconStandard> cache = new WeakHashMap<Integer, PwIconStandard>();
	private Map<UUID, PwIconCustom> customCache = new WeakHashMap<UUID, PwIconCustom>();
	
	public PwIconStandard getIcon(int iconId) {
		PwIconStandard icon = cache.get(iconId);
		
		if (icon == null) {
			icon = new PwIconStandard(iconId);
			cache.put(iconId, icon);
		}
		
		return icon;
	}
	
	public PwIconCustom getIcon(UUID iconUuid) {
		PwIconCustom icon = customCache.get(iconUuid);
		
		if (icon == null) {
			icon = new PwIconCustom(iconUuid, null);
			customCache.put(iconUuid, icon);
		}
		
		return icon;
	}
	
	public PwIconCustom getIcon(UUID iconUuid, byte[] data) {
		PwIconCustom icon = customCache.get(iconUuid);
		
		if (icon == null) {
			icon = new PwIconCustom(iconUuid, data);
			customCache.put(iconUuid, icon);
		} else {
			icon.imageData = data;
		}
		
		return icon;
	}
	
	public void setIconData(UUID iconUuid, byte[] data) {
		getIcon(iconUuid, data);
	}
	
	public void put(PwIconCustom icon) {
		customCache.put(icon.uuid, icon);
	}

}
",False,93,6,29,6,11,5,2,L2
67,com.keepassdroid.database.PwEntryV3.java,"/*
KeePass for J2ME

Copyright 2007 Naomaru Itoi <nao@phoneid.org>

This file was derived from 

Java clone of KeePass - A KeePass file viewer for Java
Copyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

package com.keepassdroid.database;

// PhoneID
import java.util.Calendar;
import java.util.Date;
import java.util.Random;
import java.util.UUID;

import android.util.Log;

import com.keepassdroid.Database;
import com.keepassdroid.utils.Types;


/**
 * Structure containing information about one entry.
 * 
 * <PRE>
 * One entry: [FIELDTYPE(FT)][FIELDSIZE(FS)][FIELDDATA(FD)]
 *            [FT+FS+(FD)][FT+FS+(FD)][FT+FS+(FD)][FT+FS+(FD)][FT+FS+(FD)]...
 *            
 * [ 2 bytes] FIELDTYPE
 * [ 4 bytes] FIELDSIZE, size of FIELDDATA in bytes
 * [ n bytes] FIELDDATA, n = FIELDSIZE
 * 
 * Notes:
 *  - Strings are stored in UTF-8 encoded form and are null-terminated.
 *  - FIELDTYPE can be one of the FT_ constants.
 * </PRE>
 *
 * @author Naomaru Itoi <nao@phoneid.org>
 * @author Bill Zwicky <wrzwicky@pobox.com>
 * @author Dominik Reichl <dominik.reichl@t-online.de>
 */
public class PwEntryV3 extends PwEntry {

	public static final Date NEVER_EXPIRE = getNeverExpire();
	

	/** Size of byte buffer needed to hold this struct. */
	public static final String PMS_ID_BINDESC = ""bin-stream"";
	public static final String PMS_ID_TITLE   = ""Meta-Info"";
	public static final String PMS_ID_USER    = ""SYSTEM"";
	public static final String PMS_ID_URL     = ""$"";
	private static final String PMS_TAN_ENTRY =""<TAN>"";



	public int              groupId;
	public 	String 			username;
	private byte[]          password;
	private byte[]          uuid;
	public String title;
	public String url;
	public String additional;


	public PwDate             tCreation;
	public PwDate             tLastMod;
	public PwDate             tLastAccess;
	public PwDate             tExpire;

	/** A string describing what is in pBinaryData */
	public String           binaryDesc;
	private byte[]          binaryData;

	private static Date getNeverExpire() {
		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.YEAR, 2999);
		cal.set(Calendar.MONTH, 11);
		cal.set(Calendar.DAY_OF_MONTH, 28);
		cal.set(Calendar.HOUR, 23);
		cal.set(Calendar.MINUTE, 59);
		cal.set(Calendar.SECOND, 59);

		return cal.getTime();
	}

	public static boolean IsNever(Date date) {
		Calendar never = Calendar.getInstance();
		never.setTime(NEVER_EXPIRE);
		never.set(Calendar.MILLISECOND, 0);

		Calendar cal = Calendar.getInstance();
		cal.setTime(date);
		cal.set(Calendar.MILLISECOND, 0);

		Log.d(""never"", ""L=""+ never.get(Calendar.YEAR) + "" R="" + cal.get(Calendar.YEAR));
		Log.d(""never"", ""L=""+ never.get(Calendar.MONTH) + "" R="" + cal.get(Calendar.MONTH));
		Log.d(""never"", ""L=""+ never.get(Calendar.DAY_OF_MONTH) + "" R="" + cal.get(Calendar.DAY_OF_MONTH));
		Log.d(""never"", ""L=""+ never.get(Calendar.HOUR) + "" R="" + cal.get(Calendar.HOUR));
		Log.d(""never"", ""L=""+ never.get(Calendar.MINUTE) + "" R="" + cal.get(Calendar.MINUTE));
		Log.d(""never"", ""L=""+ never.get(Calendar.SECOND) + "" R="" + cal.get(Calendar.SECOND));

		return (never.get(Calendar.YEAR) == cal.get(Calendar.YEAR)) && 
		(never.get(Calendar.MONTH) == cal.get(Calendar.MONTH)) &&
		(never.get(Calendar.DAY_OF_MONTH) == cal.get(Calendar.DAY_OF_MONTH)) &&
		(never.get(Calendar.HOUR) == cal.get(Calendar.HOUR)) &&
		(never.get(Calendar.MINUTE) == cal.get(Calendar.MINUTE)) &&
		(never.get(Calendar.SECOND) == cal.get(Calendar.SECOND));

	}

	// for tree traversing
	public PwGroupV3 parent = null;


	public PwEntryV3() {
		super();
	}

	/*
	public PwEntryV3(PwEntryV3 source) {
		assign(source);
	}
	*/

	public PwEntryV3(Database db, int parentId) {

		

		parent = (PwGroupV3) db.groups.get(new PwGroupIdV3(parentId));
		groupId = parentId;

		Random random = new Random();
		uuid = new byte[16];
		random.nextBytes(uuid);

		Calendar cal = Calendar.getInstance();
		Date now = cal.getTime();
		tCreation = new PwDate(now);
		tLastAccess = new PwDate(now);
		tLastMod = new PwDate(now);
		tExpire = new PwDate(NEVER_EXPIRE);

	}
	
	public boolean isTan() {
		return title.equals(PMS_TAN_ENTRY);
	}
	
	@Override
	public String getDisplayTitle() {
		if ( isTan() ) {
			return PMS_TAN_ENTRY + "" "" + username;
		} else {
			return title;	
		}
	}

	/**
	 * @return the actual password byte array.
	 */
	@Override
	public String getPassword() {
		return new String(password);
	}
	
	public byte[] getPasswordBytes() {
		return password;
	}


	/**
	 * fill byte array
	 */
	private static void fill(byte[] array, byte value)
	{
		for (int i=0; i<array.length; i++)
			array[i] = value;
		return;
	}

	/** Securely erase old password before copying new. */
	public void setPassword( byte[] buf, int offset, int len ) {
		if( password != null ) {
			fill( password, (byte)0 );
			password = null;
		}
		password = new byte[len];
		System.arraycopy( buf, offset, password, 0, len );
	}



	/**
	 * @return the actual binaryData byte array.
	 */
	public byte[] getBinaryData() {
		return binaryData;
	}



	/** Securely erase old data before copying new. */
	public void setBinaryData( byte[] buf, int offset, int len ) {
		if( binaryData != null ) {
			fill( binaryData, (byte)0 );
			binaryData = null;
		}
		binaryData = new byte[len];
		System.arraycopy( buf, offset, binaryData, 0, len );
	}

	// Determine if this is a MetaStream entry
	@Override
	public boolean isMetaStream() {
		if ( binaryData == null ) return false;
		if ( additional == null || additional.length() == 0 ) return false;
		if ( ! binaryDesc.equals(PMS_ID_BINDESC) ) return false;
		if ( title == null ) return false;
		if ( ! title.equals(PMS_ID_TITLE) ) return false;
		if ( username == null ) return false;
		if ( ! username.equals(PMS_ID_USER) ) return false;
		if ( url == null ) return false;
		if ( ! url.equals(PMS_ID_URL)) return false;
		if ( !icon.isMetaStreamIcon() ) return false;

		return true;
	}

	
	@Override
	public void assign(PwEntry source) {
		
		if ( ! (source instanceof PwEntryV3) ) {
			throw new RuntimeException(""DB version mix"");
		}
		
		super.assign(source);
		
		PwEntryV3 src = (PwEntryV3) source;
		assign(src);
	
	}

	private void assign(PwEntryV3 source) {
		title = source.title;
		url = source.url;
		groupId = source.groupId;
		username = source.username;
		additional = source.additional;
		uuid = source.uuid;

		int passLen = source.password.length;
		password = new byte[passLen]; 
		System.arraycopy(source.password, 0, password, 0, passLen);

		tCreation = (PwDate) source.tCreation.clone();
		tLastMod = (PwDate) source.tLastMod.clone();
		tLastAccess = (PwDate) source.tLastAccess.clone();
		tExpire = (PwDate) source.tExpire.clone();

		binaryDesc = source.binaryDesc;

		if ( source.binaryData != null ) {
			int descLen = source.binaryData.length;
			binaryData = new byte[descLen]; 
			System.arraycopy(source.binaryData, 0, binaryData, 0, descLen);
		}

		parent = source.parent;

	}
	
	@Override
	public Object clone() {
		PwEntryV3 newEntry = (PwEntryV3) super.clone();
		
		int passLen = password.length;
		password = new byte[passLen]; 
		System.arraycopy(password, 0, newEntry.password, 0, passLen);

		newEntry.tCreation = (PwDate) tCreation.clone();
		newEntry.tLastMod = (PwDate) tLastMod.clone();
		newEntry.tLastAccess = (PwDate) tLastAccess.clone();
		newEntry.tExpire = (PwDate) tExpire.clone();
		
		newEntry.binaryDesc = binaryDesc;

		if ( binaryData != null ) {
			int descLen = binaryData.length;
			newEntry.binaryData = new byte[descLen]; 
			System.arraycopy(binaryData, 0, newEntry.binaryData, 0, descLen);
		}

		newEntry.parent = parent;

		
		return newEntry;
	}

	@Override
	public void stampLastAccess() {
		Calendar cal = Calendar.getInstance();
		tLastAccess = new PwDate(cal.getTime());
		
	}

	@Override
	public Date getAccess() {
		return tLastAccess.getJDate();
	}

	@Override
	public Date getCreate() {
		return tCreation.getJDate();
	}

	@Override
	public Date getExpire() {
		return tExpire.getJDate();
	}

	@Override
	public Date getMod() {
		return tLastMod.getJDate();
	}

	@Override
	public PwGroupV3 getParent() {
		return parent;
	}

	@Override
	public UUID getUUID() {
		return Types.bytestoUUID(uuid);
	}

	@Override
	public void setUUID(UUID u) {
		uuid = Types.UUIDtoBytes(u);
	}

	@Override
	public String getUsername() {
		return username;
	}

	@Override
	public String getTitle() {
		return title;
	}

	@Override
	public String getNotes() {
		return additional;
	}

	@Override
	public String getUrl() {
		return url;
	}

	@Override
	public boolean expires() {
		return ! IsNever(tExpire.getJDate());
	}

}
",True,215,8,6,11,43,9,7,L6
68,com.keepassdroid.database.PwEntry.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

import java.util.Comparator;
import java.util.Date;
import java.util.UUID;

public abstract class PwEntry implements Cloneable {

	public static class EntryNameComparator implements Comparator<PwEntry> {

		public int compare(PwEntry object1, PwEntry object2) {
			return object1.getTitle().compareToIgnoreCase(object2.getTitle());
		}
		
	}
	
	public PwIconStandard icon;

	public PwEntry() {
		
	}
	
	@Override
	public Object clone() {
		PwEntry newEntry;
		try {
			newEntry = (PwEntry) super.clone();
		} catch (CloneNotSupportedException e) {
			assert(false);
			throw new RuntimeException(""Clone should be supported"");
		}
		
		return newEntry;
	}
	
	public void assign(PwEntry source) {
		icon = source.icon;
	}
	
	public abstract void stampLastAccess();

	public abstract UUID getUUID();
	public abstract void setUUID(UUID u);
	public abstract String getTitle();
	public abstract String getUsername();
	public abstract String getPassword();
	public abstract String getUrl();
	public abstract String getNotes();
	public abstract Date getCreate();
	public abstract Date getMod();
	public abstract Date getAccess();
	public abstract Date getExpire();
	public abstract boolean expires();
	public abstract PwGroup getParent();
	
	public PwIcon getIcon() {
		return icon;
	}

	public abstract String getDisplayTitle();

	public boolean isMetaStream() {
		return false;
	}

}
",False,82,4,42,2,3,23,3,L2
69,com.keepassdroid.database.PwGroupId.java,"package com.keepassdroid.database;

public abstract class PwGroupId {

}
",False,82,4,49,0,0,9,0,L2
70,com.keepassdroid.database.PwDatabase.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.DigestOutputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.List;

import com.keepassdroid.crypto.finalkey.FinalKey;
import com.keepassdroid.crypto.finalkey.FinalKeyFactory;
import com.keepassdroid.database.exception.InvalidKeyFileException;
import com.keepassdroid.stream.NullOutputStream;

public abstract class PwDatabase {

	public byte masterKey[] = new byte[32];
	public byte[] finalKey;
	public String name = ""KeePass database"";
	public PwGroup rootGroup;
	public PwIconFactory iconFactory = new PwIconFactory();
	
	
	public void makeFinalKey(byte[] masterSeed, byte[] masterSeed2, int numRounds) throws IOException {

		// Write checksum Checksum
		MessageDigest md = null;
		try {
			md = MessageDigest.getInstance(""SHA-256"");
		} catch (NoSuchAlgorithmException e) {
			throw new IOException(""SHA-256 not implemented here."");
		}
		NullOutputStream nos = new NullOutputStream();
		DigestOutputStream dos = new DigestOutputStream(nos, md);

		byte[] transformedMasterKey = transformMasterKey(masterSeed2, masterKey, numRounds); 
		dos.write(masterSeed);
		dos.write(transformedMasterKey);

		finalKey = md.digest();
	}
	
	/**
	 * Encrypt the master key a few times to make brute-force key-search harder
	 * @throws IOException 
	 */
	private static byte[] transformMasterKey( byte[] pKeySeed, byte[] pKey, int rounds ) throws IOException
	{
		FinalKey key = FinalKeyFactory.createFinalKey();
		
		return key.transformMasterKey(pKeySeed, pKey, rounds);
	}


	public abstract byte[] getMasterKey(String key, String keyFileName) throws InvalidKeyFileException, IOException;
	
	public void setMasterKey(String key, String keyFileName)
			throws InvalidKeyFileException, IOException {
				assert( key != null && keyFileName != null );
			
				masterKey = getMasterKey(key, keyFileName);
			}

	protected byte[] getCompositeKey(String key, String keyFileName)
			throws InvalidKeyFileException, IOException {
				assert(key != null && keyFileName != null);
				
				byte[] fileKey = getFileKey(keyFileName);
				
				byte[] passwordKey = getPasswordKey(key);
				
				MessageDigest md;
				try {
					md = MessageDigest.getInstance(""SHA-256"");
				} catch (NoSuchAlgorithmException e) {
					throw new IOException(""SHA-256 not supported"");
				}
				
				md.update(passwordKey);
				
				return md.digest(fileKey);
	}

	protected byte[] getFileKey(String fileName)
			throws InvalidKeyFileException, IOException {
				assert(fileName != null);
				
				File keyfile = new File(fileName);
				
				if ( ! keyfile.exists() ) {
					throw new InvalidKeyFileException(""Key file does not exist."");
				}
				
				byte[] key = loadXmlKeyFile(fileName);
				if ( key != null ) {
					return key;
				}
								
				FileInputStream fis;
				try {
					fis = new FileInputStream(keyfile);
				} catch (FileNotFoundException e) {
					throw new InvalidKeyFileException(""Key file does not exist."");
				}
				
				BufferedInputStream bis = new BufferedInputStream(fis, 64);
				
				long fileSize = keyfile.length();
				if ( fileSize == 0 ) {
					throw new InvalidKeyFileException(""Key file is empty."");
				} else if ( fileSize == 32 ) {
					byte[] outputKey = new byte[32];
					if ( bis.read(outputKey, 0, 32) != 32 ) {
						throw new IOException(""Error reading key."");
					}
					
					return outputKey;
				} else if ( fileSize == 64 ) {
					byte[] hex = new byte[64];
					
					bis.mark(64);
					if ( bis.read(hex, 0, 64) != 64 ) {
						throw new IOException(""Error reading key."");
					}
			
					try {
						return hexStringToByteArray(new String(hex));
					} catch (IndexOutOfBoundsException e) {
						// Key is not base 64, treat it as binary data
						bis.reset();
					}
				}
			
				MessageDigest md;
				try {
					md = MessageDigest.getInstance(""SHA-256"");
				} catch (NoSuchAlgorithmException e) {
					throw new IOException(""SHA-256 not supported"");
				}
				//SHA256Digest md = new SHA256Digest();
				byte[] buffer = new byte[2048];
				int offset = 0;
				
				try {
					while (true) {
						int bytesRead = bis.read(buffer, 0, 2048);
						if ( bytesRead == -1 ) break;  // End of file
						
						md.update(buffer, 0, bytesRead);
						offset += bytesRead;
						
					}
				} catch (Exception e) {
					System.out.println(e.toString());
				}
			
				return md.digest();
			}

	protected abstract byte[] loadXmlKeyFile(String fileName);

	public static byte[] hexStringToByteArray(String s) {
	    int len = s.length();
	    byte[] data = new byte[len / 2];
	    for (int i = 0; i < len; i += 2) {
	        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
	                             + Character.digit(s.charAt(i+1), 16));
	    }
	    return data;
	}

	protected byte[] getPasswordKey(String key, String encoding) throws IOException {
		assert(key!=null);
		
		if ( key.length() == 0 )
		    throw new IllegalArgumentException( ""Key cannot be empty."" );
		
		MessageDigest md;
		try {
			md = MessageDigest.getInstance(""SHA-256"");
		} catch (NoSuchAlgorithmException e) {
			throw new IOException(""SHA-256 not supported"");
		}

		byte[] bKey;
		try {
			bKey = key.getBytes(encoding);
		} catch (UnsupportedEncodingException e) {
			assert false;
			bKey = key.getBytes();
		}
		md.update(bKey, 0, bKey.length );

		return md.digest();
	}
	
	public abstract byte[] getPasswordKey(String key) throws IOException;

	public abstract List<PwGroup> getGrpRoots();
	
	public abstract List<PwGroup> getGroups();

	public abstract List<PwEntry> getEntries();
	
	public abstract long getNumRounds();
	
	public abstract void setNumRounds(long rounds) throws NumberFormatException;
	
	public abstract boolean appSettingsEnabled();
	
	public abstract PwEncryptionAlgorithm getEncAlgorithm();
	
	public void addGroupTo(PwGroup newGroup, PwGroup parent) {
		// Add group to parent group
		if ( parent == null ) {
			parent = rootGroup;
		}
		
		parent.childGroups.add(newGroup);
		newGroup.setParent(parent);
	}
	
	public void removeGroupFrom(PwGroup remove, PwGroup parent) {
		// Remove group from parent group
		parent.childGroups.remove(remove);
	}
	
	public void addEntryTo(PwEntry newEntry, PwGroup parent) {
		// Add entry to parent
		parent.childEntries.add(newEntry);
	}
	
	public void removeEntryFrom(PwEntry remove, PwGroup parent) {
		// Remove entry for parent
		parent.childEntries.remove(remove);
	}

	public abstract PwGroupId newGroupId();
	
	/**
	 * Determine if an id number is already in use
	 * 
	 * @param id
	 *            ID number to check for
	 * @return True if the ID is used, false otherwise
	 */
	protected boolean isGroupIdUsed(PwGroupId id) {
		List<PwGroup> groups = getGroups();
		
		for (int i = 0; i < groups.size(); i++) {
			PwGroup group =groups.get(i);
			if (group.getId().equals(id)) {
				return true;
			}
		}

		return false;
	}
	
	public abstract PwGroup createGroup();
	
}
",True,94,4,37,5,9,20,9,L2
71,com.keepassdroid.database.PwDbHeaderV4.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

import java.io.IOException;
import java.io.InputStream;

import com.keepassdroid.database.exception.InvalidDBVersionException;
import com.keepassdroid.stream.LEDataInputStream;
import com.keepassdroid.utils.Types;

public class PwDbHeaderV4 extends PwDbHeader {
	public static final int DBSIG_PRE2            = 0xB54BFB66;
    public static final int DBSIG_2               = 0xB54BFB67;
    
    private static final int FILE_VERSION_CRITICAL_MASK = 0xFFFF0000;
    private static final int FILE_VERSION_32 =            0x02010100;
    
    private class PwDbHeaderV4Fields {
        public static final byte EndOfHeader = 0;
        @SuppressWarnings(""unused"")
		public static final byte Comment = 1;
        public static final byte CipherID = 2;
        public static final byte CompressionFlags = 3;
        public static final byte MasterSeed = 4;
        public static final byte TransformSeed = 5;
        public static final byte TransformRounds = 6;
        public static final byte EncryptionIV = 7;
        public static final byte ProtectedStreamKey = 8;
        public static final byte StreamStartBytes = 9;
        public static final byte InnerRandomStreamID = 10;

    }
    
    private PwDatabaseV4 db;
    public byte[] protectedStreamKey;
    public byte[] streamStartBytes;
    public CrsAlgorithm innerRandomStream;

    public PwDbHeaderV4(PwDatabaseV4 d) {
    	db = d;
    }

	/** Assumes the input stream is at the beginning of the .kdbx file
	 * @param is
	 * @throws IOException 
	 * @throws InvalidDBVersionException 
	 */
	public void loadFromFile(InputStream is) throws IOException, InvalidDBVersionException {

		int sig1 = LEDataInputStream.readInt(is);
		int sig2 = LEDataInputStream.readInt(is);
		
		if ( ! matchesHeader(sig1, sig2) ) {
			throw new InvalidDBVersionException();
		}
		
		long version = LEDataInputStream.readUInt(is);
		if ( ! validVersion(version) ) {
			throw new InvalidDBVersionException();
		}
		
		boolean done = false;
		while ( ! done ) {
			done = readHeaderField(is);
		}
	}
	
	private boolean readHeaderField(InputStream is) throws IOException {
		byte fieldID = (byte) is.read();
		
		int fieldSize = Types.readShort(is);
		
		byte[] fieldData = null;
		if ( fieldSize > 0 ) {
			fieldData = new byte[fieldSize];
			
			int readSize = is.read(fieldData);
			if ( readSize != fieldSize ) {
				throw new IOException(""Header ended early."");
			}
		}
		
		switch ( fieldID ) {
			case PwDbHeaderV4Fields.EndOfHeader:
				return true;
				
			case PwDbHeaderV4Fields.CipherID:
				setCipher(fieldData);
				break;
				
			case PwDbHeaderV4Fields.CompressionFlags:
				setCompressionFlags(fieldData);
				break;
				
			case PwDbHeaderV4Fields.MasterSeed:
				masterSeed = fieldData;
				break;
				
			case PwDbHeaderV4Fields.TransformSeed:
				transformSeed = fieldData;
				break;
				
			case PwDbHeaderV4Fields.TransformRounds:
				setTransformRounds(fieldData);
				break;
				
			case PwDbHeaderV4Fields.EncryptionIV:
				encryptionIV = fieldData;
				break;
				
			case PwDbHeaderV4Fields.ProtectedStreamKey:
				protectedStreamKey = fieldData;
				break;
				
			case PwDbHeaderV4Fields.StreamStartBytes:
				streamStartBytes = fieldData;
				break;
			
			case PwDbHeaderV4Fields.InnerRandomStreamID:
				setRandomStreamID(fieldData);
				break;
				
			default:
				throw new IOException(""Invalid header type."");
			
		}
		
		return false;
	}
	
	private void setCipher(byte[] pbId) throws IOException {
		if ( pbId == null || pbId.length != 16 ) {
			throw new IOException(""Invalid cipher ID."");
		}
		
		db.dataCipher = Types.bytestoUUID(pbId);
	}
	
	private void setCompressionFlags(byte[] pbFlags) throws IOException {
		if ( pbFlags == null || pbFlags.length != 4 ) {
			throw new IOException(""Invalid compression flags."");
		}
		
		int flag = LEDataInputStream.readInt(pbFlags, 0);
		if ( flag < 0 || flag >= PwCompressionAlgorithm.count ) {
			throw new IOException(""Unrecognized compression flag."");
		}
		
		db.compressionAlgorithm = PwCompressionAlgorithm.fromId(flag);
		
	}
	
	private void setTransformRounds(byte[] rounds) throws IOException {
		if ( rounds == null || rounds.length != 8 ) {
			throw new IOException(""Invalid rounds."");
		}
		
		long rnd = LEDataInputStream.readLong(rounds, 0);
		
		if ( rnd < 0 || rnd > Integer.MAX_VALUE ) {
			//TODO: Actually support really large numbers
			throw new IOException(""Rounds higher than "" + Integer.MAX_VALUE + "" are not currently supported."");
		}
		
		db.numKeyEncRounds = rnd;
		
	}
	
	private void setRandomStreamID(byte[] streamID) throws IOException {
		if ( streamID == null || streamID.length != 4 ) {
			throw new IOException(""Invalid stream id."");
		}
		
		int id = LEDataInputStream.readInt(streamID, 0);
		if ( id < 0 || id >= CrsAlgorithm.count ) {
			throw new IOException(""Invalid stream id."");
		}
		
		innerRandomStream = CrsAlgorithm.fromId(id);
	}
	
	/** Determines if this is a supported version.
	 * 
	 *  A long is needed here to represent the unsigned int since we perform
	 *  arithmetic on it.
	 * @param version
	 * @return
	 */
	private boolean validVersion(long version) {
		
		return ! ((version & FILE_VERSION_CRITICAL_MASK) > (FILE_VERSION_32 & FILE_VERSION_CRITICAL_MASK));
		
	}

	public static boolean matchesHeader(int sig1, int sig2) {
		return (sig1 == PWM_DBSIG_1) && ( (sig2 == DBSIG_2) || (sig2 == DBSIG_2) );
	}
    
}
",False,100,5,33,5,13,2,7,L5
72,com.keepassdroid.database.ITimeLogger.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

import java.util.Date;

public interface ITimeLogger {
	Date getLastModificationTime();
	void setLastModificationTime(Date date);
	
	Date getCreationTime();
	void setCreationTime(Date date);
	
	Date getLastAccessTime();
	void setLastAccessTime(Date date);
	
	Date getExpiryTime();
	void setExpiryTime(Date date);
	
	boolean expires();
	void setExpires(boolean exp);
	
	long getUsageCount();
	void setUsageCount(long count);
	
	Date getLocationChanged();
	void setLocationChanged(Date date);

}
",False,78,6,29,0,0,3,0,L2
73,com.keepassdroid.database.PwCompressionAlgorithm.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

public enum PwCompressionAlgorithm {
	
	None(0),
	Gzip(1);
	
	// Note: We can get away with using int's to store unsigned 32-bit ints
	//       since we won't do arithmetic on these values (also unlikely to
	//       reach
	private final int id;
	public static final int count = 2;
	
	private PwCompressionAlgorithm(int num) {
		id = num;
	}
	
	public static PwCompressionAlgorithm fromId(int num) {
		for ( PwCompressionAlgorithm e : PwCompressionAlgorithm.values() ) {
			if ( e.id == num ) {
				return e;
			}
		}
		
		return null;
	}
	
}
",False,78,6,31,0,0,3,0,L2
74,com.keepassdroid.database.PwDate.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;


import com.keepassdroid.app.App;
import com.keepassdroid.utils.Types;

/** Converting from the C Date format to the Java data format is
 *  expensive when done for every record at once.  I use this class to
 *  allow lazy conversions between the formats.
 * @author bpellin
 *
 */
public class PwDate implements Cloneable {
	
	private static final int DATE_SIZE = 5; 
	
	private boolean cDateBuilt = false;
	private boolean jDateBuilt = false;
	
	private Date jDate;
	private byte[] cDate;
	
	public PwDate(byte[] buf, int offset) {
		cDate = new byte[DATE_SIZE];
		System.arraycopy(buf, offset, cDate, 0, DATE_SIZE);
		cDateBuilt = true;
	}
	
	public PwDate(Date date) {
		jDate = date;
		jDateBuilt = true;
	}
	
	public PwDate(long millis) {
		jDate = new Date(millis);
		jDateBuilt = true;
	}
	
	private PwDate() {
		
	}
	
	@Override
	public Object clone() {
		PwDate copy = new PwDate();
		
		if ( cDateBuilt ) {
			byte[] newC = new byte[DATE_SIZE];
			System.arraycopy(cDate, 0, newC, 0, DATE_SIZE);
			copy.cDate = newC;
			copy.cDateBuilt = true;
		}
		
		if ( jDateBuilt ) {
			copy.jDate = (Date) jDate.clone();
			copy.jDateBuilt = true;
		}
			
		return copy;
	}


	
	public Date getJDate() {
		if ( ! jDateBuilt ) {
			jDate = readTime(cDate, 0, App.getCalendar());
			jDateBuilt = true;
		}
		
		return jDate;
	}
	
	public byte[] getCDate() {
		if ( ! cDateBuilt ) {
			cDate = writeTime(jDate, App.getCalendar());
			cDateBuilt = true;
		}
		
		return cDate;
	}
	
	
	/**
	 * Unpack date from 5 byte format. The five bytes at 'offset' are unpacked
	 * to a java.util.Date instance.
	 */
	public static Date readTime(byte[] buf, int offset, Calendar time) {
		int dw1 = Types.readUByte(buf, offset);
		int dw2 = Types.readUByte(buf, offset + 1);
		int dw3 = Types.readUByte(buf, offset + 2);
		int dw4 = Types.readUByte(buf, offset + 3);
		int dw5 = Types.readUByte(buf, offset + 4);

		// Unpack 5 byte structure to date and time
		int year = (dw1 << 6) | (dw2 >> 2);
		int month = ((dw2 & 0x00000003) << 2) | (dw3 >> 6);

		int day = (dw3 >> 1) & 0x0000001F;
		int hour = ((dw3 & 0x00000001) << 4) | (dw4 >> 4);
		int minute = ((dw4 & 0x0000000F) << 2) | (dw5 >> 6);
		int second = dw5 & 0x0000003F;

		if (time == null) {
			time = Calendar.getInstance();
		}
		// File format is a 1 based month, java Calendar uses a zero based month
		time.set(year, month - 1, day, hour, minute, second);

		return time.getTime();

	}

	public static byte[] writeTime(Date date, Calendar cal) {
		if (date == null) {
			return null;
		}

		byte[] buf = new byte[5];
		if (cal == null) {
			cal = Calendar.getInstance();
		}
		cal.setTime(date);

		int year = cal.get(Calendar.YEAR);
		// File format is a 1 based month, java Calendar uses a zero based month
		int month = cal.get(Calendar.MONTH) + 1;
		int day = cal.get(Calendar.DAY_OF_MONTH);
		int hour = cal.get(Calendar.HOUR_OF_DAY);
		int minute = cal.get(Calendar.MINUTE);
		int second = cal.get(Calendar.SECOND);

		buf[0] = Types.writeUByte(((year >> 6) & 0x0000003F));
		buf[1] = Types.writeUByte(((year & 0x0000003F) << 2)
				| ((month >> 2) & 0x00000003));
		buf[2] = (byte) (((month & 0x00000003) << 6)
				| ((day & 0x0000001F) << 1) | ((hour >> 4) & 0x00000001));
		buf[3] = (byte) (((hour & 0x0000000F) << 4) | ((minute >> 2) & 0x0000000F));
		buf[4] = (byte) (((minute & 0x00000003) << 6) | (second & 0x0000003F));

		return buf;
	}

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null ) {
			return false;
		}
		if ( getClass() != o.getClass() ) {
			return false;
		}
		
		PwDate date = (PwDate) o;
		if ( cDateBuilt && date.cDateBuilt ) {
			return cDate.equals(date.cDate);
		} else if ( jDateBuilt && date.jDateBuilt ) {
			return jDate.equals(date.jDate);
		} else if ( cDateBuilt && date.jDateBuilt ) {
			return Arrays.equals(date.getCDate(), cDate);
		} else {
			return date.getJDate().equals(jDate);
		}
	}

}
",True,217,8,6,12,43,9,2,L6
75,com.keepassdroid.database.PwIconCustom.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

import java.util.UUID;

public class PwIconCustom extends PwIcon {
	public static final PwIconCustom ZERO = new PwIconCustom(PwDatabaseV4.UUID_ZERO, new byte[0]);
	
	public final UUID uuid;
	public byte[] imageData;
	
	public PwIconCustom(UUID u, byte[] data) {
		uuid = u;
		imageData = data;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((uuid == null) ? 0 : uuid.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		PwIconCustom other = (PwIconCustom) obj;
		if (uuid == null) {
			if (other.uuid != null)
				return false;
		} else if (!uuid.equals(other.uuid))
			return false;
		return true;
	}
}
",False,95,5,36,5,11,7,2,L2
76,com.keepassdroid.database.PwEncryptionAlgorithm.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

public enum PwEncryptionAlgorithm {
	
	Rjindal,
	Twofish;
}
",False,78,5,32,0,0,8,0,L2
77,com.keepassdroid.database.PwGroupV3.java,"/*
 * Copyright 2009 Brian Pellin.

This file was derived from

Copyright 2007 Naomaru Itoi <nao@phoneid.org>

This file was derived from 

Java clone of KeePass - A KeePass file viewer for Java
Copyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>

 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
*/

package com.keepassdroid.database;

import java.util.Calendar;
import java.util.Date;
import java.util.List;



/**
 * @author Brian Pellin <bpellin@gmail.com>
 * @author Naomaru Itoi <nao@phoneid.org>
 * @author Bill Zwicky <wrzwicky@pobox.com>
 * @author Dominik Reichl <dominik.reichl@t-online.de>
 */
public class PwGroupV3 extends PwGroup {
  public PwGroupV3() {
  }

	public String toString() {
		return name;
	}

	public static final Date NEVER_EXPIRE = PwEntryV3.NEVER_EXPIRE;
	
	/** Size of byte buffer needed to hold this struct. */
	public static final int BUF_SIZE = 124;

	// for tree traversing
	public PwGroupV3 parent = null;

	public int groupId;

	public PwDate tCreation;
	public PwDate tLastMod;
	public PwDate tLastAccess;
	public PwDate tExpire;

	public int level; // short

	/** Used by KeePass internally, don't use */
	public int flags;
	
	public void setGroups(List<PwGroup> groups) {
		childGroups = groups;
	}
	
	@Override
	public PwGroup getParent() {
		return parent;
	}

	@Override
	public PwGroupId getId() {
		return new PwGroupIdV3(groupId);
	}

	@Override
	public void setId(PwGroupId id) {
		PwGroupIdV3 id3 = (PwGroupIdV3) id;
		groupId = id3.getId();
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public Date getLastMod() {
		return tLastMod.getJDate();
	}

	@Override
	public void setParent(PwGroup prt) {
		parent = (PwGroupV3) prt;
		level = parent.level + 1;
		
	}

	@Override
	public void initNewGroup(String nm, PwGroupId newId) {
		super.initNewGroup(nm, newId);
		
		Date now = Calendar.getInstance().getTime();
		tCreation = new PwDate(now);
		tLastAccess = new PwDate(now);
		tLastMod = new PwDate(now);
		tExpire = new PwDate(PwGroupV3.NEVER_EXPIRE);

	}

}
",False,215,6,8,12,43,11,5,L6
78,com.keepassdroid.database.PwIconStandard.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

public class PwIconStandard extends PwIcon {
	public final int iconId;
	
	public PwIconStandard(int iconId) {
		this.iconId = iconId;
	}

	@Override
	public boolean isMetaStreamIcon() {
		return iconId == 0;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + iconId;
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		PwIconStandard other = (PwIconStandard) obj;
		if (iconId != other.iconId)
			return false;
		return true;
	}
}
",False,81,5,32,1,1,8,1,L2
79,com.keepassdroid.database.PwDatabaseV3.java,"/*

KeePass for J2ME

Copyright 2007 Naomaru Itoi <nao@phoneid.org>

This file was derived from 

Java clone of KeePass - A KeePass file viewer for Java
Copyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

package com.keepassdroid.database;

// Java
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import com.keepassdroid.database.exception.InvalidKeyFileException;

/**
 * @author Naomaru Itoi <nao@phoneid.org>
 * @author Bill Zwicky <wrzwicky@pobox.com>
 * @author Dominik Reichl <dominik.reichl@t-online.de>
 */
public class PwDatabaseV3 extends PwDatabase {
	// TODO: delete ME
	public byte[] postHeader;

	// Constants
	// private static final int PWM_SESSION_KEY_SIZE = 12;

	// Special entry for settings
	public PwEntry metaInfo;

	// all entries
	public List<PwEntry> entries = new ArrayList<PwEntry>();
	// all groups
	public List<PwGroup> groups = new ArrayList<PwGroup>();
	// Algorithm used to encrypt the database
	public PwEncryptionAlgorithm algorithm;
	public int numKeyEncRounds;

	// Debugging entries
	public PwDbHeaderV3 dbHeader;

	@Override
	public PwEncryptionAlgorithm getEncAlgorithm() {
		return algorithm;
	}

	public int getNumKeyEncRecords() {
		return numKeyEncRounds;
	}

	@Override
	public List<PwGroup> getGroups() {
		return groups;
	}

	@Override
	public List<PwEntry> getEntries() {
		return entries;
	}

	public void setGroups(List<PwGroup> grp) {
		groups = grp;
	}

	@Override
	public List<PwGroup> getGrpRoots() {
		int target = 0;
		List<PwGroup> kids = new ArrayList<PwGroup>();
		for (int i = 0; i < groups.size(); i++) {
			PwGroupV3 grp = (PwGroupV3) groups.get(i);
			if (grp.level == target)
				kids.add(grp);
		}
		return kids;
	}

	public int getRootGroupId() {
		for (int i = 0; i < groups.size(); i++) {
			PwGroupV3 grp = (PwGroupV3) groups.get(i);
			if (grp.level == 0) {
				return grp.groupId;
			}
		}

		return -1;
	}

	public List<PwGroup> getGrpChildren(PwGroupV3 parent) {
		int idx = groups.indexOf(parent);
		int target = parent.level + 1;
		List<PwGroup> kids = new ArrayList<PwGroup>();
		while (++idx < groups.size()) {
			PwGroupV3 grp = (PwGroupV3) groups.get(idx);
			if (grp.level < target)
				break;
			else if (grp.level == target)
				kids.add(grp);
		}
		return kids;
	}

	public List<PwEntry> getEntries(PwGroupV3 parent) {
		List<PwEntry> kids = new ArrayList<PwEntry>();
		/*
		 * for( Iterator i = entries.iterator(); i.hasNext(); ) { PwEntryV3 ent
		 * = (PwEntryV3)i.next(); if( ent.groupId == parent.groupId ) kids.add(
		 * ent ); }
		 */
		for (int i = 0; i < entries.size(); i++) {
			PwEntryV3 ent = (PwEntryV3) entries.get(i);
			if (ent.groupId == parent.groupId)
				kids.add(ent);
		}
		return kids;
	}

	public String toString() {
		return name;
	}

	public void constructTree(PwGroupV3 currentGroup) {
		// I'm in root
		if (currentGroup == null) {
			PwGroupV3 root = new PwGroupV3();
			rootGroup = root;

			List<PwGroup> rootChildGroups = getGrpRoots();
			root.setGroups(rootChildGroups);
			root.childEntries = new ArrayList<PwEntry>();
			root.level = -1;
			for (int i = 0; i < rootChildGroups.size(); i++) {
				PwGroupV3 grp = (PwGroupV3) rootChildGroups.get(i);
				grp.parent = root;
				constructTree(grp);
			}
			return;
		}

		// I'm in non-root
		// get child groups
		currentGroup.setGroups(getGrpChildren(currentGroup));
		currentGroup.childEntries = getEntries(currentGroup);

		// set parent in child entries
		for (int i = 0; i < currentGroup.childEntries.size(); i++) {
			PwEntryV3 entry = (PwEntryV3) currentGroup.childEntries.get(i);
			entry.parent = currentGroup;
		}
		// recursively construct child groups
		for (int i = 0; i < currentGroup.childGroups.size(); i++) {
			PwGroupV3 grp = (PwGroupV3) currentGroup.childGroups.get(i);
			grp.parent = currentGroup;
			constructTree((PwGroupV3) currentGroup.childGroups.get(i));
		}
		return;
	}

	/*
	public void removeGroup(PwGroupV3 group) {
		group.parent.childGroups.remove(group);
		groups.remove(group);
	}
	*/

	/**
	 * Generates an unused random group id
	 * 
	 * @return new group id
	 */
	@Override
	public PwGroupIdV3 newGroupId() {
		PwGroupIdV3 newId = new PwGroupIdV3(0);

		Random random = new Random();

		while (true) {
			newId = new PwGroupIdV3(random.nextInt());

			if (!isGroupIdUsed(newId)) break;
		}

		return newId;
	}

	public byte[] getMasterKey(String key, String keyFileName)
			throws InvalidKeyFileException, IOException {
		assert (key != null && keyFileName != null);

		if (key.length() > 0 && keyFileName.length() > 0) {
			return getCompositeKey(key, keyFileName);
		} else if (key.length() > 0) {
			return getPasswordKey(key);
		} else if (keyFileName.length() > 0) {
			return getFileKey(keyFileName);
		} else {
			throw new IllegalArgumentException(""Key cannot be empty."");
		}

	}

	public byte[] getPasswordKey(String key) throws IOException {
		return getPasswordKey(key, ""ISO-8859-1"");
	}
	
	@Override
	protected byte[] loadXmlKeyFile(String fileName) {
		return null;
	}



	@Override
	public long getNumRounds() {
		return numKeyEncRounds;
	}

	@Override
	public void setNumRounds(long rounds) throws NumberFormatException {
		if (rounds > Integer.MAX_VALUE || rounds < Integer.MIN_VALUE) {
			throw new NumberFormatException();
		}

		numKeyEncRounds = (int) rounds;
	}

	@Override
	public boolean appSettingsEnabled() {
		return true;
	}

	@Override
	public void addEntryTo(PwEntry newEntry, PwGroup parent) {
		super.addEntryTo(newEntry, parent);
		
		// Add entry to root entries
		entries.add(newEntry);
		
	}

	@Override
	public void addGroupTo(PwGroup newGroup, PwGroup parent) {
		super.addGroupTo(newGroup, parent);
		
		// Add group to root groups
		groups.add(newGroup);
		
	}

	@Override
	public void removeEntryFrom(PwEntry remove, PwGroup parent) {
		super.removeEntryFrom(remove, parent);
		
		// Remove entry from root entry
		entries.remove(remove);
	}

	@Override
	public void removeGroupFrom(PwGroup remove, PwGroup parent) {
		super.removeGroupFrom(remove, parent);
		
		// Remove group from root entry
		groups.remove(remove);
	}

	@Override
	public PwGroup createGroup() {
		return new PwGroupV3();
	}

}
",True,223,5,9,12,43,14,9,L6
80,com.keepassdroid.database.PwGroupIdV4.java,"package com.keepassdroid.database;

import java.util.UUID;

public class PwGroupIdV4 extends PwGroupId {
	private UUID uuid;
	
	public PwGroupIdV4(UUID u) {
		uuid = u;
	}
	
	@Override
	public boolean equals(Object id) {
		if ( ! (id instanceof PwGroupIdV4) ) {
			return false;
		}
		
		PwGroupIdV4 v4 = (PwGroupIdV4) id;
		
		return uuid.equals(v4.uuid);
	}

	@Override
	public int hashCode() {
		return uuid.hashCode();
	}
	
	public UUID getId() {
		return uuid;
	}

}
",False,79,6,31,1,1,3,1,L2
81,com.keepassdroid.database.PwDbHeader.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

public abstract class PwDbHeader {

	public static final int PWM_DBSIG_1 = 0x9AA2D903;

	/** Seed that gets hashed with the userkey to form the final key */
	public byte masterSeed[];

	/** Used for the dwKeyEncRounds AES transformations */
	public byte transformSeed[];

	/** IV used for content encryption */
	public byte encryptionIV[];
	
}
",False,71,6,30,0,0,7,0,L5
82,com.keepassdroid.database.PwGroupV4.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

import java.util.Date;
import java.util.List;
import java.util.UUID;

public class PwGroupV4 extends PwGroup implements ITimeLogger {

	//public static final int FOLDER_ICON = 48;
	
	public PwGroupV4 parent = null;
	public UUID uuid = PwDatabaseV4.UUID_ZERO;
	public String notes = """";
	public PwIconCustom customIcon = PwIconCustom.ZERO;
	public boolean isExpanded = true;
	public String defaultAutoTypeSequence = """";
	public Boolean enableAutoType = null;
	public Boolean enableSearching = null;
	public UUID lastTopVisibleEntry = PwDatabaseV4.UUID_ZERO;
	private Date parentGroupLastMod;
	private Date creation = PwDatabaseV4.DEFAULT_NOW;
	private Date lastMod = PwDatabaseV4.DEFAULT_NOW;
	private Date lastAccess = PwDatabaseV4.DEFAULT_NOW;
	private Date expireDate = PwDatabaseV4.DEFAULT_NOW;
	private boolean expires = false;
	private long usageCount = 0;
		
	public PwGroupV4() {
		
	}
	
	public void AddGroup(PwGroupV4 subGroup, boolean takeOwnership) {
		AddGroup(subGroup, takeOwnership, false);
	}
	
	public void AddGroup(PwGroupV4 subGroup, boolean takeOwnership, boolean updateLocationChanged) {
		if ( subGroup == null ) throw new RuntimeException(""subGroup"");
		
		childGroups.add(subGroup);
		
		if ( takeOwnership ) subGroup.parent = this;
		
		if ( updateLocationChanged ) subGroup.parentGroupLastMod = new Date(System.currentTimeMillis());
		
	}
	
	public void AddEntry(PwEntryV4 pe, boolean takeOwnership) {
		AddEntry(pe, takeOwnership, false);
	}
	
	public void AddEntry(PwEntryV4 pe, boolean takeOwnership, boolean updateLocationChanged) {
		assert(pe != null);
		
		childEntries.add(pe);
		
		if ( takeOwnership ) pe.parent = this;
		
		if ( updateLocationChanged ) pe.setLocationChanged(new Date(System.currentTimeMillis()));
	}
	
	@Override
	public PwGroup getParent() {
		return parent;
	}
	
	public void buildChildGroupsRecursive(List<PwGroup> list) {
		list.add(this);
		
		for ( int i = 0; i < childGroups.size(); i++) {
			PwGroupV4 child = (PwGroupV4) childGroups.get(i);
			child.buildChildGroupsRecursive(list);
			
		}
	}

	public void buildChildEntriesRecursive(List<PwEntry> list) {
		for ( int i = 0; i < childEntries.size(); i++ ) {
			list.add(childEntries.get(i));
		}
		
		for ( int i = 0; i < childGroups.size(); i++ ) {
			PwGroupV4 child = (PwGroupV4) childGroups.get(i);
			child.buildChildEntriesRecursive(list);
		}
		
	}

	@Override
	public PwGroupId getId() {
		return new PwGroupIdV4(uuid);
	}

	@Override
	public void setId(PwGroupId id) {
		PwGroupIdV4 id4 = (PwGroupIdV4) id;
		uuid = id4.getId();
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public Date getLastMod() {
		return parentGroupLastMod;
	}

	public Date getCreationTime() {
		return creation;
	}

	public Date getExpiryTime() {
		return expireDate;
	}

	public Date getLastAccessTime() {
		return lastAccess;
	}

	public Date getLastModificationTime() {
		return lastMod;
	}

	public Date getLocationChanged() {
		return parentGroupLastMod;
	}

	public long getUsageCount() {
		return usageCount;
	}

	public void setCreationTime(Date date) {
		creation = date;
		
	}

	public void setExpiryTime(Date date) {
		expireDate = date;
	}

	public void setLastAccessTime(Date date) {
		lastAccess = date;
	}

	public void setLastModificationTime(Date date) {
		lastMod = date;
	}

	public void setLocationChanged(Date date) {
		parentGroupLastMod = date;
	}

	public void setUsageCount(long count) {
		usageCount = count;
	}

	public boolean expires() {
		return expires;
	}

	public void setExpires(boolean exp) {
		expires = exp;
	}

	@Override
	public void setParent(PwGroup prt) {
		parent = (PwGroupV4) prt;
		
	}

	@Override
	public PwIcon getIcon() {
		if (customIcon == null || customIcon.uuid.equals(PwDatabaseV4.UUID_ZERO)) {
			return super.getIcon();
		} else {
			return customIcon;
		}
	}

}
",False,94,5,28,5,9,6,9,L2
83,com.keepassdroid.database.PwDbHeaderV3.java,"/*
KeePass for J2ME

Copyright 2007 Naomaru Itoi <nao@phoneid.org>

This file was derived from 

Java clone of KeePass - A KeePass file viewer for Java
Copyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

package com.keepassdroid.database;

import java.io.IOException;

import com.keepassdroid.stream.LEDataInputStream;

public class PwDbHeaderV3 extends PwDbHeader {

	// DB sig from KeePass 1.03
	public static final int DBSIG_2               = 0xB54BFB65;
	// DB sig from KeePass 1.03
	public static final int DBVER_DW              = 0x00030002;

	public static final int FLAG_SHA2             = 1;
	public static final int FLAG_RIJNDAEL         = 2;
	public static final int FLAG_ARCFOUR          = 4;
	public static final int FLAG_TWOFISH          = 8;

	/** Size of byte buffer needed to hold this struct. */
	public static final int BUF_SIZE        = 124;



	public int              signature1;                  // = PWM_DBSIG_1
	public int              signature2;                  // = DBSIG_2
	public int              flags;
	public int              version;

	/** Number of groups in the database */
	public int              numGroups;
	/** Number of entries in the database */
	public int              numEntries;

	/** SHA-256 hash of the database, used for integrity check */
	public byte             contentsHash[] = new byte[32];

	public int              numKeyEncRounds;

	/**
	 * Parse given buf, as read from file.
	 * @param buf
	 * @throws IOException 
	 */
	public void loadFromFile( byte buf[], int offset ) throws IOException {
		signature1 = LEDataInputStream.readInt( buf, offset + 0 );
		signature2 = LEDataInputStream.readInt( buf, offset + 4 );
		flags = LEDataInputStream.readInt( buf, offset + 8 );
		version = LEDataInputStream.readInt( buf, offset + 12 );

		System.arraycopy( buf, offset + 16, masterSeed, 0, 16 );
		System.arraycopy( buf, offset + 32, encryptionIV, 0, 16 );

		numGroups = LEDataInputStream.readInt( buf, offset + 48 );
		numEntries = LEDataInputStream.readInt( buf, offset + 52 );

		System.arraycopy( buf, offset + 56, contentsHash, 0, 32 );

		System.arraycopy( buf, offset + 88, transformSeed, 0, 32 );
		numKeyEncRounds = LEDataInputStream.readInt( buf, offset + 120 );
		if ( numKeyEncRounds < 0 ) {
			// TODO: Really treat this like an unsigned integer
			throw new IOException(""Does not support more than "" + Integer.MAX_VALUE + "" rounds."");
		}
	}

	public PwDbHeaderV3() {
		masterSeed = new byte[16];
		transformSeed = new byte[32];
		encryptionIV = new byte[16];
	}

	public static boolean matchesHeader(int sig1, int sig2) {
		return (sig1 == PWM_DBSIG_1) && (sig2 == DBSIG_2);
	}


}
",False,69,5,30,1,2,6,2,L6
84,com.keepassdroid.database.PwDefsV4.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

public class PwDefsV4 {

	public static final String TITLE_FIELD = ""Title"";

    public static final String USERNAME_FIELD = ""UserName"";

    public static final String PASSWORD_FIELD = ""Password"";

    public static final String URL_FIELD = ""URL"";

    public static final String NOTES_FIELD = ""Notes"";

}
",True,78,6,31,0,0,1,0,L2
85,com.keepassdroid.database.PwIcon.java,"package com.keepassdroid.database;

public abstract class PwIcon {
	
	public boolean isMetaStreamIcon() {
		return false;
	}
	
	public void writeBytes() {
	}
	
}
",False,81,5,33,0,0,7,0,L2
86,com.keepassdroid.database.PwDeletedObject.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

import java.util.Date;
import java.util.UUID;

public class PwDeletedObject {
	public UUID uuid;
	private Date deletionTime;
	
	public Date getDeletionTime() {
		if ( deletionTime == null ) {
			return new Date(System.currentTimeMillis());
		}
		
		return deletionTime;
	}
	
	public void setDeletionTime(Date date) {
		deletionTime = date;
	}
}
",False,78,6,31,0,0,2,0,L2
87,com.keepassdroid.database.PwDatabaseV4.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

import java.io.FileInputStream;
import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

import biz.source_code.base64Coder.Base64Coder;

import com.keepassdroid.database.exception.InvalidKeyFileException;


public class PwDatabaseV4 extends PwDatabase {

	public static final Date DEFAULT_NOW = new Date();
	
	public UUID dataCipher;
	public PwCompressionAlgorithm compressionAlgorithm;
    public long numKeyEncRounds;
    public Date nameChanged;
    public String description;
    public Date descriptionChanged;
    public String defaultUserName;
    public Date defaultUserNameChanged;
    
    public Date keyLastChanged = DEFAULT_NOW;
    public long keyChangeRecDays = -1;
    public long keyChangeForceDays = 1;
    
    public long maintenanceHistoryDays = 365;
    public boolean recycleBinEnabled;
    public UUID recycleBinUUID;
    public Date recycleBinChanged;
    public UUID entryTemplatesGroup;
    public Date entryTemplatesGroupChanged;
    public UUID lastSelectedGroup;
    public UUID lastTopVisibleGroup;
    public MemoryProtectionConfig memoryProtection = new MemoryProtectionConfig();
    public List<PwDeletedObject> deletedObjects = new ArrayList<PwDeletedObject>();
    public List<PwIconCustom> customIcons = new ArrayList<PwIconCustom>();
    public Map<String, String> customData = new HashMap<String, String>();
    
    public class MemoryProtectionConfig {
    	public boolean protectTitle = false;
    	public boolean protectUserName = false;
    	public boolean protectPassword = false;
    	public boolean protectUrl = false;
    	public boolean protectNotes = false;
    	
    	public boolean autoEnableVisualHiding = false;
    	
    	public boolean GetProtection(String field) {
    		if ( field.equalsIgnoreCase(PwDefsV4.TITLE_FIELD)) return protectTitle;
    		if ( field.equalsIgnoreCase(PwDefsV4.USERNAME_FIELD)) return protectUserName;
    		if ( field.equalsIgnoreCase(PwDefsV4.PASSWORD_FIELD)) return protectPassword;
    		if ( field.equalsIgnoreCase(PwDefsV4.URL_FIELD)) return protectUrl;
    		if ( field.equalsIgnoreCase(PwDefsV4.NOTES_FIELD)) return protectNotes;
    		
    		return false;
    	}
    }

    public static final UUID UUID_ZERO = new UUID(0,0);
    
	@Override
	public byte[] getMasterKey(String key, String keyFileName)
			throws InvalidKeyFileException, IOException {
		assert( key != null && keyFileName != null );
		
		byte[] fKey;
		
		if ( key.length() > 0 && keyFileName.length() > 0 ) {
			return getCompositeKey(key, keyFileName);
		} else if ( key.length() > 0 ) {
			fKey =  getPasswordKey(key);
		} else if ( keyFileName.length() > 0 ) {
			fKey = getFileKey(keyFileName);
		} else {
			throw new IllegalArgumentException( ""Key cannot be empty."" );
		}
		
		MessageDigest md;
		try {
			md = MessageDigest.getInstance(""SHA-256"");
		} catch (NoSuchAlgorithmException e) {
			throw new IOException(""No SHA-256 implementation"");
		}
		
		return md.digest(fKey);
	}

    @Override
	public byte[] getPasswordKey(String key) throws IOException {
		return getPasswordKey(key, ""UTF-8"");
	}
    
	private static final String RootElementName = ""KeyFile"";
	//private static final String MetaElementName = ""Meta"";
	//private static final String VersionElementName = ""Version"";
	private static final String KeyElementName = ""Key"";
	private static final String KeyDataElementName = ""Data"";
	
	@Override
	protected byte[] loadXmlKeyFile(String fileName) {
		try {
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			DocumentBuilder db = dbf.newDocumentBuilder();
			FileInputStream fis = new FileInputStream(fileName);
			Document doc = db.parse(fis);
			
			Element el = doc.getDocumentElement();
			if (el == null || ! el.getNodeName().equalsIgnoreCase(RootElementName)) {
				return null;
			}
			
			NodeList children = el.getChildNodes();
			if (children.getLength() < 2) {
				return null;
			}
			
			for ( int i = 0; i < children.getLength(); i++ ) {
				Node child = children.item(i);
				
				if ( child.getNodeName().equalsIgnoreCase(KeyElementName) ) {
					NodeList keyChildren = child.getChildNodes();
					for ( int j = 0; j < keyChildren.getLength(); j++ ) {
						Node keyChild = keyChildren.item(j);
						if ( keyChild.getNodeName().equalsIgnoreCase(KeyDataElementName) ) {
							NodeList children2 = keyChild.getChildNodes();
							for ( int k = 0; k < children2.getLength(); k++) {
								Node text = children2.item(k);
								if (text.getNodeType() == Node.TEXT_NODE) {
									Text txt = (Text) text;
									return Base64Coder.decode(txt.getNodeValue());
								}
							}
						}
					}
				}
			}
		} catch (Exception e) {
			return null;
		}
		return null;
	}

	@Override
	public List<PwGroup> getGroups() {
		List<PwGroup> list = new ArrayList<PwGroup>();
		PwGroupV4 root = (PwGroupV4) rootGroup;
		root.buildChildGroupsRecursive(list);
		
		return list;
	}

	@Override
	public List<PwGroup> getGrpRoots() {
		return rootGroup.childGroups;
	}

	@Override
	public List<PwEntry> getEntries() {
		List<PwEntry> list = new ArrayList<PwEntry>();
		PwGroupV4 root = (PwGroupV4) rootGroup;
		root.buildChildEntriesRecursive(list);
		
		return list;
	}

	@Override
	public long getNumRounds() {
		return numKeyEncRounds;
	}

	@Override
	public void setNumRounds(long rounds) throws NumberFormatException {
		numKeyEncRounds = rounds;
		
	}

	@Override
	public boolean appSettingsEnabled() {
		return false;
	}

	@Override
	public PwEncryptionAlgorithm getEncAlgorithm() {
		return PwEncryptionAlgorithm.Rjindal;
	}

	@Override
	public PwGroupIdV4 newGroupId() {
		PwGroupIdV4 id = new PwGroupIdV4(UUID_ZERO);
		
		while (true) {
			id = new PwGroupIdV4(UUID.randomUUID());
			
			if (!isGroupIdUsed(id)) break;
		}
		
		return id;
	}

	@Override
	public PwGroup createGroup() {
		return new PwGroupV4();
	}
}
",True,94,5,29,4,12,9,12,L2
88,com.keepassdroid.database.CrsAlgorithm.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

public enum CrsAlgorithm {
	
	Null(0),
	ArcFourVariant(1),
	Salsa20(2);
	
	public static final int count = 3;
	private final int id;
	
	private CrsAlgorithm(int num) {
		id = num;
	}

	public static CrsAlgorithm fromId(int num) {
		for ( CrsAlgorithm e : CrsAlgorithm.values() ) {
			if ( e.id == num ) {
				return e;
			}
		}
		
		return null;
	}

}
",False,70,6,33,0,0,2,0,L5
89,com.keepassdroid.database.PwGroup.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

public abstract class PwGroup {
	public List<PwGroup> childGroups = new ArrayList<PwGroup>();
	public List<PwEntry> childEntries = new ArrayList<PwEntry>();
	public String name = """";
	public PwIconStandard icon;

	public abstract PwGroup getParent();
	public abstract void setParent(PwGroup parent);
	
	public abstract PwGroupId getId();
	public abstract void setId(PwGroupId id);

	public abstract String getName();
	
	public abstract Date getLastMod();
	
	public PwIcon getIcon() {
		return icon;
	}

	public void sortGroupsByName() {
		Collections.sort(childGroups, new GroupNameComparator());
	}

	public static class GroupNameComparator implements Comparator<PwGroup> {

		public int compare(PwGroup object1, PwGroup object2) {
			return object1.getName().compareToIgnoreCase(object2.getName());
		}
		
	}
	
	public void sortEntriesByName() {
		Collections.sort(childEntries, new PwEntry.EntryNameComparator());
	}
	
	public void initNewGroup(String nm, PwGroupId newId) {
		setId(newId);
		name = nm;
	}

}
",False,82,4,38,1,4,28,4,L2
90,com.keepassdroid.database.PwEntryV4.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

public class PwEntryV4 extends PwEntry implements ITimeLogger {
	private static final String STR_TITLE = ""Title"";
	private static final String STR_USERNAME = ""UserName"";
	private static final String STR_PASSWORD = ""Password"";
	private static final String STR_URL = ""URL"";
	private static final String STR_NOTES = ""Notes"";
	
	public PwGroupV4 parent;
	public UUID uuid;
	public Map<String, String> strings = new HashMap<String, String>();
	public Map<String, byte[]> binaries = new HashMap<String, byte[]>();
	public PwIconCustom customIcon = PwIconCustom.ZERO;
	public String foregroundColor;
	public String backgroupColor;
	public String overrideURL;
	public AutoType autoType = new AutoType();
	public List<PwEntryV4> history = new ArrayList<PwEntryV4>();
	
	private Date parentGroupLastMod;
	private Date creation;
	private Date lastMod;
	private Date lastAccess;
	private Date expireDate;
	private boolean expires = false;
	private long usageCount = 0;
	public String url;
	public String additional;
	public String tags;

	public class AutoType {
		public boolean enabled;
		public long obfuscationOptions;
		public String defaultSequence;
		
		private Map<String, String> windowSeqPairs = new HashMap<String, String>();
		
		public void put(String key, String value) {
			windowSeqPairs.put(key, value);
		}

	}
	
	public PwEntryV4() {

	}

	@Override
	public void assign(PwEntry source) {
		
		if ( ! (source instanceof PwEntryV4) ) {
			throw new RuntimeException(""DB version mix."");
		}
		
		super.assign(source);
		
		PwEntryV4 src = (PwEntryV4) source;
		assign(src);
	}

	private void assign(PwEntryV4 source) {
		parent = source.parent;
		uuid = source.uuid;
		strings = source.strings;
		binaries = source.binaries;
		customIcon = source.customIcon;
		foregroundColor = source.foregroundColor;
		backgroupColor = source.backgroupColor;
		overrideURL = source.overrideURL;
		autoType = source.autoType;
		history = source.history;
		parentGroupLastMod = source.parentGroupLastMod;
		creation = source.creation;
		lastMod = source.lastMod;
		lastAccess = source.lastAccess;
		expireDate = source.expireDate;
		expires = source.expires;
		usageCount = source.usageCount;
		url = source.url;
		additional = source.additional;
		
	}
	
	@Override
	public Object clone() {
		PwEntryV4 newEntry = (PwEntryV4) super.clone();
		
		return newEntry;
	}

	@Override
	public void stampLastAccess() {
		lastAccess = new Date(System.currentTimeMillis());
	}

	@Override
	public String getUsername() {
		return getString(STR_USERNAME);
	}

	@Override
	public String getTitle() {
		return getString(STR_TITLE);
	}
	
	@Override
	public String getPassword() {
		return getString(STR_PASSWORD);
	}

	@Override
	public Date getAccess() {
		return lastAccess;
	}

	@Override
	public Date getCreate() {
		return creation;
	}

	@Override
	public Date getExpire() {
		return expireDate;
	}

	@Override
	public Date getMod() {
		return lastMod;
	}

	@Override
	public String getDisplayTitle() {
		// TODO: Add TAN support
		return getTitle();
	}

	@Override
	public PwGroupV4 getParent() {
		return parent;
	}

	@Override
	public UUID getUUID() {
		return uuid;
	}


	@Override
	public void setUUID(UUID u) {
		uuid = u;
	}
	
	public String getString(String key) {
		String value = strings.get(key);
		
		if ( value == null ) return new String("""");
		
		return value;
	}

	public Date getCreationTime() {
		return creation;
	}

	public Date getExpiryTime() {
		return expireDate;
	}

	public Date getLastAccessTime() {
		return lastAccess;
	}

	public Date getLastModificationTime() {
		return lastMod;
	}

	public Date getLocationChanged() {
		return parentGroupLastMod;
	}

	public long getUsageCount() {
		return usageCount;
	}

	public void setCreationTime(Date date) {
		creation = date;
		
	}

	public void setExpiryTime(Date date) {
		expireDate = date;
	}

	public void setLastAccessTime(Date date) {
		lastAccess = date;
	}

	public void setLastModificationTime(Date date) {
		lastMod = date;
	}

	public void setLocationChanged(Date date) {
		parentGroupLastMod = date;
	}

	public void setUsageCount(long count) {
		usageCount = count;
	}
	
	@Override
	public boolean expires() {
		return expires;
	}

	public void setExpires(boolean exp) {
		expires = exp;
	}

	@Override
	public String getNotes() {
		return getString(STR_NOTES);
	}

	@Override
	public String getUrl() {
		return getString(STR_URL);
	}

	@Override
	public PwIcon getIcon() {
		if (customIcon == null || customIcon.uuid.equals(PwDatabaseV4.UUID_ZERO)) {
			return super.getIcon();
		} else {
			return customIcon;
		}
		
	}

}
",True,94,6,31,5,11,4,6,L2
91,com.keepassdroid.database.edit.SaveDB.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.edit;

import java.io.IOException;

import com.keepassdroid.Database;
import com.keepassdroid.database.exception.PwDbOutputException;

public class SaveDB extends RunnableOnFinish {
	private Database mDb;
	private boolean mDontSave;

	public SaveDB(Database db, OnFinish finish, boolean dontSave) {
		super(finish);
		
		mDb = db;
		mDontSave = dontSave;
	}

	public SaveDB(Database db, OnFinish finish) {
		super(finish);
		
		mDb = db;
		mDontSave = false;
	}

	@Override
	public void run() {

		if ( ! mDontSave ) {
			try {
				mDb.SaveData();
			} catch (IOException e) {
				finish(false, e.getMessage());
				return;
			} catch (PwDbOutputException e) {
				finish(false, e.getMessage());
				return;
			}
		}

		finish(true);
	}

}
",False,225,5,10,11,43,8,4,L7
92,com.keepassdroid.database.edit.SetPassword.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.edit;

import java.io.IOException;


import com.keepassdroid.Database;
import com.keepassdroid.database.PwDatabase;
import com.keepassdroid.database.exception.InvalidKeyFileException;

public class SetPassword extends RunnableOnFinish {
	
	private String mPassword;
	private String mKeyfile;
	private Database mDb;
	private boolean mDontSave;
	
	public SetPassword(Database db, String password, String keyfile, OnFinish finish) {
		super(finish);
		
		mDb = db;
		mPassword = password;
		mKeyfile = keyfile;
		mDontSave = false;
	}

	public SetPassword(Database db, String password, String keyfile, OnFinish finish, boolean dontSave) {
		super(finish);
		
		mDb = db;
		mPassword = password;
		mKeyfile = keyfile;
		mDontSave = dontSave;
	}

	@Override
	public void run() {
		PwDatabase pm = mDb.pm;
		
		byte[] backupKey = new byte[pm.masterKey.length];
		System.arraycopy(pm.masterKey, 0, backupKey, 0, backupKey.length);

		// Set key
		try {
			pm.setMasterKey(mPassword, mKeyfile);
		} catch (InvalidKeyFileException e) {
			erase(backupKey);
			finish(false, e.getMessage());
			return;
		} catch (IOException e) {
			erase(backupKey);
			finish(false, e.getMessage());
			return;
		}
		
		// Save Database
		mFinish = new AfterSave(backupKey, mFinish);
		SaveDB save = new SaveDB(mDb, mFinish, mDontSave);
		save.run();
	}
	
	private class AfterSave extends OnFinish {
		private byte[] mBackup;
		
		public AfterSave(byte[] backup, OnFinish finish) {
			super(finish);
			
			mBackup = backup;
		}

		@Override
		public void run() {
			if ( ! mSuccess ) {
				// Erase the current master key
				erase(mDb.pm.masterKey);
				mDb.pm.masterKey = mBackup;
			}
			
			super.run();
		}

	}
	
	/** Overwrite the array as soon as we don't need it to avoid keeping the extra data in memory
	 * @param array
	 */
	private void erase(byte[] array) {
		if ( array == null ) return;
		
		for ( int i = 0; i < array.length; i++ ) {
			array[i] = 0;
		}
	}

}
",True,219,5,11,11,43,1,6,L8
93,com.keepassdroid.database.edit.OnFinish.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.edit;

import android.content.Context;
import android.os.Handler;
import android.widget.Toast;

/**
 * Callback after a task is completed.
 * 
 * @author bpellin
 *
 */
public class OnFinish implements Runnable {
	protected boolean mSuccess;
	protected String mMessage;
	
	protected OnFinish mOnFinish;
	protected Handler mHandler;

	public OnFinish() {
	}
	
	public OnFinish(Handler handler) {
		mOnFinish = null;
		mHandler = handler;
	}
	
	public OnFinish(OnFinish finish, Handler handler) {
		mOnFinish = finish;
		mHandler = handler;
	}
	
	public OnFinish(OnFinish finish) {
		mOnFinish = finish;
		mHandler = null;
	}
	
	public void setResult(boolean success, String message) {
		mSuccess = success;
		mMessage = message;
	}
	
	public void setResult(boolean success) {
		mSuccess = success;
	}
	
	public void run() {
		if ( mOnFinish != null ) {
			// Pass on result on call finish
			mOnFinish.setResult(mSuccess, mMessage);
			
			if ( mHandler != null ) {
				mHandler.post(mOnFinish);
			} else {
				mOnFinish.run();
			}
		}
	}
	
	protected void displayMessage(Context ctx) {
		if ( mMessage != null && mMessage.length() > 0 ) {
			Toast.makeText(ctx, mMessage, Toast.LENGTH_LONG).show();
		}
	}

}
",True,40,4,20,0,0,20,0,L7
94,com.keepassdroid.database.edit.CreateDB.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.edit;


import com.keepassdroid.Database;
import com.keepassdroid.app.App;
import com.keepassdroid.database.PwDatabaseV3;
import com.keepassdroid.database.PwEncryptionAlgorithm;

public class CreateDB extends RunnableOnFinish {

	private final int DEFAULT_ENCRYPTION_ROUNDS = 300;
	
	private String mFilename;
	private boolean mDontSave;
	
	public CreateDB(String filename, OnFinish finish, boolean dontSave) {
		super(finish);

		mFilename = filename;
		mDontSave = dontSave;
	}

	@Override
	public void run() {
		// Create new database record
		Database db = new Database();
		App.setDB(db);
		
		// Create the PwDatabaseV3
		PwDatabaseV3 pm = new PwDatabaseV3();
		pm.algorithm = PwEncryptionAlgorithm.Rjindal;
		pm.numKeyEncRounds = DEFAULT_ENCRYPTION_ROUNDS;
		pm.name = ""KeePass Password Manager"";
		// Build the root group
		pm.constructTree(null);
		
		// Set Database state
		db.root = pm.rootGroup;
		db.pm = pm;
		db.mFilename = mFilename;
		db.setLoaded();
		
		// Add a couple default groups
		AddGroup internet = AddGroup.getInstance(db, ""Internet"", 1, pm.rootGroup, null, true);
		internet.run();
		AddGroup email = AddGroup.getInstance(db, ""eMail"", 19, pm.rootGroup, null, true);
		email.run();
		
		// Commit changes
		SaveDB save = new SaveDB(db, mFinish, mDontSave);
		mFinish = null;
		save.run();


	}

}
",True,219,5,12,11,43,1,9,L8
95,com.keepassdroid.database.edit.UpdateEntry.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.edit;

import com.keepassdroid.Database;
import com.keepassdroid.database.PwEntry;
import com.keepassdroid.database.PwGroup;
import com.keepassdroid.search.SearchDbHelper;

public class UpdateEntry extends RunnableOnFinish {
	private Database mDb;
	private PwEntry mOldE;
	private PwEntry mNewE;
	
	public UpdateEntry(Database db, PwEntry oldE, PwEntry newE, OnFinish finish) {
		super(finish);
		
		mDb = db;
		mOldE = oldE;
		mNewE = newE;
		
		// Keep backup of original values in case save fails
		PwEntry backup;
		backup = (PwEntry) mOldE.clone();
		
		mFinish = new AfterUpdate(backup, finish);
	}

	@Override
	public void run() {
		// Update entry with new values
		mOldE.assign(mNewE);
		
		// Commit to disk
		SaveDB save = new SaveDB(mDb, mFinish);
		save.run();
	}
	
	private class AfterUpdate extends OnFinish {
		private PwEntry mBackup;
		
		public AfterUpdate(PwEntry backup, OnFinish finish) {
			super(finish);
			
			mBackup = backup;
		}
		
		@Override
		public void run() {
			if ( mSuccess ) {
				// Mark group dirty if title or icon changes
				if ( ! mBackup.getTitle().equals(mNewE.getTitle()) || ! mBackup.getIcon().equals(mNewE.getIcon()) ) {
					PwGroup parent = mBackup.getParent();
					if ( parent != null ) {
						// Resort entries
						parent.sortEntriesByName();

						// Mark parent group dirty
						mDb.dirty.add(parent);
						
					}
					
					if ( mDb.indexBuilt ) {
						// Update search index
						SearchDbHelper helper = mDb.searchHelper;
						helper.open();
						helper.updateEntry(mOldE);
						helper.close();
					}
				}
			} else {
				// If we fail to save, back out changes to global structure
				mOldE.assign(mBackup);
			}
			
			super.run();
		}
		
	}


}
",True,218,8,6,11,43,1,7,L8
96,com.keepassdroid.database.edit.FileOnFinish.java,"package com.keepassdroid.database.edit;

public class FileOnFinish extends OnFinish {
	private String mFilename = """";
	protected FileOnFinish mOnFinish;
	
	public FileOnFinish(FileOnFinish finish) {
		super(finish);
		
		mOnFinish = finish;
	}
	
	public void setFilename(String filename) {
		mFilename = filename;
	}
	
	public String getFilename() {
		return mFilename;
	}

}
",False,28,4,17,1,1,2,1,L8
97,com.keepassdroid.database.edit.AddGroup.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.edit;

import com.keepassdroid.Database;
import com.keepassdroid.database.PwDatabase;
import com.keepassdroid.database.PwDatabaseV3;
import com.keepassdroid.database.PwGroup;

public class AddGroup extends RunnableOnFinish {
	protected Database mDb;
	private String mName;
	private int mIconID;
	private PwGroup mGroup;
	private PwGroup mParent;
	protected boolean mDontSave;
	
	
	public static AddGroup getInstance(Database db, String name, int iconid, PwGroup parent, OnFinish finish, boolean dontSave) {
		return new AddGroup(db, name, iconid, parent, finish, dontSave);
	}
	
	
	private AddGroup(Database db, String name, int iconid, PwGroup parent, OnFinish finish, boolean dontSave) {
		super(finish);
		
		mDb = db;
		mName = name;
		mIconID = iconid;
		mParent = parent;
		mDontSave = dontSave;
		
		mFinish = new AfterAdd(mFinish);
	}
	
	@Override
	public void run() {
		PwDatabase pm = (PwDatabaseV3) mDb.pm;
		
		// Generate new group
		mGroup = pm.createGroup();
		mGroup.initNewGroup(mName, pm.newGroupId());
		mGroup.icon = mDb.pm.iconFactory.getIcon(mIconID);
		pm.addGroupTo(mGroup, mParent);
		
		//mParent.sortGroupsByName();
		
		// Commit to disk
		SaveDB save = new SaveDB(mDb, mFinish, mDontSave);
		save.run();
	}
	
	private class AfterAdd extends OnFinish {

		public AfterAdd(OnFinish finish) {
			super(finish);
		}

		@Override
		public void run() {
			
			if ( mSuccess ) {
				// Mark parent group dirty
				mDb.dirty.add(mParent);
				
				// Add group to global list
				mDb.groups.put(mGroup.getId(), mGroup);
			} else {
				mDb.pm.removeGroupFrom(mGroup, mParent);
			}
			
			super.run();
		}

	}
	

}
",True,219,6,8,11,43,2,8,L8
98,com.keepassdroid.database.edit.DeleteEntry.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.edit;

import com.keepassdroid.Database;
import com.keepassdroid.database.PwEntry;
import com.keepassdroid.database.PwGroup;
import com.keepassdroid.search.SearchDbHelper;

/** Task to delete entries
 * @author bpellin
 *
 */
public class DeleteEntry extends RunnableOnFinish {

	private Database mDb;
	private PwEntry mEntry;
	private boolean mDontSave;
	
	public DeleteEntry(Database db, PwEntry entry, OnFinish finish) {
		super(finish);
		
		mDb = db;
		mEntry = entry;
		mDontSave = false;
		
	}
	
	public DeleteEntry(Database db, PwEntry entry, OnFinish finish, boolean dontSave) {
		super(finish);
		
		mDb = db;
		mEntry = entry;
		mDontSave = dontSave;
		
	}
	
	@Override
	public void run() {

		// Remove Entry from parent
		PwGroup parent = mEntry.getParent();
		parent.childEntries.remove(mEntry);
		
		// Remove Entry from PwDatabase
		mDb.pm.getEntries().remove(mEntry);
		
		// Save
		mFinish = new AfterDelete(mFinish, parent, mEntry);
		
		// Commit database
		SaveDB save = new SaveDB(mDb, mFinish, mDontSave);
		save.run();
	
		
	}

	private class AfterDelete extends OnFinish {

		private PwGroup mParent;
		private PwEntry mEntry;
		
		public AfterDelete(OnFinish finish, PwGroup parent, PwEntry entry) {
			super(finish);
			
			mParent = parent;
			mEntry = entry;
		}
		
		@Override
		public void run() {
			if ( mSuccess ) {
				if ( mDb.indexBuilt ) {
					SearchDbHelper dbHelper = mDb.searchHelper;
					dbHelper.open();
	
					// Remove from entry global
					mDb.entries.remove(mEntry);
					
					// Remove from search db
					dbHelper.deleteEntry(mEntry);
					dbHelper.close();
				}
				
				// Mark parent dirty
				if ( mParent != null ) {
					mDb.dirty.add(mParent);
				}
			} else {
				mDb.pm.getEntries().add(mEntry);
				
				PwGroup parent = mEntry.getParent();
				if ( parent != null ) {
					parent.childEntries.add(mEntry);
				}
			}

			super.run();
			
		}
		
	}
	
}
",True,218,8,7,11,43,2,8,L8
99,com.keepassdroid.database.edit.DeleteGroup.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.edit;

import java.util.ArrayList;
import java.util.List;

import com.keepassdroid.Database;
import com.keepassdroid.GroupBaseActivity;
import com.keepassdroid.app.App;
import com.keepassdroid.database.PwEntry;
import com.keepassdroid.database.PwGroup;

public class DeleteGroup extends RunnableOnFinish {
	
	private Database mDb;
	private PwGroup mGroup;
	private GroupBaseActivity mAct;
	private boolean mDontSave;
	
	public DeleteGroup(Database db, PwGroup group, GroupBaseActivity act, OnFinish finish) {
		super(finish);
		setMembers(db, group, act, false);
	}
	
	public DeleteGroup(Database db, PwGroup group, GroupBaseActivity act, OnFinish finish, boolean dontSave) {
		super(finish);
		setMembers(db, group, act, dontSave);
	}

	
	public DeleteGroup(Database db, PwGroup group, OnFinish finish, boolean dontSave) {
		super(finish);
		setMembers(db, group, null, dontSave);
	}

	private void setMembers(Database db, PwGroup group, GroupBaseActivity act, boolean dontSave) {
		mDb = db;
		mGroup = group;
		mAct = act;
		mDontSave = dontSave;

		mFinish = new AfterDelete(mFinish);
	}
	
	
	
	@Override
	public void run() {
		
		// Remove child entries
		List<PwEntry> childEnt = new ArrayList<PwEntry>(mGroup.childEntries);
		for ( int i = 0; i < childEnt.size(); i++ ) {
			DeleteEntry task = new DeleteEntry(mDb, childEnt.get(i), null, true);
			task.run();
		}
		
		// Remove child groups
		List<PwGroup> childGrp = new ArrayList<PwGroup>(mGroup.childGroups);
		for ( int i = 0; i < childGrp.size(); i++ ) {
			DeleteGroup task = new DeleteGroup(mDb, childGrp.get(i), mAct, null, true);
			task.run();
		}
		
		
		// Remove from parent
		PwGroup parent = mGroup.getParent();
		if ( parent != null ) {
			parent.childGroups.remove(mGroup);
		}
		
		// Remove from PwDatabaseV3
		mDb.pm.getGroups().remove(mGroup);
		
		// Save
		SaveDB save = new SaveDB(mDb, mFinish, mDontSave);
		save.run();

	}
	
	private class AfterDelete extends OnFinish {
		public AfterDelete(OnFinish finish) {
			super(finish);
		}

		public void run() {
			if ( mSuccess ) {
				// Remove from group global
				mDb.groups.remove(mGroup.getId());
				
				// Remove group from the dirty global (if it is present), not a big deal if this fails
				mDb.dirty.remove(mGroup);
				
				// Mark parent dirty
				PwGroup parent = mGroup.getParent();
				if ( parent != null ) {
					mDb.dirty.add(parent);
				}
			} else {
				// Let's not bother recovering from a failure to save a deleted group.  It is too much work.
				App.setShutdown();
			}
			
			super.run();

		}

	}
}
",True,243,1,1,11,43,2,10,L8
100,com.keepassdroid.database.edit.LoadDB.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.edit;

import java.io.FileNotFoundException;
import java.io.IOException;

import android.content.Context;
import android.content.SharedPreferences;
import android.preference.PreferenceManager;

import com.android.keepass.R;
import com.keepassdroid.Database;
import com.keepassdroid.app.App;
import com.keepassdroid.database.exception.ArcFourException;
import com.keepassdroid.database.exception.InvalidDBException;
import com.keepassdroid.database.exception.InvalidDBSignatureException;
import com.keepassdroid.database.exception.InvalidDBVersionException;
import com.keepassdroid.database.exception.InvalidKeyFileException;
import com.keepassdroid.database.exception.InvalidPasswordException;
import com.keepassdroid.fileselect.FileDbHelper;

public class LoadDB extends RunnableOnFinish {
	private String mFileName;
	private String mPass;
	private String mKey;
	private Database mDb;
	private Context mCtx;
	private boolean mRememberKeyfile;
	
	public LoadDB(Database db, Context ctx, String fileName, String pass, String key, OnFinish finish) {
		super(finish);
		
		mDb = db;
		mCtx = ctx;
		mFileName = fileName;
		mPass = pass;
		mKey = key;
		
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);
		mRememberKeyfile = prefs.getBoolean(ctx.getString(R.string.keyfile_key), ctx.getResources().getBoolean(R.bool.keyfile_default));
	}

	@Override
	public void run() {
		try {
			mDb.LoadData(mCtx, mFileName, mPass, mKey, mStatus);
			
			saveFileData(mFileName, mKey);
		
		} catch (ArcFourException e) {
			finish(false, mCtx.getString(R.string.error_arc4));
			return;
		} catch (InvalidPasswordException e) {
			finish(false, mCtx.getString(R.string.InvalidPassword));
			return;
		} catch (FileNotFoundException e) {
			finish(false, mCtx.getString(R.string.FileNotFound));
			return;
		} catch (IOException e) {
			finish(false, e.getMessage());
			return;
		} catch (InvalidKeyFileException e) {
			finish(false, e.getMessage());
			return;
		} catch (InvalidDBSignatureException e) {
			finish(false, mCtx.getString(R.string.invalid_db_sig));
			return;
		} catch (InvalidDBVersionException e) {
			finish(false, mCtx.getString(R.string.unsupported_db_version));
			return;
		} catch (InvalidDBException e) {
			finish(false, mCtx.getString(R.string.error_invalid_db));
			return;
		} catch (OutOfMemoryError e) {
			finish(false, mCtx.getString(R.string.error_out_of_memory));
			return;
		}
		
		finish(true);
	}
	
	private void saveFileData(String fileName, String key) {
		FileDbHelper db = App.fileDbHelper;
		
		if ( ! mRememberKeyfile ) {
			key = """";
		}
		
		db.createFile(fileName, key);
	}
	


}
",False,217,6,12,11,43,1,11,L8
101,com.keepassdroid.database.edit.RunnableOnFinish.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.edit;

import com.keepassdroid.UpdateStatus;


public abstract class RunnableOnFinish implements Runnable {
	
	public OnFinish mFinish;
	public UpdateStatus mStatus;
	
	public RunnableOnFinish(OnFinish finish) {
		mFinish = finish;
	}
	
	protected void finish(boolean result, String message) {
		if ( mFinish != null ) {
			mFinish.setResult(result, message);
			mFinish.run();
		}
	}
	
	protected void finish(boolean result) {
		if ( mFinish != null ) {
			mFinish.setResult(result);
			mFinish.run();
		}
	}
	
	public void setStatus(UpdateStatus status) {
		mStatus = status;
	}
	
	abstract public void run();
}
",True,40,5,12,1,2,12,2,L7
102,com.keepassdroid.database.edit.BuildIndex.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.edit;

import android.content.Context;

import com.keepassdroid.Database;

public class BuildIndex extends RunnableOnFinish {
	
	private Database mDb;
	private Context mCtx;
	
	public BuildIndex(Database db, Context ctx, OnFinish finish) {
		super(finish);
		
		mDb = db;
		mCtx = ctx.getApplicationContext();
		
	}
	
	@Override
	public void run() {
		mDb.buildSearchIndex(mCtx);
		finish(true);
	}

}
",False,193,1,1,11,43,1,3,L9
103,com.keepassdroid.database.edit.AddEntry.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.edit;

import com.keepassdroid.Database;
import com.keepassdroid.database.PwEntry;
import com.keepassdroid.database.PwGroup;
import com.keepassdroid.search.SearchDbHelper;

public class AddEntry extends RunnableOnFinish {
	protected Database mDb;
	private PwEntry mEntry;
	
	public static AddEntry getInstance(Database db, PwEntry entry, OnFinish finish) {
		return new AddEntry(db, entry, finish);
	}
	
	protected AddEntry(Database db, PwEntry entry, OnFinish finish) {
		super(finish);
		
		mDb = db;
		mEntry = entry;
		
		mFinish = new AfterAdd(mFinish);
	}
	
	@Override
	public void run() {
		mDb.pm.addEntryTo(mEntry, mEntry.getParent());
		
		// Commit to disk
		SaveDB save = new SaveDB(mDb, mFinish);
		save.run();
	}
	
	private class AfterAdd extends OnFinish {

		public AfterAdd(OnFinish finish) {
			super(finish);
		}

		@Override
		public void run() {
			if ( mSuccess ) {
				
				PwGroup parent = mEntry.getParent();

				// Mark parent group dirty
				mDb.dirty.add(parent);
		
				// Add entry to global
				mDb.entries.put(mEntry.getUUID(), mEntry);
				
				if ( mDb.indexBuilt ) {
					// Add entry to search index
					SearchDbHelper helper = mDb.searchHelper;
					helper.open();
					helper.insertEntry(mEntry);
					helper.close();
				}
			} else {
				mDb.pm.removeEntryFrom(mEntry, mEntry.getParent());
			}
			
			super.run();
		}
	}
	

}
",True,218,8,6,11,43,1,8,L8
104,com.keepassdroid.database.exception.InconsistentDBException.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.exception;

public class InconsistentDBException extends Exception {

	public InconsistentDBException(String msg) {
		super(msg);
	}
	
	private static final long serialVersionUID = 4879502365625912291L;

}
",False,1,0,0,0,0,0,0,I0
105,com.keepassdroid.database.exception.InvalidPasswordException.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.exception;

public class InvalidPasswordException extends InvalidDBException {

	/**
	 * 
	 */
	private static final long serialVersionUID = -8729476180242058319L;

	public InvalidPasswordException(String str) {
		super(str);
	}
	
	public InvalidPasswordException() {
		super();
	}
}
",False,69,6,32,1,1,3,1,L5
106,com.keepassdroid.database.exception.InvalidKeyFileException.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */package com.keepassdroid.database.exception;

public class InvalidKeyFileException extends InvalidDBException {
	/**
	 * 
	 */
	private static final long serialVersionUID = 5540694419562294464L;

	public InvalidKeyFileException(String str) {
		super(str);
	}
}
",False,79,5,30,1,1,6,1,L2
107,com.keepassdroid.database.exception.InvalidDBException.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.exception;

public class InvalidDBException extends Exception {

	public InvalidDBException(String str) {
		super(str);
	}

	public InvalidDBException() {
		super();
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 5191964825154190923L;

}
",False,83,4,40,0,0,11,0,L2
108,com.keepassdroid.database.exception.InvalidDBVersionException.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.exception;

public class InvalidDBVersionException extends InvalidDBException {
	/**
	 * 
	 */
	private static final long serialVersionUID = -4260650987856400586L;

	public InvalidDBVersionException() {
		super();
	}

}",False,70,6,32,1,1,3,1,L5
109,com.keepassdroid.database.exception.ArcFourException.java,"/*
 * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.exception;

public class ArcFourException extends InvalidDBException {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2103983626687861237L;

}
",False,69,6,32,1,1,2,1,L5
110,com.keepassdroid.database.exception.PwDbOutputException.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.exception;

public class PwDbOutputException extends Exception {
	public PwDbOutputException(String string) {
		super(string);
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 3321212743159473368L;
}
",False,66,5,32,0,0,5,0,L6
111,com.keepassdroid.database.exception.InvalidDBSignatureException.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.exception;

public class InvalidDBSignatureException extends InvalidDBException {
	/**
	 * 
	 */
	private static final long serialVersionUID = -5358923878743513758L;

	public InvalidDBSignatureException() {
		super();
	}

}
",False,67,5,32,1,1,3,1,L6
112,com.keepassdroid.database.load.ImporterV4.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.load;

import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.Stack;
import java.util.UUID;
import java.util.zip.GZIPInputStream;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;

import org.bouncycastle.crypto.StreamCipher;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlPullParserFactory;

import biz.source_code.base64Coder.Base64Coder;

import com.keepassdroid.UpdateStatus;
import com.keepassdroid.crypto.CipherFactory;
import com.keepassdroid.crypto.PwStreamCipherFactory;
import com.keepassdroid.database.ITimeLogger;
import com.keepassdroid.database.PwCompressionAlgorithm;
import com.keepassdroid.database.PwIconCustom;
import com.keepassdroid.database.PwDatabaseV4;
import com.keepassdroid.database.PwDbHeaderV4;
import com.keepassdroid.database.PwDeletedObject;
import com.keepassdroid.database.PwEntryV4;
import com.keepassdroid.database.PwGroupV4;
import com.keepassdroid.database.exception.ArcFourException;
import com.keepassdroid.database.exception.InvalidDBException;
import com.keepassdroid.database.exception.InvalidPasswordException;
import com.keepassdroid.stream.BetterCipherInputStream;
import com.keepassdroid.stream.HashedBlockInputStream;
import com.keepassdroid.stream.LEDataInputStream;
import com.keepassdroid.utils.Types;

public class ImporterV4 extends Importer {
	
	private StreamCipher randomStream;
	private PwDatabaseV4 db;

	@Override
	public PwDatabaseV4 openDatabase(InputStream inStream, String password,
			String keyfile) throws IOException, InvalidDBException {

		return openDatabase(inStream, password, keyfile, new UpdateStatus());
	}
	
	@Override
	public PwDatabaseV4 openDatabase(InputStream inStream, String password,
			String keyfile, UpdateStatus status) throws IOException,
			InvalidDBException {

		db = new PwDatabaseV4();
		
		PwDbHeaderV4 header = new PwDbHeaderV4(db);
		
		header.loadFromFile(inStream);
			
		db.setMasterKey(password, keyfile);
		db.makeFinalKey(header.masterSeed, header.transformSeed, (int)db.numKeyEncRounds);
		
		// Attach decryptor
		Cipher cipher;
		try {
			cipher = CipherFactory.getInstance(db.dataCipher, db.finalKey, header.encryptionIV);
		} catch (NoSuchAlgorithmException e) {
			throw new IOException(""Invalid algorithm."");
		} catch (NoSuchPaddingException e) {
			throw new IOException(""Invalid algorithm."");
		} catch (InvalidKeyException e) {
			throw new IOException(""Invalid algorithm."");
		} catch (InvalidAlgorithmParameterException e) {
			throw new IOException(""Invalid algorithm."");
		}
		
		InputStream decrypted = new BetterCipherInputStream(inStream, cipher, 50 * 1024);
		LEDataInputStream dataDecrypted = new LEDataInputStream(decrypted);
		byte[] storedStartBytes = dataDecrypted.readBytes(32);
		if ( storedStartBytes == null || storedStartBytes.length != 32 ) {
			throw new IOException(""Invalid data."");
		}
		
		if ( ! Arrays.equals(storedStartBytes, header.streamStartBytes) ) {
			throw new InvalidPasswordException();
		}

		HashedBlockInputStream hashed = new HashedBlockInputStream(dataDecrypted); 
		
		InputStream decompressed;
		if ( db.compressionAlgorithm == PwCompressionAlgorithm.Gzip ) {
			decompressed = new GZIPInputStream(hashed); 
		} else {
			decompressed = hashed;
		}
		
		if ( header.protectedStreamKey == null ) {
			assert(false);
			throw new IOException(""Invalid stream key."");
		}
		
		randomStream = PwStreamCipherFactory.getInstance(header.innerRandomStream, header.protectedStreamKey);
		
		if ( randomStream == null ) {
			throw new ArcFourException();
		}
		
		ReadXmlStreamed(decompressed);

		return db;
		
		
	}
	
	private enum KdbContext {
        Null,
        KeePassFile,
        Meta,
        Root,
        MemoryProtection,
        CustomIcons,
        CustomIcon,
        CustomData,
        CustomDataItem,
        RootDeletedObjects,
        DeletedObject,
        Group,
        GroupTimes,
        Entry,
        EntryTimes,
        EntryString,
        EntryBinary,
        EntryAutoType,
        EntryAutoTypeItem,
        EntryHistory
	}
	
    private static final String ElemDocNode = ""KeePassFile"";
    private static final String ElemMeta = ""Meta"";
    private static final String ElemRoot = ""Root"";
    private static final String ElemGroup = ""Group"";
    private static final String ElemEntry = ""Entry"";

    private static final String ElemGenerator = ""Generator"";
    private static final String ElemDbName = ""DatabaseName"";
    private static final String ElemDbNameChanged = ""DatabaseNameChanged"";
    private static final String ElemDbDesc = ""DatabaseDescription"";
    private static final String ElemDbDescChanged = ""DatabaseDescriptionChanged"";
    private static final String ElemDbDefaultUser = ""DefaultUserName"";
    private static final String ElemDbDefaultUserChanged = ""DefaultUserNameChanged"";
    private static final String ElemDbMntncHistoryDays = ""MaintenanceHistoryDays"";
    private static final String ElemDbKeyChanged = ""MasterKeyChanged"";
    private static final String ElemDbKeyChangeRec = ""MasterKeyChangeRec"";
    private static final String ElemDbKeyChangeForce = ""MasterKeyChangeForce"";
    private static final String ElemRecycleBinEnabled = ""RecycleBinEnabled"";
    private static final String ElemRecycleBinUuid = ""RecycleBinUUID"";
    private static final String ElemRecycleBinChanged = ""RecycleBinChanged"";
    private static final String ElemEntryTemplatesGroup = ""EntryTemplatesGroup"";
    private static final String ElemEntryTemplatesGroupChanged = ""EntryTemplatesGroupChanged"";
    private static final String ElemLastSelectedGroup = ""LastSelectedGroup"";
    private static final String ElemLastTopVisibleGroup = ""LastTopVisibleGroup"";

    private static final String ElemMemoryProt = ""MemoryProtection"";
    private static final String ElemProtTitle = ""ProtectTitle"";
    private static final String ElemProtUserName = ""ProtectUserName"";
    private static final String ElemProtPassword = ""ProtectPassword"";
    private static final String ElemProtURL = ""ProtectURL"";
    private static final String ElemProtNotes = ""ProtectNotes"";
    private static final String ElemProtAutoHide = ""AutoEnableVisualHiding"";

    private static final String ElemCustomIcons = ""CustomIcons"";
    private static final String ElemCustomIconItem = ""Icon"";
    private static final String ElemCustomIconItemID = ""UUID"";
    private static final String ElemCustomIconItemData = ""Data"";

    private static final String ElemAutoType = ""AutoType"";
    private static final String ElemHistory = ""History"";

    private static final String ElemName = ""Name"";
    private static final String ElemNotes = ""Notes"";
    private static final String ElemUuid = ""UUID"";
    private static final String ElemIcon = ""IconID"";
    private static final String ElemCustomIconID = ""CustomIconUUID"";
    private static final String ElemFgColor = ""ForegroundColor"";
    private static final String ElemBgColor = ""BackgroundColor"";
    private static final String ElemOverrideUrl = ""OverrideURL"";
    private static final String ElemTimes = ""Times"";
    private static final String ElemTags = ""Tags"";

    private static final String ElemCreationTime = ""CreationTime"";
    private static final String ElemLastModTime = ""LastModificationTime"";
    private static final String ElemLastAccessTime = ""LastAccessTime"";
    private static final String ElemExpiryTime = ""ExpiryTime"";
    private static final String ElemExpires = ""Expires"";
    private static final String ElemUsageCount = ""UsageCount"";
    private static final String ElemLocationChanged = ""LocationChanged"";

    private static final String ElemGroupDefaultAutoTypeSeq = ""DefaultAutoTypeSequence"";
    private static final String ElemEnableAutoType = ""EnableAutoType"";
    private static final String ElemEnableSearching = ""EnableSearching"";

    private static final String ElemString = ""String"";
    private static final String ElemBinary = ""Binary"";
    private static final String ElemKey = ""Key"";
    private static final String ElemValue = ""Value"";

    private static final String ElemAutoTypeEnabled = ""Enabled"";
    private static final String ElemAutoTypeObfuscation = ""DataTransferObfuscation"";
    private static final String ElemAutoTypeDefaultSeq = ""DefaultSequence"";
    private static final String ElemAutoTypeItem = ""Association"";
    private static final String ElemWindow = ""Window"";
    private static final String ElemKeystrokeSequence = ""KeystrokeSequence"";

    private static final String AttrProtected = ""Protected"";

    private static final String ElemIsExpanded = ""IsExpanded"";
    private static final String ElemLastTopVisibleEntry = ""LastTopVisibleEntry"";

    private static final String ElemDeletedObjects = ""DeletedObjects"";
    private static final String ElemDeletedObject = ""DeletedObject"";
    private static final String ElemDeletionTime = ""DeletionTime"";

    @SuppressWarnings(""unused"")
	private static final String ValFalse = ""False"";
    private static final String ValTrue = ""True"";

    private static final String ElemCustomData = ""CustomData"";
    private static final String ElemStringDictExItem = ""Item"";
    
    private static final long DEFAULT_HISTORY_DAYS = 365;

	
	private boolean readNextNode = true;
	private Stack<PwGroupV4> ctxGroups = new Stack<PwGroupV4>();
	private PwGroupV4 ctxGroup = null;
	private PwEntryV4 ctxEntry = null;
	private String ctxStringName = null;
	private String ctxStringValue = null;
	private String ctxBinaryName = null;
	private byte[] ctxBinaryValue = null;
	private String ctxATName = null;
	private String ctxATSeq = null;
	private boolean entryInHistory = false;
	private PwEntryV4 ctxHistoryBase = null;
	private PwDeletedObject ctxDeletedObject = null;
	private UUID customIconID = PwDatabaseV4.UUID_ZERO;
	private byte[] customIconData;
	private String customDataKey = null;
	private String customDataValue = null;
	
	private void ReadXmlStreamed(InputStream readerStream) throws IOException {
		
			try {
				ReadDocumentStreamed(CreatePullParser(readerStream));
			} catch (XmlPullParserException e) {
				e.printStackTrace();
				throw new IOException(e.getLocalizedMessage());
			}
	}
	
	private static XmlPullParser CreatePullParser(InputStream readerStream) throws XmlPullParserException {
		XmlPullParserFactory xppf = XmlPullParserFactory.newInstance();
		xppf.setNamespaceAware(false);
		
		XmlPullParser xpp = xppf.newPullParser();
		xpp.setInput(readerStream, null);
		
		return xpp;
	}

	private void ReadDocumentStreamed(XmlPullParser xpp) throws XmlPullParserException, IOException {

		ctxGroups.clear();
		
		KdbContext ctx = KdbContext.Null;
		
		readNextNode = true;
		
		while (true) {
			if ( readNextNode ) {
				if( xpp.next() == XmlPullParser.END_DOCUMENT ) break;
			} else {
				readNextNode = true;
			}
			
			switch ( xpp.getEventType() ) {
			case XmlPullParser.START_TAG:
				ctx = ReadXmlElement(ctx, xpp);
				break;
				
			case XmlPullParser.END_TAG:
				ctx = EndXmlElement(ctx, xpp);
				break;
				
			default:
				assert(false);
				break;
					
			}
			
		}
		
		// Error checks
		if ( ctx != KdbContext.Null ) throw new IOException(""Malformed"");
		if ( ctxGroups.size() != 0 ) throw new IOException(""Malformed"");
	}


	private KdbContext ReadXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException, IOException {
		String name = xpp.getName();
		switch (ctx) {
		case Null:
			if ( name.equalsIgnoreCase(ElemDocNode) ) {
				return SwitchContext(ctx, KdbContext.KeePassFile, xpp);
			} else ReadUnknown(xpp);
			break;
			
		case KeePassFile:
			if ( name.equalsIgnoreCase(ElemMeta) ) {
				return SwitchContext(ctx, KdbContext.Meta, xpp);
			} else if ( name.equalsIgnoreCase(ElemRoot) ) {
				return SwitchContext(ctx, KdbContext.Root, xpp);
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case Meta:
			if ( name.equalsIgnoreCase(ElemGenerator) ) {
				ReadString(xpp); // Ignore
			} else if ( name.equalsIgnoreCase(ElemDbName) ) {
				db.name = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemDbNameChanged) ) {
				db.nameChanged = ReadTime(xpp);
			} else if ( name.equalsIgnoreCase(ElemDbDesc) ) {
				db.description = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemDbDescChanged) ) {
				db.descriptionChanged = ReadTime(xpp);
			} else if ( name.equalsIgnoreCase(ElemDbDefaultUser) ) {
				db.defaultUserName = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemDbDefaultUserChanged) ) {
				db.defaultUserNameChanged = ReadTime(xpp);
			} else if ( name.equalsIgnoreCase(ElemDbMntncHistoryDays) ) {
				db.maintenanceHistoryDays = ReadUInt(xpp, DEFAULT_HISTORY_DAYS);
			} else if ( name.equalsIgnoreCase(ElemDbKeyChanged) ) {
				db.keyLastChanged = ReadTime(xpp);
			} else if ( name.equalsIgnoreCase(ElemDbKeyChangeRec) ) {
				db.keyChangeRecDays = ReadLong(xpp, -1);
			} else if ( name.equalsIgnoreCase(ElemDbKeyChangeForce) ) {
				db.keyChangeForceDays = ReadLong(xpp, -1);
			} else if ( name.equalsIgnoreCase(ElemMemoryProt) ) {
				return SwitchContext(ctx, KdbContext.MemoryProtection, xpp);
			} else if ( name.equalsIgnoreCase(ElemCustomIcons) ) {
				return SwitchContext(ctx, KdbContext.CustomIcons, xpp);
			} else if ( name.equalsIgnoreCase(ElemRecycleBinEnabled) ) {
				db.recycleBinEnabled = ReadBool(xpp, true);
			} else if ( name.equalsIgnoreCase(ElemRecycleBinUuid) ) {
				db.recycleBinUUID = ReadUuid(xpp);
			} else if ( name.equalsIgnoreCase(ElemRecycleBinChanged) ) {
				db.recycleBinChanged = ReadTime(xpp);
			} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroup) ) {
				db.entryTemplatesGroup = ReadUuid(xpp);
			} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroupChanged) ) {
				db.entryTemplatesGroupChanged = ReadTime(xpp);
			} else if ( name.equalsIgnoreCase(ElemLastSelectedGroup) ) {
				db.lastSelectedGroup = ReadUuid(xpp);
			} else if ( name.equalsIgnoreCase(ElemLastTopVisibleGroup) ) {
				db.lastTopVisibleGroup = ReadUuid(xpp);
			} else if ( name.equalsIgnoreCase(ElemCustomData) ) {
				return SwitchContext(ctx, KdbContext.CustomData, xpp);
			}
			break;
			
		case MemoryProtection:
			if ( name.equalsIgnoreCase(ElemProtTitle) ) {
				db.memoryProtection.protectTitle = ReadBool(xpp, false);
			} else if ( name.equalsIgnoreCase(ElemProtUserName) ) {
				db.memoryProtection.protectUserName = ReadBool(xpp, false);
			} else if ( name.equalsIgnoreCase(ElemProtPassword) ) {
				db.memoryProtection.protectPassword = ReadBool(xpp, false);
			} else if ( name.equalsIgnoreCase(ElemProtURL) ) {
				db.memoryProtection.protectUrl = ReadBool(xpp, false);
			} else if ( name.equalsIgnoreCase(ElemProtNotes) ) {
				db.memoryProtection.protectNotes = ReadBool(xpp, false);
			} else if ( name.equalsIgnoreCase(ElemProtAutoHide) ) {
				db.memoryProtection.autoEnableVisualHiding = ReadBool(xpp, false);
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case CustomIcons:
			if ( name.equalsIgnoreCase(ElemCustomIconItem) ) {
				return SwitchContext(ctx, KdbContext.CustomIcon, xpp);
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case CustomIcon:
			if ( name.equalsIgnoreCase(ElemCustomIconItemID) ) {
				customIconID = ReadUuid(xpp);
			} else if ( name.equalsIgnoreCase(ElemCustomIconItemData) ) {
				String strData = ReadString(xpp);
				if ( strData != null && strData.length() > 0 ) {
					customIconData = Base64Coder.decode(strData);
				} else {
					assert(false);
				}
			} else {
				ReadUnknown(xpp);
			}
			break;

		case CustomData:
			if ( name.equalsIgnoreCase(ElemStringDictExItem) ) {
				return SwitchContext(ctx, KdbContext.CustomDataItem, xpp);
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case CustomDataItem:
			if ( name.equalsIgnoreCase(ElemKey) ) {
				customDataKey = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemValue) ) {
				customDataValue = ReadString(xpp);
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case Root:
			if ( name.equalsIgnoreCase(ElemGroup) ) {
				assert(ctxGroups.size() == 0);
				if ( ctxGroups.size() != 0 ) throw new IOException(""Group list should be empty."");
				
				db.rootGroup = new PwGroupV4();
				ctxGroups.push((PwGroupV4)db.rootGroup);
				ctxGroup = ctxGroups.peek();
				
				return SwitchContext(ctx, KdbContext.Group, xpp);
			} else if ( name.equalsIgnoreCase(ElemDeletedObjects) ) {
				return SwitchContext(ctx, KdbContext.RootDeletedObjects, xpp);
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case Group:
			if ( name.equalsIgnoreCase(ElemUuid) ) {
				ctxGroup.uuid = ReadUuid(xpp);
			} else if ( name.equalsIgnoreCase(ElemName) ) {
				ctxGroup.name = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemNotes) ) {
				ctxGroup.notes = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemIcon) ) {
				ctxGroup.icon = db.iconFactory.getIcon((int)ReadUInt(xpp, 0));
			} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {
				ctxGroup.customIcon = db.iconFactory.getIcon(ReadUuid(xpp));
			} else if ( name.equalsIgnoreCase(ElemTimes) ) {
				return SwitchContext(ctx, KdbContext.GroupTimes, xpp);
			} else if ( name.equalsIgnoreCase(ElemIsExpanded) ) {
				ctxGroup.isExpanded = ReadBool(xpp, true);
			} else if ( name.equalsIgnoreCase(ElemGroupDefaultAutoTypeSeq) ) {
				ctxGroup.defaultAutoTypeSequence = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemEnableAutoType) ) {
				ctxGroup.enableAutoType = StringToBoolean(ReadString(xpp));
			} else if ( name.equalsIgnoreCase(ElemEnableSearching) ) {
				ctxGroup.enableSearching = StringToBoolean(ReadString(xpp));
			} else if ( name.equalsIgnoreCase(ElemLastTopVisibleEntry) ) {
				ctxGroup.lastTopVisibleEntry = ReadUuid(xpp);
			} else if ( name.equalsIgnoreCase(ElemGroup) ) {
				ctxGroup = new PwGroupV4();
				ctxGroups.peek().AddGroup(ctxGroup, true);
				ctxGroups.push(ctxGroup);
				
				return SwitchContext(ctx, KdbContext.Group, xpp);
			} else if ( name.equalsIgnoreCase(ElemEntry) ) {
				ctxEntry = new PwEntryV4();
				ctxGroup.AddEntry(ctxEntry, true);
				
				entryInHistory = false;
				return SwitchContext(ctx, KdbContext.Entry, xpp);
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case Entry:
			if ( name.equalsIgnoreCase(ElemUuid) ) {
				ctxEntry.setUUID(ReadUuid(xpp));
			} else if ( name.equalsIgnoreCase(ElemIcon) ) {
				ctxEntry.icon = db.iconFactory.getIcon((int)ReadUInt(xpp, 0));
			} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {
				ctxEntry.customIcon = db.iconFactory.getIcon(ReadUuid(xpp));
			} else if ( name.equalsIgnoreCase(ElemFgColor) ) {
				ctxEntry.foregroundColor = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemBgColor) ) {
				ctxEntry.backgroupColor = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemOverrideUrl) ) {
				ctxEntry.overrideURL = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemTags) ) {
				ctxEntry.tags = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemTimes) ) {
				return SwitchContext(ctx, KdbContext.EntryTimes, xpp);
			} else if ( name.equalsIgnoreCase(ElemString) ) {
				return SwitchContext(ctx, KdbContext.EntryString, xpp);
			} else if ( name.equalsIgnoreCase(ElemBinary) ) {
				return SwitchContext(ctx, KdbContext.EntryBinary, xpp);
			} else if ( name.equalsIgnoreCase(ElemAutoType) ) {
				return SwitchContext(ctx, KdbContext.EntryAutoType, xpp);
			} else if ( name.equalsIgnoreCase(ElemHistory) ) {
				assert(!entryInHistory);
				
				if ( ! entryInHistory ) {
					ctxHistoryBase = ctxEntry;
					return SwitchContext(ctx, KdbContext.EntryHistory, xpp);
				} else {
					ReadUnknown(xpp);
				}
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case GroupTimes:
		case EntryTimes:
			ITimeLogger tl;
			if ( ctx == KdbContext.GroupTimes ) {
				tl = ctxGroup;
			} else {
				tl = ctxEntry;
			}
			
			if ( name.equalsIgnoreCase(ElemLastModTime) ) {
				tl.setLastModificationTime(ReadTime(xpp));
			} else if ( name.equalsIgnoreCase(ElemCreationTime) ) {
				tl.setCreationTime(ReadTime(xpp));
			} else if ( name.equalsIgnoreCase(ElemLastAccessTime) ) {
				tl.setLastAccessTime(ReadTime(xpp));
			} else if ( name.equalsIgnoreCase(ElemExpiryTime) ) {
				tl.setExpiryTime(ReadTime(xpp));
			} else if ( name.equalsIgnoreCase(ElemExpires) ) {
				tl.setExpires(ReadBool(xpp, false));
			} else if ( name.equalsIgnoreCase(ElemUsageCount) ) {
				tl.setUsageCount(ReadULong(xpp, 0));
			} else if ( name.equalsIgnoreCase(ElemLocationChanged) ) {
				tl.setLocationChanged(ReadTime(xpp));
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case EntryString:
			if ( name.equalsIgnoreCase(ElemKey) ) {
				ctxStringName = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemValue) ) {
				ctxStringValue = ReadProtectedString(xpp); 
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case EntryBinary:
			if ( name.equalsIgnoreCase(ElemKey) ) {
				ctxBinaryName = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemValue) ) {
				ctxBinaryValue = ReadProtectedBinary(xpp);
			}
			break;
			
		case EntryAutoType:
			if ( name.equalsIgnoreCase(ElemAutoTypeEnabled) ) {
				ctxEntry.autoType.enabled = ReadBool(xpp, true);
			} else if ( name.equalsIgnoreCase(ElemAutoTypeObfuscation) ) {
				ctxEntry.autoType.obfuscationOptions = ReadUInt(xpp, 0);
			} else if ( name.equalsIgnoreCase(ElemAutoTypeDefaultSeq) ) {
				ctxEntry.autoType.defaultSequence = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemAutoTypeItem) ) {
				return SwitchContext(ctx, KdbContext.EntryAutoTypeItem, xpp);
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case EntryAutoTypeItem:
			if ( name.equalsIgnoreCase(ElemWindow) ) {
				ctxATName = ReadString(xpp);
			} else if ( name.equalsIgnoreCase(ElemKeystrokeSequence) ) {
				ctxATSeq = ReadString(xpp);
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case EntryHistory:
			if ( name.equalsIgnoreCase(ElemEntry) ) {
				ctxEntry = new PwEntryV4();
				ctxHistoryBase.history.add(ctxEntry);
				
				entryInHistory = true;
				return SwitchContext(ctx, KdbContext.Entry, xpp);
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case RootDeletedObjects:
			if ( name.equalsIgnoreCase(ElemDeletedObject) ) {
				ctxDeletedObject = new PwDeletedObject();
				db.deletedObjects.add(ctxDeletedObject);
				
				return SwitchContext(ctx, KdbContext.DeletedObject, xpp);
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		case DeletedObject:
			if ( name.equalsIgnoreCase(ElemUuid) ) {
				ctxDeletedObject.uuid = ReadUuid(xpp);
			} else if ( name.equalsIgnoreCase(ElemDeletionTime) ) {
				ctxDeletedObject.setDeletionTime(ReadTime(xpp));
			} else {
				ReadUnknown(xpp);
			}
			break;
			
		default:
			ReadUnknown(xpp);
			break;
		}
		
		return ctx;
	}

	private KdbContext EndXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException {
		assert(xpp.getEventType() == XmlPullParser.END_TAG);
		
		String name = xpp.getName();
		if ( ctx == KdbContext.KeePassFile && name.equalsIgnoreCase(ElemDocNode) ) {
			return KdbContext.Null;
		} else if ( ctx == KdbContext.Meta && name.equalsIgnoreCase(ElemMeta) ) {
			return KdbContext.KeePassFile;
		} else if ( ctx == KdbContext.Root && name.equalsIgnoreCase(ElemRoot) ) {
			return KdbContext.KeePassFile;
		} else if ( ctx == KdbContext.MemoryProtection && name.equalsIgnoreCase(ElemMemoryProt) ) {
			return KdbContext.Meta;
		} else if ( ctx == KdbContext.CustomIcons && name.equalsIgnoreCase(ElemCustomIcons) ) {
			return KdbContext.Meta;
		} else if ( ctx == KdbContext.CustomIcon && name.equalsIgnoreCase(ElemCustomIconItem) ) {
			if ( ! customIconID.equals(PwDatabaseV4.UUID_ZERO) ) {
				PwIconCustom icon = new PwIconCustom(customIconID, customIconData);
				db.customIcons.add(icon);
				db.iconFactory.put(icon);
			} else assert(false);
			
			customIconID = PwDatabaseV4.UUID_ZERO;
			customIconData = null;
			
			return KdbContext.CustomIcons;
		} else if ( ctx == KdbContext.CustomData && name.equalsIgnoreCase(ElemCustomData) ) {
			return KdbContext.Meta;
		} else if ( ctx == KdbContext.CustomDataItem && name.equalsIgnoreCase(ElemStringDictExItem) ) {
			if ( customDataKey != null && customDataValue != null) {
				db.customData.put(customDataKey, customDataValue);
			} else assert(false);
			
			customDataKey = null;
			customDataValue = null;
			
			return KdbContext.CustomData;
		} else if ( ctx == KdbContext.Group && name.equalsIgnoreCase(ElemGroup) ) {
			if ( ctxGroup.uuid == null || ctxGroup.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {
				ctxGroup.uuid = UUID.randomUUID();
			}
			
			ctxGroups.pop();
			
			if ( ctxGroups.size() == 0 ) {
				ctxGroup = null;
				return KdbContext.Root;
			} else {
				ctxGroup = ctxGroups.peek();
				return KdbContext.Group;
			}
		} else if ( ctx == KdbContext.GroupTimes && name.equalsIgnoreCase(ElemTimes) ) {
			return KdbContext.Group;
		} else if ( ctx == KdbContext.Entry && name.equalsIgnoreCase(ElemEntry) ) {
			if ( ctxEntry.uuid == null || ctxEntry.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {
				ctxEntry.uuid = UUID.randomUUID();
			}
			
			if ( entryInHistory ) {
				ctxEntry = ctxHistoryBase;
				return KdbContext.EntryHistory;
			}
			
			return KdbContext.Group;
		} else if ( ctx == KdbContext.EntryTimes && name.equalsIgnoreCase(ElemTimes) ) {
			return KdbContext.Entry;
		} else if ( ctx == KdbContext.EntryString && name.equalsIgnoreCase(ElemString) ) {
			ctxEntry.strings.put(ctxStringName, ctxStringValue);
			ctxStringName = null;
			ctxStringValue = null;
			
			return KdbContext.Entry;
		} else if ( ctx == KdbContext.EntryBinary && name.equalsIgnoreCase(ElemBinary) ) {
			ctxEntry.binaries.put(ctxBinaryName, ctxBinaryValue);
			ctxBinaryName = null;
			ctxBinaryValue = null;
			
			return KdbContext.Entry;
		} else if ( ctx == KdbContext.EntryAutoType && name.equalsIgnoreCase(ElemAutoType) ) {
			return KdbContext.Entry;
		} else if ( ctx == KdbContext.EntryAutoTypeItem && name.equalsIgnoreCase(ElemAutoTypeItem) ) {
			ctxEntry.autoType.put(ctxATName, ctxATSeq);
			ctxATName = null;
			ctxATSeq = null;
			
			return KdbContext.EntryAutoType;
		} else if ( ctx == KdbContext.EntryHistory && name.equalsIgnoreCase(ElemHistory) ) {
			entryInHistory = false;
			return KdbContext.Entry;
		} else if ( ctx == KdbContext.RootDeletedObjects && name.equalsIgnoreCase(ElemDeletedObjects) ) {
			return KdbContext.Root;
		} else if ( ctx == KdbContext.DeletedObject && name.equalsIgnoreCase(ElemDeletedObject) ) {
			ctxDeletedObject = null;
			return KdbContext.RootDeletedObjects;
		} else {
			assert(false);
			
			throw new RuntimeException(""Invalid end element"");
		}
	}
	
	private static final SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-mm-dd'T'HH:mm:ss'Z'"");
	private Date ReadTime(XmlPullParser xpp) throws IOException, XmlPullParserException {
		String sDate = ReadString(xpp);
		
		Date utcDate;
		try {
			utcDate = dateFormat.parse(sDate);
		} catch (ParseException e) {
			e.printStackTrace();
			throw new IOException(e.getLocalizedMessage());
		}
		
		return utcDate;
		
	}

	private void ReadUnknown(XmlPullParser xpp) throws XmlPullParserException, IOException {
		assert(false);
		
		if ( xpp.isEmptyElementTag() ) return;
		
		String unknownName = xpp.getName();
		ProcessNode(xpp);
		
		while (xpp.next() != XmlPullParser.END_DOCUMENT ) {
			if ( xpp.getEventType() == XmlPullParser.END_TAG ) break;
			if ( xpp.getEventType() == XmlPullParser.START_TAG ) continue;
			
			ReadUnknown(xpp);
		}
		
		assert(xpp.getName() == unknownName);
		
	}
	
	private boolean ReadBool(XmlPullParser xpp, boolean bDefault) throws IOException, XmlPullParserException {
		String str = ReadString(xpp);
		
		if ( str.equalsIgnoreCase(""true"") ) {
			return true;
		} else if ( str.equalsIgnoreCase(""false"") ) {
			return false;
		} else {
			return bDefault;
		}
	}
	
	private UUID ReadUuid(XmlPullParser xpp) throws IOException, XmlPullParserException {
		String encoded = ReadString(xpp);
		
		if (encoded == null || encoded.length() == 0 ) {
			return PwDatabaseV4.UUID_ZERO;
		}
		
		// TODO: Switch to framework Base64 once API level 8 is the minimum
		byte[] buf = Base64Coder.decode(encoded);
		
		return Types.bytestoUUID(buf);
	}
	
	private static final long MAX_UINT = 4294967296L; // 2^32
	private long ReadUInt(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {
		long u;
		
		u = ReadULong(xpp, uDefault);
		if ( u < 0 || u > MAX_UINT ) {
			throw new NumberFormatException(""Outside of the uint size"");
		}

		return u;
		
	}
	
	private long ReadLong(XmlPullParser xpp, long def) throws IOException, XmlPullParserException {
		String str = ReadString(xpp);
		
		long u;
		try {
			u = Long.parseLong(str);
		} catch( NumberFormatException e) {
			u = def;
		}
		
		return u;
	}
	
	private long ReadULong(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {
		long u = ReadLong(xpp, uDefault);
		
		if ( u < 0 ) {
			u = uDefault;
		}
		
		return u;
		
	}
	
	private String ReadProtectedString(XmlPullParser xpp) throws XmlPullParserException, IOException {
		byte[] buf = ProcessNode(xpp);
		
		if ( buf != null) {
			try {
				return new String(buf, ""UTF-8"");
			} catch (UnsupportedEncodingException e) {
				e.printStackTrace();
				throw new IOException(e.getLocalizedMessage());
			} 
		}
		
		return ReadString(xpp);
	}
	
	private byte[] ReadProtectedBinary(XmlPullParser xpp) throws XmlPullParserException, IOException {
		byte[] buf = ProcessNode(xpp);
		
		if ( buf != null ) return buf;
		
		String base64 = ReadString(xpp);
		if ( base64.length() == 0 ) return new byte[0];
		
		return Base64Coder.decode(base64);
	}
	
	private String ReadString(XmlPullParser xpp) throws IOException, XmlPullParserException {
		byte[] buf = ProcessNode(xpp);
		
		if ( buf != null ) {
			try {
				return new String(buf, ""UTF-8"");
			} catch (UnsupportedEncodingException e) {
				throw new IOException(e.getLocalizedMessage());
			}
		}
		
		//readNextNode = false;
		return xpp.nextText();
		
	}
	
	private String ReadStringRaw(XmlPullParser xpp) throws XmlPullParserException, IOException {
		
		//readNextNode = false;
		return xpp.nextText();
	}

	private byte[] ProcessNode(XmlPullParser xpp) throws XmlPullParserException, IOException {
		assert(xpp.getEventType() == XmlPullParser.START_TAG);
		
		byte[] buf = null;
		
		if ( xpp.getAttributeCount() > 0 ) {
			String protect = xpp.getAttributeValue(null, AttrProtected);
			if ( protect != null && protect.equalsIgnoreCase(ValTrue) ) {
				String encrypted = ReadStringRaw(xpp);
				
				if ( encrypted.length() > 0 ) {
					buf = Base64Coder.decode(encrypted);
					byte[] plainText = new byte[buf.length];
					
					randomStream.processBytes(buf, 0, buf.length, plainText, 0);
					
					return plainText;
				} else {
					buf = new byte[0];
				}
			}
		}
		
		return buf;
	}

	private KdbContext SwitchContext(KdbContext ctxCurrent, KdbContext ctxNew,
			XmlPullParser xpp) throws XmlPullParserException, IOException {

		if ( xpp.isEmptyElementTag() ) {
			xpp.next();  // Consume the end tag
			return ctxCurrent;
		}
		return ctxNew;
	}


	private Boolean StringToBoolean(String str) {
		if ( str == null || str.length() == 0 ) {
			return null;
		}
		
		String trimmed = str.trim();
		if ( trimmed.equalsIgnoreCase(""true"") ) {
			return true;
		} else if ( trimmed.equalsIgnoreCase(""false"") ) {
			return false;
		}
		
		return null;
		
	}
}
",True,233,5,33,8,43,3,26,L5
113,com.keepassdroid.database.load.Importer.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.load;

import java.io.IOException;
import java.io.InputStream;

import com.keepassdroid.UpdateStatus;
import com.keepassdroid.database.PwDatabase;
import com.keepassdroid.database.exception.InvalidDBException;

public abstract class Importer {

	public static final boolean DEBUG = true;
	protected final boolean debug;
	
	public Importer() {
		debug = false;
	}

	public Importer(boolean d) {
		debug = d;
	}

	public abstract PwDatabase openDatabase( InputStream inStream, String password, String keyfile ) 
		throws IOException, InvalidDBException;

	public abstract PwDatabase openDatabase( InputStream inStream, String password, String keyfile, UpdateStatus status ) 
		throws IOException, InvalidDBException;


}
",False,95,4,39,6,9,6,3,L5
114,com.keepassdroid.database.load.ImporterV3.java,"/*
KeePass for J2ME

Copyright 2007 Naomaru Itoi <nao@phoneid.org>

This file was derived from 

Java clone of KeePass - A KeePass file viewer for Java
Copyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

package com.keepassdroid.database.load;

import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.security.DigestOutputStream;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import android.util.Log;

import com.android.keepass.R;
import com.keepassdroid.UpdateStatus;
import com.keepassdroid.crypto.CipherFactory;
import com.keepassdroid.database.PwDatabaseV3;
import com.keepassdroid.database.PwDate;
import com.keepassdroid.database.PwDbHeader;
import com.keepassdroid.database.PwDbHeaderV3;
import com.keepassdroid.database.PwEncryptionAlgorithm;
import com.keepassdroid.database.PwEntryV3;
import com.keepassdroid.database.PwGroupV3;
import com.keepassdroid.database.exception.InvalidDBException;
import com.keepassdroid.database.exception.InvalidDBSignatureException;
import com.keepassdroid.database.exception.InvalidDBVersionException;
import com.keepassdroid.database.exception.InvalidKeyFileException;
import com.keepassdroid.database.exception.InvalidPasswordException;
import com.keepassdroid.stream.LEDataInputStream;
import com.keepassdroid.stream.LEDataOutputStream;
import com.keepassdroid.stream.NullOutputStream;
import com.keepassdroid.utils.Types;

/**
 * Load a v3 database file.
 *
 * @author Naomaru Itoi <nao@phoneid.org>
 * @author Bill Zwicky <wrzwicky@pobox.com>
 */
public class ImporterV3 extends Importer {

	public ImporterV3() {
		super();
	}

	public ImporterV3(boolean debug) {
		super(debug);
	}


	/**
	 * Load a v3 database file, return contents in a new PwDatabaseV3.
	 * 
	 * @param infile  Existing file to load.
	 * @param password Pass phrase for infile.
	 * @param pRepair (unused)
	 * @return new PwDatabaseV3 container.
	 * 
	 * @throws IOException on any file error.
	 * @throws InvalidKeyFileException 
	 * @throws InvalidPasswordException 
	 * @throws InvalidPasswordException on a decryption error, or possible internal bug.
	 * @throws InvalidDBSignatureException 
	 * @throws InvalidDBVersionException 
	 * @throws IllegalBlockSizeException on a decryption error, or possible internal bug.
	 * @throws BadPaddingException on a decryption error, or possible internal bug.
	 * @throws NoSuchAlgorithmException on a decryption error, or possible internal bug.
	 * @throws NoSuchPaddingException on a decryption error, or possible internal bug.
	 * @throws InvalidAlgorithmParameterException if error decrypting main file body. 
	 * @throws ShortBufferException if error decrypting main file body.
	 */
	public PwDatabaseV3 openDatabase( InputStream inStream, String password, String keyfile )
	throws IOException, InvalidDBException
	{
		return openDatabase(inStream, password, keyfile, new UpdateStatus());
	}

	public PwDatabaseV3 openDatabase( InputStream inStream, String password, String keyfile, UpdateStatus status )
	throws IOException, InvalidDBException
	{
		PwDatabaseV3        newManager;


		// Load entire file, most of it's encrypted.
		byte[] filebuf = new byte[(int)inStream.available()];
		inStream.read( filebuf, 0, (int)inStream.available());
		inStream.close();

		// Parse header (unencrypted)
		if( filebuf.length < PwDbHeaderV3.BUF_SIZE )
			throw new IOException( ""File too short for header"" );
		PwDbHeaderV3 hdr = new PwDbHeaderV3();
		hdr.loadFromFile(filebuf, 0 );

		if( (hdr.signature1 != PwDbHeader.PWM_DBSIG_1) || (hdr.signature2 != PwDbHeaderV3.DBSIG_2) ) {
			throw new InvalidDBSignatureException();
		}

		if( hdr.version != PwDbHeaderV3.DBVER_DW ) {
			throw new InvalidDBVersionException();
		}

		status.updateMessage(R.string.creating_db_key);
		newManager = new PwDatabaseV3();
		newManager.setMasterKey( password, keyfile );

		// Select algorithm
		if( (hdr.flags & PwDbHeaderV3.FLAG_RIJNDAEL) != 0 ) {
			newManager.algorithm = PwEncryptionAlgorithm.Rjindal;
		} else if( (hdr.flags & PwDbHeaderV3.FLAG_TWOFISH) != 0 ) {
			newManager.algorithm = PwEncryptionAlgorithm.Twofish;
		} else {
			throw new IOException( ""Unknown algorithm."" );
		}


		if ( debug ) {
			newManager.dbHeader = hdr;
		}

		newManager.numKeyEncRounds = hdr.numKeyEncRounds;

		newManager.name = ""KeePass Password Manager"";

		// Generate transformedMasterKey from masterKey
		newManager.makeFinalKey(hdr.masterSeed, hdr.transformSeed, newManager.numKeyEncRounds);

		status.updateMessage(R.string.decrypting_db);
		// Initialize Rijndael algorithm
		Cipher cipher;
		try {
			if ( newManager.algorithm == PwEncryptionAlgorithm.Rjindal ) {
				cipher = CipherFactory.getInstance(""AES/CBC/PKCS5Padding"");
			} else if ( newManager.algorithm == PwEncryptionAlgorithm.Twofish ) {
				cipher = CipherFactory.getInstance(""TWOFISH/CBC/PKCS7PADDING"");
			} else {
				throw new IOException( ""Encryption algorithm is not supported"" );
			}

		} catch (NoSuchAlgorithmException e1) {
			throw new IOException(""No such algorithm"");
		} catch (NoSuchPaddingException e1) {
			throw new IOException(""No such pdading"");
		}

		try {
			cipher.init( Cipher.DECRYPT_MODE, new SecretKeySpec( newManager.finalKey, ""AES"" ), new IvParameterSpec( hdr.encryptionIV ) );
		} catch (InvalidKeyException e1) {
			throw new IOException(""Invalid key"");
		} catch (InvalidAlgorithmParameterException e1) {
			throw new IOException(""Invalid algorithm parameter."");
		}

		// Decrypt! The first bytes aren't encrypted (that's the header)
		int encryptedPartSize;
		try {
			encryptedPartSize = cipher.doFinal(filebuf, PwDbHeaderV3.BUF_SIZE, filebuf.length - PwDbHeaderV3.BUF_SIZE, filebuf, PwDbHeaderV3.BUF_SIZE );
		} catch (ShortBufferException e1) {
			throw new IOException(""Buffer too short"");
		} catch (IllegalBlockSizeException e1) {
			throw new IOException(""Invalid block size"");
		} catch (BadPaddingException e1) {
			throw new InvalidPasswordException();
		}

		if ( debug ) {
			newManager.postHeader = new byte[encryptedPartSize];
			System.arraycopy(filebuf, PwDbHeaderV3.BUF_SIZE, newManager.postHeader, 0, encryptedPartSize);
		}

		MessageDigest md = null;
		try {
			md = MessageDigest.getInstance(""SHA-256"");
		} catch (NoSuchAlgorithmException e) {
			throw new IOException(""No SHA-256 algorithm"");
		}
		NullOutputStream nos = new NullOutputStream();
		DigestOutputStream dos = new DigestOutputStream(nos, md);
		dos.write(filebuf, PwDbHeaderV3.BUF_SIZE, encryptedPartSize);
		dos.close();
		byte[] hash = md.digest();
		
		if( ! Arrays.equals(hash, hdr.contentsHash) ) {

			Log.w(""KeePassDroid"",""Database file did not decrypt correctly. (checksum code is broken)"");
			throw new InvalidPasswordException();
		}

		// Import all groups

		int pos = PwDbHeaderV3.BUF_SIZE;
		PwGroupV3 newGrp = new PwGroupV3();
		for( int i = 0; i < hdr.numGroups; ) {
			int fieldType = Types.readShort( filebuf, pos );
			pos += 2;
			int fieldSize = LEDataInputStream.readInt( filebuf, pos );
			pos += 4;

			if( fieldType == 0xFFFF ) {

				// End-Group record.  Save group and count it.
				newManager.groups.add(newGrp);
				newGrp = new PwGroupV3();
				i++;
			}
			else {
				readGroupField(newManager, newGrp, fieldType, filebuf, pos);
			}
			pos += fieldSize;
		}

		// Import all entries
		PwEntryV3 newEnt = new PwEntryV3();
		for( int i = 0; i < hdr.numEntries; ) {
			int fieldType = Types.readShort( filebuf, pos );
			int fieldSize = LEDataInputStream.readInt( filebuf, pos + 2 );

			if( fieldType == 0xFFFF ) {
				// End-Group record.  Save group and count it.
				newManager.entries.add(newEnt);
				newEnt = new PwEntryV3();
				i++;
			}
			else {
				readEntryField(newManager, newEnt, filebuf, pos);
			}
			pos += 2 + 4 + fieldSize;
		}

		newManager.constructTree(null);
		
		return newManager;
	}

	/**
	 * KeePass's custom pad style.
	 * 
	 * @param data buffer to pad.
	 * @return addtional bytes to append to data[] to make
	 *    a properly padded array.
	 */
	public static byte[] makePad( byte[] data ) {
		//custom pad method

		// append 0x80 plus zeros to a multiple of 4 bytes
		int thisblk = 32 - data.length % 32;  // bytes needed to finish blk
		int nextblk = 0;                      // 32 if we need another block
		// need 9 bytes; add new block if no room
		if( thisblk < 9 ) {
			nextblk = 32;
		}

		// all bytes are zeroed for free
		byte[] pad = new byte[ thisblk + nextblk ];
		pad[0] = (byte)0x80;

		// write length*8 to end of final block
		int ix = thisblk + nextblk - 8;
		LEDataOutputStream.writeInt( data.length>>29, pad, ix );
		bsw32( pad, ix );
		ix += 4;
		LEDataOutputStream.writeInt( data.length<<3, pad, ix );
		bsw32( pad, ix );

		return pad;
	}

	public static void bsw32( byte[] ary, int offset ) {
		byte t = ary[offset];
		ary[offset] = ary[offset+3];
		ary[offset+3] = t;
		t = ary[offset+1];
		ary[offset+1] = ary[offset+2];
		ary[offset+2] = t;
	}


	/**
	 * Parse and save one record from binary file.
	 * @param buf
	 * @param offset
	 * @return If >0, 
	 * @throws UnsupportedEncodingException 
	 */
	void readGroupField(PwDatabaseV3 db, PwGroupV3 grp, int fieldType, byte[] buf, int offset) throws UnsupportedEncodingException {
		switch( fieldType ) {
		case 0x0000 :
			// Ignore field
			break;
		case 0x0001 :
			grp.groupId = LEDataInputStream.readInt(buf, offset);
			break;
		case 0x0002 :
			grp.name = Types.readCString(buf, offset);
			break;
		case 0x0003 :
			grp.tCreation = new PwDate(buf, offset);
			break;
		case 0x0004 :
			grp.tLastMod = new PwDate(buf, offset);
			break;
		case 0x0005 :
			grp.tLastAccess = new PwDate(buf, offset);
			break;
		case 0x0006 :
			grp.tExpire = new PwDate(buf, offset);
			break;
		case 0x0007 :
			grp.icon = db.iconFactory.getIcon(LEDataInputStream.readInt(buf, offset));
			break;
		case 0x0008 :
			grp.level = Types.readShort(buf, offset);
			break;
		case 0x0009 :
			grp.flags = LEDataInputStream.readInt(buf, offset);
			break;
		}
	}



	void readEntryField(PwDatabaseV3 db, PwEntryV3 ent, byte[] buf, int offset)
	throws UnsupportedEncodingException
	{
		int fieldType = Types.readShort(buf, offset);
		offset += 2;
		int fieldSize = LEDataInputStream.readInt(buf, offset);
		offset += 4;

		switch( fieldType ) {
		case 0x0000 :
			// Ignore field
			break;
		case 0x0001 :
			ent.setUUID(Types.bytestoUUID(buf, offset));
			break;
		case 0x0002 :
			ent.groupId = LEDataInputStream.readInt(buf, offset);
			break;
		case 0x0003 :
			ent.icon = db.iconFactory.getIcon(LEDataInputStream.readInt(buf, offset));
			break;
		case 0x0004 :
			ent.title = Types.readCString(buf, offset); 
			break;
		case 0x0005 :
			ent.url = Types.readCString(buf, offset);
			break;
		case 0x0006 :
			ent.username = Types.readCString(buf, offset);
			break;
		case 0x0007 :
			ent.setPassword(buf, offset, Types.strlen(buf, offset));
			break;
		case 0x0008 :
			ent.additional = Types.readCString(buf, offset);
			break;
		case 0x0009 :
			ent.tCreation = new PwDate(buf, offset);
			break;
		case 0x000A :
			ent.tLastMod = new PwDate(buf, offset);
			break;
		case 0x000B :
			ent.tLastAccess = new PwDate(buf, offset);
			break;
		case 0x000C :
			ent.tExpire = new PwDate(buf, offset);
			break;
		case 0x000D :
			ent.binaryDesc = Types.readCString(buf, offset);
			break;
		case 0x000E :
			ent.setBinaryData(buf, offset, fieldSize);
			break;
		}
	}
}",True,191,1,2,8,44,3,23,L6
115,com.keepassdroid.database.load.ImporterFactory.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.load;

import java.io.IOException;
import java.io.InputStream;

import com.keepassdroid.database.PwDbHeaderV3;
import com.keepassdroid.database.PwDbHeaderV4;
import com.keepassdroid.database.exception.InvalidDBSignatureException;
import com.keepassdroid.stream.LEDataInputStream;

public class ImporterFactory {
	public static Importer createImporter(InputStream is) throws InvalidDBSignatureException, IOException
	{
		return createImporter(is, false);
	}

	public static Importer createImporter(InputStream is, boolean debug) throws InvalidDBSignatureException, IOException
	{
		int sig1 = LEDataInputStream.readInt(is);
		int sig2 = LEDataInputStream.readInt(is);
		
		if ( PwDbHeaderV3.matchesHeader(sig1, sig2) ) {
			return new ImporterV3(debug);
		} else if ( PwDbHeaderV4.matchesHeader(sig1, sig2) ) {
			return new ImporterV4();
		}

		throw new InvalidDBSignatureException();
		
	}
}
",False,190,1,1,9,43,2,7,L6
116,com.keepassdroid.database.save.PwDbHeaderOutputV3.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.save;

import java.io.IOException;
import java.io.OutputStream;


import com.keepassdroid.database.PwDbHeaderV3;
import com.keepassdroid.utils.Types;

public class PwDbHeaderOutputV3 {
	private PwDbHeaderV3 mHeader;
	private OutputStream mOS;
	
	public PwDbHeaderOutputV3(PwDbHeaderV3 header, OutputStream os) {
		mHeader = header;
		mOS = os;
	}
	
	public void output() throws IOException {
		mOS.write(Types.writeInt(mHeader.signature1));
		mOS.write(Types.writeInt(mHeader.signature2));
		mOS.write(Types.writeInt(mHeader.flags));
		mOS.write(Types.writeInt(mHeader.version));
		mOS.write(mHeader.masterSeed);
		mOS.write(mHeader.encryptionIV);
		mOS.write(Types.writeInt(mHeader.numGroups));
		mOS.write(Types.writeInt(mHeader.numEntries));
		mOS.write(mHeader.contentsHash);
		mOS.write(mHeader.transformSeed);
		mOS.write(Types.writeInt(mHeader.numKeyEncRounds));
		
	}
	
	public void close() throws IOException {
		mOS.close();
	}
}
",False,71,7,33,2,3,2,3,L6
117,com.keepassdroid.database.save.PwDbOutput.java,"/*
` * Copyright 2010 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.save;

import java.io.OutputStream;

import com.keepassdroid.database.PwDatabase;
import com.keepassdroid.database.PwDatabaseV3;
import com.keepassdroid.database.PwDatabaseV4;
import com.keepassdroid.database.exception.PwDbOutputException;

public abstract class PwDbOutput {
	public abstract void output() throws PwDbOutputException;
	
	public static PwDbOutput getInstance(PwDatabase pm, OutputStream os) {
		return getInstance(pm, os, false);
	}
	
	public static PwDbOutput getInstance(PwDatabase pm, OutputStream os, boolean debug) {
		if ( pm instanceof PwDatabaseV3 ) {
			return new PwDbV3Output((PwDatabaseV3)pm, os, debug);
		} else if ( pm instanceof PwDatabaseV4 ) {
			// TODO: Implement me
			throw new RuntimeException("".kdbx output not yet supported."");
		}
		
		return null;
	}
}
",False,189,0,0,9,44,2,5,L6
118,com.keepassdroid.database.save.PwDbV3Output.java,"/*
` * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.save;

import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.security.DigestOutputStream;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.List;

import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import com.keepassdroid.crypto.CipherFactory;
import com.keepassdroid.database.PwDatabaseV3;
import com.keepassdroid.database.PwDbHeader;
import com.keepassdroid.database.PwDbHeaderV3;
import com.keepassdroid.database.PwEncryptionAlgorithm;
import com.keepassdroid.database.PwEntryV3;
import com.keepassdroid.database.PwGroup;
import com.keepassdroid.database.PwGroupV3;
import com.keepassdroid.database.exception.PwDbOutputException;
import com.keepassdroid.stream.NullOutputStream;

public class PwDbV3Output extends PwDbOutput {
	private PwDatabaseV3 mPM;
	private OutputStream mOS;
	private final boolean mDebug;
	public static final boolean DEBUG = true;
	
	public PwDbV3Output(PwDatabaseV3 pm, OutputStream os) {
		mPM = pm;
		mOS = os;
		mDebug = false;
	}

	public PwDbV3Output(PwDatabaseV3 pm, OutputStream os, boolean debug) {
		mPM = pm;
		mOS = os;
		mDebug = debug;
	}
	
	public byte[] getFinalKey(PwDbHeader header) throws PwDbOutputException {
		try {
			mPM.makeFinalKey(header.masterSeed, header.transformSeed, mPM.numKeyEncRounds);
			return mPM.finalKey;
		} catch (IOException e) {
			throw new PwDbOutputException(""Key creation failed: "" + e.getMessage());
		}
	}
	
	public void output() throws PwDbOutputException {
		
		// Before we output the header, we should sort our list of groups and remove any orphaned nodes that are no longer part of the group hierarchy
		sortGroupsForOutput();
		
		PwDbHeader header = outputHeader(mOS);
		
		byte[] finalKey = getFinalKey(header);
		
		Cipher cipher;
		try {
			if (mPM.algorithm == PwEncryptionAlgorithm.Rjindal) {
				cipher = CipherFactory.getInstance(""AES/CBC/PKCS5Padding"");
			} else if (mPM.algorithm == PwEncryptionAlgorithm.Twofish){
				cipher = CipherFactory.getInstance(""TWOFISH/CBC/PKCS7PADDING"");
			} else {
				throw new Exception();
			}
		} catch (Exception e) {
			throw new PwDbOutputException(""Algorithm not supported."");
		}

		try {
			cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, ""AES"" ), new IvParameterSpec(header.encryptionIV) );
			CipherOutputStream cos = new CipherOutputStream(mOS, cipher);
			BufferedOutputStream bos = new BufferedOutputStream(cos);
			outputPlanGroupAndEntries(bos);
			bos.flush();
			bos.close();

		} catch (InvalidKeyException e) {
			throw new PwDbOutputException(""Invalid key"");
		} catch (InvalidAlgorithmParameterException e) {
			throw new PwDbOutputException(""Invalid algorithm parameter."");
		} catch (IOException e) {
			throw new PwDbOutputException(""Failed to output final encrypted part."");
		}
	}
	
	public PwDbHeaderV3 outputHeader(OutputStream os) throws PwDbOutputException {
		// Build header
		PwDbHeaderV3 header = new PwDbHeaderV3();
		header.signature1 = PwDbHeader.PWM_DBSIG_1;
		header.signature2 = PwDbHeaderV3.DBSIG_2;
		header.flags = PwDbHeaderV3.FLAG_SHA2;
		
		if ( mPM.getEncAlgorithm() == PwEncryptionAlgorithm.Rjindal ) {
			header.flags |= PwDbHeaderV3.FLAG_RIJNDAEL;
		} else if ( mPM.getEncAlgorithm() == PwEncryptionAlgorithm.Twofish ) {
			header.flags |= PwDbHeaderV3.FLAG_TWOFISH;
		} else {
			throw new PwDbOutputException(""Unsupported algorithm."");
		}
		
		header.version = PwDbHeaderV3.DBVER_DW;
		header.numGroups = mPM.getGroups().size();
		header.numEntries = mPM.entries.size();
		header.numKeyEncRounds = mPM.getNumKeyEncRecords();
		
		// Reuse random values to test equivalence in debug mode
		if ( mDebug ) {
			System.arraycopy(mPM.dbHeader.encryptionIV, 0, header.encryptionIV, 0, mPM.dbHeader.encryptionIV.length);
			System.arraycopy(mPM.dbHeader.masterSeed, 0, header.masterSeed, 0, mPM.dbHeader.masterSeed.length);
			System.arraycopy(mPM.dbHeader.transformSeed, 0, header.transformSeed, 0, mPM.dbHeader.transformSeed.length);
		} else {
			SecureRandom random;
			try {
				random = SecureRandom.getInstance(""SHA1PRNG"");
			} catch (NoSuchAlgorithmException e) {
				throw new PwDbOutputException(""Does not support secure random number generation."");
			}
			random.nextBytes(header.encryptionIV);
			random.nextBytes(header.masterSeed);
			random.nextBytes(header.transformSeed);
		}
		
		// Write checksum Checksum
		MessageDigest md = null;
		try {
			md = MessageDigest.getInstance(""SHA-256"");
		} catch (NoSuchAlgorithmException e) {
			throw new PwDbOutputException(""SHA-256 not implemented here."");
		}
		
		NullOutputStream nos;
		nos = new NullOutputStream();
		DigestOutputStream dos = new DigestOutputStream(nos, md);
		BufferedOutputStream bos = new BufferedOutputStream(dos);
		try {
			outputPlanGroupAndEntries(bos);
			bos.flush();
			bos.close();
		} catch (IOException e) {
			throw new PwDbOutputException(""Failed to generate checksum."");
		}

		header.contentsHash = md.digest();
		
		// Output header
		PwDbHeaderOutputV3 pho = new PwDbHeaderOutputV3(header, os);
		try {
			pho.output();
		} catch (IOException e) {
			throw new PwDbOutputException(""Failed to output the header."");
		}

		return header;
	}
	
	public void outputPlanGroupAndEntries(OutputStream os) throws PwDbOutputException  {
		//long size = 0;
		
		// Groups
		List<PwGroup> groups = mPM.getGroups();
		for ( int i = 0; i < groups.size(); i++ ) {
			PwGroupV3 pg = (PwGroupV3) groups.get(i);
			PwGroupOutputV3 pgo = new PwGroupOutputV3(pg, os);
			try {
				pgo.output();
			} catch (IOException e) {
				throw new PwDbOutputException(""Failed to output a group: "" + e.getMessage());
			}
		}
		
		// Entries
		for (int i = 0; i < mPM.entries.size(); i++ ) {
			PwEntryV3 pe = (PwEntryV3) mPM.entries.get(i);
			PwEntryOutputV3 peo = new PwEntryOutputV3(pe, os);
			try {
				peo.output();
			} catch (IOException e) {
				throw new PwDbOutputException(""Failed to output an entry."");
			}
		}
	}
	
	private void sortGroupsForOutput() {
		List<PwGroup> groupList = new ArrayList<PwGroup>();
		
		// Rebuild list according to coalation sorting order removing any orphaned groups
		List<PwGroup> roots = mPM.getGrpRoots();
		for ( int i = 0; i < roots.size(); i++ ) {
			sortGroup((PwGroupV3) roots.get(i), groupList);
		}
		
		mPM.setGroups(groupList);
	}
	
	private void sortGroup(PwGroupV3 group, List<PwGroup> groupList) {
		// Add current group
		groupList.add(group);
		
		// Recurse over children
		for ( int i = 0; i < group.childGroups.size(); i++ ) {
			sortGroup((PwGroupV3) group.childGroups.get(i), groupList);
		}
	}
}
",False,190,1,1,8,44,2,15,L6
119,com.keepassdroid.database.save.PwGroupOutputV3.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.save;

import java.io.IOException;
import java.io.OutputStream;


import com.keepassdroid.database.PwGroupV3;
import com.keepassdroid.utils.Types;

public class PwGroupOutputV3 {
	// Constants
	public static final byte[] GROUPID_FIELD_TYPE = Types.writeShort(1);
	public static final byte[] NAME_FIELD_TYPE =    Types.writeShort(2);
	public static final byte[] CREATE_FIELD_TYPE =  Types.writeShort(3);
	public static final byte[] MOD_FIELD_TYPE =     Types.writeShort(4);
	public static final byte[] ACCESS_FIELD_TYPE =  Types.writeShort(5);
	public static final byte[] EXPIRE_FIELD_TYPE =  Types.writeShort(6);
	public static final byte[] IMAGEID_FIELD_TYPE = Types.writeShort(7);
	public static final byte[] LEVEL_FIELD_TYPE =   Types.writeShort(8);
	public static final byte[] FLAGS_FIELD_TYPE =   Types.writeShort(9);
	public static final byte[] END_FIELD_TYPE =     Types.writeShort(0xFFFF);
	public static final byte[] LONG_FOUR =          Types.writeInt(4);
	public static final byte[] GROUPID_FIELD_SIZE = LONG_FOUR;
	public static final byte[] DATE_FIELD_SIZE =    Types.writeInt(5);
	public static final byte[] IMAGEID_FIELD_SIZE = LONG_FOUR;
	public static final byte[] LEVEL_FIELD_SIZE =   Types.writeInt(2);
	public static final byte[] FLAGS_FIELD_SIZE =   LONG_FOUR;
	public static final byte[] ZERO_FIELD_SIZE =    Types.writeInt(0);
	
	private OutputStream mOS;
	private PwGroupV3 mPG;
	
	/** Output the PwGroupV3 to the stream
	 * @param pg
	 * @param os
	 */
	public PwGroupOutputV3(PwGroupV3 pg, OutputStream os) {
		mPG = pg;
		mOS = os;
	}

	public void output() throws IOException {
		//NOTE: Need be to careful about using ints.  The actual type written to file is a unsigned int, but most values can't be greater than 2^31, so it probably doesn't matter.

		// Group ID
		mOS.write(GROUPID_FIELD_TYPE);
		mOS.write(GROUPID_FIELD_SIZE);
		mOS.write(Types.writeInt(mPG.groupId));
		
		// Name
		mOS.write(NAME_FIELD_TYPE);
		Types.writeCString(mPG.name, mOS);

		// Create date
		mOS.write(CREATE_FIELD_TYPE);
		mOS.write(DATE_FIELD_SIZE);
		mOS.write(mPG.tCreation.getCDate());
		
		// Modification date
		mOS.write(MOD_FIELD_TYPE);
		mOS.write(DATE_FIELD_SIZE);
		mOS.write(mPG.tLastMod.getCDate());
		
		// Access date
		mOS.write(ACCESS_FIELD_TYPE);
		mOS.write(DATE_FIELD_SIZE);
		mOS.write(mPG.tLastAccess.getCDate());
		
		// Expiration date
		mOS.write(EXPIRE_FIELD_TYPE);
		mOS.write(DATE_FIELD_SIZE);
		mOS.write(mPG.tExpire.getCDate());
		
		// Image ID
		mOS.write(IMAGEID_FIELD_TYPE);
		mOS.write(IMAGEID_FIELD_SIZE);
		mOS.write(Types.writeInt(mPG.icon.iconId));
		
		// Level
		mOS.write(LEVEL_FIELD_TYPE);
		mOS.write(LEVEL_FIELD_SIZE);
		mOS.write(Types.writeShort(mPG.level));
		
		// Flags
		mOS.write(FLAGS_FIELD_TYPE);
		mOS.write(FLAGS_FIELD_SIZE);
		mOS.write(Types.writeInt(mPG.flags));

		// End
		mOS.write(END_FIELD_TYPE);
		mOS.write(ZERO_FIELD_SIZE);
	}

}
",False,189,0,0,13,43,1,5,L6
120,com.keepassdroid.database.save.PwEntryOutputV3.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.database.save;

import java.io.IOException;
import java.io.OutputStream;

import com.keepassdroid.database.PwEntryV3;
import com.keepassdroid.utils.Types;

public class PwEntryOutputV3 {
	// Constants
	public static final byte[] UUID_FIELD_TYPE =     Types.writeShort(1);
	public static final byte[] GROUPID_FIELD_TYPE =  Types.writeShort(2);
	public static final byte[] IMAGEID_FIELD_TYPE =  Types.writeShort(3);
	public static final byte[] TITLE_FIELD_TYPE =    Types.writeShort(4);
	public static final byte[] URL_FIELD_TYPE =      Types.writeShort(5);
	public static final byte[] USERNAME_FIELD_TYPE =  Types.writeShort(6);
	public static final byte[] PASSWORD_FIELD_TYPE = Types.writeShort(7);
	public static final byte[] ADDITIONAL_FIELD_TYPE =   Types.writeShort(8);
	public static final byte[] CREATE_FIELD_TYPE =   Types.writeShort(9);
	public static final byte[] MOD_FIELD_TYPE =   Types.writeShort(10);
	public static final byte[] ACCESS_FIELD_TYPE =   Types.writeShort(11);
	public static final byte[] EXPIRE_FIELD_TYPE =   Types.writeShort(12);
	public static final byte[] BINARY_DESC_FIELD_TYPE =   Types.writeShort(13);
	public static final byte[] BINARY_DATA_FIELD_TYPE =   Types.writeShort(14);
	public static final byte[] END_FIELD_TYPE =     Types.writeShort(0xFFFF);
	public static final byte[] LONG_FOUR = Types.writeInt(4);
	public static final byte[] UUID_FIELD_SIZE =    Types.writeInt(16);
	public static final byte[] DATE_FIELD_SIZE =    Types.writeInt(5);
	public static final byte[] IMAGEID_FIELD_SIZE = LONG_FOUR;
	public static final byte[] LEVEL_FIELD_SIZE =   LONG_FOUR;
	public static final byte[] FLAGS_FIELD_SIZE =   LONG_FOUR;
	public static final byte[] ZERO_FIELD_SIZE =    Types.writeInt(0);
	public static final byte[] ZERO_FIVE       =   {0x00, 0x00, 0x00, 0x00, 0x00};
	public static final byte[] TEST = {0x33, 0x33, 0x33, 0x33};

	private OutputStream mOS;
	private PwEntryV3 mPE;
	private long outputBytes = 0;
	
	/** Output the PwGroupV3 to the stream
	 * @param pe
	 * @param os
	 */
	public PwEntryOutputV3(PwEntryV3 pe, OutputStream os) {
		mPE = pe;
		mOS = os;
	}

	//NOTE: Need be to careful about using ints.  The actual type written to file is a unsigned int
	public void output() throws IOException {
		
		outputBytes += 134;  // Length of fixed size fields
		
		// UUID
		mOS.write(UUID_FIELD_TYPE);
		mOS.write(UUID_FIELD_SIZE);
		mOS.write(Types.UUIDtoBytes(mPE.getUUID()));
		
		// Group ID
		mOS.write(GROUPID_FIELD_TYPE);
		mOS.write(LONG_FOUR);
		mOS.write(Types.writeInt(mPE.groupId));
		
		// Image ID
		mOS.write(IMAGEID_FIELD_TYPE);
		mOS.write(LONG_FOUR);
		mOS.write(Types.writeInt(mPE.icon.iconId));

		// Title
		//byte[] title = mPE.title.getBytes(""UTF-8"");
		mOS.write(TITLE_FIELD_TYPE);
		int titleLen = Types.writeCString(mPE.title, mOS);
		outputBytes += titleLen;

		// URL
		mOS.write(URL_FIELD_TYPE);
		int urlLen = Types.writeCString(mPE.url, mOS);
		outputBytes += urlLen;
		
		// Username
		mOS.write(USERNAME_FIELD_TYPE);
		int userLen = Types.writeCString(mPE.username, mOS);
		outputBytes += userLen;
		
		// Password
		byte[] password = mPE.getPasswordBytes();
		mOS.write(PASSWORD_FIELD_TYPE);
		mOS.write(Types.writeInt(password.length+1));
		mOS.write(password);
		mOS.write(0);
		outputBytes += password.length + 1;

		// Additional
		mOS.write(ADDITIONAL_FIELD_TYPE);
		int addlLen = Types.writeCString(mPE.additional, mOS);
		outputBytes += addlLen;

		// Create date
		writeDate(CREATE_FIELD_TYPE, mPE.tCreation.getCDate());
		
		// Modification date
		writeDate(MOD_FIELD_TYPE, mPE.tLastMod.getCDate());

		// Access date
		writeDate(ACCESS_FIELD_TYPE, mPE.tLastAccess.getCDate());

		// Expiration date
		writeDate(EXPIRE_FIELD_TYPE, mPE.tExpire.getCDate());
	
		// Binary desc
		mOS.write(BINARY_DESC_FIELD_TYPE);
		int descLen = Types.writeCString(mPE.binaryDesc, mOS);
		outputBytes += descLen;
	
		// Binary data
		int dataLen = writeByteArray(mPE.getBinaryData());
		outputBytes += dataLen;

		// End
		mOS.write(END_FIELD_TYPE);
		mOS.write(ZERO_FIELD_SIZE);
	}
	
	private int writeByteArray(byte[] data) throws IOException {
		int dataLen;
		if ( data != null ) {
			dataLen = data.length;
		} else {
			dataLen = 0;
		}
		mOS.write(BINARY_DATA_FIELD_TYPE);
		mOS.write(Types.writeInt(dataLen));
		if ( data != null ) {
			mOS.write(data);
		}
		
		return dataLen;

	}
	
	private void writeDate(byte[] type, byte[] date) throws IOException {
		mOS.write(type);
		mOS.write(DATE_FIELD_SIZE);
		if ( date != null ) {
			mOS.write(date);
		} else {
			mOS.write(ZERO_FIVE);
		}
	}
	
	/** Returns the number of bytes written by the stream
	 * @return Number of bytes written
	 */
	public long getLength() {
		return outputBytes;
	}
}
",True,189,0,0,12,43,1,5,L6
121,com.keepassdroid.app.App.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.app;

import java.util.Calendar;

import android.app.Application;

import com.keepassdroid.Database;
import com.keepassdroid.fileselect.FileDbHelper;

public class App extends Application {
	private static Database db;
	private static boolean shutdown = false;
	private static Calendar calendar;
	
	public static FileDbHelper fileDbHelper;
	
	public static Database getDB() {
		if ( db == null ) {
			db = new Database();
		}
		
		return db;
	}
	
	public static void setDB(Database d) {
		db = d;
	}
	
	public static boolean isShutdown() {
		return shutdown;
	}
	
	public static void setShutdown() {
		shutdown = true;
	}
	
	public static void clearShutdown() {
		shutdown = false;
	}
	
	public static Calendar getCalendar() {
		
		if ( calendar == null ) {
			calendar = Calendar.getInstance();
		}
		
		return calendar;
	}

	@Override
	public void onCreate() {
		super.onCreate();
		
		fileDbHelper = new FileDbHelper(this);
		fileDbHelper.open();
		
	}

	@Override
	public void onTerminate() {
		super.onTerminate();
		
		if ( db != null ) {
			db.clear();
		}
		
		if ( fileDbHelper != null && fileDbHelper.isOpen() ) {
			fileDbHelper.close();
		}
	}
	
	
}
",True,223,2,25,11,43,26,2,L6
122,com.keepassdroid.intents.Intents.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */package com.keepassdroid.intents;

public class Intents {
	public static final String TIMEOUT = ""com.keepassdroid.timeout"";
	
	public static final String COPY_USERNAME = ""com.keepassdroid.copy_username"";
	public static final String COPY_PASSWORD = ""com.keepassdroid.copy_password"";

	public static final String FILE_BROWSE = ""org.openintents.action.PICK_FILE"";
}
",True,31,5,10,0,0,5,0,L8
123,com.keepassdroid.password.PasswordGenerator.java,"/*
 * Copyright 2010 Tolga Onbay, Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.password;

import java.util.Random;

import android.content.Context;

import com.android.keepass.R;

public class PasswordGenerator {
	private static final String upperCaseChars	= ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
	private static final String lowerCaseChars 	= ""abcdefghijklmnopqrstuvwxyz"";
	private static final String digitChars 		= ""0123456789"";
	private static final String minusChars 		= ""-"";
	private static final String underlineChars 	= ""_"";
	private static final String spaceChars 		= "" "";
	private static final String specialChars 	= ""!\""#$%&'*+,./:;=?@\\^`"";
	private static final String bracketChars 	= ""[]{}()<>"";
	
	private Context cxt;
	
	public PasswordGenerator(Context cxt) {
		this.cxt = cxt;
	}
	
	public String generatePassword(int length, boolean upperCase, boolean lowerCase, boolean digits, boolean minus, boolean underline, boolean space, boolean specials, boolean brackets) throws IllegalArgumentException{
		if (length <= 0)
			throw new IllegalArgumentException(cxt.getString(R.string.error_wrong_length));
		
		if (!upperCase && !lowerCase && !digits && !minus && !underline && !space && !specials && !brackets)
			throw new IllegalArgumentException(cxt.getString(R.string.error_pass_gen_type));
		
		String characterSet = getCharacterSet(upperCase, lowerCase, digits, minus, underline, space, specials, brackets);
		
		int size = characterSet.length();
		
		StringBuffer buffer = new StringBuffer();

		Random random = new Random();
		if (size > 0) {
			
			for (int i = 0; i < length; i++) {
				char c = characterSet.charAt((char) random.nextInt(size));
				
				buffer.append(c);
			}
		}
		
		return buffer.toString();
	}
	
	public String getCharacterSet(boolean upperCase, boolean lowerCase, boolean digits, boolean minus, boolean underline, boolean space, boolean specials, boolean brackets) {
		StringBuffer charSet = new StringBuffer();
		
		if (upperCase)
			charSet.append(upperCaseChars);
		
		if (lowerCase)
			charSet.append(lowerCaseChars);
		
		if (digits)
			charSet.append(digitChars);
		
		if (minus)
			charSet.append(minusChars);
		
		if (underline)
			charSet.append(underlineChars);
		
		if (space)
			charSet.append(spaceChars);
		
		if (specials)
			charSet.append(specialChars);
		
		if (brackets)
			charSet.append(bracketChars);
		
		return charSet.toString();
	}
}
",True,26,9,6,0,0,1,0,L8
124,com.keepassdroid.settings.AppSettingsActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.settings;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.preference.Preference;
import android.preference.Preference.OnPreferenceChangeListener;

import com.android.keepass.R;
import com.keepassdroid.Database;
import com.keepassdroid.LockingClosePreferenceActivity;
import com.keepassdroid.app.App;
import com.keepassdroid.compat.BackupManagerCompat;
import com.keepassdroid.database.PwEncryptionAlgorithm;
import com.keepassdroid.fileselect.FileDbHelper;

public class AppSettingsActivity extends LockingClosePreferenceActivity {
	public static boolean KEYFILE_DEFAULT = false;
	
	private BackupManagerCompat backupManager;
	
	public static void Launch(Context ctx) {
		Intent i = new Intent(ctx, AppSettingsActivity.class);
		
		ctx.startActivity(i);
	}
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		
		addPreferencesFromResource(R.xml.preferences);
		
		Preference keyFile = findPreference(getString(R.string.keyfile_key));
		keyFile.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {
			
			public boolean onPreferenceChange(Preference preference, Object newValue) {
				Boolean value = (Boolean) newValue;
				
				if ( ! value.booleanValue() ) {
					FileDbHelper helper = App.fileDbHelper;

					helper.deleteAllKeys();
				}
				
				return true;
			}
		});
		
		Database db = App.getDB();
		if ( db.Loaded() && db.pm.appSettingsEnabled() ) {
			Preference rounds = findPreference(getString(R.string.rounds_key));
			rounds.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {
				
				public boolean onPreferenceChange(Preference preference, Object newValue) {
					setRounds(App.getDB(), preference);
					return true;
				}
			});
			
			setRounds(db, rounds);
			
			Preference algorithm = findPreference(getString(R.string.algorithm_key));
			setAlgorithm(db, algorithm);
		} else {
			Preference dbSettings = findPreference(getString(R.string.db_key));
			dbSettings.setEnabled(false);
		}
		
		backupManager = new BackupManagerCompat(this);
		
	}
	
	@Override
	protected void onStop() {
		backupManager.dataChanged();
		
		super.onStop();
	}

	private void setRounds(Database db, Preference rounds) {
		rounds.setSummary(Long.toString(db.pm.getNumRounds()));
	}
	
	private void setAlgorithm(Database db, Preference algorithm) {
		int resId;
		if ( db.pm.getEncAlgorithm() == PwEncryptionAlgorithm.Rjindal ) {
			resId = R.string.rijndael;
		} else  {
			resId = R.string.twofish;
		}
		
		algorithm.setSummary(resId);
	}
	
	

}
",True,242,0,0,11,43,3,7,L8
125,com.keepassdroid.settings.PrefsUtil.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.settings;

import android.content.Context;
import android.content.SharedPreferences;
import android.preference.PreferenceManager;

import com.android.keepass.R;

public class PrefsUtil {
	public static float getListTextSize(Context ctx) {
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);
		return Float.parseFloat(prefs.getString(ctx.getString(R.string.list_size_key), ctx.getString(R.string.list_size_default)));

	}
}
",False,26,8,7,0,0,2,0,L8
126,com.keepassdroid.settings.RoundsPreference.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.settings;


import android.content.Context;
import android.os.Handler;
import android.preference.DialogPreference;
import android.util.AttributeSet;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

import com.android.keepass.R;
import com.keepassdroid.Database;
import com.keepassdroid.ProgressTask;
import com.keepassdroid.app.App;
import com.keepassdroid.database.PwDatabase;
import com.keepassdroid.database.edit.OnFinish;
import com.keepassdroid.database.edit.SaveDB;

public class RoundsPreference extends DialogPreference {
	
	private PwDatabase mPM;
	private TextView mRoundsView;

	@Override
	protected View onCreateDialogView() {
		View view =  super.onCreateDialogView();
		
		mRoundsView = (TextView) view.findViewById(R.id.rounds);
		
		Database db = App.getDB();
		mPM = db.pm;
		long numRounds = mPM.getNumRounds();
		mRoundsView.setText(Long.toString(numRounds));
		
		return view;
	}

	public RoundsPreference(Context context, AttributeSet attrs) {
		super(context, attrs);
	}

	public RoundsPreference(Context context, AttributeSet attrs, int defStyle) {
	   super(context, attrs, defStyle);
   }

	@Override
	protected void onDialogClosed(boolean positiveResult) {
		super.onDialogClosed(positiveResult);

		if ( positiveResult ) {
			int rounds;
			
			try {
				String strRounds = mRoundsView.getText().toString(); 
				rounds = Integer.parseInt(strRounds);
			} catch (NumberFormatException e) {
				Toast.makeText(getContext(), R.string.error_rounds_not_number, Toast.LENGTH_LONG).show();
				return;
			}
			
			if ( rounds < 1 ) {
				rounds = 1;
			}
			
			long oldRounds = mPM.getNumRounds();
			try {
				mPM.setNumRounds(rounds);
			} catch (NumberFormatException e) {
				Toast.makeText(getContext(), R.string.error_rounds_too_large, Toast.LENGTH_LONG).show();
				mPM.setNumRounds(Integer.MAX_VALUE);
			}
			
			Handler handler = new Handler();
			SaveDB save = new SaveDB(App.getDB(), new AfterSave(getContext(), handler, oldRounds));
			ProgressTask pt = new ProgressTask(getContext(), save, R.string.saving_database);
			pt.run();
			
		}

	}
	
	private class AfterSave extends OnFinish {
		private long mOldRounds;
		private Context mCtx;
		
		public AfterSave(Context ctx, Handler handler, long oldRounds) {
			super(handler);
			
			mCtx = ctx;
			mOldRounds = oldRounds;
		}

		@Override
		public void run() {
			if ( mSuccess ) {
				OnPreferenceChangeListener listner = getOnPreferenceChangeListener();
				if ( listner != null ) {
					listner.onPreferenceChange(RoundsPreference.this, null);
				}
			} else {
				displayMessage(mCtx);
				mPM.setNumRounds(mOldRounds);
			}
			
			super.run();
		}
		
	}

}
",True,194,0,0,11,43,0,6,L9
127,com.keepassdroid.fileselect.FileDbHelper.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.fileselect;

import android.content.ContentValues;
import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

public class FileDbHelper {
	
	public static final String LAST_FILENAME = ""lastFile"";
	public static final String LAST_KEYFILE = ""lastKey"";
	
	private static final String DATABASE_NAME = ""keepassdroid"";
	private static final String FILE_TABLE = ""files"";
	private static final int DATABASE_VERSION = 1;
	
	private static final int MAX_FILES = 5;
	
	public static final String KEY_FILE_ID = ""_id"";
	public static final String KEY_FILE_FILENAME = ""fileName"";
	public static final String KEY_FILE_KEYFILE = ""keyFile"";
	public static final String KEY_FILE_UPDATED = ""updated"";

	private static final String DATABASE_CREATE = 
		""create table "" + FILE_TABLE + "" ( "" + KEY_FILE_ID + "" integer primary key autoincrement, "" 
			+ KEY_FILE_FILENAME + "" text not null, "" + KEY_FILE_KEYFILE + "" text, ""
			+ KEY_FILE_UPDATED + "" integer not null);"";
	
	private final Context mCtx;
	private DatabaseHelper mDbHelper;
	private SQLiteDatabase mDb;
	
	private static class DatabaseHelper extends SQLiteOpenHelper {
		private final Context mCtx;
		
		DatabaseHelper(Context ctx) {
			super(ctx, DATABASE_NAME, null, DATABASE_VERSION);
			mCtx = ctx;
		}

		@Override
		public void onCreate(SQLiteDatabase db) {
			db.execSQL(DATABASE_CREATE);
			
			// Migrate preference to database if it is set.
			SharedPreferences settings = mCtx.getSharedPreferences(""PasswordActivity"", Context.MODE_PRIVATE); 
			String lastFile = settings.getString(LAST_FILENAME, """");
			String lastKey = settings.getString(LAST_KEYFILE,"""");
						
			if ( lastFile.length() > 0 ) {
				ContentValues vals = new ContentValues();
				vals.put(KEY_FILE_FILENAME, lastFile);
				vals.put(KEY_FILE_UPDATED, System.currentTimeMillis());
				
				if ( lastKey.length() > 0 ) {
					vals.put(KEY_FILE_KEYFILE, lastKey);
				}
				
				db.insert(FILE_TABLE, null, vals);
				
				// Clear old preferences
				deletePrefs(settings);
				
			}
		}

		@Override
		public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
			// Only one database version so far
		}
		
		private void deletePrefs(SharedPreferences prefs) {
			// We won't worry too much if this fails
			try {
				SharedPreferences.Editor editor = prefs.edit();
				editor.remove(LAST_FILENAME);
				editor.remove(LAST_KEYFILE);
				editor.commit();
			} catch (Exception e) {
				assert(true);
			}
		}
	}
	
	public FileDbHelper(Context ctx) {
		mCtx = ctx;
	}
	
	public FileDbHelper open() throws SQLException {
		mDbHelper = new DatabaseHelper(mCtx);
		mDb = mDbHelper.getWritableDatabase();
		return this;
	}
	
	public boolean isOpen() {
		return mDb.isOpen();
	}
	
	public void close() {
		mDb.close();
	}
	
	public long createFile(String fileName, String keyFile) {
		
		// Check to see if this filename is already used
		Cursor cursor;
		try {
			cursor = mDb.query(true, FILE_TABLE, new String[] {KEY_FILE_ID}, 
					KEY_FILE_FILENAME + ""=?"", new String[] {fileName}, null, null, null, null);
		} catch (Exception e ) {
			assert(true);
			return -1;
		}
		
		long result;
		// If there is an existing entry update it with the new key file
		if ( cursor.getCount() > 0 ) {
			cursor.moveToFirst();
			long id = cursor.getLong(cursor.getColumnIndexOrThrow(KEY_FILE_ID));
			
			ContentValues vals = new ContentValues();
			vals.put(KEY_FILE_KEYFILE, keyFile);
			vals.put(KEY_FILE_UPDATED, System.currentTimeMillis());
			
			result = mDb.update(FILE_TABLE, vals, KEY_FILE_ID + "" = "" + id, null);
		
		// Otherwise add the new entry
		} else {
			ContentValues vals = new ContentValues();
			vals.put(KEY_FILE_FILENAME, fileName);
			vals.put(KEY_FILE_KEYFILE, keyFile);
			vals.put(KEY_FILE_UPDATED, System.currentTimeMillis());
			
			result = mDb.insert(FILE_TABLE, null, vals);
			
		}
		// Delete all but the last five records
		try {
			deleteAllBut(MAX_FILES);
		} catch (Exception e) {
			e.printStackTrace();
			assert(true);
		}
		
		cursor.close();
		
		return result;
		
	}
	
	private void deleteAllBut(int limit) {
		Cursor cursor = mDb.query(FILE_TABLE, new String[] {KEY_FILE_UPDATED}, null, null, null, null, KEY_FILE_UPDATED);
		
		if ( cursor.getCount() > limit ) {
			cursor.moveToFirst();
			long time = cursor.getLong(cursor.getColumnIndexOrThrow(KEY_FILE_UPDATED));
			
			mDb.execSQL(""DELETE FROM "" + FILE_TABLE + "" WHERE "" + KEY_FILE_UPDATED + ""<"" + time + "";"");
		}
		
		cursor.close();
		
	}
	
	public void deleteAllKeys() {
		ContentValues vals = new ContentValues();
		vals.put(KEY_FILE_KEYFILE, """");
		
		mDb.update(FILE_TABLE, vals, null, null);
	}
	
	public void deleteFile(String filename) {
		mDb.delete(FILE_TABLE, KEY_FILE_FILENAME + "" = ?"", new String[] {filename});
	}
	
	
	public Cursor fetchAllFiles() {
		Cursor ret;
		ret = mDb.query(FILE_TABLE, new String[] {KEY_FILE_ID, KEY_FILE_FILENAME, KEY_FILE_KEYFILE }, null, null, null, null, KEY_FILE_UPDATED + "" DESC"", Integer.toString(MAX_FILES));
		return ret;
	}
	
	public Cursor fetchFile(long fileId) throws SQLException {
		Cursor cursor = mDb.query(true, FILE_TABLE, new String[] {KEY_FILE_FILENAME, KEY_FILE_KEYFILE}, 
				KEY_FILE_ID + ""="" + fileId, null, null, null, null, null);
		
		if ( cursor != null ) {
			cursor.moveToFirst();
		}
		
		return cursor;
		
	}
	
	public String getFileByName(String name) {
		Cursor cursor = mDb.query(true, FILE_TABLE, new String[] {KEY_FILE_KEYFILE}, 
				KEY_FILE_FILENAME + ""= ?"", new String[] {name}, null, null, null, null);
		
		if ( cursor == null ) {
			return """";
		}
		
		String filename;
		
		if ( cursor.moveToFirst() ) {
			filename = cursor.getString(0);
		} else {
			// Cursor is empty
			filename = """";
		}
		cursor.close();
		return filename;
	}
	
	public boolean hasRecentFiles() {
		Cursor cursor = fetchAllFiles();
		
		boolean hasRecent = cursor.getCount() > 0;
		cursor.close();
		
		return hasRecent; 
	}
}
",True,66,6,23,0,0,5,0,L6
128,com.keepassdroid.fileselect.BrowserDialog.java,"package com.keepassdroid.fileselect;

import android.app.Dialog;
import android.content.Context;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;

import com.android.keepass.R;
import com.keepassdroid.utils.Util;

public class BrowserDialog extends Dialog {

	public BrowserDialog(Context context) {
		super(context);
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.browser_install);
		setTitle(R.string.file_browser);
		
		Button cancel = (Button) findViewById(R.id.cancel);
		cancel.setOnClickListener(new View.OnClickListener() {
			
			public void onClick(View v) {
				BrowserDialog.this.cancel();
			}
		});
		
		Button market = (Button) findViewById(R.id.install_market);
		market.setOnClickListener(new View.OnClickListener() {
			
			public void onClick(View v) {
				Util.gotoUrl(getContext(), R.string.oi_filemanager_market);
				BrowserDialog.this.cancel();
			}
		});
		
		Button web = (Button) findViewById(R.id.install_web);
		web.setOnClickListener(new View.OnClickListener() {
			
			public void onClick(View v) {
				Util.gotoUrl(getContext(), R.string.oi_filemanager_web);
				BrowserDialog.this.cancel();
			}
		});
	}

}
",False,27,5,12,1,1,2,1,L8
129,com.keepassdroid.fileselect.FileSelectActivity.java,"/*
 * Copyright 2009 Brian Pellin.
 *     
 * This file is part of KeePassDroid.
 *
 *  KeePassDroid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDroid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.keepassdroid.fileselect;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URLDecoder;

import android.app.ListActivity;
import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.preference.PreferenceManager;
import android.view.ContextMenu;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ContextMenu.ContextMenuInfo;
import android.widget.Button;
import android.widget.CursorAdapter;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.ListView;
import android.widget.SimpleCursorAdapter;
import android.widget.TextView;
import android.widget.Toast;
import android.widget.AdapterView.AdapterContextMenuInfo;

import com.android.keepass.R;
import com.keepassdroid.AboutDialog;
import com.keepassdroid.GroupActivity;
import com.keepassdroid.PasswordActivity;
import com.keepassdroid.ProgressTask;
import com.keepassdroid.SetPasswordDialog;
import com.keepassdroid.app.App;
import com.keepassdroid.database.edit.CreateDB;
import com.keepassdroid.database.edit.FileOnFinish;
import com.keepassdroid.intents.Intents;
import com.keepassdroid.settings.AppSettingsActivity;
import com.keepassdroid.utils.Interaction;
import com.keepassdroid.utils.Util;
import com.keepassdroid.view.FileNameView;

public class FileSelectActivity extends ListActivity {

	private static final int MENU_DONATE = Menu.FIRST;
	private static final int MENU_ABOUT = Menu.FIRST + 1;
	private static final int MENU_APP_SETTINGS = Menu.FIRST + 2;
	
	private static final int CMENU_CLEAR = Menu.FIRST;
	
	public static final int FILE_BROWSE = 1;
	
	private FileDbHelper mDbHelper;

	private boolean recentMode = false;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		
		mDbHelper = App.fileDbHelper;

		if (mDbHelper.hasRecentFiles()) {
			recentMode = true;
			setContentView(R.layout.file_selection);
		} else {
			setContentView(R.layout.file_selection_no_recent);
		}

		// Open button
		Button openButton = (Button) findViewById(R.id.open);
		openButton.setOnClickListener(new View.OnClickListener() {

			public void onClick(View v) {
				String fileName = Util.getEditText(FileSelectActivity.this,
						R.id.file_filename);

				try {
					PasswordActivity.Launch(FileSelectActivity.this, fileName);
				} catch (FileNotFoundException e) {
					Toast.makeText(FileSelectActivity.this,
							R.string.FileNotFound, Toast.LENGTH_LONG).show();
				}

			}
		});

		// Create button
		Button createButton = (Button) findViewById(R.id.create);
		createButton.setOnClickListener(new View.OnClickListener() {

			public void onClick(View v) {
				String filename = Util.getEditText(FileSelectActivity.this,
						R.id.file_filename);

				// Make sure file name exists
				if (filename.length() == 0) {
					Toast
							.makeText(FileSelectActivity.this,
									R.string.error_filename_required,
									Toast.LENGTH_LONG).show();
					return;
				}

				// Try to create the file
				File file = new File(filename);
				try {
					if (file.exists()) {
						Toast.makeText(FileSelectActivity.this,
								R.string.error_database_exists,
								Toast.LENGTH_LONG).show();
						return;
					}
					File parent = file.getParentFile();
					
					if ( parent == null || (parent.exists() && ! parent.isDirectory()) ) {
						Toast.makeText(FileSelectActivity.this,
								R.string.error_invalid_path,
								Toast.LENGTH_LONG).show();
						return;
					}
					
					if ( ! parent.exists() ) {
						// Create parent dircetory
						if ( ! parent.mkdirs() ) {
							Toast.makeText(FileSelectActivity.this,
									R.string.error_could_not_create_parent,
									Toast.LENGTH_LONG).show();
							return;
							
						}
					}
					
					file.createNewFile();
				} catch (IOException e) {
					Toast.makeText(
							FileSelectActivity.this,
							getText(R.string.error_file_not_create) + "" ""
									+ e.getLocalizedMessage(),
							Toast.LENGTH_LONG).show();
					return;
				}

				// Prep an object to collect a password once the database has
				// been created
				CollectPassword password = new CollectPassword(
						new LaunchGroupActivity(filename));

				// Create the new database
				CreateDB create = new CreateDB(filename, password, true);
				ProgressTask createTask = new ProgressTask(
						FileSelectActivity.this, create,
						R.string.progress_create);
				createTask.run();

			}

		});
		
		ImageButton browseButton = (ImageButton) findViewById(R.id.browse_button);
		browseButton.setOnClickListener(new View.OnClickListener() {
			
			public void onClick(View v) {
				if (Interaction.isIntentAvailable(FileSelectActivity.this, Intents.FILE_BROWSE)) {
					Intent i = new Intent(Intents.FILE_BROWSE);
					i.setData(Uri.parse(""file://"" + Util.getEditText(FileSelectActivity.this, R.id.file_filename)));
					startActivityForResult(i, FILE_BROWSE);
					
				} else {
					BrowserDialog diag = new BrowserDialog(FileSelectActivity.this);
					diag.show();
				}
				
			}
		});

		fillData();
		
		registerForContextMenu(getListView());
		
		// Load default database
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
		String fileName = prefs.getString(PasswordActivity.KEY_DEFAULT_FILENAME, """");
		if (fileName.length() > 0) {
			try {
				PasswordActivity.Launch(FileSelectActivity.this, fileName);
			} catch (Exception e) {
				// Ignore exception
			}
		}
	}

	private class LaunchGroupActivity extends FileOnFinish {
		private String mFilename;

		public LaunchGroupActivity(String filename) {
			super(null);

			mFilename = filename;
		}

		@Override
		public void run() {
			if (mSuccess) {
				// Add to recent files
				FileDbHelper dbHelper = App.fileDbHelper;

				dbHelper.createFile(mFilename, getFilename());

				GroupActivity.Launch(FileSelectActivity.this);

			} else {
				File file = new File(mFilename);
				file.delete();
			}
		}
	}

	private class CollectPassword extends FileOnFinish {

		public CollectPassword(FileOnFinish finish) {
			super(finish);
		}

		@Override
		public void run() {
			SetPasswordDialog password = new SetPasswordDialog(FileSelectActivity.this, mOnFinish);
			password.show();
		}

	}

	private void fillData() {
		// Set the initial value of the filename
		EditText filename = (EditText) findViewById(R.id.file_filename);
		filename.setText(Environment.getExternalStorageDirectory() + getString(R.string.default_file_path));
		
		// Get all of the rows from the database and create the item list
		Cursor filesCursor = mDbHelper.fetchAllFiles();
		startManagingCursor(filesCursor);

		// Create an array to specify the fields we want to display in the list
		// (only TITLE)
		String[] from = new String[] { FileDbHelper.KEY_FILE_FILENAME };

		// and an array of the fields we want to bind those fields to (in this
		// case just text1)
		int[] to = new int[] { R.id.file_filename };

		// Now create a simple cursor adapter and set it to display
		SimpleCursorAdapter notes = new SimpleCursorAdapter(this,
				R.layout.file_row, filesCursor, from, to);
		setListAdapter(notes);
	}

	@Override
	protected void onListItemClick(ListView l, View v, int position, long id) {
		super.onListItemClick(l, v, position, id);

		Cursor cursor = mDbHelper.fetchFile(id);
		startManagingCursor(cursor);

		String fileName = cursor.getString(cursor
				.getColumnIndexOrThrow(FileDbHelper.KEY_FILE_FILENAME));
		String keyFile = cursor.getString(cursor
				.getColumnIndexOrThrow(FileDbHelper.KEY_FILE_KEYFILE));

		try {
			PasswordActivity.Launch(this, fileName, keyFile);
		} catch (FileNotFoundException e) {
			Toast.makeText(this, R.string.FileNotFound, Toast.LENGTH_LONG)
					.show();
		}
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		super.onActivityResult(requestCode, resultCode, data);

		fillData();
		
		if (requestCode == FILE_BROWSE && resultCode == RESULT_OK) {
			String filename = data.getDataString();
			if (filename != null) {
				if (filename.startsWith(""file://"")) {
					filename = filename.substring(7);
				}
				
				filename = URLDecoder.decode(filename);
				
				EditText fn = (EditText) findViewById(R.id.file_filename);
				fn.setText(filename);
				
			}
			
		}
	}

	@Override
	protected void onResume() {
		super.onResume();
		
		// Check to see if we need to change modes
		if ( mDbHelper.hasRecentFiles() != recentMode ) {
			// Restart the activity
			Intent intent = getIntent();
			startActivity(intent);
			finish();
		}
		
		FileNameView fnv = (FileNameView) findViewById(R.id.file_select);
		fnv.updateExternalStorageWarning();
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);

		menu.add(0, MENU_DONATE, 0, R.string.menu_donate);
		menu.findItem(MENU_DONATE).setIcon(android.R.drawable.ic_menu_share);

		menu.add(0, MENU_APP_SETTINGS, 0, R.string.menu_app_settings);
		menu.findItem(MENU_APP_SETTINGS).setIcon(android.R.drawable.ic_menu_preferences);
		
		menu.add(0, MENU_ABOUT, 0, R.string.menu_about);
		menu.findItem(MENU_ABOUT).setIcon(android.R.drawable.ic_menu_help);

		return true;
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		case MENU_DONATE:
			try {
				Util.gotoUrl(this, R.string.donate_url);
			} catch (ActivityNotFoundException e) {
				Toast.makeText(this, R.string.error_failed_to_launch_link, Toast.LENGTH_LONG).show();
				return false;
			}
			
			return true;
			
		case MENU_ABOUT:
			AboutDialog dialog = new AboutDialog(this);
			dialog.show();
			return true;
			
		case MENU_APP_SETTINGS:
			AppSettingsActivity.Launch(this);
			return true;
		}

		return super.onOptionsItemSelected(item);
	}

	@Override
	public void onCreateContextMenu(ContextMenu menu, View v,
			ContextMenuInfo menuInfo) {
		super.onCreateContextMenu(menu, v, menuInfo);
		
		menu.add(0, CMENU_CLEAR, 0, R.string.remove_from_filelist);
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		super.onContextItemSelected(item);
		
		if ( item.getItemId() == CMENU_CLEAR ) {
			AdapterContextMenuInfo acmi = (AdapterContextMenuInfo) item.getMenuInfo();
			
			TextView tv = (TextView) acmi.targetView;
			String filename = tv.getText().toString();
			mDbHelper.deleteFile(filename);
			
			refreshList();
			
			return true;
		}
		
		return false;
	}
	
	private void refreshList() {
		CursorAdapter ca = (CursorAdapter) getListAdapter();
		Cursor cursor = ca.getCursor();
		cursor.requery();
	}

}
",True,242,0,0,12,43,1,16,L8
