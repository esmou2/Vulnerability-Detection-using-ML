,file_path,source_code,is_vulnerable, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,com.fsck.k9.Preferences.java,"
package com.fsck.k9;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import android.content.Context;
import android.content.SharedPreferences;
import android.util.Config;
import android.util.Log;
import com.fsck.k9.preferences.Editor;
import com.fsck.k9.preferences.Storage;

public class Preferences {

    /**
     * Immutable empty {@link Account} array
     */
    private static final Account[] EMPTY_ACCOUNT_ARRAY = new Account[0];

    private static Preferences preferences;

    public static synchronized Preferences getPreferences(Context context) {
        if (preferences == null) {
            preferences = new Preferences(context);
        }
        return preferences;
    }


    private Storage mStorage;
    private List<Account> accounts;
    private Account newAccount;
    private Context mContext;

    private Preferences(Context context) {
        mStorage = Storage.getStorage(context);
        mContext = context;
        if (mStorage.size() == 0) {
            Log.i(K9.LOG_TAG, ""Preferences storage is zero-size, importing from Android-style preferences"");
            Editor editor = mStorage.edit();
            editor.copy(context.getSharedPreferences(""AndroidMail.Main"", Context.MODE_PRIVATE));
            editor.commit();
        }
    }

    private synchronized void loadAccounts() {
        String accountUuids = getPreferences().getString(""accountUuids"", null);
        if ((accountUuids != null) && (accountUuids.length() != 0)) {
            String[] uuids = accountUuids.split("","");
            accounts = new ArrayList<Account>(uuids.length);
            for (String uuid : uuids) {
                accounts.add(new Account(this, uuid));
            }
        } else {
            accounts = new ArrayList<Account>();
        }
    }

    /**
     * Returns an array of the accounts on the system. If no accounts are
     * registered the method returns an empty array.
     * @return all accounts
     */
    public synchronized Account[] getAccounts() {
        if (accounts == null) {
            loadAccounts();
        }

        if ((newAccount != null) && newAccount.getAccountNumber() != -1) {
            accounts.add(newAccount);
            newAccount = null;
        }

        return accounts.toArray(EMPTY_ACCOUNT_ARRAY);
    }

    /**
     * Returns an array of the accounts on the system. If no accounts are
     * registered the method returns an empty array.
     * @return all accounts with {@link Account#isAvailable(Context)}
     */
    public synchronized Collection<Account> getAvailableAccounts() {
        if (accounts == null) {
            loadAccounts();
        }

        if ((newAccount != null) && newAccount.getAccountNumber() != -1) {
            accounts.add(newAccount);
            newAccount = null;
        }
        Collection<Account> retval = new ArrayList<Account>(accounts.size());
        for (Account account : accounts) {
            if (account.isAvailable(mContext)) {
                retval.add(account);
            }
        }

        return retval;
    }

    public synchronized Account getAccount(String uuid) {
        if (accounts == null) {
            loadAccounts();
        }

        for (Account account : accounts) {
            if (account.getUuid().equals(uuid)) {
                return account;
            }
        }

        if ((newAccount != null) && newAccount.getUuid().equals(uuid)) {
            return newAccount;
        }

        return null;
    }

    public synchronized Account newAccount() {
        newAccount = new Account(K9.app);

        return newAccount;
    }

    public synchronized void deleteAccount(Account account) {
        accounts.remove(account);
        account.delete(this);

        if (newAccount == account) {
            newAccount = null;
        }
    }

    /**
     * Returns the Account marked as default. If no account is marked as default
     * the first account in the list is marked as default and then returned. If
     * there are no accounts on the system the method returns null.
     */
    public Account getDefaultAccount() {
        String defaultAccountUuid = getPreferences().getString(""defaultAccountUuid"", null);
        Account defaultAccount = getAccount(defaultAccountUuid);

        if (defaultAccount == null) {
            Collection<Account> accounts = getAvailableAccounts();
            if (accounts.size() > 0) {
                defaultAccount = accounts.iterator().next();
                setDefaultAccount(defaultAccount);
            }
        }

        return defaultAccount;
    }

    public void setDefaultAccount(Account account) {
        getPreferences().edit().putString(""defaultAccountUuid"", account.getUuid()).commit();
    }

    public void dump() {
        if (Config.LOGV) {
            for (String key : getPreferences().getAll().keySet()) {
                Log.v(K9.LOG_TAG, key + "" = "" + getPreferences().getAll().get(key));
            }
        }
    }

    public SharedPreferences getPreferences() {
        return mStorage;
    }
}
",True,148,1,4,6,52,35,4,L1
1,com.fsck.k9.Account.java,"
package com.fsck.k9;

import android.content.Context;
import android.content.SharedPreferences;
import android.net.ConnectivityManager;
import android.net.Uri;
import android.util.Log;

import com.fsck.k9.crypto.Apg;
import com.fsck.k9.crypto.CryptoProvider;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.StorageManager;
import com.fsck.k9.mail.store.StorageManager.StorageProvider;
import com.fsck.k9.view.ColorChip;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Account stores all of the settings for a single account defined by the user. It is able to save
 * and delete itself given a Preferences to work with. Each account is defined by a UUID.
 */
public class Account implements BaseAccount {
    /**
     * Default value for the inbox folder (never changes for POP3 and IMAP)
     */
    public static final String INBOX = ""INBOX"";

    /**
     * This local folder is used to store messages to be sent.
     */
    public static final String OUTBOX = ""K9MAIL_INTERNAL_OUTBOX"";

    public static final String EXPUNGE_IMMEDIATELY = ""EXPUNGE_IMMEDIATELY"";
    public static final String EXPUNGE_MANUALLY = ""EXPUNGE_MANUALLY"";
    public static final String EXPUNGE_ON_POLL = ""EXPUNGE_ON_POLL"";

    public static final int DELETE_POLICY_NEVER = 0;
    public static final int DELETE_POLICY_7DAYS = 1;
    public static final int DELETE_POLICY_ON_DELETE = 2;
    public static final int DELETE_POLICY_MARK_AS_READ = 3;

    public static final String TYPE_WIFI = ""WIFI"";
    public static final String TYPE_MOBILE = ""MOBILE"";
    public static final String TYPE_OTHER = ""OTHER"";
    private static final String[] networkTypes = { TYPE_WIFI, TYPE_MOBILE, TYPE_OTHER };

    private static final MessageFormat DEFAULT_MESSAGE_FORMAT = MessageFormat.HTML;
    private static final QuoteStyle DEFAULT_QUOTE_STYLE = QuoteStyle.PREFIX;
    private static final String DEFAULT_QUOTE_PREFIX = "">"";
    private static final boolean DEFAULT_QUOTED_TEXT_SHOWN = true;
    private static final boolean DEFAULT_REPLY_AFTER_QUOTE = false;

    /**
     * <pre>
     * 0 - Never (DELETE_POLICY_NEVER)
     * 1 - After 7 days (DELETE_POLICY_7DAYS)
     * 2 - When I delete from inbox (DELETE_POLICY_ON_DELETE)
     * 3 - Mark as read (DELETE_POLICY_MARK_AS_READ)
     * </pre>
     */
    private int mDeletePolicy;

    private final String mUuid;
    private String mStoreUri;

    /**
     * Storage provider ID, used to locate and manage the underlying DB/file
     * storage
     */
    private String mLocalStorageProviderId;
    private String mTransportUri;
    private String mDescription;
    private String mAlwaysBcc;
    private int mAutomaticCheckIntervalMinutes;
    private int mDisplayCount;
    private int mChipColor;
    private long mLastAutomaticCheckTime;
    private long mLatestOldMessageSeenTime;
    private boolean mNotifyNewMail;
    private boolean mNotifySelfNewMail;
    private String mInboxFolderName;
    private String mDraftsFolderName;
    private String mSentFolderName;
    private String mTrashFolderName;
    private String mArchiveFolderName;
    private String mSpamFolderName;
    private String mAutoExpandFolderName;
    private FolderMode mFolderDisplayMode;
    private FolderMode mFolderSyncMode;
    private FolderMode mFolderPushMode;
    private FolderMode mFolderTargetMode;
    private int mAccountNumber;
    private boolean mSaveAllHeaders;
    private boolean mPushPollOnConnect;
    private boolean mNotifySync;
    private ScrollButtons mScrollMessageViewButtons;
    private ScrollButtons mScrollMessageViewMoveButtons;
    private ShowPictures mShowPictures;
    private boolean mEnableMoveButtons;
    private boolean mIsSignatureBeforeQuotedText;
    private String mExpungePolicy = EXPUNGE_IMMEDIATELY;
    private int mMaxPushFolders;
    private int mIdleRefreshMinutes;
    private boolean goToUnreadMessageSearch;
    private boolean mNotificationShowsUnreadCount;
    private final Map<String, Boolean> compressionMap = new ConcurrentHashMap<String, Boolean>();
    private Searchable searchableFolders;
    private boolean subscribedFoldersOnly;
    private int maximumPolledMessageAge;
    private int maximumAutoDownloadMessageSize;
    // Tracks if we have sent a notification for this account for
    // current set of fetched messages
    private boolean mRingNotified;
    private MessageFormat mMessageFormat;
    private QuoteStyle mQuoteStyle;
    private String mQuotePrefix;
    private boolean mDefaultQuotedTextShown;
    private boolean mReplyAfterQuote;
    private boolean mSyncRemoteDeletions;
    private String mCryptoApp;
    private boolean mCryptoAutoSignature;

    private CryptoProvider mCryptoProvider = null;

    /**
     * Name of the folder that was last selected for a copy or move operation.
     *
     * Note: For now this value isn't persisted. So it will be reset when
     *       K-9 Mail is restarted.
     */
    private String lastSelectedFolderName = null;

    private List<Identity> identities;

    private NotificationSetting mNotificationSetting = new NotificationSetting();

    public enum FolderMode {
        NONE, ALL, FIRST_CLASS, FIRST_AND_SECOND_CLASS, NOT_SECOND_CLASS
    }

    public enum ScrollButtons {
        NEVER, ALWAYS, KEYBOARD_AVAILABLE
    }

    public enum ShowPictures {
        NEVER, ALWAYS, ONLY_FROM_CONTACTS
    }

    public enum Searchable {
        ALL, DISPLAYABLE, NONE
    }

    public enum QuoteStyle {
        PREFIX, HEADER
    }

    public enum MessageFormat {
        TEXT, HTML
    }

    protected Account(Context context) {
        mUuid = UUID.randomUUID().toString();
        mLocalStorageProviderId = StorageManager.getInstance(K9.app).getDefaultProviderId();
        mAutomaticCheckIntervalMinutes = -1;
        mIdleRefreshMinutes = 24;
        mSaveAllHeaders = true;
        mPushPollOnConnect = true;
        mDisplayCount = K9.DEFAULT_VISIBLE_LIMIT;
        mAccountNumber = -1;
        mNotifyNewMail = true;
        mNotifySync = true;
        mNotifySelfNewMail = true;
        mFolderDisplayMode = FolderMode.NOT_SECOND_CLASS;
        mFolderSyncMode = FolderMode.FIRST_CLASS;
        mFolderPushMode = FolderMode.FIRST_CLASS;
        mFolderTargetMode = FolderMode.NOT_SECOND_CLASS;
        mScrollMessageViewButtons = ScrollButtons.NEVER;
        mScrollMessageViewMoveButtons = ScrollButtons.NEVER;
        mShowPictures = ShowPictures.NEVER;
        mEnableMoveButtons = false;
        mIsSignatureBeforeQuotedText = false;
        mExpungePolicy = EXPUNGE_IMMEDIATELY;
        mAutoExpandFolderName = INBOX;
        mInboxFolderName = INBOX;
        mMaxPushFolders = 10;
        mChipColor = (new Random()).nextInt(0xffffff) + 0xff000000;
        goToUnreadMessageSearch = false;
        mNotificationShowsUnreadCount = true;
        subscribedFoldersOnly = false;
        maximumPolledMessageAge = -1;
        maximumAutoDownloadMessageSize = 32768;
        mMessageFormat = DEFAULT_MESSAGE_FORMAT;
        mQuoteStyle = DEFAULT_QUOTE_STYLE;
        mQuotePrefix = DEFAULT_QUOTE_PREFIX;
        mDefaultQuotedTextShown = DEFAULT_QUOTED_TEXT_SHOWN;
        mReplyAfterQuote = DEFAULT_REPLY_AFTER_QUOTE;
        mSyncRemoteDeletions = true;
        mCryptoApp = Apg.NAME;
        mCryptoAutoSignature = false;

        searchableFolders = Searchable.ALL;

        identities = new ArrayList<Identity>();

        Identity identity = new Identity();
        identity.setSignatureUse(true);
        identity.setSignature(context.getString(R.string.default_signature));
        identity.setDescription(context.getString(R.string.default_identity_description));
        identities.add(identity);

        mNotificationSetting = new NotificationSetting();
        mNotificationSetting.setVibrate(false);
        mNotificationSetting.setVibratePattern(0);
        mNotificationSetting.setVibrateTimes(5);
        mNotificationSetting.setRing(true);
        mNotificationSetting.setRingtone(""content://settings/system/notification_sound"");
        mNotificationSetting.setLedColor(mChipColor);
    }

    protected Account(Preferences preferences, String uuid) {
        this.mUuid = uuid;
        loadAccount(preferences);
    }

    /**
     * Load stored settings for this account.
     */
    private synchronized void loadAccount(Preferences preferences) {

        SharedPreferences prefs = preferences.getPreferences();

        mStoreUri = Utility.base64Decode(prefs.getString(mUuid + "".storeUri"", null));
        mLocalStorageProviderId = prefs.getString(mUuid + "".localStorageProvider"", StorageManager.getInstance(K9.app).getDefaultProviderId());
        mTransportUri = Utility.base64Decode(prefs.getString(mUuid + "".transportUri"", null));
        mDescription = prefs.getString(mUuid + "".description"", null);
        mAlwaysBcc = prefs.getString(mUuid + "".alwaysBcc"", mAlwaysBcc);
        mAutomaticCheckIntervalMinutes = prefs.getInt(mUuid + "".automaticCheckIntervalMinutes"", -1);
        mIdleRefreshMinutes = prefs.getInt(mUuid + "".idleRefreshMinutes"", 24);
        mSaveAllHeaders = prefs.getBoolean(mUuid + "".saveAllHeaders"", true);
        mPushPollOnConnect = prefs.getBoolean(mUuid + "".pushPollOnConnect"", true);
        mDisplayCount = prefs.getInt(mUuid + "".displayCount"", K9.DEFAULT_VISIBLE_LIMIT);
        if (mDisplayCount < 0) {
            mDisplayCount = K9.DEFAULT_VISIBLE_LIMIT;
        }
        mLastAutomaticCheckTime = prefs.getLong(mUuid + "".lastAutomaticCheckTime"", 0);
        mLatestOldMessageSeenTime = prefs.getLong(mUuid + "".latestOldMessageSeenTime"", 0);
        mNotifyNewMail = prefs.getBoolean(mUuid + "".notifyNewMail"", false);
        mNotifySelfNewMail = prefs.getBoolean(mUuid + "".notifySelfNewMail"", true);
        mNotifySync = prefs.getBoolean(mUuid + "".notifyMailCheck"", false);
        mDeletePolicy = prefs.getInt(mUuid + "".deletePolicy"", 0);
        mInboxFolderName = prefs.getString(mUuid  + "".inboxFolderName"", INBOX);
        mDraftsFolderName = prefs.getString(mUuid  + "".draftsFolderName"", ""Drafts"");
        mSentFolderName = prefs.getString(mUuid  + "".sentFolderName"", ""Sent"");
        mTrashFolderName = prefs.getString(mUuid  + "".trashFolderName"", ""Trash"");
        mArchiveFolderName = prefs.getString(mUuid  + "".archiveFolderName"", ""Archive"");
        mSpamFolderName = prefs.getString(mUuid  + "".spamFolderName"", ""Spam"");
        mExpungePolicy = prefs.getString(mUuid  + "".expungePolicy"", EXPUNGE_IMMEDIATELY);
        mSyncRemoteDeletions = prefs.getBoolean(mUuid  + "".syncRemoteDeletions"", true);

        mMaxPushFolders = prefs.getInt(mUuid + "".maxPushFolders"", 10);
        goToUnreadMessageSearch = prefs.getBoolean(mUuid + "".goToUnreadMessageSearch"", false);
        mNotificationShowsUnreadCount = prefs.getBoolean(mUuid + "".notificationUnreadCount"", true);
        subscribedFoldersOnly = prefs.getBoolean(mUuid + "".subscribedFoldersOnly"", false);
        maximumPolledMessageAge = prefs.getInt(mUuid + "".maximumPolledMessageAge"", -1);
        maximumAutoDownloadMessageSize = prefs.getInt(mUuid + "".maximumAutoDownloadMessageSize"", 32768);
        mMessageFormat = MessageFormat.valueOf(prefs.getString(mUuid + "".messageFormat"", DEFAULT_MESSAGE_FORMAT.name()));
        mQuoteStyle = QuoteStyle.valueOf(prefs.getString(mUuid + "".quoteStyle"", DEFAULT_QUOTE_STYLE.name()));
        mQuotePrefix = prefs.getString(mUuid + "".quotePrefix"", DEFAULT_QUOTE_PREFIX);
        mDefaultQuotedTextShown = prefs.getBoolean(mUuid + "".defaultQuotedTextShown"", DEFAULT_QUOTED_TEXT_SHOWN);
        mReplyAfterQuote = prefs.getBoolean(mUuid + "".replyAfterQuote"", DEFAULT_REPLY_AFTER_QUOTE);
        for (String type : networkTypes) {
            Boolean useCompression = prefs.getBoolean(mUuid + "".useCompression."" + type,
                                     true);
            compressionMap.put(type, useCompression);
        }

        mAutoExpandFolderName = prefs.getString(mUuid  + "".autoExpandFolderName"", INBOX);

        mAccountNumber = prefs.getInt(mUuid + "".accountNumber"", 0);

        Random random = new Random((long)mAccountNumber + 4);

        mChipColor = prefs.getInt(mUuid + "".chipColor"",
                                  (random.nextInt(0x70)) +
                                  (random.nextInt(0x70) * 0xff) +
                                  (random.nextInt(0x70) * 0xffff) +
                                  0xff000000);

        try {
            mScrollMessageViewButtons = ScrollButtons.valueOf(prefs.getString(mUuid + "".hideButtonsEnum"",
                                        ScrollButtons.NEVER.name()));
        } catch (Exception e) {
            mScrollMessageViewButtons = ScrollButtons.NEVER;
        }

        try {
            mScrollMessageViewMoveButtons = ScrollButtons.valueOf(prefs.getString(mUuid + "".hideMoveButtonsEnum"",
                                            ScrollButtons.NEVER.name()));
        } catch (Exception e) {
            mScrollMessageViewMoveButtons = ScrollButtons.NEVER;
        }

        try {
            mShowPictures = ShowPictures.valueOf(prefs.getString(mUuid + "".showPicturesEnum"",
                                                 ShowPictures.NEVER.name()));
        } catch (Exception e) {
            mShowPictures = ShowPictures.NEVER;
        }

        mEnableMoveButtons = prefs.getBoolean(mUuid + "".enableMoveButtons"", false);

        mNotificationSetting.setVibrate(prefs.getBoolean(mUuid + "".vibrate"", false));
        mNotificationSetting.setVibratePattern(prefs.getInt(mUuid + "".vibratePattern"", 0));
        mNotificationSetting.setVibrateTimes(prefs.getInt(mUuid + "".vibrateTimes"", 5));
        mNotificationSetting.setRing(prefs.getBoolean(mUuid + "".ring"", true));
        mNotificationSetting.setRingtone(prefs.getString(mUuid  + "".ringtone"",
                                         ""content://settings/system/notification_sound""));
        mNotificationSetting.setLed(prefs.getBoolean(mUuid + "".led"", true));
        mNotificationSetting.setLedColor(prefs.getInt(mUuid + "".ledColor"", mChipColor));

        try {
            mFolderDisplayMode = FolderMode.valueOf(prefs.getString(mUuid  + "".folderDisplayMode"",
                                                    FolderMode.NOT_SECOND_CLASS.name()));
        } catch (Exception e) {
            mFolderDisplayMode = FolderMode.NOT_SECOND_CLASS;
        }

        try {
            mFolderSyncMode = FolderMode.valueOf(prefs.getString(mUuid  + "".folderSyncMode"",
                                                 FolderMode.FIRST_CLASS.name()));
        } catch (Exception e) {
            mFolderSyncMode = FolderMode.FIRST_CLASS;
        }

        try {
            mFolderPushMode = FolderMode.valueOf(prefs.getString(mUuid  + "".folderPushMode"",
                                                 FolderMode.FIRST_CLASS.name()));
        } catch (Exception e) {
            mFolderPushMode = FolderMode.FIRST_CLASS;
        }

        try {
            mFolderTargetMode = FolderMode.valueOf(prefs.getString(mUuid  + "".folderTargetMode"",
                                                   FolderMode.NOT_SECOND_CLASS.name()));
        } catch (Exception e) {
            mFolderTargetMode = FolderMode.NOT_SECOND_CLASS;
        }

        try {
            searchableFolders = Searchable.valueOf(prefs.getString(mUuid  + "".searchableFolders"",
                                                   Searchable.ALL.name()));
        } catch (Exception e) {
            searchableFolders = Searchable.ALL;
        }

        mIsSignatureBeforeQuotedText = prefs.getBoolean(mUuid  + "".signatureBeforeQuotedText"", false);
        identities = loadIdentities(prefs);

        mCryptoApp = prefs.getString(mUuid + "".cryptoApp"", Apg.NAME);
        mCryptoAutoSignature = prefs.getBoolean(mUuid + "".cryptoAutoSignature"", false);
    }


    protected synchronized void delete(Preferences preferences) {
        String[] uuids = preferences.getPreferences().getString(""accountUuids"", """").split("","");
        StringBuffer sb = new StringBuffer();
        for (int i = 0, length = uuids.length; i < length; i++) {
            if (!uuids[i].equals(mUuid)) {
                if (sb.length() > 0) {
                    sb.append(',');
                }
                sb.append(uuids[i]);
            }
        }
        String accountUuids = sb.toString();
        SharedPreferences.Editor editor = preferences.getPreferences().edit();
        editor.putString(""accountUuids"", accountUuids);

        editor.remove(mUuid + "".storeUri"");
        editor.remove(mUuid + "".localStoreUri"");
        editor.remove(mUuid + "".transportUri"");
        editor.remove(mUuid + "".description"");
        editor.remove(mUuid + "".name"");
        editor.remove(mUuid + "".email"");
        editor.remove(mUuid + "".alwaysBcc"");
        editor.remove(mUuid + "".automaticCheckIntervalMinutes"");
        editor.remove(mUuid + "".pushPollOnConnect"");
        editor.remove(mUuid + "".saveAllHeaders"");
        editor.remove(mUuid + "".idleRefreshMinutes"");
        editor.remove(mUuid + "".lastAutomaticCheckTime"");
        editor.remove(mUuid + "".latestOldMessageSeenTime"");
        editor.remove(mUuid + "".notifyNewMail"");
        editor.remove(mUuid + "".notifySelfNewMail"");
        editor.remove(mUuid + "".deletePolicy"");
        editor.remove(mUuid + "".draftsFolderName"");
        editor.remove(mUuid + "".sentFolderName"");
        editor.remove(mUuid + "".trashFolderName"");
        editor.remove(mUuid + "".archiveFolderName"");
        editor.remove(mUuid + "".spamFolderName"");
        editor.remove(mUuid + "".autoExpandFolderName"");
        editor.remove(mUuid + "".accountNumber"");
        editor.remove(mUuid + "".vibrate"");
        editor.remove(mUuid + "".vibratePattern"");
        editor.remove(mUuid + "".vibrateTimes"");
        editor.remove(mUuid + "".ring"");
        editor.remove(mUuid + "".ringtone"");
        editor.remove(mUuid + "".lastFullSync"");
        editor.remove(mUuid + "".folderDisplayMode"");
        editor.remove(mUuid + "".folderSyncMode"");
        editor.remove(mUuid + "".folderPushMode"");
        editor.remove(mUuid + "".folderTargetMode"");
        editor.remove(mUuid + "".hideButtonsEnum"");
        editor.remove(mUuid + "".signatureBeforeQuotedText"");
        editor.remove(mUuid + "".expungePolicy"");
        editor.remove(mUuid + "".syncRemoteDeletions"");
        editor.remove(mUuid + "".maxPushFolders"");
        editor.remove(mUuid + "".searchableFolders"");
        editor.remove(mUuid + "".chipColor"");
        editor.remove(mUuid + "".led"");
        editor.remove(mUuid + "".ledColor"");
        editor.remove(mUuid + "".goToUnreadMessageSearch"");
        editor.remove(mUuid + "".notificationUnreadCount"");
        editor.remove(mUuid + "".subscribedFoldersOnly"");
        editor.remove(mUuid + "".maximumPolledMessageAge"");
        editor.remove(mUuid + "".maximumAutoDownloadMessageSize"");
        editor.remove(mUuid + "".quoteStyle"");
        editor.remove(mUuid + "".quotePrefix"");
        editor.remove(mUuid + "".showPicturesEnum"");
        editor.remove(mUuid + "".replyAfterQuote"");
        editor.remove(mUuid + "".cryptoApp"");
        editor.remove(mUuid + "".cryptoAutoSignature"");
        editor.remove(mUuid + "".enableMoveButtons"");
        editor.remove(mUuid + "".hideMoveButtonsEnum"");
        for (String type : networkTypes) {
            editor.remove(mUuid + "".useCompression."" + type);
        }
        deleteIdentities(preferences.getPreferences(), editor);
        editor.commit();
    }

    public synchronized void save(Preferences preferences) {
        SharedPreferences.Editor editor = preferences.getPreferences().edit();

        if (!preferences.getPreferences().getString(""accountUuids"", """").contains(mUuid)) {
            /*
             * When the account is first created we assign it a unique account number. The
             * account number will be unique to that account for the lifetime of the account.
             * So, we get all the existing account numbers, sort them ascending, loop through
             * the list and check if the number is greater than 1 + the previous number. If so
             * we use the previous number + 1 as the account number. This refills gaps.
             * mAccountNumber starts as -1 on a newly created account. It must be -1 for this
             * algorithm to work.
             *
             * I bet there is a much smarter way to do this. Anyone like to suggest it?
             */
            Account[] accounts = preferences.getAccounts();
            int[] accountNumbers = new int[accounts.length];
            for (int i = 0; i < accounts.length; i++) {
                accountNumbers[i] = accounts[i].getAccountNumber();
            }
            Arrays.sort(accountNumbers);
            for (int accountNumber : accountNumbers) {
                if (accountNumber > mAccountNumber + 1) {
                    break;
                }
                mAccountNumber = accountNumber;
            }
            mAccountNumber++;

            String accountUuids = preferences.getPreferences().getString(""accountUuids"", """");
            accountUuids += (accountUuids.length() != 0 ? "","" : """") + mUuid;
            editor.putString(""accountUuids"", accountUuids);
        }

        editor.putString(mUuid + "".storeUri"", Utility.base64Encode(mStoreUri));
        editor.putString(mUuid + "".localStorageProvider"", mLocalStorageProviderId);
        editor.putString(mUuid + "".transportUri"", Utility.base64Encode(mTransportUri));
        editor.putString(mUuid + "".description"", mDescription);
        editor.putString(mUuid + "".alwaysBcc"", mAlwaysBcc);
        editor.putInt(mUuid + "".automaticCheckIntervalMinutes"", mAutomaticCheckIntervalMinutes);
        editor.putInt(mUuid + "".idleRefreshMinutes"", mIdleRefreshMinutes);
        editor.putBoolean(mUuid + "".saveAllHeaders"", mSaveAllHeaders);
        editor.putBoolean(mUuid + "".pushPollOnConnect"", mPushPollOnConnect);
        editor.putInt(mUuid + "".displayCount"", mDisplayCount);
        editor.putLong(mUuid + "".lastAutomaticCheckTime"", mLastAutomaticCheckTime);
        editor.putLong(mUuid + "".latestOldMessageSeenTime"", mLatestOldMessageSeenTime);
        editor.putBoolean(mUuid + "".notifyNewMail"", mNotifyNewMail);
        editor.putBoolean(mUuid + "".notifySelfNewMail"", mNotifySelfNewMail);
        editor.putBoolean(mUuid + "".notifyMailCheck"", mNotifySync);
        editor.putInt(mUuid + "".deletePolicy"", mDeletePolicy);
        editor.putString(mUuid + "".inboxFolderName"", mInboxFolderName);
        editor.putString(mUuid + "".draftsFolderName"", mDraftsFolderName);
        editor.putString(mUuid + "".sentFolderName"", mSentFolderName);
        editor.putString(mUuid + "".trashFolderName"", mTrashFolderName);
        editor.putString(mUuid + "".archiveFolderName"", mArchiveFolderName);
        editor.putString(mUuid + "".spamFolderName"", mSpamFolderName);
        editor.putString(mUuid + "".autoExpandFolderName"", mAutoExpandFolderName);
        editor.putInt(mUuid + "".accountNumber"", mAccountNumber);
        editor.putString(mUuid + "".hideButtonsEnum"", mScrollMessageViewButtons.name());
        editor.putString(mUuid + "".hideMoveButtonsEnum"", mScrollMessageViewMoveButtons.name());
        editor.putString(mUuid + "".showPicturesEnum"", mShowPictures.name());
        editor.putBoolean(mUuid + "".enableMoveButtons"", mEnableMoveButtons);
        editor.putString(mUuid + "".folderDisplayMode"", mFolderDisplayMode.name());
        editor.putString(mUuid + "".folderSyncMode"", mFolderSyncMode.name());
        editor.putString(mUuid + "".folderPushMode"", mFolderPushMode.name());
        editor.putString(mUuid + "".folderTargetMode"", mFolderTargetMode.name());
        editor.putBoolean(mUuid + "".signatureBeforeQuotedText"", this.mIsSignatureBeforeQuotedText);
        editor.putString(mUuid + "".expungePolicy"", mExpungePolicy);
        editor.putBoolean(mUuid + "".syncRemoteDeletions"", mSyncRemoteDeletions);
        editor.putInt(mUuid + "".maxPushFolders"", mMaxPushFolders);
        editor.putString(mUuid + "".searchableFolders"", searchableFolders.name());
        editor.putInt(mUuid + "".chipColor"", mChipColor);
        editor.putBoolean(mUuid + "".goToUnreadMessageSearch"", goToUnreadMessageSearch);
        editor.putBoolean(mUuid + "".notificationUnreadCount"", mNotificationShowsUnreadCount);
        editor.putBoolean(mUuid + "".subscribedFoldersOnly"", subscribedFoldersOnly);
        editor.putInt(mUuid + "".maximumPolledMessageAge"", maximumPolledMessageAge);
        editor.putInt(mUuid + "".maximumAutoDownloadMessageSize"", maximumAutoDownloadMessageSize);
        editor.putString(mUuid + "".messageFormat"", mMessageFormat.name());
        editor.putString(mUuid + "".quoteStyle"", mQuoteStyle.name());
        editor.putString(mUuid + "".quotePrefix"", mQuotePrefix);
        editor.putBoolean(mUuid + "".defaultQuotedTextShown"", mDefaultQuotedTextShown);
        editor.putBoolean(mUuid + "".replyAfterQuote"", mReplyAfterQuote);
        editor.putString(mUuid + "".cryptoApp"", mCryptoApp);
        editor.putBoolean(mUuid + "".cryptoAutoSignature"", mCryptoAutoSignature);

        editor.putBoolean(mUuid + "".vibrate"", mNotificationSetting.shouldVibrate());
        editor.putInt(mUuid + "".vibratePattern"", mNotificationSetting.getVibratePattern());
        editor.putInt(mUuid + "".vibrateTimes"", mNotificationSetting.getVibrateTimes());
        editor.putBoolean(mUuid + "".ring"", mNotificationSetting.shouldRing());
        editor.putString(mUuid + "".ringtone"", mNotificationSetting.getRingtone());
        editor.putBoolean(mUuid + "".led"", mNotificationSetting.isLed());
        editor.putInt(mUuid + "".ledColor"", mNotificationSetting.getLedColor());

        for (String type : networkTypes) {
            Boolean useCompression = compressionMap.get(type);
            if (useCompression != null) {
                editor.putBoolean(mUuid + "".useCompression."" + type, useCompression);
            }
        }
        saveIdentities(preferences.getPreferences(), editor);

        editor.commit();

    }

    public void resetVisibleLimits() {
        try {
            getLocalStore().resetVisibleLimits(getDisplayCount());
        } catch (MessagingException e) {
            Log.e(K9.LOG_TAG, ""Unable to reset visible limits"", e);
        }

    }

    /**
     * @param context
     * @return <code>null</code> if not available
     * @throws MessagingException
     * @see {@link #isAvailable(Context)}
     */
    public AccountStats getStats(Context context) throws MessagingException {
        if (!isAvailable(context)) {
            return null;
        }
        long startTime = System.currentTimeMillis();
        AccountStats stats = new AccountStats();
        LocalStore localStore = getLocalStore();
        if (K9.measureAccounts()) {
            stats.size = localStore.getSize();
        }
        localStore.getMessageCounts(stats);
        long endTime = System.currentTimeMillis();
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""Account.getStats() on "" + getDescription() + "" took "" + (endTime - startTime) + "" ms;"");
        return stats;
    }


    public synchronized void setChipColor(int color) {
        mChipColor = color;
    }

    public synchronized int getChipColor() {
        return mChipColor;
    }


    public ColorChip generateColorChip() {
        return new ColorChip(mChipColor);
    }


    public String getUuid() {
        return mUuid;
    }

    public Uri getContentUri() {
        return Uri.parse(""content://accounts/"" + getUuid());
    }

    public synchronized String getStoreUri() {
        return mStoreUri;
    }

    public synchronized void setStoreUri(String storeUri) {
        this.mStoreUri = storeUri;
    }

    public synchronized String getTransportUri() {
        return mTransportUri;
    }

    public synchronized void setTransportUri(String transportUri) {
        this.mTransportUri = transportUri;
    }

    public synchronized String getDescription() {
        return mDescription;
    }

    public synchronized void setDescription(String description) {
        this.mDescription = description;
    }

    public synchronized String getName() {
        return identities.get(0).getName();
    }

    public synchronized void setName(String name) {
        identities.get(0).setName(name);
    }

    public synchronized boolean getSignatureUse() {
        return identities.get(0).getSignatureUse();
    }

    public synchronized void setSignatureUse(boolean signatureUse) {
        identities.get(0).setSignatureUse(signatureUse);
    }

    public synchronized String getSignature() {
        return identities.get(0).getSignature();
    }

    public synchronized void setSignature(String signature) {
        identities.get(0).setSignature(signature);
    }

    public synchronized String getEmail() {
        return identities.get(0).getEmail();
    }

    public synchronized void setEmail(String email) {
        identities.get(0).setEmail(email);
    }

    public synchronized String getAlwaysBcc() {
        return mAlwaysBcc;
    }

    public synchronized void setAlwaysBcc(String alwaysBcc) {
        this.mAlwaysBcc = alwaysBcc;
    }

    /* Have we sent a new mail notification on this account */
    public boolean isRingNotified() {
        return mRingNotified;
    }

    public void setRingNotified(boolean ringNotified) {
        mRingNotified = ringNotified;
    }

    public String getLocalStorageProviderId() {
        return mLocalStorageProviderId;
    }

    public void setLocalStorageProviderId(String id) {

        if (!mLocalStorageProviderId.equals(id)) {

            boolean successful = false;
            try {
                switchLocalStorage(id);
                successful = true;
            } catch (MessagingException e) {
                Log.e(K9.LOG_TAG, ""Switching local storage provider from "" +
                      mLocalStorageProviderId + "" to "" + id + "" failed."", e);
            } finally {
                // if migration to/from SD-card failed once, it will fail again.
                if (!successful) {
                    return;
                }
            }

            mLocalStorageProviderId = id;
        }

    }

//    public synchronized void setLocalStoreUri(String localStoreUri)
//    {
//        this.mLocalStoreUri = localStoreUri;
//    }

    /**
     * Returns -1 for never.
     */
    public synchronized int getAutomaticCheckIntervalMinutes() {
        return mAutomaticCheckIntervalMinutes;
    }

    /**
     * @param automaticCheckIntervalMinutes or -1 for never.
     */
    public synchronized boolean setAutomaticCheckIntervalMinutes(int automaticCheckIntervalMinutes) {
        int oldInterval = this.mAutomaticCheckIntervalMinutes;
        this.mAutomaticCheckIntervalMinutes = automaticCheckIntervalMinutes;

        return (oldInterval != automaticCheckIntervalMinutes);
    }

    public synchronized int getDisplayCount() {
        return mDisplayCount;
    }

    public synchronized void setDisplayCount(int displayCount) {
        if (displayCount != -1) {
            this.mDisplayCount = displayCount;
        } else {
            this.mDisplayCount = K9.DEFAULT_VISIBLE_LIMIT;
        }
        resetVisibleLimits();
    }

    public synchronized long getLastAutomaticCheckTime() {
        return mLastAutomaticCheckTime;
    }

    public synchronized void setLastAutomaticCheckTime(long lastAutomaticCheckTime) {
        this.mLastAutomaticCheckTime = lastAutomaticCheckTime;
    }

    public synchronized long getLatestOldMessageSeenTime() {
        return mLatestOldMessageSeenTime;
    }

    public synchronized void setLatestOldMessageSeenTime(long latestOldMessageSeenTime) {
        this.mLatestOldMessageSeenTime = latestOldMessageSeenTime;
    }

    public synchronized boolean isNotifyNewMail() {
        return mNotifyNewMail;
    }

    public synchronized void setNotifyNewMail(boolean notifyNewMail) {
        this.mNotifyNewMail = notifyNewMail;
    }

    public synchronized int getDeletePolicy() {
        return mDeletePolicy;
    }

    public synchronized void setDeletePolicy(int deletePolicy) {
        this.mDeletePolicy = deletePolicy;
    }


    public boolean isSpecialFolder(String folderName) {
        if (folderName != null && (folderName.equalsIgnoreCase(getInboxFolderName()) ||
                                   folderName.equals(getTrashFolderName()) ||
                                   folderName.equals(getDraftsFolderName()) ||
                                   folderName.equals(getArchiveFolderName()) ||
                                   folderName.equals(getSpamFolderName()) ||
                                   folderName.equals(getOutboxFolderName()) ||
                                   folderName.equals(getSentFolderName()) ||
                                   folderName.equals(getErrorFolderName()))) {
            return true;

        } else {
            return false;
        }

    }


    public synchronized String getDraftsFolderName() {
        return mDraftsFolderName;
    }

    public synchronized void setDraftsFolderName(String draftsFolderName) {
        mDraftsFolderName = draftsFolderName;
    }

    public synchronized String getSentFolderName() {
        return mSentFolderName;
    }

    public synchronized String getErrorFolderName() {
        return K9.ERROR_FOLDER_NAME;
    }

    public synchronized void setSentFolderName(String sentFolderName) {
        mSentFolderName = sentFolderName;
    }

    public synchronized String getTrashFolderName() {
        return mTrashFolderName;
    }

    public synchronized void setTrashFolderName(String trashFolderName) {
        mTrashFolderName = trashFolderName;
    }

    public synchronized String getArchiveFolderName() {
        return mArchiveFolderName;
    }

    public synchronized void setArchiveFolderName(String archiveFolderName) {
        mArchiveFolderName = archiveFolderName;
    }

    public synchronized String getSpamFolderName() {
        return mSpamFolderName;
    }

    public synchronized void setSpamFolderName(String spamFolderName) {
        mSpamFolderName = spamFolderName;
    }

    public synchronized String getOutboxFolderName() {
        return OUTBOX;
    }

    public synchronized String getAutoExpandFolderName() {
        return mAutoExpandFolderName;
    }

    public synchronized void setAutoExpandFolderName(String autoExpandFolderName) {
        mAutoExpandFolderName = autoExpandFolderName;
    }

    public synchronized int getAccountNumber() {
        return mAccountNumber;
    }

    public synchronized FolderMode getFolderDisplayMode() {
        return mFolderDisplayMode;
    }

    public synchronized boolean setFolderDisplayMode(FolderMode displayMode) {
        FolderMode oldDisplayMode = mFolderDisplayMode;
        mFolderDisplayMode = displayMode;
        return oldDisplayMode != displayMode;
    }

    public synchronized FolderMode getFolderSyncMode() {
        return mFolderSyncMode;
    }

    public synchronized boolean setFolderSyncMode(FolderMode syncMode) {
        FolderMode oldSyncMode = mFolderSyncMode;
        mFolderSyncMode = syncMode;

        if (syncMode == FolderMode.NONE && oldSyncMode != FolderMode.NONE) {
            return true;
        }
        if (syncMode != FolderMode.NONE && oldSyncMode == FolderMode.NONE) {
            return true;
        }
        return false;
    }

    public synchronized FolderMode getFolderPushMode() {
        return mFolderPushMode;
    }

    public synchronized boolean setFolderPushMode(FolderMode pushMode) {
        FolderMode oldPushMode = mFolderPushMode;

        mFolderPushMode = pushMode;
        return pushMode != oldPushMode;
    }

    public synchronized boolean isShowOngoing() {
        return mNotifySync;
    }

    public synchronized void setShowOngoing(boolean showOngoing) {
        this.mNotifySync = showOngoing;
    }

    public synchronized ScrollButtons getScrollMessageViewButtons() {
        return mScrollMessageViewButtons;
    }

    public synchronized void setScrollMessageViewButtons(ScrollButtons scrollMessageViewButtons) {
        mScrollMessageViewButtons = scrollMessageViewButtons;
    }

    public synchronized ScrollButtons getScrollMessageViewMoveButtons() {
        return mScrollMessageViewMoveButtons;
    }

    public synchronized void setScrollMessageViewMoveButtons(ScrollButtons scrollMessageViewButtons) {
        mScrollMessageViewMoveButtons = scrollMessageViewButtons;
    }

    public synchronized ShowPictures getShowPictures() {
        return mShowPictures;
    }

    public synchronized void setShowPictures(ShowPictures showPictures) {
        mShowPictures = showPictures;
    }

    public synchronized FolderMode getFolderTargetMode() {
        return mFolderTargetMode;
    }

    public synchronized void setFolderTargetMode(FolderMode folderTargetMode) {
        mFolderTargetMode = folderTargetMode;
    }

    public synchronized boolean isSignatureBeforeQuotedText() {
        return mIsSignatureBeforeQuotedText;
    }

    public synchronized void setSignatureBeforeQuotedText(boolean mIsSignatureBeforeQuotedText) {
        this.mIsSignatureBeforeQuotedText = mIsSignatureBeforeQuotedText;
    }

    public synchronized boolean isNotifySelfNewMail() {
        return mNotifySelfNewMail;
    }

    public synchronized void setNotifySelfNewMail(boolean notifySelfNewMail) {
        mNotifySelfNewMail = notifySelfNewMail;
    }

    public synchronized String getExpungePolicy() {
        return mExpungePolicy;
    }

    public synchronized void setExpungePolicy(String expungePolicy) {
        mExpungePolicy = expungePolicy;
    }

    public synchronized int getMaxPushFolders() {
        return mMaxPushFolders;
    }

    public synchronized boolean setMaxPushFolders(int maxPushFolders) {
        int oldMaxPushFolders = mMaxPushFolders;
        mMaxPushFolders = maxPushFolders;
        return oldMaxPushFolders != maxPushFolders;
    }

    public LocalStore getLocalStore() throws MessagingException {
        return Store.getLocalInstance(this, K9.app);
    }

    public Store getRemoteStore() throws MessagingException {
        return Store.getRemoteInstance(this);
    }

    @Override
    public synchronized String toString() {
        return mDescription;
    }

    public synchronized void setCompression(String networkType, boolean useCompression) {
        compressionMap.put(networkType, useCompression);
    }

    public synchronized boolean useCompression(String networkType) {
        Boolean useCompression = compressionMap.get(networkType);
        if (useCompression == null) {
            return true;
        } else {
            return useCompression;
        }
    }

    public boolean useCompression(int type) {
        String networkType = TYPE_OTHER;
        switch (type) {
        case ConnectivityManager.TYPE_MOBILE:
            networkType = TYPE_MOBILE;
            break;
        case ConnectivityManager.TYPE_WIFI:
            networkType = TYPE_WIFI;
            break;
        }
        return useCompression(networkType);
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof Account) {
            return ((Account)o).mUuid.equals(mUuid);
        }
        return super.equals(o);
    }

    @Override
    public int hashCode() {
        return mUuid.hashCode();
    }


    private synchronized List<Identity> loadIdentities(SharedPreferences prefs) {
        List<Identity> newIdentities = new ArrayList<Identity>();
        int ident = 0;
        boolean gotOne = false;
        do {
            gotOne = false;
            String name = prefs.getString(mUuid + "".name."" + ident, null);
            String email = prefs.getString(mUuid + "".email."" + ident, null);
            boolean signatureUse = prefs.getBoolean(mUuid  + "".signatureUse."" + ident, true);
            String signature = prefs.getString(mUuid + "".signature."" + ident, null);
            String description = prefs.getString(mUuid + "".description."" + ident, null);
            final String replyTo = prefs.getString(mUuid + "".replyTo."" + ident, null);
            if (email != null) {
                Identity identity = new Identity();
                identity.setName(name);
                identity.setEmail(email);
                identity.setSignatureUse(signatureUse);
                identity.setSignature(signature);
                identity.setDescription(description);
                identity.setReplyTo(replyTo);
                newIdentities.add(identity);
                gotOne = true;
            }
            ident++;
        } while (gotOne);

        if (newIdentities.size() == 0) {
            String name = prefs.getString(mUuid + "".name"", null);
            String email = prefs.getString(mUuid + "".email"", null);
            boolean signatureUse = prefs.getBoolean(mUuid  + "".signatureUse"", true);
            String signature = prefs.getString(mUuid + "".signature"", null);
            Identity identity = new Identity();
            identity.setName(name);
            identity.setEmail(email);
            identity.setSignatureUse(signatureUse);
            identity.setSignature(signature);
            identity.setDescription(email);
            newIdentities.add(identity);
        }

        return newIdentities;
    }

    private synchronized void deleteIdentities(SharedPreferences prefs, SharedPreferences.Editor editor) {
        int ident = 0;
        boolean gotOne = false;
        do {
            gotOne = false;
            String email = prefs.getString(mUuid + "".email."" + ident, null);
            if (email != null) {
                editor.remove(mUuid + "".name."" + ident);
                editor.remove(mUuid + "".email."" + ident);
                editor.remove(mUuid + "".signatureUse."" + ident);
                editor.remove(mUuid + "".signature."" + ident);
                editor.remove(mUuid + "".description."" + ident);
                editor.remove(mUuid + "".replyTo."" + ident);
                gotOne = true;
            }
            ident++;
        } while (gotOne);
    }

    private synchronized void saveIdentities(SharedPreferences prefs, SharedPreferences.Editor editor) {
        deleteIdentities(prefs, editor);
        int ident = 0;

        for (Identity identity : identities) {
            editor.putString(mUuid + "".name."" + ident, identity.getName());
            editor.putString(mUuid + "".email."" + ident, identity.getEmail());
            editor.putBoolean(mUuid + "".signatureUse."" + ident, identity.getSignatureUse());
            editor.putString(mUuid + "".signature."" + ident, identity.getSignature());
            editor.putString(mUuid + "".description."" + ident, identity.getDescription());
            editor.putString(mUuid + "".replyTo."" + ident, identity.getReplyTo());
            ident++;
        }
    }

    public synchronized List<Identity> getIdentities() {
        return identities;
    }

    public synchronized void setIdentities(List<Identity> newIdentities) {
        identities = new ArrayList<Identity>(newIdentities);
    }

    public synchronized Identity getIdentity(int i) {
        if (i < identities.size()) {
            return identities.get(i);
        }
        return null;
    }

    public boolean isAnIdentity(Address[] addrs) {
        if (addrs == null) {
            return false;
        }
        for (Address addr : addrs) {
            if (findIdentity(addr) != null) {
                return true;
            }
        }

        return false;
    }

    public boolean isAnIdentity(Address addr) {
        return findIdentity(addr) != null;
    }

    public synchronized Identity findIdentity(Address addr) {
        for (Identity identity : identities) {
            String email = identity.getEmail();
            if (email != null && email.equalsIgnoreCase(addr.getAddress())) {
                return identity;
            }
        }
        return null;
    }

    public synchronized Searchable getSearchableFolders() {
        return searchableFolders;
    }

    public synchronized void setSearchableFolders(Searchable searchableFolders) {
        this.searchableFolders = searchableFolders;
    }

    public synchronized int getIdleRefreshMinutes() {
        return mIdleRefreshMinutes;
    }

    public synchronized void setIdleRefreshMinutes(int idleRefreshMinutes) {
        mIdleRefreshMinutes = idleRefreshMinutes;
    }

    public synchronized boolean isPushPollOnConnect() {
        return mPushPollOnConnect;
    }

    public synchronized void setPushPollOnConnect(boolean pushPollOnConnect) {
        mPushPollOnConnect = pushPollOnConnect;
    }

    public synchronized boolean saveAllHeaders() {
        return mSaveAllHeaders;
    }

    public synchronized void setSaveAllHeaders(boolean saveAllHeaders) {
        mSaveAllHeaders = saveAllHeaders;
    }

    /**
     * Are we storing out localStore on the SD-card instead of the local device
     * memory?<br/>
     * Only to be called durin initial account-setup!<br/>
     * Side-effect: changes {@link #mLocalStorageProviderId}.
     *
     * @param context
     * @param newStorageProviderId
     *            Never <code>null</code>.
     * @throws MessagingException
     */
    public void switchLocalStorage(final String newStorageProviderId) throws MessagingException {
        if (!mLocalStorageProviderId.equals(newStorageProviderId)) {
            getLocalStore().switchLocalStorage(newStorageProviderId);
        }
    }

    public synchronized boolean goToUnreadMessageSearch() {
        return goToUnreadMessageSearch;
    }

    public synchronized void setGoToUnreadMessageSearch(boolean goToUnreadMessageSearch) {
        this.goToUnreadMessageSearch = goToUnreadMessageSearch;
    }

    public boolean isNotificationShowsUnreadCount() {
        return mNotificationShowsUnreadCount;
    }

    public void setNotificationShowsUnreadCount(boolean notificationShowsUnreadCount) {
        this.mNotificationShowsUnreadCount = notificationShowsUnreadCount;
    }

    public synchronized boolean subscribedFoldersOnly() {
        return subscribedFoldersOnly;
    }

    public synchronized void setSubscribedFoldersOnly(boolean subscribedFoldersOnly) {
        this.subscribedFoldersOnly = subscribedFoldersOnly;
    }

    public synchronized int getMaximumPolledMessageAge() {
        return maximumPolledMessageAge;
    }

    public synchronized void setMaximumPolledMessageAge(int maximumPolledMessageAge) {
        this.maximumPolledMessageAge = maximumPolledMessageAge;
    }

    public synchronized int getMaximumAutoDownloadMessageSize() {
        return maximumAutoDownloadMessageSize;
    }

    public synchronized void setMaximumAutoDownloadMessageSize(int maximumAutoDownloadMessageSize) {
        this.maximumAutoDownloadMessageSize = maximumAutoDownloadMessageSize;
    }

    public Date getEarliestPollDate() {
        int age = getMaximumPolledMessageAge();
        if (age >= 0) {
            Calendar now = Calendar.getInstance();
            now.set(Calendar.HOUR_OF_DAY, 0);
            now.set(Calendar.MINUTE, 0);
            now.set(Calendar.SECOND, 0);
            now.set(Calendar.MILLISECOND, 0);
            if (age < 28) {
                now.add(Calendar.DATE, age * -1);
            } else switch (age) {
                case 28:
                    now.add(Calendar.MONTH, -1);
                    break;
                case 56:
                    now.add(Calendar.MONTH, -2);
                    break;
                case 84:
                    now.add(Calendar.MONTH, -3);
                    break;
                case 168:
                    now.add(Calendar.MONTH, -6);
                    break;
                case 365:
                    now.add(Calendar.YEAR, -1);
                    break;
                }

            return now.getTime();
        } else {
            return null;
        }
    }

    public MessageFormat getMessageFormat() {
        return mMessageFormat;
    }

    public void setMessageFormat(MessageFormat messageFormat) {
        this.mMessageFormat = messageFormat;
    }

    public QuoteStyle getQuoteStyle() {
        return mQuoteStyle;
    }

    public void setQuoteStyle(QuoteStyle quoteStyle) {
        this.mQuoteStyle = quoteStyle;
    }

    public synchronized String getQuotePrefix() {
        return mQuotePrefix;
    }

    public synchronized void setQuotePrefix(String quotePrefix) {
        mQuotePrefix = quotePrefix;
    }

    public synchronized boolean isDefaultQuotedTextShown() {
        return mDefaultQuotedTextShown;
    }

    public synchronized void setDefaultQuotedTextShown(boolean shown) {
        mDefaultQuotedTextShown = shown;
    }

    public synchronized boolean isReplyAfterQuote() {
        return mReplyAfterQuote;
    }

    public synchronized void setReplyAfterQuote(boolean replyAfterQuote) {
        mReplyAfterQuote = replyAfterQuote;
    }

    public boolean getEnableMoveButtons() {
        return mEnableMoveButtons;
    }

    public void setEnableMoveButtons(boolean enableMoveButtons) {
        mEnableMoveButtons = enableMoveButtons;
    }

    public String getCryptoApp() {
        return mCryptoApp;
    }

    public void setCryptoApp(String cryptoApp) {
        mCryptoApp = cryptoApp;
        // invalidate the provider
        mCryptoProvider = null;
    }

    public boolean getCryptoAutoSignature() {
        return mCryptoAutoSignature;
    }

    public void setCryptoAutoSignature(boolean cryptoAutoSignature) {
        mCryptoAutoSignature = cryptoAutoSignature;
    }

    public String getInboxFolderName() {
        return mInboxFolderName;
    }

    public void setInboxFolderName(String mInboxFolderName) {
        this.mInboxFolderName = mInboxFolderName;
    }

    public synchronized boolean syncRemoteDeletions() {
        return mSyncRemoteDeletions;
    }

    public synchronized void setSyncRemoteDeletions(boolean syncRemoteDeletions) {
        mSyncRemoteDeletions = syncRemoteDeletions;
    }

    public synchronized String getLastSelectedFolderName() {
        return lastSelectedFolderName;
    }

    public synchronized void setLastSelectedFolderName(String folderName) {
        lastSelectedFolderName = folderName;
    }

    public synchronized CryptoProvider getCryptoProvider() {
        if (mCryptoProvider == null) {
            mCryptoProvider = CryptoProvider.createInstance(getCryptoApp());
        }
        return mCryptoProvider;
    }

    public synchronized NotificationSetting getNotificationSetting() {
        return mNotificationSetting;
    }

    /**
     * @return <code>true</code> if our {@link StorageProvider} is ready. (e.g.
     *         card inserted)
     */
    public boolean isAvailable(Context context) {
        String localStorageProviderId = getLocalStorageProviderId();
        if (localStorageProviderId == null) {
            return true; // defaults to internal memory
        }
        return StorageManager.getInstance(K9.app).isReady(localStorageProviderId);
    }

}
",True,148,1,4,6,42,48,15,L1
2,com.fsck.k9.SearchSpecification.java,"
package com.fsck.k9;

import com.fsck.k9.mail.Flag;

public interface SearchSpecification {

    public Flag[] getRequiredFlags();

    public Flag[] getForbiddenFlags();

    public boolean isIntegrate();

    public String getQuery();

    public String[] getAccountUuids();

    public String[] getFolderNames();
}",False,114,5,61,1,1,5,1,L1
3,com.fsck.k9.FontSizes.java,"package com.fsck.k9;

import android.content.SharedPreferences;
import android.webkit.WebSettings.TextSize;

/**
 * Manage font size of the information displayed in the account list, folder
 * list, message list and in the message view.
 */
public class FontSizes {
    /*
     * Keys for the preference storage.
     */
    private static final String ACCOUNT_NAME = ""fontSizeAccountName"";
    private static final String ACCOUNT_DESCRIPTION = ""fontSizeAccountDescription"";
    private static final String FOLDER_NAME = ""fontSizeFolderName"";
    private static final String FOLDER_STATUS = ""fontSizeFolderStatus"";
    private static final String MESSAGE_LIST_SUBJECT = ""fontSizeMessageListSubject"";
    private static final String MESSAGE_LIST_SENDER = ""fontSizeMessageListSender"";
    private static final String MESSAGE_LIST_DATE = ""fontSizeMessageListDate"";
    private static final String MESSAGE_LIST_PREVIEW = ""fontSizeMessageListPreview"";
    private static final String MESSAGE_VIEW_SENDER = ""fontSizeMessageViewSender"";
    private static final String MESSAGE_VIEW_TO = ""fontSizeMessageViewTo"";
    private static final String MESSAGE_VIEW_CC = ""fontSizeMessageViewCC"";
    private static final String MESSAGE_VIEW_ADDITIONAL_HEADERS = ""fontSizeMessageViewAdditionalHeaders"";
    private static final String MESSAGE_VIEW_SUBJECT = ""fontSizeMessageViewSubject"";
    private static final String MESSAGE_VIEW_TIME = ""fontSizeMessageViewTime"";
    private static final String MESSAGE_VIEW_DATE = ""fontSizeMessageViewDate"";
    private static final String MESSAGE_VIEW_CONTENT = ""fontSizeMessageViewContent"";

    /*
     * Values for the font sizes in DIP (device independent pixel)
     */
    public static final int FONT_10DIP = 10;
    public static final int FONT_12DIP = 12;
    public static final int SMALL = 14;         // ?android:attr/textAppearanceSmall
    public static final int FONT_16DIP = 16;
    public static final int MEDIUM = 18;        // ?android:attr/textAppearanceMedium
    public static final int FONT_20DIP = 20;
    public static final int LARGE = 22;         // ?android:attr/textAppearanceLarge


    /**
     * Font size of account names in the account list activity.
     */
    private int accountName;

    /**
     * Font size of account descriptions in the account list activity.
     */
    private int accountDescription;

    /**
     * Font size of folder names in the folder list activity.
     */
    private int folderName;

    /**
     * Font size of the folder status in the folder list activity.
     */
    private int folderStatus;

    /**
     * Font size of message subjects in the message list activity.
     */
    private int messageListSubject;

    /**
     * Font size of message senders in the message list activity.
     */
    private int messageListSender;

    /**
     * Font size of message dates in the message list activity.
     */
    private int messageListDate;

    /**
     * Font size of message preview in the message list activity.
     */
    private int messageListPreview;

    /**
     * Font size of the message sender in the message view activity.
     */
    private int messageViewSender;

    /**
     * Font size of the message receiver(s) (To) in the message view activity.
     */
    private int messageViewTo;

    /**
     * Font size of the message receiver(s) (CC) in the message view activity.
     */
    private int messageViewCC;

    /**
     * Font size of additional headers in the message view activity.
     */
    private int messageViewAdditionalHeaders;

    /**
     * Font size of the message subject in the message view activity.
     */
    private int messageViewSubject;

    /**
     * Font size of the message time in the message view activity.
     */
    private int messageViewTime;

    /**
     * Font size of the message date in the message view activity.
     */
    private int messageViewDate;

    /**
     * Font size of the message content in the message view activity.
     *
     * Note: The unit is WebSettings.TextSize
     */
    private TextSize messageViewContent = TextSize.NORMAL;

    /**
     * Create a <code>FontSizes</code> object with default values.
     */
    public FontSizes() {
        accountName = MEDIUM;
        accountDescription = SMALL;

        folderName = LARGE;
        folderStatus = SMALL;

        messageListSubject = FONT_16DIP;
        messageListSender = SMALL;
        messageListDate = SMALL;
        messageListPreview = SMALL;

        messageViewSender = SMALL;
        messageViewTo = FONT_12DIP;
        messageViewCC = FONT_12DIP;
        messageViewAdditionalHeaders = FONT_12DIP;
        messageViewSubject = FONT_12DIP;
        messageViewTime = FONT_10DIP;
        messageViewDate = FONT_10DIP;
    }

    /**
     * Permanently save the font size settings.
     *
     * @param editor Used to save the font size settings.
     */
    public void save(SharedPreferences.Editor editor) {
        editor.putInt(ACCOUNT_NAME, accountName);
        editor.putInt(ACCOUNT_DESCRIPTION, accountDescription);

        editor.putInt(FOLDER_NAME, folderName);
        editor.putInt(FOLDER_STATUS, folderStatus);

        editor.putInt(MESSAGE_LIST_SUBJECT, messageListSubject);
        editor.putInt(MESSAGE_LIST_SENDER, messageListSender);
        editor.putInt(MESSAGE_LIST_DATE, messageListDate);
        editor.putInt(MESSAGE_LIST_PREVIEW, messageListPreview);

        editor.putInt(MESSAGE_VIEW_SENDER, messageViewSender);
        editor.putInt(MESSAGE_VIEW_TO, messageViewTo);
        editor.putInt(MESSAGE_VIEW_CC, messageViewCC);
        editor.putInt(MESSAGE_VIEW_ADDITIONAL_HEADERS, messageViewAdditionalHeaders);
        editor.putInt(MESSAGE_VIEW_SUBJECT, messageViewSubject);
        editor.putInt(MESSAGE_VIEW_TIME, messageViewTime);
        editor.putInt(MESSAGE_VIEW_DATE, messageViewDate);
        editor.putInt(MESSAGE_VIEW_CONTENT, getMessageViewContentAsInt());
    }

    /**
     * Load the font size settings from permanent storage.
     *
     * @param prefs Used to load the font size settings.
     */
    public void load(SharedPreferences prefs) {
        accountName = prefs.getInt(ACCOUNT_NAME, accountName);
        accountDescription = prefs.getInt(ACCOUNT_DESCRIPTION, accountDescription);

        folderName = prefs.getInt(FOLDER_NAME, folderName);
        folderStatus = prefs.getInt(FOLDER_STATUS, folderStatus);

        messageListSubject = prefs.getInt(MESSAGE_LIST_SUBJECT, messageListSubject);
        messageListSender = prefs.getInt(MESSAGE_LIST_SENDER, messageListSender);
        messageListDate = prefs.getInt(MESSAGE_LIST_DATE, messageListDate);
        messageListPreview = prefs.getInt(MESSAGE_LIST_PREVIEW, messageListPreview);

        messageViewSender = prefs.getInt(MESSAGE_VIEW_SENDER, messageViewSender);
        messageViewTo = prefs.getInt(MESSAGE_VIEW_TO, messageViewTo);
        messageViewCC = prefs.getInt(MESSAGE_VIEW_CC, messageViewCC);
        messageViewAdditionalHeaders = prefs.getInt(MESSAGE_VIEW_ADDITIONAL_HEADERS, messageViewAdditionalHeaders);
        messageViewSubject = prefs.getInt(MESSAGE_VIEW_SUBJECT, messageViewSubject);
        messageViewTime = prefs.getInt(MESSAGE_VIEW_TIME, messageViewTime);
        messageViewDate = prefs.getInt(MESSAGE_VIEW_DATE, messageViewDate);
        setMessageViewContent(prefs.getInt(MESSAGE_VIEW_CONTENT, 3));
    }

    public int getAccountName() {
        return accountName;
    }

    public void setAccountName(int accountName) {
        this.accountName = accountName;
    }

    public int getAccountDescription() {
        return accountDescription;
    }

    public void setAccountDescription(int accountDescription) {
        this.accountDescription = accountDescription;
    }

    public int getFolderName() {
        return folderName;
    }

    public void setFolderName(int folderName) {
        this.folderName = folderName;
    }

    public int getFolderStatus() {
        return folderStatus;
    }

    public void setFolderStatus(int folderStatus) {
        this.folderStatus = folderStatus;
    }

    public int getMessageListSubject() {
        return messageListSubject;
    }

    public void setMessageListSubject(int messageListSubject) {
        this.messageListSubject = messageListSubject;
    }

    public int getMessageListSender() {
        return messageListSender;
    }

    public void setMessageListSender(int messageListSender) {
        this.messageListSender = messageListSender;
    }

    public int getMessageListDate() {
        return messageListDate;
    }

    public void setMessageListDate(int messageListDate) {
        this.messageListDate = messageListDate;
    }

    public int getMessageListPreview() {
        return messageListPreview;
    }

    public void setMessageListPreview(int messageListPreview) {
        this.messageListPreview = messageListPreview;
    }

    public int getMessageViewSender() {
        return messageViewSender;
    }

    public void setMessageViewSender(int messageViewSender) {
        this.messageViewSender = messageViewSender;
    }

    public int getMessageViewTo() {
        return messageViewTo;
    }

    public void setMessageViewTo(int messageViewTo) {
        this.messageViewTo = messageViewTo;
    }

    public int getMessageViewCC() {
        return messageViewCC;
    }

    public void setMessageViewCC(int messageViewCC) {
        this.messageViewCC = messageViewCC;
    }

    public int getMessageViewAdditionalHeaders() {
        return messageViewAdditionalHeaders;
    }

    public void setMessageViewAdditionalHeaders(int messageViewAdditionalHeaders) {
        this.messageViewAdditionalHeaders = messageViewAdditionalHeaders;
    }

    public int getMessageViewSubject() {
        return messageViewSubject;
    }

    public void setMessageViewSubject(int messageViewSubject) {
        this.messageViewSubject = messageViewSubject;
    }

    public int getMessageViewTime() {
        return messageViewTime;
    }

    public void setMessageViewTime(int messageViewTime) {
        this.messageViewTime = messageViewTime;
    }

    public int getMessageViewDate() {
        return messageViewDate;
    }

    public void setMessageViewDate(int messageViewDate) {
        this.messageViewDate = messageViewDate;
    }

    public TextSize getMessageViewContent() {
        return messageViewContent;
    }

    public int getMessageViewContentAsInt() {
        switch (messageViewContent) {
        case SMALLEST:
            return 1;
        case SMALLER:
            return 2;
        default:
        case NORMAL:
            return 3;
        case LARGER:
            return 4;
        case LARGEST:
            return 5;
        }
    }

    public void setMessageViewContent(int size) {
        switch (size) {
        case 1:
            messageViewContent = TextSize.SMALLEST;
            break;
        case 2:
            messageViewContent = TextSize.SMALLER;
            break;
        case 3:
            messageViewContent = TextSize.NORMAL;
            break;
        case 4:
            messageViewContent = TextSize.LARGER;
            break;
        case 5:
            messageViewContent = TextSize.LARGEST;
            break;
        }
    }
}
",False,113,4,70,0,0,9,0,L1
4,com.fsck.k9.EmailAddressAdapter.java,"/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9;

import com.fsck.k9.helper.Contacts;
import com.fsck.k9.mail.Address;
import android.content.Context;
import android.database.Cursor;
import android.view.View;
import android.widget.ResourceCursorAdapter;
import android.widget.TextView;

public class EmailAddressAdapter extends ResourceCursorAdapter {
    private static EmailAddressAdapter sInstance;

    public static EmailAddressAdapter getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new EmailAddressAdapter(context);
        }

        return sInstance;
    }


    private final Contacts mContacts;

    private EmailAddressAdapter(Context context) {
        super(context, R.layout.recipient_dropdown_item, null);
        mContacts = Contacts.getInstance(context);
    }

    @Override
    public final String convertToString(final Cursor cursor) {
        final String name = mContacts.getName(cursor);
        final String address = mContacts.getEmail(cursor);

        return new Address(address, name).toString();
    }

    @Override
    public final void bindView(final View view, final Context context, final Cursor cursor) {
        final TextView text1 = (TextView) view.findViewById(R.id.text1);
        final TextView text2 = (TextView) view.findViewById(R.id.text2);
        text1.setText(mContacts.getName(cursor));
        text2.setText(mContacts.getEmail(cursor));
    }

    @Override
    public Cursor runQueryOnBackgroundThread(CharSequence constraint) {
        return mContacts.searchContacts(constraint);
    }
}
",False,144,0,0,8,52,1,2,L1
5,com.fsck.k9.K9.java,"
package com.fsck.k9;

import java.io.File;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;

import android.app.Application;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.net.Uri;
import android.os.Environment;
import android.os.Handler;
import android.os.Looper;
import android.text.format.Time;
import android.text.style.AbsoluteSizeSpan;
import android.util.Log;

import com.fsck.k9.activity.MessageCompose;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.internet.BinaryTempFileBody;
import com.fsck.k9.service.BootReceiver;
import com.fsck.k9.service.MailService;
import com.fsck.k9.service.ShutdownReceiver;
import com.fsck.k9.service.StorageGoneReceiver;

public class K9 extends Application {
    /**
     * Components that are interested in knowing when the K9 instance is
     * available and ready (Android invokes Application.onCreate() after other
     * components') should implement this interface and register using
     * {@link K9#registerApplicationAware(ApplicationAware)}.
     */
    public static interface ApplicationAware {
        /**
         * Called when the Application instance is available and ready.
         *
         * @param application
         *            The application instance. Never <code>null</code>.
         * @throws Exception
         */
        void initializeComponent(K9 application);
    }

    public static Application app = null;
    public static File tempDirectory;
    public static final String LOG_TAG = ""k9"";

    /**
     * Components that are interested in knowing when the K9 instance is
     * available and ready.
     *
     * @see ApplicationAware
     */
    private static List<ApplicationAware> observers = new ArrayList<ApplicationAware>();

    /**
     * @see K9#createAbsoluteSizeSpan(int)
     */
    private static Constructor<AbsoluteSizeSpan> sAbsoluteSizeSpanConstructor;

    public enum BACKGROUND_OPS {
        WHEN_CHECKED, ALWAYS, NEVER, WHEN_CHECKED_AUTO_SYNC
    }

    private static String language = """";
    private static int theme = android.R.style.Theme_Light;

    private static final FontSizes fontSizes = new FontSizes();

    private static BACKGROUND_OPS backgroundOps = BACKGROUND_OPS.WHEN_CHECKED;
    /**
     * Some log messages can be sent to a file, so that the logs
     * can be read using unprivileged access (eg. Terminal Emulator)
     * on the phone, without adb.  Set to null to disable
     */
    public static final String logFile = null;
    //public static final String logFile = Environment.getExternalStorageDirectory() + ""/k9mail/debug.log"";

    /**
     * If this is enabled, various development settings will be enabled
     * It should NEVER be on for Market builds
     * Right now, it just governs strictmode
     **/
    public static boolean DEVELOPER_MODE = true;


    /**
     * If this is enabled there will be additional logging information sent to
     * Log.d, including protocol dumps.
     * Controlled by Preferences at run-time
     */
    public static boolean DEBUG = false;

    /**
     * Should K-9 log the conversation it has over the wire with
     * SMTP servers?
     */

    public static boolean DEBUG_PROTOCOL_SMTP = true;

    /**
     * Should K-9 log the conversation it has over the wire with
     * IMAP servers?
     */

    public static boolean DEBUG_PROTOCOL_IMAP = true;


    /**
     * Should K-9 log the conversation it has over the wire with
     * POP3 servers?
     */

    public static boolean DEBUG_PROTOCOL_POP3 = true;

    /**
     * Should K-9 log the conversation it has over the wire with
     * WebDAV servers?
     */

    public static boolean DEBUG_PROTOCOL_WEBDAV = true;



    /**
     * If this is enabled than logging that normally hides sensitive information
     * like passwords will show that information.
     */
    public static boolean DEBUG_SENSITIVE = false;

    /**
     * Can create messages containing stack traces that can be forwarded
     * to the development team.
     */
    public static boolean ENABLE_ERROR_FOLDER = true;
    public static String ERROR_FOLDER_NAME = ""K9mail-errors"";

    private static boolean mAnimations = true;

    private static boolean mConfirmDelete = false;
    private static boolean mConfirmSpam = false;
    private static boolean mConfirmMarkAllAsRead = true;
    private static boolean mKeyguardPrivacy = false;

    private static boolean mMessageListStars = true;
    private static boolean mMessageListCheckboxes = false;
    private static boolean mMessageListTouchable = false;
    private static int mMessageListPreviewLines = 2;

    private static boolean mShowCorrespondentNames = true;
    private static boolean mShowContactName = false;
    private static boolean mChangeContactNameColor = false;
    private static int mContactNameColor = 0xff00008f;
    private static boolean mMessageViewFixedWidthFont = false;
    private static boolean mMessageViewReturnToList = false;

    private static boolean mGesturesEnabled = true;
    private static boolean mUseVolumeKeysForNavigation = false;
    private static boolean mUseVolumeKeysForListNavigation = false;
    private static boolean mManageBack = false;
    private static boolean mStartIntegratedInbox = false;
    private static boolean mMeasureAccounts = true;
    private static boolean mCountSearchMessages = true;
    private static boolean mHideSpecialAccounts = false;
    private static boolean mZoomControlsEnabled = false;
    private static boolean mMobileOptimizedLayout = false;
    private static boolean mQuietTimeEnabled = false;
    private static String mQuietTimeStarts = null;
    private static String mQuietTimeEnds = null;
    private static boolean compactLayouts = false;
    private static String mAttachmentDefaultPath = """";


    private static boolean useGalleryBugWorkaround = false;
    private static boolean galleryBuggy;


    /**
     * The MIME type(s) of attachments we're willing to view.
     */
    public static final String[] ACCEPTABLE_ATTACHMENT_VIEW_TYPES = new String[] {
        ""*/*"",
    };

    /**
     * The MIME type(s) of attachments we're not willing to view.
     */
    public static final String[] UNACCEPTABLE_ATTACHMENT_VIEW_TYPES = new String[] {
    };

    /**
     * The MIME type(s) of attachments we're willing to download to SD.
     */
    public static final String[] ACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES = new String[] {
        ""*/*"",
    };

    /**
     * The MIME type(s) of attachments we're not willing to download to SD.
     */
    public static final String[] UNACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES = new String[] {
    };

    /**
     * For use when displaying that no folder is selected
     */
    public static final String FOLDER_NONE = ""-NONE-"";

    public static final String LOCAL_UID_PREFIX = ""K9LOCAL:"";

    public static final String REMOTE_UID_PREFIX = ""K9REMOTE:"";

    public static final String IDENTITY_HEADER = ""X-K9mail-Identity"";

    /**
     * Specifies how many messages will be shown in a folder by default. This number is set
     * on each new folder and can be incremented with ""Load more messages..."" by the
     * VISIBLE_LIMIT_INCREMENT
     */
    public static int DEFAULT_VISIBLE_LIMIT = 25;

    /**
     * The maximum size of an attachment we're willing to download (either View or Save)
     * Attachments that are base64 encoded (most) will be about 1.375x their actual size
     * so we should probably factor that in. A 5MB attachment will generally be around
     * 6.8MB downloaded but only 5MB saved.
     */
    public static final int MAX_ATTACHMENT_DOWNLOAD_SIZE = (128 * 1024 * 1024);


    /* How many times should K-9 try to deliver a message before giving up
     * until the app is killed and restarted
     */

    public static int MAX_SEND_ATTEMPTS = 5;

    /**
     * Max time (in millis) the wake lock will be held for when background sync is happening
     */
    public static final int WAKE_LOCK_TIMEOUT = 600000;

    public static final int MANUAL_WAKE_LOCK_TIMEOUT = 120000;

    public static final int PUSH_WAKE_LOCK_TIMEOUT = 60000;

    public static final int MAIL_SERVICE_WAKE_LOCK_TIMEOUT = 30000;

    public static final int BOOT_RECEIVER_WAKE_LOCK_TIMEOUT = 60000;

    /**
     * Time the LED is on/off when blinking on new email notification
     */
    public static final int NOTIFICATION_LED_ON_TIME = 500;
    public static final int NOTIFICATION_LED_OFF_TIME = 2000;

    public static final boolean NOTIFICATION_LED_WHILE_SYNCING = false;
    public static final int NOTIFICATION_LED_FAST_ON_TIME = 100;
    public static final int NOTIFICATION_LED_FAST_OFF_TIME = 100;


    public static final int NOTIFICATION_LED_BLINK_SLOW = 0;
    public static final int NOTIFICATION_LED_BLINK_FAST = 1;



    public static final int NOTIFICATION_LED_SENDING_FAILURE_COLOR = 0xffff0000;

    // Must not conflict with an account number
    public static final int FETCHING_EMAIL_NOTIFICATION      = -5000;
    public static final int SEND_FAILED_NOTIFICATION      = -1500;
    public static final int CONNECTIVITY_ID = -3;


    public static class Intents {

        public static class EmailReceived {
            public static final String ACTION_EMAIL_RECEIVED    = ""com.fsck.k9.intent.action.EMAIL_RECEIVED"";
            public static final String ACTION_EMAIL_DELETED     = ""com.fsck.k9.intent.action.EMAIL_DELETED"";
            public static final String ACTION_REFRESH_OBSERVER  = ""com.fsck.k9.intent.action.REFRESH_OBSERVER"";
            public static final String EXTRA_ACCOUNT            = ""com.fsck.k9.intent.extra.ACCOUNT"";
            public static final String EXTRA_FOLDER             = ""com.fsck.k9.intent.extra.FOLDER"";
            public static final String EXTRA_SENT_DATE          = ""com.fsck.k9.intent.extra.SENT_DATE"";
            public static final String EXTRA_FROM               = ""com.fsck.k9.intent.extra.FROM"";
            public static final String EXTRA_TO                 = ""com.fsck.k9.intent.extra.TO"";
            public static final String EXTRA_CC                 = ""com.fsck.k9.intent.extra.CC"";
            public static final String EXTRA_BCC                = ""com.fsck.k9.intent.extra.BCC"";
            public static final String EXTRA_SUBJECT            = ""com.fsck.k9.intent.extra.SUBJECT"";
            public static final String EXTRA_FROM_SELF          = ""com.fsck.k9.intent.extra.FROM_SELF"";
        }

        public static class Share {
            /*
             * We don't want to use EmailReceived.EXTRA_FROM (""com.fsck.k9.intent.extra.FROM"")
             * because of different semantics (String array vs. string with comma separated
             * email addresses)
             */
            public static final String EXTRA_FROM               = ""com.fsck.k9.intent.extra.SENDER"";
        }
    }

    /**
     * Called throughout the application when the number of accounts has changed. This method
     * enables or disables the Compose activity, the boot receiver and the service based on
     * whether any accounts are configured.
     */
    public static void setServicesEnabled(Context context) {
        int acctLength = Preferences.getPreferences(context).getAvailableAccounts().size();

        setServicesEnabled(context, acctLength > 0, null);

    }

    private static void setServicesEnabled(Context context, boolean enabled, Integer wakeLockId) {

        PackageManager pm = context.getPackageManager();

        if (!enabled && pm.getComponentEnabledSetting(new ComponentName(context, MailService.class)) ==
                PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
            /*
             * If no accounts now exist but the service is still enabled we're about to disable it
             * so we'll reschedule to kill off any existing alarms.
             */
            MailService.actionReset(context, wakeLockId);
        }
        Class<?>[] classes = { MessageCompose.class, BootReceiver.class, MailService.class };

        for (Class<?> clazz : classes) {

            boolean alreadyEnabled = pm.getComponentEnabledSetting(new ComponentName(context, clazz)) ==
                                     PackageManager.COMPONENT_ENABLED_STATE_ENABLED;

            if (enabled != alreadyEnabled) {
                pm.setComponentEnabledSetting(
                    new ComponentName(context, clazz),
                    enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED :
                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                    PackageManager.DONT_KILL_APP);
            }
        }

        if (enabled && pm.getComponentEnabledSetting(new ComponentName(context, MailService.class)) ==
                PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
            /*
             * And now if accounts do exist then we've just enabled the service and we want to
             * schedule alarms for the new accounts.
             */
            MailService.actionReset(context, wakeLockId);
        }

    }

    /**
     * Register BroadcastReceivers programmaticaly because doing it from manifest
     * would make K-9 auto-start. We don't want auto-start because the initialization
     * sequence isn't safe while some events occur (SD card unmount).
     */
    protected void registerReceivers() {
        final StorageGoneReceiver receiver = new StorageGoneReceiver();
        final IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_MEDIA_EJECT);
        filter.addAction(Intent.ACTION_MEDIA_UNMOUNTED);
        filter.addDataScheme(""file"");

        final BlockingQueue<Handler> queue = new SynchronousQueue<Handler>();

        // starting a new thread to handle unmount events
        new Thread(new Runnable() {
            @Override
            public void run() {
                Looper.prepare();
                try {
                    queue.put(new Handler());
                } catch (InterruptedException e) {
                    Log.e(K9.LOG_TAG, """", e);
                }
                Looper.loop();
            }

        }, ""Unmount-thread"").start();

        try {
            final Handler storageGoneHandler = queue.take();
            registerReceiver(receiver, filter, null, storageGoneHandler);
            Log.i(K9.LOG_TAG, ""Registered: unmount receiver"");
        } catch (InterruptedException e) {
            Log.e(K9.LOG_TAG, ""Unable to register unmount receiver"", e);
        }

        registerReceiver(new ShutdownReceiver(), new IntentFilter(Intent.ACTION_SHUTDOWN));
        Log.i(K9.LOG_TAG, ""Registered: shutdown receiver"");
    }

    public static void save(SharedPreferences.Editor editor) {
        editor.putBoolean(""enableDebugLogging"", K9.DEBUG);
        editor.putBoolean(""enableSensitiveLogging"", K9.DEBUG_SENSITIVE);
        editor.putString(""backgroundOperations"", K9.backgroundOps.toString());
        editor.putBoolean(""animations"", mAnimations);
        editor.putBoolean(""gesturesEnabled"", mGesturesEnabled);
        editor.putBoolean(""useVolumeKeysForNavigation"", mUseVolumeKeysForNavigation);
        editor.putBoolean(""useVolumeKeysForListNavigation"", mUseVolumeKeysForListNavigation);
        editor.putBoolean(""manageBack"", mManageBack);
        editor.putBoolean(""zoomControlsEnabled"", mZoomControlsEnabled);
        editor.putBoolean(""mobileOptimizedLayout"", mMobileOptimizedLayout);
        editor.putBoolean(""quietTimeEnabled"", mQuietTimeEnabled);
        editor.putString(""quietTimeStarts"", mQuietTimeStarts);
        editor.putString(""quietTimeEnds"", mQuietTimeEnds);

        editor.putBoolean(""startIntegratedInbox"", mStartIntegratedInbox);
        editor.putBoolean(""measureAccounts"", mMeasureAccounts);
        editor.putBoolean(""countSearchMessages"", mCountSearchMessages);
        editor.putBoolean(""hideSpecialAccounts"", mHideSpecialAccounts);
        editor.putBoolean(""messageListStars"", mMessageListStars);
        editor.putBoolean(""messageListCheckboxes"", mMessageListCheckboxes);
        editor.putBoolean(""messageListTouchable"", mMessageListTouchable);
        editor.putInt(""messageListPreviewLines"", mMessageListPreviewLines);

        editor.putBoolean(""showCorrespondentNames"", mShowCorrespondentNames);
        editor.putBoolean(""showContactName"", mShowContactName);
        editor.putBoolean(""changeRegisteredNameColor"", mChangeContactNameColor);
        editor.putInt(""registeredNameColor"", mContactNameColor);
        editor.putBoolean(""messageViewFixedWidthFont"", mMessageViewFixedWidthFont);
        editor.putBoolean(""messageViewReturnToList"", mMessageViewReturnToList);

        editor.putString(""language"", language);
        editor.putInt(""theme"", theme);
        editor.putBoolean(""useGalleryBugWorkaround"", useGalleryBugWorkaround);

        editor.putBoolean(""confirmDelete"", mConfirmDelete);
        editor.putBoolean(""confirmSpam"", mConfirmSpam);
        editor.putBoolean(""confirmMarkAllAsRead"", mConfirmMarkAllAsRead);

        editor.putBoolean(""keyguardPrivacy"", mKeyguardPrivacy);

        editor.putBoolean(""compactLayouts"", compactLayouts);
        editor.putString(""attachmentdefaultpath"", mAttachmentDefaultPath);
        fontSizes.save(editor);
    }

    @Override
    public void onCreate() {
        maybeSetupStrictMode();
        super.onCreate();
        app = this;


        galleryBuggy = checkForBuggyGallery();

        Preferences prefs = Preferences.getPreferences(this);
        SharedPreferences sprefs = prefs.getPreferences();
        DEBUG = sprefs.getBoolean(""enableDebugLogging"", false);
        DEBUG_SENSITIVE = sprefs.getBoolean(""enableSensitiveLogging"", false);
        mAnimations = sprefs.getBoolean(""animations"", true);
        mGesturesEnabled = sprefs.getBoolean(""gesturesEnabled"", true);
        mUseVolumeKeysForNavigation = sprefs.getBoolean(""useVolumeKeysForNavigation"", false);
        mUseVolumeKeysForListNavigation = sprefs.getBoolean(""useVolumeKeysForListNavigation"", false);
        mManageBack = sprefs.getBoolean(""manageBack"", false);
        mStartIntegratedInbox = sprefs.getBoolean(""startIntegratedInbox"", false);
        mMeasureAccounts = sprefs.getBoolean(""measureAccounts"", true);
        mCountSearchMessages = sprefs.getBoolean(""countSearchMessages"", true);
        mHideSpecialAccounts = sprefs.getBoolean(""hideSpecialAccounts"", false);
        mMessageListStars = sprefs.getBoolean(""messageListStars"", true);
        mMessageListCheckboxes = sprefs.getBoolean(""messageListCheckboxes"", false);
        mMessageListTouchable = sprefs.getBoolean(""messageListTouchable"", false);
        mMessageListPreviewLines = sprefs.getInt(""messageListPreviewLines"", 2);

        mMobileOptimizedLayout = sprefs.getBoolean(""mobileOptimizedLayout"", false);
        mZoomControlsEnabled = sprefs.getBoolean(""zoomControlsEnabled"", false);

        mQuietTimeEnabled = sprefs.getBoolean(""quietTimeEnabled"", false);
        mQuietTimeStarts = sprefs.getString(""quietTimeStarts"", ""21:00"");
        mQuietTimeEnds = sprefs.getString(""quietTimeEnds"", ""7:00"");

        mShowCorrespondentNames = sprefs.getBoolean(""showCorrespondentNames"", true);
        mShowContactName = sprefs.getBoolean(""showContactName"", false);
        mChangeContactNameColor = sprefs.getBoolean(""changeRegisteredNameColor"", false);
        mContactNameColor = sprefs.getInt(""registeredNameColor"", 0xff00008f);
        mMessageViewFixedWidthFont = sprefs.getBoolean(""messageViewFixedWidthFont"", false);
        mMessageViewReturnToList = sprefs.getBoolean(""messageViewReturnToList"", false);

        useGalleryBugWorkaround = sprefs.getBoolean(""useGalleryBugWorkaround"", K9.isGalleryBuggy());

        mConfirmDelete = sprefs.getBoolean(""confirmDelete"", false);
        mConfirmSpam = sprefs.getBoolean(""confirmSpam"", false);
        mConfirmMarkAllAsRead = sprefs.getBoolean(""confirmMarkAllAsRead"", true);


        mKeyguardPrivacy = sprefs.getBoolean(""keyguardPrivacy"", false);

        compactLayouts = sprefs.getBoolean(""compactLayouts"", false);
        mAttachmentDefaultPath = sprefs.getString(""attachmentdefaultpath"",  Environment.getExternalStorageDirectory().toString());
        fontSizes.load(sprefs);

        try {
            setBackgroundOps(BACKGROUND_OPS.valueOf(sprefs.getString(""backgroundOperations"", ""WHEN_CHECKED"")));
        } catch (Exception e) {
            setBackgroundOps(BACKGROUND_OPS.WHEN_CHECKED);
        }

        K9.setK9Language(sprefs.getString(""language"", """"));
        K9.setK9Theme(sprefs.getInt(""theme"", android.R.style.Theme_Light));

        /*
         * We have to give MimeMessage a temp directory because File.createTempFile(String, String)
         * doesn't work in Android and MimeMessage does not have access to a Context.
         */
        BinaryTempFileBody.setTempDirectory(getCacheDir());

        /*
         * Enable background sync of messages
         */

        setServicesEnabled(this);
        registerReceivers();

        MessagingController.getInstance(this).addListener(new MessagingListener() {
            private void broadcastIntent(String action, Account account, String folder, Message message) {
                try {
                    Uri uri = Uri.parse(""email://messages/"" + account.getAccountNumber() + ""/"" + Uri.encode(folder) + ""/"" + Uri.encode(message.getUid()));
                    Intent intent = new Intent(action, uri);
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_ACCOUNT, account.getDescription());
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_FOLDER, folder);
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_SENT_DATE, message.getSentDate());
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_FROM, Address.toString(message.getFrom()));
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_TO, Address.toString(message.getRecipients(Message.RecipientType.TO)));
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_CC, Address.toString(message.getRecipients(Message.RecipientType.CC)));
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_BCC, Address.toString(message.getRecipients(Message.RecipientType.BCC)));
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_SUBJECT, message.getSubject());
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_FROM_SELF, account.isAnIdentity(message.getFrom()));
                    K9.this.sendBroadcast(intent);
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Broadcasted: action="" + action
                              + "" account="" + account.getDescription()
                              + "" folder="" + folder
                              + "" message uid="" + message.getUid()
                             );

                } catch (MessagingException e) {
                    Log.w(K9.LOG_TAG, ""Error: action="" + action
                          + "" account="" + account.getDescription()
                          + "" folder="" + folder
                          + "" message uid="" + message.getUid()
                         );
                }
            }

            @Override
            public void synchronizeMailboxRemovedMessage(Account account, String folder, Message message) {
                broadcastIntent(K9.Intents.EmailReceived.ACTION_EMAIL_DELETED, account, folder, message);
            }

            @Override
            public void messageDeleted(Account account, String folder, Message message) {
                broadcastIntent(K9.Intents.EmailReceived.ACTION_EMAIL_DELETED, account, folder, message);
            }

            @Override
            public void synchronizeMailboxNewMessage(Account account, String folder, Message message) {
                broadcastIntent(K9.Intents.EmailReceived.ACTION_EMAIL_RECEIVED, account, folder, message);
            }

            @Override
            public void searchStats(final AccountStats stats) {
                // let observers know a fetch occured
                K9.this.sendBroadcast(new Intent(K9.Intents.EmailReceived.ACTION_REFRESH_OBSERVER, null));
            }

        });

        notifyObservers();
    }

    private void maybeSetupStrictMode() {
        if (!K9.DEVELOPER_MODE)
            return;

        try {
            Class<?> strictMode = Class.forName(""android.os.StrictMode"");
            Method enableDefaults = strictMode.getMethod(""enableDefaults"");
            enableDefaults.invoke(strictMode);
        }

        catch (Exception e) {
            // Discard , as it means we're not running on a device with strict mode
            Log.v(K9.LOG_TAG, ""Failed to turn on strict mode "" + e);
        }

    }


    /**
     * since Android invokes Application.onCreate() only after invoking all
     * other components' onCreate(), here is a way to notify interested
     * component that the application is available and ready
     */
    protected void notifyObservers() {
        for (final ApplicationAware aware : observers) {
            if (K9.DEBUG) {
                Log.v(K9.LOG_TAG, ""Initializing observer: "" + aware);
            }
            try {
                aware.initializeComponent(this);
            } catch (Exception e) {
                Log.w(K9.LOG_TAG, ""Failure when notifying "" + aware, e);
            }
        }
    }

    /**
     * Register a component to be notified when the {@link K9} instance is ready.
     *
     * @param component
     *            Never <code>null</code>.
     */
    public static void registerApplicationAware(final ApplicationAware component) {
        if (!observers.contains(component)) {
            observers.add(component);
        }
    }

    public static String getK9Language() {
        return language;
    }

    public static void setK9Language(String nlanguage) {
        language = nlanguage;
    }

    public static int getK9Theme() {
        return theme;
    }

    public static void setK9Theme(int ntheme) {
        theme = ntheme;
    }

    public static BACKGROUND_OPS getBackgroundOps() {
        return backgroundOps;
    }

    public static boolean setBackgroundOps(BACKGROUND_OPS backgroundOps) {
        BACKGROUND_OPS oldBackgroundOps = K9.backgroundOps;
        K9.backgroundOps = backgroundOps;
        return backgroundOps != oldBackgroundOps;
    }

    public static boolean setBackgroundOps(String nbackgroundOps) {
        return setBackgroundOps(BACKGROUND_OPS.valueOf(nbackgroundOps));
    }

    public static boolean gesturesEnabled() {
        return mGesturesEnabled;
    }

    public static void setGesturesEnabled(boolean gestures) {
        mGesturesEnabled = gestures;
    }

    public static boolean useVolumeKeysForNavigationEnabled() {
        return mUseVolumeKeysForNavigation;
    }

    public static void setUseVolumeKeysForNavigation(boolean volume) {
        mUseVolumeKeysForNavigation = volume;
    }

    public static boolean useVolumeKeysForListNavigationEnabled() {
        return mUseVolumeKeysForListNavigation;
    }

    public static void setUseVolumeKeysForListNavigation(boolean enabled) {
        mUseVolumeKeysForListNavigation = enabled;
    }

    public static boolean manageBack() {
        return mManageBack;
    }

    public static void setManageBack(boolean manageBack) {
        mManageBack = manageBack;
    }

    public static boolean zoomControlsEnabled() {
        return mZoomControlsEnabled;
    }

    public static void setZoomControlsEnabled(boolean zoomControlsEnabled) {
        mZoomControlsEnabled = zoomControlsEnabled;
    }


    public static boolean mobileOptimizedLayout() {
        return mMobileOptimizedLayout;
    }

    public static void setMobileOptimizedLayout(boolean mobileOptimizedLayout) {
        mMobileOptimizedLayout = mobileOptimizedLayout;
    }

    public static boolean getQuietTimeEnabled() {
        return mQuietTimeEnabled;
    }

    public static void setQuietTimeEnabled(boolean quietTimeEnabled) {
        mQuietTimeEnabled = quietTimeEnabled;
    }

    public static String getQuietTimeStarts() {
        return mQuietTimeStarts;
    }

    public static void setQuietTimeStarts(String quietTimeStarts) {
        mQuietTimeStarts = quietTimeStarts;
    }

    public static String getQuietTimeEnds() {
        return mQuietTimeEnds;
    }

    public static void setQuietTimeEnds(String quietTimeEnds) {
        mQuietTimeEnds = quietTimeEnds;
    }


    public static boolean isQuietTime() {
        if (!mQuietTimeEnabled) {
            return false;
        }

        Time time = new Time();
        time.setToNow();
        Integer startHour = Integer.parseInt(mQuietTimeStarts.split("":"")[0]);
        Integer startMinute = Integer.parseInt(mQuietTimeStarts.split("":"")[1]);
        Integer endHour = Integer.parseInt(mQuietTimeEnds.split("":"")[0]);
        Integer endMinute = Integer.parseInt(mQuietTimeEnds.split("":"")[1]);

        Integer now = (time.hour * 60) + time.minute;
        Integer quietStarts = startHour * 60 + startMinute;
        Integer quietEnds =  endHour * 60 + endMinute;

        // If start and end times are the same, we're never quiet
        if (quietStarts.equals(quietEnds)) {
            return false;
        }


        // 21:00 - 05:00 means we want to be quiet if it's after 9 or before 5
        if (quietStarts > quietEnds) {
            // if it's 22:00 or 03:00 but not 8:00
            if (now >= quietStarts || now <= quietEnds) {
                return true;
            }
        }

        // 01:00 - 05:00
        else {

            // if it' 2:00 or 4:00 but not 8:00 or 0:00
            if (now >= quietStarts && now <= quietEnds) {
                return true;
            }
        }

        return false;
    }



    public static boolean startIntegratedInbox() {
        return mStartIntegratedInbox;
    }

    public static void setStartIntegratedInbox(boolean startIntegratedInbox) {
        mStartIntegratedInbox = startIntegratedInbox;
    }

    public static boolean showAnimations() {
        return mAnimations;
    }

    public static void setAnimations(boolean animations) {
        mAnimations = animations;
    }

    public static boolean messageListTouchable() {
        return mMessageListTouchable;
    }

    public static void setMessageListTouchable(boolean touchy) {
        mMessageListTouchable = touchy;
    }

    public static int messageListPreviewLines() {
        return mMessageListPreviewLines;
    }

    public static void setMessageListPreviewLines(int lines) {
        mMessageListPreviewLines = lines;
    }

    public static boolean messageListStars() {
        return mMessageListStars;
    }

    public static void setMessageListStars(boolean stars) {
        mMessageListStars = stars;
    }
    public static boolean messageListCheckboxes() {
        return mMessageListCheckboxes;
    }

    public static void setMessageListCheckboxes(boolean checkboxes) {
        mMessageListCheckboxes = checkboxes;
    }

    public static boolean showCorrespondentNames() {
        return mShowCorrespondentNames;
    }

    public static void setShowCorrespondentNames(boolean showCorrespondentNames) {
        mShowCorrespondentNames = showCorrespondentNames;
    }

    public static boolean showContactName() {
        return mShowContactName;
    }

    public static void setShowContactName(boolean showContactName) {
        mShowContactName = showContactName;
    }

    public static boolean changeContactNameColor() {
        return mChangeContactNameColor;
    }

    public static void setChangeContactNameColor(boolean changeContactNameColor) {
        mChangeContactNameColor = changeContactNameColor;
    }

    public static int getContactNameColor() {
        return mContactNameColor;
    }

    public static void setContactNameColor(int contactNameColor) {
        mContactNameColor = contactNameColor;
    }

    public static boolean messageViewFixedWidthFont() {
        return mMessageViewFixedWidthFont;
    }

    public static void setMessageViewFixedWidthFont(boolean fixed) {
        mMessageViewFixedWidthFont = fixed;
    }

    public static boolean messageViewReturnToList() {
        return mMessageViewReturnToList;
    }

    public static void setMessageViewReturnToList(boolean messageViewReturnToList) {
        mMessageViewReturnToList = messageViewReturnToList;
    }

    public static Method getMethod(Class<?> classObject, String methodName) {
        try {
            return classObject.getMethod(methodName, boolean.class);
        } catch (NoSuchMethodException e) {
            Log.i(K9.LOG_TAG, ""Can't get method "" +
                  classObject.toString() + ""."" + methodName);
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Error while using reflection to get method "" +
                  classObject.toString() + ""."" + methodName, e);
        }
        return null;
    }

    public static FontSizes getFontSizes() {
        return fontSizes;
    }

    public static boolean measureAccounts() {
        return mMeasureAccounts;
    }

    public static void setMeasureAccounts(boolean measureAccounts) {
        mMeasureAccounts = measureAccounts;
    }

    public static boolean countSearchMessages() {
        return mCountSearchMessages;
    }

    public static void setCountSearchMessages(boolean countSearchMessages) {
        mCountSearchMessages = countSearchMessages;
    }

    public static boolean isHideSpecialAccounts() {
        return mHideSpecialAccounts;
    }

    public static void setHideSpecialAccounts(boolean hideSpecialAccounts) {
        mHideSpecialAccounts = hideSpecialAccounts;
    }

    public static boolean useGalleryBugWorkaround() {
        return useGalleryBugWorkaround;
    }

    public static void setUseGalleryBugWorkaround(boolean useGalleryBugWorkaround) {
        K9.useGalleryBugWorkaround = useGalleryBugWorkaround;
    }

    public static boolean isGalleryBuggy() {
        return galleryBuggy;
    }

    public static boolean confirmDelete() {
        return mConfirmDelete;
    }

    public static void setConfirmDelete(final boolean confirm) {
        mConfirmDelete = confirm;
    }

    public static boolean confirmSpam() {
        return mConfirmSpam;
    }

    public static void setConfirmSpam(final boolean confirm) {
        mConfirmSpam = confirm;
    }

    public static boolean confirmMarkAllAsRead() {
        return mConfirmMarkAllAsRead;
    }

    public static void setConfirmMarkAllAsRead(final boolean confirm) {
        mConfirmMarkAllAsRead = confirm;
    }

    /**
     * @return Whether privacy rules should be applied when system is locked
     */
    public static boolean keyguardPrivacy() {
        return mKeyguardPrivacy;
    }

    public static void setKeyguardPrivacy(final boolean state) {
        mKeyguardPrivacy = state;
    }

    public static boolean useCompactLayouts() {
        return compactLayouts;
    }

    public static void setCompactLayouts(boolean compactLayouts) {
        K9.compactLayouts = compactLayouts;
    }

    /**
     * Check if this system contains a buggy Gallery 3D package.
     *
     * We have to work around the fact that those Gallery versions won't show
     * any images or videos when the pick intent is used with a MIME type other
     * than image/* or video/*. See issue 1186.
     *
     * @return true, if a buggy Gallery 3D package was found. False, otherwise.
     */
    private boolean checkForBuggyGallery() {
        try {
            PackageInfo pi = getPackageManager().getPackageInfo(""com.cooliris.media"", 0);

            return (pi.versionCode == 30682);
        } catch (NameNotFoundException e) {
            return false;
        }
    }

    public static String getAttachmentDefaultPath() {
        return mAttachmentDefaultPath;
    }

    public static void setAttachmentDefaultPath(String attachmentDefaultPath) {
        K9.mAttachmentDefaultPath = attachmentDefaultPath;
    }

    /**
     * Creates an {@link AbsoluteSizeSpan} object.
     *
     * <p>
     * Android versions prior to 2.0 don't support the constructor with two parameters
     * ({@link AbsoluteSizeSpan#AbsoluteSizeSpan(int, boolean)}). So we have to perform some
     * reflection magic to dynamically load the new constructor on devices that support it.
     * For devices with old Android versions we just use the size as pixels (instead of dip).
     * </p>
     *
     * @param size This is used as the {@code size} parameter for the AbsoluteSizeSpan constructor.
     * @return a AbsoluteSizeSpan object with the specified text size.
     */
    public static AbsoluteSizeSpan createAbsoluteSizeSpan(int size) {
        if (Integer.parseInt(android.os.Build.VERSION.SDK) < 5) {
            // For Android 1.5/1.6 simply use the constructor with only the size parameter.
            // Yes, that will most likely look wrong!
            return new AbsoluteSizeSpan(size);
        }

        if (sAbsoluteSizeSpanConstructor == null) {
            try {
                sAbsoluteSizeSpanConstructor = AbsoluteSizeSpan.class.getConstructor(int.class, boolean.class);
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Couldn't get the AbsoluteSizeSpan(int, boolean) constructor"", e);

                // Fallback
                return new AbsoluteSizeSpan(size);
            }
        }

        AbsoluteSizeSpan result;
        try {
            result = sAbsoluteSizeSpanConstructor.newInstance(size, true);
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Couldn't call the AbsoluteSizeSpan(int, boolean) constructor"", e);

            // Fallback
            result = new AbsoluteSizeSpan(size);
        }

        return result;
    }
}
",True,154,2,9,6,55,76,15,L1
6,com.fsck.k9.AccountStats.java,"/**
 *
 */
package com.fsck.k9;

import java.io.Serializable;

public class AccountStats implements Serializable {
    private static final long serialVersionUID = -5706839923710842234L;
    public long size = -1;
    public int unreadMessageCount = 0;
    public int flaggedMessageCount = 0;
    public boolean available = true;
}
",False,113,4,80,0,0,10,0,L1
7,com.fsck.k9.Identity.java,"package com.fsck.k9;

import java.io.Serializable;

public class Identity implements Serializable {
    private static final long serialVersionUID = -1666669071480985760L;
    private String mDescription;
    private String mName;
    private String mEmail;
    private String mSignature;
    private boolean mSignatureUse;
    private String replyTo;

    public synchronized String getName() {
        return mName;
    }

    public synchronized void setName(String name) {
        mName = name;
    }

    public synchronized String getEmail() {
        return mEmail;
    }

    public synchronized void setEmail(String email) {
        mEmail = email;
    }

    public synchronized boolean getSignatureUse() {
        return mSignatureUse;
    }

    public synchronized void setSignatureUse(boolean signatureUse) {
        mSignatureUse = signatureUse;
    }

    public synchronized String getSignature() {
        return mSignature;
    }

    public synchronized void setSignature(String signature) {
        mSignature = signature;
    }

    public synchronized String getDescription() {
        return mDescription;
    }

    public synchronized void setDescription(String description) {
        mDescription = description;
    }

    public synchronized String getReplyTo() {
        return replyTo;
    }

    public synchronized void setReplyTo(String replyTo) {
        this.replyTo = replyTo;
    }

    @Override
    public synchronized String toString() {
        return ""Account.Identity(description="" + mDescription + "", name="" + mName + "", email="" + mEmail + "", replyTo="" + replyTo + "", signature="" + mSignature;
    }
}
",False,113,5,51,0,0,6,0,L1
8,com.fsck.k9.EmailReceivedIntent.java,"package com.fsck.k9;

public class EmailReceivedIntent {

    public static final String ACTION_EMAIL_RECEIVED = ""com.fsck.k9.intent.action.EMAIL_RECEIVED"";
    public static final String EXTRA_ACCOUNT    = ""com.fsck.k9.intent.extra.ACCOUNT"";
    public static final String EXTRA_FOLDER     = ""com.fsck.k9.intent.extra.FOLDER"";
    public static final String EXTRA_SENT_DATE  = ""com.fsck.k9.intent.extra.SENT_DATE"";
    public static final String EXTRA_FROM       = ""com.fsck.k9.intent.extra.FROM"";
    public static final String EXTRA_TO         = ""com.fsck.k9.intent.extra.TO"";
    public static final String EXTRA_CC         = ""com.fsck.k9.intent.extra.CC"";
    public static final String EXTRA_BCC        = ""com.fsck.k9.intent.extra.BCC"";
    public static final String EXTRA_SUBJECT    = ""com.fsck.k9.intent.extra.SUBJECT"";
}
",False,1,0,0,0,0,0,0,I0
9,com.fsck.k9.BaseAccount.java,"package com.fsck.k9;

public interface BaseAccount {
    public String getEmail();
    public void setEmail(String email);
    public String getDescription();
    public void setDescription(String description);
    public String getUuid();
}
",False,113,5,49,0,0,5,0,L1
10,com.fsck.k9.SearchAccount.java,"/**
 *
 */
package com.fsck.k9;

import java.io.Serializable;
import java.util.UUID;

import android.content.Context;

import com.fsck.k9.mail.Flag;

public class SearchAccount implements BaseAccount, SearchSpecification, Serializable {
    private static final long serialVersionUID = -4388420303235543976L;
    private Flag[] mRequiredFlags = null;
    private Flag[] mForbiddenFlags = null;
    private String email = null;
    private String description = null;
    private String query = """";
    private boolean integrate = false;
    private String mUuid = null;
    private boolean builtin = false;
    private String[] accountUuids = null;
    private String[] folderNames = null;

    public SearchAccount(Preferences preferences) {

    }
    protected synchronized void delete(Preferences preferences) {

    }

    public synchronized void save(Preferences preferences) {

    }


    public SearchAccount(Context context, boolean nintegrate, Flag[] requiredFlags, Flag[] forbiddenFlags) {
        mRequiredFlags = requiredFlags;
        mForbiddenFlags = forbiddenFlags;
        integrate = nintegrate;
    }

    @Override
    public synchronized String getEmail() {
        return email;
    }

    @Override
    public synchronized void setEmail(String email) {
        this.email = email;
    }

    public Flag[] getRequiredFlags() {
        return mRequiredFlags;
    }

    public Flag[] getForbiddenFlags() {
        return mForbiddenFlags;
    }

    public boolean isIntegrate() {
        return integrate;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getQuery() {
        return query;
    }

    public void setQuery(String query) {
        this.query = query;
    }
    public String getUuid() {
        if (mUuid == null) {
            setUuid(UUID.randomUUID().toString());
        }
        return mUuid;
    }
    public void setUuid(String nUuid) {
        mUuid = nUuid;
    }

    public void setIntegrate(boolean integrate) {
        this.integrate = integrate;
    }

    public boolean isBuiltin() {
        return builtin;
    }

    public void setBuiltin(boolean builtin) {
        this.builtin = builtin;
    }
    public String[] getAccountUuids() {
        return accountUuids;
    }
    public void setAccountUuids(String[] accountUuids) {
        this.accountUuids = accountUuids;
    }
    @Override
    public String[] getFolderNames() {
        return folderNames;
    }
    public void setFolderNames(String[] folderNames) {
        this.folderNames = folderNames;
    }
}
",False,145,1,1,7,50,2,4,L1
11,com.fsck.k9.EmailAddressValidator.java,"
package com.fsck.k9;

import android.text.util.Rfc822Tokenizer;
import android.widget.AutoCompleteTextView.Validator;

public class EmailAddressValidator implements Validator {
    public CharSequence fixText(CharSequence invalidText) {
        return """";
    }

    public boolean isValid(CharSequence text) {
        return Rfc822Tokenizer.tokenize(text).length > 0;
    }

    public boolean isValidAddressOnly(CharSequence text) {
        return com.fsck.k9.helper.Regex.EMAIL_ADDRESS_PATTERN.matcher(text).matches();
    }
}
",False,114,5,73,1,1,2,1,L1
12,com.fsck.k9.NotificationSetting.java,"package com.fsck.k9;

/**
 * Describes how a notification should behave.
 */
public class NotificationSetting {

    /**
     * Ring notification kill switch. Allow disabling ringtones without losing
     * ringtone selection.
     */
    private boolean mRing;

    private String mRingtoneUri;

    /**
     * LED kill switch.
     */
    private boolean mLed;

    private int mLedColor;

    /**
     * Vibration kill switch.
     */
    private boolean mVibrate;

    private int mVibratePattern;

    private int mVibrateTimes;

    /**
     * Set the ringtone kill switch. Allow to disable ringtone without losing
     * ringtone selection.
     *
     * @param ring
     *            <code>true</code> to allow ringtones, <code>false</code>
     *            otherwise.
     */
    public synchronized void setRing(boolean ring) {
        mRing = ring;
    }

    /**
     * @return <code>true</code> if ringtone is allowed to play,
     *         <code>false</code> otherwise.
     */
    public synchronized boolean shouldRing() {
        return mRing;
    }

    public synchronized String getRingtone() {
        return mRingtoneUri;
    }

    public synchronized void setRingtone(String ringtoneUri) {
        mRingtoneUri = ringtoneUri;
    }

    public synchronized boolean isLed() {
        return mLed;
    }

    public synchronized void setLed(final boolean led) {
        mLed = led;
    }

    public synchronized int getLedColor() {
        return mLedColor;
    }

    public synchronized void setLedColor(int color) {
        mLedColor = color;
    }

    public synchronized boolean shouldVibrate() {
        return mVibrate;
    }

    public synchronized void setVibrate(boolean vibrate) {
        mVibrate = vibrate;
    }

    public synchronized int getVibratePattern() {
        return mVibratePattern;
    }

    public synchronized int getVibrateTimes() {
        return mVibrateTimes;
    }

    public synchronized void setVibratePattern(int pattern) {
        mVibratePattern = pattern;
    }

    public synchronized void setVibrateTimes(int times) {
        mVibrateTimes = times;
    }



    /*
     * Fetch a vibration pattern.
     *
     * @param vibratePattern Vibration pattern index to use.
     * @param vibrateTimes Number of times to do the vibration pattern.
     * @return Pattern multiplied by the number of times requested.
     */

    public long[] getVibration() {
        return getVibration(mVibratePattern, mVibrateTimes);
    }

    public static long[] getVibration(int pattern, int times) {
        // These are ""off, on"" patterns, specified in milliseconds
        long[] pattern0 = new long[] {300, 200}; // like the default pattern
        long[] pattern1 = new long[] {100, 200};
        long[] pattern2 = new long[] {100, 500};
        long[] pattern3 = new long[] {200, 200};
        long[] pattern4 = new long[] {200, 500};
        long[] pattern5 = new long[] {500, 500};

        long[] selectedPattern = pattern0; //default pattern

        switch (pattern) {
        case 1:
            selectedPattern = pattern1;
            break;
        case 2:
            selectedPattern = pattern2;
            break;
        case 3:
            selectedPattern = pattern3;
            break;
        case 4:
            selectedPattern = pattern4;
            break;
        case 5:
            selectedPattern = pattern5;
            break;
        }

        long[] repeatedPattern = new long[selectedPattern.length * times];
        for (int n = 0; n < times; n++) {
            System.arraycopy(selectedPattern, 0, repeatedPattern, n * selectedPattern.length, selectedPattern.length);
        }
        // Do not wait before starting the vibration pattern.
        repeatedPattern[0] = 0;
        return repeatedPattern;
    }



}
",False,113,5,51,0,0,4,0,L1
13,com.fsck.k9.view.AccessibleWebView.java,"/*
 * Copyright (C) 2010 The IDEAL Group
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.view;

import android.content.Context;
import android.content.Intent;
import android.text.Html;
import android.util.AttributeSet;
import android.view.View;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.widget.TextView;

import com.fsck.k9.activity.AccessibleEmailContentActivity;

public class AccessibleWebView extends TextView {
    private Context mContext;
    private String mHtmlSource;
    private WebView mDummyWebView;

    public AccessibleWebView(Context context) {
        super(context);
        init(context);
    }

    public AccessibleWebView(Context context, AttributeSet attributes) {
        super(context, attributes);
        init(context);
    }

    private void init(Context context) {
        mContext = context;
        mDummyWebView = new WebView(context);
        setFocusable(true);
        setFocusableInTouchMode(true);
        setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View arg0) {
                diveIn();
            }
        });
    }

    public void loadData(String data, String mimeType, String encoding) {
        mHtmlSource = data;
        this.setText(Html.fromHtml(mHtmlSource, null, null));
    }

    public WebSettings getSettings() {
        return mDummyWebView.getSettings();
    }

    public void loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding,
                                    String historyUrl) {
        mHtmlSource = data;
        this.setText(Html.fromHtml(mHtmlSource, null, null));
    }

    public boolean zoomIn() {
        if (getTextSize() < 100) {
            setTextSize(getTextSize() + 5);
            return true;
        }
        return false;
    }

    public boolean zoomOut() {
        if (getTextSize() > 5) {
            setTextSize(getTextSize() - 5);
            return true;
        }
        return false;
    }

    private void diveIn() {
        Intent i = new Intent();
        i.setClass(mContext, AccessibleEmailContentActivity.class);
        i.putExtra(""content"", mHtmlSource);
        mContext.startActivity(i);
    }
}
",False,114,8,45,1,1,1,1,L1
14,com.fsck.k9.view.MessageWebView.java,"package com.fsck.k9.view;

import android.content.Context;
import android.os.Build;
import android.util.AttributeSet;
import android.util.Log;
import android.view.KeyEvent;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.widget.Toast;
import com.fsck.k9.K9;
import com.fsck.k9.R;

import java.lang.reflect.Method;

public class MessageWebView extends WebView {

    /**
     * We use WebSettings.getBlockNetworkLoads() to prevent the WebView that displays email
     * bodies from loading external resources over the network. Unfortunately this method
     * isn't exposed via the official Android API. That's why we use reflection to be able
     * to call the method.
     */
    public static final Method mGetBlockNetworkLoads = K9.getMethod(WebSettings.class, ""setBlockNetworkLoads"");

    public MessageWebView(Context context) {
        super(context);
    }

    public MessageWebView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MessageWebView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    /**
     * Configure a web view to load or not load network data. A <b>true</b> setting here means that
     * network data will be blocked.
     * @param shouldBlockNetworkData True if network data should be blocked, false to allow network data.
     */
    public void blockNetworkData(final boolean shouldBlockNetworkData) {
        // Sanity check to make sure we don't blow up.
        if (getSettings() == null) {
            return;
        }

        // Block network loads.
        if (mGetBlockNetworkLoads != null) {
            try {
                mGetBlockNetworkLoads.invoke(getSettings(), shouldBlockNetworkData);
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Error on invoking WebSettings.setBlockNetworkLoads()"", e);
            }
        }

        // Block network images.
        getSettings().setBlockNetworkImage(shouldBlockNetworkData);
    }


    /**
     * Configure a {@link android.webkit.WebView} to display a Message. This method takes into account a user's
     * preferences when configuring the view. This message is used to view a message and to display a message being
     * replied to.
     */
    public void configure() {
        this.setVerticalScrollBarEnabled(true);
        this.setVerticalScrollbarOverlay(true);
        this.setScrollBarStyle(SCROLLBARS_INSIDE_OVERLAY);


        final WebSettings webSettings = this.getSettings();

        webSettings.setCacheMode(WebSettings.LOAD_NO_CACHE);
        webSettings.setSupportZoom(true);
        webSettings.setJavaScriptEnabled(false);
        webSettings.setLoadsImagesAutomatically(true);
        webSettings.setRenderPriority(WebSettings.RenderPriority.HIGH);

        if (K9.zoomControlsEnabled()) {
            webSettings.setBuiltInZoomControls(true);
        }

        // SINGLE_COLUMN layout was broken on Android < 2.2, so we
        // administratively disable it
        if (
            (Integer.parseInt(Build.VERSION.SDK)  > 7)
            &&  K9.mobileOptimizedLayout()) {
            webSettings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN);
        } else {
            webSettings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.NARROW_COLUMNS);
        }

        webSettings.setTextSize(K9.getFontSizes().getMessageViewContent());

        // Disable network images by default.  This is overriden by preferences.
        blockNetworkData(true);
    }

    /*
     * Emulate the shift key being pressed to trigger the text selection mode
     * of a WebView.
     */
    @Override
    public void emulateShiftHeld() {
        try {

            KeyEvent shiftPressEvent = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN,
                                                    KeyEvent.KEYCODE_SHIFT_LEFT, 0, 0);
            shiftPressEvent.dispatch(this);
            Toast.makeText(getContext() , R.string.select_text_now, Toast.LENGTH_SHORT).show();
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Exception in emulateShiftHeld()"", e);
        }
    }
}
",True,144,0,0,7,54,2,2,L1
15,com.fsck.k9.view.ToggleScrollView.java,"package com.fsck.k9.view;

import android.content.Context;
import android.util.AttributeSet;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.widget.ScrollView;

public class ToggleScrollView extends ScrollView {
    private GestureDetector mDetector;
    private boolean mScrolling = true;

    public ToggleScrollView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mDetector = new GestureDetector(new YScrollDetector());
    }

    public void setScrolling(boolean enable) {
        mScrolling = enable;
    }

    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        return (mScrolling) ? super.onTouchEvent(ev) : true;
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if (!mScrolling) {
            return false;
        }

        // This doesn't quite get us to diagonal scrolling, but it's somewhat better than what we've
        // currently got.  This is based on
        // http://stackoverflow.com/questions/2646028/android-horizontalscrollview-within-scrollview-touch-handling
        boolean result = super.onInterceptTouchEvent(ev);
        // Let the original ScrollView handle ACTION_DOWN so we can stop the scroll when someone touches the screen.
        if (ev.getAction() == MotionEvent.ACTION_DOWN || mDetector.onTouchEvent(ev)) {
            return result;
        }

        return false;
    }

    // Return false if we're scrolling in the x direction. That is, decline to consume the event and
    // let the parent class take a stab at it.
    class YScrollDetector extends GestureDetector.SimpleOnGestureListener {
        @Override
        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
            try {
                if (Math.abs(distanceY) > Math.abs(distanceX)) {
                    return true;
                } else {
                    return false;
                }
            } catch (Exception e) {
                // nothing
            }
            return false;
        }
    }
}
",True,113,7,46,0,0,1,0,L1
16,com.fsck.k9.view.MessageCryptoView.java,"package com.fsck.k9.view;

import android.app.Activity;
import android.content.Context;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;
import android.widget.LinearLayout;
import android.widget.*;
import com.fsck.k9.K9;
import com.fsck.k9.R;
import com.fsck.k9.crypto.CryptoProvider;
import com.fsck.k9.crypto.PgpData;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Part;
import com.fsck.k9.mail.internet.MimeUtility;




public class MessageCryptoView extends LinearLayout {

    private Context mContext;
    private Activity mActivity;
    private Button mDecryptButton;
    private LinearLayout mCryptoSignatureLayout = null;
    private ImageView mCryptoSignatureStatusImage = null;
    private TextView mCryptoSignatureUserId = null;
    private TextView mCryptoSignatureUserIdRest = null;


    public MessageCryptoView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mContext = context;
    }

    public void setupChildViews() {
        mCryptoSignatureLayout = (LinearLayout) findViewById(R.id.crypto_signature);
        mCryptoSignatureStatusImage = (ImageView) findViewById(R.id.ic_crypto_signature_status);
        mCryptoSignatureUserId = (TextView) findViewById(R.id.userId);
        mCryptoSignatureUserIdRest = (TextView) findViewById(R.id.userIdRest);
        mCryptoSignatureLayout.setVisibility(View.INVISIBLE);
        mDecryptButton = (Button) findViewById(R.id.btn_decrypt);
    }

    public void setActivity(Activity activity) {
        mActivity = activity;

    }


    public void hide() {
        this.setVisibility(View.GONE);
    }

    /**
     * Fill the decrypt layout with signature data, if known, make controls visible, if
     * they should be visible.
     */
    public void updateLayout(final CryptoProvider cryptoProvider, final PgpData pgpData, final Message message) {
        if (pgpData.getSignatureKeyId() != 0) {
            mCryptoSignatureUserIdRest.setText(
                mContext.getString(R.string.key_id, Long.toHexString(pgpData.getSignatureKeyId() & 0xffffffffL)));
            String userId = pgpData.getSignatureUserId();
            if (userId == null) {
                userId = mContext.getString(R.string.unknown_crypto_signature_user_id);
            }
            String chunks[] = userId.split("" <"", 2);
            String name = chunks[0];
            if (chunks.length > 1) {
                mCryptoSignatureUserIdRest.setText(""<"" + chunks[1]);
            }
            mCryptoSignatureUserId.setText(name);
            if (pgpData.getSignatureSuccess()) {
                mCryptoSignatureStatusImage.setImageResource(R.drawable.overlay_ok);
            } else if (pgpData.getSignatureUnknown()) {
                mCryptoSignatureStatusImage.setImageResource(R.drawable.overlay_error);
            } else {
                mCryptoSignatureStatusImage.setImageResource(R.drawable.overlay_error);
            }
            mCryptoSignatureLayout.setVisibility(View.VISIBLE);
            this.setVisibility(View.VISIBLE);
        } else {
            mCryptoSignatureLayout.setVisibility(View.INVISIBLE);
        }
        if ((message == null) && (pgpData.getDecryptedData() == null)) {
            this.setVisibility(View.GONE);
            return;
        }
        if (pgpData.getDecryptedData() != null) {
            if (pgpData.getSignatureKeyId() == 0) {
                this.setVisibility(View.GONE);
            } else {
                // no need to show this after decryption/verification
                mDecryptButton.setVisibility(View.GONE);
            }
            return;
        }


        mDecryptButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                try {
                    String data = null;
                    Part part = MimeUtility.findFirstPartByMimeType(message, ""text/plain"");
                    if (part == null) {
                        part = MimeUtility.findFirstPartByMimeType(message, ""text/html"");
                    }
                    if (part != null) {
                        data = MimeUtility.getTextFromPart(part);
                    }
                    cryptoProvider.decrypt(mActivity, data, pgpData);
                } catch (MessagingException me) {
                    Log.e(K9.LOG_TAG, ""Unable to decrypt email."", me);
                }
            }
        });


        mDecryptButton.setVisibility(View.VISIBLE);
        if (cryptoProvider.isEncrypted(message)) {
            mDecryptButton.setText(R.string.btn_decrypt);
            this.setVisibility(View.VISIBLE);
        } else if (cryptoProvider.isSigned(message)) {
            mDecryptButton.setText(R.string.btn_verify);
            this.setVisibility(View.VISIBLE);
        } else {
            this.setVisibility(View.GONE);
            try {
                // check for PGP/MIME encryption
                Part pgp = MimeUtility.findFirstPartByMimeType(message, ""application/pgp-encrypted"");
                if (pgp != null) {
                    Toast.makeText(mContext, R.string.pgp_mime_unsupported, Toast.LENGTH_LONG).show();
                }
            } catch (MessagingException e) {
                // nothing to do...
            }
        }
    }

}
",True,144,0,0,6,42,1,7,L1
17,com.fsck.k9.view.AttachmentView.java,"package com.fsck.k9.view;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import org.apache.commons.io.IOUtils;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.os.Environment;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.R;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.helper.MediaScannerNotifier;
import com.fsck.k9.helper.SizeFormatter;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.Part;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.store.LocalStore.LocalAttachmentBodyPart;
import com.fsck.k9.provider.AttachmentProvider;

public class AttachmentView extends FrameLayout {

    private Context mContext;
    public Button viewButton;
    public Button downloadButton;
    public LocalAttachmentBodyPart part;
    private Message mMessage;
    private Account mAccount;
    private MessagingController mController;
    private MessagingListener mListener;
    public String name;
    public String contentType;
    public long size;
    public ImageView iconView;

    private AttachmentFileDownloadCallback callback;

    public AttachmentView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        mContext = context;
    }
    public AttachmentView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mContext = context;
    }
    public AttachmentView(Context context) {
        super(context);
        mContext = context;
    }


    public interface AttachmentFileDownloadCallback {
        /**
         * this method i called by the attachmentview when
         * he wants to show a filebrowser
         * the provider should show the filebrowser activity
         * and save the reference to the attachment view for later.
         * in his onActivityResult he can get the saved reference and
         * call the saveFile method of AttachmentView
         * @param view
         */
        public void showFileBrowser(AttachmentView caller);
    }
    public boolean populateFromPart(Part inputPart, Message message, Account account, MessagingController controller, MessagingListener listener) {
        try {
            part = (LocalAttachmentBodyPart) inputPart;

            contentType = MimeUtility.unfoldAndDecode(part.getContentType());
            String contentDisposition = MimeUtility.unfoldAndDecode(part.getDisposition());

            name = MimeUtility.getHeaderParameter(contentType, ""name"");
            if (name == null) {
                name = MimeUtility.getHeaderParameter(contentDisposition, ""filename"");
            }
            if (name == null) {
                return false;
            }

            mAccount = account;
            mMessage = message;
            mController = controller;
            mListener = listener;

            size = Integer.parseInt(MimeUtility.getHeaderParameter(contentDisposition, ""size""));
            contentType = MimeUtility.getMimeTypeForViewing(part.getMimeType(), name);
            TextView attachmentName = (TextView) findViewById(R.id.attachment_name);
            TextView attachmentInfo = (TextView) findViewById(R.id.attachment_info);
            ImageView attachmentIcon = (ImageView) findViewById(R.id.attachment_icon);
            viewButton = (Button) findViewById(R.id.view);
            downloadButton = (Button) findViewById(R.id.download);
            if ((!MimeUtility.mimeTypeMatches(contentType, K9.ACCEPTABLE_ATTACHMENT_VIEW_TYPES))
                    || (MimeUtility.mimeTypeMatches(contentType, K9.UNACCEPTABLE_ATTACHMENT_VIEW_TYPES))) {
                viewButton.setVisibility(View.GONE);
            }
            if ((!MimeUtility.mimeTypeMatches(contentType, K9.ACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES))
                    || (MimeUtility.mimeTypeMatches(contentType, K9.UNACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES))) {
                downloadButton.setVisibility(View.GONE);
            }
            if (size > K9.MAX_ATTACHMENT_DOWNLOAD_SIZE) {
                viewButton.setVisibility(View.GONE);
                downloadButton.setVisibility(View.GONE);
            }

            viewButton.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    onViewButtonClicked();
                    return;
                }
            });


            downloadButton.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    onSaveButtonClicked();
                    return;
                }
            });
            downloadButton.setOnLongClickListener(new OnLongClickListener() {

                @Override
                public boolean onLongClick(View v) {
                    callback.showFileBrowser(AttachmentView.this);
                    return true;
                }
            });

            attachmentName.setText(name);
            attachmentInfo.setText(SizeFormatter.formatSize(mContext, size));
            Bitmap previewIcon = getPreviewIcon();
            if (previewIcon != null) {
                attachmentIcon.setImageBitmap(previewIcon);
            } else {
                attachmentIcon.setImageResource(R.drawable.attached_image_placeholder);
            }
        }

        catch (Exception e) {
            Log.e(K9.LOG_TAG, ""error "", e);
        }

        return true;
    }

    private Bitmap getPreviewIcon() {
        try {
            return BitmapFactory.decodeStream(
                       mContext.getContentResolver().openInputStream(
                           AttachmentProvider.getAttachmentThumbnailUri(mAccount,
                                   part.getAttachmentId(),
                                   62,
                                   62)));
        } catch (Exception e) {
            /*
             * We don't care what happened, we just return null for the preview icon.
             */
            return null;
        }
    }

    private void onViewButtonClicked() {
        if (mMessage != null) {
            mController.loadAttachment(mAccount, mMessage, part, new Object[] { false, this }, mListener);
        }
    }


    private void onSaveButtonClicked() {
        saveFile();
    }

    /**
     * Writes the attachment onto the given path
     * @param directory: the base dir where the file should be saved.
     */
    public void writeFile(File directory) {
        try {
            File file = Utility.createUniqueFile(directory, name);
            Uri uri = AttachmentProvider.getAttachmentUri(mAccount, part.getAttachmentId());
            InputStream in = mContext.getContentResolver().openInputStream(uri);
            OutputStream out = new FileOutputStream(file);
            IOUtils.copy(in, out);
            out.flush();
            out.close();
            in.close();
            attachmentSaved(file.toString());
            new MediaScannerNotifier(mContext, file);
        } catch (IOException ioe) {
            attachmentNotSaved();
        }
    }
    /**
     * saves the file to the defaultpath setting in the config, or if the config
     * is not set => to the Environment
     */
    public void writeFile() {
        writeFile(new File(K9.getAttachmentDefaultPath()));
    }

    public void saveFile() {
        //TODO: Can the user save attachments on the internal filesystem or sd card only?
        if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
            /*
             * Abort early if there's no place to save the attachment. We don't want to spend
             * the time downloading it and then abort.
             */
            Toast.makeText(mContext,
                           mContext.getString(R.string.message_view_status_attachment_not_saved),
                           Toast.LENGTH_SHORT).show();
            return;
        }
        if (mMessage != null) {
            mController.loadAttachment(mAccount, mMessage, part, new Object[] {true, this}, mListener);
        }
    }


    public void showFile() {
        Uri uri = AttachmentProvider.getAttachmentUriForViewing(mAccount, part.getAttachmentId());
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setData(uri);
        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
        try {
            mContext.startActivity(intent);
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Could not display attachment of type "" + contentType, e);
            Toast toast = Toast.makeText(mContext, mContext.getString(R.string.message_view_no_viewer, contentType), Toast.LENGTH_LONG);
            toast.show();
        }
    }

    /**
     * Check the {@link PackageManager} if the phone has an application
     * installed to view this type of attachment.
     * If not, {@link #viewButton} is disabled.
     * This should be done in any place where
     * attachment.viewButton.setEnabled(enabled); is called.
     * This method is safe to be called from the UI-thread.
     */
    public void checkViewable() {
        if (viewButton.getVisibility() == View.GONE) {
            // nothing to do
            return;
        }
        if (!viewButton.isEnabled()) {
            // nothing to do
            return;
        }
        try {
            Uri uri = AttachmentProvider.getAttachmentUriForViewing(mAccount, part.getAttachmentId());
            Intent intent = new Intent(Intent.ACTION_VIEW);
            intent.setData(uri);
            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
            if (intent.resolveActivity(mContext.getPackageManager()) == null) {
                viewButton.setEnabled(false);
            }
            // currently we do not cache re result.
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Cannot resolve activity to determine if we shall show the 'view'-button for an attachment"", e);
        }
    }

    public void attachmentSaved(final String filename) {
        Toast.makeText(mContext, String.format(
                           mContext.getString(R.string.message_view_status_attachment_saved), filename),
                       Toast.LENGTH_LONG).show();
    }

    public void attachmentNotSaved() {
        Toast.makeText(mContext,
                       mContext.getString(R.string.message_view_status_attachment_not_saved),
                       Toast.LENGTH_LONG).show();
    }
    public AttachmentFileDownloadCallback getCallback() {
        return callback;
    }
    public void setCallback(AttachmentFileDownloadCallback callback) {
        this.callback = callback;
    }

}
",True,144,0,0,6,50,2,13,L1
18,com.fsck.k9.view.SingleMessageView.java,"package com.fsck.k9.view;

import android.app.Activity;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ResolveInfo;
import android.database.Cursor;
import android.net.Uri;
import android.util.AttributeSet;
import android.util.Log;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.Button;
import android.widget.LinearLayout;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.R;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.crypto.CryptoProvider;
import com.fsck.k9.crypto.PgpData;
import com.fsck.k9.helper.Contacts;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.store.LocalStore;

import java.util.List;


/**
 */
public class SingleMessageView extends LinearLayout {
    private boolean mScreenReaderEnabled;
    private MessageCryptoView mCryptoView;
    private MessageWebView mMessageContentView;
    private AccessibleWebView mAccessibleMessageContentView;
    private MessageHeader mHeaderContainer;
    private LinearLayout        mAttachments;
    private View mShowPicturesSection;
    private boolean mShowPictures;
    private Button mDownloadRemainder;
    private LayoutInflater mInflater;
    private Contacts mContacts;
    private AttachmentView.AttachmentFileDownloadCallback attachmentCallback;

    public void initialize(Activity activity) {
        mMessageContentView = (MessageWebView) findViewById(R.id.message_content);
        mAccessibleMessageContentView = (AccessibleWebView) findViewById(R.id.accessible_message_content);
        mAttachments = (LinearLayout) findViewById(R.id.attachments);
        mHeaderContainer = (MessageHeader) findViewById(R.id.header_container);
        mCryptoView = (MessageCryptoView) findViewById(R.id.layout_decrypt);
        mCryptoView.setActivity(activity);
        mCryptoView.setupChildViews();
        mShowPicturesSection = findViewById(R.id.show_pictures_section);
        mShowPictures = false;

        mContacts = Contacts.getInstance(activity);

        mInflater = activity.getLayoutInflater();
        mDownloadRemainder = (Button) findViewById(R.id.download_remainder);
        mMessageContentView.configure();


        mAttachments.setVisibility(View.GONE);
        if (isScreenReaderActive(activity)) {
            mAccessibleMessageContentView.setVisibility(View.VISIBLE);
            mMessageContentView.setVisibility(View.GONE);
            mScreenReaderEnabled = true;
        } else {
            mAccessibleMessageContentView.setVisibility(View.GONE);
            mMessageContentView.setVisibility(View.VISIBLE);
            mScreenReaderEnabled = false;
        }

    }

    public SingleMessageView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }


    private boolean isScreenReaderActive(Activity activity) {
        final String SCREENREADER_INTENT_ACTION = ""android.accessibilityservice.AccessibilityService"";
        final String SCREENREADER_INTENT_CATEGORY = ""android.accessibilityservice.category.FEEDBACK_SPOKEN"";
        // Restrict the set of intents to only accessibility services that have
        // the category FEEDBACK_SPOKEN (aka, screen readers).
        Intent screenReaderIntent = new Intent(SCREENREADER_INTENT_ACTION);
        screenReaderIntent.addCategory(SCREENREADER_INTENT_CATEGORY);
        List<ResolveInfo> screenReaders = activity.getPackageManager().queryIntentServices(
                                              screenReaderIntent, 0);
        ContentResolver cr = activity.getContentResolver();
        Cursor cursor = null;
        int status = 0;
        for (ResolveInfo screenReader : screenReaders) {
            // All screen readers are expected to implement a content provider
            // that responds to
            // content://<nameofpackage>.providers.StatusProvider
            cursor = cr.query(Uri.parse(""content://"" + screenReader.serviceInfo.packageName
                                        + "".providers.StatusProvider""), null, null, null, null);
            if (cursor != null) {
                cursor.moveToFirst();
                // These content providers use a special cursor that only has
                // one element,
                // an integer that is 1 if the screen reader is running.
                status = cursor.getInt(0);
                cursor.close();
                if (status == 1) {
                    return true;
                }
            }
        }
        return false;
    }



    public boolean showPictures() {
        return mShowPictures;
    }
    public void setShowPictures(Boolean show) {
        mShowPictures = show;
    }

    /**
     * Enable/disable image loading of the WebView. But always hide the
     * ""Show pictures"" button!
     *
     * @param enable true, if (network) images should be loaded.
     *               false, otherwise.
     */
    public void setLoadPictures(boolean enable) {
        mMessageContentView.blockNetworkData(!enable);
        setShowPictures(enable);
        showShowPicturesSection(false);
    }

    public Button downloadRemainderButton() {
        return  mDownloadRemainder;
    }

    public void showShowPicturesSection(boolean show) {
        mShowPicturesSection.setVisibility(show ? View.VISIBLE : View.GONE);
    }

    public void setHeaders(final Message message, Account account) {
        try {
            mHeaderContainer.populate(message, account);


        } catch (Exception me) {
            Log.e(K9.LOG_TAG, ""setHeaders - error"", me);
        }
    }

    public void setShowDownloadButton(Message message) {
        if (message.isSet(Flag.X_DOWNLOADED_FULL)) {
            mDownloadRemainder.setVisibility(View.GONE);
        } else {
            mDownloadRemainder.setEnabled(true);
            mDownloadRemainder.setVisibility(View.VISIBLE);
        }
    }

    public void setOnFlagListener(OnClickListener listener) {
        mHeaderContainer.setOnFlagListener(listener);
    }

    public void showAllHeaders() {
        mHeaderContainer.onShowAdditionalHeaders();
    }

    public boolean additionalHeadersVisible() {
        return mHeaderContainer.additionalHeadersVisible();
    }

    public void displayMessageBody(Account account, String folder, String uid, Message message, PgpData pgpData) throws MessagingException {
        // TODO - really this code  path? this is an odd place to put it
        removeAllAttachments();

        String type;
        String text = pgpData.getDecryptedData();
        if (text != null) {
            type = ""text/plain"";
        } else {
            // getTextForDisplay() always returns HTML-ified content.
            text = ((LocalStore.LocalMessage) message).getTextForDisplay();
            type = ""text/html"";
        }
        if (text != null) {
            final String emailText = text;
            final String contentType = type;
            loadBodyFromText(account.getCryptoProvider(), pgpData, message, emailText, contentType);
            // If the message contains external pictures and the ""Show pictures""
            // button wasn't already pressed, see if the user's preferences has us
            // showing them anyway.
            if (Utility.hasExternalImages(text) && !showPictures()) {
                if ((account.getShowPictures() == Account.ShowPictures.ALWAYS) ||
                        ((account.getShowPictures() == Account.ShowPictures.ONLY_FROM_CONTACTS) &&
                         mContacts.isInContacts(message.getFrom()[0].getAddress()))) {
                    setLoadPictures(true);
                } else {
                    showShowPicturesSection(true);
                }
            }
        } else {
            loadBodyFromUrl(""file:///android_asset/empty.html"");
        }
    }

    public void loadBodyFromUrl(String url) {
        mMessageContentView.loadUrl(url);
        mCryptoView.hide();

    }

    public void loadBodyFromText(CryptoProvider cryptoProvider, PgpData pgpData, Message message, String emailText, String contentType) {
        if (mScreenReaderEnabled) {
            mAccessibleMessageContentView.loadDataWithBaseURL(""http://"", emailText, contentType, ""utf-8"", null);
        } else {
            mMessageContentView.loadDataWithBaseURL(""http://"", emailText, contentType, ""utf-8"", null);
            mMessageContentView.scrollTo(0, 0);
        }
        updateCryptoLayout(cryptoProvider, pgpData, message);

    }

    public void updateCryptoLayout(CryptoProvider cp, PgpData pgpData, Message message) {
        mCryptoView.updateLayout(cp, pgpData, message);
    }

    public void setAttachmentsEnabled(boolean enabled) {
        for (int i = 0, count = mAttachments.getChildCount(); i < count; i++) {
            AttachmentView attachment = (AttachmentView) mAttachments.getChildAt(i);
            attachment.viewButton.setEnabled(enabled);
            attachment.downloadButton.setEnabled(enabled);
        }
    }


    public void removeAllAttachments() {
        for (int i = 0, count = mAttachments.getChildCount(); i < count; i++) {
            mAttachments.removeView(mAttachments.getChildAt(i));
        }
    }

    public void renderAttachments(Part part, int depth,

                                  Message message, Account account, MessagingController controller, MessagingListener listener) throws MessagingException {

        if (part.getBody() instanceof Multipart) {
            Multipart mp = (Multipart) part.getBody();
            for (int i = 0; i < mp.getCount(); i++) {
                renderAttachments(mp.getBodyPart(i), depth + 1, message, account, controller, listener);
            }
        } else if (part instanceof LocalStore.LocalAttachmentBodyPart) {
            String contentDisposition = MimeUtility.unfoldAndDecode(part.getDisposition());
            // Inline parts with a content-id are almost certainly components of an HTML message
            // not attachments. Don't show attachment download buttons for them.
            if (contentDisposition != null &&
                    MimeUtility.getHeaderParameter(contentDisposition, null).matches(""^(?i:inline)"")
                    && part.getHeader(""Content-ID"") != null) {
                return;
            }
            AttachmentView view = (AttachmentView)mInflater.inflate(R.layout.message_view_attachment, null);
            view.setCallback(attachmentCallback);
            if (view.populateFromPart(part, message, account, controller, listener)) {
                addAttachment(view);
            }
        }
    }


    public void addAttachment(View attachmentView) {
        mAttachments.addView(attachmentView);
        mAttachments.setVisibility(View.VISIBLE);
    }
    public void zoom(KeyEvent event) {
        if (mScreenReaderEnabled) {
            mAccessibleMessageContentView.zoomIn();
        } else {
            if (event.isShiftPressed()) {
                mMessageContentView.zoomIn();
            } else {
                mMessageContentView.zoomOut();
            }
        }
    }
    public void beginSelectingText() {
        mMessageContentView.emulateShiftHeld();
    }


    public void resetView() {
        setLoadPictures(false);
        mMessageContentView.scrollTo(0, 0);
        mHeaderContainer.setVisibility(View.GONE);
        mMessageContentView.clearView();
        mAttachments.removeAllViews();
    }

    public AttachmentView.AttachmentFileDownloadCallback getAttachmentCallback() {
        return attachmentCallback;
    }

    public void setAttachmentCallback(
        AttachmentView.AttachmentFileDownloadCallback attachmentCallback) {
        this.attachmentCallback = attachmentCallback;
    }

}
",True,144,0,0,5,52,1,21,L1
19,com.fsck.k9.view.ColorPickerBox.java,"/* Sourced from http://code.google.com/p/android-color-picker/source/browse/trunk/AmbilWarna/src/yuku/ambilwarna/AmbilWarnaBox.java?r=1
 * On 2010-11-07
 * Translated to English, Ported to use the same (inferior) API as the more standard ""ColorPickerDialog"" and imported into the K-9 namespace by Jesse Vincent
 * In an ideal world, we should move to using AmbilWarna as an Android Library Project in the future
 * License: Apache 2.0
 * Author: yukuku@code.google.com
 */



package com.fsck.k9.view;
import com.fsck.k9.R;
import android.content.*;
import android.graphics.*;
import android.graphics.Shader.*;
import android.util.*;
import android.view.*;

public class ColorPickerBox extends View {

    Paint paint;
    Shader dalam;
    Shader luar;
    float hue;
    float onedp;
    float sizeUiDp = 240.f;
    float sizeUiPx; // diset di constructor
    float[] tmp00 = new float[3];

    public ColorPickerBox(Context context) {
        this(context, null);
    }

    public ColorPickerBox(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public ColorPickerBox(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);

        onedp = context.getResources().getDimension(R.dimen.colorpicker_onedp);
        sizeUiPx = sizeUiDp * onedp;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (paint == null) {
            paint = new Paint();
            luar = new LinearGradient(0.f, 0.f, 0.f, sizeUiPx, 0xffffffff, 0xff000000, TileMode.CLAMP);
        }

        tmp00[1] = tmp00[2] = 1.f;
        tmp00[0] = hue;
        int rgb = Color.HSVToColor(tmp00);

        dalam = new LinearGradient(0.f, 0.f, sizeUiPx, 0.f, 0xffffffff, rgb, TileMode.CLAMP);
        ComposeShader shader = new ComposeShader(luar, dalam, PorterDuff.Mode.MULTIPLY);

        paint.setShader(shader);

        canvas.drawRect(0.f, 0.f, sizeUiPx, sizeUiPx, paint);
    }

    public void setHue(float hue) {
        this.hue = hue;
        invalidate();
    }
}
",False,114,8,60,0,0,1,0,L1
20,com.fsck.k9.view.ColorChip.java,"package com.fsck.k9.view;

import android.graphics.Path;
import android.graphics.drawable.ShapeDrawable;
import android.graphics.drawable.shapes.PathShape;

public class ColorChip {
    private static final Path CHIP_PATH = new Path();

    static {

        CHIP_PATH.lineTo(6, 0);

        CHIP_PATH.cubicTo(8f, 0f, 10f, 0f, 10f, 2f);
        CHIP_PATH.lineTo(10, 8);
        CHIP_PATH.cubicTo(10f, 9f, 10f, 10f, 6f, 10f);
        CHIP_PATH.lineTo(0, 10);
        CHIP_PATH.close();
    }


    private ShapeDrawable mDrawable;

    public ColorChip(int color) {

        mDrawable = new ShapeDrawable(new PathShape(CHIP_PATH, 10, 10));
        mDrawable.getPaint().setColor(color);


    }

    public ShapeDrawable drawable() {

        return mDrawable;
    }


}
",False,113,5,49,0,0,5,0,L1
21,com.fsck.k9.view.MessageHeader.java,"package com.fsck.k9.view;

import android.content.Context;
import android.graphics.Typeface;
import android.text.SpannableString;
import android.text.SpannableStringBuilder;
import android.text.style.StyleSpan;
import android.util.Log;
import android.util.AttributeSet;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;
import com.fsck.k9.FontSizes;
import com.fsck.k9.K9;
import com.fsck.k9.R;
import com.fsck.k9.helper.Contacts;
import com.fsck.k9.Account;
import com.fsck.k9.helper.DateFormatter;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.store.LocalStore;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.text.DateFormat;

public class MessageHeader extends LinearLayout {
    private Context mContext;
    private TextView mFromView;
    private TextView mDateView;
    private TextView mTimeView;
    private TextView mToView;
    private TextView mCcView;
    private TextView mSubjectView;
    private DateFormat mDateFormat;
    private DateFormat mTimeFormat;

    private View mChip;
    private CheckBox mFlagged;
    private int defaultSubjectColor;
    private LinearLayout mToContainerView;
    private LinearLayout mCcContainerView;
    private TextView mAdditionalHeadersView;
    private View mAttachmentIcon;
    private View mAnsweredIcon;
    private Message mMessage;
    private Account mAccount;
    private FontSizes mFontSizes = K9.getFontSizes();
    private Contacts mContacts;

    /**
     * Pair class is only available since API Level 5, so we need
     * this helper class unfortunately
     */
    private static class HeaderEntry {
        public String label;
        public String value;

        public HeaderEntry(String label, String value) {
            this.label = label;
            this.value = value;
        }
    }

    public MessageHeader(Context context, AttributeSet attrs) {
        super(context, attrs);
        mContext = context;
        mDateFormat = DateFormatter.getDateFormat(mContext);
        mTimeFormat = android.text.format.DateFormat.getTimeFormat(mContext);   // 12/24 date format
        mContacts = Contacts.getInstance(mContext);
    }

    private void initializeLayout() {
        mAttachmentIcon = findViewById(R.id.attachment);
        mAnsweredIcon = findViewById(R.id.answered);
        mFromView = (TextView) findViewById(R.id.from);
        mToView = (TextView) findViewById(R.id.to);
        mCcView = (TextView) findViewById(R.id.cc);
        mToContainerView = (LinearLayout) findViewById(R.id.to_container);
        mCcContainerView = (LinearLayout) findViewById(R.id.cc_container);
        mSubjectView = (TextView) findViewById(R.id.subject);
        mAdditionalHeadersView = (TextView) findViewById(R.id.additional_headers_view);
        mChip = findViewById(R.id.chip);
        mDateView = (TextView) findViewById(R.id.date);
        mTimeView = (TextView) findViewById(R.id.time);
        mFlagged = (CheckBox) findViewById(R.id.flagged);

        defaultSubjectColor = mSubjectView.getCurrentTextColor();
        mSubjectView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewSubject());
        mTimeView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewTime());
        mDateView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewDate());
        mAdditionalHeadersView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewAdditionalHeaders());
        mAdditionalHeadersView.setVisibility(View.GONE);
        mAttachmentIcon.setVisibility(View.GONE);
        mAnsweredIcon.setVisibility(View.GONE);
        mFromView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewSender());
        mToView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewTo());
        mCcView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewCC());
        ((TextView) findViewById(R.id.to_label)).setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewTo());
        ((TextView) findViewById(R.id.cc_label)).setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewCC());

        setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                onShowAdditionalHeaders();
                return;
            }
        });

        mFromView.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                if (mMessage != null) {
                    try {
                        final Address senderEmail = mMessage.getFrom()[0];
                        mContacts.createContact(senderEmail);
                    } catch (Exception e) {
                        Log.e(K9.LOG_TAG, ""Couldn't create contact"", e);
                    }
                }
            }
        });
    }

    public void setOnFlagListener(OnClickListener listener) {
        mFlagged.setOnClickListener(listener);
    }


    public boolean additionalHeadersVisible() {
        if (mAdditionalHeadersView != null && mAdditionalHeadersView.getVisibility() == View.VISIBLE) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Clear the text field for the additional headers display if they are
     * not shown, to save UI resources.
     */
    private void hideAdditionalHeaders() {
        mAdditionalHeadersView.setVisibility(View.GONE);
        mAdditionalHeadersView.setText("""");

    }


    /**
     * Set up and then show the additional headers view. Called by
     * {@link #onShowAdditionalHeaders()}
     * (when switching between messages).
     */
    private void showAdditionalHeaders() {
        Integer messageToShow = null;
        try {
            // Retrieve additional headers
            boolean allHeadersDownloaded = mMessage.isSet(Flag.X_GOT_ALL_HEADERS);
            List<HeaderEntry> additionalHeaders = getAdditionalHeaders(mMessage);
            if (!additionalHeaders.isEmpty()) {
                // Show the additional headers that we have got.
                populateAdditionalHeadersView(additionalHeaders);
                mAdditionalHeadersView.setVisibility(View.VISIBLE);
            }
            if (!allHeadersDownloaded) {
                /*
                * Tell the user about the ""save all headers"" setting
                *
                * NOTE: This is only a temporary solution... in fact,
                * the system should download headers on-demand when they
                * have not been saved in their entirety initially.
                */
                messageToShow = R.string.message_additional_headers_not_downloaded;
            } else if (additionalHeaders.isEmpty()) {
                // All headers have been downloaded, but there are no additional headers.
                messageToShow = R.string.message_no_additional_headers_available;
            }
        } catch (MessagingException e) {
            messageToShow = R.string.message_additional_headers_retrieval_failed;
        }
        // Show a message to the user, if any
        if (messageToShow != null) {
            Toast toast = Toast.makeText(mContext, messageToShow, Toast.LENGTH_LONG);
            toast.setGravity(Gravity.CENTER_VERTICAL | Gravity.CENTER_HORIZONTAL, 0, 0);
            toast.show();
        }

    }

    public void populate(final Message message, final Account account) throws MessagingException {
        final Contacts contacts = K9.showContactName() ? mContacts : null;
        final CharSequence from = Address.toFriendly(message.getFrom(), contacts);
        final String date = mDateFormat.format(message.getSentDate());
        final String time = mTimeFormat.format(message.getSentDate());
        final CharSequence to = Address.toFriendly(message.getRecipients(Message.RecipientType.TO), contacts);
        final CharSequence cc = Address.toFriendly(message.getRecipients(Message.RecipientType.CC), contacts);

        mMessage = message;
        mAccount = account;

        initializeLayout();
        String subject = message.getSubject();
        if (subject == null || subject.equals("""")) {
            mSubjectView.setText(mContext.getText(R.string.general_no_subject));
        } else {
            mSubjectView.setText(subject);
        }
        mSubjectView.setTextColor(0xff000000 | defaultSubjectColor);

        mFromView.setText(from);

        if (date != null) {
            mDateView.setText(date);
            mDateView.setVisibility(View.VISIBLE);
        } else {
            mDateView.setVisibility(View.GONE);
        }
        mTimeView.setText(time);
        mToContainerView.setVisibility((to != null && to.length() > 0) ? View.VISIBLE : View.GONE);
        mToView.setText(to);
        mCcContainerView.setVisibility((cc != null && cc.length() > 0) ? View.VISIBLE : View.GONE);
        mCcView.setText(cc);
        mAttachmentIcon.setVisibility(((LocalStore.LocalMessage) message).hasAttachments() ? View.VISIBLE : View.GONE);
        mAnsweredIcon.setVisibility(message.isSet(Flag.ANSWERED) ? View.VISIBLE : View.GONE);
        mFlagged.setChecked(message.isSet(Flag.FLAGGED));
        mChip.setBackgroundDrawable(mAccount.generateColorChip().drawable());
        mChip.getBackground().setAlpha(!message.isSet(Flag.SEEN) ? 255 : 127);
        setVisibility(View.VISIBLE);
        if (mAdditionalHeadersView.getVisibility() == View.VISIBLE) {
            showAdditionalHeaders();
        }
    }

    public void onShowAdditionalHeaders() {
        int currentVisibility = mAdditionalHeadersView.getVisibility();
        if (currentVisibility == View.VISIBLE) {
            hideAdditionalHeaders();
        } else {
            showAdditionalHeaders();
        }
    }

    private List<HeaderEntry> getAdditionalHeaders(final Message message)
    throws MessagingException {
        List<HeaderEntry> additionalHeaders = new LinkedList<HeaderEntry>();
        /*
        * Remove ""Subject"" header as it is already shown in the standard
        * message view header. But do show ""From"", ""To"", and ""Cc"" again.
        * This time including the email addresses. See issue 1805.
        */
        Set<String> headerNames = new HashSet<String>(message.getHeaderNames());
        headerNames.remove(""Subject"");
        for (String headerName : headerNames) {
            String[] headerValues = message.getHeader(headerName);
            for (String headerValue : headerValues) {
                additionalHeaders.add(new HeaderEntry(headerName, headerValue));
            }
        }
        return additionalHeaders;
    }

    /**
     * Set up the additional headers text view with the supplied header data.
     *
     * @param additionalHeaders List of header entries. Each entry consists of a header
     *                          name and a header value. Header names may appear multiple
     *                          times.
     *                          <p/>
     *                          This method is always called from within the UI thread by
     *                          {@link #showAdditionalHeaders()}.
     */
    private void populateAdditionalHeadersView(final List<HeaderEntry> additionalHeaders) {
        SpannableStringBuilder sb = new SpannableStringBuilder();
        boolean first = true;
        for (HeaderEntry additionalHeader : additionalHeaders) {
            if (!first) {
                sb.append(""\n"");
            } else {
                first = false;
            }
            StyleSpan boldSpan = new StyleSpan(Typeface.BOLD);
            SpannableString label = new SpannableString(additionalHeader.label + "": "");
            label.setSpan(boldSpan, 0, label.length(), 0);
            sb.append(label);
            sb.append(MimeUtility.unfoldAndDecode(additionalHeader.value));
        }
        mAdditionalHeadersView.setText(sb);
    }

}
",True,144,0,0,6,41,1,12,L1
22,com.fsck.k9.crypto.None.java,"package com.fsck.k9.crypto;

import android.app.Activity;
import android.content.Context;

import com.fsck.k9.mail.Message;

/**
 * Dummy CryptoProvider for when cryptography is disabled. It is never ""available"" and doesn't
 * do anything.
 */
public class None extends CryptoProvider {
    static final long serialVersionUID = 0x21071230;
    public static final String NAME = """";

    public static None createInstance() {
        return new None();
    }

    @Override
    public boolean isAvailable(Context context) {
        return false;
    }

    @Override
    public boolean selectSecretKey(Activity activity, PgpData pgpData) {
        return false;
    }

    @Override
    public boolean selectEncryptionKeys(Activity activity, String emails, PgpData pgpData) {
        return false;
    }

    @Override
    public long[] getSecretKeyIdsFromEmail(Context context, String email) {
        return null;
    }

    @Override
    public String getUserId(Context context, long keyId) {
        return null;
    }

    @Override
    public boolean onActivityResult(Activity activity, int requestCode, int resultCode,
                                    android.content.Intent data, PgpData pgpData) {
        return false;
    }

    @Override
    public boolean encrypt(Activity activity, String data, PgpData pgpData) {
        return false;
    }

    @Override
    public boolean decrypt(Activity activity, String data, PgpData pgpData) {
        return false;
    }

    @Override
    public boolean isEncrypted(Message message) {
        return false;
    }

    @Override
    public boolean isSigned(Message message) {
        return false;
    }

    @Override
    public String getName() {
        return NAME;
    }

    @Override
    public boolean test(Context context) {
        return true;
    }
}
",False,144,0,0,7,47,1,3,L1
23,com.fsck.k9.crypto.CryptoProvider.java,"package com.fsck.k9.crypto;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;

import com.fsck.k9.mail.Message;

/**
 * A CryptoProvider provides functionalities such as encryption, decryption, digital signatures.
 * It currently also stores the results of such encryption or decryption.
 * TODO: separate the storage from the provider
 */
abstract public class CryptoProvider {
    static final long serialVersionUID = 0x21071234;

    abstract public boolean isAvailable(Context context);
    abstract public boolean isEncrypted(Message message);
    abstract public boolean isSigned(Message message);
    abstract public boolean onActivityResult(Activity activity, int requestCode, int resultCode,
            Intent data, PgpData pgpData);
    abstract public boolean selectSecretKey(Activity activity, PgpData pgpData);
    abstract public boolean selectEncryptionKeys(Activity activity, String emails, PgpData pgpData);
    abstract public boolean encrypt(Activity activity, String data, PgpData pgpData);
    abstract public boolean decrypt(Activity activity, String data, PgpData pgpData);
    abstract public long[] getSecretKeyIdsFromEmail(Context context, String email);
    abstract public String getUserId(Context context, long keyId);
    abstract public String getName();
    abstract public boolean test(Context context);

    public static CryptoProvider createInstance(String name) {
        if (Apg.NAME.equals(name)) {
            return Apg.createInstance();
        }

        return None.createInstance();
    }
}
",False,144,0,0,6,44,8,4,L1
24,com.fsck.k9.crypto.PgpData.java,"package com.fsck.k9.crypto;

import java.io.Serializable;

public class PgpData implements Serializable {
    private static final long serialVersionUID = 6314045536470848410L;
    protected long mEncryptionKeyIds[] = null;
    protected long mSignatureKeyId = 0;
    protected String mSignatureUserId = null;
    protected boolean mSignatureSuccess = false;
    protected boolean mSignatureUnknown = false;
    protected String mDecryptedData = null;
    protected String mEncryptedData = null;

    public void setSignatureKeyId(long keyId) {
        mSignatureKeyId = keyId;
    }

    public long getSignatureKeyId() {
        return mSignatureKeyId;
    }

    public void setEncryptionKeys(long keyIds[]) {
        mEncryptionKeyIds = keyIds;
    }

    public long[] getEncryptionKeys() {
        return mEncryptionKeyIds;
    }

    public boolean hasSignatureKey() {
        return mSignatureKeyId != 0;
    }

    public boolean hasEncryptionKeys() {
        return (mEncryptionKeyIds != null) && (mEncryptionKeyIds.length > 0);
    }

    public String getEncryptedData() {
        return mEncryptedData;
    }

    public void setEncryptedData(String data) {
        mEncryptedData = data;
    }

    public String getDecryptedData() {
        return mDecryptedData;
    }

    public void setDecryptedData(String data) {
        mDecryptedData = data;
    }

    public void setSignatureUserId(String userId) {
        mSignatureUserId = userId;
    }

    public String getSignatureUserId() {
        return mSignatureUserId;
    }

    public boolean getSignatureSuccess() {
        return mSignatureSuccess;
    }

    public void setSignatureSuccess(boolean success) {
        mSignatureSuccess = success;
    }

    public boolean getSignatureUnknown() {
        return mSignatureUnknown;
    }

    public void setSignatureUnknown(boolean unknown) {
        mSignatureUnknown = unknown;
    }
}
",False,113,5,79,0,0,7,0,L1
25,com.fsck.k9.crypto.Apg.java,"package com.fsck.k9.crypto;

import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ContentUris;
import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.database.Cursor;
import android.net.Uri;
import android.widget.Toast;

import com.fsck.k9.R;
import com.fsck.k9.activity.MessageCompose;
import com.fsck.k9.activity.MessageView;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Part;
import com.fsck.k9.mail.internet.MimeUtility;

/**
 * APG integration.
 */
public class Apg extends CryptoProvider {
    static final long serialVersionUID = 0x21071235;
    public static final String NAME = ""apg"";

    private static final String mApgPackageName = ""org.thialfihar.android.apg"";
    private static final int mMinRequiredVersion = 16;

    public static final String AUTHORITY = ""org.thialfihar.android.apg.provider"";
    public static final Uri CONTENT_URI_SECRET_KEY_RING_BY_KEY_ID =
        Uri.parse(""content://"" + AUTHORITY + ""/key_rings/secret/key_id/"");
    public static final Uri CONTENT_URI_SECRET_KEY_RING_BY_EMAILS =
        Uri.parse(""content://"" + AUTHORITY + ""/key_rings/secret/emails/"");

    public static final Uri CONTENT_URI_PUBLIC_KEY_RING_BY_KEY_ID =
        Uri.parse(""content://"" + AUTHORITY + ""/key_rings/public/key_id/"");
    public static final Uri CONTENT_URI_PUBLIC_KEY_RING_BY_EMAILS =
        Uri.parse(""content://"" + AUTHORITY + ""/key_rings/public/emails/"");

    public static class Intent {
        public static final String DECRYPT = ""org.thialfihar.android.apg.intent.DECRYPT"";
        public static final String ENCRYPT = ""org.thialfihar.android.apg.intent.ENCRYPT"";
        public static final String DECRYPT_FILE = ""org.thialfihar.android.apg.intent.DECRYPT_FILE"";
        public static final String ENCRYPT_FILE = ""org.thialfihar.android.apg.intent.ENCRYPT_FILE"";
        public static final String DECRYPT_AND_RETURN = ""org.thialfihar.android.apg.intent.DECRYPT_AND_RETURN"";
        public static final String ENCRYPT_AND_RETURN = ""org.thialfihar.android.apg.intent.ENCRYPT_AND_RETURN"";
        public static final String SELECT_PUBLIC_KEYS = ""org.thialfihar.android.apg.intent.SELECT_PUBLIC_KEYS"";
        public static final String SELECT_SECRET_KEY = ""org.thialfihar.android.apg.intent.SELECT_SECRET_KEY"";
    }

    public static final String EXTRA_TEXT = ""text"";
    public static final String EXTRA_DATA = ""data"";
    public static final String EXTRA_ERROR = ""error"";
    public static final String EXTRA_DECRYPTED_MESSAGE = ""decryptedMessage"";
    public static final String EXTRA_ENCRYPTED_MESSAGE = ""encryptedMessage"";
    public static final String EXTRA_SIGNATURE = ""signature"";
    public static final String EXTRA_SIGNATURE_KEY_ID = ""signatureKeyId"";
    public static final String EXTRA_SIGNATURE_USER_ID = ""signatureUserId"";
    public static final String EXTRA_SIGNATURE_SUCCESS = ""signatureSuccess"";
    public static final String EXTRA_SIGNATURE_UNKNOWN = ""signatureUnknown"";
    public static final String EXTRA_USER_ID = ""userId"";
    public static final String EXTRA_KEY_ID = ""keyId"";
    public static final String EXTRA_ENCRYPTION_KEY_IDS = ""encryptionKeyIds"";
    public static final String EXTRA_SELECTION = ""selection"";
    public static final String EXTRA_MESSAGE = ""message"";
    public static final String EXTRA_INTENT_VERSION = ""intentVersion"";

    public static final String INTENT_VERSION = ""1"";

    public static final int DECRYPT_MESSAGE = 0x21070001;
    public static final int ENCRYPT_MESSAGE = 0x21070002;
    public static final int SELECT_PUBLIC_KEYS = 0x21070003;
    public static final int SELECT_SECRET_KEY = 0x21070004;

    public static Pattern PGP_MESSAGE =
        Pattern.compile("".*?(-----BEGIN PGP MESSAGE-----.*?-----END PGP MESSAGE-----).*"",
                        Pattern.DOTALL);

    public static Pattern PGP_SIGNED_MESSAGE =
        Pattern.compile("".*?(-----BEGIN PGP SIGNED MESSAGE-----.*?-----BEGIN PGP SIGNATURE-----.*?-----END PGP SIGNATURE-----).*"",
                        Pattern.DOTALL);

    public static Apg createInstance() {
        return new Apg();
    }

    /**
     * Check whether APG is installed and at a high enough version.
     *
     * @param context
     * @return whether a suitable version of APG was found
     */
    @Override
    public boolean isAvailable(Context context) {
        try {
            PackageInfo pi = context.getPackageManager().getPackageInfo(mApgPackageName, 0);
            if (pi.versionCode >= mMinRequiredVersion) {
                return true;
            } else {
                Toast.makeText(context,
                               R.string.error_apg_version_not_supported, Toast.LENGTH_SHORT).show();
            }
        } catch (NameNotFoundException e) {
            // not found
        }

        return false;
    }

    /**
     * Select the signature key.
     *
     * @param activity
     * @param pgpData
     * @return success or failure
     */
    @Override
    public boolean selectSecretKey(Activity activity, PgpData pgpData) {
        android.content.Intent intent = new android.content.Intent(Intent.SELECT_SECRET_KEY);
        intent.putExtra(EXTRA_INTENT_VERSION, INTENT_VERSION);
        try {
            activity.startActivityForResult(intent, Apg.SELECT_SECRET_KEY);
            return true;
        } catch (ActivityNotFoundException e) {
            Toast.makeText(activity,
                           R.string.error_activity_not_found,
                           Toast.LENGTH_SHORT).show();
            return false;
        }
    }

    /**
     * Select encryption keys.
     *
     * @param activity
     * @param emails The emails that should be used for preselection.
     * @param pgpData
     * @return success or failure
     */
    @Override
    public boolean selectEncryptionKeys(Activity activity, String emails, PgpData pgpData) {
        android.content.Intent intent = new android.content.Intent(Apg.Intent.SELECT_PUBLIC_KEYS);
        intent.putExtra(EXTRA_INTENT_VERSION, INTENT_VERSION);
        long[] initialKeyIds = null;
        if (!pgpData.hasEncryptionKeys()) {
            Vector<Long> keyIds = new Vector<Long>();
            if (pgpData.hasSignatureKey()) {
                keyIds.add(pgpData.getSignatureKeyId());
            }

            try {
                Uri contentUri = Uri.withAppendedPath(
                                     Apg.CONTENT_URI_PUBLIC_KEY_RING_BY_EMAILS,
                                     emails);
                Cursor c = activity.getContentResolver().query(contentUri,
                           new String[] { ""master_key_id"" },
                           null, null, null);
                if (c != null) {
                    while (c.moveToNext()) {
                        keyIds.add(c.getLong(0));
                    }
                }

                if (c != null) {
                    c.close();
                }
            } catch (SecurityException e) {
                Toast.makeText(activity,
                               activity.getResources().getString(R.string.insufficient_apg_permissions),
                               Toast.LENGTH_LONG).show();
            }
            if (keyIds.size() > 0) {
                initialKeyIds = new long[keyIds.size()];
                for (int i = 0, size = keyIds.size(); i < size; ++i) {
                    initialKeyIds[i] = keyIds.get(i);
                }
            }
        } else {
            initialKeyIds = pgpData.getEncryptionKeys();
        }
        intent.putExtra(Apg.EXTRA_SELECTION, initialKeyIds);
        try {
            activity.startActivityForResult(intent, Apg.SELECT_PUBLIC_KEYS);
            return true;
        } catch (ActivityNotFoundException e) {
            Toast.makeText(activity,
                           R.string.error_activity_not_found,
                           Toast.LENGTH_SHORT).show();
            return false;
        }
    }

    /**
     * Get secret key ids based on a given email.
     *
     * @param context
     * @param email The email in question.
     * @return key ids
     */
    @Override
    public long[] getSecretKeyIdsFromEmail(Context context, String email) {
        long ids[] = null;
        try {
            Uri contentUri = Uri.withAppendedPath(Apg.CONTENT_URI_SECRET_KEY_RING_BY_EMAILS,
                                                  email);
            Cursor c = context.getContentResolver().query(contentUri,
                       new String[] { ""master_key_id"" },
                       null, null, null);
            if (c != null && c.getCount() > 0) {
                ids = new long[c.getCount()];
                while (c.moveToNext()) {
                    ids[c.getPosition()] = c.getLong(0);
                }
            }

            if (c != null) {
                c.close();
            }
        } catch (SecurityException e) {
            Toast.makeText(context,
                           context.getResources().getString(R.string.insufficient_apg_permissions),
                           Toast.LENGTH_LONG).show();
        }

        return ids;
    }

    /**
     * Get the user id based on the key id.
     *
     * @param context
     * @param keyId
     * @return user id
     */
    @Override
    public String getUserId(Context context, long keyId) {
        String userId = null;
        try {
            Uri contentUri = ContentUris.withAppendedId(
                                 Apg.CONTENT_URI_SECRET_KEY_RING_BY_KEY_ID,
                                 keyId);
            Cursor c = context.getContentResolver().query(contentUri,
                       new String[] { ""user_id"" },
                       null, null, null);
            if (c != null && c.moveToFirst()) {
                userId = c.getString(0);
            }

            if (c != null) {
                c.close();
            }
        } catch (SecurityException e) {
            Toast.makeText(context,
                           context.getResources().getString(R.string.insufficient_apg_permissions),
                           Toast.LENGTH_LONG).show();
        }

        if (userId == null) {
            userId = context.getString(R.string.unknown_crypto_signature_user_id);
        }
        return userId;
    }

    /**
     * Handle the activity results that concern us.
     *
     * @param activity
     * @param requestCode
     * @param resultCode
     * @param data
     * @return handled or not
     */
    @Override
    public boolean onActivityResult(Activity activity, int requestCode, int resultCode,
                                    android.content.Intent data, PgpData pgpData) {
        switch (requestCode) {
        case Apg.SELECT_SECRET_KEY:
            if (resultCode != Activity.RESULT_OK || data == null) {
                break;
            }
            pgpData.setSignatureKeyId(data.getLongExtra(Apg.EXTRA_KEY_ID, 0));
            pgpData.setSignatureUserId(data.getStringExtra(Apg.EXTRA_USER_ID));
            ((MessageCompose) activity).updateEncryptLayout();
            break;

        case Apg.SELECT_PUBLIC_KEYS:
            if (resultCode != Activity.RESULT_OK || data == null) {
                pgpData.setEncryptionKeys(null);
                ((MessageCompose) activity).onEncryptionKeySelectionDone();
                break;
            }
            pgpData.setEncryptionKeys(data.getLongArrayExtra(Apg.EXTRA_SELECTION));
            ((MessageCompose) activity).onEncryptionKeySelectionDone();
            break;

        case Apg.ENCRYPT_MESSAGE:
            if (resultCode != Activity.RESULT_OK || data == null) {
                pgpData.setEncryptionKeys(null);
                ((MessageCompose) activity).onEncryptDone();
                break;
            }
            pgpData.setEncryptedData(data.getStringExtra(Apg.EXTRA_ENCRYPTED_MESSAGE));
            // this was a stupid bug in an earlier version, just gonna leave this in for an APG
            // version or two
            if (pgpData.getEncryptedData() == null) {
                pgpData.setEncryptedData(data.getStringExtra(Apg.EXTRA_DECRYPTED_MESSAGE));
            }
            if (pgpData.getEncryptedData() != null) {
                ((MessageCompose) activity).onEncryptDone();
            }
            break;

        case Apg.DECRYPT_MESSAGE:
            if (resultCode != Activity.RESULT_OK || data == null) {
                break;
            }

            pgpData.setSignatureUserId(data.getStringExtra(Apg.EXTRA_SIGNATURE_USER_ID));
            pgpData.setSignatureKeyId(data.getLongExtra(Apg.EXTRA_SIGNATURE_KEY_ID, 0));
            pgpData.setSignatureSuccess(data.getBooleanExtra(Apg.EXTRA_SIGNATURE_SUCCESS, false));
            pgpData.setSignatureUnknown(data.getBooleanExtra(Apg.EXTRA_SIGNATURE_UNKNOWN, false));

            pgpData.setDecryptedData(data.getStringExtra(Apg.EXTRA_DECRYPTED_MESSAGE));
            ((MessageView) activity).onDecryptDone(pgpData);

            break;

        default:
            return false;
        }

        return true;
    }

    /**
     * Start the encrypt activity.
     *
     * @param activity
     * @param data
     * @param pgpData
     * @return success or failure
     */
    @Override
    public boolean encrypt(Activity activity, String data, PgpData pgpData) {
        android.content.Intent intent = new android.content.Intent(Intent.ENCRYPT_AND_RETURN);
        intent.putExtra(EXTRA_INTENT_VERSION, INTENT_VERSION);
        intent.setType(""text/plain"");
        intent.putExtra(Apg.EXTRA_TEXT, data);
        intent.putExtra(Apg.EXTRA_ENCRYPTION_KEY_IDS, pgpData.getEncryptionKeys());
        intent.putExtra(Apg.EXTRA_SIGNATURE_KEY_ID, pgpData.getSignatureKeyId());
        try {
            activity.startActivityForResult(intent, Apg.ENCRYPT_MESSAGE);
            return true;
        } catch (ActivityNotFoundException e) {
            Toast.makeText(activity,
                           R.string.error_activity_not_found,
                           Toast.LENGTH_SHORT).show();
            return false;
        }
    }

    /**
     * Start the decrypt activity.
     *
     * @param activity
     * @param data
     * @param pgpData
     * @return success or failure
     */
    @Override
    public boolean decrypt(Activity activity, String data, PgpData pgpData) {
        android.content.Intent intent = new android.content.Intent(Apg.Intent.DECRYPT_AND_RETURN);
        intent.putExtra(EXTRA_INTENT_VERSION, INTENT_VERSION);
        intent.setType(""text/plain"");
        if (data == null) {
            return false;
        }
        try {
            intent.putExtra(EXTRA_TEXT, data);
            activity.startActivityForResult(intent, Apg.DECRYPT_MESSAGE);
            return true;
        } catch (ActivityNotFoundException e) {
            Toast.makeText(activity, R.string.error_activity_not_found, Toast.LENGTH_SHORT).show();
            return false;
        }
    }

    @Override
    public boolean isEncrypted(Message message) {
        String data = null;
        try {
            Part part = MimeUtility.findFirstPartByMimeType(message, ""text/plain"");
            if (part == null) {
                part = MimeUtility.findFirstPartByMimeType(message, ""text/html"");
            }
            if (part != null) {
                data = MimeUtility.getTextFromPart(part);
            }
        } catch (MessagingException e) {
            // guess not...
            // TODO: maybe log this?
        }

        if (data == null) {
            return false;
        }

        Matcher matcher = PGP_MESSAGE.matcher(data);
        return matcher.matches();
    }

    @Override
    public boolean isSigned(Message message) {
        String data = null;
        try {
            Part part = MimeUtility.findFirstPartByMimeType(message, ""text/plain"");
            if (part == null) {
                part = MimeUtility.findFirstPartByMimeType(message, ""text/html"");
            }
            if (part != null) {
                data = MimeUtility.getTextFromPart(part);
            }
        } catch (MessagingException e) {
            // guess not...
            // TODO: maybe log this?
        }

        if (data == null) {
            return false;
        }

        Matcher matcher = PGP_SIGNED_MESSAGE.matcher(data);
        return matcher.matches();
    }

    /**
     * Get the name of the provider.
     *
     * @return provider name
     */
    @Override
    public String getName() {
        return NAME;
    }

    /**
     * Test the APG installation.
     *
     * @return success or failure
     */
    @Override
    public boolean test(Context context) {
        if (!isAvailable(context)) {
            return false;
        }

        try {
            // try out one content provider to check permissions
            Uri contentUri = ContentUris.withAppendedId(
                                 Apg.CONTENT_URI_SECRET_KEY_RING_BY_KEY_ID,
                                 12345);
            Cursor c = context.getContentResolver().query(contentUri,
                       new String[] { ""user_id"" },
                       null, null, null);
            if (c != null) {
                c.close();
            }
        } catch (SecurityException e) {
            // if there was a problem, then let the user know, this will not stop K9/APG from
            // working, but some features won't be available, so we can still return ""true""
            Toast.makeText(context,
                           context.getResources().getString(R.string.insufficient_apg_permissions),
                           Toast.LENGTH_LONG).show();
        }

        return true;
    }
}
",True,144,0,0,6,45,3,8,L1
26,com.fsck.k9.helper.Utility.java,"
package com.fsck.k9.helper;

import android.text.Editable;
import android.util.Log;
import android.widget.EditText;
import android.widget.TextView;

import com.fsck.k9.K9;
import com.fsck.k9.mail.filter.Base64;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Utility {

    // \u00A0 (non-breaking space) happens to be used by French MUA

    // Note: no longer using the ^ beginning character combined with (...)+
    // repetition matching as we might want to strip ML tags. Ex:
    // Re: [foo] Re: RE : [foo] blah blah blah
    private static final Pattern RESPONSE_PATTERN = Pattern.compile(
                ""((Re|Fw|Fwd|Aw|R\\u00E9f\\.)(\\[\\d+\\])?[\\u00A0 ]?: *)+"", Pattern.CASE_INSENSITIVE);

    /**
     * Mailing-list tag pattern to match strings like ""[foobar] ""
     */
    private static final Pattern TAG_PATTERN = Pattern.compile(""\\[[-_a-z0-9]+\\] "",
            Pattern.CASE_INSENSITIVE);

    public static String readInputStream(InputStream in, String encoding) throws IOException {
        InputStreamReader reader = new InputStreamReader(in, encoding);
        StringBuffer sb = new StringBuffer();
        int count;
        char[] buf = new char[512];
        while ((count = reader.read(buf)) != -1) {
            sb.append(buf, 0, count);
        }
        return sb.toString();
    }

    public static boolean arrayContains(Object[] a, Object o) {
        for (Object element : a) {
            if (element.equals(o)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Combines the given array of Objects into a single String using
     * each Object's toString() method and the separator character
     * between each part.
     *
     * @param parts
     * @param separator
     * @return new String
     */
    public static String combine(Object[] parts, char separator) {
        if (parts == null) {
            return null;
        } else if (parts.length == 0) {
            return """";
        }
        StringBuilder sb = new StringBuilder();
        sb.append(parts[0]);
        for (int i = 1; i < parts.length; ++i) {
            sb.append(separator);
            sb.append(parts[i]);
        }
        return sb.toString();
    }

    public static String base64Decode(String encoded) {
        if (encoded == null) {
            return null;
        }
        byte[] decoded = new Base64().decode(encoded.getBytes());
        return new String(decoded);
    }

    public static String base64Encode(String s) {
        if (s == null) {
            return s;
        }
        byte[] encoded = new Base64().encode(s.getBytes());
        return new String(encoded);
    }

    public static boolean requiredFieldValid(TextView view) {
        return view.getText() != null && view.getText().length() > 0;
    }


    public static boolean requiredFieldValid(Editable s) {
        return s != null && s.length() > 0;
    }

    public static boolean domainFieldValid(EditText view) {
        if (view.getText() != null) {
            String s = view.getText().toString();
            if (s.matches(""^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}$"")) {
                return true;
            }
            if (s.matches(""^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"")) {
                return true;
            }
            if ((s.equalsIgnoreCase(""localhost"")) || (s.equalsIgnoreCase(""localhost.localdomain""))) {
                return true;
            }
        }
        return false;
    }

    private static final Pattern ATOM = Pattern.compile(""^(?:[a-zA-Z0-9!#$%&'*+\\-/=?^_`{|}~]|\\s)+$"");

    /**
     * Quote a string, if necessary, based upon the definition of an ""atom,"" as defined by RFC2822
     * (http://tools.ietf.org/html/rfc2822#section-3.2.4). Strings that consist purely of atoms are
     * left unquoted; anything else is returned as a quoted string.
     * @param text String to quote.
     * @return Possibly quoted string.
     */
    public static String quoteAtoms(final String text) {
        if (ATOM.matcher(text).matches()) {
            return text;
        } else {
            return quoteString(text);
        }
    }

    /**
     * Ensures that the given string starts and ends with the double quote character. The string is not modified in any way except to add the
     * double quote character to start and end if it's not already there.
     * sample -> ""sample""
     * ""sample"" -> ""sample""
     * """"sample"""" -> ""sample""
     * ""sample"""" -> ""sample""
     * sa""mp""le -> ""sa""mp""le""
     * ""sa""mp""le"" -> ""sa""mp""le""
     * (empty string) -> """"
     * "" -> """"
     * @param s
     * @return
     */
    public static String quoteString(String s) {
        if (s == null) {
            return null;
        }
        if (!s.matches(""^\"".*\""$"")) {
            return ""\"""" + s + ""\"""";
        } else {
            return s;
        }
    }

    /**
     * A fast version of  URLDecoder.decode() that works only with UTF-8 and does only two
     * allocations. This version is around 3x as fast as the standard one and I'm using it
     * hundreds of times in places that slow down the UI, so it helps.
     */
    public static String fastUrlDecode(String s) {
        try {
            byte[] bytes = s.getBytes(""UTF-8"");
            byte ch;
            int length = 0;
            for (int i = 0, count = bytes.length; i < count; i++) {
                ch = bytes[i];
                if (ch == '%') {
                    int h = (bytes[i + 1] - '0');
                    int l = (bytes[i + 2] - '0');
                    if (h > 9) {
                        h -= 7;
                    }
                    if (l > 9) {
                        l -= 7;
                    }
                    bytes[length] = (byte)((h << 4) | l);
                    i += 2;
                } else if (ch == '+') {
                    bytes[length] = ' ';
                } else {
                    bytes[length] = bytes[i];
                }
                length++;
            }
            return new String(bytes, 0, length, ""UTF-8"");
        } catch (UnsupportedEncodingException uee) {
            return null;
        }
    }

    /**
     * Returns true if the specified date is within 18 hours of ""now"". Returns false otherwise.
     * @param date
     * @return
     */
    public static boolean isDateToday(Date date) {
        Date now = new Date();
        if (now.getTime() - 64800000 > date.getTime() || now.getTime() + 64800000 < date.getTime()) {
            return false;
        } else {
            return true;
        }
    }

    /*
     * TODO disabled this method globally. It is used in all the settings screens but I just
     * noticed that an unrelated icon was dimmed. Android must share drawables internally.
     */
    public static void setCompoundDrawablesAlpha(TextView view, int alpha) {
//        Drawable[] drawables = view.getCompoundDrawables();
//        for (Drawable drawable : drawables) {
//            if (drawable != null) {
//                drawable.setAlpha(alpha);
//            }
//        }
    }

    /**
     * <p>Wraps a multiline string of text, identifying words by <code>' '</code>.</p>
     *
     * <p>New lines will be separated by the system property line separator.
     * Very long words, such as URLs will <i>not</i> be wrapped.</p>
     *
     * <p>Leading spaces on a new line are stripped.
     * Trailing spaces are not stripped.</p>
     *
     * <pre>
     * WordUtils.wrap(null, *) = null
     * WordUtils.wrap("""", *) = """"
     * </pre>
     *
     * Adapted from the Apache Commons Lang library.
     * http://svn.apache.org/viewvc/commons/proper/lang
     *   /trunk/src/main/java/org/apache/commons/lang3/text/WordUtils.java
     * SVN Revision 925967, Mon Mar 22 06:16:49 2010 UTC
     *
     * Licensed to the Apache Software Foundation (ASF) under one or more
     * contributor license agreements.  See the NOTICE file distributed with
     * this work for additional information regarding copyright ownership.
     * The ASF licenses this file to You under the Apache License, Version 2.0
     * (the ""License""); you may not use this file except in compliance with
     * the License.  You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an ""AS IS"" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * @param str  the String to be word wrapped, may be null
     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1
     * @return a line with newlines inserted, <code>null</code> if null input
     */
    private static final String NEWLINE_REGEX = ""(?:\\r?\\n)"";
    public static String wrap(String str, int wrapLength) {
        StringBuilder result = new StringBuilder();
        for (String piece : str.split(NEWLINE_REGEX)) {
            result.append(wrap(piece, wrapLength, null, false));
            result.append(""\n"");
        }
        return result.toString();
    }

    /**
     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>
     *
     * <p>Leading spaces on a new line are stripped.
     * Trailing spaces are not stripped.</p>
     *
     * <pre>
     * WordUtils.wrap(null, *, *, *) = null
     * WordUtils.wrap("""", *, *, *) = """"
     * </pre>
     *
     * This is from the Apache Commons Lang library.
     * http://svn.apache.org/viewvc/commons/proper/lang
     *   /trunk/src/main/java/org/apache/commons/lang3/text/WordUtils.java
     * SVN Revision 925967, Mon Mar 22 06:16:49 2010 UTC
     *
     * Licensed to the Apache Software Foundation (ASF) under one or more
     * contributor license agreements.  See the NOTICE file distributed with
     * this work for additional information regarding copyright ownership.
     * The ASF licenses this file to You under the Apache License, Version 2.0
     * (the ""License""); you may not use this file except in compliance with
     * the License.  You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an ""AS IS"" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * @param str  the String to be word wrapped, may be null
     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1
     * @param newLineStr  the string to insert for a new line,
     *  <code>null</code> uses the system property line separator
     * @param wrapLongWords  true if long words (such as URLs) should be wrapped
     * @return a line with newlines inserted, <code>null</code> if null input
     */
    public static String wrap(String str, int wrapLength, String newLineStr, boolean wrapLongWords) {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = ""\n"";
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);

        while ((inputLineLength - offset) > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);

            if (spaceToWrapAt >= offset) {
                // normal case
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                // really long word or URL
                if (wrapLongWords) {
                    // wrap really long word one line at a time
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    // do not wrap really long word, just extend beyond limit
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }

        // Whatever is left in line is short enough to just pass through
        wrappedLine.append(str.substring(offset));

        return wrappedLine.toString();
    }

    /**
     * Extract the 'original' subject value, by ignoring leading
     * response/forward marker and '[XX]' formatted tags (as many mailing-list
     * softwares do).
     *
     * <p>
     * Result is also trimmed.
     * </p>
     *
     * @param subject
     *            Never <code>null</code>.
     * @return Never <code>null</code>.
     */
    public static String stripSubject(final String subject) {
        int lastPrefix = 0;

        final Matcher tagMatcher = TAG_PATTERN.matcher(subject);
        String tag = null;
        // whether tag stripping logic should be active
        boolean tagPresent = false;
        // whether the last action stripped a tag
        boolean tagStripped = false;
        if (tagMatcher.find(0)) {
            tagPresent = true;
            if (tagMatcher.start() == 0) {
                // found at beginning of subject, considering it an actual tag
                tag = tagMatcher.group();

                // now need to find response marker after that tag
                lastPrefix = tagMatcher.end();
                tagStripped = true;
            }
        }

        final Matcher matcher = RESPONSE_PATTERN.matcher(subject);

        // while:
        // - lastPrefix is within the bounds
        // - response marker found at lastPrefix position
        // (to make sure we don't catch response markers that are part of
        // the actual subject)

        while (lastPrefix < subject.length() - 1
                && matcher.find(lastPrefix)
                && matcher.start() == lastPrefix
                && (!tagPresent || tag == null || subject.regionMatches(matcher.end(), tag, 0,
                        tag.length()))) {
            lastPrefix = matcher.end();

            if (tagPresent) {
                tagStripped = false;
                if (tag == null) {
                    // attempt to find tag
                    if (tagMatcher.start() == lastPrefix) {
                        tag = tagMatcher.group();
                        lastPrefix += tag.length();
                        tagStripped = true;
                    }
                } else if (lastPrefix < subject.length() - 1 && subject.startsWith(tag, lastPrefix)) {
                    // Re: [foo] Re: [foo] blah blah blah
                    //               ^     ^
                    //               ^     ^
                    //               ^    new position
                    //               ^
                    //              initial position
                    lastPrefix += tag.length();
                    tagStripped = true;
                }
            }
        }
        // Null pointer check is to make the static analysis component of Eclipse happy.
        if (tagStripped && (tag != null)) {
            // restore the last tag
            lastPrefix -= tag.length();
        }
        if (lastPrefix > -1 && lastPrefix < subject.length() - 1) {
            return subject.substring(lastPrefix).trim();
        } else {
            return subject.trim();
        }
    }

    /**
     * @param parentDir
     * @param name
     *            Never <code>null</code>.
     */
    public static void touchFile(final File parentDir, final String name) {
        final File file = new File(parentDir, name);
        try {
            if (!file.exists()) {
                file.createNewFile();
            } else {
                file.setLastModified(System.currentTimeMillis());
            }
        } catch (Exception e) {
            Log.d(K9.LOG_TAG, ""Unable to touch file: "" + file.getAbsolutePath(), e);
        }
    }

    /**
     * Creates a unique file in the given directory by appending a hyphen
     * and a number to the given filename.
     *
     * @param directory
     * @param filename
     * @return
     */
    public static File createUniqueFile(File directory, String filename) {
        File file = new File(directory, filename);
        if (!file.exists()) {
            return file;
        }
        // Get the extension of the file, if any.
        int index = filename.lastIndexOf('.');
        String format;
        if (index != -1) {
            String name = filename.substring(0, index);
            String extension = filename.substring(index);
            format = name + ""-%d"" + extension;
        } else {
            format = filename + ""-%d"";
        }
        for (int i = 2; i < Integer.MAX_VALUE; i++) {
            file = new File(directory, String.format(format, i));
            if (!file.exists()) {
                return file;
            }
        }
        return null;
    }



    /**
     * @param from
     * @param to
     * @return
     */
    public static boolean move(final File from, final File to) {
        if (to.exists()) {
            to.delete();
        }
        to.getParentFile().mkdirs();

        try {
            FileInputStream in = new FileInputStream(from);
            FileOutputStream out = new FileOutputStream(to);
            byte[] buffer = new byte[1024];
            int count = -1;
            while ((count = in.read(buffer)) > 0) {
                out.write(buffer, 0, count);
            }
            out.close();
            in.close();
            from.delete();
            return true;
        } catch (Exception e) {
            Log.w(K9.LOG_TAG, ""cannot move "" + from.getAbsolutePath() + "" to "" + to.getAbsolutePath(), e);
            return false;
        }

    }

    /**
     * @param fromDir
     * @param toDir
     */
    public static void moveRecursive(final File fromDir, final File toDir) {
        if (!fromDir.exists()) {
            return;
        }
        if (!fromDir.isDirectory()) {
            if (toDir.exists()) {
                if (!toDir.delete()) {
                    Log.w(K9.LOG_TAG, ""cannot delete already existing file/directory "" + toDir.getAbsolutePath());
                }
            }
            if (!fromDir.renameTo(toDir)) {
                Log.w(K9.LOG_TAG, ""cannot rename "" + fromDir.getAbsolutePath() + "" to "" + toDir.getAbsolutePath() + "" - moving instead"");
                move(fromDir, toDir);
            }
            return;
        }
        if (!toDir.exists() || !toDir.isDirectory()) {
            if (toDir.exists()) {
                toDir.delete();
            }
            if (!toDir.mkdirs()) {
                Log.w(K9.LOG_TAG, ""cannot create directory "" + toDir.getAbsolutePath());
            }
        }
        File[] files = fromDir.listFiles();
        for (File file : files) {
            if (file.isDirectory()) {
                moveRecursive(file, new File(toDir, file.getName()));
                file.delete();
            } else {
                File target = new File(toDir, file.getName());
                if (!file.renameTo(target)) {
                    Log.w(K9.LOG_TAG, ""cannot rename "" + file.getAbsolutePath() + "" to "" + target.getAbsolutePath() + "" - moving instead"");
                    move(file, target);
                }
            }
        }
        if (!fromDir.delete()) {
            Log.w(K9.LOG_TAG, ""cannot delete "" + fromDir.getAbsolutePath());
        }
    }

    private static final String IMG_SRC_REGEX = ""(?is:<img[^>]+src\\s*=\\s*['\""]?([a-z]+)\\:)"";
    private static final Pattern IMG_PATTERN = Pattern.compile(IMG_SRC_REGEX);
    /**
     * Figure out if this part has images.
     * TODO: should only return true if we're an html part
     * @param message Content to evaluate
     * @return True if it has external images; false otherwise.
     */
    public static boolean hasExternalImages(final String message) {
        Matcher imgMatches = IMG_PATTERN.matcher(message);
        while (imgMatches.find()) {
            if (!imgMatches.group(1).equals(""content"")) {
                if (K9.DEBUG) {
                    Log.d(K9.LOG_TAG, ""External images found"");
                }
                return true;
            }
        }
        if (K9.DEBUG) {
            Log.d(K9.LOG_TAG, ""No external images."");
        }
        return false;
    }
}
",True,145,1,1,7,54,21,2,L1
27,com.fsck.k9.helper.DomainNameChecker.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.helper;

import android.net.http.SslCertificate;
import android.util.Log;
import com.fsck.k9.K9;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.security.cert.X509Certificate;
import java.security.cert.CertificateParsingException;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

/**
 * Implements basic domain-name validation as specified by RFC2818.
 */
public class DomainNameChecker {
    private static Pattern QUICK_IP_PATTERN;
    static {
        try {
            QUICK_IP_PATTERN = Pattern.compile(""^[a-f0-9\\.:]+$"");
        } catch (PatternSyntaxException e) {
        }
    }

    private static final int ALT_DNS_NAME = 2;
    private static final int ALT_IPA_NAME = 7;

    /**
     * Checks the site certificate against the domain name of the site being
     * visited
     *
     * @param certificate
     *            The certificate to check
     * @param thisDomain
     *            The domain name of the site being visited
     * @return True iff if there is a domain match as specified by RFC2818
     */
    public static boolean match(X509Certificate certificate, String thisDomain) {
        if ((certificate == null) || (thisDomain == null)
                || (thisDomain.length() == 0)) {
            return false;
        }

        thisDomain = thisDomain.toLowerCase();
        if (!isIpAddress(thisDomain)) {
            return matchDns(certificate, thisDomain);
        } else {
            return matchIpAddress(certificate, thisDomain);
        }
    }

    /**
     * @return True iff the domain name is specified as an IP address
     */
    private static boolean isIpAddress(String domain) {
        if ((domain == null) || (domain.length() == 0)) {
            return false;
        }

        boolean rval;
        try {
            // do a quick-dirty IP match first to avoid DNS lookup
            rval = QUICK_IP_PATTERN.matcher(domain).matches();
            if (rval) {
                rval = domain.equals(InetAddress.getByName(domain)
                                     .getHostAddress());
            }
        } catch (UnknownHostException e) {
            String errorMessage = e.getMessage();
            if (errorMessage == null) {
                errorMessage = ""unknown host exception"";
            }

            if (K9.DEBUG) {
                Log.v(K9.LOG_TAG, ""DomainNameChecker.isIpAddress(): ""
                      + errorMessage);
            }

            rval = false;
        }

        return rval;
    }

    /**
     * Checks the site certificate against the IP domain name of the site being
     * visited
     *
     * @param certificate
     *            The certificate to check
     * @param thisDomain
     *            The DNS domain name of the site being visited
     * @return True iff if there is a domain match as specified by RFC2818
     */
    private static boolean matchIpAddress(X509Certificate certificate, String thisDomain) {
        if (K9.DEBUG) {
            Log.v(K9.LOG_TAG, ""DomainNameChecker.matchIpAddress(): this domain: "" + thisDomain);
        }

        try {
            Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
            if (subjectAltNames != null) {
                for (Object subjectAltName : subjectAltNames) {
                    List<?> altNameEntry = (List<?>)(subjectAltName);
                    if ((altNameEntry != null) && (2 <= altNameEntry.size())) {
                        Integer altNameType = (Integer)(altNameEntry.get(0));
                        if (altNameType != null) {
                            if (altNameType == ALT_IPA_NAME) {
                                String altName = (String)(altNameEntry.get(1));
                                if (altName != null) {
                                    if (K9.DEBUG) {
                                        Log.v(K9.LOG_TAG, ""alternative IP: "" + altName);
                                    }
                                    if (thisDomain.equalsIgnoreCase(altName)) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } catch (CertificateParsingException e) {
        }

        return false;
    }

    /**
     * Checks the site certificate against the DNS domain name of the site being
     * visited
     *
     * @param certificate
     *            The certificate to check
     * @param thisDomain
     *            The DNS domain name of the site being visited
     * @return True iff if there is a domain match as specified by RFC2818
     */
    private static boolean matchDns(X509Certificate certificate, String thisDomain) {
        boolean hasDns = false;
        try {
            Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
            if (subjectAltNames != null) {
                Iterator<?> i = subjectAltNames.iterator();
                while (i.hasNext()) {
                    List<?> altNameEntry = (List<?>)(i.next());
                    if ((altNameEntry != null) && (2 <= altNameEntry.size())) {
                        Integer altNameType = (Integer)(altNameEntry.get(0));
                        if (altNameType != null) {
                            if (altNameType.intValue() == ALT_DNS_NAME) {
                                hasDns = true;
                                String altName = (String)(altNameEntry.get(1));
                                if (altName != null) {
                                    if (matchDns(thisDomain, altName)) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } catch (CertificateParsingException e) {
            // one way we can get here is if an alternative name starts with
            // '*' character, which is contrary to one interpretation of the
            // spec (a valid DNS name must start with a letter); there is no
            // good way around this, and in order to be compatible we proceed
            // to check the common name (ie, ignore alternative names)
            if (K9.DEBUG) {
                String errorMessage = e.getMessage();
                if (errorMessage == null) {
                    errorMessage = ""failed to parse certificate"";
                }

                Log.v(K9.LOG_TAG, ""DomainNameChecker.matchDns(): ""
                      + errorMessage);
            }
        }

        if (!hasDns) {
            SslCertificate sslCertificate = new SslCertificate(certificate);
            return matchDns(thisDomain, sslCertificate.getIssuedTo().getCName());
        }

        return false;
    }

    /**
     * @param thisDomain
     *            The domain name of the site being visited
     * @param thatDomain
     *            The domain name from the certificate
     * @return True iff thisDomain matches thatDomain as specified by RFC2818
     */
    private static boolean matchDns(String thisDomain, String thatDomain) {
        if (K9.DEBUG) {
            Log.v(K9.LOG_TAG, ""DomainNameChecker.matchDns():""
                  + "" this domain: "" + thisDomain + "" that domain: ""
                  + thatDomain);
        }

        if ((thisDomain == null) || (thisDomain.length() == 0)
                || (thatDomain == null) || (thatDomain.length() == 0)) {
            return false;
        }

        thatDomain = thatDomain.toLowerCase();

        // (a) domain name strings are equal, ignoring case: X matches X
        boolean rval = thisDomain.equals(thatDomain);
        if (!rval) {
            String[] thisDomainTokens = thisDomain.split(""\\."");
            String[] thatDomainTokens = thatDomain.split(""\\."");

            int thisDomainTokensNum = thisDomainTokens.length;
            int thatDomainTokensNum = thatDomainTokens.length;

            // (b) OR thatHost is a '.'-suffix of thisHost: Z.Y.X matches X
            if (thisDomainTokensNum >= thatDomainTokensNum) {
                for (int i = thatDomainTokensNum - 1; i >= 0; --i) {
                    rval = thisDomainTokens[i].equals(thatDomainTokens[i]);
                    if (!rval) {
                        // (c) OR we have a special *-match:
                        // Z.Y.X matches *.Y.X but does not match *.X
                        rval = ((i == 0) && (thisDomainTokensNum == thatDomainTokensNum));
                        if (rval) {
                            rval = thatDomainTokens[0].equals(""*"");
                            if (!rval) {
                                // (d) OR we have a *-component match:
                                // f*.com matches foo.com but not bar.com
                                rval = domainTokenMatch(thisDomainTokens[0],
                                                        thatDomainTokens[0]);
                            }
                        }

                        break;
                    }
                }
            }
        }

        return rval;
    }

    /**
     * @param thisDomainToken
     *            The domain token from the current domain name
     * @param thatDomainToken
     *            The domain token from the certificate
     * @return True iff thisDomainToken matches thatDomainToken, using the
     *         wildcard match as specified by RFC2818-3.1. For example, f*.com
     *         must match foo.com but not bar.com
     */
    private static boolean domainTokenMatch(String thisDomainToken, String thatDomainToken) {
        if ((thisDomainToken != null) && (thatDomainToken != null)) {
            int starIndex = thatDomainToken.indexOf('*');
            if (starIndex >= 0) {
                if (thatDomainToken.length() - 1 <= thisDomainToken.length()) {
                    String prefix = thatDomainToken.substring(0, starIndex);
                    String suffix = thatDomainToken.substring(starIndex + 1);

                    return thisDomainToken.startsWith(prefix)
                           && thisDomainToken.endsWith(suffix);
                }
            }
        }

        return false;
    }
}
",True,144,0,0,7,55,1,1,L1
28,com.fsck.k9.helper.SizeFormatter.java,"package com.fsck.k9.helper;

import android.content.Context;
import com.fsck.k9.R;

public class SizeFormatter {
    /*
     * Formats the given size as a String in bytes, kB, MB or GB with a single digit
     * of precision. Ex: 12,315,000 = 12.3 MB
     */
    public static String formatSize(Context context, long size) {
        if (size > 1024000000) {
            return ((float)(size / 102400000) / 10) + context.getString(R.string.abbrev_gigabytes);
        }
        if (size > 1024000) {
            return ((float)(size / 102400) / 10) + context.getString(R.string.abbrev_megabytes);
        }
        if (size > 1024) {
            return ((float)(size / 102) / 10) + context.getString(R.string.abbrev_kilobytes);
        }
        return size + context.getString(R.string.abbrev_bytes);
    }

}


",False,113,6,61,0,0,3,0,L1
29,com.fsck.k9.helper.MessageHelper.java,"package com.fsck.k9.helper;

import java.text.DateFormat;
import java.util.Date;

import android.content.Context;
import android.text.SpannableStringBuilder;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.R;
import com.fsck.k9.activity.FolderInfoHolder;
import com.fsck.k9.activity.MessageInfoHolder;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.store.LocalStore.LocalMessage;
import com.fsck.k9.helper.DateFormatter;

public class MessageHelper {

    private static MessageHelper sInstance;

    public synchronized static MessageHelper getInstance(final Context context) {
        if (sInstance == null) {
            sInstance = new MessageHelper(context);
        }
        return sInstance;
    }

    private Context mContext;

    private DateFormat mTodayDateFormat;

    private DateFormat mDateFormat;

    private MessageHelper(final Context context) {
        mContext = context;
        mDateFormat = DateFormatter.getDateFormat(mContext);
        mTodayDateFormat = android.text.format.DateFormat.getTimeFormat(mContext);
    }

    public void populate(final MessageInfoHolder target, final Message m,
                         final FolderInfoHolder folder, final Account account) {
        final Contacts contactHelper = K9.showContactName() ? Contacts.getInstance(mContext) : null;
        try {
            LocalMessage message = (LocalMessage) m;
            target.message = message;
            target.compareDate = message.getSentDate();
            if (target.compareDate == null) {
                target.compareDate = message.getInternalDate();
            }

            target.folder = folder;

            target.read = message.isSet(Flag.SEEN);
            target.answered = message.isSet(Flag.ANSWERED);
            target.flagged = message.isSet(Flag.FLAGGED);
            target.downloaded = message.isSet(Flag.X_DOWNLOADED_FULL);
            target.partially_downloaded = message.isSet(Flag.X_DOWNLOADED_PARTIAL);

            Address[] addrs = message.getFrom();

            if (addrs.length > 0 &&  account.isAnIdentity(addrs[0])) {
                CharSequence to = Address.toFriendly(message .getRecipients(RecipientType.TO), contactHelper);
                target.compareCounterparty = to.toString();
                target.sender = new SpannableStringBuilder(mContext.getString(R.string.message_to_label)).append(to);
            } else {
                target.sender = Address.toFriendly(addrs, contactHelper);
                target.compareCounterparty = target.sender.toString();
            }

            if (addrs.length > 0) {
                target.senderAddress = addrs[0].getAddress();
            } else {
                // a reasonable fallback ""whomever we were corresponding with
                target.senderAddress = target.compareCounterparty;
            }




            target.uid = message.getUid();

            target.account = account.getDescription();
            target.uri = ""email://messages/"" + account.getAccountNumber() + ""/"" + m.getFolder().getName() + ""/"" + m.getUid();

        } catch (MessagingException me) {
            Log.w(K9.LOG_TAG, ""Unable to load message info"", me);
        }
    }
    public String formatDate(Date date) {
        if (Utility.isDateToday(date)) {
            return mTodayDateFormat.format(date);
        } else {
            return mDateFormat.format(date);
        }
    }

    public void refresh() {
        mDateFormat = DateFormatter.getDateFormat(mContext);
        mTodayDateFormat = android.text.format.DateFormat.getTimeFormat(mContext);
    }
}
",True,145,1,1,6,40,3,14,L1
30,com.fsck.k9.helper.ContactsSdk5.java,"package com.fsck.k9.helper;

import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.util.Log;
import android.provider.ContactsContract;
import android.provider.ContactsContract.Contacts;
import android.provider.ContactsContract.Intents;
import android.provider.ContactsContract.CommonDataKinds.Email;
import com.fsck.k9.mail.Address;
import com.fsck.k9.K9;

/**
 * Access the contacts on the device using the API introduced with SDK 5.
 *
 * @see android.provider.ContactsContract
 */
public class ContactsSdk5 extends com.fsck.k9.helper.Contacts {
    /**
     * The order in which the search results are returned by
     * {@link #searchContacts(CharSequence)}.
     */
    protected static final String SORT_ORDER =
        Email.TIMES_CONTACTED + "" DESC, "" +
        Contacts.DISPLAY_NAME + "", "" +
        Email._ID;

    /**
     * Array of columns to load from the database.
     *
     * Important: The _ID field is needed by
     * {@link com.fsck.k9.EmailAddressAdapter} or more specificly by
     * {@link android.widget.ResourceCursorAdapter}.
     */
    protected static final String PROJECTION[] = {
        Email._ID,
        Contacts.DISPLAY_NAME,
        Email.DATA,
        Email.CONTACT_ID
    };

    /**
     * Index of the name field in the projection. This must match the order in
     * {@link #PROJECTION}.
     */
    protected static final int NAME_INDEX = 1;

    /**
     * Index of the email address field in the projection. This must match the
     * order in {@link #PROJECTION}.
     */
    protected static final int EMAIL_INDEX = 2;

    /**
     * Index of the contact id field in the projection. This must match the order in
     * {@link #PROJECTION}.
     */
    protected static final int CONTACT_ID_INDEX = 3;


    public ContactsSdk5(final Context context) {
        super(context);
    }

    @Override
    public void createContact(final Address email) {
        final Uri contactUri = Uri.fromParts(""mailto"", email.getAddress(), null);

        final Intent contactIntent = new Intent(Intents.SHOW_OR_CREATE_CONTACT);
        contactIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        contactIntent.setData(contactUri);

        // Pass along full E-mail string for possible create dialog
        contactIntent.putExtra(Intents.EXTRA_CREATE_DESCRIPTION,
                               email.toString());

        // Only provide personal name hint if we have one
        final String senderPersonal = email.getPersonal();
        if (senderPersonal != null) {
            contactIntent.putExtra(Intents.Insert.NAME, senderPersonal);
        }

        mContext.startActivity(contactIntent);
    }

    @Override
    public boolean isInContacts(final String emailAddress) {
        boolean result = false;

        final Cursor c = getContactByAddress(emailAddress);

        if (c != null) {
            if (c.getCount() > 0) {
                result = true;
            }
            c.close();
        }

        return result;
    }

    @Override
    public Cursor searchContacts(final CharSequence constraint) {
        final String filter = (constraint == null) ? """" : constraint.toString();
        final Uri uri = Uri.withAppendedPath(Email.CONTENT_FILTER_URI, Uri.encode(filter));
        final Cursor c = mContentResolver.query(
                             uri,
                             PROJECTION,
                             null,
                             null,
                             SORT_ORDER);

        if (c != null) {
            /*
             * To prevent expensive execution in the UI thread:
             * Cursors get lazily executed, so if you don't call anything on
             * the cursor before returning it from the background thread you'll
             * have a complied program for the cursor, but it won't have been
             * executed to generate the data yet. Often the execution is more
             * expensive than the compilation...
             */
            c.getCount();
        }

        return c;
    }

    @Override
    public String getNameForAddress(String address) {
        if (address == null) {
            return null;
        }

        final Cursor c = getContactByAddress(address);

        String name = null;
        if (c != null) {
            if (c.getCount() > 0) {
                c.moveToFirst();
                name = getName(c);
            }
            c.close();
        }

        return name;
    }

    @Override
    public String getName(Cursor c) {
        return c.getString(NAME_INDEX);
    }

    @Override
    public String getEmail(Cursor c) {
        return c.getString(EMAIL_INDEX);
    }

    @Override
    public void markAsContacted(final Address[] addresses) {
        //TODO: Optimize! Potentially a lot of database queries
        for (final Address address : addresses) {
            final Cursor c = getContactByAddress(address.getAddress());

            if (c != null) {
                if (c.getCount() > 0) {
                    c.moveToFirst();
                    final long personId = c.getLong(CONTACT_ID_INDEX);
                    ContactsContract.Contacts.markAsContacted(mContentResolver, personId);
                }
                c.close();
            }
        }
    }

    @Override
    public Intent contactPickerIntent() {
        return new Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI);
    }

    @Override
    public String getEmailFromContactPicker(final Intent data) {
        Cursor cursor = null;
        String email = """";

        try {
            Uri result = data.getData();

            // Get the contact id from the Uri
            String id = result.getLastPathSegment();
            cursor = mContentResolver.query(Email.CONTENT_URI,
                                            null, Email.CONTACT_ID + ""=?"", new String[] { id },
                                            null);

            int emailIdx = cursor.getColumnIndex(Email.DATA);

            if (cursor.moveToFirst()) {
                email = cursor.getString(emailIdx);
            }
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Failed to get email data"", e);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }

        return email;
    }

    /**
     * Return a {@link Cursor} instance that can be used to fetch information
     * about the contact with the given email address.
     *
     * @param address The email address to search for.
     * @return A {@link Cursor} instance that can be used to fetch information
     *         about the contact with the given email address
     */
    private Cursor getContactByAddress(final String address) {
        final Uri uri = Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(address));
        final Cursor c = mContentResolver.query(
                             uri,
                             PROJECTION,
                             null,
                             null,
                             SORT_ORDER);
        return c;
    }
}
",True,146,1,1,7,54,1,3,L2
31,com.fsck.k9.helper.ContactsSdk5p.java,"package com.fsck.k9.helper;

import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.provider.ContactsContract.Data;
import android.provider.ContactsContract.CommonDataKinds.Email;
import android.provider.ContactsContract.CommonDataKinds.StructuredName;

/**
 * Access the contacts on the device using the API introduced with SDK 5.
 * Use some additional code to make search work with phonetic names.
 *
 * Android versions >= 2.2 (Froyo) support searching for phonetic names
 * out of the box (see {@link ContactsSdk5}).
 *
 * @see android.provider.ContactsContract
 */
public class ContactsSdk5p extends ContactsSdk5 {
    public ContactsSdk5p(final Context context) {
        super(context);
    }

    @Override
    public Cursor searchContacts(final CharSequence constraint) {
        if (constraint == null) {
            return null;
        }

        // Lookup using Email.CONTENT_FILTER_URI to get matching contact ids.
        // This does all sorts of magic we don't want to replicate.
        final String filter = constraint.toString();
        final Uri uri = Uri.withAppendedPath(Email.CONTENT_FILTER_URI, Uri.encode(filter));
        final Cursor cursor = mContentResolver.query(
                                  uri,
                                  new String[] {Email.CONTACT_ID},
                                  null,
                                  null,
                                  null);

        final StringBuilder matches = new StringBuilder();
        if ((cursor != null) && (cursor.getCount() > 0)) {
            boolean first = true;
            while (cursor.moveToNext()) {
                if (first) {
                    first = false;
                } else {
                    matches.append("","");
                }
                matches.append(cursor.getLong(0));
            }
            cursor.close();
        }

        // Find contacts with email addresses that have been found using
        // Email.CONTENT_FILTER_URI above or ones that have a matching phonetic name.
        final String where = Data.MIMETYPE + "" = '"" + Email.CONTENT_ITEM_TYPE + ""'"" +
                             "" AND "" +
                             ""("" +
                             // Match if found by Email.CONTENT_FILTER_URI
                             Email.CONTACT_ID + "" IN ("" + matches.toString() + "")"" +
                             "" OR "" +
                             // Match if phonetic given name starts with ""constraint""
                             StructuredName.PHONETIC_GIVEN_NAME + "" LIKE ?"" +
                             "" OR "" +
                             // Match if phonetic given name contains a word that starts with ""constraint""
                             StructuredName.PHONETIC_GIVEN_NAME + "" LIKE ?"" +
                             "" OR "" +
                             // Match if phonetic middle name starts with ""constraint""
                             StructuredName.PHONETIC_MIDDLE_NAME + "" LIKE ?"" +
                             "" OR "" +
                             // Match if phonetic middle name contains a word that starts with ""constraint""
                             StructuredName.PHONETIC_MIDDLE_NAME + "" LIKE ?"" +
                             "" OR "" +
                             // Match if phonetic family name starts with ""constraint""
                             StructuredName.PHONETIC_FAMILY_NAME + "" LIKE ?"" +
                             "" OR "" +
                             // Match if phonetic family name contains a word that starts with ""constraint""
                             StructuredName.PHONETIC_FAMILY_NAME + "" LIKE ?"" +
                             "")"";
        final String filter1 = constraint.toString() + ""%"";
        final String filter2 = ""% "" + filter1;
        final String[] args = new String[] {filter1, filter2, filter1, filter2, filter1, filter2};
        final Cursor c = mContentResolver.query(
                             Email.CONTENT_URI,
                             PROJECTION,
                             where,
                             args,
                             SORT_ORDER);

        if (c != null) {
            /*
             * To prevent expensive execution in the UI thread:
             * Cursors get lazily executed, so if you don't call anything on
             * the cursor before returning it from the background thread you'll
             * have a complied program for the cursor, but it won't have been
             * executed to generate the data yet. Often the execution is more
             * expensive than the compilation...
             */
            c.getCount();
        }

        return c;
    }
}
",True,146,0,0,8,54,0,2,L2
32,com.fsck.k9.helper.MediaScannerNotifier.java,"package com.fsck.k9.helper;

import android.content.Context;
import android.content.Intent;
import android.media.MediaScannerConnection;
import android.media.MediaScannerConnection.MediaScannerConnectionClient;
import android.net.Uri;

import java.io.File;


public class MediaScannerNotifier implements MediaScannerConnectionClient {
    private MediaScannerConnection mConnection;
    private File mFile;
    private Context mContext;

    public MediaScannerNotifier(Context context, File file) {
        mFile = file;
        mConnection = new MediaScannerConnection(context, this);
        mConnection.connect();
        mContext = context;

    }

    public void onMediaScannerConnected() {
        mConnection.scanFile(mFile.getAbsolutePath(), null);
    }

    public void onScanCompleted(String path, Uri uri) {
        try {
            if (uri != null) {
                Intent intent = new Intent(Intent.ACTION_VIEW);
                intent.setData(uri);
                mContext.startActivity(intent);
            }
        } finally {
            mConnection.disconnect();
        }
    }
}
",False,113,8,44,0,0,1,0,L1
33,com.fsck.k9.helper.ContactsSdk3_4.java,"package com.fsck.k9.helper;

import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.util.Log;
import android.provider.Contacts;
import android.provider.Contacts.ContactMethods;
import com.fsck.k9.mail.Address;
import com.fsck.k9.K9;


/**
 * Access the contacts on the device using the old API (introduced in SDK 1).
 *
 * @see android.provider.Contacts
 */
@SuppressWarnings(""deprecation"")
public class ContactsSdk3_4 extends com.fsck.k9.helper.Contacts {
    /**
     * The order in which the search results are returned by
     * {@link #searchContacts(CharSequence)}.
     */
    private static final String SORT_ORDER =
        Contacts.ContactMethods.TIMES_CONTACTED + "" DESC, "" +
        Contacts.ContactMethods.DISPLAY_NAME + "", "" +
        Contacts.ContactMethods._ID;

    /**
     * Array of columns to load from the database.
     *
     * Important: The _ID field is needed by
     * {@link com.fsck.k9.EmailAddressAdapter} or more specificly by
     * {@link android.widget.ResourceCursorAdapter}.
     */
    private static final String PROJECTION[] = {
        Contacts.ContactMethods._ID,
        Contacts.ContactMethods.DISPLAY_NAME,
        Contacts.ContactMethods.DATA,
        Contacts.ContactMethods.PERSON_ID
    };

    /**
     * Index of the name field in the projection. This must match the order in
     * {@link #PROJECTION}.
     */
    private static final int NAME_INDEX = 1;

    /**
     * Index of the email address field in the projection. This must match the
     * order in {@link #PROJECTION}.
     */
    private static final int EMAIL_INDEX = 2;

    /**
     * Index of the contact id field in the projection. This must match the order in
     * {@link #PROJECTION}.
     */
    private static final int CONTACT_ID_INDEX = 3;


    public ContactsSdk3_4(final Context context) {
        super(context);
    }

    @Override
    public void createContact(final Address email) {
        final Uri contactUri = Uri.fromParts(""mailto"", email.getAddress(), null);

        final Intent contactIntent = new Intent(Contacts.Intents.SHOW_OR_CREATE_CONTACT);
        contactIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        contactIntent.setData(contactUri);

        // Pass along full E-mail string for possible create dialog
        contactIntent.putExtra(Contacts.Intents.EXTRA_CREATE_DESCRIPTION,
                               email.toString());

        // Only provide personal name hint if we have one
        final String senderPersonal = email.getPersonal();
        if (senderPersonal != null) {
            contactIntent.putExtra(Contacts.Intents.Insert.NAME, senderPersonal);
        }

        mContext.startActivity(contactIntent);
    }

    @Override
    public boolean isInContacts(final String emailAddress) {
        boolean result = false;

        final Cursor c = getContactByAddress(emailAddress);

        if (c != null) {
            if (c.getCount() > 0) {
                result = true;
            }
            c.close();
        }

        return result;
    }

    @Override
    public Cursor searchContacts(final CharSequence constraint) {
        final String where;
        final String[] args;
        if (constraint == null) {
            where = Contacts.ContactMethods.KIND + "" = "" + Contacts.KIND_EMAIL;
            args = null;
        } else {
            where = Contacts.ContactMethods.KIND + "" = "" + Contacts.KIND_EMAIL +
                    "" AND "" +
                    ""("" +
                    // Match if name starts with ""constraint""
                    Contacts.People.NAME + "" LIKE ?"" +
                    "" OR "" +
                    // Match if name contains a word that starts with ""constraint""
                    Contacts.People.NAME + "" LIKE ?"" +
                    "" OR "" +
                    // Match if phonetic name starts with ""constraint""
                    Contacts.People.PHONETIC_NAME + "" LIKE ?"" +
                    "" OR "" +
                    // Match if phonetic name contains a word that starts with ""constraint""
                    Contacts.People.PHONETIC_NAME + "" LIKE ?"" +
                    "" OR "" +
                    // Match if email address starts with ""constraint""
                    Contacts.ContactMethods.DATA + "" LIKE ?"" +
                    "")"";
            final String filter = constraint.toString() + ""%"";
            final String filter2 = ""% "" + filter;
            args = new String[] {filter, filter2, filter, filter2, filter};
        }

        final Cursor c = mContentResolver.query(
                             Contacts.ContactMethods.CONTENT_URI,
                             PROJECTION,
                             where,
                             args,
                             SORT_ORDER);

        if (c != null) {
            /*
             * To prevent expensive execution in the UI thread:
             * Cursors get lazily executed, so if you don't call anything on
             * the cursor before returning it from the background thread you'll
             * have a complied program for the cursor, but it won't have been
             * executed to generate the data yet. Often the execution is more
             * expensive than the compilation...
             */
            c.getCount();
        }

        return c;
    }

    @Override
    public String getNameForAddress(String address) {
        if (address == null) {
            return null;
        }

        final Cursor c = getContactByAddress(address);

        String name = null;
        if (c != null) {
            if (c.getCount() > 0) {
                c.moveToFirst();
                name = getName(c);
            }
            c.close();
        }

        return name;
    }

    @Override
    public String getName(Cursor c) {
        return c.getString(NAME_INDEX);
    }

    @Override
    public String getEmail(Cursor c) {
        return c.getString(EMAIL_INDEX);
    }

    @Override
    public void markAsContacted(final Address[] addresses) {
        //TODO: Optimize! Potentially a lot of database queries
        for (final Address address : addresses) {
            final Cursor c = getContactByAddress(address.getAddress());

            if (c != null) {
                if (c.getCount() > 0) {
                    c.moveToFirst();
                    final long personId = c.getLong(CONTACT_ID_INDEX);
                    Contacts.People.markAsContacted(mContentResolver, personId);
                }
                c.close();
            }
        }
    }

    @Override
    public Intent contactPickerIntent() {
        return new Intent(Intent.ACTION_PICK, Contacts.People.CONTENT_URI);
    }

    @Override
    public String getEmailFromContactPicker(final Intent data) {
        Cursor cursor = null;
        Cursor cursor2 = null;
        String email = """";

        try {
            Uri result = data.getData();
            cursor = mContentResolver.query(result, null, null, null, null);
            if (cursor.moveToFirst()) {
                String emailId = cursor.getString(cursor.getColumnIndex(Contacts.People.PRIMARY_EMAIL_ID));
                cursor2 = mContext.getContentResolver().query(
                              ContactMethods.CONTENT_EMAIL_URI,
                              new String[] { ContactMethods.DATA },
                              ""contact_methods._id=?"",
                              new String[] { emailId },
                              null);

                if (cursor2.moveToFirst()) {
                    email = cursor2.getString(0);
                }
            }
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Failed to get email data"", e);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
            if (cursor2 != null) {
                cursor2.close();
            }
        }

        return email;
    }

    /**
     * Return a {@link Cursor} instance that can be used to fetch information
     * about the contact with the given email address.
     *
     * @param address The email address to search for.
     * @return A {@link Cursor} instance that can be used to fetch information
     *         about the contact with the given email address
     */
    private Cursor getContactByAddress(String address) {
        final String where = Contacts.ContactMethods.KIND + "" = "" + Contacts.KIND_EMAIL +
                             "" AND "" +
                             Contacts.ContactMethods.DATA + "" = ?"";
        final String[] args = new String[] {address};

        final Cursor c = mContentResolver.query(
                             Contacts.ContactMethods.CONTENT_URI,
                             PROJECTION,
                             where,
                             args,
                             SORT_ORDER);
        return c;
    }
}
",True,145,0,0,7,54,0,3,L2
34,com.fsck.k9.helper.DateFormatter.java,"package com.fsck.k9.helper;

import android.content.Context;
import android.content.SharedPreferences.Editor;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Map;

public class DateFormatter {
    private DateFormatter() {
    }
    private final static Calendar SAMPLE_DATE = Calendar.getInstance();
    static {
        SAMPLE_DATE.set(SAMPLE_DATE.get(Calendar.YEAR), SAMPLE_DATE.getActualMaximum(Calendar.MONTH), SAMPLE_DATE.getActualMaximum(Calendar.DAY_OF_MONTH));
    }

    public static final String SHORT_FORMAT = ""SHORT"";
    public static final String MEDIUM_FORMAT = ""MEDIUM"";
    public static final String DEFAULT_FORMAT = SHORT_FORMAT;

    public static final String PREF_KEY = ""dateFormat"";

    private static volatile String sChosenFormat = null;

    public static String getSampleDate(Context context, String formatString) {
        java.text.DateFormat formatter = getDateFormat(context, formatString);
        return formatter.format(SAMPLE_DATE.getTime());
    }

    public static String[] getFormats(Context context) {
        return context.getResources().getStringArray(R.array.date_formats);
    }

    private static ThreadLocal<Map<String, DateFormat>> storedFormats = new ThreadLocal<Map<String, DateFormat>>() {
        @Override
        public synchronized Map<String, DateFormat> initialValue() {
            return new HashMap<String, DateFormat>();
        }
    };

    public static DateFormat getDateFormat(Context context, String formatString) {
        java.text.DateFormat dateFormat;

        if (SHORT_FORMAT.equals(formatString)) {
            dateFormat = android.text.format.DateFormat.getDateFormat(context);
        } else if (MEDIUM_FORMAT.equals(formatString)) {
            dateFormat = android.text.format.DateFormat.getMediumDateFormat(context);
        } else {
            Map<String, DateFormat> formatMap = storedFormats.get();
            dateFormat = formatMap.get(formatString);

            if (dateFormat == null) {
                dateFormat = new SimpleDateFormat(formatString);
                formatMap.put(formatString, dateFormat);
            }
        }
        return dateFormat;
    }

    public static void setDateFormat(Editor editor, String formatString) {
        sChosenFormat = formatString;
        editor.putString(PREF_KEY, formatString);
    }

    public static String getFormat(Context context) {
        if (sChosenFormat == null) {
            Preferences prefs = Preferences.getPreferences(context);
            sChosenFormat = prefs.getPreferences().getString(PREF_KEY, DEFAULT_FORMAT);
        }
        return sChosenFormat;
    }

    public static DateFormat getDateFormat(Context context) {
        String formatString = getFormat(context);
        return getDateFormat(context, formatString);
    }
}
",True,144,0,0,7,52,5,1,L1
35,com.fsck.k9.helper.AutoSyncSdk5.java,"package com.fsck.k9.helper;

import android.content.ContentResolver;
import android.content.Context;

public class AutoSyncSdk5 implements IAutoSync {
    public void initialize(Context context) throws NoSuchMethodException {
        // Nothing to do here
    }

    public boolean getMasterSyncAutomatically() {
        /*
         * SDK 2.0/API 5 introduced an official method to query the auto-sync
         * state.
         */
        return ContentResolver.getMasterSyncAutomatically();
    }
}
",False,2,0,0,1,1,0,1,L2
36,com.fsck.k9.helper.AutoSyncSdk3.java,"package com.fsck.k9.helper;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import android.content.ContentResolver;
import android.content.Context;
import android.os.Handler;

public class AutoSyncSdk3 implements IAutoSync {
    private Method mGetListenForNetworkTickles;
    private Object mQueryMap;

    public void initialize(Context context) throws NoSuchMethodException {
        /*
         * There's no documented/official way to query the state of the
         * auto-sync setting for a normal application in SDK 1.5/API 3.
         *
         * We use reflection to get an Sync.Settings.QueryMap"" object, so we
         * can call its getListenForNetworkTickles() method. This will return
         * the current auto-sync state.
         */
        try {
            Class<?> clazz = Class.forName(""android.provider.Sync$Settings$QueryMap"");
            Constructor<?> c = clazz.getConstructor(ContentResolver.class, boolean.class, Handler.class);
            mQueryMap = c.newInstance(context.getContentResolver(), true, null);
            mGetListenForNetworkTickles = mQueryMap.getClass().getMethod(""getListenForNetworkTickles"");
        } catch (Exception e) {
            throw new NoSuchMethodException();
        }
    }

    public boolean getMasterSyncAutomatically() {
        try {
            return (Boolean) mGetListenForNetworkTickles.invoke(mQueryMap);
        } catch (Exception e) {
            return false;
        }
    }
}
",True,2,0,0,1,1,0,1,L2
37,com.fsck.k9.helper.HtmlConverter.java,"package com.fsck.k9.helper;

import android.text.*;
import android.util.Log;
import com.fsck.k9.K9;
import org.xml.sax.XMLReader;

import java.io.IOException;
import java.io.StringReader;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;

/**
 * Contains common routines to convert html to text and vice versa.
 */
public class HtmlConverter {
    /**
     * When generating previews, Spannable objects that can't be converted into a String are
     * represented as 0xfffc. When displayed, these show up as undisplayed squares. These constants
     * define the object character and the replacement character.
     */
    private static final char PREVIEW_OBJECT_CHARACTER = (char)0xfffc;
    private static final char PREVIEW_OBJECT_REPLACEMENT = (char)0x20;  // space

    /**
     * toHtml() converts non-breaking spaces into the UTF-8 non-breaking space, which doesn't get
     * rendered properly in some clients. Replace it with a simple space.
     */
    private static final char NBSP_CHARACTER = (char)0x00a0;    // utf-8 non-breaking space
    private static final char NBSP_REPLACEMENT = (char)0x20;    // space

    // Number of extra bytes to allocate in a string buffer for htmlification.
    private static final int TEXT_TO_HTML_EXTRA_BUFFER_LENGTH = 512;

    /**
     * Convert an HTML string to a plain text string.
     * @param html HTML string to convert.
     * @return Plain text result.
     */
    public static String htmlToText(final String html) {
        return Html.fromHtml(html, null, new HtmlToTextTagHandler()).toString()
               .replace(PREVIEW_OBJECT_CHARACTER, PREVIEW_OBJECT_REPLACEMENT)
               .replace(NBSP_CHARACTER, NBSP_REPLACEMENT);
    }

    /**
     * Custom tag handler to use when converting HTML messages to text. It currently handles text
     * representations of HTML tags that Android's built-in parser doesn't understand and hides code
     * contained in STYLE and SCRIPT blocks.
     */
    private static class HtmlToTextTagHandler implements Html.TagHandler {
        // List of tags whose content should be ignored.
        private static final Set<String> TAGS_WITH_IGNORED_CONTENT = Collections.unmodifiableSet(new HashSet<String>() {
            {
                add(""style"");
                add(""script"");
                add(""title"");
                add(""!"");   // comments
            }
        });

        @Override
        public void handleTag(boolean opening, String tag, Editable output, XMLReader xmlReader) {
            tag = tag.toLowerCase();
            if (tag.equals(""hr"") && opening) {
                // In the case of an <hr>, replace it with a bunch of underscores. This is roughly
                // the behaviour of Outlook in Rich Text mode.
                output.append(""_____________________________________________\n"");
            } else if (TAGS_WITH_IGNORED_CONTENT.contains(tag)) {
                handleIgnoredTag(opening, output);
            }
        }

        private static final String IGNORED_ANNOTATION_KEY = ""K9_ANNOTATION"";
        private static final String IGNORED_ANNOTATION_VALUE = ""hiddenSpan"";

        /**
         * When we come upon an ignored tag, we mark it with an Annotation object with a specific key
         * and value as above. We don't really need to be checking these values since Html.fromHtml()
         * doesn't use Annotation spans, but we should do it now to be safe in case they do start using
         * it in the future.
         * @param opening If this is an opening tag or not.
         * @param output Spannable string that we're working with.
         */
        private void handleIgnoredTag(boolean opening, Editable output) {
            int len = output.length();
            if (opening) {
                output.setSpan(new Annotation(IGNORED_ANNOTATION_KEY, IGNORED_ANNOTATION_VALUE), len,
                               len, Spannable.SPAN_MARK_MARK);
            } else {
                Object start = getOpeningAnnotation(output);
                if (start != null) {
                    int where = output.getSpanStart(start);
                    // Remove the temporary Annotation span.
                    output.removeSpan(start);
                    // Delete everything between the start of the Annotation and the end of the string
                    // (what we've generated so far).
                    output.delete(where, len);
                }
            }
        }

        /**
         * Fetch the matching opening Annotation object and verify that it's the one added by K9.
         * @param output Spannable string we're working with.
         * @return Starting Annotation object.
         */
        private Object getOpeningAnnotation(Editable output) {
            Object[] objs = output.getSpans(0, output.length(), Annotation.class);
            for (int i = objs.length - 1; i >= 0; i--) {
                Annotation span = (Annotation) objs[i];
                if (output.getSpanFlags(objs[i]) == Spannable.SPAN_MARK_MARK
                        && span.getKey().equals(IGNORED_ANNOTATION_KEY)
                        && span.getValue().equals(IGNORED_ANNOTATION_VALUE)) {
                    return objs[i];
                }
            }
            return null;
        }
    }

    private static final int MAX_SMART_HTMLIFY_MESSAGE_LENGTH = 1024 * 256 ;

    /**
     * Naively convert a text string into an HTML document.  This method avoids using regular expressions on the entire
     * message body to save memory.
     * @param text Plain text string.
     * @return HTML string.
     */
    private static String simpleTextToHtml(String text) {
        // Encode HTML entities to make sure we don't display something evil.
        text = TextUtils.htmlEncode(text);

        StringReader reader = new StringReader(text);
        StringBuilder buff = new StringBuilder(text.length() + TEXT_TO_HTML_EXTRA_BUFFER_LENGTH);
        buff.append(""<html><head/><body>"");

        int c;
        try {
            while ((c = reader.read()) != -1) {
                switch (c) {
                case '\n':
                    // pine treats <br> as two newlines, but <br/> as one newline.  Use <br/> so our messages aren't
                    // doublespaced.
                    buff.append(""<br />"");
                    break;
                case '\r':
                    break;
                default:
                    buff.append((char)c);
                }//switch
            }
        } catch (IOException e) {
            //Should never happen
            Log.e(K9.LOG_TAG, ""Could not read string to convert text to HTML:"", e);
        }

        buff.append(""</body></html>"");

        return buff.toString();
    }

    /**
     * Convert a text string into an HTML document. Attempts to do smart replacement for large
     * documents to prevent OOM errors. This method adds headers and footers to create a proper HTML
     * document. To convert to a fragment, use {@link #textToHtmlFragment(String)}.
     * @param text Plain text string.
     * @return HTML string.
     */
    public static String textToHtml(String text) {
        // Our HTMLification code is somewhat memory intensive
        // and was causing lots of OOM errors on the market
        // if the message is big and plain text, just do
        // a trivial htmlification
        if (text.length() > MAX_SMART_HTMLIFY_MESSAGE_LENGTH) {
            return simpleTextToHtml(text);
        }
        StringReader reader = new StringReader(text);
        StringBuilder buff = new StringBuilder(text.length() + TEXT_TO_HTML_EXTRA_BUFFER_LENGTH);
        int c;
        try {
            while ((c = reader.read()) != -1) {
                switch (c) {
                case '\n':
                    // pine treats <br> as two newlines, but <br/> as one newline.  Use <br/> so our messages aren't
                    // doublespaced.
                    buff.append(""<br />"");
                    break;
                case '&':
                    buff.append(""&amp;"");
                    break;
                case '<':
                    buff.append(""&lt;"");
                    break;
                case '>':
                    buff.append(""&gt;"");
                    break;
                case '\r':
                    break;
                default:
                    buff.append((char)c);
                }//switch
            }
        } catch (IOException e) {
            //Should never happen
            Log.e(K9.LOG_TAG, ""Could not read string to convert text to HTML:"", e);
        }
        text = buff.toString();

        // Replace lines of -,= or _ with horizontal rules
        text = text.replaceAll(""\\s*([-=_]{30,}+)\\s*"", ""<hr />"");

        // TODO: reverse engineer (or troll history) and document
        text = text.replaceAll(""(?m)^([^\r\n]{4,}[\\s\\w,:;+/])(?:\r\n|\n|\r)(?=[a-z]\\S{0,10}[\\s\\n\\r])"", ""$1 "");

        // Compress four or more newlines down to two newlines
        text = text.replaceAll(""(?m)(\r\n|\n|\r){4,}"", ""\n\n"");

        StringBuffer sb = new StringBuffer(text.length() + TEXT_TO_HTML_EXTRA_BUFFER_LENGTH);
        sb.append(""<html><head></head><body>"");
        sb.append(htmlifyMessageHeader());
        linkifyText(text, sb);
        sb.append(htmlifyMessageFooter());
        sb.append(""</body></html>"");
        text = sb.toString();

        return text;
    }

    /**
     * Searches for link-like text in a string and turn it into a link. Append the result to
     * <tt>outputBuffer</tt>. <tt>text</tt> is not modified.
     * @param text Plain text to be linkified.
     * @param outputBuffer Buffer to append linked text to.
     */
    private static void linkifyText(final String text, final StringBuffer outputBuffer) {
        Matcher m = Regex.WEB_URL_PATTERN.matcher(text);
        while (m.find()) {
            int start = m.start();
            if (start == 0 || (start != 0 && text.charAt(start - 1) != '@')) {
                if (m.group().indexOf(':') > 0) { // With no URI-schema we may get ""http:/"" links with the second / missing
                    m.appendReplacement(outputBuffer, ""<a href=\""$0\"">$0</a>"");
                } else {
                    m.appendReplacement(outputBuffer, ""<a href=\""http://$0\"">$0</a>"");
                }
            } else {
                m.appendReplacement(outputBuffer, ""$0"");
            }
        }

        m.appendTail(outputBuffer);
    }

    /*
     * Lightweight method to check whether the message contains emoji or not.
     * Useful to avoid calling the heavyweight convertEmoji2Img method.
     * We don't use String.codePointAt here for performance reasons.
     */
    private static boolean hasEmoji(String html) {
        for (int i = 0; i < html.length(); ++i) {
            char c = html.charAt(i);
            if (c >= 0xDBB8 && c < 0xDBBC)
                return true;
        }
        return false;
    }

    public static String convertEmoji2Img(String html) {
        if (!hasEmoji(html)) {
            return html;

        }
        StringBuilder buff = new StringBuilder(html.length() + 512);
        for (int i = 0; i < html.length(); i = html.offsetByCodePoints(i, 1)) {
            int codePoint = html.codePointAt(i);
            String emoji = getEmojiForCodePoint(codePoint);
            if (emoji != null)
                buff.append(""<img src=\""file:///android_asset/emoticons/"").append(emoji).append("".gif\"" alt=\"""").append(emoji).append(""\"" />"");
            else
                buff.appendCodePoint(codePoint);

        }
        return buff.toString();
    }

    private static String getEmojiForCodePoint(int codePoint) {
        // Derived from http://code.google.com/p/emoji4unicode/source/browse/trunk/data/emoji4unicode.xml
        // XXX: This doesn't cover all the characters.  More emoticons are wanted.
        switch (codePoint) {
        case 0xFE000:
            return ""sun"";
        case 0xFE001:
            return ""cloud"";
        case 0xFE002:
            return ""rain"";
        case 0xFE003:
            return ""snow"";
        case 0xFE004:
            return ""thunder"";
        case 0xFE005:
            return ""typhoon"";
        case 0xFE006:
            return ""mist"";
        case 0xFE007:
            return ""sprinkle"";
        case 0xFE008:
            return ""night"";
        case 0xFE009:
            return ""sun"";
        case 0xFE00A:
            return ""sun"";
        case 0xFE00C:
            return ""sun"";
        case 0xFE010:
            return ""night"";
        case 0xFE011:
            return ""newmoon"";
        case 0xFE012:
            return ""moon1"";
        case 0xFE013:
            return ""moon2"";
        case 0xFE014:
            return ""moon3"";
        case 0xFE015:
            return ""fullmoon"";
        case 0xFE016:
            return ""moon2"";
        case 0xFE018:
            return ""soon"";
        case 0xFE019:
            return ""on"";
        case 0xFE01A:
            return ""end"";
        case 0xFE01B:
            return ""sandclock"";
        case 0xFE01C:
            return ""sandclock"";
        case 0xFE01D:
            return ""watch"";
        case 0xFE01E:
            return ""clock"";
        case 0xFE01F:
            return ""clock"";
        case 0xFE020:
            return ""clock"";
        case 0xFE021:
            return ""clock"";
        case 0xFE022:
            return ""clock"";
        case 0xFE023:
            return ""clock"";
        case 0xFE024:
            return ""clock"";
        case 0xFE025:
            return ""clock"";
        case 0xFE026:
            return ""clock"";
        case 0xFE027:
            return ""clock"";
        case 0xFE028:
            return ""clock"";
        case 0xFE029:
            return ""clock"";
        case 0xFE02A:
            return ""clock"";
        case 0xFE02B:
            return ""aries"";
        case 0xFE02C:
            return ""taurus"";
        case 0xFE02D:
            return ""gemini"";
        case 0xFE02E:
            return ""cancer"";
        case 0xFE02F:
            return ""leo"";
        case 0xFE030:
            return ""virgo"";
        case 0xFE031:
            return ""libra"";
        case 0xFE032:
            return ""scorpius"";
        case 0xFE033:
            return ""sagittarius"";
        case 0xFE034:
            return ""capricornus"";
        case 0xFE035:
            return ""aquarius"";
        case 0xFE036:
            return ""pisces"";
        case 0xFE038:
            return ""wave"";
        case 0xFE03B:
            return ""night"";
        case 0xFE03C:
            return ""clover"";
        case 0xFE03D:
            return ""tulip"";
        case 0xFE03E:
            return ""bud"";
        case 0xFE03F:
            return ""maple"";
        case 0xFE040:
            return ""cherryblossom"";
        case 0xFE042:
            return ""maple"";
        case 0xFE04E:
            return ""clover"";
        case 0xFE04F:
            return ""cherry"";
        case 0xFE050:
            return ""banana"";
        case 0xFE051:
            return ""apple"";
        case 0xFE05B:
            return ""apple"";
        case 0xFE190:
            return ""eye"";
        case 0xFE191:
            return ""ear"";
        case 0xFE193:
            return ""kissmark"";
        case 0xFE194:
            return ""bleah"";
        case 0xFE195:
            return ""rouge"";
        case 0xFE198:
            return ""hairsalon"";
        case 0xFE19A:
            return ""shadow"";
        case 0xFE19B:
            return ""happy01"";
        case 0xFE19C:
            return ""happy01"";
        case 0xFE19D:
            return ""happy01"";
        case 0xFE19E:
            return ""happy01"";
        case 0xFE1B7:
            return ""dog"";
        case 0xFE1B8:
            return ""cat"";
        case 0xFE1B9:
            return ""snail"";
        case 0xFE1BA:
            return ""chick"";
        case 0xFE1BB:
            return ""chick"";
        case 0xFE1BC:
            return ""penguin"";
        case 0xFE1BD:
            return ""fish"";
        case 0xFE1BE:
            return ""horse"";
        case 0xFE1BF:
            return ""pig"";
        case 0xFE1C8:
            return ""chick"";
        case 0xFE1C9:
            return ""fish"";
        case 0xFE1CF:
            return ""aries"";
        case 0xFE1D0:
            return ""dog"";
        case 0xFE1D8:
            return ""dog"";
        case 0xFE1D9:
            return ""fish"";
        case 0xFE1DB:
            return ""foot"";
        case 0xFE1DD:
            return ""chick"";
        case 0xFE1E0:
            return ""pig"";
        case 0xFE1E3:
            return ""cancer"";
        case 0xFE320:
            return ""angry"";
        case 0xFE321:
            return ""sad"";
        case 0xFE322:
            return ""wobbly"";
        case 0xFE323:
            return ""despair"";
        case 0xFE324:
            return ""wobbly"";
        case 0xFE325:
            return ""coldsweats02"";
        case 0xFE326:
            return ""gawk"";
        case 0xFE327:
            return ""lovely"";
        case 0xFE328:
            return ""smile"";
        case 0xFE329:
            return ""bleah"";
        case 0xFE32A:
            return ""bleah"";
        case 0xFE32B:
            return ""delicious"";
        case 0xFE32C:
            return ""lovely"";
        case 0xFE32D:
            return ""lovely"";
        case 0xFE32F:
            return ""happy02"";
        case 0xFE330:
            return ""happy01"";
        case 0xFE331:
            return ""coldsweats01"";
        case 0xFE332:
            return ""happy02"";
        case 0xFE333:
            return ""smile"";
        case 0xFE334:
            return ""happy02"";
        case 0xFE335:
            return ""delicious"";
        case 0xFE336:
            return ""happy01"";
        case 0xFE337:
            return ""happy01"";
        case 0xFE338:
            return ""coldsweats01"";
        case 0xFE339:
            return ""weep"";
        case 0xFE33A:
            return ""crying"";
        case 0xFE33B:
            return ""shock"";
        case 0xFE33C:
            return ""bearing"";
        case 0xFE33D:
            return ""pout"";
        case 0xFE33E:
            return ""confident"";
        case 0xFE33F:
            return ""sad"";
        case 0xFE340:
            return ""think"";
        case 0xFE341:
            return ""shock"";
        case 0xFE342:
            return ""sleepy"";
        case 0xFE343:
            return ""catface"";
        case 0xFE344:
            return ""coldsweats02"";
        case 0xFE345:
            return ""coldsweats02"";
        case 0xFE346:
            return ""bearing"";
        case 0xFE347:
            return ""wink"";
        case 0xFE348:
            return ""happy01"";
        case 0xFE349:
            return ""smile"";
        case 0xFE34A:
            return ""happy02"";
        case 0xFE34B:
            return ""lovely"";
        case 0xFE34C:
            return ""lovely"";
        case 0xFE34D:
            return ""weep"";
        case 0xFE34E:
            return ""pout"";
        case 0xFE34F:
            return ""smile"";
        case 0xFE350:
            return ""sad"";
        case 0xFE351:
            return ""ng"";
        case 0xFE352:
            return ""ok"";
        case 0xFE357:
            return ""paper"";
        case 0xFE359:
            return ""sad"";
        case 0xFE35A:
            return ""angry"";
        case 0xFE4B0:
            return ""house"";
        case 0xFE4B1:
            return ""house"";
        case 0xFE4B2:
            return ""building"";
        case 0xFE4B3:
            return ""postoffice"";
        case 0xFE4B4:
            return ""hospital"";
        case 0xFE4B5:
            return ""bank"";
        case 0xFE4B6:
            return ""atm"";
        case 0xFE4B7:
            return ""hotel"";
        case 0xFE4B9:
            return ""24hours"";
        case 0xFE4BA:
            return ""school"";
        case 0xFE4C1:
            return ""ship"";
        case 0xFE4C2:
            return ""bottle"";
        case 0xFE4C3:
            return ""fuji"";
        case 0xFE4C9:
            return ""wrench"";
        case 0xFE4CC:
            return ""shoe"";
        case 0xFE4CD:
            return ""shoe"";
        case 0xFE4CE:
            return ""eyeglass"";
        case 0xFE4CF:
            return ""t-shirt"";
        case 0xFE4D0:
            return ""denim"";
        case 0xFE4D1:
            return ""crown"";
        case 0xFE4D2:
            return ""crown"";
        case 0xFE4D6:
            return ""boutique"";
        case 0xFE4D7:
            return ""boutique"";
        case 0xFE4DB:
            return ""t-shirt"";
        case 0xFE4DC:
            return ""moneybag"";
        case 0xFE4DD:
            return ""dollar"";
        case 0xFE4E0:
            return ""dollar"";
        case 0xFE4E2:
            return ""yen"";
        case 0xFE4E3:
            return ""dollar"";
        case 0xFE4EF:
            return ""camera"";
        case 0xFE4F0:
            return ""bag"";
        case 0xFE4F1:
            return ""pouch"";
        case 0xFE4F2:
            return ""bell"";
        case 0xFE4F3:
            return ""door"";
        case 0xFE4F9:
            return ""movie"";
        case 0xFE4FB:
            return ""flair"";
        case 0xFE4FD:
            return ""sign05"";
        case 0xFE4FF:
            return ""book"";
        case 0xFE500:
            return ""book"";
        case 0xFE501:
            return ""book"";
        case 0xFE502:
            return ""book"";
        case 0xFE503:
            return ""book"";
        case 0xFE505:
            return ""spa"";
        case 0xFE506:
            return ""toilet"";
        case 0xFE507:
            return ""toilet"";
        case 0xFE508:
            return ""toilet"";
        case 0xFE50F:
            return ""ribbon"";
        case 0xFE510:
            return ""present"";
        case 0xFE511:
            return ""birthday"";
        case 0xFE512:
            return ""xmas"";
        case 0xFE522:
            return ""pocketbell"";
        case 0xFE523:
            return ""telephone"";
        case 0xFE524:
            return ""telephone"";
        case 0xFE525:
            return ""mobilephone"";
        case 0xFE526:
            return ""phoneto"";
        case 0xFE527:
            return ""memo"";
        case 0xFE528:
            return ""faxto"";
        case 0xFE529:
            return ""mail"";
        case 0xFE52A:
            return ""mailto"";
        case 0xFE52B:
            return ""mailto"";
        case 0xFE52C:
            return ""postoffice"";
        case 0xFE52D:
            return ""postoffice"";
        case 0xFE52E:
            return ""postoffice"";
        case 0xFE535:
            return ""present"";
        case 0xFE536:
            return ""pen"";
        case 0xFE537:
            return ""chair"";
        case 0xFE538:
            return ""pc"";
        case 0xFE539:
            return ""pencil"";
        case 0xFE53A:
            return ""clip"";
        case 0xFE53B:
            return ""bag"";
        case 0xFE53E:
            return ""hairsalon"";
        case 0xFE540:
            return ""memo"";
        case 0xFE541:
            return ""memo"";
        case 0xFE545:
            return ""book"";
        case 0xFE546:
            return ""book"";
        case 0xFE547:
            return ""book"";
        case 0xFE548:
            return ""memo"";
        case 0xFE54D:
            return ""book"";
        case 0xFE54F:
            return ""book"";
        case 0xFE552:
            return ""memo"";
        case 0xFE553:
            return ""foot"";
        case 0xFE7D0:
            return ""sports"";
        case 0xFE7D1:
            return ""baseball"";
        case 0xFE7D2:
            return ""golf"";
        case 0xFE7D3:
            return ""tennis"";
        case 0xFE7D4:
            return ""soccer"";
        case 0xFE7D5:
            return ""ski"";
        case 0xFE7D6:
            return ""basketball"";
        case 0xFE7D7:
            return ""motorsports"";
        case 0xFE7D8:
            return ""snowboard"";
        case 0xFE7D9:
            return ""run"";
        case 0xFE7DA:
            return ""snowboard"";
        case 0xFE7DC:
            return ""horse"";
        case 0xFE7DF:
            return ""train"";
        case 0xFE7E0:
            return ""subway"";
        case 0xFE7E1:
            return ""subway"";
        case 0xFE7E2:
            return ""bullettrain"";
        case 0xFE7E3:
            return ""bullettrain"";
        case 0xFE7E4:
            return ""car"";
        case 0xFE7E5:
            return ""rvcar"";
        case 0xFE7E6:
            return ""bus"";
        case 0xFE7E8:
            return ""ship"";
        case 0xFE7E9:
            return ""airplane"";
        case 0xFE7EA:
            return ""yacht"";
        case 0xFE7EB:
            return ""bicycle"";
        case 0xFE7EE:
            return ""yacht"";
        case 0xFE7EF:
            return ""car"";
        case 0xFE7F0:
            return ""run"";
        case 0xFE7F5:
            return ""gasstation"";
        case 0xFE7F6:
            return ""parking"";
        case 0xFE7F7:
            return ""signaler"";
        case 0xFE7FA:
            return ""spa"";
        case 0xFE7FC:
            return ""carouselpony"";
        case 0xFE7FF:
            return ""fish"";
        case 0xFE800:
            return ""karaoke"";
        case 0xFE801:
            return ""movie"";
        case 0xFE802:
            return ""movie"";
        case 0xFE803:
            return ""music"";
        case 0xFE804:
            return ""art"";
        case 0xFE805:
            return ""drama"";
        case 0xFE806:
            return ""event"";
        case 0xFE807:
            return ""ticket"";
        case 0xFE808:
            return ""slate"";
        case 0xFE809:
            return ""drama"";
        case 0xFE80A:
            return ""game"";
        case 0xFE813:
            return ""note"";
        case 0xFE814:
            return ""notes"";
        case 0xFE81A:
            return ""notes"";
        case 0xFE81C:
            return ""tv"";
        case 0xFE81D:
            return ""cd"";
        case 0xFE81E:
            return ""cd"";
        case 0xFE823:
            return ""kissmark"";
        case 0xFE824:
            return ""loveletter"";
        case 0xFE825:
            return ""ring"";
        case 0xFE826:
            return ""ring"";
        case 0xFE827:
            return ""kissmark"";
        case 0xFE829:
            return ""heart02"";
        case 0xFE82B:
            return ""freedial"";
        case 0xFE82C:
            return ""sharp"";
        case 0xFE82D:
            return ""mobaq"";
        case 0xFE82E:
            return ""one"";
        case 0xFE82F:
            return ""two"";
        case 0xFE830:
            return ""three"";
        case 0xFE831:
            return ""four"";
        case 0xFE832:
            return ""five"";
        case 0xFE833:
            return ""six"";
        case 0xFE834:
            return ""seven"";
        case 0xFE835:
            return ""eight"";
        case 0xFE836:
            return ""nine"";
        case 0xFE837:
            return ""zero"";
        case 0xFE960:
            return ""fastfood"";
        case 0xFE961:
            return ""riceball"";
        case 0xFE962:
            return ""cake"";
        case 0xFE963:
            return ""noodle"";
        case 0xFE964:
            return ""bread"";
        case 0xFE96A:
            return ""noodle"";
        case 0xFE973:
            return ""typhoon"";
        case 0xFE980:
            return ""restaurant"";
        case 0xFE981:
            return ""cafe"";
        case 0xFE982:
            return ""bar"";
        case 0xFE983:
            return ""beer"";
        case 0xFE984:
            return ""japanesetea"";
        case 0xFE985:
            return ""bottle"";
        case 0xFE986:
            return ""wine"";
        case 0xFE987:
            return ""beer"";
        case 0xFE988:
            return ""bar"";
        case 0xFEAF0:
            return ""upwardright"";
        case 0xFEAF1:
            return ""downwardright"";
        case 0xFEAF2:
            return ""upwardleft"";
        case 0xFEAF3:
            return ""downwardleft"";
        case 0xFEAF4:
            return ""up"";
        case 0xFEAF5:
            return ""down"";
        case 0xFEAF6:
            return ""leftright"";
        case 0xFEAF7:
            return ""updown"";
        case 0xFEB04:
            return ""sign01"";
        case 0xFEB05:
            return ""sign02"";
        case 0xFEB06:
            return ""sign03"";
        case 0xFEB07:
            return ""sign04"";
        case 0xFEB08:
            return ""sign05"";
        case 0xFEB0B:
            return ""sign01"";
        case 0xFEB0C:
            return ""heart01"";
        case 0xFEB0D:
            return ""heart02"";
        case 0xFEB0E:
            return ""heart03"";
        case 0xFEB0F:
            return ""heart04"";
        case 0xFEB10:
            return ""heart01"";
        case 0xFEB11:
            return ""heart02"";
        case 0xFEB12:
            return ""heart01"";
        case 0xFEB13:
            return ""heart01"";
        case 0xFEB14:
            return ""heart01"";
        case 0xFEB15:
            return ""heart01"";
        case 0xFEB16:
            return ""heart01"";
        case 0xFEB17:
            return ""heart01"";
        case 0xFEB18:
            return ""heart02"";
        case 0xFEB19:
            return ""cute"";
        case 0xFEB1A:
            return ""heart"";
        case 0xFEB1B:
            return ""spade"";
        case 0xFEB1C:
            return ""diamond"";
        case 0xFEB1D:
            return ""club"";
        case 0xFEB1E:
            return ""smoking"";
        case 0xFEB1F:
            return ""nosmoking"";
        case 0xFEB20:
            return ""wheelchair"";
        case 0xFEB21:
            return ""free"";
        case 0xFEB22:
            return ""flag"";
        case 0xFEB23:
            return ""danger"";
        case 0xFEB26:
            return ""ng"";
        case 0xFEB27:
            return ""ok"";
        case 0xFEB28:
            return ""ng"";
        case 0xFEB29:
            return ""copyright"";
        case 0xFEB2A:
            return ""tm"";
        case 0xFEB2B:
            return ""secret"";
        case 0xFEB2C:
            return ""recycle"";
        case 0xFEB2D:
            return ""r-mark"";
        case 0xFEB2E:
            return ""ban"";
        case 0xFEB2F:
            return ""empty"";
        case 0xFEB30:
            return ""pass"";
        case 0xFEB31:
            return ""full"";
        case 0xFEB36:
            return ""new"";
        case 0xFEB44:
            return ""fullmoon"";
        case 0xFEB48:
            return ""ban"";
        case 0xFEB55:
            return ""cute"";
        case 0xFEB56:
            return ""flair"";
        case 0xFEB57:
            return ""annoy"";
        case 0xFEB58:
            return ""bomb"";
        case 0xFEB59:
            return ""sleepy"";
        case 0xFEB5A:
            return ""impact"";
        case 0xFEB5B:
            return ""sweat01"";
        case 0xFEB5C:
            return ""sweat02"";
        case 0xFEB5D:
            return ""dash"";
        case 0xFEB5F:
            return ""sad"";
        case 0xFEB60:
            return ""shine"";
        case 0xFEB61:
            return ""cute"";
        case 0xFEB62:
            return ""cute"";
        case 0xFEB63:
            return ""newmoon"";
        case 0xFEB64:
            return ""newmoon"";
        case 0xFEB65:
            return ""newmoon"";
        case 0xFEB66:
            return ""newmoon"";
        case 0xFEB67:
            return ""newmoon"";
        case 0xFEB77:
            return ""shine"";
        case 0xFEB81:
            return ""id"";
        case 0xFEB82:
            return ""key"";
        case 0xFEB83:
            return ""enter"";
        case 0xFEB84:
            return ""clear"";
        case 0xFEB85:
            return ""search"";
        case 0xFEB86:
            return ""key"";
        case 0xFEB87:
            return ""key"";
        case 0xFEB8A:
            return ""key"";
        case 0xFEB8D:
            return ""search"";
        case 0xFEB90:
            return ""key"";
        case 0xFEB91:
            return ""recycle"";
        case 0xFEB92:
            return ""mail"";
        case 0xFEB93:
            return ""rock"";
        case 0xFEB94:
            return ""scissors"";
        case 0xFEB95:
            return ""paper"";
        case 0xFEB96:
            return ""punch"";
        case 0xFEB97:
            return ""good"";
        case 0xFEB9D:
            return ""paper"";
        case 0xFEB9F:
            return ""ok"";
        case 0xFEBA0:
            return ""down"";
        case 0xFEBA1:
            return ""paper"";
        case 0xFEE10:
            return ""info01"";
        case 0xFEE11:
            return ""info02"";
        case 0xFEE12:
            return ""by-d"";
        case 0xFEE13:
            return ""d-point"";
        case 0xFEE14:
            return ""appli01"";
        case 0xFEE15:
            return ""appli02"";
        case 0xFEE1C:
            return ""movie"";
        default:
            return null;
        }
    }

    private static String htmlifyMessageHeader() {
        final String font = K9.messageViewFixedWidthFont()
                            ? ""monospace""
                            : ""sans-serif"";
        return ""<pre style=\""white-space: pre-wrap; word-wrap:break-word; font-family: "" + font + ""\"">"";
    }

    private static String htmlifyMessageFooter() {
        return ""</pre>"";
    }

    /**
     * Convert a plain text string into an HTML fragment.
     * @param text Plain text.
     * @return HTML fragment.
     */
    public static String textToHtmlFragment(final String text) {
        // Escape the entities and add newlines.
        String htmlified = TextUtils.htmlEncode(text);

        // Linkify the message.
        StringBuffer linkified = new StringBuffer(htmlified.length() + TEXT_TO_HTML_EXTRA_BUFFER_LENGTH);
        linkifyText(htmlified, linkified);

        // Add newlines and unescaping.
        //
        // For some reason, TextUtils.htmlEncode escapes ' into &apos;, which is technically part of the XHTML 1.0
        // standard, but Gmail doesn't recognize it as an HTML entity. We unescape that here.
        return linkified.toString().replace(""\n"", ""<br>\n"").replace(""&apos;"", ""&#39;"");
    }
}
",False,144,0,0,7,54,2,2,L1
38,com.fsck.k9.helper.Regex.java,"/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Imported from AOSP on 2011-01-12 by JRV.
 * Domain patterns updated from IANA on 2010-01-12
 *
 *
 */

package com.fsck.k9.helper;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Commonly used regular expression patterns.
 */
public class Regex {

    /**
     *  Regular expression to match all IANA top-level domains.
     *  List accurate as of 2011/01/12.  List taken from:
     *  http://data.iana.org/TLD/tlds-alpha-by-domain.txt
     *  This pattern is auto-generated by frameworks/base/common/tools/make-iana-tld-pattern.py
     */
    public static final String TOP_LEVEL_DOMAIN_STR =
        ""((aero|arpa|asia|a[cdefgilmnoqrstuwxz])""
        + ""|(biz|b[abdefghijmnorstvwyz])""
        + ""|(cat|com|coop|c[acdfghiklmnoruvxyz])""
        + ""|d[ejkmoz]""
        + ""|(edu|e[cegrstu])""
        + ""|f[ijkmor]""
        + ""|(gov|g[abdefghilmnpqrstuwy])""
        + ""|h[kmnrtu]""
        + ""|(info|int|i[delmnoqrst])""
        + ""|(jobs|j[emop])""
        + ""|k[eghimnprwyz]""
        + ""|l[abcikrstuvy]""
        + ""|(mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])""
        + ""|(name|net|n[acefgilopruz])""
        + ""|(org|om)""
        + ""|(pro|p[aefghklmnrstwy])""
        + ""|qa""
        + ""|r[eosuw]""
        + ""|s[abcdeghijklmnortuvyz]""
        + ""|(tel|travel|t[cdfghjklmnoprtvwz])""
        + ""|u[agksyz]""
        + ""|v[aceginu]""
        + ""|w[fs]""
        + ""|(xn\\-\\-0zwm56d|xn\\-\\-11b5bs3a9aj6g|xn\\-\\-80akhbyknj4f|xn\\-\\-9t4b11yi5a|xn\\-\\-deba0ad|xn\\-\\-fiqs8s|xn\\-\\-fiqz9s|xn\\-\\-fzc2c9e2c|xn\\-\\-g6w251d|xn\\-\\-hgbk6aj7f53bba|xn\\-\\-hlcj6aya9esc7a|xn\\-\\-j6w193g|xn\\-\\-jxalpdlp|xn\\-\\-kgbechtv|xn\\-\\-kprw13d|xn\\-\\-kpry57d|xn\\-\\-mgbaam7a8h|xn\\-\\-mgbayh7gpa|xn\\-\\-mgberp4a5d4ar|xn\\-\\-o3cw4h|xn\\-\\-p1ai|xn\\-\\-pgbs0dh|xn\\-\\-wgbh1c|xn\\-\\-wgbl6a|xn\\-\\-xkc2al3hye2a|xn\\-\\-ygbi2ammx|xn\\-\\-zckzah)""
        + ""|y[et]""
        + ""|z[amw])"";

    /**
     *  Regular expression pattern to match all IANA top-level domains.
     */
    public static final Pattern TOP_LEVEL_DOMAIN_PATTERN =
        Pattern.compile(TOP_LEVEL_DOMAIN_STR);


    /**
     * Goegular expression to match all IANA top-level domains for WEB_URL.
     *  List accurate as of 2011/01/12.  List taken from:
     *  http://data.iana.org/TLD/tlds-alpha-by-domain.txt
     *  This pattern is auto-generated by frameworks/base/common/tools/make-iana-tld-pattern.py
     */
    public static final String TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL =
        ""(?:""
        + ""(?:aero|arpa|asia|a[cdefgilmnoqrstuwxz])""
        + ""|(?:biz|b[abdefghijmnorstvwyz])""
        + ""|(?:cat|com|coop|c[acdfghiklmnoruvxyz])""
        + ""|d[ejkmoz]""
        + ""|(?:edu|e[cegrstu])""
        + ""|f[ijkmor]""
        + ""|(?:gov|g[abdefghilmnpqrstuwy])""
        + ""|h[kmnrtu]""
        + ""|(?:info|int|i[delmnoqrst])""
        + ""|(?:jobs|j[emop])""
        + ""|k[eghimnprwyz]""
        + ""|l[abcikrstuvy]""
        + ""|(?:mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])""
        + ""|(?:name|net|n[acefgilopruz])""
        + ""|(?:org|om)""
        + ""|(?:pro|p[aefghklmnrstwy])""
        + ""|qa""
        + ""|r[eosuw]""
        + ""|s[abcdeghijklmnortuvyz]""
        + ""|(?:tel|travel|t[cdfghjklmnoprtvwz])""
        + ""|u[agksyz]""
        + ""|v[aceginu]""
        + ""|w[fs]""
        + ""|(?:xn\\-\\-0zwm56d|xn\\-\\-11b5bs3a9aj6g|xn\\-\\-80akhbyknj4f|xn\\-\\-9t4b11yi5a|xn\\-\\-deba0ad|xn\\-\\-fiqs8s|xn\\-\\-fiqz9s|xn\\-\\-fzc2c9e2c|xn\\-\\-g6w251d|xn\\-\\-hgbk6aj7f53bba|xn\\-\\-hlcj6aya9esc7a|xn\\-\\-j6w193g|xn\\-\\-jxalpdlp|xn\\-\\-kgbechtv|xn\\-\\-kprw13d|xn\\-\\-kpry57d|xn\\-\\-mgbaam7a8h|xn\\-\\-mgbayh7gpa|xn\\-\\-mgberp4a5d4ar|xn\\-\\-o3cw4h|xn\\-\\-p1ai|xn\\-\\-pgbs0dh|xn\\-\\-wgbh1c|xn\\-\\-wgbl6a|xn\\-\\-xkc2al3hye2a|xn\\-\\-ygbi2ammx|xn\\-\\-zckzah)""
        + ""|y[et]""
        + ""|z[amw]))"";

    /* This comprises most common used Unicode characters allowed in IRI
    * as detailed in RFC 3987.
    * Specifically, those two byte Unicode characters are not included.
    */
    public static final String GOOD_IRI_CHAR =
        ""a-zA-Z0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF"";

    /**
     *  Regular expression pattern to match most part of RFC 3987
     *  Internationalized URLs, aka IRIs.  Commonly used Unicode characters are
     *  added.
     */
    public static final Pattern WEB_URL_PATTERN = Pattern.compile(
                ""((?:(http|https|Http|Https|rtsp|Rtsp):\\/\\/(?:(?:[a-zA-Z0-9\\$\\-\\_\\.\\+\\!\\*\\'\\(\\)""
                + ""\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,64}(?:\\:(?:[a-zA-Z0-9\\$\\-\\_""
                + ""\\.\\+\\!\\*\\'\\(\\)\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,25})?\\@)?)?""
                + ""((?:(?:["" + GOOD_IRI_CHAR + ""]["" + GOOD_IRI_CHAR + ""\\-]{0,64}\\.)+""   // named host
                + TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL
                + ""|(?:(?:25[0-5]|2[0-4]"" // or ip address
                + ""[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(?:25[0-5]|2[0-4][0-9]""
                + ""|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1]""
                + ""[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}""
                + ""|[1-9][0-9]|[0-9])))""
                + ""(?:\\:\\d{1,5})?)"" // plus option port number
                + ""(\\/(?:(?:["" + GOOD_IRI_CHAR + ""\\;\\/\\?\\:\\@\\&\\=\\#\\~""  // plus option query params
                + ""\\-\\.\\+\\!\\*\\'\\(\\)\\,\\_])|(?:\\%[a-fA-F0-9]{2}))*)?""
                + ""(?:\\b|$)""); // and finally, a word boundary or end of
    // input.  This is to stop foo.sure from
    // matching as foo.su

    public static final Pattern IP_ADDRESS_PATTERN
    = Pattern.compile(
          ""((25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(25[0-5]|2[0-4]""
          + ""[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]""
          + ""[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}""
          + ""|[1-9][0-9]|[0-9]))"");

    public static final Pattern DOMAIN_NAME_PATTERN
    = Pattern.compile(
          ""((((["" + GOOD_IRI_CHAR + ""]["" + GOOD_IRI_CHAR + ""\\-]*)*["" + GOOD_IRI_CHAR + ""]\\.)+""
          + TOP_LEVEL_DOMAIN_PATTERN + "")|""
          + IP_ADDRESS_PATTERN + "")"");

    public static final Pattern EMAIL_ADDRESS_PATTERN
    = Pattern.compile(
          ""[a-zA-Z0-9\\+\\.\\_\\%\\-\\+]{1,256}"" +
          ""\\@"" +
          ""[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}"" +
          ""("" +
          ""\\."" +
          ""[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25}"" +
          "")+""
      );

    /**
     * This pattern is intended for searching for things that look like they
     * might be phone numbers in arbitrary text, not for validating whether
     * something is in fact a phone number.  It will miss many things that
     * are legitimate phone numbers.
     *
     * <p> The pattern matches the following:
     * <ul>
     * <li>Optionally, a + sign followed immediately by one or more digits. Spaces, dots, or dashes
     * may follow.
     * <li>Optionally, sets of digits in parentheses, separated by spaces, dots, or dashes.
     * <li>A string starting and ending with a digit, containing digits, spaces, dots, and/or dashes.
     * </ul>
     */
    public static final Pattern PHONE_PATTERN
    = Pattern.compile(                                  // sdd = space, dot, or dash
          ""(\\+[0-9]+[\\- \\.]*)?""                    // +<digits><sdd>*
          + ""(\\([0-9]+\\)[\\- \\.]*)?""               // (<digits>)<sdd>*
          + ""([0-9][0-9\\- \\.][0-9\\- \\.]+[0-9])""); // <digit><digit|sdd>+<digit>

    /**
     *  Convenience method to take all of the non-null matching groups in a
     *  regex Matcher and return them as a concatenated string.
     *
     *  @param matcher      The Matcher object from which grouped text will
     *                      be extracted
     *
     *  @return             A String comprising all of the non-null matched
     *                      groups concatenated together
     */
    public static final String concatGroups(Matcher matcher) {
        StringBuilder b = new StringBuilder();
        final int numGroups = matcher.groupCount();

        for (int i = 1; i <= numGroups; i++) {
            String s = matcher.group(i);

            System.err.println(""Group("" + i + "") : "" + s);

            if (s != null) {
                b.append(s);
            }
        }

        return b.toString();
    }

    /**
     * Convenience method to return only the digits and plus signs
     * in the matching string.
     *
     * @param matcher      The Matcher object from which digits and plus will
     *                     be extracted
     *
     * @return             A String comprising all of the digits and plus in
     *                     the match
     */
    public static final String digitsAndPlusOnly(Matcher matcher) {
        StringBuilder buffer = new StringBuilder();
        String matchingRegion = matcher.group();

        for (int i = 0, size = matchingRegion.length(); i < size; i++) {
            char character = matchingRegion.charAt(i);

            if (character == '+' || Character.isDigit(character)) {
                buffer.append(character);
            }
        }
        return buffer.toString();
    }

}
",True,114,6,68,0,0,2,0,L1
39,com.fsck.k9.helper.FileBrowserHelper.java,"package com.fsck.k9.helper;

import java.io.File;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.ActivityNotFoundException;
import android.content.DialogInterface;
import android.content.Intent;
import android.net.Uri;
import android.text.InputType;
import android.widget.EditText;

import com.fsck.k9.K9;
import com.fsck.k9.R;

public class FileBrowserHelper {
    /**
     * A string array that specifies the name of the intent to use, and the scheme to use with it
     * when setting the data for the intent.
     */
    private static final String[][] PICK_DIRECTORY_INTENTS = {
        { ""org.openintents.action.PICK_DIRECTORY"", ""file://"" },   // OI File Manager (maybe others)
        { ""com.estrongs.action.PICK_DIRECTORY"", ""file://"" },      // ES File Explorer
        { Intent.ACTION_PICK, ""folder://"" },                      // Blackmoon File Browser (maybe others)
        { ""com.androidworkz.action.PICK_DIRECTORY"", ""file://"" }
    }; // SystemExplorer

    private static FileBrowserHelper sInstance;

    /**
     * callback class to provide the result of the fallback textedit path dialog
     */
    public interface FileBrowserFailOverCallback {
        /**
         * the user has entered a path
         * @param path the path as String
         */
        public void onPathEntered(String path);
        /**
         * the user has cancel the inputtext dialog
         */
        public void onCancel();
    }
    /**
     * factory method
     *
     */
    private FileBrowserHelper() {
    }
    public synchronized static FileBrowserHelper getInstance() {
        if (sInstance == null) {
            sInstance = new FileBrowserHelper();
        }
        return sInstance;
    }


    /**
     * tries to open known filebrowsers.
     * If no filebrowser is found and fallback textdialog is shown
     * @param c the context as activity
     * @param startPath: the default value, where the filebrowser will start.
     *      if startPath = null => the default path is used
     * @param requestcode: the int you will get as requestcode in onActivityResult
     *      (only used if there is a filebrowser installed)
     * @param callback: the callback (only used when no filebrowser is installed.
     *      if a filebrowser is installed => override the onActivtyResult Method
     *
     * @return true: if a filebrowser has been found (the result will be in the onActivityResult
     *          false: a fallback textinput has been shown. The Result will be sent with the callback method
     *
     *
     */
    public boolean showFileBrowserActivity(Activity c, File startPath, int requestcode, FileBrowserFailOverCallback callback) {
        boolean success = false;

        if (startPath == null) {
            startPath = new File(K9.getAttachmentDefaultPath());
        }

        int listIndex = 0;
        do {
            String intentAction = PICK_DIRECTORY_INTENTS[listIndex][0];
            String uriPrefix = PICK_DIRECTORY_INTENTS[listIndex][1];
            Intent intent = new Intent(intentAction);
            intent.setData(Uri.parse(uriPrefix + startPath.getPath()));

            try {
                c.startActivityForResult(intent, requestcode);
                success = true;
            } catch (ActivityNotFoundException e) {
                // Try the next intent in the list
                listIndex++;
            };
        } while (!success && (listIndex < PICK_DIRECTORY_INTENTS.length));

        if (listIndex == PICK_DIRECTORY_INTENTS.length) {
            //No Filebrowser is installed => show a fallback textdialog
            showPathTextInput(c, startPath, callback);
            success = false;
        }

        return success;
    }

    private void showPathTextInput(final Activity c, final File startPath, final FileBrowserFailOverCallback callback) {
        AlertDialog.Builder alert = new AlertDialog.Builder(c);

        alert.setTitle(c.getString(R.string.attachment_save_title));
        alert.setMessage(c.getString(R.string.attachment_save_desc));
        final EditText input = new EditText(c);
        input.setInputType(InputType.TYPE_CLASS_TEXT);
        if (startPath != null)
            input.setText(startPath.toString());
        alert.setView(input);

        alert.setPositiveButton(c.getString(R.string.okay_action), new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int whichButton) {
                String path = input.getText().toString();
                callback.onPathEntered(path);
            }
        });

        alert.setNegativeButton(c.getString(R.string.cancel_action),
        new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int whichButton) {
                callback.onCancel();
            }
        });

        alert.show();
    }
}
",True,144,0,0,7,55,2,1,L1
40,com.fsck.k9.helper.AutoSyncHelper.java,"package com.fsck.k9.helper;

import com.fsck.k9.K9;
import android.os.Build;
import android.util.Log;

/**
 * Helper class to get the current state of the auto-sync setting.
 */
public class AutoSyncHelper {
    /**
     * False, if we never tried to load the class for this SDK version.
     * True, otherwise.
     *
     * Note: if sAutoSync is null and sChecked is true, then an error occured
     * while loading the class for the SDK version we're running on.
     */
    private static boolean sChecked = false;

    /**
     * Instance of the SDK specific class that implements the IAutoSync
     * interface.
     */
    private static IAutoSync sAutoSync = null;

    /**
     * String for the auto-sync changed Intent.  This isn't currently exposed by the API
     */
    public static String SYNC_CONN_STATUS_CHANGE = ""com.android.sync.SYNC_CONN_STATUS_CHANGED"";
    /**
     * Try loading the class that implements IAutoSync for this SDK version.
     *
     * @return the IAutoSync object for this SDK version, or null if something
     *         went wrong.
     */
    private static IAutoSync loadAutoSync() {
        /*
         * We're trying to load the class for this SDK version. If anything
         * goes wrong after this point, we don't want to try again.
         */
        sChecked = true;

        /*
         * Check the version of the SDK we are running on. Choose an
         * implementation class designed for that version of the SDK.
         */
        int sdkVersion = Integer.parseInt(Build.VERSION.SDK);

        String className = null;
        if (sdkVersion == Build.VERSION_CODES.CUPCAKE) {
            className = ""com.fsck.k9.helper.AutoSyncSdk3"";
        } else if (sdkVersion == Build.VERSION_CODES.DONUT) {
            className = ""com.fsck.k9.helper.AutoSyncSdk4"";
        } else if (sdkVersion >= Build.VERSION_CODES.ECLAIR) {
            className = ""com.fsck.k9.helper.AutoSyncSdk5"";
        }

        /*
         * Find the required class by name and instantiate it.
         */
        try {
            Class <? extends IAutoSync > clazz =
                Class.forName(className).asSubclass(IAutoSync.class);

            IAutoSync autoSync = clazz.newInstance();
            autoSync.initialize(K9.app);

            return autoSync;
        } catch (ClassNotFoundException e) {
            Log.e(K9.LOG_TAG, ""Couldn't find class: "" + className, e);
        } catch (InstantiationException e) {
            Log.e(K9.LOG_TAG, ""Couldn't instantiate class: "" + className, e);
        } catch (IllegalAccessException e) {
            Log.e(K9.LOG_TAG, ""Couldn't access class: "" + className, e);
        } catch (NoSuchMethodException e) {
            if (K9.DEBUG) {
                Log.d(K9.LOG_TAG, ""Couldn't load method to get auto-sync state"", e);
            }
        }
        return null;
    }

    /**
     * Checks whether we can query the auto-sync state using
     * getMasterSyncAutomatically() or not.
     *
     * @return true, if calls to getMasterSyncAutomatically() will return the
     *         state of the auto-sync setting. false, otherwise.
     */
    public static boolean isAvailable() {
        if (!sChecked) {
            sAutoSync = loadAutoSync();
        }
        return (sAutoSync != null);
    }

    /**
     * Query the state of the auto-sync setting.
     *
     * @return the state of the auto-sync setting.
     * @see IAutoSync
     */
    public static boolean getMasterSyncAutomatically() {
        if (!sChecked) {
            sAutoSync = loadAutoSync();
        }

        if (sAutoSync == null) {
            throw new RuntimeException(
                ""Called getMasterSyncAutomatically() before checking if it's available."");
        }

        return sAutoSync.getMasterSyncAutomatically();
    }
}
",True,144,0,0,7,54,2,2,L1
41,com.fsck.k9.helper.Contacts.java,"package com.fsck.k9.helper;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import android.content.ContentResolver;
import android.content.Context;
import android.database.Cursor;
import android.os.Build;
import android.content.Intent;
import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.mail.Address;

/**
 * Helper class to access the contacts stored on the device. This is needed
 * because the original contacts API introduced with SDK 1 was deprecated with
 * SDK 5 and will eventually be removed in newer SDK versions.
 * A class that uses the latest contacts API available on the device will be
 * loaded at runtime.
 *
 * @see ContactsSdk3_4
 * @see ContactsSdk5
 */
public abstract class Contacts {
    /**
     * Instance of the SDK specific class that interfaces with the contacts
     * API.
     */
    private static Contacts sInstance = null;

    /**
     * Get SDK specific instance of the Contacts class.
     *
     * @param context A {@link Context} instance.
     * @return Appropriate {@link Contacts} instance for this device.
     */
    public static Contacts getInstance(Context context) {
        if (sInstance == null) {
            /*
             * Check the version of the SDK we are running on. Choose an
             * implementation class designed for that version of the SDK.
             */
            int sdkVersion = Integer.parseInt(Build.VERSION.SDK);

            String className = null;
            if (sdkVersion <= Build.VERSION_CODES.DONUT) {
                className = ""com.fsck.k9.helper.ContactsSdk3_4"";
            } else if (sdkVersion <= Build.VERSION_CODES.ECLAIR_MR1) {
                /*
                 * The new API was introduced with SDK 5. But Android versions < 2.2
                 * need some additional code to be able to search for phonetic names.
                 */
                className = ""com.fsck.k9.helper.ContactsSdk5p"";
            } else {
                className = ""com.fsck.k9.helper.ContactsSdk5"";
            }

            /*
             * Find the required class by name and instantiate it.
             */
            try {
                Class <? extends Contacts > clazz =
                    Class.forName(className).asSubclass(Contacts.class);

                Constructor <? extends Contacts > constructor = clazz.getConstructor(Context.class);
                sInstance = constructor.newInstance(context);
            } catch (ClassNotFoundException e) {
                Log.e(K9.LOG_TAG, ""Couldn't find class: "" + className, e);
            } catch (InstantiationException e) {
                Log.e(K9.LOG_TAG, ""Couldn't instantiate class: "" + className, e);
            } catch (IllegalAccessException e) {
                Log.e(K9.LOG_TAG, ""Couldn't access class: "" + className, e);
            } catch (NoSuchMethodException e) {
                Log.e(K9.LOG_TAG, ""Couldn't find constructor of class: "" + className, e);
            } catch (IllegalArgumentException e) {
                Log.e(K9.LOG_TAG, ""Wrong arguments for constructor of class: "" + className, e);
            } catch (InvocationTargetException e) {
                Log.e(K9.LOG_TAG, ""Couldn't invoke constructor of class: "" + className, e);
            }
        }

        return sInstance;
    }


    protected Context mContext;
    protected ContentResolver mContentResolver;
    protected Boolean mHasContactPicker;

    /**
     * Constructor
     *
     * @param context A {@link Context} instance.
     */
    protected Contacts(Context context) {
        mContext = context;
        mContentResolver = context.getContentResolver();
    }

    /**
     * Start the activity to add information to an existing contact or add a
     * new one.
     *
     * @param email An {@link Address} instance containing the email address
     *              of the entity you want to add to the contacts. Optionally
     *              the instance also contains the (display) name of that
     *              entity.
     */
    public abstract void createContact(Address email);

    /**
     * Check whether the provided email address belongs to one of the contacts.
     *
     * @param emailAddress The email address to look for.
     * @return <tt>true</tt>, if the email address belongs to a contact.
     *         <tt>false</tt>, otherwise.
     */
    public abstract boolean isInContacts(String emailAddress);

    /**
     * Filter the contacts matching the given search term.
     *
     * @param filter The search term to filter the contacts.
     * @return A {@link Cursor} instance that can be used to get the
     *         matching contacts.
     */
    public abstract Cursor searchContacts(CharSequence filter);

    /**
     * Get the name of the contact an email address belongs to.
     *
     * @param address The email address to search for.
     * @return The name of the contact the email address belongs to. Or
     *      <tt>null</tt> if there's no matching contact.
     */
    public abstract String getNameForAddress(String address);

    /**
     * Extract the name from a {@link Cursor} instance returned by
     * {@link #searchContacts(CharSequence)}.
     *
     * @param cursor The {@link Cursor} instance.
     * @return The name of the contact in the {@link Cursor}'s current row.
     */
    public abstract String getName(Cursor cursor);

    /**
     * Extract the email address from a {@link Cursor} instance returned by
     * {@link #searchContacts(CharSequence)}.
     *
     * @param cursor The {@link Cursor} instance.
     * @return The email address of the contact in the {@link Cursor}'s current
     *         row.
     */
    public abstract String getEmail(Cursor cursor);

    /**
     * Mark contacts with the provided email addresses as contacted.
     *
     * @param addresses Array of {@link Address} objects describing the
     *        contacts to be marked as contacted.
     */
    public abstract void markAsContacted(final Address[] addresses);

    /**
     * Creates the intent necessary to open a contact picker.
     *
     * @return The intent necessary to open a contact picker.
     */
    public abstract Intent contactPickerIntent();

    /**
     * Given a contact picker intent, returns the primary email address of that
     * contact.
     *
     * @param intent The {@link Intent} returned by this contact picker.
     * @return The primary email address of the picked contact.
     */
    public abstract String getEmailFromContactPicker(final Intent intent);

    /**
     * Does the device actually have a Contacts application suitable for
     * picking a contact. As hard as it is to believe, some vendors ship
     * without it.
     *
     * @return True, if the device supports picking contacts. False, otherwise.
     */
    public boolean hasContactPicker() {
        if (mHasContactPicker == null) {
            mHasContactPicker = (mContext.getPackageManager().
                                 queryIntentActivities(contactPickerIntent(), 0).size() > 0);
        }
        return mHasContactPicker;
    }
}
",True,147,1,3,7,54,9,2,L1
42,com.fsck.k9.helper.IAutoSync.java,"package com.fsck.k9.helper;

import android.content.Context;

/**
 * Classes that implement this interface know how to query the system for the
 * current state of the auto-sync setting. This method differs from SDK 3 to
 * SDK 5, so there are specialized implementations for each SDK version.
 */
public interface IAutoSync {
    /**
     * Do the necessary reflection magic to get the necessary objects and/or
     * methods to later query the state of the auto-sync setting.
     *
     * @param context The application context object.
     * @throws NoSuchMethodException if something went wrong.
     */
    public void initialize(Context context) throws NoSuchMethodException;

    /**
     * Query the state of the auto-sync setting.
     *
     * @return the state of the auto-sync setting.
     */
    public boolean getMasterSyncAutomatically();
}
",False,115,6,63,0,0,4,0,L0
43,com.fsck.k9.helper.AutoSyncSdk4.java,"package com.fsck.k9.helper;

import java.lang.reflect.Method;

import com.fsck.k9.K9;

import android.content.ContentResolver;
import android.content.Context;
import android.util.Log;

public class AutoSyncSdk4 implements IAutoSync {
    private Method mGetListenForNetworkTickles;
    private Object mContentService;

    public void initialize(Context context) throws NoSuchMethodException {
        /*
         * There's no documented/official way to query the state of the
         * auto-sync setting for a normal application in SDK 1.6/API 4.
         *
         * We use reflection to get an ContentService object, so we can call its
         * getListenForNetworkTickles() method. This will return the current
         * auto-sync state.
         */
        try {
            Method getContentService = ContentResolver.class.getMethod(""getContentService"");
            mContentService = getContentService.invoke(null);
            mGetListenForNetworkTickles = mContentService.getClass().getMethod(""getListenForNetworkTickles"");
        } catch (Exception e) {
            throw new NoSuchMethodException();
        }
    }

    public boolean getMasterSyncAutomatically() {
        try {
            return (Boolean) mGetListenForNetworkTickles.invoke(mContentService);
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Could not query for network tickle"", e);
            return true;
        }
    }
}
",True,145,0,0,7,55,0,2,L2
44,com.fsck.k9.helper.power.TracingPowerManager.java,"package com.fsck.k9.helper.power;

import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.atomic.AtomicInteger;

import com.fsck.k9.K9;
import android.content.Context;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Log;

public class TracingPowerManager {
    private final static boolean TRACE = false;
    public static AtomicInteger wakeLockId = new AtomicInteger(0);
    PowerManager pm = null;
    private static TracingPowerManager tracingPowerManager;
    private Timer timer = null;

    public static synchronized TracingPowerManager getPowerManager(Context context) {
        if (tracingPowerManager == null) {
            if (K9.DEBUG) {
                Log.v(K9.LOG_TAG, ""Creating TracingPowerManager"");
            }
            tracingPowerManager = new TracingPowerManager(context);
        }
        return tracingPowerManager;
    }


    private TracingPowerManager(Context context) {
        pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
        if (TRACE) {
            timer = new Timer();
        }
    }

    public TracingWakeLock newWakeLock(int flags, String tag) {
        return new TracingWakeLock(flags, tag);
    }
    public class TracingWakeLock {
        final WakeLock wakeLock;
        final int id;
        final String tag;
        volatile TimerTask timerTask;
        volatile Long startTime = null;
        volatile Long timeout = null;
        public TracingWakeLock(int flags, String ntag) {
            tag = ntag;
            wakeLock = pm.newWakeLock(flags, tag);
            id = wakeLockId.getAndIncrement();
            if (K9.DEBUG) {
                Log.v(K9.LOG_TAG, ""TracingWakeLock for tag "" + tag + "" / id "" + id + "": Create"");
            }
        }
        public void acquire(long timeout) {
            synchronized (wakeLock) {
                wakeLock.acquire(timeout);
            }
            if (K9.DEBUG) {
                Log.v(K9.LOG_TAG, ""TracingWakeLock for tag "" + tag + "" / id "" + id + "" for "" + timeout + "" ms: acquired"");
            }
            raiseNotification();
            if (startTime == null) {
                startTime = System.currentTimeMillis();
            }
            this.timeout = timeout;
        }
        public void acquire() {
            synchronized (wakeLock) {
                wakeLock.acquire();
            }
            raiseNotification();
            if (K9.DEBUG) {
                Log.w(K9.LOG_TAG, ""TracingWakeLock for tag "" + tag + "" / id "" + id + "": acquired with no timeout.  K-9 Mail should not do this"");
            }
            if (startTime == null) {
                startTime = System.currentTimeMillis();
            }
            timeout = null;
        }
        public void setReferenceCounted(boolean counted) {
            synchronized (wakeLock) {
                wakeLock.setReferenceCounted(counted);
            }
        }
        public void release() {
            if (startTime != null) {
                Long endTime = System.currentTimeMillis();
                if (K9.DEBUG) {
                    Log.v(K9.LOG_TAG, ""TracingWakeLock for tag "" + tag + "" / id "" + id + "": releasing after "" + (endTime - startTime) + "" ms, timeout = "" + timeout + "" ms"");
                }
            } else {
                if (K9.DEBUG) {
                    Log.v(K9.LOG_TAG, ""TracingWakeLock for tag "" + tag + "" / id "" + id + "", timeout = "" + timeout + "" ms: releasing"");
                }
            }
            cancelNotification();
            synchronized (wakeLock) {
                wakeLock.release();
            }
            startTime = null;
        }
        private void cancelNotification() {
            if (timer != null) {
                synchronized (timer) {
                    if (timerTask != null) {
                        timerTask.cancel();
                    }
                }
            }
        }
        private void raiseNotification() {
            if (timer != null) {
                synchronized (timer) {
                    if (timerTask != null) {
                        timerTask.cancel();
                        timerTask = null;
                    }
                    timerTask = new TimerTask() {
                        @Override
                        public void run() {
                            if (startTime != null) {
                                Long endTime = System.currentTimeMillis();
                                Log.i(K9.LOG_TAG, ""TracingWakeLock for tag "" + tag + "" / id "" + id + "": has been active for ""
                                      + (endTime - startTime) + "" ms, timeout = "" + timeout + "" ms"");

                            } else {
                                Log.i(K9.LOG_TAG, ""TracingWakeLock for tag "" + tag + "" / id "" + id + "": still active, timeout = "" + timeout + "" ms"");
                            }
                        }

                    };
                    timer.schedule(timerTask, 1000, 1000);
                }
            }
        }

    }
}
",True,144,0,0,7,54,9,1,L1
45,com.fsck.k9.activity.K9Activity.java,"package com.fsck.k9.activity;


import java.util.Locale;

import android.app.Activity;
import android.content.Context;
import android.content.res.Configuration;
import android.os.Bundle;
import android.view.GestureDetector;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.MotionEvent;
import android.view.View;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.TranslateAnimation;
import android.widget.ScrollView;
import com.fsck.k9.K9;
import com.fsck.k9.helper.DateFormatter;


public class K9Activity extends Activity {
    private GestureDetector gestureDetector;

    protected ScrollView mTopView;

    @Override
    public void onCreate(Bundle icicle) {
        onCreate(icicle, true);
    }

    public void onCreate(Bundle icicle, boolean useTheme) {
        setLanguage(this, K9.getK9Language());
        if (useTheme) {
            setTheme(K9.getK9Theme());
        }
        super.onCreate(icicle);
        setupFormats();

        // Gesture detection
        gestureDetector = new GestureDetector(new MyGestureDetector());

    }

    public static void setLanguage(Context context, String language) {
        Locale locale;
        if (language == null || language.equals("""")) {
            locale = Locale.getDefault();
        } else if (language.length() == 5 && language.charAt(2) == '_') {
            // language is in the form: en_US
            locale = new Locale(language.substring(0, 2), language.substring(3));
        } else {
            locale = new Locale(language);
        }
        Configuration config = new Configuration();
        config.locale = locale;
        context.getResources().updateConfiguration(config,
                context.getResources().getDisplayMetrics());
    }

    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        super.dispatchTouchEvent(ev);
        return gestureDetector.onTouchEvent(ev);
    }

    @Override
    public void onResume() {
        super.onResume();
        setupFormats();
    }

    private java.text.DateFormat mDateFormat;
    private java.text.DateFormat mTimeFormat;

    private void setupFormats() {

        mDateFormat = DateFormatter.getDateFormat(this);
        mTimeFormat = android.text.format.DateFormat.getTimeFormat(this);   // 12/24 date format
    }

    public java.text.DateFormat getTimeFormat() {
        return mTimeFormat;
    }

    public java.text.DateFormat getDateFormat() {
        return mDateFormat;
    }
    protected void onNext() {

    }
    protected void onPrevious() {
    }


    protected Animation inFromRightAnimation() {
        return slideAnimation(0.0f, +1.0f);
    }

    protected Animation outToLeftAnimation() {
        return slideAnimation(0.0f, -1.0f);
    }

    private Animation slideAnimation(float right, float left) {

        Animation slide = new TranslateAnimation(
            Animation.RELATIVE_TO_PARENT,  right, Animation.RELATIVE_TO_PARENT,  left,
            Animation.RELATIVE_TO_PARENT,  0.0f, Animation.RELATIVE_TO_PARENT,   0.0f
        );
        slide.setDuration(125);
        slide.setFillBefore(true);
        slide.setInterpolator(new AccelerateInterpolator());
        return slide;
    }

    class MyGestureDetector extends SimpleOnGestureListener {

        private static final float SWIPE_MIN_DISTANCE_DIP = 130.0f;
        private static final float SWIPE_MAX_OFF_PATH_DIP = 250f;
        private static final float SWIPE_THRESHOLD_VELOCITY_DIP = 325f;

        @Override
        public boolean onDoubleTap(MotionEvent ev) {
            super.onDoubleTap(ev);
            if (mTopView != null) {
                int height = getResources().getDisplayMetrics().heightPixels;
                if (ev.getRawY() < (height / 4)) {
                    mTopView.fullScroll(View.FOCUS_UP);

                } else if (ev.getRawY() > (height - height / 4)) {
                    mTopView.fullScroll(View.FOCUS_DOWN);

                }
            }
            return false;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            if (K9.gesturesEnabled()) {
                // Convert the dips to pixels
                final float mGestureScale = getResources().getDisplayMetrics().density;
                int min_distance = (int)(SWIPE_MIN_DISTANCE_DIP * mGestureScale + 0.5f);
                int min_velocity = (int)(SWIPE_THRESHOLD_VELOCITY_DIP * mGestureScale + 0.5f);
                int max_off_path = (int)(SWIPE_MAX_OFF_PATH_DIP * mGestureScale + 0.5f);


                try {
                    if (Math.abs(e1.getY() - e2.getY()) > max_off_path)
                        return false;
                    // right to left swipe
                    if (e1.getX() - e2.getX() > min_distance && Math.abs(velocityX) > min_velocity) {
                        onNext();
                    } else if (e2.getX() - e1.getX() > min_distance && Math.abs(velocityX) > min_velocity) {
                        onPrevious();
                    }
                } catch (Exception e) {
                    // nothing
                }
            }
            return false;
        }
    }


}
",True,144,0,0,7,54,14,2,L1
46,com.fsck.k9.activity.ChooseFolder.java,"
package com.fsck.k9.activity;

import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Filter;
import android.widget.ListView;
import android.widget.TextView;
import com.fsck.k9.*;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.MessagingException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class ChooseFolder extends K9ListActivity {
    String mFolder;
    String mSelectFolder;
    Account mAccount;
    MessageReference mMessageReference;
    ArrayAdapter<String> mAdapter;
    private ChooseFolderHandler mHandler = new ChooseFolderHandler();
    String heldInbox = null;
    boolean hideCurrentFolder = true;
    boolean showOptionNone = false;
    boolean showDisplayableOnly = false;

    /**
     * What folders to display.<br/>
     * Initialized to whatever is configured
     * but can be overridden via {@link #onOptionsItemSelected(MenuItem)}
     * while this activity is showing.
     */
    private Account.FolderMode mMode;
    /**
     * Current filter used by our ArrayAdapter.<br/>
     * Created on the fly and invalidated if a new
     * set of folders is chosen via {@link #onOptionsItemSelected(MenuItem)}
     */
    private FolderListFilter<String> myFilter = null;

    public static final String EXTRA_ACCOUNT = ""com.fsck.k9.ChooseFolder_account"";
    public static final String EXTRA_CUR_FOLDER = ""com.fsck.k9.ChooseFolder_curfolder"";
    public static final String EXTRA_SEL_FOLDER = ""com.fsck.k9.ChooseFolder_selfolder"";
    public static final String EXTRA_NEW_FOLDER = ""com.fsck.k9.ChooseFolder_newfolder"";
    public static final String EXTRA_MESSAGE = ""com.fsck.k9.ChooseFolder_message"";
    public static final String EXTRA_SHOW_CURRENT = ""com.fsck.k9.ChooseFolder_showcurrent"";
    public static final String EXTRA_SHOW_FOLDER_NONE = ""com.fsck.k9.ChooseFolder_showOptionNone"";
    public static final String EXTRA_SHOW_DISPLAYABLE_ONLY = ""com.fsck.k9.ChooseFolder_showDisplayableOnly"";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        getListView().setFastScrollEnabled(true);
        getListView().setItemsCanFocus(false);
        getListView().setChoiceMode(ListView.CHOICE_MODE_NONE);
        Intent intent = getIntent();
        String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mMessageReference = intent.getParcelableExtra(EXTRA_MESSAGE);
        mFolder = intent.getStringExtra(EXTRA_CUR_FOLDER);
        mSelectFolder = intent.getStringExtra(EXTRA_SEL_FOLDER);
        if (intent.getStringExtra(EXTRA_SHOW_CURRENT) != null) {
            hideCurrentFolder = false;
        }
        if (intent.getStringExtra(EXTRA_SHOW_FOLDER_NONE) != null) {
            showOptionNone = true;
        }
        if (intent.getStringExtra(EXTRA_SHOW_DISPLAYABLE_ONLY) != null) {
            showDisplayableOnly = true;
        }
        if (mFolder == null)
            mFolder = """";

        mAdapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1) {
            private Filter myFilter = null;

            @Override
            public Filter getFilter() {
                if (myFilter == null) {
                    myFilter = new FolderListFilter<String>(this);
                }
                return myFilter;
            }
        };

        setListAdapter(mAdapter);


        mMode = mAccount.getFolderTargetMode();
        MessagingController.getInstance(getApplication()).listFolders(mAccount, false, mListener);


        this.getListView().setOnItemClickListener(new AdapterView.OnItemClickListener() {
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                Intent intent = new Intent();
                intent.putExtra(EXTRA_ACCOUNT, mAccount.getUuid());
                intent.putExtra(EXTRA_CUR_FOLDER, mFolder);
                String destFolderName = (String)((TextView)view).getText();
                if (heldInbox != null && getString(R.string.special_mailbox_name_inbox).equals(destFolderName)) {
                    destFolderName = heldInbox;
                }
                intent.putExtra(EXTRA_NEW_FOLDER, destFolderName);
                intent.putExtra(EXTRA_MESSAGE, mMessageReference);
                setResult(RESULT_OK, intent);
                finish();
            }
        });

    }

    class ChooseFolderHandler extends Handler {

        private static final int MSG_PROGRESS = 2;

        private static final int MSG_DATA_CHANGED = 3;
        private static final int MSG_SET_SELECTED_FOLDER = 4;

        @Override
        public void handleMessage(android.os.Message msg) {
            switch (msg.what) {
            case MSG_PROGRESS:
                setProgressBarIndeterminateVisibility(msg.arg1 != 0);
                break;
            case MSG_DATA_CHANGED:
                mAdapter.notifyDataSetChanged();

                /*
                 * Only enable the text filter after the list has been
                 * populated to avoid possible race conditions because our
                 * FolderListFilter isn't really thread-safe.
                 */
                getListView().setTextFilterEnabled(true);
                break;
            case MSG_SET_SELECTED_FOLDER:
                getListView().setSelection(msg.arg1);
                break;
            }
        }

        public void progress(boolean progress) {
            android.os.Message msg = new android.os.Message();
            msg.what = MSG_PROGRESS;
            msg.arg1 = progress ? 1 : 0;
            sendMessage(msg);
        }

        public void setSelectedFolder(int position) {
            android.os.Message msg = new android.os.Message();
            msg.what = MSG_SET_SELECTED_FOLDER;
            msg.arg1 = position;
            sendMessage(msg);
        }

        public void dataChanged() {
            sendEmptyMessage(MSG_DATA_CHANGED);
        }
    }

    @Override public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.folder_select_option, menu);
        return true;
    }

    @Override public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {


        case R.id.display_1st_class: {
            setDisplayMode(FolderMode.FIRST_CLASS);
            return true;
        }
        case R.id.display_1st_and_2nd_class: {
            setDisplayMode(FolderMode.FIRST_AND_SECOND_CLASS);
            return true;
        }
        case R.id.display_not_second_class: {
            setDisplayMode(FolderMode.NOT_SECOND_CLASS);
            return true;
        }
        case R.id.display_all: {
            setDisplayMode(FolderMode.ALL);
            return true;
        }
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    private void setDisplayMode(FolderMode aMode) {
        mMode = aMode;
        // invalidate the current filter as it is working on an inval
        if (myFilter != null) {
            myFilter.invalidate();
        }
        //re-populate the list
        MessagingController.getInstance(getApplication()).listFolders(mAccount,
                false, mListener);
    }

    private MessagingListener mListener = new MessagingListener() {
        @Override
        public void listFoldersStarted(Account account) {
            if (!account.equals(mAccount)) {
                return;
            }
            mHandler.progress(true);
        }

        @Override
        public void listFoldersFailed(Account account, String message) {
            if (!account.equals(mAccount)) {
                return;
            }
            mHandler.progress(false);
        }

        @Override
        public void listFoldersFinished(Account account) {
            if (!account.equals(mAccount)) {
                return;
            }
            mHandler.progress(false);
        }
        @Override
        public void listFolders(Account account, Folder[] folders) {
            if (!account.equals(mAccount)) {
                return;
            }
            Account.FolderMode aMode = mMode;
            Preferences prefs = Preferences.getPreferences(getApplication().getApplicationContext());
            ArrayList<String> localFolders = new ArrayList<String>();

            for (Folder folder : folders) {
                String name = folder.getName();

                // Inbox needs to be compared case-insensitively
                if (hideCurrentFolder && (name.equals(mFolder) ||
                (mAccount.getInboxFolderName().equalsIgnoreCase(mFolder) && mAccount.getInboxFolderName().equalsIgnoreCase(name)))) {
                    continue;
                }
                try {
                    folder.refresh(prefs);
                    Folder.FolderClass fMode = folder.getDisplayClass();

                    if ((aMode == Account.FolderMode.FIRST_CLASS && fMode != Folder.FolderClass.FIRST_CLASS)
                            || (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
                                fMode != Folder.FolderClass.FIRST_CLASS &&
                                fMode != Folder.FolderClass.SECOND_CLASS)
                    || (aMode == Account.FolderMode.NOT_SECOND_CLASS && fMode == Folder.FolderClass.SECOND_CLASS)) {
                        continue;
                    }
                } catch (MessagingException me) {
                    Log.e(K9.LOG_TAG, ""Couldn't get prefs to check for displayability of folder "" + folder.getName(), me);
                }

                localFolders.add(folder.getName());

            }

            if (showOptionNone) {
                localFolders.add(K9.FOLDER_NONE);
            }

            Collections.sort(localFolders, new Comparator<String>() {
                public int compare(String aName, String bName) {
                    if (K9.FOLDER_NONE.equalsIgnoreCase(aName)) {
                        return -1;
                    }
                    if (K9.FOLDER_NONE.equalsIgnoreCase(bName)) {
                        return 1;
                    }
                    if (mAccount.getInboxFolderName().equalsIgnoreCase(aName)) {
                        return -1;
                    }
                    if (mAccount.getInboxFolderName().equalsIgnoreCase(bName)) {
                        return 1;
                    }

                    return aName.compareToIgnoreCase(bName);
                }
            });
            mAdapter.setNotifyOnChange(false);
            int selectedFolder = -1;
            try {
                mAdapter.clear();
                int position = 0;
                for (String name : localFolders) {
                    if (mAccount.getInboxFolderName().equalsIgnoreCase(name)) {
                        mAdapter.add(getString(R.string.special_mailbox_name_inbox));
                        heldInbox = name;
                    } else if (!K9.ERROR_FOLDER_NAME.equals(name) && !account.getOutboxFolderName().equals(name)) {
                        mAdapter.add(name);
                    }

                    if (mSelectFolder != null) {
                        /*
                         * Never select EXTRA_CUR_FOLDER (mFolder) if EXTRA_SEL_FOLDER
                         * (mSelectedFolder) was provided.
                         */

                        if (name.equals(mSelectFolder)) {
                            selectedFolder = position;
                        }
                    } else if (name.equals(mFolder) ||
                    (mAccount.getInboxFolderName().equalsIgnoreCase(mFolder) && mAccount.getInboxFolderName().equalsIgnoreCase(name))) {
                        selectedFolder = position;
                    }
                    position++;
                }
            } finally {
                mAdapter.setNotifyOnChange(true);
                runOnUiThread(new Runnable() {
                    public void run() {
                        //              runOnUiThread(
                        mAdapter.notifyDataSetChanged();
                    }
                });
            }

            mHandler.dataChanged();

            if (selectedFolder != -1) {
                mHandler.setSelectedFolder(selectedFolder);
            }
        }
    };
}
",False,144,0,0,6,47,3,10,L1
47,com.fsck.k9.activity.ProgressListener.java,"
package com.fsck.k9.activity;

import android.content.Context;

/**
 * A listener that the user can register for global, persistent progress events.
 */
public interface ProgressListener {
    /**
     * @param context
     * @param title
     * @param message
     * @param currentProgress
     * @param maxProgress
     * @param indeterminate
     */
    void showProgress(Context context, String title, String message, long currentProgress,
                      long maxProgress, boolean indeterminate);

    /**
     * @param context
     * @param title
     * @param message
     * @param currentProgress
     * @param maxProgress
     * @param indeterminate
     */
    void updateProgress(Context context, String title, String message, long currentProgress,
                        long maxProgress, boolean indeterminate);

    /**
     * @param context
     */
    void hideProgress(Context context);
}
",False,1,0,0,0,0,0,0,I0
48,com.fsck.k9.activity.K9ExpandableListActivity.java,"package com.fsck.k9.activity;

import android.app.ExpandableListActivity;
import android.os.Bundle;

import com.fsck.k9.K9;

/**
 * @see ExpandableListActivity
 */
public class K9ExpandableListActivity extends ExpandableListActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        setTheme(K9.getK9Theme());
        super.onCreate(savedInstanceState);
    }
}
",False,144,0,0,7,55,1,1,L1
49,com.fsck.k9.activity.K9ListActivity.java,"package com.fsck.k9.activity;

import android.app.ListActivity;
import android.util.Log;
import android.view.KeyEvent;
import android.widget.AdapterView;
import android.widget.ListView;
import android.os.Bundle;
import com.fsck.k9.K9;
import com.fsck.k9.helper.DateFormatter;

public class K9ListActivity extends ListActivity {
    @Override
    public void onCreate(Bundle icicle) {
        K9Activity.setLanguage(this, K9.getK9Language());
        setTheme(K9.getK9Theme());
        super.onCreate(icicle);
        setupFormats();
    }

    @Override
    public void onResume() {
        super.onResume();
        setupFormats();
    }

    private java.text.DateFormat mDateFormat;
    private java.text.DateFormat mTimeFormat;

    private void setupFormats() {
        mDateFormat = DateFormatter.getDateFormat(this);
        mTimeFormat = android.text.format.DateFormat.getTimeFormat(this);   // 12/24 date format
    }

    public java.text.DateFormat getTimeFormat() {
        return mTimeFormat;
    }

    public java.text.DateFormat getDateFormat() {
        return mDateFormat;
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        // Shortcuts that work no matter what is selected
        switch (keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP: {
            final ListView listView = getListView();
            if (K9.useVolumeKeysForListNavigationEnabled()) {
                int currentPosition = listView.getSelectedItemPosition();
                if (currentPosition == AdapterView.INVALID_POSITION || listView.isInTouchMode()) {
                    currentPosition = listView.getFirstVisiblePosition();
                }
                if (currentPosition > 0) {
                    listView.setSelection(currentPosition - 1);
                }
                return true;
            }
        }
        case KeyEvent.KEYCODE_VOLUME_DOWN: {
            final ListView listView = getListView();
            if (K9.useVolumeKeysForListNavigationEnabled()) {
                int currentPosition = listView.getSelectedItemPosition();
                if (currentPosition == AdapterView.INVALID_POSITION || listView.isInTouchMode()) {
                    currentPosition = listView.getFirstVisiblePosition();
                }

                if (currentPosition < listView.getCount()) {
                    listView.setSelection(currentPosition + 1);
                }
                return true;
            }
        }
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        // Swallow these events too to avoid the audible notification of a volume change
        if (K9.useVolumeKeysForListNavigationEnabled()) {
            if ((keyCode == KeyEvent.KEYCODE_VOLUME_UP) || (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN)) {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""Swallowed key up."");
                return true;
            }
        }
        return super.onKeyUp(keyCode, event);
    }
}
",False,145,1,1,7,54,6,3,L1
50,com.fsck.k9.activity.SearchModifier.java,"/**
 *
 */
package com.fsck.k9.activity;

import com.fsck.k9.R;
import com.fsck.k9.mail.Flag;

enum SearchModifier {
    FLAGGED(R.string.flagged_modifier, new Flag[] { Flag.FLAGGED}, null), UNREAD(R.string.unread_modifier, null, new Flag[] { Flag.SEEN});

    final int resId;
    final Flag[] requiredFlags;
    final Flag[] forbiddenFlags;

    SearchModifier(int nResId, Flag[] nRequiredFlags, Flag[] nForbiddenFlags) {
        resId = nResId;
        requiredFlags = nRequiredFlags;
        forbiddenFlags = nForbiddenFlags;
    }

}",False,114,6,61,1,1,2,1,L1
51,com.fsck.k9.activity.InsertableHtmlContent.java,"package com.fsck.k9.activity;

import java.io.Serializable;

/**
 * <p>Represents an HTML document with an insertion point for placing a reply. The quoted
 * document may have been modified to make it suitable for insertion. The modified quoted
 * document should be used in place of the original document.</p>
 *
 * <p>Changes to the user-generated inserted content should be done with {@link
 * #setUserContent(String)}.</p>
 *
 * TODO: This container should also have a text part, along with its insertion point.  Or maybe a generic InsertableContent and maintain one each for Html and Text?
 */
class InsertableHtmlContent implements Serializable {
    private static final long serialVersionUID = 2397327034L;
    // Default to a headerInsertionPoint at the beginning of the message.
    private int headerInsertionPoint = 0;
    private int footerInsertionPoint = 0;
    // Quoted message, if any.  headerInsertionPoint refers to a position in this string.
    private StringBuilder quotedContent = new StringBuilder();
    // User content (typically their reply or comments on a forward)
    private StringBuilder userContent = new StringBuilder();
    // Where to insert the content.  Default to top posting.
    private InsertionLocation insertionLocation = InsertionLocation.BEFORE_QUOTE;

    /**
     * Defines where user content should be inserted, either before or after quoted content.
     */
    public enum InsertionLocation {
        BEFORE_QUOTE, AFTER_QUOTE
    }

    public void setHeaderInsertionPoint(int headerInsertionPoint) {
        this.headerInsertionPoint = headerInsertionPoint;
    }

    public void setFooterInsertionPoint(int footerInsertionPoint) {
        this.footerInsertionPoint = footerInsertionPoint;
    }

    /**
     * Get the quoted content.
     * @return Quoted content.
     */
    public String getQuotedContent() {
        return quotedContent.toString();
    }

    /**
     * Set the quoted content.  The insertion point should be set against this content.
     * @param content
     */
    public void setQuotedContent(StringBuilder content) {
        this.quotedContent = content;
    }

    /**
     * <p>Insert something into the quoted content header. This is typically used for inserting
     * reply/forward headers into the quoted content rather than inserting the user-generated reply
     * content.</p>
     *
     * <p>Subsequent calls to {@link #insertIntoQuotedHeader(String)} will <b>prepend</b> text onto any
     * existing header and quoted content.</p>
     * @param content Content to add.
     */
    public void insertIntoQuotedHeader(final String content) {
        quotedContent.insert(headerInsertionPoint, content);
        // Update the location of the footer insertion point.
        footerInsertionPoint += content.length();
    }

    /**
     * <p>Insert something into the quoted content footer. This is typically used for inserting closing
     * tags of reply/forward headers rather than inserting the user-generated reply content.</p>
     *
     * <p>Subsequent calls to {@link #insertIntoQuotedFooter(String)} will <b>append</b> text onto any
     * existing footer and quoted content.</p>
     * @param content Content to add.
     */
    public void insertIntoQuotedFooter(final String content) {
        quotedContent.insert(footerInsertionPoint, content);
        // Update the location of the footer insertion point to the end of the inserted content.
        footerInsertionPoint += content.length();
    }

    /**
     * Remove all quoted content.
     */
    public void clearQuotedContent() {
        quotedContent.setLength(0);
        footerInsertionPoint = 0;
        headerInsertionPoint = 0;
    }

    /**
     * Set the inserted content to the specified content. Replaces anything currently in the
     * inserted content buffer.
     * @param content
     */
    public void setUserContent(final String content) {
        userContent = new StringBuilder(content);
    }

    /**
     * Configure where user content should be inserted, either before or after the quoted content.
     * @param insertionLocation Where to insert user content.
     */
    public void setInsertionLocation(final InsertionLocation insertionLocation) {
        this.insertionLocation = insertionLocation;
    }

    /**
     * Fetch the insertion point based upon the quote style.
     * @return Insertion point
     */
    public int getInsertionPoint() {
        if (insertionLocation == InsertionLocation.BEFORE_QUOTE) {
            return headerInsertionPoint;
        } else {
            return footerInsertionPoint;
        }
    }

    /**
     * Build the composed string with the inserted and original content.
     * @return Composed string.
     */
    @Override
    public String toString() {
        final int insertionPoint = getInsertionPoint();
        // Inserting and deleting was twice as fast as instantiating a new StringBuilder and
        // using substring() to build the new pieces.
        String result = quotedContent.insert(insertionPoint, userContent.toString()).toString();
        quotedContent.delete(insertionPoint, insertionPoint + userContent.length());
        return result;
    }

    /**
     * Return debugging information for this container.
     * @return Debug string.
     */
    public String toDebugString() {
        return ""InsertableHtmlContent{"" +
               ""headerInsertionPoint="" + headerInsertionPoint +
               "", footerInsertionPoint="" + footerInsertionPoint +
               "", insertionLocation="" + insertionLocation +
               "", quotedContent="" + quotedContent +
               "", userContent="" + userContent +
               "", compiledResult="" + toString() +
               '}';
    }
}
",False,113,5,74,0,0,1,0,L1
52,com.fsck.k9.activity.FolderList.java,"package com.fsck.k9.activity;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.PowerManager;
import android.util.Config;
import android.util.Log;
import android.util.TypedValue;
import android.view.*;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.View.OnClickListener;
import android.widget.*;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.AdapterView.OnItemClickListener;

import com.fsck.k9.*;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.activity.FolderInfoHolder;
import com.fsck.k9.activity.setup.Prefs;
import com.fsck.k9.activity.setup.AccountSettings;
import com.fsck.k9.activity.setup.FolderSettings;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.helper.SizeFormatter;
import com.fsck.k9.helper.power.TracingPowerManager;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.service.MailService;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;

/**
 * FolderList is the primary user interface for the program. This
 * Activity shows list of the Account's folders
 */

public class FolderList extends K9ListActivity {

    private static final int DIALOG_MARK_ALL_AS_READ = 1;

    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_INITIAL_FOLDER = ""initialFolder"";
    private static final String EXTRA_FROM_NOTIFICATION = ""fromNotification"";
    private static final String EXTRA_FROM_SHORTCUT = ""fromShortcut"";

    private static final boolean REFRESH_REMOTE = true;

    private ListView mListView;

    private FolderListAdapter mAdapter;

    private LayoutInflater mInflater;

    private Account mAccount;

    private FolderListHandler mHandler = new FolderListHandler();

    private int mUnreadMessageCount;

    private FontSizes mFontSizes = K9.getFontSizes();
    private Context context;

    class FolderListHandler extends Handler {

        public void refreshTitle() {
            runOnUiThread(new Runnable() {
                public void run() {
                    String dispString = mAdapter.mListener.formatHeader(FolderList.this,
                                        getString(R.string.folder_list_title, mAccount.getDescription()), mUnreadMessageCount, getTimeFormat());


                    setTitle(dispString);
                }
            });
        }


        public void newFolders(final List<FolderInfoHolder> newFolders) {
            runOnUiThread(new Runnable() {
                public void run() {
                    mAdapter.mFolders.clear();
                    mAdapter.mFolders.addAll(newFolders);
                    mAdapter.mFilteredFolders = mAdapter.mFolders;
                    mHandler.dataChanged();
                }
            });
        }

        public void workingAccount(final int res) {
            runOnUiThread(new Runnable() {
                public void run() {
                    String toastText = getString(res, mAccount.getDescription());
                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_SHORT);
                    toast.show();
                }
            });
        }

        public void accountSizeChanged(final long oldSize, final long newSize) {
            runOnUiThread(new Runnable() {
                public void run() {
                    String toastText = getString(R.string.account_size_changed, mAccount.getDescription(), SizeFormatter.formatSize(getApplication(), oldSize), SizeFormatter.formatSize(getApplication(), newSize));

                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
                    toast.show();
                }
            });
        }

        public void folderLoading(final String folder, final boolean loading) {
            runOnUiThread(new Runnable() {
                public void run() {
                    FolderInfoHolder folderHolder = mAdapter.getFolder(folder);


                    if (folderHolder != null) {
                        folderHolder.loading = loading;
                    }

                }
            });
        }

        public void progress(final boolean progress) {
            runOnUiThread(new Runnable() {
                public void run() {
                    setProgressBarIndeterminateVisibility(progress);
                }
            });

        }

        public void dataChanged() {
            runOnUiThread(new Runnable() {
                public void run() {
                    mAdapter.notifyDataSetChanged();
                }
            });
        }
    }

    /**
    * This class is responsible for reloading the list of local messages for a
    * given folder, notifying the adapter that the message have been loaded and
    * queueing up a remote update of the folder.
     */

    private void checkMail(FolderInfoHolder folder) {
        TracingPowerManager pm = TracingPowerManager.getPowerManager(this);
        final TracingWakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""FolderList checkMail"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(K9.WAKE_LOCK_TIMEOUT);
        MessagingListener listener = new MessagingListener() {
            @Override
            public void synchronizeMailboxFinished(Account account, String folder, int totalMessagesInMailbox, int numNewMessages) {
                if (!account.equals(mAccount)) {
                    return;
                }
                wakeLock.release();
            }

            @Override
            public void synchronizeMailboxFailed(Account account, String folder,
            String message) {
                if (!account.equals(mAccount)) {
                    return;
                }
                wakeLock.release();
            }
        };
        MessagingController.getInstance(getApplication()).synchronizeMailbox(mAccount, folder.name, listener, null);
        sendMail(mAccount);
    }

    public static Intent actionHandleAccountIntent(Context context, Account account) {
        return actionHandleAccountIntent(context, account, null, false);
    }

    public static Intent actionHandleAccountIntent(Context context, Account account, String initialFolder) {
        return actionHandleAccountIntent(context, account, initialFolder, false);
    }

    public static Intent actionHandleAccountIntent(Context context, Account account, String initialFolder, boolean fromShortcut) {
        Intent intent = new Intent(context, FolderList.class);
        intent.putExtra(EXTRA_ACCOUNT, account.getUuid());

        if (initialFolder != null) {
            intent.putExtra(EXTRA_INITIAL_FOLDER, initialFolder);
        }

        if (fromShortcut) {
            intent.putExtra(EXTRA_FROM_SHORTCUT, true);
        }

        return intent;
    }

    private static void actionHandleAccount(Context context, Account account, String initialFolder) {
        Intent intent = actionHandleAccountIntent(context, account, initialFolder);
        context.startActivity(intent);
    }

    public static void actionHandleAccount(Context context, Account account) {
        actionHandleAccount(context, account, null);
    }

    public static Intent actionHandleNotification(Context context, Account account, String initialFolder) {
        Intent intent = new Intent(
            Intent.ACTION_VIEW,
            Uri.parse(""email://accounts/"" + account.getAccountNumber()),
            context,
            FolderList.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.putExtra(EXTRA_ACCOUNT, account.getUuid());
        intent.putExtra(EXTRA_FROM_NOTIFICATION, true);

        if (initialFolder != null) {
            intent.putExtra(EXTRA_INITIAL_FOLDER, initialFolder);
        }
        return intent;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);

        setContentView(R.layout.folder_list);
        mListView = getListView();
        mListView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_INSET);
        mListView.setLongClickable(true);
        mListView.setFastScrollEnabled(true);
        mListView.setScrollingCacheEnabled(true);
        mListView.setOnItemClickListener(new OnItemClickListener() {
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                onOpenFolder(((FolderInfoHolder)mAdapter.getItem(position)).name);
            }
        });
        registerForContextMenu(mListView);

        mListView.setSaveEnabled(true);

        mInflater = getLayoutInflater();

        onNewIntent(getIntent());

        context = this;
    }

    @Override
    public void onNewIntent(Intent intent) {
        setIntent(intent); // onNewIntent doesn't autoset our ""internal"" intent

        String initialFolder;

        mUnreadMessageCount = 0;
        String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        if (mAccount == null) {
            // This shouldn't normally happen. But apparently it does. See issue 2261.
            finish();
            return;
        }

        initialFolder = intent.getStringExtra(EXTRA_INITIAL_FOLDER);
        boolean fromNotification = intent.getBooleanExtra(EXTRA_FROM_NOTIFICATION, false);
        if (fromNotification && mAccount.goToUnreadMessageSearch()) {
            MessagingController.getInstance(getApplication()).notifyAccountCancel(this, mAccount);
            openUnreadSearch(this, mAccount);
            finish();
        } else if (initialFolder != null && !K9.FOLDER_NONE.equals(initialFolder)) {
            onOpenFolder(initialFolder);
            finish();
        } else if (intent.getBooleanExtra(EXTRA_FROM_SHORTCUT, false) &&
                   !K9.FOLDER_NONE.equals(mAccount.getAutoExpandFolderName())) {
            onOpenFolder(mAccount.getAutoExpandFolderName());
            finish();
        } else {

            initializeActivityView();
        }
    }

    private void initializeActivityView() {
        mAdapter = new FolderListAdapter();
        restorePreviousData();

        setListAdapter(mAdapter);
        getListView().setTextFilterEnabled(mAdapter.getFilter() != null); // should never be false but better safe then sorry

        setTitle(mAccount.getDescription());

    }

    @SuppressWarnings(""unchecked"")
    private void restorePreviousData() {
        final Object previousData = getLastNonConfigurationInstance();

        if (previousData != null) {
            mAdapter.mFolders = (ArrayList<FolderInfoHolder>) previousData;
            mAdapter.mFilteredFolders = Collections.unmodifiableList(mAdapter.mFolders);
        }
    }


    @Override public Object onRetainNonConfigurationInstance() {
        return (mAdapter == null) ? null : mAdapter.mFolders;
    }

    @Override public void onPause() {
        super.onPause();
        MessagingController.getInstance(getApplication()).removeListener(mAdapter.mListener);
    }

    /**
    * On resume we refresh the folder list (in the background) and we refresh the
    * messages for any folder that is currently open. This guarantees that things
    * like unread message count and read status are updated.
     */
    @Override public void onResume() {
        super.onResume();

        if (!mAccount.isAvailable(this)) {
            Log.i(K9.LOG_TAG, ""account unavaliabale, not showing folder-list but account-list"");
            startActivity(new Intent(this, Accounts.class));
            finish();
            return;
        }
        if (mAdapter == null)
            initializeActivityView();

        MessagingController.getInstance(getApplication()).addListener(mAdapter.mListener);
        //mAccount.refresh(Preferences.getPreferences(this));
        MessagingController.getInstance(getApplication()).getAccountStats(this, mAccount, mAdapter.mListener);

        onRefresh(!REFRESH_REMOTE);

        MessagingController.getInstance(getApplication()).notifyAccountCancel(this, mAccount);
    }


    @Override
    public void onBackPressed() {
        // This will be called either automatically for you on 2.0
        // or later, or by the code above on earlier versions of the
        // platform.
        if (K9.manageBack()) {
            onAccounts();
        } else {
            // TODO - when we move to android 2.0, uncomment this instead.
            // super.onBackPressed()
            finish();
        }
    }

    @Override public boolean onKeyDown(int keyCode, KeyEvent event) {
        //Shortcuts that work no matter what is selected

        if (
            // TODO - when we move to android 2.0, uncomment this.
            // android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.ECLAIR &&

            keyCode == KeyEvent.KEYCODE_BACK
            && event.getRepeatCount() == 0
            && K9.manageBack()) {
            // Take care of calling this method on earlier versions of
            // the platform where it doesn't exist.
            onBackPressed();
            return true;
        }


        switch (keyCode) {
        case KeyEvent.KEYCODE_Q:
            //case KeyEvent.KEYCODE_BACK:
        {
            onAccounts();
            return true;
        }

        case KeyEvent.KEYCODE_S: {
            onEditAccount();
            return true;
        }

        case KeyEvent.KEYCODE_H: {
            Toast toast = Toast.makeText(this, R.string.folder_list_help_key, Toast.LENGTH_LONG);
            toast.show();
            return true;
        }

        case KeyEvent.KEYCODE_1: {
            setDisplayMode(FolderMode.FIRST_CLASS);
            return true;
        }
        case KeyEvent.KEYCODE_2: {
            setDisplayMode(FolderMode.FIRST_AND_SECOND_CLASS);
            return true;
        }
        case KeyEvent.KEYCODE_3: {
            setDisplayMode(FolderMode.NOT_SECOND_CLASS);
            return true;
        }
        case KeyEvent.KEYCODE_4: {
            setDisplayMode(FolderMode.ALL);
            return true;
        }
        }//switch


        return super.onKeyDown(keyCode, event);
    }//onKeyDown

    private void setDisplayMode(FolderMode newMode) {
        mAccount.setFolderDisplayMode(newMode);
        mAccount.save(Preferences.getPreferences(this));
        if (mAccount.getFolderPushMode() != FolderMode.NONE) {
            MailService.actionRestartPushers(this, null);
        }
        onRefresh(false);
    }


    private void onRefresh(final boolean forceRemote) {

        MessagingController.getInstance(getApplication()).listFolders(mAccount, forceRemote, mAdapter.mListener);

    }

    private void onEditPrefs() {
        Prefs.actionPrefs(this);
    }
    private void onEditAccount() {
        AccountSettings.actionSettings(this, mAccount);
    }

    private void onEditFolder(Account account, String folderName) {
        FolderSettings.actionSettings(this, account, folderName);
    }

    private void onAccounts() {
        Accounts.listAccounts(this);
        finish();
    }

    private void onEmptyTrash(final Account account) {
        mHandler.dataChanged();

        MessagingController.getInstance(getApplication()).emptyTrash(account, null);
    }

    private void onExpunge(final Account account, String folderName) {
        MessagingController.getInstance(getApplication()).expunge(account, folderName, null);
    }


    private void onClearFolder(Account account, String folderName) {
        // There has to be a cheaper way to get at the localFolder object than this
        LocalFolder localFolder = null;
        try {
            if (account == null || folderName == null || !account.isAvailable(FolderList.this)) {
                Log.i(K9.LOG_TAG, ""not clear folder of unavailable account"");
                return;
            }
            localFolder = account.getLocalStore().getFolder(folderName);
            localFolder.open(Folder.OpenMode.READ_WRITE);
            localFolder.clearAllMessages();
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Exception while clearing folder"", e);
        } finally {
            if (localFolder != null) {
                localFolder.close();
            }
        }

        onRefresh(!REFRESH_REMOTE);
    }





    private void sendMail(Account account) {
        MessagingController.getInstance(getApplication()).sendPendingMessages(account, mAdapter.mListener);
    }

    @Override public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.compose:
            MessageCompose.actionCompose(this, mAccount);

            return true;

        case R.id.check_mail:
            MessagingController.getInstance(getApplication()).checkMail(this, mAccount, true, true, mAdapter.mListener);

            return true;

        case R.id.send_messages:
            MessagingController.getInstance(getApplication()).sendPendingMessages(mAccount, null);
            return true;
        case R.id.accounts:
            onAccounts();

            return true;

        case R.id.list_folders:
            onRefresh(REFRESH_REMOTE);

            return true;

        case R.id.account_settings:
            onEditAccount();

            return true;

        case R.id.app_settings:
            onEditPrefs();

            return true;

        case R.id.empty_trash:
            onEmptyTrash(mAccount);

            return true;

        case R.id.compact:
            onCompact(mAccount);

            return true;

        case R.id.display_1st_class: {
            setDisplayMode(FolderMode.FIRST_CLASS);
            return true;
        }
        case R.id.display_1st_and_2nd_class: {
            setDisplayMode(FolderMode.FIRST_AND_SECOND_CLASS);
            return true;
        }
        case R.id.display_not_second_class: {
            setDisplayMode(FolderMode.NOT_SECOND_CLASS);
            return true;
        }
        case R.id.display_all: {
            setDisplayMode(FolderMode.ALL);
            return true;
        }
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    private void onOpenFolder(String folder) {
        MessageList.actionHandleFolder(this, mAccount, folder);
        if (K9.manageBack()) {
            finish();
        }
    }

    private void onCompact(Account account) {
        mHandler.workingAccount(R.string.compacting_account);
        MessagingController.getInstance(getApplication()).compact(account, null);
    }

    @Override public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.folder_list_option, menu);
        return true;
    }

    @Override public boolean onContextItemSelected(MenuItem item) {
        AdapterContextMenuInfo info = (AdapterContextMenuInfo) item .getMenuInfo();
        FolderInfoHolder folder = (FolderInfoHolder) mAdapter.getItem(info.position);

        switch (item.getItemId()) {
        case R.id.open_folder:
            onOpenFolder(folder.name);
            break;

        case R.id.mark_all_as_read:
            onMarkAllAsRead(mAccount, folder.name);
            break;

        case R.id.send_messages:
            sendMail(mAccount);

            break;

        case R.id.check_mail:
            checkMail(folder);

            break;

        case R.id.folder_settings:
            onEditFolder(mAccount, folder.name);

            break;

        case R.id.empty_trash:
            onEmptyTrash(mAccount);

            break;
        case R.id.expunge:
            onExpunge(mAccount, folder.name);

            break;

        case R.id.clear_local_folder:
            onClearFolder(mAccount, folder.name);
            break;
        }

        return super.onContextItemSelected(item);
    }

    private FolderInfoHolder mSelectedContextFolder = null;


    private void onMarkAllAsRead(final Account account, final String folder) {
        mSelectedContextFolder = mAdapter.getFolder(folder);
        if (K9.confirmMarkAllAsRead()) {
            showDialog(DIALOG_MARK_ALL_AS_READ);
        } else {
            markAllAsRead();
        }
    }

    private void markAllAsRead() {
        try {
            MessagingController.getInstance(getApplication())
            .markAllMessagesRead(mAccount, mSelectedContextFolder.name);
            mSelectedContextFolder.unreadMessageCount = 0;
            mHandler.dataChanged();
        } catch (Exception e) {
            /* Ignore */
        }
    }

    @Override
    public Dialog onCreateDialog(int id) {
        switch (id) {
        case DIALOG_MARK_ALL_AS_READ:
            return ConfirmationDialog.create(this, id,
                                             R.string.mark_all_as_read_dlg_title,
                                             getString(R.string.mark_all_as_read_dlg_instructions_fmt,
                                                     mSelectedContextFolder.displayName),
                                             R.string.okay_action,
                                             R.string.cancel_action,
            new Runnable() {
                @Override
                public void run() {
                    markAllAsRead();
                }
            });
        }

        return super.onCreateDialog(id);
    }

    @Override
    public void onPrepareDialog(int id, Dialog dialog) {
        switch (id) {
        case DIALOG_MARK_ALL_AS_READ:
            ((AlertDialog)dialog).setMessage(getString(R.string.mark_all_as_read_dlg_instructions_fmt,
                                             mSelectedContextFolder.displayName));

            break;

        default:
            super.onPrepareDialog(id, dialog);
        }
    }

    @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);
        AdapterContextMenuInfo info = (AdapterContextMenuInfo) menuInfo;
        getMenuInflater().inflate(R.menu.folder_context, menu);

        FolderInfoHolder folder = (FolderInfoHolder) mAdapter.getItem(info.position);

        menu.setHeaderTitle(folder.displayName);

        if (!folder.name.equals(mAccount.getTrashFolderName()))
            menu.findItem(R.id.empty_trash).setVisible(false);

        if (folder.name.equals(mAccount.getOutboxFolderName())) {
            menu.findItem(R.id.check_mail).setVisible(false);
        } else {
            menu.findItem(R.id.send_messages).setVisible(false);
        }
        if (K9.ERROR_FOLDER_NAME.equals(folder.name)) {
            menu.findItem(R.id.expunge).setVisible(false);
        }

        menu.setHeaderTitle(folder.displayName);
    }

    class FolderListAdapter extends BaseAdapter implements Filterable {
        private ArrayList<FolderInfoHolder> mFolders = new ArrayList<FolderInfoHolder>();
        private List<FolderInfoHolder> mFilteredFolders = Collections.unmodifiableList(mFolders);
        private Filter mFilter = new FolderListFilter();

        public Object getItem(long position) {
            return getItem((int)position);
        }

        public Object getItem(int position) {
            return mFilteredFolders.get(position);
        }


        public long getItemId(int position) {
            return mFilteredFolders.get(position).folder.getName().hashCode() ;
        }

        public int getCount() {
            return mFilteredFolders.size();
        }

        @Override
        public boolean isEnabled(int item) {
            return true;
        }

        @Override
        public boolean areAllItemsEnabled() {
            return true;
        }

        private ActivityListener mListener = new ActivityListener() {
            @Override
            public void informUserOfStatus() {
                mHandler.refreshTitle();
            }
            @Override
            public void accountStatusChanged(BaseAccount account, AccountStats stats) {
                if (!account.equals(mAccount)) {
                    return;
                }
                if (stats == null) {
                    return;
                }
                mUnreadMessageCount = stats.unreadMessageCount;
                super.accountStatusChanged(account, stats);
            }

            @Override
            public void listFoldersStarted(Account account) {
                if (account.equals(mAccount)) {
                    mHandler.progress(true);
                }
                super.listFoldersStarted(account);

            }

            @Override
            public void listFoldersFailed(Account account, String message) {
                if (account.equals(mAccount)) {

                    mHandler.progress(false);

                    if (Config.LOGV) {
                        Log.v(K9.LOG_TAG, ""listFoldersFailed "" + message);
                    }
                }
                super.listFoldersFailed(account, message);
            }

            @Override
            public void listFoldersFinished(Account account) {
                if (account.equals(mAccount)) {

                    mHandler.progress(false);
                    MessagingController.getInstance(getApplication()).refreshListener(mAdapter.mListener);
                    mHandler.dataChanged();
                }
                super.listFoldersFinished(account);

            }

            @Override
            public void listFolders(Account account, Folder[] folders) {
                if (account.equals(mAccount)) {

                    List<FolderInfoHolder> newFolders = new LinkedList<FolderInfoHolder>();
                    List<FolderInfoHolder> topFolders = new LinkedList<FolderInfoHolder>();

                    Account.FolderMode aMode = account.getFolderDisplayMode();
                    Preferences prefs = Preferences.getPreferences(getApplication().getApplicationContext());
                    for (Folder folder : folders) {
                        try {
                            folder.refresh(prefs);

                            Folder.FolderClass fMode = folder.getDisplayClass();

                            if ((aMode == Account.FolderMode.FIRST_CLASS && fMode != Folder.FolderClass.FIRST_CLASS)
                                    || (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
                                        fMode != Folder.FolderClass.FIRST_CLASS &&
                                        fMode != Folder.FolderClass.SECOND_CLASS)
                            || (aMode == Account.FolderMode.NOT_SECOND_CLASS && fMode == Folder.FolderClass.SECOND_CLASS)) {
                                continue;
                            }
                        } catch (MessagingException me) {
                            Log.e(K9.LOG_TAG, ""Couldn't get prefs to check for displayability of folder "" + folder.getName(), me);
                        }

                        FolderInfoHolder holder = null;

                        int folderIndex = getFolderIndex(folder.getName());
                        if (folderIndex >= 0) {
                            holder = (FolderInfoHolder) getItem(folderIndex);
                        }
                        int unreadMessageCount = 0;
                        try {
                            unreadMessageCount  = folder.getUnreadMessageCount();
                        } catch (Exception e) {
                            Log.e(K9.LOG_TAG, ""Unable to get unreadMessageCount for "" + mAccount.getDescription() + "":""
                                  + folder.getName());
                        }

                        if (holder == null) {
                            holder = new FolderInfoHolder(context, folder, mAccount, unreadMessageCount);
                        } else {
                            holder.populate(context, folder, mAccount, unreadMessageCount);

                        }
                        if (folder.isInTopGroup()) {
                            topFolders.add(holder);
                        } else {
                            newFolders.add(holder);
                        }
                    }
                    Collections.sort(newFolders);
                    Collections.sort(topFolders);
                    topFolders.addAll(newFolders);
                    mHandler.newFolders(topFolders);
                }
                super.listFolders(account, folders);
            }

            @Override
            public void synchronizeMailboxStarted(Account account, String folder) {
                super.synchronizeMailboxStarted(account, folder);
                if (account.equals(mAccount)) {

                    mHandler.progress(true);
                    mHandler.folderLoading(folder, true);
                    mHandler.dataChanged();
                }

            }

            @Override
            public void synchronizeMailboxFinished(Account account, String folder, int totalMessagesInMailbox, int numNewMessages) {
                super.synchronizeMailboxFinished(account, folder, totalMessagesInMailbox, numNewMessages);
                if (account.equals(mAccount)) {
                    mHandler.progress(false);
                    mHandler.folderLoading(folder, false);

                    refreshFolder(account, folder);
                }

            }

            private void refreshFolder(Account account, String folderName) {
                // There has to be a cheaper way to get at the localFolder object than this
                Folder localFolder = null;
                try {
                    if (account != null && folderName != null) {
                        if (!account.isAvailable(FolderList.this)) {
                            Log.i(K9.LOG_TAG, ""not refreshing folder of unavailable account"");
                            return;
                        }
                        localFolder = account.getLocalStore().getFolder(folderName);
                        int unreadMessageCount = localFolder.getUnreadMessageCount();
                        FolderInfoHolder folderHolder = getFolder(folderName);
                        if (folderHolder != null) {
                            folderHolder.populate(context, localFolder, mAccount, unreadMessageCount);
                            mHandler.dataChanged();
                        }
                    }
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Exception while populating folder"", e);
                } finally {
                    if (localFolder != null) {
                        localFolder.close();
                    }
                }

            }

            @Override
            public void synchronizeMailboxFailed(Account account, String folder, String message) {
                super.synchronizeMailboxFailed(account, folder, message);
                if (!account.equals(mAccount)) {
                    return;
                }


                mHandler.progress(false);

                mHandler.folderLoading(folder, false);

                //   String mess = truncateStatus(message);

                //   mHandler.folderStatus(folder, mess);
                FolderInfoHolder holder = getFolder(folder);

                if (holder != null) {
                    holder.lastChecked = 0;
                }

                mHandler.dataChanged();

            }

            @Override
            public void setPushActive(Account account, String folderName, boolean enabled) {
                if (!account.equals(mAccount)) {
                    return;
                }
                FolderInfoHolder holder = getFolder(folderName);

                if (holder != null) {
                    holder.pushActive = enabled;

                    mHandler.dataChanged();
                }
            }


            @Override
            public void messageDeleted(Account account, String folder, Message message) {
                synchronizeMailboxRemovedMessage(account, folder, message);
            }

            @Override
            public void emptyTrashCompleted(Account account) {
                if (account.equals(mAccount)) {
                    refreshFolder(account, mAccount.getTrashFolderName());
                }
            }

            @Override
            public void folderStatusChanged(Account account, String folderName, int unreadMessageCount) {
                if (account.equals(mAccount)) {
                    refreshFolder(account, folderName);
                }
            }

            @Override
            public void sendPendingMessagesCompleted(Account account) {
                super.sendPendingMessagesCompleted(account);
                if (account.equals(mAccount)) {
                    refreshFolder(account, mAccount.getOutboxFolderName());
                }
            }

            @Override
            public void sendPendingMessagesStarted(Account account) {
                super.sendPendingMessagesStarted(account);

                if (account.equals(mAccount)) {
                    mHandler.dataChanged();
                }
            }

            @Override
            public void sendPendingMessagesFailed(Account account) {
                super.sendPendingMessagesFailed(account);
                if (account.equals(mAccount)) {
                    refreshFolder(account, mAccount.getOutboxFolderName());
                }
            }

            @Override
            public void accountSizeChanged(Account account, long oldSize, long newSize) {
                if (account.equals(mAccount)) {
                    mHandler.accountSizeChanged(oldSize, newSize);
                }
            }
        };


        public int getFolderIndex(String folder) {
            FolderInfoHolder searchHolder = new FolderInfoHolder();
            searchHolder.name = folder;
            return   mFilteredFolders.indexOf(searchHolder);
        }

        public FolderInfoHolder getFolder(String folder) {
            FolderInfoHolder holder = null;

            int index = getFolderIndex(folder);
            if (index >= 0) {
                holder = (FolderInfoHolder) getItem(index);
                if (holder != null) {
                    return holder;
                }
            }
            return null;
        }

        public View getView(int position, View convertView, ViewGroup parent) {
            if (position <= getCount()) {
                return  getItemView(position, convertView, parent);
            } else {
                Log.e(K9.LOG_TAG, ""getView with illegal positon="" + position
                      + "" called! count is only "" + getCount());
                return null;
            }
        }

        public View getItemView(int itemPosition, View convertView, ViewGroup parent) {
            FolderInfoHolder folder = (FolderInfoHolder) getItem(itemPosition);
            View view;
            if (convertView != null) {
                view = convertView;
            } else {
                view = mInflater.inflate(R.layout.folder_list_item, parent, false);
            }

            FolderViewHolder holder = (FolderViewHolder) view.getTag();

            if (holder == null) {
                holder = new FolderViewHolder();
                holder.folderName = (TextView) view.findViewById(R.id.folder_name);
                holder.newMessageCount = (TextView) view.findViewById(R.id.folder_unread_message_count);
                holder.flaggedMessageCount = (TextView) view.findViewById(R.id.folder_flagged_message_count);
                holder.folderStatus = (TextView) view.findViewById(R.id.folder_status);
                holder.activeIcons = (RelativeLayout) view.findViewById(R.id.active_icons);
                holder.chip = view.findViewById(R.id.chip);
                holder.folderListItemLayout = (LinearLayout)view.findViewById(R.id.folder_list_item_layout);
                holder.rawFolderName = folder.name;

                view.setTag(holder);
            }

            if (folder == null) {
                return view;
            }

            holder.folderName.setText(folder.displayName);
            String statusText = """";

            if (folder.loading) {
                statusText = getString(R.string.status_loading);
            } else if (folder.status != null) {
                statusText = folder.status;
            } else if (folder.lastChecked != 0) {
                Date lastCheckedDate = new Date(folder.lastChecked);

                statusText = getTimeFormat().format(lastCheckedDate) + "" "" +
                             getDateFormat().format(lastCheckedDate);
            }

            if (folder.pushActive) {
                statusText = getString(R.string.folder_push_active_symbol) + "" "" + statusText;
            }

            if (statusText != null) {
                holder.folderStatus.setText(statusText);
                holder.folderStatus.setVisibility(View.VISIBLE);
            } else {
                holder.folderStatus.setText(null);
                holder.folderStatus.setVisibility(View.GONE);
            }

            if (folder.unreadMessageCount != 0) {
                holder.newMessageCount.setText(Integer
                                               .toString(folder.unreadMessageCount));
                holder.newMessageCount.setOnClickListener(new FolderClickListener(mAccount, folder.name, folder.displayName, SearchModifier.UNREAD));
                holder.newMessageCount.setVisibility(View.VISIBLE);
            } else {
                holder.newMessageCount.setVisibility(View.GONE);
            }

            if (K9.messageListStars() && folder.flaggedMessageCount > 0) {
                holder.flaggedMessageCount.setText(Integer
                                                   .toString(folder.flaggedMessageCount));
                holder.flaggedMessageCount.setOnClickListener(new FolderClickListener(mAccount, folder.name, folder.displayName, SearchModifier.FLAGGED));
                holder.flaggedMessageCount.setVisibility(View.VISIBLE);
            } else {
                holder.flaggedMessageCount.setVisibility(View.GONE);
            }
            if (K9.useCompactLayouts() && holder.folderListItemLayout != null) {
                holder.folderListItemLayout.setMinimumHeight(0);
            }
            holder.activeIcons.setOnClickListener(new OnClickListener() {
                public void onClick(View v) {
                    Toast toast = Toast.makeText(getApplication(), getString(R.string.tap_hint), Toast.LENGTH_SHORT);
                    toast.show();
                }
            }
                                                 );

            holder.chip.setBackgroundDrawable(mAccount.generateColorChip().drawable());
            holder.chip.getBackground().setAlpha(folder.unreadMessageCount == 0 ? 127 : 255);

            holder.folderName.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getFolderName());
            holder.folderStatus.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getFolderStatus());


            return view;
        }

        @Override
        public boolean hasStableIds() {
            return true;
        }

        public boolean isItemSelectable(int position) {
            return true;
        }

        public void setFilter(final Filter filter) {
            this.mFilter = filter;
        }

        public Filter getFilter() {
            return mFilter;
        }

        /**
         * Filter to search for occurences of the search-expression in any place of the
         * folder-name instead of doing jsut a prefix-search.
         *
         * @author Marcus@Wolschon.biz
         */
        public class FolderListFilter extends Filter {

            /**
             * Do the actual search.
             * {@inheritDoc}
             *
             * @see #publishResults(CharSequence, FilterResults)
             */
            @Override
            protected FilterResults performFiltering(CharSequence searchTerm) {
                FilterResults results = new FilterResults();

                if ((searchTerm == null) || (searchTerm.length() == 0)) {
                    ArrayList<FolderInfoHolder> list = new ArrayList<FolderInfoHolder>(mFolders);
                    results.values = list;
                    results.count = list.size();
                } else {
                    final String searchTermString = searchTerm.toString().toLowerCase();
                    final String[] words = searchTermString.split("" "");
                    final int wordCount = words.length;

                    final ArrayList<FolderInfoHolder> newValues = new ArrayList<FolderInfoHolder>();

                    for (final FolderInfoHolder value : mFolders) {
                        if (value.displayName == null) {
                            continue;
                        }
                        final String valueText = value.displayName.toLowerCase();

                        for (int k = 0; k < wordCount; k++) {
                            if (valueText.contains(words[k])) {
                                newValues.add(value);
                                break;
                            }
                        }
                    }

                    results.values = newValues;
                    results.count = newValues.size();
                }

                return results;
            }

            /**
             * Publish the results to the user-interface.
             * {@inheritDoc}
             */
            @SuppressWarnings(""unchecked"")
            @Override
            protected void publishResults(CharSequence constraint, FilterResults results) {
                //noinspection unchecked
                mFilteredFolders = Collections.unmodifiableList((ArrayList<FolderInfoHolder>) results.values);
                // Send notification that the data set changed now
                notifyDataSetChanged();
            }
        }
    }

    static class FolderViewHolder {
        public TextView folderName;

        public TextView folderStatus;

        public TextView newMessageCount;
        public TextView flaggedMessageCount;

        public RelativeLayout activeIcons;
        public String rawFolderName;
        public View chip;
        public LinearLayout folderListItemLayout;
    }

    private class FolderClickListener implements OnClickListener {

        final BaseAccount account;
        final String folderName;
        final String displayName;
        final SearchModifier searchModifier;
        FolderClickListener(BaseAccount nAccount, String folderName, String displayName, SearchModifier nSearchModifier) {
            account = nAccount;
            this.folderName = folderName;
            searchModifier = nSearchModifier;
            this.displayName = displayName;
        }
        @Override
        public void onClick(View v) {
            String description = getString(R.string.search_title,
                                           getString(R.string.message_list_title, account.getDescription(), displayName),
                                           getString(searchModifier.resId));

            SearchSpecification searchSpec = new SearchSpecification() {
                @Override
                public String[] getAccountUuids() {
                    return new String[] { account.getUuid() };
                }

                @Override
                public Flag[] getForbiddenFlags() {
                    return searchModifier.forbiddenFlags;
                }

                @Override
                public String getQuery() {
                    return """";
                }

                @Override
                public Flag[] getRequiredFlags() {
                    return searchModifier.requiredFlags;
                }

                @Override
                public boolean isIntegrate() {
                    return false;
                }

                @Override
                public String[] getFolderNames() {
                    return new String[] { folderName };
                }

            };
            MessageList.actionHandle(FolderList.this, description, searchSpec);

        }

    }

    private static Flag[] UNREAD_FLAG_ARRAY = { Flag.SEEN };

    private void openUnreadSearch(Context context, final Account account) {
        String description = getString(R.string.search_title, mAccount.getDescription(), getString(R.string.unread_modifier));

        SearchSpecification searchSpec = new SearchSpecification() {
            //interface has no override            @Override
            public String[] getAccountUuids() {
                return new String[] { account.getUuid() };
            }

            //interface has no override            @Override
            public Flag[] getForbiddenFlags() {
                return UNREAD_FLAG_ARRAY;
            }

            //interface has no override            @Override
            public String getQuery() {
                return """";
            }

            @Override
            public Flag[] getRequiredFlags() {
                return null;
            }

            @Override
            public boolean isIntegrate() {
                return false;
            }

            @Override
            public String[] getFolderNames() {
                return null;
            }

        };
        MessageList.actionHandle(context, description, searchSpec);
    }

}
",True,145,1,1,5,71,4,28,L1
53,com.fsck.k9.activity.Accounts.java,"
package com.fsck.k9.activity;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.util.TypedValue;
import android.view.*;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.View.OnClickListener;
import android.webkit.WebView;
import android.widget.*;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.AdapterView.OnItemClickListener;
import com.fsck.k9.*;
import com.fsck.k9.helper.SizeFormatter;
import com.fsck.k9.activity.setup.AccountSettings;
import com.fsck.k9.activity.setup.AccountSetupBasics;
import com.fsck.k9.activity.setup.Prefs;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.store.StorageManager;
import com.fsck.k9.view.ColorChip;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Accounts extends K9ListActivity implements OnItemClickListener, OnClickListener {

    /**
     * Immutable empty {@link BaseAccount} array
     */
    private static final BaseAccount[] EMPTY_BASE_ACCOUNT_ARRAY = new BaseAccount[0];

    /**
     * Immutable empty {@link Flag} array
     */
    private static final Flag[] EMPTY_FLAG_ARRAY = new Flag[0];

    private static final int DIALOG_REMOVE_ACCOUNT = 1;
    private static final int DIALOG_CLEAR_ACCOUNT = 2;
    private static final int DIALOG_RECREATE_ACCOUNT = 3;
    private ConcurrentHashMap<String, AccountStats> accountStats = new ConcurrentHashMap<String, AccountStats>();

    private ConcurrentHashMap<BaseAccount, String> pendingWork = new ConcurrentHashMap<BaseAccount, String>();

    private BaseAccount mSelectedContextAccount;
    private int mUnreadMessageCount = 0;

    private AccountsHandler mHandler = new AccountsHandler();
    private AccountsAdapter mAdapter;
    private SearchAccount unreadAccount = null;
    private SearchAccount integratedInboxAccount = null;
    private FontSizes mFontSizes = K9.getFontSizes();

    class AccountsHandler extends Handler {
        private void setViewTitle() {
            String dispString = mListener.formatHeader(Accounts.this, getString(R.string.accounts_title), mUnreadMessageCount, getTimeFormat());

            setTitle(dispString);
        }
        public void refreshTitle() {
            runOnUiThread(new Runnable() {
                public void run() {
                    setViewTitle();
                }
            });
        }

        public void dataChanged() {
            runOnUiThread(new Runnable() {
                public void run() {
                    if (mAdapter != null) {
                        mAdapter.notifyDataSetChanged();
                    }
                }
            });
        }

        public void workingAccount(final Account account, final int res) {
            runOnUiThread(new Runnable() {
                public void run() {
                    String toastText = getString(res, account.getDescription());

                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_SHORT);
                    toast.show();
                }
            });
        }

        public void accountSizeChanged(final Account account, final long oldSize, final long newSize) {
            runOnUiThread(new Runnable() {
                public void run() {
                    AccountStats stats = accountStats.get(account.getUuid());
                    if (newSize != -1 && stats != null && K9.measureAccounts()) {
                        stats.size = newSize;
                    }
                    String toastText = getString(R.string.account_size_changed, account.getDescription(),
                                                 SizeFormatter.formatSize(getApplication(), oldSize), SizeFormatter.formatSize(getApplication(), newSize));

                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
                    toast.show();
                    if (mAdapter != null) {
                        mAdapter.notifyDataSetChanged();
                    }
                }
            });
        }

        public void progress(final boolean progress) {
            runOnUiThread(new Runnable() {
                public void run() {
                    setProgressBarIndeterminateVisibility(progress);
                }
            });
        }
        public void progress(final int progress) {
            runOnUiThread(new Runnable() {
                public void run() {
                    getWindow().setFeatureInt(Window.FEATURE_PROGRESS, progress);
                }
            });
        }
    }

    ActivityListener mListener = new ActivityListener() {
        @Override
        public void informUserOfStatus() {
            mHandler.refreshTitle();
        }

        @Override
        public void folderStatusChanged(Account account, String folderName, int unreadMessageCount) {
            try {
                AccountStats stats = account.getStats(Accounts.this);
                if (stats == null) {
                    Log.w(K9.LOG_TAG, ""Unable to get account stats"");
                } else {
                    accountStatusChanged(account, stats);
                }
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Unable to get account stats"", e);
            }
        }
        @Override
        public void accountStatusChanged(BaseAccount account, AccountStats stats) {
            AccountStats oldStats = accountStats.get(account.getUuid());
            int oldUnreadMessageCount = 0;
            if (oldStats != null) {
                oldUnreadMessageCount = oldStats.unreadMessageCount;
            }
            if (stats == null) {
                stats = new AccountStats(); // empty stats for unavailable accounts
                stats.available = false;
            }
            accountStats.put(account.getUuid(), stats);
            if (account instanceof Account) {
                mUnreadMessageCount += stats.unreadMessageCount - oldUnreadMessageCount;
            }
            mHandler.dataChanged();
            pendingWork.remove(account);

            if (pendingWork.isEmpty()) {
                mHandler.progress(Window.PROGRESS_END);
                mHandler.refreshTitle();
            } else {
                int level = (Window.PROGRESS_END / mAdapter.getCount()) * (mAdapter.getCount() - pendingWork.size()) ;
                mHandler.progress(level);
            }
        }

        @Override
        public void accountSizeChanged(Account account, long oldSize, long newSize) {
            mHandler.accountSizeChanged(account, oldSize, newSize);
        }

        @Override
        public void synchronizeMailboxFinished(
            Account account,
            String folder,
            int totalMessagesInMailbox,
        int numNewMessages) {
            MessagingController.getInstance(getApplication()).getAccountStats(Accounts.this, account, mListener);
            super.synchronizeMailboxFinished(account, folder, totalMessagesInMailbox, numNewMessages);

            mHandler.progress(false);

        }

        @Override
        public void synchronizeMailboxStarted(Account account, String folder) {
            super.synchronizeMailboxStarted(account, folder);
            mHandler.progress(true);
        }

        @Override
        public void synchronizeMailboxFailed(Account account, String folder,
        String message) {
            super.synchronizeMailboxFailed(account, folder, message);
            mHandler.progress(false);

        }

    };

    private static String ACCOUNT_STATS = ""accountStats"";
    private static String SELECTED_CONTEXT_ACCOUNT = ""selectedContextAccount"";

    public static final String EXTRA_STARTUP = ""startup"";


    public static void actionLaunch(Context context) {
        Intent intent = new Intent(context, Accounts.class);
        intent.putExtra(EXTRA_STARTUP, true);
        context.startActivity(intent);
    }

    public static void listAccounts(Context context) {
        Intent intent = new Intent(context, Accounts.class);
        intent.putExtra(EXTRA_STARTUP, false);
        context.startActivity(intent);
    }


    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);

        if (!K9.isHideSpecialAccounts()) {
            unreadAccount = new SearchAccount(this, false, null, null);
            unreadAccount.setDescription(getString(R.string.search_all_messages_title));
            unreadAccount.setEmail(getString(R.string.search_all_messages_detail));

            integratedInboxAccount = new SearchAccount(this, true, null,  null);
            integratedInboxAccount.setDescription(getString(R.string.integrated_inbox_title));
            integratedInboxAccount.setEmail(getString(R.string.integrated_inbox_detail));
        }

        Account[] accounts = Preferences.getPreferences(this).getAccounts();
        Intent intent = getIntent();
        boolean startup = intent.getBooleanExtra(EXTRA_STARTUP, true);
        if (startup && K9.startIntegratedInbox() && !K9.isHideSpecialAccounts()) {
            onOpenAccount(integratedInboxAccount);
            finish();
        } else if (startup && accounts.length == 1 && onOpenAccount(accounts[0])) {
            // fall through to ""else"" if !onOpenAccount()
            finish();
        } else {
            requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
            requestWindowFeature(Window.FEATURE_PROGRESS);

            setContentView(R.layout.accounts);
            ListView listView = getListView();
            listView.setOnItemClickListener(this);
            listView.setItemsCanFocus(false);
            listView.setEmptyView(findViewById(R.id.empty));
            findViewById(R.id.next).setOnClickListener(this);
            registerForContextMenu(listView);

            if (icicle != null && icicle.containsKey(SELECTED_CONTEXT_ACCOUNT)) {
                String accountUuid = icicle.getString(""selectedContextAccount"");
                mSelectedContextAccount = Preferences.getPreferences(this).getAccount(accountUuid);
            }

            restoreAccountStats(icicle);
        }
    }

    @SuppressWarnings(""unchecked"")
    private void restoreAccountStats(Bundle icicle) {
        if (icicle != null) {
            Map<String, AccountStats> oldStats = (Map<String, AccountStats>)icicle.get(ACCOUNT_STATS);
            if (oldStats != null) {
                accountStats.putAll(oldStats);
            }
        }
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        if (mSelectedContextAccount != null) {
            outState.putString(SELECTED_CONTEXT_ACCOUNT, mSelectedContextAccount.getUuid());
        }
        outState.putSerializable(ACCOUNT_STATS, accountStats);
    }

    private StorageManager.StorageListener storageListener = new StorageManager.StorageListener() {

        @Override
        public void onUnmount(String providerId) {
            refresh();
        }

        @Override
        public void onMount(String providerId) {
            refresh();
        }
    };

    @Override
    public void onResume() {
        super.onResume();

        refresh();
        MessagingController.getInstance(getApplication()).addListener(mListener);
        StorageManager.getInstance(getApplication()).addListener(storageListener);
    }

    @Override
    public void onPause() {
        super.onPause();
        MessagingController.getInstance(getApplication()).removeListener(mListener);
        StorageManager.getInstance(getApplication()).removeListener(storageListener);

    }

    private void refresh() {
        BaseAccount[] accounts = Preferences.getPreferences(this).getAccounts();

        List<BaseAccount> newAccounts;
        if (!K9.isHideSpecialAccounts()
                && accounts.length > 0) {
            newAccounts = new ArrayList<BaseAccount>(accounts.length + 2);
            newAccounts.add(integratedInboxAccount);
            newAccounts.add(unreadAccount);
        } else {
            newAccounts = new ArrayList<BaseAccount>(accounts.length);
        }

        newAccounts.addAll(Arrays.asList(accounts));

        mAdapter = new AccountsAdapter(newAccounts.toArray(EMPTY_BASE_ACCOUNT_ARRAY));
        getListView().setAdapter(mAdapter);
        if (newAccounts.size() > 0) {
            mHandler.progress(Window.PROGRESS_START);
        }
        pendingWork.clear();

        for (BaseAccount account : newAccounts) {

            if (account instanceof Account) {
                pendingWork.put(account, ""true"");
                Account realAccount = (Account)account;
                MessagingController.getInstance(getApplication()).getAccountStats(Accounts.this, realAccount, mListener);
            } else if (K9.countSearchMessages() && account instanceof SearchAccount) {
                pendingWork.put(account, ""true"");
                final SearchAccount searchAccount = (SearchAccount)account;

                MessagingController.getInstance(getApplication()).searchLocalMessages(searchAccount, null, new MessagingListener() {
                    @Override
                    public void searchStats(AccountStats stats) {
                        mListener.accountStatusChanged(searchAccount, stats);
                    }
                });
            }
        }

    }

    private void onAddNewAccount() {
        AccountSetupBasics.actionNewAccount(this);
    }

    private void onEditAccount(Account account) {
        AccountSettings.actionSettings(this, account);
    }

    private void onEditPrefs() {
        Prefs.actionPrefs(this);
    }


    /*
     * This method is called with 'null' for the argument 'account' if
     * all accounts are to be checked. This is handled accordingly in
     * MessagingController.checkMail().
     */
    private void onCheckMail(Account account) {
        MessagingController.getInstance(getApplication()).checkMail(this, account, true, true, null);
        if (account == null) {
            MessagingController.getInstance(getApplication()).sendPendingMessages(null);
        } else {
            MessagingController.getInstance(getApplication()).sendPendingMessages(account, null);
        }

    }

    private void onClearCommands(Account account) {
        MessagingController.getInstance(getApplication()).clearAllPending(account);
    }

    private void onEmptyTrash(Account account) {
        MessagingController.getInstance(getApplication()).emptyTrash(account, null);
    }


    private void onCompose() {
        Account defaultAccount = Preferences.getPreferences(this).getDefaultAccount();
        if (defaultAccount != null) {
            MessageCompose.actionCompose(this, defaultAccount);
        } else {
            onAddNewAccount();
        }
    }

    /**
     * Show that account's inbox or folder-list
     * or return false if the account is not available.
     * @param account the account to open ({@link SearchAccount} or {@link Account})
     * @return false if unsuccessfull
     */
    private boolean onOpenAccount(BaseAccount account) {
        if (account instanceof SearchAccount) {
            SearchAccount searchAccount = (SearchAccount)account;
            MessageList.actionHandle(this, searchAccount.getDescription(), searchAccount);
        } else {
            Account realAccount = (Account)account;
            if (!realAccount.isAvailable(this)) {
                String toastText = getString(R.string.account_unavailable, account.getDescription());
                Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_SHORT);
                toast.show();

                Log.i(K9.LOG_TAG, ""refusing to open account that is not available"");
                return false;
            }
            if (K9.FOLDER_NONE.equals(realAccount.getAutoExpandFolderName())) {
                FolderList.actionHandleAccount(this, realAccount);
            } else {
                MessageList.actionHandleFolder(this, realAccount, realAccount.getAutoExpandFolderName());
            }
        }
        return true;
    }

    public void onClick(View view) {
        if (view.getId() == R.id.next) {
            onAddNewAccount();
        }
    }

    private void onDeleteAccount(Account account) {
        mSelectedContextAccount = account;
        showDialog(DIALOG_REMOVE_ACCOUNT);
    }

    @Override
    public Dialog onCreateDialog(int id) {
        switch (id) {
        case DIALOG_REMOVE_ACCOUNT:
            return ConfirmationDialog.create(this, id,
                                             R.string.account_delete_dlg_title,
                                             getString(R.string.account_delete_dlg_instructions_fmt,
                                                     mSelectedContextAccount.getDescription()),
                                             R.string.okay_action,
                                             R.string.cancel_action,
            new Runnable() {
                @Override
                public void run() {
                    if (mSelectedContextAccount instanceof Account) {
                        Account realAccount = (Account)mSelectedContextAccount;
                        try {
                            realAccount.getLocalStore().delete();
                        } catch (Exception e) {
                            // Ignore, this may lead to localStores on sd-cards that are
                            // currently not inserted to be left
                        }
                        MessagingController.getInstance(getApplication())
                        .notifyAccountCancel(Accounts.this, realAccount);
                        Preferences.getPreferences(Accounts.this).deleteAccount(realAccount);
                        K9.setServicesEnabled(Accounts.this);
                        refresh();
                    }
                }
            });

        case DIALOG_CLEAR_ACCOUNT:
            return ConfirmationDialog.create(this, id,
                                             R.string.account_clear_dlg_title,
                                             getString(R.string.account_clear_dlg_instructions_fmt,
                                                     mSelectedContextAccount.getDescription()),
                                             R.string.okay_action,
                                             R.string.cancel_action,
            new Runnable() {
                @Override
                public void run() {
                    if (mSelectedContextAccount instanceof Account) {
                        Account realAccount = (Account)mSelectedContextAccount;
                        mHandler.workingAccount(realAccount, R.string.clearing_account);
                        MessagingController.getInstance(getApplication()).clear(realAccount, null);
                    }
                }
            });

        case DIALOG_RECREATE_ACCOUNT:
            return ConfirmationDialog.create(this, id,
                                             R.string.account_recreate_dlg_title,
                                             getString(R.string.account_recreate_dlg_instructions_fmt,
                                                     mSelectedContextAccount.getDescription()),
                                             R.string.okay_action,
                                             R.string.cancel_action,
            new Runnable() {
                @Override
                public void run() {
                    if (mSelectedContextAccount instanceof Account) {
                        Account realAccount = (Account)mSelectedContextAccount;
                        mHandler.workingAccount(realAccount, R.string.recreating_account);
                        MessagingController.getInstance(getApplication()).recreate(realAccount, null);
                    }
                }
            });
        }
        return super.onCreateDialog(id);
    }

    @Override
    public void onPrepareDialog(int id, Dialog d) {

        AlertDialog alert = (AlertDialog) d;
        switch (id) {
        case DIALOG_REMOVE_ACCOUNT:
            alert.setMessage(getString(R.string.account_delete_dlg_instructions_fmt,
                                       mSelectedContextAccount.getDescription()));
            break;
        case DIALOG_CLEAR_ACCOUNT:
            alert.setMessage(getString(R.string.account_clear_dlg_instructions_fmt,
                                       mSelectedContextAccount.getDescription()));
            break;
        case DIALOG_RECREATE_ACCOUNT:
            alert.setMessage(getString(R.string.account_recreate_dlg_instructions_fmt,
                                       mSelectedContextAccount.getDescription()));
            break;
        }

        super.onPrepareDialog(id, d);
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        AdapterContextMenuInfo menuInfo = (AdapterContextMenuInfo)item.getMenuInfo();
        // submenus don't actually set the menuInfo, so the ""advanced""
        // submenu wouldn't work.
        if (menuInfo != null) {
            mSelectedContextAccount = (BaseAccount)getListView().getItemAtPosition(menuInfo.position);
        }
        Account realAccount = null;
        if (mSelectedContextAccount instanceof Account) {
            realAccount = (Account)mSelectedContextAccount;
        }
        switch (item.getItemId()) {
        case R.id.delete_account:
            onDeleteAccount(realAccount);
            break;
        case R.id.edit_account:
            onEditAccount(realAccount);
            break;
        case R.id.open:
            onOpenAccount(mSelectedContextAccount);
            break;
        case R.id.check_mail:
            onCheckMail(realAccount);
            break;
        case R.id.clear_pending:
            onClearCommands(realAccount);
            break;
        case R.id.empty_trash:
            onEmptyTrash(realAccount);
            break;
        case R.id.compact:
            onCompact(realAccount);
            break;
        case R.id.clear:
            onClear(realAccount);
            break;
        case R.id.recreate:
            onRecreate(realAccount);
            break;
        }
        return true;
    }



    private void onCompact(Account account) {
        mHandler.workingAccount(account, R.string.compacting_account);
        MessagingController.getInstance(getApplication()).compact(account, null);
    }

    private void onClear(Account account) {
        showDialog(DIALOG_CLEAR_ACCOUNT);

    }
    private void onRecreate(Account account) {
        showDialog(DIALOG_RECREATE_ACCOUNT);
    }


    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
        BaseAccount account = (BaseAccount)parent.getItemAtPosition(position);
        onOpenAccount(account);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.add_new_account:
            onAddNewAccount();
            break;
        case R.id.edit_prefs:
            onEditPrefs();
            break;
        case R.id.check_mail:
            onCheckMail(null);
            break;
        case R.id.compose:
            onCompose();
            break;
        case R.id.about:
            onAbout();
            break;
        case R.id.search:
            onSearchRequested();
            break;
        default:
            return super.onOptionsItemSelected(item);
        }
        return true;
    }

    private static String[][] USED_LIBRARIES = new String[][] {
        new String[] {""jutf7"", ""http://jutf7.sourceforge.net/""},
        new String[] {""JZlib"", ""http://www.jcraft.com/jzlib/""},
        new String[] {""Commons IO"", ""http://commons.apache.org/io/""},
        new String[] {""Mime4j"", ""http://james.apache.org/mime4j/""},
    };

    private void onAbout() {
        String appName = getString(R.string.app_name);
        String year = ""2011"";
        WebView wv = new WebView(this);
        StringBuilder html = new StringBuilder()
        .append(""<meta http-equiv=\""content-type\"" content=\""text/html; charset=utf-8\"" />"")
        .append(""<img src=\""file:///android_asset/icon.png\"" alt=\"""").append(appName).append(""\""/>"")
        .append(""<h1>"")
        .append(String.format(getString(R.string.about_title_fmt),
                              ""<a href=\"""" + getString(R.string.app_webpage_url)) + ""\"">"")
        .append(appName)
        .append(""</a>"")
        .append(""</h1><p>"")
        .append(appName)
        .append("" "")
        .append(String.format(getString(R.string.debug_version_fmt), getVersionNumber()))
        .append(""</p><p>"")
        .append(String.format(getString(R.string.app_authors_fmt),
                              getString(R.string.app_authors)))
        .append(""</p><p>"")
        .append(String.format(getString(R.string.app_revision_fmt),
                              ""<a href=\"""" + getString(R.string.app_revision_url) + ""\"">"" +
                              getString(R.string.app_revision_url) +
                              ""</a>""))
        .append(""</p><hr/><p>"")
        .append(String.format(getString(R.string.app_copyright_fmt), year, year))
        .append(""</p><hr/><p>"")
        .append(getString(R.string.app_license))
        .append(""</p><hr/><p>"");

        StringBuilder libs = new StringBuilder().append(""<ul>"");
        for (String[] library : USED_LIBRARIES) {
            libs.append(""<li><a href=\"""" + library[1] + ""\"">"" + library[0] + ""</a></li>"");
        }
        libs.append(""</ul>"");

        html.append(String.format(getString(R.string.app_libraries), libs.toString()))
        .append(""</p><hr/><p>"")
        .append(String.format(getString(R.string.app_emoji_icons),
                              ""<div>TypePad \u7d75\u6587\u5b57\u30a2\u30a4\u30b3\u30f3\u753b\u50cf "" +
                              ""(<a href=\""http://typepad.jp/\"">Six Apart Ltd</a>) / "" +
                              ""<a href=\""http://creativecommons.org/licenses/by/2.1/jp/\"">CC BY 2.1</a></div>""))
        .append(""</p>"");

        wv.loadDataWithBaseURL(""file:///android_res/drawable/"", html.toString(), ""text/html"", ""utf-8"", null);
        new AlertDialog.Builder(this)
        .setView(wv)
        .setCancelable(true)
        .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface d, int c) {
                d.dismiss();
            }
        })
        .show();
    }

    /**
     * Get current version number.
     *
     * @return String version
     */
    private String getVersionNumber() {
        String version = ""?"";
        try {
            PackageInfo pi = getPackageManager().getPackageInfo(getPackageName(), 0);
            version = pi.versionName;
        } catch (PackageManager.NameNotFoundException e) {
            //Log.e(TAG, ""Package name not found"", e);
        }
        return version;
    }

    public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {
        return true;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.accounts_option, menu);
        return true;
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);
        menu.setHeaderTitle(R.string.accounts_context_menu_title);
        getMenuInflater().inflate(R.menu.accounts_context, menu);

        AdapterContextMenuInfo info = (AdapterContextMenuInfo) menuInfo;
        BaseAccount account =  mAdapter.getItem(info.position);
        if (account instanceof SearchAccount) {
            for (int i = 0; i < menu.size(); i++) {
                MenuItem item = menu.getItem(i);
                if (item.getItemId() != R.id.open) {
                    item.setVisible(false);
                }
            }
        }
    }

    class AccountsAdapter extends ArrayAdapter<BaseAccount> {
        public AccountsAdapter(BaseAccount[] accounts) {
            super(Accounts.this, 0, accounts);
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            final BaseAccount account = getItem(position);
            View view;
            if (convertView != null) {
                view = convertView;
            } else {
                view = getLayoutInflater().inflate(R.layout.accounts_item, parent, false);
            }
            AccountViewHolder holder = (AccountViewHolder) view.getTag();
            if (holder == null) {
                holder = new AccountViewHolder();
                holder.description = (TextView) view.findViewById(R.id.description);
                holder.email = (TextView) view.findViewById(R.id.email);
                holder.newMessageCount = (TextView) view.findViewById(R.id.new_message_count);
                holder.flaggedMessageCount = (TextView) view.findViewById(R.id.flagged_message_count);
                holder.activeIcons = (RelativeLayout) view.findViewById(R.id.active_icons);

                holder.chip = view.findViewById(R.id.chip);
                holder.folders = (ImageButton) view.findViewById(R.id.folders);
                holder.accountsItemLayout = (LinearLayout)view.findViewById(R.id.accounts_item_layout);

                view.setTag(holder);
            }
            AccountStats stats = accountStats.get(account.getUuid());

            if (stats != null && account instanceof Account && stats.size >= 0) {
                holder.email.setText(SizeFormatter.formatSize(Accounts.this, stats.size));
                holder.email.setVisibility(View.VISIBLE);
            } else {
                if (account.getEmail().equals(account.getDescription())) {
                    holder.email.setVisibility(View.GONE);
                } else {
                    holder.email.setVisibility(View.VISIBLE);
                    holder.email.setText(account.getEmail());
                }
            }

            String description = account.getDescription();
            if (description == null || description.length() == 0) {
                description = account.getEmail();
            }

            holder.description.setText(description);

            Integer unreadMessageCount = null;
            if (stats != null) {
                unreadMessageCount = stats.unreadMessageCount;
                holder.newMessageCount.setText(Integer.toString(unreadMessageCount));
                holder.newMessageCount.setVisibility(unreadMessageCount > 0 ? View.VISIBLE : View.GONE);

                holder.flaggedMessageCount.setText(Integer.toString(stats.flaggedMessageCount));
                holder.flaggedMessageCount.setVisibility(K9.messageListStars() && stats.flaggedMessageCount > 0 ? View.VISIBLE : View.GONE);

                holder.flaggedMessageCount.setOnClickListener(new AccountClickListener(account, SearchModifier.FLAGGED));
                holder.newMessageCount.setOnClickListener(new AccountClickListener(account, SearchModifier.UNREAD));

                view.getBackground().setAlpha(stats.available ? 0 : 127);

                holder.activeIcons.setOnClickListener(new OnClickListener() {
                    public void onClick(View v) {
                        Toast toast = Toast.makeText(getApplication(), getString(R.string.tap_hint), Toast.LENGTH_SHORT);
                        toast.show();
                    }
                }
                                                     );

            } else {
                holder.newMessageCount.setVisibility(View.GONE);
                holder.flaggedMessageCount.setVisibility(View.GONE);
                view.getBackground().setAlpha(0);
            }
            if (account instanceof Account) {
                Account realAccount = (Account)account;

                holder.chip.setBackgroundDrawable(realAccount.generateColorChip().drawable());
                if (unreadMessageCount == null) {
                    holder.chip.getBackground().setAlpha(0);
                } else if (unreadMessageCount == 0) {
                    holder.chip.getBackground().setAlpha(127);
                } else {
                    holder.chip.getBackground().setAlpha(255);
                }

            } else {
                holder.chip.setBackgroundDrawable(new ColorChip(0xff999999).drawable());
            }


            holder.description.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getAccountName());
            holder.email.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getAccountDescription());

            if (K9.useCompactLayouts()) {
                holder.accountsItemLayout.setMinimumHeight(0);
            }
            if (account instanceof SearchAccount || K9.useCompactLayouts()) {

                holder.folders.setVisibility(View.GONE);
            } else {
                holder.folders.setVisibility(View.VISIBLE);
                holder.folders.setOnClickListener(new OnClickListener() {
                    public void onClick(View v) {
                        FolderList.actionHandleAccount(Accounts.this, (Account)account);

                    }
                });
            }

            return view;
        }

        class AccountViewHolder {
            public TextView description;
            public TextView email;
            public TextView newMessageCount;
            public TextView flaggedMessageCount;
            public RelativeLayout activeIcons;
            public View chip;
            public ImageButton folders;
            public LinearLayout accountsItemLayout;
        }
    }
    private Flag[] combine(Flag[] set1, Flag[] set2) {
        if (set1 == null) {
            return set2;
        }
        if (set2 == null) {
            return set1;
        }
        Set<Flag> flags = new HashSet<Flag>();
        flags.addAll(Arrays.asList(set1));
        flags.addAll(Arrays.asList(set2));
        return flags.toArray(EMPTY_FLAG_ARRAY);
    }

    private class AccountClickListener implements OnClickListener {

        final BaseAccount account;
        final SearchModifier searchModifier;
        AccountClickListener(BaseAccount nAccount, SearchModifier nSearchModifier) {
            account = nAccount;
            searchModifier = nSearchModifier;
        }
        @Override
        public void onClick(View v) {
            String description = getString(R.string.search_title, account.getDescription(), getString(searchModifier.resId));
            if (account instanceof SearchAccount) {
                SearchAccount searchAccount = (SearchAccount)account;

                MessageList.actionHandle(Accounts.this,
                                         description, """", searchAccount.isIntegrate(),
                                         combine(searchAccount.getRequiredFlags(), searchModifier.requiredFlags),
                                         combine(searchAccount.getForbiddenFlags(), searchModifier.forbiddenFlags));
            } else {
                SearchSpecification searchSpec = new SearchSpecification() {
                    @Override
                    public String[] getAccountUuids() {
                        return new String[] { account.getUuid() };
                    }

                    @Override
                    public Flag[] getForbiddenFlags() {
                        return searchModifier.forbiddenFlags;
                    }

                    @Override
                    public String getQuery() {
                        return """";
                    }

                    @Override
                    public Flag[] getRequiredFlags() {
                        return searchModifier.requiredFlags;
                    }

                    @Override
                    public boolean isIntegrate() {
                        return false;
                    }

                    @Override
                    public String[] getFolderNames() {
                        return null;
                    }

                };
                MessageList.actionHandle(Accounts.this, description, searchSpec);
            }
        }

    }

}
",True,145,1,1,5,72,5,24,L1
54,com.fsck.k9.activity.MessageInfoHolder.java,"package com.fsck.k9.activity;

import java.util.Date;
import com.fsck.k9.helper.MessageHelper;
import com.fsck.k9.mail.store.LocalStore.LocalMessage;

public class MessageInfoHolder {
    public String date;
    public Date compareDate;
    public String compareSubject;
    public CharSequence sender;
    public String senderAddress;
    public String compareCounterparty;
    public String[] recipients;
    public String uid;
    public boolean read;
    public boolean answered;
    public boolean flagged;
    public boolean downloaded;
    public boolean partially_downloaded;
    public boolean dirty;
    public LocalMessage message;
    public FolderInfoHolder folder;
    public boolean selected;
    public String account;
    public String uri;

    // Empty constructor for comparison
    public MessageInfoHolder() {
        this.selected = false;
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof MessageInfoHolder == false) {
            return false;
        }
        MessageInfoHolder other = (MessageInfoHolder)o;
        return message.equals(other.message);
    }

    @Override
    public int hashCode() {
        return uid.hashCode();
    }

    public String getDate(MessageHelper messageHelper) {
        if (date == null) {
            date = messageHelper.formatDate(message.getSentDate());
        }
        return date;
    }
}
",False,145,1,1,7,33,3,5,L1
55,com.fsck.k9.activity.Search.java,"package com.fsck.k9.activity;
import com.fsck.k9.activity.MessageList;


public class Search extends MessageList {

}
",False,145,0,0,6,70,0,1,L2
56,com.fsck.k9.activity.ChooseIdentity.java,"
package com.fsck.k9.activity;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.Toast;
import com.fsck.k9.Account;
import com.fsck.k9.Identity;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import java.util.List;

public class ChooseIdentity extends K9ListActivity {
    Account mAccount;
    String mUID;
    ArrayAdapter<String> adapter;

    public static final String EXTRA_ACCOUNT = ""com.fsck.k9.ChooseIdentity_account"";
    public static final String EXTRA_IDENTITY = ""com.fsck.k9.ChooseIdentity_identity"";

    protected List<Identity> identities = null;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);

        getListView().setTextFilterEnabled(true);
        getListView().setItemsCanFocus(false);
        getListView().setChoiceMode(ListView.CHOICE_MODE_NONE);
        Intent intent = getIntent();
        String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1);

        setListAdapter(adapter);
        setupClickListeners();
    }


    @Override
    public void onResume() {
        super.onResume();
        refreshView();
    }


    protected void refreshView() {
        adapter.setNotifyOnChange(false);
        adapter.clear();

        identities = mAccount.getIdentities();
        for (Identity identity : identities) {
            String description = identity.getDescription();
            if (description == null || description.trim().length() == 0) {
                description = getString(R.string.message_view_from_format, identity.getName(), identity.getEmail());
            }
            adapter.add(description);
        }

        adapter.notifyDataSetChanged();
    }

    protected void setupClickListeners() {
        this.getListView().setOnItemClickListener(new AdapterView.OnItemClickListener() {
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                Identity identity = mAccount.getIdentity(position);
                String email = identity.getEmail();
                if (email != null && !email.trim().equals("""")) {
                    Intent intent = new Intent();

                    intent.putExtra(EXTRA_IDENTITY, mAccount.getIdentity(position));
                    setResult(RESULT_OK, intent);
                    finish();
                } else {
                    Toast.makeText(ChooseIdentity.this, getString(R.string.identity_has_no_email),
                                   Toast.LENGTH_LONG).show();
                }
            }
        });

    }
}
",False,144,0,0,7,40,3,4,L1
57,com.fsck.k9.activity.ManageIdentities.java,"package com.fsck.k9.activity;

import android.content.Intent;
import android.view.*;
import android.view.ContextMenu.ContextMenuInfo;
import android.widget.AdapterView;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.ListView;
import android.widget.Toast;
import com.fsck.k9.Identity;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;

public class ManageIdentities extends ChooseIdentity {
    private boolean mIdentitiesChanged = false;
    public static final String EXTRA_IDENTITIES = ""com.fsck.k9.EditIdentity_identities"";

    private static final int ACTIVITY_EDIT_IDENTITY = 1;

    @Override
    protected void setupClickListeners() {
        this.getListView().setOnItemClickListener(new AdapterView.OnItemClickListener() {
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                editItem(position);
            }
        });

        ListView listView = getListView();
        registerForContextMenu(listView);
    }

    private void editItem(int i) {
        Intent intent = new Intent(ManageIdentities.this, EditIdentity.class);
        intent.putExtra(EditIdentity.EXTRA_ACCOUNT, mAccount.getUuid());
        intent.putExtra(EditIdentity.EXTRA_IDENTITY, mAccount.getIdentity(i));
        intent.putExtra(EditIdentity.EXTRA_IDENTITY_INDEX, i);
        startActivityForResult(intent, ACTIVITY_EDIT_IDENTITY);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.manage_identities_option, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.new_identity:
            Intent intent = new Intent(ManageIdentities.this, EditIdentity.class);
            intent.putExtra(EditIdentity.EXTRA_ACCOUNT, mAccount.getUuid());
            startActivityForResult(intent, ACTIVITY_EDIT_IDENTITY);
            break;
        default:
            return super.onOptionsItemSelected(item);
        }
        return true;
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);
        menu.setHeaderTitle(R.string.manage_identities_context_menu_title);
        getMenuInflater().inflate(R.menu.manage_identities_context, menu);
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        AdapterContextMenuInfo menuInfo = (AdapterContextMenuInfo)item.getMenuInfo();
        switch (item.getItemId()) {
        case R.id.edit:
            editItem(menuInfo.position);
            break;
        case R.id.up:
            if (menuInfo.position > 0) {
                Identity identity = identities.remove(menuInfo.position);
                identities.add(menuInfo.position - 1, identity);
                mIdentitiesChanged = true;
                refreshView();
            }

            break;
        case R.id.down:
            if (menuInfo.position < identities.size() - 1) {
                Identity identity = identities.remove(menuInfo.position);
                identities.add(menuInfo.position + 1, identity);
                mIdentitiesChanged = true;
                refreshView();
            }
            break;
        case R.id.top:
            Identity identity = identities.remove(menuInfo.position);
            identities.add(0, identity);
            mIdentitiesChanged = true;
            refreshView();
            break;
        case R.id.remove:
            if (identities.size() > 1) {
                identities.remove(menuInfo.position);
                mIdentitiesChanged = true;
                refreshView();
            } else {
                Toast.makeText(this, getString(R.string.no_removable_identity),
                               Toast.LENGTH_LONG).show();
            }
            break;
        }
        return true;
    }


    @Override
    public void onResume() {
        super.onResume();
        //mAccount.refresh(Preferences.getPreferences(getApplication().getApplicationContext()));
        refreshView();
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            saveIdentities();
        }
        return super.onKeyDown(keyCode, event);
    }

    private void saveIdentities() {
        if (mIdentitiesChanged) {
            mAccount.setIdentities(identities);
            mAccount.save(Preferences.getPreferences(getApplication().getApplicationContext()));
        }
        finish();
    }
}
",False,144,0,0,7,40,1,6,L1
58,com.fsck.k9.activity.EditIdentity.java,"package com.fsck.k9.activity;

import android.os.Bundle;
import android.view.KeyEvent;
import android.view.View;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.EditText;
import android.widget.LinearLayout;
import com.fsck.k9.Account;
import com.fsck.k9.Identity;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import java.util.List;

public class EditIdentity extends K9Activity {

    public static final String EXTRA_IDENTITY = ""com.fsck.k9.EditIdentity_identity"";
    public static final String EXTRA_IDENTITY_INDEX = ""com.fsck.k9.EditIdentity_identity_index"";
    public static final String EXTRA_ACCOUNT = ""com.fsck.k9.EditIdentity_account"";

    private Account mAccount;
    private Identity mIdentity;
    private int mIdentityIndex;
    private EditText mDescriptionView;
    private CheckBox mSignatureUse;
    private EditText mSignatureView;
    private LinearLayout mSignatureLayout;
    private EditText mEmailView;
//  private EditText mAlwaysBccView;
    private EditText mNameView;
    private EditText mReplyTo;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mIdentity = (Identity)getIntent().getSerializableExtra(EXTRA_IDENTITY);
        mIdentityIndex = getIntent().getIntExtra(EXTRA_IDENTITY_INDEX, -1);
        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        if (mIdentityIndex == -1) {
            mIdentity = new Identity();
        }

        setContentView(R.layout.edit_identity);

        /*
         * If we're being reloaded we override the original account with the one
         * we saved
         */
        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_IDENTITY)) {
            mIdentity = (Identity)savedInstanceState.getSerializable(EXTRA_IDENTITY);
        }

        mDescriptionView = (EditText)findViewById(R.id.description);
        mDescriptionView.setText(mIdentity.getDescription());

        mNameView = (EditText)findViewById(R.id.name);
        mNameView.setText(mIdentity.getName());

        mEmailView = (EditText)findViewById(R.id.email);
        mEmailView.setText(mIdentity.getEmail());

        mReplyTo = (EditText) findViewById(R.id.reply_to);
        mReplyTo.setText(mIdentity.getReplyTo());

//      mAccountAlwaysBcc = (EditText)findViewById(R.id.bcc);
//      mAccountAlwaysBcc.setText(mIdentity.getAlwaysBcc());

        mSignatureLayout = (LinearLayout)findViewById(R.id.signature_layout);
        mSignatureUse = (CheckBox)findViewById(R.id.signature_use);
        mSignatureView = (EditText)findViewById(R.id.signature);
        mSignatureUse.setChecked(mIdentity.getSignatureUse());
        mSignatureUse.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                if (isChecked) {
                    mSignatureLayout.setVisibility(View.VISIBLE);
                    mSignatureView.setText(mIdentity.getSignature());
                } else {
                    mSignatureLayout.setVisibility(View.GONE);
                }
            }
        });

        if (mSignatureUse.isChecked()) {
            mSignatureView.setText(mIdentity.getSignature());
        } else {
            mSignatureLayout.setVisibility(View.GONE);
        }
    }

    @Override
    public void onResume() {
        super.onResume();
    }

    private void saveIdentity() {

        mIdentity.setDescription(mDescriptionView.getText().toString());
        mIdentity.setEmail(mEmailView.getText().toString());
        //      mIdentity.setAlwaysBcc(mAccountAlwaysBcc.getText().toString());
        mIdentity.setName(mNameView.getText().toString());
        mIdentity.setSignatureUse(mSignatureUse.isChecked());
        mIdentity.setSignature(mSignatureView.getText().toString());

        if (mReplyTo.getText().length() == 0) {
            mIdentity.setReplyTo(null);
        } else {
            mIdentity.setReplyTo(mReplyTo.getText().toString());
        }

        List<Identity> identities = mAccount.getIdentities();
        if (mIdentityIndex == -1) {
            identities.add(mIdentity);
        } else {
            identities.remove(mIdentityIndex);
            identities.add(mIdentityIndex, mIdentity);
        }

        mAccount.save(Preferences.getPreferences(getApplication().getApplicationContext()));

        finish();
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            saveIdentity();
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putSerializable(EXTRA_IDENTITY, mIdentity);
    }
}
",False,144,0,0,7,40,1,4,L1
59,com.fsck.k9.activity.LauncherShortcuts.java,"package com.fsck.k9.activity;

import android.content.Intent;
import android.os.Bundle;
import android.os.Parcelable;
import android.util.TypedValue;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.TextView;

import com.fsck.k9.Account;
import com.fsck.k9.FontSizes;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;

public class LauncherShortcuts extends K9ListActivity implements OnItemClickListener {
    private AccountsAdapter mAdapter;
    private FontSizes mFontSizes = K9.getFontSizes();

    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);

        // finish() immediately if we aren't supposed to be here
        if (!Intent.ACTION_CREATE_SHORTCUT.equals(getIntent().getAction())) {
            finish();
            return;
        }

        setContentView(R.layout.launcher_shortcuts);
        ListView listView = getListView();
        listView.setOnItemClickListener(this);
        listView.setItemsCanFocus(false);

        refresh();
    }

    private void refresh() {
        Account[] accounts = Preferences.getPreferences(this).getAccounts();

        mAdapter = new AccountsAdapter(accounts);
        getListView().setAdapter(mAdapter);
    }

    private void setupShortcut(Account account) {
        final Intent shortcutIntent = FolderList.actionHandleAccountIntent(this, account, null, true);

        Intent intent = new Intent();
        intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
        String description = account.getDescription();
        if (description == null || description.length() == 0) {
            description = account.getEmail();
        }
        intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, description);
        Parcelable iconResource = Intent.ShortcutIconResource.fromContext(this, R.drawable.icon);
        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, iconResource);

        setResult(RESULT_OK, intent);
        finish();
    }

    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
        Account account = (Account) parent.getItemAtPosition(position);
        setupShortcut(account);
    }

    class AccountsAdapter extends ArrayAdapter<Account> {
        public AccountsAdapter(Account[] accounts) {
            super(LauncherShortcuts.this, 0, accounts);
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            final Account account = getItem(position);

            final View view;
            if (convertView != null) {
                view = convertView;
            } else {
                view = getLayoutInflater().inflate(R.layout.accounts_item, parent, false);
                view.findViewById(R.id.active_icons).setVisibility(View.GONE);
            }

            AccountViewHolder holder = (AccountViewHolder) view.getTag();
            if (holder == null) {
                holder = new AccountViewHolder();
                holder.description = (TextView) view.findViewById(R.id.description);
                holder.email = (TextView) view.findViewById(R.id.email);
                holder.chip = view.findViewById(R.id.chip);

                view.setTag(holder);
            }

            String description = account.getDescription();
            if (account.getEmail().equals(description)) {
                holder.email.setVisibility(View.GONE);
            } else {
                holder.email.setVisibility(View.VISIBLE);
                holder.email.setText(account.getEmail());
            }

            if (description == null || description.length() == 0) {
                description = account.getEmail();
            }

            holder.description.setText(description);

            holder.chip.setBackgroundColor(account.getChipColor());
            holder.chip.getBackground().setAlpha(255);

            holder.description.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getAccountName());
            holder.email.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getAccountDescription());

            return view;
        }

        class AccountViewHolder {
            public TextView description;
            public TextView email;
            public View chip;
        }
    }
}
",False,145,0,0,6,61,0,6,L2
60,com.fsck.k9.activity.MessageCompose.java,"package com.fsck.k9.activity;


import java.io.File;
import java.io.Serializable;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import android.text.*;
import android.webkit.WebViewClient;
import com.fsck.k9.helper.HtmlConverter;
import com.fsck.k9.mail.*;
import com.fsck.k9.view.MessageWebView;
import org.apache.james.mime4j.codec.EncoderUtil;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.ContentResolver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Parcelable;
import android.provider.OpenableColumns;
import android.text.util.Rfc822Tokenizer;
import android.util.Log;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnFocusChangeListener;
import android.view.Window;
import android.webkit.WebView;
import android.widget.AutoCompleteTextView.Validator;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.MultiAutoCompleteTextView;
import android.widget.TextView;
import android.widget.Toast;

import com.fsck.k9.Account;
import com.fsck.k9.Account.QuoteStyle;
import com.fsck.k9.Account.MessageFormat;
import com.fsck.k9.EmailAddressAdapter;
import com.fsck.k9.EmailAddressValidator;
import com.fsck.k9.Identity;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.crypto.CryptoProvider;
import com.fsck.k9.crypto.PgpData;
import com.fsck.k9.helper.Contacts;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.internet.MimeBodyPart;
import com.fsck.k9.mail.internet.MimeHeader;
import com.fsck.k9.mail.internet.MimeMessage;
import com.fsck.k9.mail.internet.MimeMultipart;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.internet.TextBody;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalAttachmentBody;

public class MessageCompose extends K9Activity implements OnClickListener, OnFocusChangeListener {
    private static final int DIALOG_SAVE_OR_DISCARD_DRAFT_MESSAGE = 1;

    private static final String ACTION_REPLY = ""com.fsck.k9.intent.action.REPLY"";
    private static final String ACTION_REPLY_ALL = ""com.fsck.k9.intent.action.REPLY_ALL"";
    private static final String ACTION_FORWARD = ""com.fsck.k9.intent.action.FORWARD"";
    private static final String ACTION_EDIT_DRAFT = ""com.fsck.k9.intent.action.EDIT_DRAFT"";

    private static final String EXTRA_ACCOUNT = ""account"";
    private static final String EXTRA_MESSAGE_BODY  = ""messageBody"";
    private static final String EXTRA_MESSAGE_REFERENCE = ""message_reference"";

    private static final String STATE_KEY_ATTACHMENTS =
        ""com.fsck.k9.activity.MessageCompose.attachments"";
    private static final String STATE_KEY_CC_SHOWN =
        ""com.fsck.k9.activity.MessageCompose.ccShown"";
    private static final String STATE_KEY_BCC_SHOWN =
        ""com.fsck.k9.activity.MessageCompose.bccShown"";
    private static final String STATE_KEY_QUOTED_TEXT_MODE =
        ""com.fsck.k9.activity.MessageCompose.QuotedTextShown"";
    private static final String STATE_KEY_SOURCE_MESSAGE_PROCED =
        ""com.fsck.k9.activity.MessageCompose.stateKeySourceMessageProced"";
    private static final String STATE_KEY_DRAFT_UID =
        ""com.fsck.k9.activity.MessageCompose.draftUid"";
    private static final String STATE_KEY_HTML_QUOTE = ""com.fsck.k9.activity.MessageCompose.HTMLQuote"";
    private static final String STATE_IDENTITY_CHANGED =
        ""com.fsck.k9.activity.MessageCompose.identityChanged"";
    private static final String STATE_IDENTITY =
        ""com.fsck.k9.activity.MessageCompose.identity"";
    private static final String STATE_PGP_DATA = ""pgpData"";
    private static final String STATE_IN_REPLY_TO = ""com.fsck.k9.activity.MessageCompose.inReplyTo"";
    private static final String STATE_REFERENCES = ""com.fsck.k9.activity.MessageCompose.references"";
    private static final String STATE_KEY_MESSAGE_FORMAT = ""com.fsck.k9.activity.MessageCompose.messageFormat"";

    private static final int MSG_PROGRESS_ON = 1;
    private static final int MSG_PROGRESS_OFF = 2;
    private static final int MSG_UPDATE_TITLE = 3;
    private static final int MSG_SKIPPED_ATTACHMENTS = 4;
    private static final int MSG_SAVED_DRAFT = 5;
    private static final int MSG_DISCARDED_DRAFT = 6;

    private static final int ACTIVITY_REQUEST_PICK_ATTACHMENT = 1;
    private static final int ACTIVITY_CHOOSE_IDENTITY = 2;
    private static final int ACTIVITY_CHOOSE_ACCOUNT = 3;
    private static final int CONTACT_PICKER_TO = 4;
    private static final int CONTACT_PICKER_CC = 5;
    private static final int CONTACT_PICKER_BCC = 6;


    /**
     * Regular expression to remove the first localized ""Re:"" prefix in subjects.
     *
     * Currently:
     * - ""Aw:"" (german: abbreviation for ""Antwort"")
     */
    private static final Pattern prefix = Pattern.compile(""^AW[:\\s]\\s*"", Pattern.CASE_INSENSITIVE);

    /**
     * The account used for message composition.
     */
    private Account mAccount;


    private Contacts mContacts;

    /**
     * This identity's settings are used for message composition.
     * Note: This has to be an identity of the account {@link #mAccount}.
     */
    private Identity mIdentity;

    private boolean mIdentityChanged = false;
    private boolean mSignatureChanged = false;

    /**
     * Reference to the source message (in case of reply, forward, or edit
     * draft actions).
     */
    private MessageReference mMessageReference;

    private Message mSourceMessage;
    private String mSourceMessageBody;

    /**
     * Indicates that the source message has been processed at least once and should not
     * be processed on any subsequent loads. This protects us from adding attachments that
     * have already been added from the restore of the view state.
     */
    private boolean mSourceMessageProcessed = false;

    private enum QuotedTextMode {
        NONE,
        SHOW,
        HIDE
    };

    private QuotedTextMode mQuotedTextMode = QuotedTextMode.NONE;

    private TextView mFromView;
    private LinearLayout mCcWrapper;
    private LinearLayout mBccWrapper;
    private MultiAutoCompleteTextView mToView;
    private MultiAutoCompleteTextView mCcView;
    private MultiAutoCompleteTextView mBccView;
    private EditText mSubjectView;
    private EditText mSignatureView;
    private EditText mMessageContentView;
    private LinearLayout mAttachments;
    private Button mQuotedTextShow;
    private View mQuotedTextBar;
    private ImageButton mQuotedTextEdit;
    private ImageButton mQuotedTextDelete;
    private EditText mQuotedText;
    private MessageWebView mQuotedHTML;
    private InsertableHtmlContent mQuotedHtmlContent;   // Container for HTML reply as it's being built.
    private View mEncryptLayout;
    private CheckBox mCryptoSignatureCheckbox;
    private CheckBox mEncryptCheckbox;
    private TextView mCryptoSignatureUserId;
    private TextView mCryptoSignatureUserIdRest;

    private ImageButton mAddToFromContacts;
    private ImageButton mAddCcFromContacts;
    private ImageButton mAddBccFromContacts;

    private PgpData mPgpData = null;

    private String mReferences;
    private String mInReplyTo;

    private boolean mSourceProcessed = false;
    private MessageFormat mMessageFormat;

    private boolean mDraftNeedsSaving = false;
    private boolean mPreventDraftSaving = false;

    /**
     * The draft uid of this message. This is used when saving drafts so that the same draft is
     * overwritten instead of being created anew. This property is null until the first save.
     */
    private String mDraftUid;

    private Handler mHandler = new Handler() {
        @Override
        public void handleMessage(android.os.Message msg) {
            switch (msg.what) {
            case MSG_PROGRESS_ON:
                setProgressBarIndeterminateVisibility(true);
                break;
            case MSG_PROGRESS_OFF:
                setProgressBarIndeterminateVisibility(false);
                break;
            case MSG_UPDATE_TITLE:
                updateTitle();
                break;
            case MSG_SKIPPED_ATTACHMENTS:
                Toast.makeText(
                    MessageCompose.this,
                    getString(R.string.message_compose_attachments_skipped_toast),
                    Toast.LENGTH_LONG).show();
                break;
            case MSG_SAVED_DRAFT:
                Toast.makeText(
                    MessageCompose.this,
                    getString(R.string.message_saved_toast),
                    Toast.LENGTH_LONG).show();
                break;
            case MSG_DISCARDED_DRAFT:
                Toast.makeText(
                    MessageCompose.this,
                    getString(R.string.message_discarded_toast),
                    Toast.LENGTH_LONG).show();
                break;
            default:
                super.handleMessage(msg);
                break;
            }
        }
    };

    private Listener mListener = new Listener();
    private EmailAddressAdapter mAddressAdapter;
    private Validator mAddressValidator;


    static class Attachment implements Serializable {
        private static final long serialVersionUID = 3642382876618963734L;
        public String name;
        public String contentType;
        public long size;
        public Uri uri;
    }

    /**
     * Compose a new message using the given account. If account is null the default account
     * will be used.
     * @param context
     * @param account
     */
    public static void actionCompose(Context context, Account account) {
        if (account == null) {
            account = Preferences.getPreferences(context).getDefaultAccount();
        }
        Intent i = new Intent(context, MessageCompose.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    /**
     * Compose a new message as a reply to the given message. If replyAll is true the function
     * is reply all instead of simply reply.
     * @param context
     * @param account
     * @param message
     * @param replyAll
     * @param messageBody optional, for decrypted messages, null if it should be grabbed from the given message
     */
    public static void actionReply(
        Context context,
        Account account,
        Message message,
        boolean replyAll,
        String messageBody) {
        Intent i = new Intent(context, MessageCompose.class);
        i.putExtra(EXTRA_MESSAGE_BODY, messageBody);
        i.putExtra(EXTRA_MESSAGE_REFERENCE, message.makeMessageReference());
        if (replyAll) {
            i.setAction(ACTION_REPLY_ALL);
        } else {
            i.setAction(ACTION_REPLY);
        }
        context.startActivity(i);
    }

    /**
     * Compose a new message as a forward of the given message.
     * @param context
     * @param account
     * @param message
     * @param messageBody optional, for decrypted messages, null if it should be grabbed from the given message
     */
    public static void actionForward(
        Context context,
        Account account,
        Message message,
        String messageBody) {
        Intent i = new Intent(context, MessageCompose.class);
        i.putExtra(EXTRA_MESSAGE_BODY, messageBody);
        i.putExtra(EXTRA_MESSAGE_REFERENCE, message.makeMessageReference());
        i.setAction(ACTION_FORWARD);
        context.startActivity(i);
    }

    /**
     * Continue composition of the given message. This action modifies the way this Activity
     * handles certain actions.
     * Save will attempt to replace the message in the given folder with the updated version.
     * Discard will delete the message from the given folder.
     * @param context
     * @param account
     * @param message
     */
    public static void actionEditDraft(Context context, Account account, Message message) {
        Intent i = new Intent(context, MessageCompose.class);
        i.putExtra(EXTRA_MESSAGE_REFERENCE, message.makeMessageReference());
        i.setAction(ACTION_EDIT_DRAFT);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        setContentView(R.layout.message_compose);

        final Intent intent = getIntent();

        mMessageReference = intent.getParcelableExtra(EXTRA_MESSAGE_REFERENCE);
        mSourceMessageBody = intent.getStringExtra(EXTRA_MESSAGE_BODY);

        if (K9.DEBUG && mSourceMessageBody != null)
            Log.d(K9.LOG_TAG, ""Composing message with explicitly specified message body."");

        final String accountUuid = (mMessageReference != null) ?
                                   mMessageReference.accountUuid :
                                   intent.getStringExtra(EXTRA_ACCOUNT);

        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        if (mAccount == null) {
            mAccount = Preferences.getPreferences(this).getDefaultAccount();
        }

        if (mAccount == null) {
            /*
             * There are no accounts set up. This should not have happened. Prompt the
             * user to set up an account as an acceptable bailout.
             */
            startActivity(new Intent(this, Accounts.class));
            mDraftNeedsSaving = false;
            finish();
            return;
        }

        mContacts = Contacts.getInstance(MessageCompose.this);

        mAddressAdapter = EmailAddressAdapter.getInstance(this);
        mAddressValidator = new EmailAddressValidator();

        mFromView = (TextView) findViewById(R.id.from);
        mToView = (MultiAutoCompleteTextView) findViewById(R.id.to);
        mCcView = (MultiAutoCompleteTextView) findViewById(R.id.cc);
        mBccView = (MultiAutoCompleteTextView) findViewById(R.id.bcc);
        mSubjectView = (EditText) findViewById(R.id.subject);
        mSubjectView.getInputExtras(true).putBoolean(""allowEmoji"", true);

        mAddToFromContacts = (ImageButton) findViewById(R.id.add_to);
        mAddCcFromContacts = (ImageButton) findViewById(R.id.add_cc);
        mAddBccFromContacts = (ImageButton) findViewById(R.id.add_bcc);
        mCcWrapper = (LinearLayout) findViewById(R.id.cc_wrapper);
        mBccWrapper = (LinearLayout) findViewById(R.id.bcc_wrapper);

        EditText upperSignature = (EditText)findViewById(R.id.upper_signature);
        EditText lowerSignature = (EditText)findViewById(R.id.lower_signature);

        mMessageContentView = (EditText)findViewById(R.id.message_content);
        mMessageContentView.getInputExtras(true).putBoolean(""allowEmoji"", true);
        mAttachments = (LinearLayout)findViewById(R.id.attachments);
        mQuotedTextShow = (Button)findViewById(R.id.quoted_text_show);
        mQuotedTextBar = findViewById(R.id.quoted_text_bar);
        mQuotedTextEdit = (ImageButton)findViewById(R.id.quoted_text_edit);
        mQuotedTextDelete = (ImageButton)findViewById(R.id.quoted_text_delete);
        mQuotedText = (EditText)findViewById(R.id.quoted_text);
        mQuotedText.getInputExtras(true).putBoolean(""allowEmoji"", true);

        mQuotedHTML = (MessageWebView) findViewById(R.id.quoted_html);
        mQuotedHTML.configure();
        // Disable the ability to click links in the quoted HTML page. I think this is a nice feature, but if someone
        // feels this should be a preference (or should go away all together), I'm ok with that too. -achen 20101130
        mQuotedHTML.setWebViewClient(new WebViewClient() {
            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String url) {
                return true;
            }
        });

        TextWatcher watcher = new TextWatcher() {
            public void beforeTextChanged(CharSequence s, int start,
            int before, int after) { }

            public void onTextChanged(CharSequence s, int start,
            int before, int count) {
                mDraftNeedsSaving = true;
            }

            public void afterTextChanged(android.text.Editable s) { }
        };

        TextWatcher sigwatcher = new TextWatcher() {
            public void beforeTextChanged(CharSequence s, int start,
            int before, int after) { }

            public void onTextChanged(CharSequence s, int start,
            int before, int count) {
                mDraftNeedsSaving = true;
                mSignatureChanged = true;
            }

            public void afterTextChanged(android.text.Editable s) { }
        };

        mToView.addTextChangedListener(watcher);
        mCcView.addTextChangedListener(watcher);
        mBccView.addTextChangedListener(watcher);
        mSubjectView.addTextChangedListener(watcher);

        mMessageContentView.addTextChangedListener(watcher);
        mQuotedText.addTextChangedListener(watcher);

        /* Yes, there really are poeple who ship versions of android without a contact picker */
        if (mContacts.hasContactPicker()) {
            mAddToFromContacts.setOnClickListener(new OnClickListener() {
                @Override public void onClick(View v) {
                    doLaunchContactPicker(CONTACT_PICKER_TO);
                }
            });
            mAddCcFromContacts.setOnClickListener(new OnClickListener() {
                @Override public void onClick(View v) {
                    doLaunchContactPicker(CONTACT_PICKER_CC);
                }
            });
            mAddBccFromContacts.setOnClickListener(new OnClickListener() {
                @Override public void onClick(View v) {
                    doLaunchContactPicker(CONTACT_PICKER_BCC);
                }
            });
        } else {
            mAddToFromContacts.setVisibility(View.GONE);
            mAddCcFromContacts.setVisibility(View.GONE);
            mAddBccFromContacts.setVisibility(View.GONE);
        }
        /*
         * We set this to invisible by default. Other methods will turn it back on if it's
         * needed.
         */

        showOrHideQuotedText(QuotedTextMode.NONE);

        mQuotedTextShow.setOnClickListener(this);
        mQuotedTextEdit.setOnClickListener(this);
        mQuotedTextDelete.setOnClickListener(this);

        mFromView.setVisibility(View.GONE);

        mToView.setAdapter(mAddressAdapter);
        mToView.setTokenizer(new Rfc822Tokenizer());
        mToView.setValidator(mAddressValidator);

        mCcView.setAdapter(mAddressAdapter);
        mCcView.setTokenizer(new Rfc822Tokenizer());
        mCcView.setValidator(mAddressValidator);

        mBccView.setAdapter(mAddressAdapter);
        mBccView.setTokenizer(new Rfc822Tokenizer());
        mBccView.setValidator(mAddressValidator);


        mSubjectView.setOnFocusChangeListener(this);

        if (savedInstanceState != null) {
            /*
             * This data gets used in onCreate, so grab it here instead of onRestoreInstanceState
             */
            mSourceMessageProcessed = savedInstanceState.getBoolean(STATE_KEY_SOURCE_MESSAGE_PROCED, false);
        }


        final String action = intent.getAction();
        initFromIntent(intent);

        if (mIdentity == null) {
            mIdentity = mAccount.getIdentity(0);
        }

        if (mAccount.isSignatureBeforeQuotedText()) {
            mSignatureView = upperSignature;
            lowerSignature.setVisibility(View.GONE);
        } else {
            mSignatureView = lowerSignature;
            upperSignature.setVisibility(View.GONE);
        }
        mSignatureView.addTextChangedListener(sigwatcher);

        if (!mIdentity.getSignatureUse()) {
            mSignatureView.setVisibility(View.GONE);
        }

        mMessageFormat = mAccount.getMessageFormat();

        if (!mSourceMessageProcessed) {
            updateFrom();
            updateSignature();

            if (ACTION_REPLY.equals(action) ||
                    ACTION_REPLY_ALL.equals(action) ||
                    ACTION_FORWARD.equals(action) ||
                    ACTION_EDIT_DRAFT.equals(action)) {
                /*
                 * If we need to load the message we add ourself as a message listener here
                 * so we can kick it off. Normally we add in onResume but we don't
                 * want to reload the message every time the activity is resumed.
                 * There is no harm in adding twice.
                 */
                MessagingController.getInstance(getApplication()).addListener(mListener);

                final Account account = Preferences.getPreferences(this).getAccount(mMessageReference.accountUuid);
                final String folderName = mMessageReference.folderName;
                final String sourceMessageUid = mMessageReference.uid;
                MessagingController.getInstance(getApplication()).loadMessageForView(account, folderName, sourceMessageUid, null);
            }

            if (!ACTION_EDIT_DRAFT.equals(action)) {
                String bccAddress = mAccount.getAlwaysBcc();
                if ((bccAddress != null) && !("""".equals(bccAddress))) {
                    String[] bccAddresses = bccAddress.split("","");
                    for (String oneBccAddress : bccAddresses) {
                        addAddress(mBccView, new Address(oneBccAddress, """"));
                    }
                }
            }

            /*
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""action = "" + action + "", account = "" + mMessageReference.accountUuid + "", folder = "" + mMessageReference.folderName + "", sourceMessageUid = "" + mMessageReference.uid);
            */

            updateTitle();
        }

        if (ACTION_REPLY.equals(action) ||
                ACTION_REPLY_ALL.equals(action)) {
            mMessageReference.flag = Flag.ANSWERED;
        }

        if (ACTION_REPLY.equals(action) ||
                ACTION_REPLY_ALL.equals(action) ||
                ACTION_EDIT_DRAFT.equals(action)) {
            //change focus to message body.
            mMessageContentView.requestFocus();
        } else {
            // Explicitly set focus to ""To:"" input field (see issue 2998)
            mToView.requestFocus();
        }


        mEncryptLayout = findViewById(R.id.layout_encrypt);
        mCryptoSignatureCheckbox = (CheckBox)findViewById(R.id.cb_crypto_signature);
        mCryptoSignatureUserId = (TextView)findViewById(R.id.userId);
        mCryptoSignatureUserIdRest = (TextView)findViewById(R.id.userIdRest);
        mEncryptCheckbox = (CheckBox)findViewById(R.id.cb_encrypt);

        initializeCrypto();
        final CryptoProvider crypto = mAccount.getCryptoProvider();
        if (crypto.isAvailable(this)) {
            mEncryptLayout.setVisibility(View.VISIBLE);
            mCryptoSignatureCheckbox.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    CheckBox checkBox = (CheckBox) v;
                    if (checkBox.isChecked()) {
                        mPreventDraftSaving = true;
                        if (!crypto.selectSecretKey(MessageCompose.this, mPgpData)) {
                            mPreventDraftSaving = false;
                        }
                        checkBox.setChecked(false);
                    } else {
                        mPgpData.setSignatureKeyId(0);
                        updateEncryptLayout();
                    }
                }
            });

            if (mAccount.getCryptoAutoSignature()) {
                long ids[] = crypto.getSecretKeyIdsFromEmail(this, mIdentity.getEmail());
                if (ids != null && ids.length > 0) {
                    mPgpData.setSignatureKeyId(ids[0]);
                    mPgpData.setSignatureUserId(crypto.getUserId(this, ids[0]));
                } else {
                    mPgpData.setSignatureKeyId(0);
                    mPgpData.setSignatureUserId(null);
                }
            }
            updateEncryptLayout();
        } else {
            mEncryptLayout.setVisibility(View.GONE);
        }

        mDraftNeedsSaving = false;
    }

    /**
     * Handle external intents that trigger the message compose activity.
     *
     * @param intent The (external) intent that started the activity.
     */
    private void initFromIntent(final Intent intent) {
        final String action = intent.getAction();

        if (Intent.ACTION_VIEW.equals(action) || Intent.ACTION_SENDTO.equals(action)) {
            /*
             * Someone has clicked a mailto: link. The address is in the URI.
             */
            if (intent.getData() != null) {
                Uri uri = intent.getData();
                if (""mailto"".equals(uri.getScheme())) {
                    initializeFromMailto(uri);
                }
            }

            /*
             * Note: According to the documenation ACTION_VIEW and ACTION_SENDTO
             * don't accept EXTRA_* parameters. Contrary to the AOSP Email application
             * we don't accept those EXTRAs.
             * Dear developer, if your application is using those EXTRAs you're doing
             * it wrong! So go fix your program or get AOSP to change the documentation.
             */
        }
        //TODO: Use constant Intent.ACTION_SEND_MULTIPLE once we drop Android 1.5 support
        else if (Intent.ACTION_SEND.equals(action) ||
                 ""android.intent.action.SEND_MULTIPLE"".equals(action)) {
            /*
             * Note: Here we allow a slight deviation from the documentated behavior.
             * EXTRA_TEXT is used as message body (if available) regardless of the MIME
             * type of the intent. In addition one or multiple attachments can be added
             * using EXTRA_STREAM.
             */
            CharSequence text = intent.getCharSequenceExtra(Intent.EXTRA_TEXT);
            if (text != null) {
                mMessageContentView.setText(text);
            }

            String type = intent.getType();
            if (Intent.ACTION_SEND.equals(action)) {
                Uri stream = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);
                if (stream != null) {
                    addAttachment(stream, type);
                }
            } else {
                ArrayList<Parcelable> list = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
                if (list != null) {
                    for (Parcelable parcelable : list) {
                        Uri stream = (Uri) parcelable;
                        if (stream != null) {
                            addAttachment(stream, type);
                        }
                    }
                }
            }

            String subject = intent.getStringExtra(Intent.EXTRA_SUBJECT);
            if (subject != null) {
                mSubjectView.setText(subject);
            }

            String[] extraEmail = intent.getStringArrayExtra(Intent.EXTRA_EMAIL);
            String[] extraCc = intent.getStringArrayExtra(Intent.EXTRA_CC);
            String[] extraBcc = intent.getStringArrayExtra(Intent.EXTRA_BCC);

            if (extraEmail != null) {
                setRecipients(mToView, Arrays.asList(extraEmail));
            }

            boolean ccOrBcc = false;
            if (extraCc != null) {
                ccOrBcc |= setRecipients(mCcView, Arrays.asList(extraCc));
            }

            if (extraBcc != null) {
                ccOrBcc |= setRecipients(mBccView, Arrays.asList(extraBcc));
            }

            if (ccOrBcc) {
                // Display CC and BCC text fields if CC or BCC recipients were set by the intent.
                onAddCcBcc();
            }
        }
    }

    private boolean setRecipients(TextView view, List<String> recipients) {
        boolean recipientAdded = false;
        if (recipients != null) {
            StringBuffer addressList = new StringBuffer();
            for (String recipient : recipients) {
                addressList.append(recipient);
                addressList.append("", "");
                recipientAdded = true;
            }
            view.setText(addressList);
        }

        return recipientAdded;
    }

    private void initializeCrypto() {
        if (mPgpData != null) {
            return;
        }
        mPgpData = new PgpData();
    }

    /**
     * Fill the encrypt layout with the latest data about signature key and encryption keys.
     */
    public void updateEncryptLayout() {
        if (!mPgpData.hasSignatureKey()) {
            mCryptoSignatureCheckbox.setText(R.string.btn_crypto_sign);
            mCryptoSignatureCheckbox.setChecked(false);
            mCryptoSignatureUserId.setVisibility(View.INVISIBLE);
            mCryptoSignatureUserIdRest.setVisibility(View.INVISIBLE);
        } else {
            // if a signature key is selected, then the checkbox itself has no text
            mCryptoSignatureCheckbox.setText("""");
            mCryptoSignatureCheckbox.setChecked(true);
            mCryptoSignatureUserId.setVisibility(View.VISIBLE);
            mCryptoSignatureUserIdRest.setVisibility(View.VISIBLE);
            mCryptoSignatureUserId.setText(R.string.unknown_crypto_signature_user_id);
            mCryptoSignatureUserIdRest.setText("""");

            String userId = mPgpData.getSignatureUserId();
            if (userId == null) {
                userId = mAccount.getCryptoProvider().getUserId(this, mPgpData.getSignatureKeyId());
                mPgpData.setSignatureUserId(userId);
            }

            if (userId != null) {
                String chunks[] = mPgpData.getSignatureUserId().split("" <"", 2);
                mCryptoSignatureUserId.setText(chunks[0]);
                if (chunks.length > 1) {
                    mCryptoSignatureUserIdRest.setText(""<"" + chunks[1]);
                }
            }
        }
    }

    @Override
    public void onResume() {
        super.onResume();
        MessagingController.getInstance(getApplication()).addListener(mListener);
    }

    @Override
    public void onPause() {
        super.onPause();
        saveIfNeeded();
        MessagingController.getInstance(getApplication()).removeListener(mListener);
    }

    /**
     * The framework handles most of the fields, but we need to handle stuff that we
     * dynamically show and hide:
     * Attachment list,
     * Cc field,
     * Bcc field,
     * Quoted text,
     */
    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        saveIfNeeded();
        ArrayList<Uri> attachments = new ArrayList<Uri>();
        for (int i = 0, count = mAttachments.getChildCount(); i < count; i++) {
            View view = mAttachments.getChildAt(i);
            Attachment attachment = (Attachment) view.getTag();
            attachments.add(attachment.uri);
        }
        outState.putParcelableArrayList(STATE_KEY_ATTACHMENTS, attachments);
        outState.putBoolean(STATE_KEY_CC_SHOWN, mCcView.getVisibility() == View.VISIBLE);
        outState.putBoolean(STATE_KEY_BCC_SHOWN, mBccView.getVisibility() == View.VISIBLE);
        outState.putSerializable(STATE_KEY_QUOTED_TEXT_MODE, mQuotedTextMode);
        outState.putBoolean(STATE_KEY_SOURCE_MESSAGE_PROCED, mSourceMessageProcessed);
        outState.putString(STATE_KEY_DRAFT_UID, mDraftUid);
        outState.putSerializable(STATE_IDENTITY, mIdentity);
        outState.putBoolean(STATE_IDENTITY_CHANGED, mIdentityChanged);
        outState.putSerializable(STATE_PGP_DATA, mPgpData);
        outState.putString(STATE_IN_REPLY_TO, mInReplyTo);
        outState.putString(STATE_REFERENCES, mReferences);
        outState.putSerializable(STATE_KEY_HTML_QUOTE, mQuotedHtmlContent);
        outState.putSerializable(STATE_KEY_MESSAGE_FORMAT, mMessageFormat);
    }

    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        ArrayList<Parcelable> attachments = savedInstanceState.getParcelableArrayList(STATE_KEY_ATTACHMENTS);
        mAttachments.removeAllViews();
        for (Parcelable p : attachments) {
            Uri uri = (Uri) p;
            addAttachment(uri);
        }

        mMessageFormat = (MessageFormat) savedInstanceState
                         .getSerializable(STATE_KEY_MESSAGE_FORMAT);
        mCcWrapper.setVisibility(savedInstanceState.getBoolean(STATE_KEY_CC_SHOWN) ? View.VISIBLE
                                 : View.GONE);
        mBccWrapper.setVisibility(savedInstanceState
                                  .getBoolean(STATE_KEY_BCC_SHOWN) ? View.VISIBLE : View.GONE);
        showOrHideQuotedText((QuotedTextMode)savedInstanceState.getSerializable(STATE_KEY_QUOTED_TEXT_MODE));

        if (mQuotedTextMode != QuotedTextMode.NONE && mMessageFormat == MessageFormat.HTML) {
            mQuotedHtmlContent = (InsertableHtmlContent) savedInstanceState.getSerializable(STATE_KEY_HTML_QUOTE);
            if (mQuotedHtmlContent != null && mQuotedHtmlContent.getQuotedContent() != null) {
                mQuotedHTML.loadDataWithBaseURL(""http://"", mQuotedHtmlContent.getQuotedContent(), ""text/html"", ""utf-8"", null);
            }
        }
        mDraftUid = savedInstanceState.getString(STATE_KEY_DRAFT_UID);
        mIdentity = (Identity)savedInstanceState.getSerializable(STATE_IDENTITY);
        mIdentityChanged = savedInstanceState.getBoolean(STATE_IDENTITY_CHANGED);
        mPgpData = (PgpData) savedInstanceState.getSerializable(STATE_PGP_DATA);
        mInReplyTo = savedInstanceState.getString(STATE_IN_REPLY_TO);
        mReferences = savedInstanceState.getString(STATE_REFERENCES);

        initializeCrypto();
        updateFrom();
        updateSignature();
        updateEncryptLayout();

        mDraftNeedsSaving = false;
    }

    private void updateTitle() {
        if (mSubjectView.getText().length() == 0) {
            setTitle(R.string.compose_title);
        } else {
            setTitle(mSubjectView.getText().toString());
        }
    }

    public void onFocusChange(View view, boolean focused) {
        if (!focused) {
            updateTitle();
        }
    }

    private void addAddresses(MultiAutoCompleteTextView view, Address[] addresses) {
        if (addresses == null) {
            return;
        }
        for (Address address : addresses) {
            addAddress(view, address);
        }
    }

    private void addAddress(MultiAutoCompleteTextView view, Address address) {
        view.append(address + "", "");
    }

    private Address[] getAddresses(MultiAutoCompleteTextView view) {

        return Address.parseUnencoded(view.getText().toString().trim());
    }

    /*
     * Build the Body that will contain the text of the message. We'll decide where to
     * include it later. Draft messages are treated somewhat differently in that signatures are not
     * appended and HTML separators between composed text and quoted text are not added.
     * @param isDraft If we should build a message that will be saved as a draft (as opposed to sent).
     */
    private TextBody buildText(boolean isDraft) {
        boolean replyAfterQuote = false;
        String action = getIntent().getAction();
        if (mAccount.isReplyAfterQuote() &&
                (ACTION_REPLY.equals(action) || ACTION_REPLY_ALL.equals(action))) {
            replyAfterQuote = true;
        }

        String text = mMessageContentView.getText().toString();

        boolean discardQuotedText = false;
        if (!isDraft && !mQuotedTextMode.equals(QuotedTextMode.SHOW)) {
            discardQuotedText = true;
        }


        if (discardQuotedText) {
            if (!isDraft) {
                text = appendSignature(text);
            }

            text = HtmlConverter.textToHtmlFragment(text);
            // Build the body.
            TextBody body = new TextBody(text);
            body.setComposedMessageLength(text.length());
            body.setComposedMessageOffset(0);

            return body;
        }
        // Handle HTML separate from the rest of the text content. HTML mode doesn't allow signature after the quoted
        // text, nor does it allow reply after quote. Users who want that functionality will need to stick with text
        // mode.
        else if (mMessageFormat == MessageFormat.HTML) {
            // Add the signature.
            if (!isDraft) {
                text = appendSignature(text);
            }
            text = HtmlConverter.textToHtmlFragment(text);
            // Insert it into the existing content object.
            if (K9.DEBUG && mQuotedHtmlContent != null)
                Log.d(K9.LOG_TAG, ""insertable: "" + mQuotedHtmlContent.toDebugString());
            if (mQuotedHtmlContent != null) {

                // Set the insertion location based upon our reply after quote setting. Reply after
                // quote makes no sense for HEADER style replies. In addition, add some extra
                // separators between the composed message and quoted message depending on the quote
                // location. We only add the extra separators when we're sending, that way when we
                // load a draft, we don't have to know the length of the separators to remove them
                // before editing.
                if (mAccount.getQuoteStyle() == QuoteStyle.PREFIX && replyAfterQuote) {
                    mQuotedHtmlContent.setInsertionLocation(InsertableHtmlContent.InsertionLocation.AFTER_QUOTE);
                    if (!isDraft) {
                        text = ""<br clear=\""all\"">"" + text;
                    }
                } else {
                    mQuotedHtmlContent.setInsertionLocation(InsertableHtmlContent.InsertionLocation.BEFORE_QUOTE);
                    if (!isDraft) {
                        text += ""<br><br>"";
                    }
                }

                mQuotedHtmlContent.setUserContent(text);

                // All done.  Build the body.
                TextBody body = new TextBody(mQuotedHtmlContent.toString());
                // Save length of the body and its offset.  This is used when thawing drafts.
                body.setComposedMessageLength(text.length());
                body.setComposedMessageOffset(mQuotedHtmlContent.getInsertionPoint());
                return body;
            } else {
                TextBody body = new TextBody(text);
                body.setComposedMessageLength(text.length());
                // Not in reply to anything so the message starts at the beginning (0).
                body.setComposedMessageOffset(0);
                return body;
            }
        } else if (mMessageFormat == MessageFormat.TEXT) {
            // Capture composed message length before we start attaching quoted parts and signatures.
            Integer composedMessageLength = text.length();
            Integer composedMessageOffset = 0;

            // Placing the signature before the quoted text does not make sense if replyAfterQuote is true.
            if (!replyAfterQuote && !isDraft && mAccount.isSignatureBeforeQuotedText()) {
                text = appendSignature(text);
            }

            if (mQuotedTextMode != QuotedTextMode.NONE) {
                if (replyAfterQuote) {
                    composedMessageOffset = mQuotedText.getText().toString().length() + ""\n"".length();
                    text = mQuotedText.getText().toString() + ""\n"" + text;
                } else {
                    text += ""\n\n"" + mQuotedText.getText().toString();
                }
            }

            // Note: If user has selected reply after quote AND signature before quote, ignore the
            // latter setting and append the signature at the end.
            if (!isDraft && (!mAccount.isSignatureBeforeQuotedText() || replyAfterQuote)) {
                text = appendSignature(text);
            }

            // Build the body.
            TextBody body = new TextBody(text);
            body.setComposedMessageLength(composedMessageLength);
            body.setComposedMessageOffset(composedMessageOffset);

            return body;
        } else {
            // Shouldn't happen.
            return new TextBody("""");
        }
    }

    /**
     * Build the final message to be sent (or saved). If there is another message quoted in this one, it will be baked
     * into the final message here.
     * @param isDraft Indicates if this message is a draft or not. Drafts do not have signatures
     *  appended and have some extra metadata baked into their header for use during thawing.
     * @return Message to be sent.
     * @throws MessagingException
     */
    private MimeMessage createMessage(boolean isDraft) throws MessagingException {
        MimeMessage message = new MimeMessage();
        message.addSentDate(new Date());
        Address from = new Address(mIdentity.getEmail(), mIdentity.getName());
        message.setFrom(from);
        message.setRecipients(RecipientType.TO, getAddresses(mToView));
        message.setRecipients(RecipientType.CC, getAddresses(mCcView));
        message.setRecipients(RecipientType.BCC, getAddresses(mBccView));
        message.setSubject(mSubjectView.getText().toString());
        message.setHeader(""User-Agent"", getString(R.string.message_header_mua));

        final String replyTo = mIdentity.getReplyTo();
        if (replyTo != null) {
            message.setReplyTo(new Address[] { new Address(replyTo) });
        }

        if (mInReplyTo != null) {
            message.setInReplyTo(mInReplyTo);
        }

        if (mReferences != null) {
            message.setReferences(mReferences);
        }

        // Build the body.
        // TODO FIXME - body can be either an HTML or Text part, depending on whether we're in HTML mode or not.  Should probably fix this so we don't mix up html and text parts.
        TextBody body = null;
        if (mPgpData.getEncryptedData() != null) {
            String text = mPgpData.getEncryptedData();
            body = new TextBody(text);
        } else {
            body = buildText(isDraft);
        }

        final boolean hasAttachments = mAttachments.getChildCount() > 0;

        if (mMessageFormat == MessageFormat.HTML) {
            // HTML message (with alternative text part)

            // This is the compiled MIME part for an HTML message.
            MimeMultipart composedMimeMessage = new MimeMultipart();
            composedMimeMessage.setSubType(""alternative"");   // Let the receiver select either the text or the HTML part.
            composedMimeMessage.addBodyPart(new MimeBodyPart(body, ""text/html""));
            composedMimeMessage.addBodyPart(new MimeBodyPart(new TextBody(HtmlConverter.htmlToText(body.getText())), ""text/plain""));

            if (hasAttachments) {
                // If we're HTML and have attachments, we have a MimeMultipart container to hold the
                // whole message (mp here), of which one part is a MimeMultipart container
                // (composedMimeMessage) with the user's composed messages, and subsequent parts for
                // the attachments.
                MimeMultipart mp = new MimeMultipart();
                mp.addBodyPart(new MimeBodyPart(composedMimeMessage));
                addAttachmentsToMessage(mp);
                message.setBody(mp);
            } else {
                // If no attachments, our multipart/alternative part is the only one we need.
                message.setBody(composedMimeMessage);
            }
        } else {
            // Text-only message.
            if (hasAttachments) {
                MimeMultipart mp = new MimeMultipart();
                mp.addBodyPart(new MimeBodyPart(body, ""text/plain""));
                addAttachmentsToMessage(mp);
                message.setBody(mp);
            } else {
                // No attachments to include, just stick the text body in the message and call it good.
                message.setBody(body);
            }
        }

        // If this is a draft, add metadata for thawing.
        if (isDraft) {
            // Add the identity to the message.
            message.addHeader(K9.IDENTITY_HEADER, buildIdentityHeader(body));
        }

        return message;
    }

    /**
     * Add attachments as parts into a MimeMultipart container.
     * @param mp MimeMultipart container in which to insert parts.
     * @throws MessagingException
     */
    private void addAttachmentsToMessage(final MimeMultipart mp) throws MessagingException {
        for (int i = 0, count = mAttachments.getChildCount(); i < count; i++) {
            Attachment attachment = (Attachment) mAttachments.getChildAt(i).getTag();

            MimeBodyPart bp = new MimeBodyPart(
                new LocalStore.LocalAttachmentBody(attachment.uri, getApplication()));

            /*
             * Correctly encode the filename here. Otherwise the whole
             * header value (all parameters at once) will be encoded by
             * MimeHeader.writeTo().
             */
            bp.addHeader(MimeHeader.HEADER_CONTENT_TYPE, String.format(""%s;\n name=\""%s\"""",
                         attachment.contentType,
                         EncoderUtil.encodeIfNecessary(attachment.name,
                                 EncoderUtil.Usage.WORD_ENTITY, 7)));

            bp.addHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, ""base64"");

            /*
             * TODO: Oh the joys of MIME...
             *
             * From RFC 2183 (The Content-Disposition Header Field):
             * ""Parameter values longer than 78 characters, or which
             *  contain non-ASCII characters, MUST be encoded as specified
             *  in [RFC 2184].""
             *
             * Example:
             *
             * Content-Type: application/x-stuff
             *  title*1*=us-ascii'en'This%20is%20even%20more%20
             *  title*2*=%2A%2A%2Afun%2A%2A%2A%20
             *  title*3=""isn't it!""
             */
            bp.addHeader(MimeHeader.HEADER_CONTENT_DISPOSITION, String.format(
                             ""attachment;\n filename=\""%s\"";\n size=%d"",
                             attachment.name, attachment.size));

            mp.addBodyPart(bp);
        }
    }

    // FYI, there's nothing in the code that requires these variables to one letter. They're one
    // letter simply to save space.  This name sucks.  It's too similar to Account.Identity.
    private enum IdentityField {
        LENGTH(""l""),
        OFFSET(""o""),
        MESSAGE_FORMAT(""f""),
        SIGNATURE(""s""),
        NAME(""n""),
        EMAIL(""e""),
        // TODO - store a reference to the message being replied so we can mark it at the time of send.
        ORIGINAL_MESSAGE(""m""),
        CURSOR_POSITION(""p""),   // Where in the message your cursor was when you saved.
        QUOTED_TEXT_MODE(""q"");

        private final String value;

        IdentityField(String value) {
            this.value = value;
        }

        public String value() {
            return value;
        }

        /**
         * Get the list of IdentityFields that should be integer values. These values are sanity
         * checked for integer-ness during decoding.
         * @return
         */
        public static IdentityField[] getIntegerFields() {
            return new IdentityField[] { LENGTH, OFFSET };
        }
    }

    // Version identifier for ""new style"" identity. ! is an impossible value in base64 encoding, so we
    // use that to determine which version we're in.
    private static final String IDENTITY_VERSION_1 = ""!"";

    /**
     * Build the identity header string. This string contains metadata about a draft message to be
     * used upon loading a draft for composition. This should be generated at the time of saving a
     * draft.<br>
     * <br>
     * This is a URL-encoded key/value pair string.  The list of possible values are in {@link IdentityField}.
     * @param body {@link TextBody} to analyze for body length and offset.
     * @return Identity string.
     */
    private String buildIdentityHeader(final TextBody body) {
        Uri.Builder uri = new Uri.Builder();
        if (body.getComposedMessageLength() != null && body.getComposedMessageOffset() != null) {
            // See if the message body length is already in the TextBody.
            uri.appendQueryParameter(IdentityField.LENGTH.value(), body.getComposedMessageLength().toString());
            uri.appendQueryParameter(IdentityField.OFFSET.value(), body.getComposedMessageOffset().toString());
        } else {
            // If not, calculate it now.
            uri.appendQueryParameter(IdentityField.LENGTH.value(), Integer.toString(body.getText().length()));
            uri.appendQueryParameter(IdentityField.OFFSET.value(), Integer.toString(0));
        }
        // Save the message format for this offset.
        uri.appendQueryParameter(IdentityField.MESSAGE_FORMAT.value(), mMessageFormat.name());

        // If we're not using the standard identity of signature, append it on to the identity blob.
        if (mSignatureChanged) {
            uri.appendQueryParameter(IdentityField.SIGNATURE.value(), mSignatureView.getText().toString());
        }

        if (mIdentityChanged) {
            uri.appendQueryParameter(IdentityField.NAME.value(), mIdentity.getName());
            uri.appendQueryParameter(IdentityField.EMAIL.value(), mIdentity.getEmail());
        }

        if (mMessageReference != null) {
            uri.appendQueryParameter(IdentityField.ORIGINAL_MESSAGE.value(), mMessageReference.toIdentityString());
        }

        uri.appendQueryParameter(IdentityField.CURSOR_POSITION.value(), Integer.toString(mMessageContentView.getSelectionStart()));

        uri.appendQueryParameter(IdentityField.QUOTED_TEXT_MODE.value(), mQuotedTextMode.name());

        String k9identity = IDENTITY_VERSION_1 + uri.build().getEncodedQuery();

        if (K9.DEBUG) {
            Log.d(K9.LOG_TAG, ""Generated identity: "" + k9identity);
        }

        return k9identity;
    }

    /**
     * Parse an identity string.  Handles both legacy and new (!) style identities.
     * @param identityString
     * @return
     */
    private Map<IdentityField, String> parseIdentityHeader(final String identityString) {
        Map<IdentityField, String> identity = new HashMap<IdentityField, String>();

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""Decoding identity: "" + identityString);

        if (identityString == null || identityString.length() < 1) {
            return identity;
        }

        // Check to see if this is a ""next gen"" identity.
        if (identityString.charAt(0) == IDENTITY_VERSION_1.charAt(0) && identityString.length() > 2) {
            Uri.Builder builder = new Uri.Builder();
            builder.encodedQuery(identityString.substring(1));  // Need to cut off the ! at the beginning.
            Uri uri = builder.build();
            for (IdentityField key : IdentityField.values()) {
                String value = uri.getQueryParameter(key.value());
                if (value != null) {
                    identity.put(key, value);
                }
            }

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Decoded identity: "" + identity.toString());

            // Sanity check our Integers so that recipients of this result don't have to.
            for (IdentityField key : IdentityField.getIntegerFields()) {
                if (identity.get(key) != null) {
                    try {
                        Integer.parseInt(identity.get(key));
                    } catch (NumberFormatException e) {
                        Log.e(K9.LOG_TAG, ""Invalid "" + key.name() + "" field in identity: "" + identity.get(key));
                    }
                }
            }
        } else {
            // Legacy identity

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Got a saved legacy identity: "" + identityString);
            StringTokenizer tokens = new StringTokenizer(identityString, "":"", false);

            // First item is the body length. We use this to separate the composed reply from the quoted text.
            if (tokens.hasMoreTokens()) {
                String bodyLengthS = Utility.base64Decode(tokens.nextToken());
                try {
                    identity.put(IdentityField.LENGTH, Integer.valueOf(bodyLengthS).toString());
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Unable to parse bodyLength '"" + bodyLengthS + ""'"");
                }
            }
            if (tokens.hasMoreTokens()) {
                identity.put(IdentityField.SIGNATURE, Utility.base64Decode(tokens.nextToken()));
            }
            if (tokens.hasMoreTokens()) {
                identity.put(IdentityField.NAME, Utility.base64Decode(tokens.nextToken()));
            }
            if (tokens.hasMoreTokens()) {
                identity.put(IdentityField.EMAIL, Utility.base64Decode(tokens.nextToken()));
            }
            if (tokens.hasMoreTokens()) {
                identity.put(IdentityField.QUOTED_TEXT_MODE, Utility.base64Decode(tokens.nextToken()));
            }
        }

        return identity;
    }


    private String appendSignature(String text) {
        if (mIdentity.getSignatureUse()) {
            String signature = mSignatureView.getText().toString();

            if (signature != null && !signature.contentEquals("""")) {
                text += ""\n"" + signature;
            }
        }

        return text;
    }


    private void sendMessage() {
        new SendMessageTask().execute();
    }
    private void saveMessage() {
        new SaveMessageTask().execute();
    }

    private void saveIfNeeded() {
        if (!mDraftNeedsSaving || mPreventDraftSaving || mPgpData.hasEncryptionKeys()) {
            return;
        }

        mDraftNeedsSaving = false;
        saveMessage();
    }

    public void onEncryptionKeySelectionDone() {
        if (mPgpData.hasEncryptionKeys()) {
            onSend();
        } else {
            Toast.makeText(this, R.string.send_aborted, Toast.LENGTH_SHORT).show();
        }
    }

    public void onEncryptDone() {
        if (mPgpData.getEncryptedData() != null) {
            onSend();
        } else {
            Toast.makeText(this, R.string.send_aborted, Toast.LENGTH_SHORT).show();
        }
    }

    private void onSend() {
        if (getAddresses(mToView).length == 0 && getAddresses(mCcView).length == 0 && getAddresses(mBccView).length == 0) {
            mToView.setError(getString(R.string.message_compose_error_no_recipients));
            Toast.makeText(this, getString(R.string.message_compose_error_no_recipients), Toast.LENGTH_LONG).show();
            return;
        }
        if (mEncryptCheckbox.isChecked() && !mPgpData.hasEncryptionKeys()) {
            // key selection before encryption
            String emails = """";
            Address[][] addresses = new Address[][] { getAddresses(mToView),
                    getAddresses(mCcView),
                    getAddresses(mBccView)
                                                    };
            for (Address[] addressArray : addresses) {
                for (Address address : addressArray) {
                    if (emails.length() != 0) {
                        emails += "","";
                    }
                    emails += address.getAddress();
                }
            }
            if (emails.length() != 0) {
                emails += "","";
            }
            emails += mIdentity.getEmail();

            mPreventDraftSaving = true;
            if (!mAccount.getCryptoProvider().selectEncryptionKeys(MessageCompose.this, emails, mPgpData)) {
                mPreventDraftSaving = false;
            }
            return;
        }
        if (mPgpData.hasEncryptionKeys() || mPgpData.hasSignatureKey()) {
            if (mPgpData.getEncryptedData() == null) {
                String text = buildText(false).getText();
                mPreventDraftSaving = true;
                if (!mAccount.getCryptoProvider().encrypt(this, text, mPgpData)) {
                    mPreventDraftSaving = false;
                }
                return;
            }
        }
        sendMessage();

        if (mMessageReference != null && mMessageReference.flag != null) {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Setting referenced message ("" + mMessageReference.folderName + "", "" + mMessageReference.uid + "") flag to "" + mMessageReference.flag);

            final Account account = Preferences.getPreferences(this).getAccount(mMessageReference.accountUuid);
            final String folderName = mMessageReference.folderName;
            final String sourceMessageUid = mMessageReference.uid;
            MessagingController.getInstance(getApplication()).setFlag(account, folderName, new String[] {sourceMessageUid}, mMessageReference.flag, true);
        }

        mDraftNeedsSaving = false;
        finish();
    }

    private void onDiscard() {
        if (mDraftUid != null) {
            MessagingController.getInstance(getApplication()).deleteDraft(mAccount, mDraftUid);
            mDraftUid = null;
        }
        mHandler.sendEmptyMessage(MSG_DISCARDED_DRAFT);
        mDraftNeedsSaving = false;
        finish();
    }

    private void onSave() {
        mDraftNeedsSaving = true;
        saveIfNeeded();
        finish();
    }

    private void onAddCcBcc() {
        mCcWrapper.setVisibility(View.VISIBLE);
        mBccWrapper.setVisibility(View.VISIBLE);
    }

    /**
     * Kick off a picker for whatever kind of MIME types we'll accept and let Android take over.
     */
    private void onAddAttachment() {
        if (K9.isGalleryBuggy()) {
            if (K9.useGalleryBugWorkaround()) {
                Toast.makeText(MessageCompose.this,
                               getString(R.string.message_compose_use_workaround),
                               Toast.LENGTH_LONG).show();
            } else {
                Toast.makeText(MessageCompose.this,
                               getString(R.string.message_compose_buggy_gallery),
                               Toast.LENGTH_LONG).show();
            }
        }

        onAddAttachment2(""*/*"");
    }

    /**
     * Kick off a picker for the specified MIME type and let Android take over.
     */
    private void onAddAttachment2(final String mime_type) {
        if (mAccount.getCryptoProvider().isAvailable(this)) {
            Toast.makeText(this, R.string.attachment_encryption_unsupported, Toast.LENGTH_LONG).show();
        }
        Intent i = new Intent(Intent.ACTION_GET_CONTENT);
        i.addCategory(Intent.CATEGORY_OPENABLE);
        i.setType(mime_type);
        startActivityForResult(Intent.createChooser(i, null), ACTIVITY_REQUEST_PICK_ATTACHMENT);
    }

    private void addAttachment(Uri uri) {
        addAttachment(uri, null);
    }

    private void addAttachment(Uri uri, String contentType) {
        long size = -1;
        String name = null;

        ContentResolver contentResolver = getContentResolver();

        Cursor metadataCursor = contentResolver.query(
                                    uri,
                                    new String[] { OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE },
                                    null,
                                    null,
                                    null);

        if (metadataCursor != null) {
            try {
                if (metadataCursor.moveToFirst()) {
                    name = metadataCursor.getString(0);
                    size = metadataCursor.getInt(1);
                }
            } finally {
                metadataCursor.close();
            }
        }

        if (name == null) {
            name = uri.getLastPathSegment();
        }

        if ((contentType == null) || (contentType.indexOf('*') != -1)) {
            contentType = contentResolver.getType(uri);
        }
        if (contentType == null) {
            contentType = MimeUtility.getMimeTypeByExtension(name);
        }

        if (size <= 0) {
            String uriString = uri.toString();
            if (uriString.startsWith(""file://"")) {
                Log.v(K9.LOG_TAG, uriString.substring(""file://"".length()));
                File f = new File(uriString.substring(""file://"".length()));
                size = f.length();
            } else {
                Log.v(K9.LOG_TAG, ""Not a file: "" + uriString);
            }
        } else {
            Log.v(K9.LOG_TAG, ""old attachment.size: "" + size);
        }
        Log.v(K9.LOG_TAG, ""new attachment.size: "" + size);

        Attachment attachment = new Attachment();
        attachment.uri = uri;
        attachment.contentType = contentType;
        attachment.name = name;
        attachment.size = size;

        View view = getLayoutInflater().inflate(R.layout.message_compose_attachment, mAttachments, false);
        TextView nameView = (TextView)view.findViewById(R.id.attachment_name);
        ImageButton delete = (ImageButton)view.findViewById(R.id.attachment_delete);
        nameView.setText(attachment.name);
        delete.setOnClickListener(this);
        delete.setTag(view);
        view.setTag(attachment);
        mAttachments.addView(view);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        // if a CryptoSystem activity is returning, then mPreventDraftSaving was set to true
        mPreventDraftSaving = false;

        if (mAccount.getCryptoProvider().onActivityResult(this, requestCode, resultCode, data, mPgpData)) {
            return;
        }

        if (resultCode != RESULT_OK)
            return;
        if (data == null) {
            return;
        }
        switch (requestCode) {
        case ACTIVITY_REQUEST_PICK_ATTACHMENT:
            addAttachment(data.getData());
            mDraftNeedsSaving = true;
            break;
        case ACTIVITY_CHOOSE_IDENTITY:
            onIdentityChosen(data);
            break;
        case ACTIVITY_CHOOSE_ACCOUNT:
            onAccountChosen(data);
            break;
        case CONTACT_PICKER_TO:
        case CONTACT_PICKER_CC:
        case CONTACT_PICKER_BCC:
            String email = mContacts.getEmailFromContactPicker(data);
            if (email.length() == 0) {
                Toast.makeText(this, getString(R.string.error_contact_address_not_found), Toast.LENGTH_LONG).show();
                return;
            }
            if (requestCode == CONTACT_PICKER_TO) {
                addAddress(mToView, new Address(email, """"));
            } else if (requestCode == CONTACT_PICKER_CC) {
                addAddress(mCcView, new Address(email, """"));
            } else if (requestCode == CONTACT_PICKER_BCC) {
                addAddress(mBccView, new Address(email, """"));
            } else {
                return;
            }



            break;
        }
    }

    public void doLaunchContactPicker(int resultId) {
        startActivityForResult(mContacts.contactPickerIntent(), resultId);
    }



    private void onAccountChosen(final Intent intent) {
        final Bundle extras = intent.getExtras();
        final String uuid = extras.getString(ChooseAccount.EXTRA_ACCOUNT);
        final Identity identity = (Identity) extras.getSerializable(ChooseAccount.EXTRA_IDENTITY);

        final Account account = Preferences.getPreferences(this).getAccount(uuid);

        if (!mAccount.equals(account)) {
            if (K9.DEBUG) {
                Log.v(K9.LOG_TAG, ""Switching account from "" + mAccount + "" to "" + account);
            }

            // on draft edit, make sure we don't keep previous message UID
            if (ACTION_EDIT_DRAFT.equals(getIntent().getAction())) {
                mMessageReference = null;
            }

            // test whether there is something to save
            if (mDraftNeedsSaving || (mDraftUid != null)) {
                final String previousDraftUid = mDraftUid;
                final Account previousAccount = mAccount;

                // make current message appear as new
                mDraftUid = null;

                // actual account switch
                mAccount = account;

                if (K9.DEBUG) {
                    Log.v(K9.LOG_TAG, ""Account switch, saving new draft in new account"");
                }
                saveMessage();

                if (previousDraftUid != null) {
                    if (K9.DEBUG) {
                        Log.v(K9.LOG_TAG, ""Account switch, deleting draft from previous account: ""
                              + previousDraftUid);
                    }
                    MessagingController.getInstance(getApplication()).deleteDraft(previousAccount,
                            previousDraftUid);
                }
            } else {
                mAccount = account;
            }
            // not sure how to handle mFolder, mSourceMessage?
        }

        switchToIdentity(identity);
    }

    private void onIdentityChosen(Intent intent) {
        Bundle bundle = intent.getExtras();
        switchToIdentity((Identity) bundle.getSerializable(ChooseIdentity.EXTRA_IDENTITY));
    }

    private void switchToIdentity(Identity identity) {
        mIdentity = identity;
        mIdentityChanged = true;
        mDraftNeedsSaving = true;
        updateFrom();
        updateSignature();
    }

    private void updateFrom() {
        if (mIdentityChanged) {
            mFromView.setVisibility(View.VISIBLE);
        }
        mFromView.setText(getString(R.string.message_view_from_format, mIdentity.getName(), mIdentity.getEmail()));
    }

    private void updateSignature() {
        if (mIdentity.getSignatureUse()) {
            mSignatureView.setText(mIdentity.getSignature());
            mSignatureView.setVisibility(View.VISIBLE);
        } else {
            mSignatureView.setVisibility(View.GONE);
        }
    }

    public void onClick(View view) {
        switch (view.getId()) {
        case R.id.attachment_delete:
            /*
             * The view is the delete button, and we have previously set the tag of
             * the delete button to the view that owns it. We don't use parent because the
             * view is very complex and could change in the future.
             */
            mAttachments.removeView((View) view.getTag());
            mDraftNeedsSaving = true;
            break;
        case R.id.quoted_text_show:
            showOrHideQuotedText(QuotedTextMode.SHOW);
            mDraftNeedsSaving = true;
            break;
        case R.id.quoted_text_delete:
            showOrHideQuotedText(QuotedTextMode.HIDE);
            mDraftNeedsSaving = true;
            break;
        case R.id.quoted_text_edit:
            mMessageFormat = MessageFormat.TEXT;
            if (mMessageReference != null) { // shouldn't happen...
                // TODO - Should we check if mSourceMessageBody is already present and bypass the MessagingController call?
                MessagingController.getInstance(getApplication()).addListener(mListener);
                final Account account = Preferences.getPreferences(this).getAccount(mMessageReference.accountUuid);
                final String folderName = mMessageReference.folderName;
                final String sourceMessageUid = mMessageReference.uid;
                MessagingController.getInstance(getApplication()).loadMessageForView(account, folderName, sourceMessageUid, null);
            }
            break;
        }
    }

    /*
     * Show or Hide the quoted text according to mQuotedTextMode.
     */
    private void showOrHideQuotedText(QuotedTextMode mode) {
        mQuotedTextMode = mode;
        if (mQuotedTextMode == QuotedTextMode.NONE) {
            mQuotedTextShow.setVisibility(View.GONE);
            mQuotedTextBar.setVisibility(View.GONE);

            mQuotedText.setVisibility(View.GONE);
            mQuotedHTML.setVisibility(View.GONE);
            mQuotedTextEdit.setVisibility(View.GONE);
        } else if (mQuotedTextMode == QuotedTextMode.SHOW) {
            mQuotedTextShow.setVisibility(View.GONE);
            mQuotedTextBar.setVisibility(View.VISIBLE);
            if (mMessageFormat == MessageFormat.HTML) {
                mQuotedText.setVisibility(View.GONE);
                mQuotedHTML.setVisibility(View.VISIBLE);
                mQuotedTextEdit.setVisibility(View.VISIBLE);
            } else {
                mQuotedText.setVisibility(View.VISIBLE);
                mQuotedHTML.setVisibility(View.GONE);
                mQuotedTextEdit.setVisibility(View.GONE);
            }
        } else if (mQuotedTextMode == QuotedTextMode.HIDE) {
            mQuotedTextShow.setVisibility(View.VISIBLE);
            mQuotedTextBar.setVisibility(View.GONE);

            mQuotedText.setVisibility(View.GONE);
            mQuotedHTML.setVisibility(View.GONE);
            mQuotedTextEdit.setVisibility(View.GONE);
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.send:
            mPgpData.setEncryptionKeys(null);
            onSend();
            break;
        case R.id.save:
            onSave();
            break;
        case R.id.discard:
            onDiscard();
            break;
        case R.id.add_cc_bcc:
            onAddCcBcc();
            break;
        case R.id.add_attachment:
            onAddAttachment();
            break;
        case R.id.add_attachment_image:
            onAddAttachment2(""image/*"");
            break;
        case R.id.add_attachment_video:
            onAddAttachment2(""video/*"");
            break;
        case R.id.choose_identity:
            onChooseIdentity();
            break;
        default:
            return super.onOptionsItemSelected(item);
        }
        return true;
    }

    private void onChooseIdentity() {
        // keep things simple: trigger account choice only if there are more
        // than 1 account
        if (Preferences.getPreferences(this).getAvailableAccounts().size() > 1) {
            final Intent intent = new Intent(this, ChooseAccount.class);
            intent.putExtra(ChooseAccount.EXTRA_ACCOUNT, mAccount.getUuid());
            intent.putExtra(ChooseAccount.EXTRA_IDENTITY, mIdentity);
            startActivityForResult(intent, ACTIVITY_CHOOSE_ACCOUNT);
        } else if (mAccount.getIdentities().size() > 1) {
            Intent intent = new Intent(this, ChooseIdentity.class);
            intent.putExtra(ChooseIdentity.EXTRA_ACCOUNT, mAccount.getUuid());
            startActivityForResult(intent, ACTIVITY_CHOOSE_IDENTITY);
        } else {
            Toast.makeText(this, getString(R.string.no_identities),
                           Toast.LENGTH_LONG).show();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.message_compose_option, menu);

        /*
         * Show the menu items ""Add attachment (Image)"" and ""Add attachment (Video)""
         * if the work-around for the Gallery bug is enabled (see Issue 1186).
         */
        int found = 0;
        for (int i = menu.size() - 1; i >= 0; i--) {
            MenuItem item = menu.getItem(i);
            int id = item.getItemId();
            if ((id == R.id.add_attachment_image) ||
                    (id == R.id.add_attachment_video)) {
                item.setVisible(K9.useGalleryBugWorkaround());
                found++;
            }

            // We found all the menu items we were looking for. So stop here.
            if (found == 2) break;
        }

        return true;
    }

    @Override
    public void onBackPressed() {
        // This will be called either automatically for you on 2.0
        // or later, or by the code above on earlier versions of the
        // platform.
        if (mDraftNeedsSaving) {
            showDialog(DIALOG_SAVE_OR_DISCARD_DRAFT_MESSAGE);
        } else {
            finish();
        }
    }

    @Override
    public Dialog onCreateDialog(int id) {
        switch (id) {
        case DIALOG_SAVE_OR_DISCARD_DRAFT_MESSAGE:
            return new AlertDialog.Builder(this)
                   .setTitle(R.string.save_or_discard_draft_message_dlg_title)
                   .setMessage(R.string.save_or_discard_draft_message_instructions_fmt)
            .setPositiveButton(R.string.save_draft_action, new DialogInterface.OnClickListener() {
                public void onClick(DialogInterface dialog, int whichButton) {
                    dismissDialog(DIALOG_SAVE_OR_DISCARD_DRAFT_MESSAGE);
                    onSave();
                }
            })
            .setNegativeButton(R.string.discard_action, new DialogInterface.OnClickListener() {
                public void onClick(DialogInterface dialog, int whichButton) {
                    dismissDialog(DIALOG_SAVE_OR_DISCARD_DRAFT_MESSAGE);
                    onDiscard();
                }
            })
                   .create();
        }
        return super.onCreateDialog(id);
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (
            // TODO - when we move to android 2.0, uncomment this.
            // android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.ECLAIR &&

            keyCode == KeyEvent.KEYCODE_BACK
            && event.getRepeatCount() == 0
            && K9.manageBack()) {
            // Take care of calling this method on earlier versions of
            // the platform where it doesn't exist.
            onBackPressed();
            return true;
        }

        return super.onKeyDown(keyCode, event);
    }

    /**
     * Returns true if all attachments were able to be attached, otherwise returns false.
     */
    private boolean loadAttachments(Part part, int depth) throws MessagingException {
        if (part.getBody() instanceof Multipart) {
            Multipart mp = (Multipart) part.getBody();
            boolean ret = true;
            for (int i = 0, count = mp.getCount(); i < count; i++) {
                if (!loadAttachments(mp.getBodyPart(i), depth + 1)) {
                    ret = false;
                }
            }
            return ret;
        } else {
            String contentType = MimeUtility.unfoldAndDecode(part.getContentType());
            String name = MimeUtility.getHeaderParameter(contentType, ""name"");
            if (name != null) {
                Body body = part.getBody();
                if (body != null && body instanceof LocalAttachmentBody) {
                    final Uri uri = ((LocalAttachmentBody) body).getContentUri();
                    mHandler.post(new Runnable() {
                        public void run() {
                            addAttachment(uri);
                        }
                    });
                } else {
                    return false;
                }
            }
            return true;
        }
    }

    /**
     * Pull out the parts of the now loaded source message and apply them to the new message
     * depending on the type of message being composed.
     * @param message Source message
     */
    private void processSourceMessage(Message message) {
        String action = getIntent().getAction();
        try {
            if (ACTION_REPLY.equals(action) || ACTION_REPLY_ALL.equals(action)) {
                if (message.getSubject() != null) {
                    final String subject = prefix.matcher(message.getSubject()).replaceFirst("""");

                    if (!subject.toLowerCase().startsWith(""re:"")) {
                        mSubjectView.setText(""Re: "" + subject);
                    } else {
                        mSubjectView.setText(subject);
                    }
                } else {
                    mSubjectView.setText("""");
                }

                /*
                 * If a reply-to was included with the message use that, otherwise use the from
                 * or sender address.
                 */
                Address[] replyToAddresses;
                if (message.getReplyTo().length > 0) {
                    replyToAddresses = message.getReplyTo();
                } else {
                    replyToAddresses = message.getFrom();
                }

                // if we're replying to a message we sent, we probably meant
                // to reply to the recipient of that message
                if (mAccount.isAnIdentity(replyToAddresses)) {
                    replyToAddresses = message.getRecipients(RecipientType.TO);
                }

                addAddresses(mToView, replyToAddresses);



                if (message.getMessageId() != null && message.getMessageId().length() > 0) {
                    mInReplyTo = message.getMessageId();

                    if (message.getReferences() != null && message.getReferences().length > 0) {
                        StringBuffer buffy = new StringBuffer();
                        for (int i = 0; i < message.getReferences().length; i++)
                            buffy.append(message.getReferences()[i]);

                        mReferences = buffy.toString() + "" "" + mInReplyTo;
                    } else {
                        mReferences = mInReplyTo;
                    }

                } else {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""could not get Message-ID."");
                }

                // Quote the message and setup the UI.
                populateUIWithQuotedMessage(mAccount.isDefaultQuotedTextShown());

                if (ACTION_REPLY_ALL.equals(action) || ACTION_REPLY.equals(action)) {
                    Identity useIdentity = null;
                    for (Address address : message.getRecipients(RecipientType.TO)) {
                        Identity identity = mAccount.findIdentity(address);
                        if (identity != null) {
                            useIdentity = identity;
                            break;
                        }
                    }
                    if (useIdentity == null) {
                        if (message.getRecipients(RecipientType.CC).length > 0) {
                            for (Address address : message.getRecipients(RecipientType.CC)) {
                                Identity identity = mAccount.findIdentity(address);
                                if (identity != null) {
                                    useIdentity = identity;
                                    break;
                                }
                            }
                        }
                    }
                    if (useIdentity != null) {
                        Identity defaultIdentity = mAccount.getIdentity(0);
                        if (useIdentity != defaultIdentity) {
                            switchToIdentity(useIdentity);
                        }
                    }
                }

                if (ACTION_REPLY_ALL.equals(action)) {
                    for (Address address : message.getRecipients(RecipientType.TO)) {
                        if (!mAccount.isAnIdentity(address)) {
                            addAddress(mToView, address);
                        }

                    }
                    if (message.getRecipients(RecipientType.CC).length > 0) {
                        for (Address address : message.getRecipients(RecipientType.CC)) {
                            if (!mAccount.isAnIdentity(address) && !Utility.arrayContains(replyToAddresses, address)) {
                                addAddress(mCcView, address);
                            }

                        }
                        mCcView.setVisibility(View.VISIBLE);
                    }
                }
            } else if (ACTION_FORWARD.equals(action)) {
                if (message.getSubject() != null && !message.getSubject().toLowerCase().startsWith(""fwd:"")) {
                    mSubjectView.setText(""Fwd: "" + message.getSubject());
                } else {
                    mSubjectView.setText(message.getSubject());
                }

                // Quote the message and setup the UI.
                populateUIWithQuotedMessage(true);

                if (!mSourceMessageProcessed) {
                    if (!loadAttachments(message, 0)) {
                        mHandler.sendEmptyMessage(MSG_SKIPPED_ATTACHMENTS);
                    }
                }
            } else if (ACTION_EDIT_DRAFT.equals(action)) {
                String showQuotedTextMode = ""NONE"";

                mDraftUid = message.getUid();
                mSubjectView.setText(message.getSubject());
                addAddresses(mToView, message.getRecipients(RecipientType.TO));
                if (message.getRecipients(RecipientType.CC).length > 0) {
                    addAddresses(mCcView, message.getRecipients(RecipientType.CC));
                    mCcView.setVisibility(View.VISIBLE);
                }

                Address[] bccRecipients = message.getRecipients(RecipientType.BCC);
                if (bccRecipients.length > 0) {
                    addAddresses(mBccView, bccRecipients);
                    String bccAddress = mAccount.getAlwaysBcc();
                    if (bccRecipients.length == 1 && bccAddress != null && bccAddress.equals(bccRecipients[0].toString())) {
                        // If the auto-bcc is the only entry in the BCC list, don't show the Bcc fields.
                        mBccView.setVisibility(View.GONE);
                    } else {
                        mBccView.setVisibility(View.VISIBLE);
                    }
                }

                // Read In-Reply-To header from draft
                final String[] inReplyTo = message.getHeader(""In-Reply-To"");
                if ((inReplyTo != null) && (inReplyTo.length >= 1)) {
                    mInReplyTo = inReplyTo[0];
                }

                // Read References header from draft
                final String[] references = message.getHeader(""References"");
                if ((references != null) && (references.length >= 1)) {
                    mReferences = references[0];
                }

                if (!mSourceMessageProcessed) {
                    loadAttachments(message, 0);
                }

                // Decode the identity header when loading a draft.
                // See buildIdentityHeader(TextBody) for a detailed description of the composition of this blob.
                Map<IdentityField, String> k9identity = new HashMap<IdentityField, String>();
                if (message.getHeader(K9.IDENTITY_HEADER) != null && message.getHeader(K9.IDENTITY_HEADER).length > 0 && message.getHeader(K9.IDENTITY_HEADER)[0] != null) {
                    k9identity = parseIdentityHeader(message.getHeader(K9.IDENTITY_HEADER)[0]);
                }

                Identity newIdentity = new Identity();
                if (k9identity.containsKey(IdentityField.SIGNATURE)) {
                    newIdentity.setSignatureUse(true);
                    newIdentity.setSignature(k9identity.get(IdentityField.SIGNATURE));
                    mSignatureChanged = true;
                } else {
                    newIdentity.setSignatureUse(message.getFolder().getAccount().getSignatureUse());
                    newIdentity.setSignature(mIdentity.getSignature());
                }

                if (k9identity.containsKey(IdentityField.NAME)) {
                    newIdentity.setName(k9identity.get(IdentityField.NAME));
                    mIdentityChanged = true;
                } else {
                    newIdentity.setName(mIdentity.getName());
                }

                if (k9identity.containsKey(IdentityField.EMAIL)) {
                    newIdentity.setEmail(k9identity.get(IdentityField.EMAIL));
                    mIdentityChanged = true;
                } else {
                    newIdentity.setEmail(mIdentity.getEmail());
                }

                if (k9identity.containsKey(IdentityField.ORIGINAL_MESSAGE)) {
                    mMessageReference = null;
                    try {
                        mMessageReference = new MessageReference(k9identity.get(IdentityField.ORIGINAL_MESSAGE));
                    } catch (MessagingException e) {
                        Log.e(K9.LOG_TAG, ""Could not decode message reference in identity."", e);
                    }
                }

                int cursorPosition = 0;
                if (k9identity.containsKey(IdentityField.CURSOR_POSITION)) {
                    try {
                        cursorPosition = Integer.valueOf(k9identity.get(IdentityField.CURSOR_POSITION)).intValue();
                    } catch (Exception e) {
                        Log.e(K9.LOG_TAG, ""Could not parse cursor position for MessageCompose; continuing."", e);
                    }
                }

                if (k9identity.containsKey(IdentityField.QUOTED_TEXT_MODE)) {
                    showQuotedTextMode = k9identity.get(IdentityField.QUOTED_TEXT_MODE);
                }

                mIdentity = newIdentity;

                updateSignature();
                updateFrom();

                Integer bodyLength = k9identity.get(IdentityField.LENGTH) != null
                                     ? Integer.parseInt(k9identity.get(IdentityField.LENGTH))
                                     : 0;
                Integer bodyOffset = k9identity.get(IdentityField.OFFSET) != null
                                     ? Integer.parseInt(k9identity.get(IdentityField.OFFSET))
                                     : 0;
                // Always respect the user's current composition format preference, even if the
                // draft was saved in a different format.
                // TODO - The current implementation doesn't allow a user in HTML mode to edit a draft that wasn't saved with K9mail.
                String messageFormat = k9identity.get(IdentityField.MESSAGE_FORMAT);
                if (messageFormat == null) {
                    // This message probably wasn't created by us. The exception is legacy
                    // drafts created before the advent of HTML composition. In those cases,
                    // we'll display the whole message (including the quoted part) in the
                    // composition window. If that's the case, try and convert it to text to
                    // match the behavior in text mode.
                    mMessageContentView.setText(getBodyTextFromMessage(message, MessageFormat.TEXT));
                    mMessageFormat = MessageFormat.TEXT;
                    showOrHideQuotedText(QuotedTextMode.valueOf(showQuotedTextMode));
                    return;
                }

                mMessageFormat = MessageFormat.valueOf(messageFormat);

                if (mMessageFormat == MessageFormat.HTML) {
                    Part part = MimeUtility.findFirstPartByMimeType(message, ""text/html"");
                    if (part != null) { // Shouldn't happen if we were the one who saved it.
                        String text = MimeUtility.getTextFromPart(part);
                        if (K9.DEBUG) {
                            Log.d(K9.LOG_TAG, ""Loading message with offset "" + bodyOffset + "", length "" + bodyLength + "". Text length is "" + text.length() + ""."");
                        }

                        // Grab our reply text.
                        String bodyText = text.substring(bodyOffset, bodyOffset + bodyLength);
                        mMessageContentView.setText(HtmlConverter.htmlToText(bodyText));

                        // Regenerate the quoted html without our user content in it.
                        StringBuilder quotedHTML = new StringBuilder();
                        quotedHTML.append(text.substring(0, bodyOffset));   // stuff before the reply
                        quotedHTML.append(text.substring(bodyOffset + bodyLength));
                        if (quotedHTML.length() > 0) {
                            mQuotedHtmlContent = new InsertableHtmlContent();
                            mQuotedHtmlContent.setQuotedContent(quotedHTML);
                            mQuotedHtmlContent.setHeaderInsertionPoint(bodyOffset);
                            mQuotedHTML.loadDataWithBaseURL(""http://"", mQuotedHtmlContent.getQuotedContent(), ""text/html"", ""utf-8"", null);
                        }
                    }
                } else if (mMessageFormat == MessageFormat.TEXT) {
                    Part textPart = MimeUtility.findFirstPartByMimeType(message, ""text/plain"");
                    if (textPart != null) {
                        String text = MimeUtility.getTextFromPart(textPart);
                        // If we had a body length (and it was valid), separate the composition from the quoted text
                        // and put them in their respective places in the UI.
                        if (bodyLength != null && bodyLength + 1 < text.length()) { // + 1 to get rid of the newline we added when saving the draft
                            String bodyText = text.substring(0, bodyLength);
                            String quotedText = text.substring(bodyLength + 1, text.length());

                            mMessageContentView.setText(bodyText);
                            mQuotedText.setText(quotedText);
                        } else {
                            mMessageContentView.setText(text);
                        }
                    }
                } else {
                    Log.e(K9.LOG_TAG, ""Unhandled message format."");
                }

                // Set the cursor position if we have it.
                try {
                    mMessageContentView.setSelection(cursorPosition);
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Could not set cursor position in MessageCompose; ignoring."", e);
                }

                showOrHideQuotedText(QuotedTextMode.valueOf(showQuotedTextMode));
            }
        } catch (MessagingException me) {
            /**
             * Let the user continue composing their message even if we have a problem processing
             * the source message. Log it as an error, though.
             */
            Log.e(K9.LOG_TAG, ""Error while processing source message: "", me);
        } finally {
            mSourceMessageProcessed = true;
            mDraftNeedsSaving = false;
        }
    }

    /**
     * Build and populate the UI with the quoted message.
     * @throws MessagingException
     */
    private void populateUIWithQuotedMessage(boolean shown) throws MessagingException {
        // TODO -- I am assuming that mSourceMessageBody will always be a text part.  Is this a safe assumption?

        // Handle the original message in the reply
        // If we already have mSourceMessageBody, use that.  It's pre-populated if we've got crypto going on.
        String content = mSourceMessageBody != null
                         ? mSourceMessageBody
                         : getBodyTextFromMessage(mSourceMessage, mMessageFormat);
        if (mMessageFormat == MessageFormat.HTML) {
            // Add the HTML reply header to the top of the content.
            mQuotedHtmlContent = quoteOriginalHtmlMessage(mSourceMessage, content, mAccount.getQuoteStyle());
            // Load the message with the reply header.
            mQuotedHTML.loadDataWithBaseURL(""http://"", mQuotedHtmlContent.getQuotedContent(), ""text/html"", ""utf-8"", null);

        } else if (mMessageFormat == MessageFormat.TEXT) {
            mQuotedText.setText(quoteOriginalTextMessage(mSourceMessage, content, mAccount.getQuoteStyle()));
        }

        if (shown) {
            showOrHideQuotedText(QuotedTextMode.SHOW);
        } else {
            showOrHideQuotedText(QuotedTextMode.HIDE);
        }
    }

    /**
     * Fetch the body text from a message in the desired message format. This method handles
     * conversions between formats (html to text and vice versa) if necessary.
     * @param message Message to analyze for body part.
     * @param format Desired format.
     * @return Text in desired format.
     * @throws MessagingException
     */
    private String getBodyTextFromMessage(final Message message, final MessageFormat format) throws MessagingException {
        Part part;
        if (format == MessageFormat.HTML) {
            // HTML takes precedence, then text.
            part = MimeUtility.findFirstPartByMimeType(message, ""text/html"");
            if (part != null) {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""getBodyTextFromMessage: HTML requested, HTML found."");
                return MimeUtility.getTextFromPart(part);
            }

            part = MimeUtility.findFirstPartByMimeType(message, ""text/plain"");
            if (part != null) {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""getBodyTextFromMessage: HTML requested, text found."");
                return HtmlConverter.textToHtml(MimeUtility.getTextFromPart(part));
            }
        } else if (format == MessageFormat.TEXT) {
            // Text takes precedence, then html.
            part = MimeUtility.findFirstPartByMimeType(message, ""text/plain"");
            if (part != null) {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""getBodyTextFromMessage: Text requested, text found."");
                return MimeUtility.getTextFromPart(part);
            }

            part = MimeUtility.findFirstPartByMimeType(message, ""text/html"");
            if (part != null) {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""getBodyTextFromMessage: Text requested, HTML found."");
                return HtmlConverter.htmlToText(MimeUtility.getTextFromPart(part));
            }
        }

        // If we had nothing interesting, return an empty string.
        return """";
    }

    // Regular expressions to look for various HTML tags. This is no HTML::Parser, but hopefully it's good enough for
    // our purposes.
    private static final Pattern FIND_INSERTION_POINT_HTML = Pattern.compile(""(?si:.*?(<html(?:>|\\s+[^>]*>)).*)"");
    private static final Pattern FIND_INSERTION_POINT_HEAD = Pattern.compile(""(?si:.*?(<head(?:>|\\s+[^>]*>)).*)"");
    private static final Pattern FIND_INSERTION_POINT_BODY = Pattern.compile(""(?si:.*?(<body(?:>|\\s+[^>]*>)).*)"");
    private static final Pattern FIND_INSERTION_POINT_HTML_END = Pattern.compile(""(?si:.*(</html>).*?)"");
    private static final Pattern FIND_INSERTION_POINT_BODY_END = Pattern.compile(""(?si:.*(</body>).*?)"");
    // The first group in a Matcher contains the first capture group. We capture the tag found in the above REs so that
    // we can locate the *end* of that tag.
    private static final int FIND_INSERTION_POINT_FIRST_GROUP = 1;
    // HTML bits to insert as appropriate
    // TODO is it safe to assume utf-8 here?
    private static final String FIND_INSERTION_POINT_HTML_CONTENT = ""<!DOCTYPE html PUBLIC \""-//W3C//DTD HTML 4.0 Transitional//EN\"">\n<html>"";
    private static final String FIND_INSERTION_POINT_HTML_END_CONTENT = ""</html>"";
    private static final String FIND_INSERTION_POINT_HEAD_CONTENT = ""<head><meta content=\""text/html; charset=utf-8\"" http-equiv=\""Content-Type\""></head>"";
    // Index of the start of the beginning of a String.
    private static final int FIND_INSERTION_POINT_START_OF_STRING = 0;
    /**
     * <p>Find the start and end positions of the HTML in the string. This should be the very top
     * and bottom of the displayable message. It returns a {@link InsertableHtmlContent}, which
     * contains both the insertion points and potentially modified HTML. The modified HTML should be
     * used in place of the HTML in the original message.</p>
     *
     * <p>This method loosely mimics the HTML forward/reply behavior of BlackBerry OS 4.5/BIS 2.5, which in turn mimics
     * Outlook 2003 (as best I can tell).</p>
     *
     * @param content Content to examine for HTML insertion points
     * @return Insertion points and HTML to use for insertion.
     */
    private InsertableHtmlContent findInsertionPoints(final String content) {
        InsertableHtmlContent insertable = new InsertableHtmlContent();

        // If there is no content, don't bother doing any of the regex dancing.
        if (content == null || content.equals("""")) {
            return insertable;
        }

        // Search for opening tags.
        boolean hasHtmlTag = false;
        boolean hasHeadTag = false;
        boolean hasBodyTag = false;
        // First see if we have an opening HTML tag.  If we don't find one, we'll add one later.
        Matcher htmlMatcher = FIND_INSERTION_POINT_HTML.matcher(content);
        if (htmlMatcher.matches()) {
            hasHtmlTag = true;
        }
        // Look for a HEAD tag.  If we're missing a BODY tag, we'll use the close of the HEAD to start our content.
        Matcher headMatcher = FIND_INSERTION_POINT_HEAD.matcher(content);
        if (headMatcher.matches()) {
            hasHeadTag = true;
        }
        // Look for a BODY tag.  This is the ideal place for us to start our content.
        Matcher bodyMatcher = FIND_INSERTION_POINT_BODY.matcher(content);
        if (bodyMatcher.matches()) {
            hasBodyTag = true;
        }

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""Open: hasHtmlTag:"" + hasHtmlTag + "" hasHeadTag:"" + hasHeadTag + "" hasBodyTag:"" + hasBodyTag);

        // Given our inspections, let's figure out where to start our content.
        // This is the ideal case -- there's a BODY tag and we insert ourselves just after it.
        if (hasBodyTag) {
            insertable.setQuotedContent(new StringBuilder(content));
            insertable.setHeaderInsertionPoint(bodyMatcher.end(FIND_INSERTION_POINT_FIRST_GROUP));
        } else if (hasHeadTag) {
            // Now search for a HEAD tag.  We can insert after there.

            // If BlackBerry sees a HEAD tag, it inserts right after that, so long as there is no BODY tag. It doesn't
            // try to add BODY, either.  Right or wrong, it seems to work fine.
            insertable.setQuotedContent(new StringBuilder(content));
            insertable.setHeaderInsertionPoint(headMatcher.end(FIND_INSERTION_POINT_FIRST_GROUP));
        } else if (hasHtmlTag) {
            // Lastly, check for an HTML tag.
            // In this case, it will add a HEAD, but no BODY.
            StringBuilder newContent = new StringBuilder(content);
            // Insert the HEAD content just after the HTML tag.
            newContent.insert(htmlMatcher.end(FIND_INSERTION_POINT_FIRST_GROUP), FIND_INSERTION_POINT_HEAD_CONTENT);
            insertable.setQuotedContent(newContent);
            // The new insertion point is the end of the HTML tag, plus the length of the HEAD content.
            insertable.setHeaderInsertionPoint(htmlMatcher.end(FIND_INSERTION_POINT_FIRST_GROUP) + FIND_INSERTION_POINT_HEAD_CONTENT.length());
        } else {
            // If we have none of the above, we probably have a fragment of HTML.  Yahoo! and Gmail both do this.
            // Again, we add a HEAD, but not BODY.
            StringBuilder newContent = new StringBuilder(content);
            // Add the HTML and HEAD tags.
            newContent.insert(FIND_INSERTION_POINT_START_OF_STRING, FIND_INSERTION_POINT_HEAD_CONTENT);
            newContent.insert(FIND_INSERTION_POINT_START_OF_STRING, FIND_INSERTION_POINT_HTML_CONTENT);
            // Append the </HTML> tag.
            newContent.append(FIND_INSERTION_POINT_HTML_END_CONTENT);
            insertable.setQuotedContent(newContent);
            insertable.setHeaderInsertionPoint(FIND_INSERTION_POINT_HTML_CONTENT.length() + FIND_INSERTION_POINT_HEAD_CONTENT.length());
        }

        // Search for closing tags. We have to do this after we deal with opening tags since it may
        // have modified the message.
        boolean hasHtmlEndTag = false;
        boolean hasBodyEndTag = false;
        // First see if we have an opening HTML tag.  If we don't find one, we'll add one later.
        Matcher htmlEndMatcher = FIND_INSERTION_POINT_HTML_END.matcher(insertable.getQuotedContent());
        if (htmlEndMatcher.matches()) {
            hasHtmlEndTag = true;
        }
        // Look for a BODY tag.  This is the ideal place for us to place our footer.
        Matcher bodyEndMatcher = FIND_INSERTION_POINT_BODY_END.matcher(insertable.getQuotedContent());
        if (bodyEndMatcher.matches()) {
            hasBodyEndTag = true;
        }

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""Close: hasHtmlEndTag:"" + hasHtmlEndTag + "" hasBodyEndTag:"" + hasBodyEndTag);

        // Now figure out where to put our footer.
        // This is the ideal case -- there's a BODY tag and we insert ourselves just before it.
        if (hasBodyEndTag) {
            insertable.setFooterInsertionPoint(bodyEndMatcher.start(FIND_INSERTION_POINT_FIRST_GROUP));
        } else if (hasHtmlEndTag) {
            // Check for an HTML tag.  Add ourselves just before it.
            insertable.setFooterInsertionPoint(htmlEndMatcher.start(FIND_INSERTION_POINT_FIRST_GROUP));
        } else {
            // If we have none of the above, we probably have a fragment of HTML.
            // Set our footer insertion point as the end of the string.
            insertable.setFooterInsertionPoint(insertable.getQuotedContent().length());
        }

        return insertable;
    }

    class Listener extends MessagingListener {
        @Override
        public void loadMessageForViewStarted(Account account, String folder, String uid) {
            if ((mMessageReference == null) || !mMessageReference.uid.equals(uid)) {
                return;
            }

            mHandler.sendEmptyMessage(MSG_PROGRESS_ON);
        }

        @Override
        public void loadMessageForViewFinished(Account account, String folder, String uid, Message message) {
            if ((mMessageReference == null) || !mMessageReference.uid.equals(uid)) {
                return;
            }

            mHandler.sendEmptyMessage(MSG_PROGRESS_OFF);
        }

        @Override
        public void loadMessageForViewBodyAvailable(Account account, String folder, String uid, final Message message) {
            if ((mMessageReference == null) || !mMessageReference.uid.equals(uid)) {
                return;
            }

            mSourceMessage = message;
            runOnUiThread(new Runnable() {
                public void run() {
                    // We check to see if we've previously processed the source message since this
                    // could be called when switching from HTML to text replies. If that happens, we
                    // only want to update the UI with quoted text (which picks the appropriate
                    // part).
                    if (mSourceProcessed) {
                        try {
                            populateUIWithQuotedMessage(true);
                        } catch (MessagingException e) {
                            // Hm, if we couldn't populate the UI after source reprocessing, let's just delete it?
                            showOrHideQuotedText(QuotedTextMode.HIDE);
                            Log.e(K9.LOG_TAG, ""Could not re-process source message; deleting quoted text to be safe."", e);
                        }
                    } else {
                        processSourceMessage(message);
                        mSourceProcessed = true;
                    }
                }
            });
        }

        @Override
        public void loadMessageForViewFailed(Account account, String folder, String uid, Throwable t) {
            if ((mMessageReference == null) || !mMessageReference.uid.equals(uid)) {
                return;
            }
            mHandler.sendEmptyMessage(MSG_PROGRESS_OFF);
            // TODO show network error
        }

        @Override
        public void messageUidChanged(Account account, String folder, String oldUid, String newUid) {
            //TODO: is this really necessary here? mDraftUid is update after the call to MessagingController.saveDraft()
            // Track UID changes of the draft message
            if (account.equals(mAccount) &&
                    folder.equals(mAccount.getDraftsFolderName()) &&
                    oldUid.equals(mDraftUid)) {
                mDraftUid = newUid;
            }

            // Track UID changes of the source message
            if (mMessageReference != null) {
                final Account sourceAccount = Preferences.getPreferences(MessageCompose.this).getAccount(mMessageReference.accountUuid);
                final String sourceFolder = mMessageReference.folderName;
                final String sourceMessageUid = mMessageReference.uid;

                if (account.equals(sourceAccount) && (folder.equals(sourceFolder))) {
                    if (oldUid.equals(sourceMessageUid)) {
                        mMessageReference.uid = newUid;
                    }
                    if ((mSourceMessage != null) && (oldUid.equals(mSourceMessage.getUid()))) {
                        mSourceMessage.setUid(newUid);
                    }
                }
            }
        }
    }

    /**
     * When we are launched with an intent that includes a mailto: URI, we can actually
     * gather quite a few of our message fields from it.
     */
    private void initializeFromMailto(Uri mailtoUri) {
        String schemaSpecific = mailtoUri.getSchemeSpecificPart();
        int end = schemaSpecific.indexOf('?');
        if (end == -1) {
            end = schemaSpecific.length();
        }

        // Extract the recipient's email address from the mailto URI if there's one.
        String recipient = Uri.decode(schemaSpecific.substring(0, end));

        /*
         * mailto URIs are not hierarchical. So calling getQueryParameters()
         * will throw an UnsupportedOperationException. We avoid this by
         * creating a new hierarchical dummy Uri object with the query
         * parameters of the original URI.
         */
        Uri uri = Uri.parse(""foo://bar?"" + mailtoUri.getEncodedQuery());

        // Read additional recipients from the ""to"" parameter.
        List<String> to = uri.getQueryParameters(""to"");
        if (recipient.length() != 0) {
            to = new ArrayList<String>(to);
            to.add(0, recipient);
        }
        setRecipients(mToView, to);

        // Read carbon copy recipients from the ""cc"" parameter.
        boolean ccOrBcc = setRecipients(mCcView, uri.getQueryParameters(""cc""));

        // Read blind carbon copy recipients from the ""bcc"" parameter.
        ccOrBcc |= setRecipients(mBccView, uri.getQueryParameters(""bcc""));

        if (ccOrBcc) {
            // Display CC and BCC text fields if CC or BCC recipients were set by the intent.
            onAddCcBcc();
        }

        // Read subject from the ""subject"" parameter.
        List<String> subject = uri.getQueryParameters(""subject"");
        if (subject.size() > 0) {
            mSubjectView.setText(subject.get(0));
        }

        // Read message body from the ""body"" parameter.
        List<String> body = uri.getQueryParameters(""body"");
        if (body.size() > 0) {
            mMessageContentView.setText(body.get(0));
        }
    }

    private class SendMessageTask extends AsyncTask<Void, Void, Void> {
        @Override
        protected Void doInBackground(Void... params) {
            /*
             * Create the message from all the data the user has entered.
             */
            MimeMessage message;
            try {
                message = createMessage(false);  // isDraft = true
            } catch (MessagingException me) {
                Log.e(K9.LOG_TAG, ""Failed to create new message for send or save."", me);
                throw new RuntimeException(""Failed to create a new message for send or save."", me);
            }

            try {
                mContacts.markAsContacted(message.getRecipients(RecipientType.TO));
                mContacts.markAsContacted(message.getRecipients(RecipientType.CC));
                mContacts.markAsContacted(message.getRecipients(RecipientType.BCC));
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Failed to mark contact as contacted."", e);
            }

            MessagingController.getInstance(getApplication()).sendMessage(mAccount, message, null);
            if (mDraftUid != null) {
                MessagingController.getInstance(getApplication()).deleteDraft(mAccount, mDraftUid);
                mDraftUid = null;
            }

            return null;
        }
    }

    private class SaveMessageTask extends AsyncTask<Void, Void, Void> {
        @Override
        protected Void doInBackground(Void... params) {

            /*
             * Create the message from all the data the user has entered.
             */
            MimeMessage message;
            try {
                message = createMessage(true);  // isDraft = true
            } catch (MessagingException me) {
                Log.e(K9.LOG_TAG, ""Failed to create new message for send or save."", me);
                throw new RuntimeException(""Failed to create a new message for send or save."", me);
            }

            /*
             * Save a draft
             */
            if (mDraftUid != null) {
                message.setUid(mDraftUid);
            } else if (ACTION_EDIT_DRAFT.equals(getIntent().getAction())) {
                /*
                 * We're saving a previously saved draft, so update the new message's uid
                 * to the old message's uid.
                 */
                if (mMessageReference != null) {
                    message.setUid(mMessageReference.uid);
                }
            }

            final MessagingController messagingController = MessagingController.getInstance(getApplication());
            Message draftMessage = messagingController.saveDraft(mAccount, message);
            mDraftUid = draftMessage.getUid();

            // Don't display the toast if the user is just changing the orientation
            if ((getChangingConfigurations() & ActivityInfo.CONFIG_ORIENTATION) == 0) {
                mHandler.sendEmptyMessage(MSG_SAVED_DRAFT);
            }
            return null;
        }
    }

    private static final int REPLY_WRAP_LINE_WIDTH = 72;
    private static final int QUOTE_BUFFER_LENGTH = 512; // amount of extra buffer to allocate to accommodate quoting headers or prefixes

    /**
     * Add quoting markup to a text message.
     * @param originalMessage Metadata for message being quoted.
     * @param messageBody Text of the message to be quoted.
     * @param quoteStyle Style of quoting.
     * @return Quoted text.
     * @throws MessagingException
     */
    private String quoteOriginalTextMessage(final Message originalMessage, final String messageBody, final QuoteStyle quoteStyle) throws MessagingException {
        String body = messageBody == null ? """" : messageBody;
        if (quoteStyle == QuoteStyle.PREFIX) {
            StringBuilder quotedText = new StringBuilder(body.length() + QUOTE_BUFFER_LENGTH);
            quotedText.append(String.format(
                                  getString(R.string.message_compose_reply_header_fmt),
                                  Address.toString(originalMessage.getFrom()))
                             );

            final String prefix = mAccount.getQuotePrefix();
            final String wrappedText = Utility.wrap(body, REPLY_WRAP_LINE_WIDTH - prefix.length());

            // ""$"" and ""\"" in the quote prefix have to be escaped for
            // the replaceAll() invocation.
            final String escapedPrefix = prefix.replaceAll(""(\\\\|\\$)"", ""\\\\$1"");
            quotedText.append(wrappedText.replaceAll(""(?m)^"", escapedPrefix));

            return quotedText.toString().replaceAll(""\\\r"", """");
        } else if (quoteStyle == QuoteStyle.HEADER) {
            StringBuilder quotedText = new StringBuilder(body.length() + QUOTE_BUFFER_LENGTH);
            quotedText.append(""\n"");
            quotedText.append(getString(R.string.message_compose_quote_header_separator)).append(""\n"");
            if (originalMessage.getFrom() != null && Address.toString(originalMessage.getFrom()).length() != 0) {
                quotedText.append(getString(R.string.message_compose_quote_header_from)).append("" "").append(Address.toString(originalMessage.getFrom())).append(""\n"");
            }
            if (originalMessage.getSentDate() != null) {
                quotedText.append(getString(R.string.message_compose_quote_header_send_date)).append("" "").append(originalMessage.getSentDate()).append(""\n"");
            }
            if (originalMessage.getRecipients(RecipientType.TO) != null && originalMessage.getRecipients(RecipientType.TO).length != 0) {
                quotedText.append(getString(R.string.message_compose_quote_header_to)).append("" "").append(Address.toString(originalMessage.getRecipients(RecipientType.TO))).append(""\n"");
            }
            if (originalMessage.getRecipients(RecipientType.CC) != null && originalMessage.getRecipients(RecipientType.CC).length != 0) {
                quotedText.append(getString(R.string.message_compose_quote_header_cc)).append("" "").append(Address.toString(originalMessage.getRecipients(RecipientType.CC))).append(""\n"");
            }
            if (originalMessage.getSubject() != null) {
                quotedText.append(getString(R.string.message_compose_quote_header_subject)).append("" "").append(originalMessage.getSubject()).append(""\n"");
            }
            quotedText.append(""\n"");

            quotedText.append(body);

            return quotedText.toString();
        } else {
            // Shouldn't ever happen.
            return body;
        }
    }

    /**
     * Add quoting markup to a HTML message.
     * @param originalMessage Metadata for message being quoted.
     * @param messageBody Text of the message to be quoted.
     * @param quoteStyle Style of quoting.
     * @return Modified insertable message.
     * @throws MessagingException
     */
    private InsertableHtmlContent quoteOriginalHtmlMessage(final Message originalMessage, final String messageBody, final QuoteStyle quoteStyle) throws MessagingException {
        InsertableHtmlContent insertable = findInsertionPoints(messageBody);

        if (quoteStyle == QuoteStyle.PREFIX) {
            StringBuilder header = new StringBuilder(QUOTE_BUFFER_LENGTH);
            header.append(""<div class=\""gmail_quote\"">"");
            // Remove all trailing newlines so that the quote starts immediately after the header.  ""Be like Gmail!""
            header.append(HtmlConverter.textToHtmlFragment(String.format(
                              getString(R.string.message_compose_reply_header_fmt).replaceAll(""\n$"", """"),
                              Address.toString(originalMessage.getFrom()))
                                                          ));
            header.append(""<blockquote class=\""gmail_quote\"" "" +
                          ""style=\""margin: 0pt 0pt 0pt 0.8ex; border-left: 1px solid rgb(204, 204, 204); padding-left: 1ex;\"">\n"");

            String footer = ""</blockquote></div>"";

            insertable.insertIntoQuotedHeader(header.toString());
            insertable.insertIntoQuotedFooter(footer);
        } else if (quoteStyle == QuoteStyle.HEADER) {

            StringBuilder header = new StringBuilder();
            header.append(""<div style='font-size:10.0pt;font-family:\""Tahoma\"",\""sans-serif\"";padding:3.0pt 0in 0in 0in'>\n"");
            header.append(""<hr style='border:none;border-top:solid #B5C4DF 1.0pt'>\n""); // This gets converted into a horizontal line during html to text conversion.
            if (mSourceMessage.getFrom() != null && Address.toString(mSourceMessage.getFrom()).length() != 0) {
                header.append(""<b>"").append(getString(R.string.message_compose_quote_header_from)).append(""</b> "").append(HtmlConverter.textToHtmlFragment(Address.toString(mSourceMessage.getFrom()))).append(""<br>\n"");
            }
            if (mSourceMessage.getSentDate() != null) {
                header.append(""<b>"").append(getString(R.string.message_compose_quote_header_send_date)).append(""</b> "").append(mSourceMessage.getSentDate()).append(""<br>\n"");
            }
            if (mSourceMessage.getRecipients(RecipientType.TO) != null && mSourceMessage.getRecipients(RecipientType.TO).length != 0) {
                header.append(""<b>"").append(getString(R.string.message_compose_quote_header_to)).append(""</b> "").append(HtmlConverter.textToHtmlFragment(Address.toString(mSourceMessage.getRecipients(RecipientType.TO)))).append(""<br>\n"");
            }
            if (mSourceMessage.getRecipients(RecipientType.CC) != null && mSourceMessage.getRecipients(RecipientType.CC).length != 0) {
                header.append(""<b>"").append(getString(R.string.message_compose_quote_header_cc)).append(""</b> "").append(HtmlConverter.textToHtmlFragment(Address.toString(mSourceMessage.getRecipients(RecipientType.CC)))).append(""<br>\n"");
            }
            if (mSourceMessage.getSubject() != null) {
                header.append(""<b>"").append(getString(R.string.message_compose_quote_header_subject)).append(""</b> "").append(HtmlConverter.textToHtmlFragment(mSourceMessage.getSubject())).append(""<br>\n"");
            }
            header.append(""</div>\n"");
            header.append(""<br>\n"");

            insertable.insertIntoQuotedHeader(header.toString());
        }

        return insertable;
    }
}
",True,144,0,0,6,44,6,33,L1
61,com.fsck.k9.activity.ColorPickerDialog.java,"/* Sourced from http://code.google.com/p/android-color-picker/source/browse/trunk/AmbilWarna/src/yuku/ambilwarna/AmbilWarnaDialog.java?r=1
 * On 2010-11-07
 * Translated to English, Ported to use the same (inferior) API as the more standard ""ColorPickerDialog"" and imported into the K-9 namespace by Jesse Vincent
 * In an ideal world, we should move to using AmbilWarna as an Android Library Project in the future
 * License: Apache 2.0
 * Author: yukuku@code.google.com
 */


package com.fsck.k9.activity;
import com.fsck.k9.R;
import android.app.AlertDialog;
import android.content.*;
import android.graphics.Color;
import android.util.Log;
import android.view.*;
import android.widget.*;
import com.fsck.k9.view.ColorPickerBox;


public class ColorPickerDialog {
    private static final String TAG = ColorPickerDialog.class.getSimpleName();

    public interface OnColorChangedListener {
        void colorChanged(int color);
    }

    AlertDialog dialog;
    OnColorChangedListener listener;
    View viewHue;
    ColorPickerBox viewBox;
    ImageView arrow;
    View viewColorOld;
    View viewColorNew;
    ImageView viewSpyglass;

    float onedp;
    int colorOld;
    int colorNew;
    float hue;
    float sat;
    float val;
    float sizeUiDp = 240.f;
    float sizeUiPx; // diset di constructor

    public ColorPickerDialog(Context context, OnColorChangedListener listener, int color) {
        this.listener = listener;
        this.colorOld = color;
        this.colorNew = color;
        Color.colorToHSV(color, tmp01);
        hue = tmp01[0];
        sat = tmp01[1];
        val = tmp01[2];

        onedp = context.getResources().getDimension(R.dimen.colorpicker_onedp);
        sizeUiPx = sizeUiDp * onedp;
        Log.d(TAG, ""onedp = "" + onedp + "", sizeUiPx="" + sizeUiPx);  //$NON-NLS-1$//$NON-NLS-2$

        View view = LayoutInflater.from(context).inflate(R.layout.colorpicker_dialog, null);
        viewHue = view.findViewById(R.id.colorpicker_viewHue);
        viewBox = (ColorPickerBox) view.findViewById(R.id.colorpicker_viewBox);
        arrow = (ImageView) view.findViewById(R.id.colorpicker_arrow);
        viewColorOld = view.findViewById(R.id.colorpicker_colorOld);
        viewColorNew = view.findViewById(R.id.colorpicker_colorNew);
        viewSpyglass = (ImageView) view.findViewById(R.id.colorpicker_spyglass);

        placeArrow();
        placeSpyglass();
        viewBox.setHue(hue);
        viewColorOld.setBackgroundColor(color);
        viewColorNew.setBackgroundColor(color);

        viewHue.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                if (event.getAction() == MotionEvent.ACTION_MOVE
                        || event.getAction() == MotionEvent.ACTION_DOWN
                || event.getAction() == MotionEvent.ACTION_UP) {

                    float y = event.getY(); // dalam px, bukan dp
                    if (y < 0.f) y = 0.f;
                    if (y > sizeUiPx) y = sizeUiPx - 0.001f;

                    hue = 360.f - 360.f / sizeUiPx * y;
                    if (hue == 360.f) hue = 0.f;

                    colorNew = calculateColor();
                    // update view
                    viewBox.setHue(hue);
                    placeArrow();
                    viewColorNew.setBackgroundColor(colorNew);

                    return true;
                }
                return false;
            }
        });
        viewBox.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                if (event.getAction() == MotionEvent.ACTION_MOVE
                        || event.getAction() == MotionEvent.ACTION_DOWN
                || event.getAction() == MotionEvent.ACTION_UP) {

                    float x = event.getX(); // dalam px, bukan dp
                    float y = event.getY(); // dalam px, bukan dp

                    if (x < 0.f) x = 0.f;
                    if (x > sizeUiPx) x = sizeUiPx;
                    if (y < 0.f) y = 0.f;
                    if (y > sizeUiPx) y = sizeUiPx;

                    sat = (1.f / sizeUiPx * x);
                    val = 1.f - (1.f / sizeUiPx * y);

                    colorNew = calculateColor();
                    // update view
                    placeSpyglass();
                    viewColorNew.setBackgroundColor(colorNew);

                    return true;
                }
                return false;
            }
        });

        dialog = new AlertDialog.Builder(context)
        .setView(view)
        .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                if (ColorPickerDialog.this.listener != null) {
                    ColorPickerDialog.this.listener.colorChanged(colorNew);
                }
            }
        })
        .setNegativeButton(R.string.cancel_action, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                if (ColorPickerDialog.this.listener != null) {
                }
            }
        })
        .create();

    }

    @SuppressWarnings(""deprecation"")
    protected void placeArrow() {
        float y = sizeUiPx - (hue * sizeUiPx / 360.f);
        if (y == sizeUiPx) y = 0.f;

        AbsoluteLayout.LayoutParams layoutParams = (AbsoluteLayout.LayoutParams) arrow.getLayoutParams();
        layoutParams.y = (int)(y + 4);
        arrow.setLayoutParams(layoutParams);
    }

    @SuppressWarnings(""deprecation"")
    protected void placeSpyglass() {
        float x = sat * sizeUiPx;
        float y = (1.f - val) * sizeUiPx;

        AbsoluteLayout.LayoutParams layoutParams = (AbsoluteLayout.LayoutParams) viewSpyglass.getLayoutParams();
        layoutParams.x = (int)(x + 3);
        layoutParams.y = (int)(y + 3);
        viewSpyglass.setLayoutParams(layoutParams);
    }

    float[] tmp01 = new float[3];
    private int calculateColor() {
        tmp01[0] = hue;
        tmp01[1] = sat;
        tmp01[2] = val;
        return Color.HSVToColor(tmp01);
    }

    public void show() {
        dialog.show();
    }
}
",False,114,7,60,1,1,2,1,L1
62,com.fsck.k9.activity.K9PreferenceActivity.java,"package com.fsck.k9.activity;

import com.fsck.k9.K9;
import android.os.Bundle;
import android.preference.PreferenceActivity;
import android.preference.ListPreference;
import android.preference.Preference;


public class K9PreferenceActivity extends PreferenceActivity {
    @Override
    public void onCreate(Bundle icicle) {
        K9Activity.setLanguage(this, K9.getK9Language());
        // http://code.google.com/p/k9mail/issues/detail?id=2439
        // Re-enable themeing support in preferences when
        // http://code.google.com/p/android/issues/detail?id=4611 is resolved
        // setTheme(K9.getK9Theme());
        super.onCreate(icicle);
    }

    /**
     * Set up the {@link ListPreference} instance identified by {@code key}.
     *
     * @param key
     *         The key of the {@link ListPreference} object.
     * @param value
     *         Initial value for the {@link ListPreference} object.
     *
     * @return The {@link ListPreference} instance identified by {@code key}.
     */
    protected ListPreference setupListPreference(final String key, final String value) {
        final ListPreference prefView = (ListPreference) findPreference(key);
        prefView.setValue(value);
        prefView.setSummary(prefView.getEntry());
        prefView.setOnPreferenceChangeListener(new PreferenceChangeListener(prefView));
        return prefView;
    }

    /**
     * Initialize a given {@link ListPreference} instance.
     *
     * @param prefView
     *         The {@link ListPreference} instance to initialize.
     * @param value
     *         Initial value for the {@link ListPreference} object.
     * @param entries
     *         Sets the human-readable entries to be shown in the list.
     * @param entryValues
     *         The array to find the value to save for a preference when an
     *         entry from entries is selected.
     */
    protected void initListPreference(final ListPreference prefView, final String value,
                                      final CharSequence[] entries, final CharSequence[] entryValues) {
        prefView.setEntries(entries);
        prefView.setEntryValues(entryValues);
        prefView.setValue(value);
        prefView.setSummary(prefView.getEntry());
        prefView.setOnPreferenceChangeListener(new PreferenceChangeListener(prefView));
    }

    /**
     * This class handles value changes of the {@link ListPreference} objects.
     */
    private static class PreferenceChangeListener implements Preference.OnPreferenceChangeListener {
        private ListPreference mPrefView;

        private PreferenceChangeListener(final ListPreference prefView) {
            this.mPrefView = prefView;
        }

        /**
         * Show the preference value in the preference summary field.
         */
        @Override
        public boolean onPreferenceChange(final Preference preference, final Object newValue) {
            final String summary = newValue.toString();
            final int index = mPrefView.findIndexOfValue(summary);
            mPrefView.setSummary(mPrefView.getEntries()[index]);
            mPrefView.setValue(summary);
            return false;
        }
    }

}
",False,144,0,0,7,54,4,2,L1
63,com.fsck.k9.activity.ConfirmationDialog.java,"package com.fsck.k9.activity;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;

public class ConfirmationDialog {

    /**
     * Creates a customized confirmation dialog ({@link AlertDialog}).
     *
     * @param activity The activity this dialog is created for.
     * @param dialogId The id that was used with {@link Activity#showDialog(int)}
     * @param title The resource id of the text to display in the dialog title
     * @param message The text to display in the main dialog area
     * @param confirmButton The resource id of the text to display in the confirm button
     * @param cancelButton The resource id of the text to display in the cancel button
     * @param action The action to perform if the user presses the confirm button
     * @return A confirmation dialog with the supplied arguments
     */
    public static Dialog create(final Activity activity, final int dialogId, final int title,
                                final String message, final int confirmButton, final int cancelButton,
                                final Runnable action) {
        return create(activity, dialogId, title, message, confirmButton, cancelButton,
                      action, null);
    }

    /**
     * Creates a customized confirmation dialog ({@link AlertDialog}).
     *
     * @param activity The activity this dialog is created for.
     * @param dialogId The id that was used with {@link Activity#showDialog(int)}
     * @param title The resource id of the text to display in the dialog title
     * @param message The text to display in the main dialog area
     * @param confirmButton The resource id of the text to display in the confirm button
     * @param cancelButton The resource id of the text to display in the cancel button
     * @param action The action to perform if the user presses the confirm button
     * @param negativeAction The action to perform if the user presses the cancel button. Can be {@code null}.
     * @return A confirmation dialog with the supplied arguments
     */
    public static Dialog create(final Activity activity, final int dialogId, final int title,
                                final String message, final int confirmButton, final int cancelButton,
                                final Runnable action, final Runnable negativeAction) {

        final AlertDialog.Builder builder = new AlertDialog.Builder(activity);
        builder.setTitle(title);
        builder.setMessage(message);
        builder.setPositiveButton(confirmButton,
        new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                activity.dismissDialog(dialogId);
                action.run();
            }
        });
        builder.setNegativeButton(cancelButton,
        new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                activity.dismissDialog(dialogId);
                if (negativeAction != null) {
                    negativeAction.run();
                }
            }
        });
        return builder.create();
    }

    /**
     * Creates a customized confirmation dialog ({@link AlertDialog}).
     *
     * @param activity The activity this dialog is created for.
     * @param dialogId The id that was used with {@link Activity#showDialog(int)}
     * @param title The resource id of the text to display in the dialog title
     * @param message The resource id of text to display in the main dialog area
     * @param confirmButton The resource id of the text to display in the confirm button
     * @param cancelButton The resource id of the text to display in the cancel button
     * @param action The action to perform if the user presses the confirm button
     * @return A confirmation dialog with the supplied arguments
     * @see #create(Activity,int,int,String,int,int,Runnable, Runnable)
     */
    public static Dialog create(final Activity activity, final int dialogId, final int title,
                                final int message, final int confirmButton, final int cancelButton,
                                final Runnable action) {

        return create(activity, dialogId, title, activity.getString(message), confirmButton,
                      cancelButton, action, null);
    }
}
",True,113,6,61,0,0,1,0,L1
64,com.fsck.k9.activity.MessageList.java,"package com.fsck.k9.activity;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.Intent;
import android.graphics.Color;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.text.Spannable;
import android.text.SpannableStringBuilder;
import android.text.style.ForegroundColorSpan;
import android.text.style.StyleSpan;
import android.util.Log;
import android.util.TypedValue;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.GestureDetector;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.view.Window;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.AnimationUtils;
import android.widget.AdapterView;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.BaseAdapter;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageButton;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import com.fsck.k9.Account;
import com.fsck.k9.AccountStats;
import com.fsck.k9.FontSizes;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.SearchSpecification;
import com.fsck.k9.activity.setup.AccountSettings;
import com.fsck.k9.activity.setup.FolderSettings;
import com.fsck.k9.activity.setup.Prefs;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingController.SORT_TYPE;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.helper.MessageHelper;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import com.fsck.k9.mail.store.StorageManager;


/**
 * MessageList is the primary user interface for the program. This Activity
 * shows a list of messages.
 * From this Activity the user can perform all standard message operations.
 */
public class MessageList
    extends K9Activity
    implements OnClickListener, AdapterView.OnItemClickListener, AnimationListener {

    /**
     * Reverses the result of a {@link Comparator}.
     *
     * @param <T>
     */
    public static class ReverseComparator<T> implements Comparator<T> {
        private Comparator<T> mDelegate;

        /**
         * @param delegate
         *            Never <code>null</code>.
         */
        public ReverseComparator(final Comparator<T> delegate) {
            mDelegate = delegate;
        }

        @Override
        public int compare(final T object1, final T object2) {
            // arg1 & 2 are mixed up, this is done on purpose
            return mDelegate.compare(object2, object1);
        }

    }

    /**
     * Chains comparator to find a non-0 result.
     *
     * @param <T>
     */
    public static class ComparatorChain<T> implements Comparator<T> {

        private List<Comparator<T>> mChain;

        /**
         * @param chain
         *            Comparator chain. Never <code>null</code>.
         */
        public ComparatorChain(final List<Comparator<T>> chain) {
            mChain = chain;
        }

        @Override
        public int compare(T object1, T object2) {
            int result = 0;
            for (final Comparator<T> comparator : mChain) {
                result = comparator.compare(object1, object2);
                if (result != 0) {
                    break;
                }
            }
            return result;
        }

    }

    public static class AttachmentComparator implements Comparator<MessageInfoHolder> {

        @Override
        public int compare(MessageInfoHolder object1, MessageInfoHolder object2) {
            return (object1.message.hasAttachments() ? 0 : 1) - (object2.message.hasAttachments() ? 0 : 1);
        }

    }

    public static class FlaggedComparator implements Comparator<MessageInfoHolder> {

        @Override
        public int compare(MessageInfoHolder object1, MessageInfoHolder object2) {
            return (object1.flagged ? 0 : 1) - (object2.flagged ? 0 : 1);
        }

    }

    public static class UnreadComparator implements Comparator<MessageInfoHolder> {

        @Override
        public int compare(MessageInfoHolder object1, MessageInfoHolder object2) {
            return (object1.read ? 1 : 0) - (object2.read ? 1 : 0);
        }

    }

    public static class SenderComparator implements Comparator<MessageInfoHolder> {

        @Override
        public int compare(MessageInfoHolder object1, MessageInfoHolder object2) {
            return object1.compareCounterparty.toLowerCase().compareTo(object2.compareCounterparty.toLowerCase());
        }

    }

    public static class DateComparator implements Comparator<MessageInfoHolder> {

        @Override
        public int compare(MessageInfoHolder object1, MessageInfoHolder object2) {
            return object1.compareDate.compareTo(object2.compareDate);
        }

    }

    public static class SubjectComparator implements Comparator<MessageInfoHolder> {

        @Override
        public int compare(MessageInfoHolder arg0, MessageInfoHolder arg1) {
            // XXX doesn't respect the Comparator contract since it alters the compared object
            if (arg0.compareSubject == null) {
                arg0.compareSubject = Utility.stripSubject(arg0.message.getSubject());
            }
            if (arg1.compareSubject == null) {
                arg1.compareSubject = Utility.stripSubject(arg1.message.getSubject());
            }
            return arg0.compareSubject.compareToIgnoreCase(arg1.compareSubject);
        }

    }

    /**
     * Immutable empty {@link Message} array
     */
    private static final Message[] EMPTY_MESSAGE_ARRAY = new Message[0];

    private static final int DIALOG_MARK_ALL_AS_READ = 1;

    private static final int ACTIVITY_CHOOSE_FOLDER_MOVE = 1;
    private static final int ACTIVITY_CHOOSE_FOLDER_COPY = 2;

    private static final String EXTRA_ACCOUNT = ""account"";
    private static final String EXTRA_FOLDER  = ""folder"";
    private static final String EXTRA_QUERY = ""query"";
    private static final String EXTRA_QUERY_FLAGS = ""queryFlags"";
    private static final String EXTRA_FORBIDDEN_FLAGS = ""forbiddenFlags"";
    private static final String EXTRA_INTEGRATE = ""integrate"";
    private static final String EXTRA_ACCOUNT_UUIDS = ""accountUuids"";
    private static final String EXTRA_FOLDER_NAMES = ""folderNames"";
    private static final String EXTRA_TITLE = ""title"";
    private static final String EXTRA_LIST_POSITION = ""listPosition"";

    /**
     * Maps a {@link SORT_TYPE} to a {@link Comparator} implementation.
     */
    private static final Map<SORT_TYPE, Comparator<MessageInfoHolder>> SORT_COMPARATORS;

    static {
        // fill the mapping at class time loading

        final Map<SORT_TYPE, Comparator<MessageInfoHolder>> map = new EnumMap<SORT_TYPE, Comparator<MessageInfoHolder>>(SORT_TYPE.class);
        map.put(SORT_TYPE.SORT_ATTACHMENT, new AttachmentComparator());
        map.put(SORT_TYPE.SORT_DATE, new DateComparator());
        map.put(SORT_TYPE.SORT_FLAGGED, new FlaggedComparator());
        map.put(SORT_TYPE.SORT_SENDER, new SenderComparator());
        map.put(SORT_TYPE.SORT_SUBJECT, new SubjectComparator());
        map.put(SORT_TYPE.SORT_UNREAD, new UnreadComparator());

        // make it immutable to prevent accidental alteration (content is immutable already)
        SORT_COMPARATORS = Collections.unmodifiableMap(map);
    }

    private ListView mListView;

    private boolean mTouchView = true;
    private int mPreviewLines = 0;


    private MessageListAdapter mAdapter;
    private View mFooterView;

    private FolderInfoHolder mCurrentFolder;

    private LayoutInflater mInflater;

    private MessagingController mController;

    private Account mAccount;
    private int mUnreadMessageCount = 0;

    private GestureDetector gestureDetector;
    private View.OnTouchListener gestureListener;
    /**
     * Stores the name of the folder that we want to open as soon as possible
     * after load.
     */
    private String mFolderName;

    /**
     * If we're doing a search, this contains the query string.
     */
    private String mQueryString;
    private Flag[] mQueryFlags = null;
    private Flag[] mForbiddenFlags = null;
    private boolean mIntegrate = false;
    private String[] mAccountUuids = null;
    private String[] mFolderNames = null;
    private String mTitle;

    private MessageListHandler mHandler = new MessageListHandler();

    private SORT_TYPE sortType = SORT_TYPE.SORT_DATE;

    private boolean sortAscending = true;
    private boolean sortDateAscending = false;

    private boolean mStars = true;
    private boolean mCheckboxes = true;
    private int mSelectedCount = 0;

    private View mBatchButtonArea;
    private ImageButton mBatchReadButton;
    private ImageButton mBatchDeleteButton;
    private ImageButton mBatchFlagButton;
    private ImageButton mBatchDoneButton;

    private FontSizes mFontSizes = K9.getFontSizes();

    private Bundle mState = null;

    /**
     * Remember the selection to be consistent between menu display and menu item
     * selection
     */
    private MessageInfoHolder mSelectedMessage;

    /**
     * Relevant messages for the current context when we have to remember the
     * chosen messages between user interactions (eg. Selecting a folder for
     * move operation)
     */
    private List<MessageInfoHolder> mActiveMessages;

    private Context context;

    /* package visibility for faster inner class access */
    MessageHelper mMessageHelper = MessageHelper.getInstance(this);

    private StorageManager.StorageListener mStorageListener = new StorageListenerImplementation();

    private final class StorageListenerImplementation implements StorageManager.StorageListener {
        @Override
        public void onUnmount(String providerId) {
            if (mAccount != null && providerId.equals(mAccount.getLocalStorageProviderId())) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        onAccountUnavailable();
                    }
                });
            }
        }

        @Override
        public void onMount(String providerId) {
            // no-op
        }
    }

    class MessageListHandler {
        /**
         * @param messages Never {@code null}.
         */
        public void removeMessages(final List<MessageInfoHolder> messages) {
            if (messages.isEmpty()) {
                return;
            }
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    for (MessageInfoHolder message : messages) {
                        if (message != null) {
                            if (mFolderName == null || (message.folder != null && message.folder.name.equals(mFolderName))) {
                                if (message.selected && mSelectedCount > 0) {
                                    mSelectedCount--;
                                }
                                mAdapter.messages.remove(message);
                            }
                        }
                    }
                    resetUnreadCountOnThread();

                    mAdapter.notifyDataSetChanged();
                    toggleBatchButtons();
                }
            });
        }

        /**
         * @param messages Never {@code null}.
         */
        public void addMessages(final List<MessageInfoHolder> messages) {
            if (messages.isEmpty()) {
                return;
            }
            final boolean wasEmpty = mAdapter.messages.isEmpty();
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    for (final MessageInfoHolder message : messages) {
                        if (mFolderName == null || (message.folder != null && message.folder.name.equals(mFolderName))) {
                            int index;
                            synchronized (mAdapter.messages) {
                                index = Collections.binarySearch(mAdapter.messages, message, getComparator());
                            }

                            if (index < 0) {
                                index = (index * -1) - 1;
                            }

                            mAdapter.messages.add(index, message);
                        }
                    }

                    if (wasEmpty) {
                        mListView.setSelection(0);
                    }
                    resetUnreadCountOnThread();

                    mAdapter.notifyDataSetChanged();
                }
            });
        }

        private void resetUnreadCount() {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    resetUnreadCountOnThread();
                }
            });
        }

        private void resetUnreadCountOnThread() {
            if (mQueryString != null) {
                int unreadCount = 0;
                synchronized (mAdapter.messages) {
                    for (MessageInfoHolder holder : mAdapter.messages) {
                        unreadCount += holder.read ? 0 : 1;
                    }
                }
                mUnreadMessageCount = unreadCount;
                refreshTitleOnThread();
            }
        }

        private void sortMessages() {
            final Comparator<MessageInfoHolder> chainComparator = getComparator();

            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    synchronized (mAdapter.messages) {
                        Collections.sort(mAdapter.messages, chainComparator);
                    }
                    mAdapter.notifyDataSetChanged();
                }
            });
        }

        /**
         * @return The comparator to use to display messages in an ordered
         *         fashion. Never <code>null</code>.
         */
        protected Comparator<MessageInfoHolder> getComparator() {
            final List<Comparator<MessageInfoHolder>> chain = new ArrayList<Comparator<MessageInfoHolder>>(2 /* we add 2 comparators at most */);

            {
                // add the specified comparator
                final Comparator<MessageInfoHolder> comparator = SORT_COMPARATORS.get(sortType);
                if (sortAscending) {
                    chain.add(comparator);
                } else {
                    chain.add(new ReverseComparator<MessageInfoHolder>(comparator));
                }
            }

            {
                // add the date comparator if not already specified
                if (sortType != SORT_TYPE.SORT_DATE) {
                    final Comparator<MessageInfoHolder> comparator = SORT_COMPARATORS.get(SORT_TYPE.SORT_DATE);
                    if (sortDateAscending) {
                        chain.add(comparator);
                    } else {
                        chain.add(new ReverseComparator<MessageInfoHolder>(comparator));
                    }
                }
            }

            // build the comparator chain
            final Comparator<MessageInfoHolder> chainComparator = new ComparatorChain<MessageInfoHolder>(chain);

            return chainComparator;
        }

        public void folderLoading(String folder, boolean loading) {
            if (mCurrentFolder != null && mCurrentFolder.name.equals(folder)) {
                mCurrentFolder.loading = loading;
            }
            runOnUiThread(new Runnable() {
                @Override public void run() {
                    updateFooterView();
                }
            });
        }

        private void refreshTitle() {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    refreshTitleOnThread();
                }
            });
        }

        private void refreshTitleOnThread() {
            setWindowTitle();
            setWindowProgress();
        }

        private void setWindowProgress() {
            int level = Window.PROGRESS_END;

            if (mCurrentFolder != null && mCurrentFolder.loading && mAdapter.mListener.getFolderTotal() > 0) {
                int divisor = mAdapter.mListener.getFolderTotal();
                if (divisor != 0) {
                    level = (Window.PROGRESS_END / divisor) * (mAdapter.mListener.getFolderCompleted()) ;
                    if (level > Window.PROGRESS_END) {
                        level = Window.PROGRESS_END;
                    }
                }
            }

            getWindow().setFeatureInt(Window.FEATURE_PROGRESS, level);
        }

        private void setWindowTitle() {
            String displayName;

            if (mFolderName != null) {
                displayName  = mFolderName;

                if (mAccount.getInboxFolderName().equalsIgnoreCase(displayName)) {
                    displayName = getString(R.string.special_mailbox_name_inbox);
                } else if (mAccount.getOutboxFolderName().equals(displayName)) {
                    displayName = getString(R.string.special_mailbox_name_outbox);
                }

                String dispString = mAdapter.mListener.formatHeader(MessageList.this, getString(R.string.message_list_title, mAccount.getDescription(), displayName), mUnreadMessageCount, getTimeFormat());
                setTitle(dispString);
            } else if (mQueryString != null) {
                if (mTitle != null) {
                    String dispString = mAdapter.mListener.formatHeader(MessageList.this, mTitle, mUnreadMessageCount, getTimeFormat());
                    setTitle(dispString);
                } else {
                    setTitle(getString(R.string.search_results) + "": "" + mQueryString);
                }
            }
        }

        public void progress(final boolean progress) {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    showProgressIndicator(progress);
                }
            });
        }
    }

    public static void actionHandleFolder(Context context, Account account, String folder) {
        Intent intent = actionHandleFolderIntent(context, account, folder);
        context.startActivity(intent);
    }

    public static Intent actionHandleFolderIntent(Context context, Account account, String folder) {
        Intent intent = new Intent(context, MessageList.class);
        intent.putExtra(EXTRA_ACCOUNT, account.getUuid());

        if (folder != null) {
            intent.putExtra(EXTRA_FOLDER, folder);
        }
        return intent;
    }

    public static void actionHandle(Context context, String title, String queryString, boolean integrate, Flag[] flags, Flag[] forbiddenFlags) {
        Intent intent = new Intent(context, MessageList.class);
        intent.putExtra(EXTRA_QUERY, queryString);
        if (flags != null) {
            intent.putExtra(EXTRA_QUERY_FLAGS, Utility.combine(flags, ','));
        }
        if (forbiddenFlags != null) {
            intent.putExtra(EXTRA_FORBIDDEN_FLAGS, Utility.combine(forbiddenFlags, ','));
        }
        intent.putExtra(EXTRA_INTEGRATE, integrate);
        intent.putExtra(EXTRA_TITLE, title);
        context.startActivity(intent);
    }

    public static void actionHandle(Context context, String title, SearchSpecification searchSpecification) {
        Intent intent = new Intent(context, MessageList.class);
        intent.putExtra(EXTRA_QUERY, searchSpecification.getQuery());
        if (searchSpecification.getRequiredFlags() != null) {
            intent.putExtra(EXTRA_QUERY_FLAGS, Utility.combine(searchSpecification.getRequiredFlags(), ','));
        }
        if (searchSpecification.getForbiddenFlags() != null) {
            intent.putExtra(EXTRA_FORBIDDEN_FLAGS, Utility.combine(searchSpecification.getForbiddenFlags(), ','));
        }
        intent.putExtra(EXTRA_INTEGRATE, searchSpecification.isIntegrate());
        intent.putExtra(EXTRA_ACCOUNT_UUIDS, searchSpecification.getAccountUuids());
        intent.putExtra(EXTRA_FOLDER_NAMES, searchSpecification.getFolderNames());
        intent.putExtra(EXTRA_TITLE, title);
        context.startActivity(intent);
    }

    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
        if (view == mFooterView) {
            if (mCurrentFolder != null) {
                mController.loadMoreMessages(mAccount, mFolderName, mAdapter.mListener);
            }
            return;
        }

        MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(position);
        if (mSelectedCount > 0) {
            // In multiselect mode make sure that clicking on the item results
            // in toggling the 'selected' checkbox.
            setSelected(Collections.singletonList(message), !message.selected);
        } else {
            onOpenMessage(message);
        }
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        context = this;
        super.onCreate(savedInstanceState);

        mInflater = getLayoutInflater();
        initializeLayout();
        onNewIntent(getIntent());
    }

    @Override
    public void onNewIntent(Intent intent) {
        setIntent(intent); // onNewIntent doesn't autoset our ""internal"" intent

        // Only set ""touchable"" when we're first starting up the activity.
        // Otherwise we get force closes when the user toggles it midstream.
        mTouchView = K9.messageListTouchable();
        mPreviewLines = K9.messageListPreviewLines();

        String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mFolderName = intent.getStringExtra(EXTRA_FOLDER);
        mQueryString = intent.getStringExtra(EXTRA_QUERY);

        if (mAccount != null && !mAccount.isAvailable(this)) {
            Log.i(K9.LOG_TAG, ""not opening MessageList of unavailable account"");
            onAccountUnavailable();
            return;
        }

        String queryFlags = intent.getStringExtra(EXTRA_QUERY_FLAGS);
        if (queryFlags != null) {
            String[] flagStrings = queryFlags.split("","");
            mQueryFlags = new Flag[flagStrings.length];
            for (int i = 0; i < flagStrings.length; i++) {
                mQueryFlags[i] = Flag.valueOf(flagStrings[i]);
            }
        }
        String forbiddenFlags = intent.getStringExtra(EXTRA_FORBIDDEN_FLAGS);
        if (forbiddenFlags != null) {
            String[] flagStrings = forbiddenFlags.split("","");
            mForbiddenFlags = new Flag[flagStrings.length];
            for (int i = 0; i < flagStrings.length; i++) {
                mForbiddenFlags[i] = Flag.valueOf(flagStrings[i]);
            }
        }
        mIntegrate = intent.getBooleanExtra(EXTRA_INTEGRATE, false);
        mAccountUuids = intent.getStringArrayExtra(EXTRA_ACCOUNT_UUIDS);
        mFolderNames = intent.getStringArrayExtra(EXTRA_FOLDER_NAMES);
        mTitle = intent.getStringExtra(EXTRA_TITLE);

        // Take the initial folder into account only if we are *not* restoring
        // the activity already.
        if (mFolderName == null && mQueryString == null) {
            mFolderName = mAccount.getAutoExpandFolderName();
        }

        mAdapter = new MessageListAdapter();
        restorePreviousData();

        if (mFolderName != null) {
            mCurrentFolder = mAdapter.getFolder(mFolderName, mAccount);
        }

        mController = MessagingController.getInstance(getApplication());
        mListView.setAdapter(mAdapter);
    }

    private void restorePreviousData() {
        final ActivityState previousData = getLastNonConfigurationInstance();

        if (previousData != null) {
            mAdapter.messages.addAll(previousData.messages);
            mActiveMessages = previousData.activeMessages;
        }
    }

    @Override
    public void onPause() {
        super.onPause();
        mController.removeListener(mAdapter.mListener);
        saveListState();

        StorageManager.getInstance(getApplication()).removeListener(mStorageListener);
    }

    public void saveListState() {
        mState = new Bundle();
        mState.putInt(EXTRA_LIST_POSITION, mListView.getSelectedItemPosition());
    }

    public void restoreListState() {
        if (mState == null) {
            return;
        }

        int pos = mState.getInt(EXTRA_LIST_POSITION, ListView.INVALID_POSITION);

        if (pos >= mListView.getCount()) {
            pos = mListView.getCount() - 1;
        }

        if (pos == ListView.INVALID_POSITION) {
            mListView.setSelected(false);
        } else {
            mListView.setSelection(pos);
        }
    }

    /**
     * On resume we refresh messages for the folder that is currently open.
     * This guarantees that things like unread message count and read status
     * are updated.
     */
    @Override
    public void onResume() {
        super.onResume();

        if (mAccount != null && !mAccount.isAvailable(this)) {
            onAccountUnavailable();
            return;
        }
        StorageManager.getInstance(getApplication()).addListener(mStorageListener);

        mStars = K9.messageListStars();
        mCheckboxes = K9.messageListCheckboxes();

        sortType = mController.getSortType();
        sortAscending = mController.isSortAscending(sortType);
        sortDateAscending = mController.isSortAscending(SORT_TYPE.SORT_DATE);

        mController.addListener(mAdapter.mListener);
        if (mAccount != null) {
            mController.notifyAccountCancel(this, mAccount);
            MessagingController.getInstance(getApplication()).notifyAccountCancel(this, mAccount);
        }

        if (mAdapter.messages.isEmpty()) {
            if (mFolderName != null) {
                mController.listLocalMessages(mAccount, mFolderName,  mAdapter.mListener);
            } else if (mQueryString != null) {
                mController.searchLocalMessages(mAccountUuids, mFolderNames, null, mQueryString, mIntegrate, mQueryFlags, mForbiddenFlags, mAdapter.mListener);
            }

        } else {
            // reread the selected date format preference in case it has changed
            mMessageHelper.refresh();

            new Thread() {
                @Override
                public void run() {
                    mAdapter.markAllMessagesAsDirty();

                    if (mFolderName != null) {
                        mController.listLocalMessagesSynchronous(mAccount, mFolderName,  mAdapter.mListener);
                    } else if (mQueryString != null) {
                        mController.searchLocalMessagesSynchronous(mAccountUuids, mFolderNames, null, mQueryString, mIntegrate, mQueryFlags, mForbiddenFlags, mAdapter.mListener);
                    }


                    mAdapter.pruneDirtyMessages();
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            mAdapter.notifyDataSetChanged();
                            restoreListState();
                        }
                    });
                }

            }
            .start();
        }

        if (mAccount != null && mFolderName != null) {
            mController.getFolderUnreadMessageCount(mAccount, mFolderName, mAdapter.mListener);
        }
        mHandler.refreshTitle();

    }
    private void initializeLayout() {
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        requestWindowFeature(Window.FEATURE_PROGRESS);
        setContentView(R.layout.message_list);

        mListView = (ListView) findViewById(R.id.message_list);
        mListView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_INSET);
        mListView.setLongClickable(true);
        mListView.setFastScrollEnabled(true);
        mListView.setScrollingCacheEnabled(true);
        mListView.setOnItemClickListener(this);
        mListView.addFooterView(getFooterView(mListView));

        registerForContextMenu(mListView);

        mBatchButtonArea = findViewById(R.id.batch_button_area);
        mBatchReadButton = (ImageButton) findViewById(R.id.batch_read_button);
        mBatchReadButton.setOnClickListener(this);
        mBatchDeleteButton = (ImageButton) findViewById(R.id.batch_delete_button);
        mBatchDeleteButton.setOnClickListener(this);
        mBatchFlagButton = (ImageButton) findViewById(R.id.batch_flag_button);
        mBatchFlagButton.setOnClickListener(this);
        mBatchDoneButton = (ImageButton) findViewById(R.id.batch_done_button);

        mBatchDoneButton.setOnClickListener(this);

        // Gesture detection
        gestureDetector = new GestureDetector(new MyGestureDetector());
        gestureListener = new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                if (gestureDetector.onTouchEvent(event)) {
                    return true;
                }
                return false;
            }
        };

        mListView.setOnTouchListener(gestureListener);
    }

    /**
     * Container for values to be kept while the device configuration is
     * modified at runtime (keyboard, orientation, etc.) and Android restarts
     * this activity.
     *
     * @see MessageList#onRetainNonConfigurationInstance()
     * @see MessageList#getLastNonConfigurationInstance()
     */
    static class ActivityState {
        public List<MessageInfoHolder> messages;
        public List<MessageInfoHolder> activeMessages;
    }

    /* (non-Javadoc)
     *
     * Method overriden for proper typing within this class (the return type is
     * more specific than the super implementation)
     *
     * @see android.app.Activity#onRetainNonConfigurationInstance()
     */
    @Override
    public ActivityState onRetainNonConfigurationInstance() {
        final ActivityState state = new ActivityState();
        state.messages = mAdapter.messages;
        state.activeMessages = mActiveMessages;
        return state;
    }

    /*
     * (non-Javadoc)
     *
     * Method overriden for proper typing within this class (the return type is
     * more specific than the super implementation)
     *
     * @see android.app.Activity#getLastNonConfigurationInstance()
     */
    @Override
    public ActivityState getLastNonConfigurationInstance() {
        return (ActivityState) super.getLastNonConfigurationInstance();
    }

    @Override
    public void onBackPressed() {
        // This will be called either automatically for you on 2.0
        // or later, or by the code above on earlier versions of the
        // platform.
        if (K9.manageBack()) {
            if (mQueryString == null) {
                onShowFolderList();
            } else {
                onAccounts();
            }
        } else {
            finish();
        }
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (
            // XXX TODO - when we go to android 2.0, uncomment this
            // android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.ECLAIR &&
            keyCode == KeyEvent.KEYCODE_BACK
            && event.getRepeatCount() == 0
        ) {
            // Take care of calling this method on earlier versions of
            // the platform where it doesn't exist.
            onBackPressed();
            return true;
        }

        // Shortcuts that work no matter what is selected
        switch (keyCode) {

            // messagelist is actually a K9Activity, not a K9ListActivity
            // This saddens me greatly, but to support volume key navigation
            // in MessageView, we implement this bit of wrapper code
        case KeyEvent.KEYCODE_VOLUME_UP: {
            if (K9.useVolumeKeysForListNavigationEnabled()) {
                int currentPosition = mListView.getSelectedItemPosition();
                if (currentPosition == AdapterView.INVALID_POSITION || mListView.isInTouchMode()) {
                    currentPosition = mListView.getFirstVisiblePosition();
                }
                if (currentPosition > 0) {
                    mListView.setSelection(currentPosition - 1);
                }
                return true;
            }
            return false;
        }
        case KeyEvent.KEYCODE_VOLUME_DOWN: {
            if (K9.useVolumeKeysForListNavigationEnabled()) {
                int currentPosition = mListView.getSelectedItemPosition();
                if (currentPosition == AdapterView.INVALID_POSITION || mListView.isInTouchMode()) {
                    currentPosition = mListView.getFirstVisiblePosition();
                }

                if (currentPosition < mListView.getCount()) {
                    mListView.setSelection(currentPosition + 1);
                }
                return true;
            }
            return false;
        }
        case KeyEvent.KEYCODE_DPAD_LEFT: {
            if (mBatchButtonArea.hasFocus()) {
                return false;
            } else {
                return true;
            }
        }
        case KeyEvent.KEYCODE_DPAD_RIGHT: {
            if (mBatchButtonArea.hasFocus()) {
                return false;
            } else {
                return true;
            }
        }
        case KeyEvent.KEYCODE_C: {
            onCompose();
            return true;
        }
        case KeyEvent.KEYCODE_Q: {
            onShowFolderList();
            return true;
        }
        case KeyEvent.KEYCODE_O: {
            onCycleSort();
            return true;
        }
        case KeyEvent.KEYCODE_I: {
            onToggleSortAscending();
            return true;
        }
        case KeyEvent.KEYCODE_H: {
            Toast toast = Toast.makeText(this, R.string.message_list_help_key, Toast.LENGTH_LONG);
            toast.show();
            return true;
        }
        }

        boolean retval = true;
        int position = mListView.getSelectedItemPosition();
        try {
            if (position >= 0) {
                MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(position);

                final List<MessageInfoHolder> selection = getSelectionFromMessage(message);

                if (message != null) {
                    switch (keyCode) {
                    case KeyEvent.KEYCODE_DEL: {
                        onDelete(selection);
                        return true;
                    }
                    case KeyEvent.KEYCODE_S: {
                        setSelected(selection, !message.selected);
                        return true;
                    }
                    case KeyEvent.KEYCODE_D: {
                        onDelete(selection);
                        return true;
                    }
                    case KeyEvent.KEYCODE_F: {
                        onForward(message);
                        return true;
                    }
                    case KeyEvent.KEYCODE_A: {
                        onReplyAll(message);
                        return true;
                    }
                    case KeyEvent.KEYCODE_R: {
                        onReply(message);
                        return true;
                    }
                    case KeyEvent.KEYCODE_G: {
                        setFlag(selection, Flag.FLAGGED, !message.flagged);
                        return true;
                    }
                    case KeyEvent.KEYCODE_M: {
                        onMove(selection);
                        return true;
                    }
                    case KeyEvent.KEYCODE_V: {
                        onArchive(selection);
                        return true;
                    }
                    case KeyEvent.KEYCODE_Y: {
                        onCopy(selection);
                        return true;
                    }
                    case KeyEvent.KEYCODE_Z: {
                        setFlag(selection, Flag.SEEN, !message.read);
                        return true;
                    }
                    }
                }
            }
        } finally {
            retval = super.onKeyDown(keyCode, event);
        }
        return retval;
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        // Swallow these events too to avoid the audible notification of a volume change
        if (K9.useVolumeKeysForListNavigationEnabled()) {
            if ((keyCode == KeyEvent.KEYCODE_VOLUME_UP) || (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN)) {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""Swallowed key up."");
                return true;
            }
        }
        return super.onKeyUp(keyCode, event);
    }


    private void onResendMessage(MessageInfoHolder message) {
        MessageCompose.actionEditDraft(this, message.message.getFolder().getAccount(), message.message);
    }

    private void onOpenMessage(MessageInfoHolder message) {
        if (message.folder.name.equals(message.message.getFolder().getAccount().getDraftsFolderName())) {
            MessageCompose.actionEditDraft(this, message.message.getFolder().getAccount(), message.message);
        } else {
            // Need to get the list before the sort starts
            ArrayList<MessageReference> messageRefs = new ArrayList<MessageReference>();

            synchronized (mAdapter.messages) {
                for (MessageInfoHolder holder : mAdapter.messages) {
                    MessageReference ref = holder.message.makeMessageReference();
                    messageRefs.add(ref);
                }
            }
            MessageReference ref = message.message.makeMessageReference();
            Log.i(K9.LOG_TAG, ""MessageList sending message "" + ref);

            MessageView.actionView(this, ref, messageRefs, getIntent());
        }

        /*
         * We set read=true here for UI performance reasons. The actual value
         * will get picked up on the refresh when the Activity is resumed but
         * that may take a second or so and we don't want this to show and
         * then go away. I've gone back and forth on this, and this gives a
         * better UI experience, so I am putting it back in.
         */
        if (!message.read) {
            message.read = true;
        }
    }

    private void onAccounts() {
        Accounts.listAccounts(this);
        finish();
    }

    private void onShowFolderList() {
        FolderList.actionHandleAccount(this, mAccount);
        finish();
    }

    private void onCompose() {
        if (mQueryString != null) {
            /*
             * If we have a query string, we don't have an account to let
             * compose start the default action.
             */
            MessageCompose.actionCompose(this, null);
        } else {
            MessageCompose.actionCompose(this, mAccount);
        }
    }

    private void onEditPrefs() {
        Prefs.actionPrefs(this);
    }

    private void onEditAccount() {
        AccountSettings.actionSettings(this, mAccount);
    }

    private void changeSort(SORT_TYPE newSortType) {
        if (sortType == newSortType) {
            onToggleSortAscending();
        } else {
            sortType = newSortType;
            mController.setSortType(sortType);
            sortAscending = mController.isSortAscending(sortType);
            sortDateAscending = mController.isSortAscending(SORT_TYPE.SORT_DATE);
            reSort();
        }
    }

    private void reSort() {
        int toastString = sortType.getToast(sortAscending);

        Toast toast = Toast.makeText(this, toastString, Toast.LENGTH_SHORT);
        toast.show();

        mHandler.sortMessages();
    }

    private void onCycleSort() {
        SORT_TYPE[] sorts = SORT_TYPE.values();
        int curIndex = 0;

        for (int i = 0; i < sorts.length; i++) {
            if (sorts[i] == sortType) {
                curIndex = i;
                break;
            }
        }

        curIndex++;

        if (curIndex == sorts.length) {
            curIndex = 0;
        }

        changeSort(sorts[curIndex]);
    }

    private void onToggleSortAscending() {
        mController.setSortAscending(sortType, !sortAscending);

        sortAscending = mController.isSortAscending(sortType);
        sortDateAscending = mController.isSortAscending(SORT_TYPE.SORT_DATE);

        reSort();
    }

    /**
     * @param holders
     *            Never {@code null}.
     */
    private void onDelete(final List<MessageInfoHolder> holders) {
        // FIXME: removeMessage does it own check on the 'selected' field, we're duplicating the logic here...
        final List<Message> messagesToRemove = new ArrayList<Message>();
        for (MessageInfoHolder holder : holders) {
            if (holder.selected) {
                messagesToRemove.add(holder.message);
            }
        }
        mHandler.removeMessages(holders);
        mController.deleteMessages(messagesToRemove.toArray(EMPTY_MESSAGE_ARRAY), null);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (resultCode != RESULT_OK) {
            return;
        }

        switch (requestCode) {
        case ACTIVITY_CHOOSE_FOLDER_MOVE:
        case ACTIVITY_CHOOSE_FOLDER_COPY: {
            if (data == null) {
                return;
            }

            final String destFolderName = data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER);

            if (destFolderName != null) {
                final List<MessageInfoHolder> holders = mActiveMessages;

                mActiveMessages = null; // don't need it any more

                final Account account = holders.get(0).message.getFolder().getAccount();
                account.setLastSelectedFolderName(destFolderName);

                switch (requestCode) {
                case ACTIVITY_CHOOSE_FOLDER_MOVE:
                    move(holders, destFolderName);
                    break;

                case ACTIVITY_CHOOSE_FOLDER_COPY:
                    copy(holders, destFolderName);
                    break;
                }
            }
            break;
        }
        }
    }

    private void onReply(MessageInfoHolder holder) {
        MessageCompose.actionReply(this, holder.message.getFolder().getAccount(), holder.message, false, null);
    }

    private void onReplyAll(MessageInfoHolder holder) {
        MessageCompose.actionReply(this, holder.message.getFolder().getAccount(), holder.message, true, null);
    }

    private void onForward(MessageInfoHolder holder) {
        MessageCompose.actionForward(this, holder.message.getFolder().getAccount(), holder.message, null);
    }

    private void onMarkAllAsRead(final Account account, final String folder) {
        if (K9.confirmMarkAllAsRead()) {
            showDialog(DIALOG_MARK_ALL_AS_READ);
        } else {
            markAllAsRead();
        }
    }

    private void markAllAsRead() {
        try {
            mController.markAllMessagesRead(mAccount, mCurrentFolder.name);

            synchronized (mAdapter.messages) {
                for (MessageInfoHolder holder : mAdapter.messages) {
                    holder.read = true;
                }
            }
            mHandler.sortMessages();
        } catch (Exception e) {
            // Ignore
        }
    }

    private void onExpunge(final Account account, String folderName) {
        mController.expunge(account, folderName, null);
    }

    @Override
    public Dialog onCreateDialog(int id) {
        switch (id) {
        case DIALOG_MARK_ALL_AS_READ:
            return ConfirmationDialog.create(this, id,
                                             R.string.mark_all_as_read_dlg_title,
                                             getString(R.string.mark_all_as_read_dlg_instructions_fmt,
                                                     mCurrentFolder.displayName),
                                             R.string.okay_action,
                                             R.string.cancel_action,
            new Runnable() {
                @Override
                public void run() {
                    markAllAsRead();
                }
            });
        case R.id.dialog_confirm_spam:
            return ConfirmationDialog.create(this, id,
                                             R.string.dialog_confirm_spam_title,
                                             """" /* text is refreshed by #onPrepareDialog(int, Dialog) below */,
                                             R.string.dialog_confirm_spam_confirm_button,
                                             R.string.dialog_confirm_spam_cancel_button,
            new Runnable() {
                @Override
                public void run() {
                    onSpamConfirmed(mActiveMessages);
                    // No further need for this reference
                    mActiveMessages = null;
                }
            }, new Runnable() {
                @Override
                public void run() {
                    // event for cancel, we don't need this reference any more
                    mActiveMessages = null;
                }
            });
        }

        return super.onCreateDialog(id);
    }

    /*
     * (non-Javadoc)
     *
     * Android happens to invoke this method even if the given dialog is not
     * shown (eg. a dismissed dialog) as part of the automatic activity
     * reloading following a configuration change (orientation, keyboard,
     * locale, etc.).
     */
    @Override
    public void onPrepareDialog(final int id, final Dialog dialog) {
        switch (id) {
        case DIALOG_MARK_ALL_AS_READ: {
            if (mCurrentFolder != null) {
                ((AlertDialog)dialog).setMessage(getString(R.string.mark_all_as_read_dlg_instructions_fmt,
                                                 mCurrentFolder.displayName));
            }
            break;
        }
        case R.id.dialog_confirm_spam: {
            // mActiveMessages can be null if Android restarts the activity
            // while this dialog is not actually shown (but was displayed at
            // least once)
            if (mActiveMessages != null) {
                final int selectionSize = mActiveMessages.size();
                final String message;
                message = getResources().getQuantityString(R.plurals.dialog_confirm_spam_message, selectionSize,
                          Integer.valueOf(selectionSize));
                ((AlertDialog) dialog).setMessage(message);
            }
            break;
        }
        default: {
            super.onPrepareDialog(id, dialog);
        }
        }
    }

    private void onToggleRead(MessageInfoHolder holder) {
        mController.setFlag(holder.message.getFolder().getAccount(), holder.message.getFolder().getName(), new String[] { holder.uid }, Flag.SEEN, !holder.read);
        holder.read = !holder.read;
        mHandler.sortMessages();
    }

    private void onToggleFlag(MessageInfoHolder holder) {
        mController.setFlag(holder.message.getFolder().getAccount(), holder.message.getFolder().getName(), new String[] { holder.uid }, Flag.FLAGGED, !holder.flagged);
        holder.flagged = !holder.flagged;
        mHandler.sortMessages();
    }

    private void checkMail(Account account, String folderName) {
        mController.synchronizeMailbox(account, folderName, mAdapter.mListener, null);
        mController.sendPendingMessages(account, mAdapter.mListener);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        final List<MessageInfoHolder> selection = getSelectionFromCheckboxes();
        int itemId = item.getItemId();
        switch (itemId) {
        case R.id.compose: {
            onCompose();
            return true;
        }
        case R.id.accounts: {
            onAccounts();
            return true;
        }
        case R.id.set_sort_date: {
            changeSort(SORT_TYPE.SORT_DATE);
            return true;
        }
        case R.id.set_sort_subject: {
            changeSort(SORT_TYPE.SORT_SUBJECT);
            return true;
        }
        case R.id.set_sort_sender: {
            changeSort(SORT_TYPE.SORT_SENDER);
            return true;
        }
        case R.id.set_sort_flag: {
            changeSort(SORT_TYPE.SORT_FLAGGED);
            return true;
        }
        case R.id.set_sort_unread: {
            changeSort(SORT_TYPE.SORT_UNREAD);
            return true;
        }
        case R.id.set_sort_attach: {
            changeSort(SORT_TYPE.SORT_ATTACHMENT);
            return true;
        }
        case R.id.select_all:
        case R.id.batch_select_all: {
            setAllSelected(true);
            toggleBatchButtons();
            return true;
        }
        case R.id.batch_deselect_all: {
            setAllSelected(false);
            toggleBatchButtons();
            return true;
        }
        case R.id.batch_delete_op: {
            onDelete(selection);
            return true;
        }
        case R.id.batch_mark_read_op: {
            setFlag(selection, Flag.SEEN, true);
            return true;
        }
        case R.id.batch_mark_unread_op: {
            setFlag(selection, Flag.SEEN, false);
            return true;
        }
        case R.id.batch_flag_op: {
            setFlag(selection, Flag.FLAGGED, true);
            return true;
        }
        case R.id.batch_unflag_op: {
            setFlag(selection, Flag.FLAGGED, false);
            return true;
        }
        case R.id.app_settings: {
            onEditPrefs();
            return true;
        }
        }

        if (mQueryString != null) {
            // None of the options after this point are ""safe"" for search results
            //TODO: This is not true for ""unread"" and ""starred"" searches in regular folders
            return false;
        }

        switch (itemId) {
        case R.id.check_mail: {
            if (mFolderName != null) {
                checkMail(mAccount, mFolderName);
            }
            return true;
        }
        case R.id.send_messages: {
            mController.sendPendingMessages(mAccount, mAdapter.mListener);
            return true;
        }
        case R.id.list_folders: {
            onShowFolderList();
            return true;
        }
        case R.id.mark_all_as_read: {
            if (mFolderName != null) {
                onMarkAllAsRead(mAccount, mFolderName);
            }
            return true;
        }
        case R.id.folder_settings: {
            if (mFolderName != null) {
                FolderSettings.actionSettings(this, mAccount, mFolderName);
            }
            return true;
        }
        case R.id.account_settings: {
            onEditAccount();
            return true;
        }
        case R.id.batch_copy_op: {
            onCopy(selection);
            return true;
        }
        case R.id.batch_archive_op: {
            onArchive(selection);
            return true;
        }
        case R.id.batch_spam_op: {
            onSpam(selection);
            return true;
        }
        case R.id.batch_move_op: {
            onMove(selection);
            return true;
        }
        case R.id.expunge: {
            if (mCurrentFolder != null) {
                onExpunge(mAccount, mCurrentFolder.name);
            }
            return true;
        }
        default: {
            return super.onOptionsItemSelected(item);
        }
        }
    }

    private final int[] batch_ops = { R.id.batch_copy_op, R.id.batch_delete_op, R.id.batch_flag_op,
                                      R.id.batch_unflag_op, R.id.batch_mark_read_op, R.id.batch_mark_unread_op,
                                      R.id.batch_archive_op, R.id.batch_spam_op, R.id.batch_move_op,
                                      R.id.batch_select_all, R.id.batch_deselect_all
                                    };

    private void setOpsState(Menu menu, boolean state, boolean enabled) {
        for (int id : batch_ops) {
            menu.findItem(id).setVisible(state);
            menu.findItem(id).setEnabled(enabled);
        }
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        boolean anySelected = anySelected();

        menu.findItem(R.id.select_all).setVisible(! anySelected);
        menu.findItem(R.id.batch_ops).setVisible(anySelected);

        setOpsState(menu, true, anySelected);

        if (mQueryString != null) {
            menu.findItem(R.id.mark_all_as_read).setVisible(false);
            menu.findItem(R.id.list_folders).setVisible(false);
            menu.findItem(R.id.expunge).setVisible(false);
            menu.findItem(R.id.batch_archive_op).setVisible(false);
            menu.findItem(R.id.batch_spam_op).setVisible(false);
            menu.findItem(R.id.batch_move_op).setVisible(false);
            menu.findItem(R.id.batch_copy_op).setVisible(false);
            menu.findItem(R.id.check_mail).setVisible(false);
            menu.findItem(R.id.send_messages).setVisible(false);
            menu.findItem(R.id.folder_settings).setVisible(false);
            menu.findItem(R.id.account_settings).setVisible(false);
        } else {
            if (mCurrentFolder != null && mCurrentFolder.name.equals(mAccount.getOutboxFolderName())) {
                menu.findItem(R.id.check_mail).setVisible(false);
            } else {
                menu.findItem(R.id.send_messages).setVisible(false);
            }

            if (mCurrentFolder != null && K9.ERROR_FOLDER_NAME.equals(mCurrentFolder.name)) {
                menu.findItem(R.id.expunge).setVisible(false);
            }
            if (K9.FOLDER_NONE.equalsIgnoreCase(mAccount.getArchiveFolderName())) {
                menu.findItem(R.id.batch_archive_op).setVisible(false);
            }
            if (K9.FOLDER_NONE.equalsIgnoreCase(mAccount.getSpamFolderName())) {
                menu.findItem(R.id.batch_spam_op).setVisible(false);
            }
        }

        boolean newFlagState = computeBatchDirection(true);
        boolean newReadState = computeBatchDirection(false);
        menu.findItem(R.id.batch_flag_op).setVisible(newFlagState);
        menu.findItem(R.id.batch_unflag_op).setVisible(!newFlagState);
        menu.findItem(R.id.batch_mark_read_op).setVisible(newReadState);
        menu.findItem(R.id.batch_mark_unread_op).setVisible(!newReadState);
        menu.findItem(R.id.batch_deselect_all).setVisible(anySelected);
        menu.findItem(R.id.batch_select_all).setEnabled(true);

        return true;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.message_list_option, menu);

        return true;
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        AdapterContextMenuInfo info = (AdapterContextMenuInfo) item.getMenuInfo();
        final MessageInfoHolder holder = mSelectedMessage == null ? (MessageInfoHolder) mAdapter.getItem(info.position) : mSelectedMessage;
        // don't need this anymore
        mSelectedMessage = null;

        final List<MessageInfoHolder> selection = getSelectionFromMessage(holder);
        switch (item.getItemId()) {
        case R.id.open: {
            onOpenMessage(holder);
            break;
        }
        case R.id.select: {
            setSelected(selection, true);
            break;
        }
        case R.id.deselect: {
            setSelected(selection, false);
            break;
        }
        case R.id.delete: {
            onDelete(selection);
            break;
        }
        case R.id.reply: {
            onReply(holder);
            break;
        }
        case R.id.reply_all: {
            onReplyAll(holder);
            break;
        }
        case R.id.forward: {
            onForward(holder);
            break;
        }
        case R.id.send_again: {
            onResendMessage(holder);
            break;

        }
        case R.id.mark_as_read: {
            onToggleRead(holder);
            break;
        }
        case R.id.flag: {
            onToggleFlag(holder);
            break;
        }
        case R.id.archive: {
            onArchive(selection);
            break;
        }
        case R.id.spam: {
            onSpam(selection);
            break;
        }
        case R.id.move: {
            onMove(selection);
            break;
        }
        case R.id.copy: {
            onCopy(selection);
            break;
        }
        case R.id.send_alternate: {
            onSendAlternate(mAccount, holder);
            break;
        }
        case R.id.same_sender: {
            MessageList.actionHandle(MessageList.this,
                                     ""From "" + holder.sender, holder.senderAddress, true,
                                     null, null);
            break;
        }
        }
        return super.onContextItemSelected(item);
    }

    public void onSendAlternate(Account account, MessageInfoHolder holder) {
        mController.sendAlternate(this, account, holder.message);
    }

    public void showProgressIndicator(boolean status) {
        setProgressBarIndeterminateVisibility(status);
        ProgressBar bar = (ProgressBar)mListView.findViewById(R.id.message_list_progress);
        if (bar == null) {
            return;
        }

        bar.setIndeterminate(true);
        if (status) {
            bar.setVisibility(ProgressBar.VISIBLE);
        } else {
            bar.setVisibility(ProgressBar.INVISIBLE);
        }
    }

    class MyGestureDetector extends SimpleOnGestureListener {
        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            if (e2 == null || e1 == null)
                return true;

            float deltaX = e2.getX() - e1.getX(),
                  deltaY = e2.getY() - e1.getY();

            boolean movedAcross = (Math.abs(deltaX) > Math.abs(deltaY * 4));
            boolean steadyHand = (Math.abs(deltaX / deltaY) > 2);

            if (movedAcross && steadyHand) {
                boolean selected = (deltaX > 0);
                int position = mListView.pointToPosition((int)e1.getX(), (int)e1.getY());

                if (position != AdapterView.INVALID_POSITION) {
                    MessageInfoHolder msgInfoHolder = (MessageInfoHolder) mAdapter.getItem(position);

                    if (msgInfoHolder != null && msgInfoHolder.selected != selected) {
                        msgInfoHolder.selected = selected;
                        mSelectedCount += (selected ? 1 : -1);
                        mAdapter.notifyDataSetChanged();
                        toggleBatchButtons();
                    }
                }
            }

            return false;
        }
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);

        AdapterContextMenuInfo info = (AdapterContextMenuInfo) menuInfo;
        MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(info.position);
        // remember which message was originally selected, in case the list changes while the
        // dialog is up
        mSelectedMessage = message;

        if (message == null) {
            return;
        }

        getMenuInflater().inflate(R.menu.message_list_context, menu);

        menu.setHeaderTitle(message.message.getSubject());

        if (message.read) {
            menu.findItem(R.id.mark_as_read).setTitle(R.string.mark_as_unread_action);
        }

        if (message.flagged) {
            menu.findItem(R.id.flag).setTitle(R.string.unflag_action);
        }

        Account account = message.message.getFolder().getAccount();
        if (!mController.isCopyCapable(account)) {
            menu.findItem(R.id.copy).setVisible(false);
        }

        if (!mController.isMoveCapable(account)) {
            menu.findItem(R.id.move).setVisible(false);
            menu.findItem(R.id.archive).setVisible(false);
            menu.findItem(R.id.spam).setVisible(false);
        }

        if (K9.FOLDER_NONE.equalsIgnoreCase(account.getArchiveFolderName())) {
            menu.findItem(R.id.archive).setVisible(false);
        }
        if (K9.FOLDER_NONE.equalsIgnoreCase(account.getSpamFolderName())) {
            menu.findItem(R.id.spam).setVisible(false);
        }

        if (message.selected) {
            menu.findItem(R.id.select).setVisible(false);
            menu.findItem(R.id.deselect).setVisible(true);
        } else {
            menu.findItem(R.id.select).setVisible(true);
            menu.findItem(R.id.deselect).setVisible(false);
        }
    }

    class MessageListAdapter extends BaseAdapter {
        private final List<MessageInfoHolder> messages = java.util.Collections.synchronizedList(new ArrayList<MessageInfoHolder>());

        private final ActivityListener mListener = new ActivityListener() {

            @Override
            public void informUserOfStatus() {
                mHandler.refreshTitle();
            }

            @Override
            public void synchronizeMailboxStarted(Account account, String folder) {
                if (updateForMe(account, folder)) {
                    mHandler.progress(true);
                    mHandler.folderLoading(folder, true);
                }
                super.synchronizeMailboxStarted(account, folder);
            }

            @Override
            public void synchronizeMailboxFinished(Account account, String folder,
            int totalMessagesInMailbox, int numNewMessages) {

                if (updateForMe(account, folder)) {
                    mHandler.progress(false);
                    mHandler.folderLoading(folder, false);
                    mHandler.sortMessages();
                }
                super.synchronizeMailboxFinished(account, folder, totalMessagesInMailbox, numNewMessages);
            }

            @Override
            public void synchronizeMailboxFailed(Account account, String folder, String message) {

                if (updateForMe(account, folder)) {
                    mHandler.progress(false);
                    mHandler.folderLoading(folder, false);
                    mHandler.sortMessages();
                }
                super.synchronizeMailboxFailed(account, folder, message);
            }

            @Override
            public void synchronizeMailboxAddOrUpdateMessage(Account account, String folder, Message message) {
                addOrUpdateMessage(account, folder, message, true);
            }

            @Override
            public void synchronizeMailboxRemovedMessage(Account account, String folder, Message message) {
                MessageInfoHolder holder = getMessage(message);
                if (holder == null) {
                    Log.w(K9.LOG_TAG, ""Got callback to remove non-existent message with UID "" + message.getUid());
                } else {
                    removeMessages(Collections.singletonList(holder));
                }
            }

            @Override
            public void listLocalMessagesStarted(Account account, String folder) {
                if ((mQueryString != null && folder == null) || (account != null && account.equals(mAccount))) {
                    mHandler.progress(true);
                    if (folder != null) {
                        mHandler.folderLoading(folder, true);
                    }
                }
            }

            @Override
            public void listLocalMessagesFailed(Account account, String folder, String message) {
                if ((mQueryString != null && folder == null) || (account != null && account.equals(mAccount))) {
                    mHandler.sortMessages();
                    mHandler.progress(false);
                    if (folder != null) {
                        mHandler.folderLoading(folder, false);
                    }
                }
            }

            @Override
            public void listLocalMessagesFinished(Account account, String folder) {
                if ((mQueryString != null && folder == null) || (account != null && account.equals(mAccount))) {
                    mHandler.sortMessages();
                    mHandler.progress(false);
                    if (folder != null) {
                        mHandler.folderLoading(folder, false);
                    }
                }
            }

            @Override
            public void listLocalMessagesRemoveMessage(Account account, String folder, Message message) {
                MessageInfoHolder holder = getMessage(message);
                if (holder != null) {
                    removeMessages(Collections.singletonList(holder));
                }
            }

            @Override
            public void listLocalMessagesAddMessages(Account account, String folder, List<Message> messages) {
                addOrUpdateMessages(account, folder, messages, false);
            }

            @Override
            public void listLocalMessagesUpdateMessage(Account account, String folder, Message message) {
                addOrUpdateMessage(account, folder, message, false);
            }

            @Override
            public void searchStats(AccountStats stats) {
                mUnreadMessageCount = stats.unreadMessageCount;
                super.searchStats(stats);
            }

            @Override
            public void folderStatusChanged(Account account, String folder, int unreadMessageCount) {
                if (updateForMe(account, folder)) {
                    mUnreadMessageCount = unreadMessageCount;
                }
                super.folderStatusChanged(account, folder, unreadMessageCount);
            }

            @Override
            public void messageUidChanged(Account account, String folder, String oldUid, String newUid) {
                MessageReference ref = new MessageReference();
                ref.accountUuid = account.getUuid();
                ref.folderName = folder;
                ref.uid = oldUid;

                MessageInfoHolder holder = getMessage(ref);
                if (holder != null) {
                    holder.uid = newUid;
                    holder.message.setUid(newUid);
                }
            }
        };

        private boolean updateForMe(Account account, String folder) {
            if ((account.equals(mAccount) && mFolderName != null && folder.equals(mFolderName))) {
                return true;
            } else {
                return false;
            }
        }

        private Drawable mAttachmentIcon;
        private Drawable mAnsweredIcon;

        MessageListAdapter() {
            mAttachmentIcon = getResources().getDrawable(R.drawable.ic_email_attachment_small);
            mAnsweredIcon = getResources().getDrawable(R.drawable.ic_email_answered_small);
        }

        public void markAllMessagesAsDirty() {
            for (MessageInfoHolder holder : mAdapter.messages) {
                holder.dirty = true;
            }
        }
        public void pruneDirtyMessages() {
            synchronized (mAdapter.messages) {
                Iterator<MessageInfoHolder> iter = mAdapter.messages.iterator();
                while (iter.hasNext()) {
                    MessageInfoHolder holder = iter.next();
                    if (holder.dirty) {
                        if (holder.selected) {
                            mSelectedCount--;
                            toggleBatchButtons();
                        }
                        mAdapter.removeMessages(Collections.singletonList(holder));
                    }
                }
            }
        }

        /**
         * @param holders
         *            Never {@code null}.
         */
        public void removeMessages(List<MessageInfoHolder> holders) {
            mHandler.removeMessages(holders);
        }

        private void addOrUpdateMessage(Account account, String folderName, Message message, boolean verifyAgainstSearch) {
            List<Message> messages = new ArrayList<Message>();
            messages.add(message);
            addOrUpdateMessages(account, folderName, messages, verifyAgainstSearch);
        }

        private void addOrUpdateMessages(final Account account, final String folderName, final List<Message> providedMessages, final boolean verifyAgainstSearch) {
            // we copy the message list because the callback doesn't expect
            // the callbacks to mutate it.
            final List<Message> messages = new ArrayList<Message>(providedMessages);

            boolean needsSort = false;
            final List<MessageInfoHolder> messagesToAdd = new ArrayList<MessageInfoHolder>();
            List<MessageInfoHolder> messagesToRemove = new ArrayList<MessageInfoHolder>();
            List<Message> messagesToSearch = new ArrayList<Message>();

            // cache field into local variable for faster access for JVM without JIT
            final MessageHelper messageHelper = mMessageHelper;

            for (Message message : messages) {
                MessageInfoHolder m = getMessage(message);
                if (message.isSet(Flag.DELETED)) {
                    if (m != null) {
                        messagesToRemove.add(m);
                    }
                } else {
                    final Folder messageFolder = message.getFolder();
                    final Account messageAccount = messageFolder.getAccount();
                    if (m == null) {
                        if (updateForMe(account, folderName)) {
                            m = new MessageInfoHolder();
                            messageHelper.populate(m, message, new FolderInfoHolder(MessageList.this, messageFolder, messageAccount), messageAccount);
                            messagesToAdd.add(m);
                        } else {
                            if (mQueryString != null) {
                                if (verifyAgainstSearch) {
                                    messagesToSearch.add(message);
                                } else {
                                    m = new MessageInfoHolder();
                                    messageHelper.populate(m, message, new FolderInfoHolder(MessageList.this, messageFolder, messageAccount), messageAccount);
                                    messagesToAdd.add(m);
                                }
                            }
                        }
                    } else {
                        m.dirty = false; // as we reload the message, unset its dirty flag
                        messageHelper.populate(m, message, new FolderInfoHolder(MessageList.this, messageFolder, account), account);
                        needsSort = true;
                    }
                }
            }

            if (messagesToSearch.size() > 0) {
                mController.searchLocalMessages(mAccountUuids, mFolderNames, messagesToSearch.toArray(EMPTY_MESSAGE_ARRAY), mQueryString, mIntegrate, mQueryFlags, mForbiddenFlags,
                new MessagingListener() {
                    @Override
                    public void listLocalMessagesAddMessages(Account account, String folder, List<Message> messages) {
                        addOrUpdateMessages(account, folder, messages, false);
                    }
                });
            }

            if (messagesToRemove.size() > 0) {
                removeMessages(messagesToRemove);
            }

            if (messagesToAdd.size() > 0) {
                mHandler.addMessages(messagesToAdd);
            }

            if (needsSort) {
                mHandler.sortMessages();
                mHandler.resetUnreadCount();
            }
        }
        public MessageInfoHolder getMessage(Message message) {
            return getMessage(message.makeMessageReference());
        }

        // XXX TODO - make this not use a for loop
        public MessageInfoHolder getMessage(MessageReference messageReference) {
            synchronized (mAdapter.messages) {
                for (MessageInfoHolder holder : mAdapter.messages) {
                    /*
                     * 2010-06-21 - cketti
                     * Added null pointer check. Not sure what's causing 'holder'
                     * to be null. See log provided in issue 1749, comment #15.
                     *
                     * Please remove this comment once the cause was found and the
                     * bug(?) fixed.
                     */
                    if ((holder != null) && holder.message.equalsReference(messageReference)) {
                        return holder;
                    }
                }
            }
            return null;
        }

        public FolderInfoHolder getFolder(String folder, Account account) {
            LocalFolder local_folder = null;
            try {
                LocalStore localStore = account.getLocalStore();
                local_folder = localStore.getFolder(folder);
                return new FolderInfoHolder(context, local_folder, account);
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""getFolder("" + folder + "") goes boom: "", e);
                return null;
            } finally {
                if (local_folder != null) {
                    local_folder.close();
                }
            }
        }

        private final OnClickListener flagClickListener = new OnClickListener() {
            @Override
            public void onClick(View v) {
                // Perform action on clicks
                MessageInfoHolder message = (MessageInfoHolder) getItem((Integer)v.getTag());
                onToggleFlag(message);
            }
        };

        @Override
        public int getCount() {
            return messages.size();
        }

        @Override
        public long getItemId(int position) {
            try {
                MessageInfoHolder messageHolder = (MessageInfoHolder) getItem(position);
                if (messageHolder != null) {
                    return messageHolder.message.getId();
                }
            } catch (Exception e) {
                Log.i(K9.LOG_TAG, ""getItemId("" + position + "") "", e);
            }
            return -1;
        }

        public Object getItem(long position) {
            return getItem((int)position);
        }

        @Override
        public Object getItem(int position) {
            try {
                synchronized (mAdapter.messages) {
                    if (position < mAdapter.messages.size()) {
                        return mAdapter.messages.get(position);
                    }
                }
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""getItem("" + position + ""), but folder.messages.size() = "" + mAdapter.messages.size(), e);
            }
            return null;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            MessageInfoHolder message = (MessageInfoHolder) getItem(position);
            View view;

            if ((convertView != null) && (convertView.getId() == R.layout.message_list_item)) {
                view = convertView;
            } else {
                if (mTouchView) {
                    view = mInflater.inflate(R.layout.message_list_item_touchable, parent, false);
                    view.setId(R.layout.message_list_item);
                } else {
                    view = mInflater.inflate(R.layout.message_list_item, parent, false);
                    view.setId(R.layout.message_list_item);
                }
            }

            MessageViewHolder holder = (MessageViewHolder) view.getTag();

            if (holder == null) {
                holder = new MessageViewHolder();
                holder.subject = (TextView) view.findViewById(R.id.subject);
                holder.from = (TextView) view.findViewById(R.id.from);
                holder.date = (TextView) view.findViewById(R.id.date);
                holder.chip = view.findViewById(R.id.chip);
                holder.preview = (TextView) view.findViewById(R.id.preview);
                holder.selected = (CheckBox) view.findViewById(R.id.selected_checkbox);
                holder.flagged = (CheckBox) view.findViewById(R.id.flagged);

                holder.flagged.setOnClickListener(flagClickListener);

                if (!mStars) {
                    holder.flagged.setVisibility(View.GONE);
                }

                if (mCheckboxes) {
                    holder.selected.setVisibility(View.VISIBLE);
                }

                if (holder.selected != null) {
                    holder.selected.setOnCheckedChangeListener(holder);
                }
                holder.subject.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageListSubject());
                holder.date.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageListDate());

                if (mTouchView) {
                    holder.preview.setLines(mPreviewLines);
                    holder.preview.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageListPreview());

                } else {
                    holder.from.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageListSender());
                }

                view.setTag(holder);
            }

            if (message != null) {
                bindView(position, view, holder, message);
            } else {
                // This branch code is triggered when the local store
                // hands us an invalid message

                holder.chip.getBackground().setAlpha(0);
                holder.subject.setText(getString(R.string.general_no_subject));
                holder.subject.setTypeface(null, Typeface.NORMAL);
                String noSender = getString(R.string.general_no_sender);
                if (holder.preview != null) {
                    holder.preview.setText(noSender, TextView.BufferType.SPANNABLE);
                    Spannable str = (Spannable) holder.preview.getText();

                    str.setSpan(new StyleSpan(Typeface.NORMAL),
                                0,
                                noSender.length(),
                                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                    str.setSpan(K9.createAbsoluteSizeSpan(mFontSizes.getMessageListSender()),
                                0,
                                noSender.length(),
                                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                } else {
                    holder.from.setText(noSender);
                    holder.from.setTypeface(null, Typeface.NORMAL);
                    holder.from.setCompoundDrawablesWithIntrinsicBounds(null, null, null, null);
                }

                holder.date.setText(getString(R.string.general_no_date));

                //WARNING: Order of the next 2 lines matter
                holder.position = -1;
                holder.selected.setChecked(false);

                if (!mCheckboxes) {
                    holder.selected.setVisibility(View.GONE);
                }
                holder.flagged.setChecked(false);
            }


            return view;
        }

        /**
         * Associate model data to view object.
         *
         * @param position
         *            The position of the item within the adapter's data set of
         *            the item whose view we want.
         * @param view
         *            Main view component to alter. Never <code>null</code>.
         * @param holder
         *            Convenience view holder - eases access to <tt>view</tt>
         *            child views. Never <code>null</code>.
         * @param message
         *            Never <code>null</code>.
         */
        private void bindView(final int position, final View view, final MessageViewHolder holder,
                              final MessageInfoHolder message) {
            holder.subject.setTypeface(null, message.read ? Typeface.NORMAL : Typeface.BOLD);

            // XXX TODO there has to be some way to walk our view hierarchy and get this
            holder.flagged.setTag(position);
            holder.flagged.setChecked(message.flagged);

            // So that the mSelectedCount is only incremented/decremented
            // when a user checks the checkbox (vs code)
            holder.position = -1;
            holder.selected.setChecked(message.selected);

            if (!mCheckboxes) {
                holder.selected.setVisibility(message.selected ? View.VISIBLE : View.GONE);
            }



            holder.chip.setBackgroundDrawable(message.message.getFolder().getAccount().generateColorChip().drawable());
            holder.chip.getBackground().setAlpha(message.read ? 127 : 255);
            view.getBackground().setAlpha(message.downloaded ? 0 : 127);

            if ((message.message.getSubject() == null) || message.message.getSubject().equals("""")) {
                holder.subject.setText(getText(R.string.general_no_subject));
            } else {
                holder.subject.setText(message.message.getSubject());
            }

            int senderTypeface = message.read ? Typeface.NORMAL : Typeface.BOLD;
            if (holder.preview != null) {
                /*
                 * In the touchable UI, we have previews. Otherwise, we
                 * have just a ""from"" line.
                 * Because text views can't wrap around each other(?) we
                 * compose a custom view containing the preview and the
                 * from.
                 */

                holder.preview.setText(new SpannableStringBuilder(recipientSigil(message))
                                       .append(message.sender).append("" "").append(message.message.getPreview()),
                                       TextView.BufferType.SPANNABLE);
                Spannable str = (Spannable)holder.preview.getText();

                // Create a span section for the sender, and assign the correct font size and weight.
                str.setSpan(new StyleSpan(senderTypeface),
                            0,
                            message.sender.length() + 1,
                            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                str.setSpan(K9.createAbsoluteSizeSpan(mFontSizes.getMessageListSender()),
                            0,
                            message.sender.length() + 1,
                            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

                // set span for preview message.
                str.setSpan(new ForegroundColorSpan(Color.rgb(128, 128, 128)), // How do I can specify the android.R.attr.textColorTertiary
                            message.sender.length() + 1,
                            str.length(),
                            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            } else {
                holder.from.setText(new SpannableStringBuilder(recipientSigil(message)).append(message.sender));

                holder.from.setTypeface(null, senderTypeface);
            }

            holder.date.setText(message.getDate(mMessageHelper));
            holder.subject.setCompoundDrawablesWithIntrinsicBounds(
                message.answered ? mAnsweredIcon : null, // left
                null, // top
                message.message.hasAttachments() ? mAttachmentIcon : null, // right
                null); // bottom
            holder.position = position;
        }

        private String recipientSigil(MessageInfoHolder message) {
            if (message.message.toMe()) {
                return getString(R.string.messagelist_sent_to_me_sigil);
            } else if (message.message.ccMe()) {
                return getString(R.string.messagelist_sent_cc_me_sigil);
            } else {
                return """";
            }
        }




        @Override
        public boolean hasStableIds() {
            return true;
        }

        public boolean isItemSelectable(int position) {
            if (position < mAdapter.messages.size()) {
                return true;
            } else {
                return false;
            }
        }
    }

    class MessageViewHolder
        implements OnCheckedChangeListener {
        public TextView subject;
        public TextView preview;
        public TextView from;
        public TextView time;
        public TextView date;
        public CheckBox flagged;
        public View chip;
        public CheckBox selected;
        public int position = -1;

        @Override
        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
            if (position != -1) {
                MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(position);
                if (message.selected != isChecked) {
                    if (isChecked) {
                        mSelectedCount++;
                    } else if (mSelectedCount > 0) {
                        mSelectedCount--;
                    }

                    // We must set the flag before showing the buttons as the
                    // buttons text depends on what is selected.
                    message.selected = isChecked;
                    if (!mCheckboxes) {
                        if (isChecked) {
                            selected.setVisibility(View.VISIBLE);
                        } else {
                            selected.setVisibility(View.GONE);
                        }
                    }
                    toggleBatchButtons();
                }
            }
        }
    }


    private View getFooterView(ViewGroup parent) {
        if (mFooterView == null) {
            mFooterView = mInflater.inflate(R.layout.message_list_item_footer, parent, false);
            if (mQueryString != null) {
                mFooterView.setVisibility(View.GONE);
            }
            mFooterView.setId(R.layout.message_list_item_footer);
            FooterViewHolder holder = new FooterViewHolder();
            holder.progress = (ProgressBar) mFooterView.findViewById(R.id.message_list_progress);
            holder.progress.setIndeterminate(true);
            holder.main = (TextView) mFooterView.findViewById(R.id.main_text);
            mFooterView.setTag(holder);
        }

        return mFooterView;
    }

    private void updateFooterView() {
        FooterViewHolder holder = (FooterViewHolder) mFooterView.getTag();

        if (mCurrentFolder != null && mAccount != null) {
            if (mCurrentFolder.loading) {
                holder.main.setText(getString(R.string.status_loading_more));
                holder.progress.setVisibility(ProgressBar.VISIBLE);
            } else {
                if (!mCurrentFolder.lastCheckFailed) {
                    if (mAccount.getDisplayCount() == 0) {
                        holder.main.setText(getString(R.string.message_list_load_more_messages_action));
                    } else {
                        holder.main.setText(String.format(getString(R.string.load_more_messages_fmt), mAccount.getDisplayCount()));
                    }
                } else {
                    holder.main.setText(getString(R.string.status_loading_more_failed));
                }
                holder.progress.setVisibility(ProgressBar.INVISIBLE);
            }
        } else {
            holder.progress.setVisibility(ProgressBar.INVISIBLE);
        }
    }

    private void hideBatchButtons() {
        if (mBatchButtonArea.getVisibility() != View.GONE) {
            mBatchButtonArea.setVisibility(View.GONE);
            mBatchButtonArea.startAnimation(
                AnimationUtils.loadAnimation(this, R.anim.footer_disappear));
        }
    }

    private void showBatchButtons() {
        if (mBatchButtonArea.getVisibility() != View.VISIBLE) {
            mBatchButtonArea.setVisibility(View.VISIBLE);
            Animation animation = AnimationUtils.loadAnimation(this, R.anim.footer_appear);
            animation.setAnimationListener(this);
            mBatchButtonArea.startAnimation(animation);
        }
    }

    private void toggleBatchButtons() {

        runOnUiThread(new Runnable() {
            @Override
            public void run() {

                if (mSelectedCount < 0) {
                    mSelectedCount = 0;
                }

                int readButtonIconId;
                int flagButtonIconId;

                if (mSelectedCount == 0) {
                    readButtonIconId = R.drawable.ic_button_mark_read;
                    flagButtonIconId = R.drawable.ic_button_flag;
                    hideBatchButtons();
                } else {
                    boolean newReadState = computeBatchDirection(false);
                    if (newReadState) {
                        readButtonIconId = R.drawable.ic_button_mark_read;
                    } else {
                        readButtonIconId = R.drawable.ic_button_mark_unread;
                    }
                    boolean newFlagState = computeBatchDirection(true);
                    if (newFlagState) {
                        flagButtonIconId = R.drawable.ic_button_flag;
                    } else {
                        flagButtonIconId = R.drawable.ic_button_unflag;
                    }
                    showBatchButtons();
                }

                mBatchReadButton.setImageResource(readButtonIconId);
                mBatchFlagButton.setImageResource(flagButtonIconId);


            }
        });


    }

    static class FooterViewHolder {
        public ProgressBar progress;
        public TextView main;
    }


    private boolean computeBatchDirection(boolean flagged) {
        boolean newState = false;

        synchronized (mAdapter.messages) {
            for (MessageInfoHolder holder : mAdapter.messages) {
                if (holder.selected) {
                    if (flagged) {
                        if (!holder.flagged) {
                            newState = true;
                            break;
                        }
                    } else {
                        if (!holder.read) {
                            newState = true;
                            break;
                        }
                    }
                }
            }
        }
        return newState;
    }

    private boolean anySelected() {
        synchronized (mAdapter.messages) {
            for (MessageInfoHolder holder : mAdapter.messages) {
                if (holder.selected) {
                    return true;
                }
            }
        }
        return false;
    }

    @Override
    public void onClick(View v) {
        boolean newState = false;
        List<Message> messageList = new ArrayList<Message>();
        List<MessageInfoHolder> removeHolderList = new ArrayList<MessageInfoHolder>();

        if (v == mBatchDoneButton) {
            setAllSelected(false);
            return;
        }

        if (v == mBatchFlagButton) {
            newState = computeBatchDirection(true);
        } else {
            newState = computeBatchDirection(false);
        }

        synchronized (mAdapter.messages) {
            for (MessageInfoHolder holder : mAdapter.messages) {
                if (holder.selected) {
                    if (v == mBatchDeleteButton) {
                        removeHolderList.add(holder);
                    } else if (v == mBatchFlagButton) {
                        holder.flagged = newState;
                    } else if (v == mBatchReadButton) {
                        holder.read = newState;
                    }
                    messageList.add(holder.message);
                }
            }
        }
        mAdapter.removeMessages(removeHolderList);

        if (!messageList.isEmpty()) {
            if (v == mBatchDeleteButton) {
                mController.deleteMessages(messageList.toArray(EMPTY_MESSAGE_ARRAY), null);
                mSelectedCount = 0;
                toggleBatchButtons();
            } else {
                mController.setFlag(messageList.toArray(EMPTY_MESSAGE_ARRAY), (v == mBatchReadButton ? Flag.SEEN : Flag.FLAGGED), newState);
            }
        } else {
            // Should not happen
            Toast.makeText(this, R.string.no_message_seletected_toast, Toast.LENGTH_SHORT).show();
        }
        mHandler.sortMessages();
    }

    @Override
    public void onAnimationEnd(Animation animation) {
    }

    @Override
    public void onAnimationRepeat(Animation animation) {
    }

    @Override
    public void onAnimationStart(Animation animation) {
    }



    private void setAllSelected(boolean isSelected) {
        mSelectedCount = 0;
        synchronized (mAdapter.messages) {
            for (MessageInfoHolder holder : mAdapter.messages) {
                holder.selected = isSelected;
                mSelectedCount += (isSelected ? 1 : 0);
            }
        }
        mAdapter.notifyDataSetChanged();
        toggleBatchButtons();
    }

    private void setSelected(final List<MessageInfoHolder> holders, final boolean newState) {
        for (final MessageInfoHolder holder : holders) {
            if (holder.selected != newState) {
                holder.selected = newState;
                mSelectedCount += (newState ? 1 : -1);
            }
        }
        mAdapter.notifyDataSetChanged();
        toggleBatchButtons();
    }

    /**
     * @param holders
     *            Messages to update. Never {@code null}.
     * @param flag
     *            Flag to be updated on the specified messages. Never
     *            {@code null}.
     * @param newState
     *            State to set for the given flag.
     */
    private void setFlag(final List<MessageInfoHolder> holders, final Flag flag, final boolean newState) {
        if (holders.isEmpty()) {
            return;
        }
        final Message[] messageList = new Message[holders.size()];
        int i = 0;
        for (final Iterator<MessageInfoHolder> iterator = holders.iterator(); iterator.hasNext(); i++) {
            final MessageInfoHolder holder = iterator.next();
            messageList[i] = holder.message;
            if (flag == Flag.SEEN) {
                holder.read = newState;
            } else if (flag == Flag.FLAGGED) {
                holder.flagged = newState;
            }
        }
        mController.setFlag(messageList, flag, newState);
        mHandler.sortMessages();
    }

    /**
     * Display the message move activity.
     *
     * @param holders
     *            Never {@code null}.
     */
    private void onMove(final List<MessageInfoHolder> holders) {
        if (!checkCopyOrMovePossible(holders, FolderOperation.MOVE)) {
            return;
        }

        final Folder folder = holders.size() == 1 ? holders.get(0).message.getFolder() : mCurrentFolder.folder;
        displayFolderChoice(ACTIVITY_CHOOSE_FOLDER_MOVE, folder, holders);
    }

    /**
     * Display the message copy activity.
     *
     * @param holders
     *            Never {@code null}.
     */
    private void onCopy(final List<MessageInfoHolder> holders) {
        if (!checkCopyOrMovePossible(holders, FolderOperation.COPY)) {
            return;
        }

        final Folder folder = holders.size() == 1 ? holders.get(0).message.getFolder() : mCurrentFolder.folder;
        displayFolderChoice(ACTIVITY_CHOOSE_FOLDER_COPY, folder, holders);
    }

    /**
     * Helper method to manage the invocation of
     * {@link #startActivityForResult(Intent, int)} for a folder operation
     * ({@link ChooseFolder} activity), while saving a list of associated
     * messages.
     *
     * @param requestCode
     *            If >= 0, this code will be returned in onActivityResult() when
     *            the activity exits.
     * @param folder
     *            Never {@code null}.
     * @param holders
     *            Messages to be affected by the folder operation. Never
     *            {@code null}.
     * @see #startActivityForResult(Intent, int)
     */
    private void displayFolderChoice(final int requestCode, final Folder folder, final List<MessageInfoHolder> holders) {
        final Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, folder.getAccount().getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, folder.getName());
        intent.putExtra(ChooseFolder.EXTRA_SEL_FOLDER, folder.getAccount().getLastSelectedFolderName());
        // remember the selected messages for #onActivityResult
        mActiveMessages = holders;
        startActivityForResult(intent, requestCode);
    }

    /**
     * @param holders
     *            Never {@code null}.
     */
    private void onArchive(final List<MessageInfoHolder> holders) {
        final String folderName = holders.get(0).message.getFolder().getAccount().getArchiveFolderName();
        if (K9.FOLDER_NONE.equalsIgnoreCase(folderName)) {
            return;
        }
        // TODO one should separate messages by account and call move afterwards
        // (because each account might have a specific Archive folder name)
        move(holders, folderName);
    }

    /**
     * @param holders
     *            Never {@code null}.
     */
    private void onSpam(final List<MessageInfoHolder> holders) {
        if (K9.confirmSpam()) {
            // remember the message selection for #onCreateDialog(int)
            mActiveMessages = holders;
            showDialog(R.id.dialog_confirm_spam);
        } else {
            onSpamConfirmed(holders);
        }
    }

    /**
     * @param holders
     *            Never {@code null}.
     */
    private void onSpamConfirmed(final List<MessageInfoHolder> holders) {
        final String folderName = holders.get(0).message.getFolder().getAccount().getSpamFolderName();
        if (K9.FOLDER_NONE.equalsIgnoreCase(folderName)) {
            return;
        }
        // TODO one should separate messages by account and call move afterwards
        // (because each account might have a specific Spam folder name)
        move(holders, folderName);
    }

    private static enum FolderOperation {
        COPY, MOVE
    }

    /**
     * Display an Toast message if any message isn't synchronized
     *
     * @param holders
     *            Never <code>null</code>.
     * @param operation
     *            Never {@code null}.
     *
     * @return <code>true</code> if operation is possible
     */
    private boolean checkCopyOrMovePossible(final List<MessageInfoHolder> holders, final FolderOperation operation) {
        if (holders.isEmpty()) {
            return false;
        }
        boolean first = true;
        for (final MessageInfoHolder holder : holders) {
            final Message message = holder.message;
            if (first) {
                first = false;
                // account check
                final Account account = message.getFolder().getAccount();
                if ((operation == FolderOperation.MOVE && !mController.isMoveCapable(account)) || (operation == FolderOperation.COPY && !mController.isCopyCapable(account))) {
                    return false;
                }
            }
            // message check
            if ((operation == FolderOperation.MOVE && !mController.isMoveCapable(message)) || (operation == FolderOperation.COPY && !mController.isCopyCapable(message))) {
                final Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message,
                                                   Toast.LENGTH_LONG);
                toast.show();
                return false;
            }
        }
        return true;
    }

    /**
     * Helper method to get a List of message ready to be processed. This implementation will return a list containing the sole argument.
     *
     * @param holder Never {@code null}.
     * @return Never {@code null}.
     */
    private List<MessageInfoHolder> getSelectionFromMessage(final MessageInfoHolder holder) {
        final List<MessageInfoHolder> selection = Collections.singletonList(holder);
        return selection;
    }

    /**
     * Helper method to get a List of message ready to be processed. This implementation will iterate over messages and choose the checked ones.
     *
     * @return Never {@code null}.
     */
    private List<MessageInfoHolder> getSelectionFromCheckboxes() {
        final List<MessageInfoHolder> selection = new ArrayList<MessageInfoHolder>();
        synchronized (mAdapter.messages) {
            for (final MessageInfoHolder holder : mAdapter.messages) {
                if (holder.selected) {
                    selection.add(holder);
                }
            }
        }
        return selection;
    }

    /**
     * Copy the specified messages to the specified folder.
     *
     * @param holders Never {@code null}.
     * @param destination Never {@code null}.
     */
    private void copy(final List<MessageInfoHolder> holders, final String destination) {
        copyOrMove(holders, destination, FolderOperation.COPY);
    }

    /**
     * Move the specified messages to the specified folder.
     *
     * @param holders Never {@code null}.
     * @param destination Never {@code null}.
     */
    private void move(final List<MessageInfoHolder> holders, final String destination) {
        copyOrMove(holders, destination, FolderOperation.MOVE);
    }

    /**
     * The underlying implementation for {@link #copy(List, String)} and
     * {@link #move(List, String)}. This method was added mainly because those 2
     * methods share common behavior.
     *
     * @param holders
     *            Never {@code null}.
     * @param destination
     *            Never {@code null}.
     * @param operation
     *            Never {@code null}.
     */
    private void copyOrMove(final List<MessageInfoHolder> holders, final String destination, final FolderOperation operation) {
        if (K9.FOLDER_NONE.equalsIgnoreCase(destination)) {
            return;
        }

        boolean first = true;
        Account account = null;
        String folderName = null;

        final List<Message> messages = new ArrayList<Message>(holders.size());

        for (final MessageInfoHolder holder : holders) {
            final Message message = holder.message;
            if (first) {
                first = false;
                folderName = message.getFolder().getName();
                account = message.getFolder().getAccount();
                if ((operation == FolderOperation.MOVE && !mController.isMoveCapable(account)) || (operation == FolderOperation.COPY && !mController.isCopyCapable(account))) {
                    // account is not copy/move capable
                    return;
                }
            } else if (!account.equals(message.getFolder().getAccount())
                       || !folderName.equals(message.getFolder().getName())) {
                // make sure all messages come from the same account/folder?
                return;
            }
            if ((operation == FolderOperation.MOVE && !mController.isMoveCapable(message)) || (operation == FolderOperation.COPY && !mController.isCopyCapable(message))) {
                final Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message,
                                                   Toast.LENGTH_LONG);
                toast.show();

                // XXX return meaningful error value?

                // message isn't synchronized
                return;
            }
            messages.add(message);
        }

        if (operation == FolderOperation.MOVE) {
            mController.moveMessages(account, folderName, messages.toArray(new Message[messages.size()]), destination,
                                     null);
            mHandler.removeMessages(holders);
        } else {
            mController.copyMessages(account, folderName, messages.toArray(new Message[messages.size()]), destination,
                                     null);
        }
    }

    protected void onAccountUnavailable() {
        finish();
        // TODO inform user about account unavailability using Toast
        Accounts.listAccounts(this);
    }

}
",True,146,1,2,5,70,5,30,L1
65,com.fsck.k9.activity.MessageView.java,"package com.fsck.k9.activity;

import android.app.ActivityManager;
import android.app.ActivityManager.RunningTaskInfo;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.Intent;
import android.content.res.Configuration;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.util.Config;
import android.util.Log;
import android.view.*;
import android.view.View.OnClickListener;
import android.widget.*;
import com.fsck.k9.*;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.crypto.PgpData;
import com.fsck.k9.helper.FileBrowserHelper;
import com.fsck.k9.helper.FileBrowserHelper.FileBrowserFailOverCallback;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.store.StorageManager;
import com.fsck.k9.view.AttachmentView;
import com.fsck.k9.view.ToggleScrollView;
import com.fsck.k9.view.SingleMessageView;
import com.fsck.k9.view.AttachmentView.AttachmentFileDownloadCallback;

import java.io.File;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.*;

public class MessageView extends K9Activity implements OnClickListener {
    private static final String EXTRA_MESSAGE_REFERENCE = ""com.fsck.k9.MessageView_messageReference"";
    private static final String EXTRA_MESSAGE_REFERENCES = ""com.fsck.k9.MessageView_messageReferences"";
    private static final String EXTRA_ORIGINATING_INTENT = ""com.fsck.k9.MessageView_originatingIntent"";
    private static final String EXTRA_NEXT = ""com.fsck.k9.MessageView_next"";
    private static final String SHOW_PICTURES = ""showPictures"";
    private static final String STATE_PGP_DATA = ""pgpData"";
    private static final int ACTIVITY_CHOOSE_FOLDER_MOVE = 1;
    private static final int ACTIVITY_CHOOSE_FOLDER_COPY = 2;
    private static final int ACTIVITY_CHOOSE_DIRECTORY = 3;

    /**
     * Whether parent class have the onBackPressed() method (with no argument)
     */
    private static final boolean HAS_SUPER_ON_BACK_METHOD;
    static {
        boolean hasOnBackMethod;
        try {
            final Class <? super MessageView > superClass = MessageView.class.getSuperclass();
            final Method method = superClass.getMethod(""onBackPressed"", new Class[] {});
            hasOnBackMethod = (method.getModifiers() & Modifier.PUBLIC) == Modifier.PUBLIC;
        } catch (final SecurityException e) {
            if (K9.DEBUG) {
                Log.v(K9.LOG_TAG, ""Security exception while checking for 'onBackPressed' method"", e);
            }
            hasOnBackMethod = false;
        } catch (final NoSuchMethodException e) {
            hasOnBackMethod = false;
        }
        HAS_SUPER_ON_BACK_METHOD = hasOnBackMethod;
    }

    /**
     * If user opt-in for the ""Manage BACK button"", we have to remember how to get back to the
     * originating activity (just recreating a new Intent could lose the calling activity state)
     */
    private Intent mCreatorIntent;

    private SingleMessageView mMessageView;

    private PgpData mPgpData;


    private View mNext;
    private View mPrevious;
    private View mDelete;
    private View mArchive;
    private View mMove;
    private View mSpam;
    private ToggleScrollView mToggleScrollView;
    private Account mAccount;
    private MessageReference mMessageReference;
    private ArrayList<MessageReference> mMessageReferences;
    private Message mMessage;
    private static final int PREVIOUS = 1;
    private static final int NEXT = 2;
    private int mLastDirection = PREVIOUS;
    private MessagingController mController = MessagingController.getInstance(getApplication());
    private MessageReference mNextMessage = null;
    private MessageReference mPreviousMessage = null;
    private Listener mListener = new Listener();
    private MessageViewHandler mHandler = new MessageViewHandler();
    private StorageManager.StorageListener mStorageListener = new StorageListenerImplementation();

    /** this variable is used to save the calling AttachmentView
     *  until the onActivityResult is called.
     *  => with this reference we can identity the caller
     */
    private AttachmentView attachmentTmpStore;

    /**
     * Used to temporarily store the destination folder for refile operations if a confirmation
     * dialog is shown.
     */
    private String mDstFolder;

    private final class StorageListenerImplementation implements StorageManager.StorageListener {
        @Override
        public void onUnmount(String providerId) {
            if (!providerId.equals(mAccount.getLocalStorageProviderId())) {
                return;
            }
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    onAccountUnavailable();
                }
            });
        }

        @Override
        public void onMount(String providerId) {} // no-op
    }


    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_UP) {
            // Text selection is finished. Allow scrolling again.
            mToggleScrollView.setScrolling(true);
        } else if (K9.zoomControlsEnabled()) {
            // If we have system zoom controls enabled, disable scrolling so the screen isn't wiggling around while
            // trying to zoom.
            if (ev.getAction() == MotionEvent.ACTION_POINTER_2_DOWN) {
                mToggleScrollView.setScrolling(false);
            } else if (ev.getAction() == MotionEvent.ACTION_POINTER_2_UP) {
                mToggleScrollView.setScrolling(true);
            }
        }
        return super.dispatchTouchEvent(ev);
    }

    @Override
    public boolean dispatchKeyEvent(KeyEvent event) {
        boolean ret = false;
        if (KeyEvent.ACTION_DOWN == event.getAction()) {
            ret = onKeyDown(event.getKeyCode(), event);
        }
        if (!ret) {
            ret = super.dispatchKeyEvent(event);
        }
        return ret;
    }

    @Override
    public boolean onKeyDown(final int keyCode, final KeyEvent event) {
        if (
            // XXX TODO - when we go to android 2.0, uncomment this
            // android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.ECLAIR &&
            keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
            // Take care of calling this method on earlier versions of
            // the platform where it doesn't exist.
            onBackPressed();
            return true;
        }
        switch (keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP: {
            if (K9.useVolumeKeysForNavigationEnabled()) {
                onNext();
                return true;
            }
        }
        case KeyEvent.KEYCODE_VOLUME_DOWN: {
            if (K9.useVolumeKeysForNavigationEnabled()) {
                onPrevious();
                return true;
            }
        }
        case KeyEvent.KEYCODE_SHIFT_LEFT:
        case KeyEvent.KEYCODE_SHIFT_RIGHT: {
            /*
             * Selecting text started via shift key. Disable scrolling as
             * this causes problems when selecting text.
             */
            mToggleScrollView.setScrolling(false);
            break;
        }
        case KeyEvent.KEYCODE_DEL: {
            onDelete();
            return true;
        }
        case KeyEvent.KEYCODE_D: {
            onDelete();
            return true;
        }
        case KeyEvent.KEYCODE_F: {
            onForward();
            return true;
        }
        case KeyEvent.KEYCODE_A: {
            onReplyAll();
            return true;
        }
        case KeyEvent.KEYCODE_R: {
            onReply();
            return true;
        }
        case KeyEvent.KEYCODE_G: {
            onFlag();
            return true;
        }
        case KeyEvent.KEYCODE_M: {
            onMove();
            return true;
        }
        case KeyEvent.KEYCODE_S: {
            onRefile(mAccount.getSpamFolderName());
            return true;
        }
        case KeyEvent.KEYCODE_V: {
            onRefile(mAccount.getArchiveFolderName());
            return true;
        }
        case KeyEvent.KEYCODE_Y: {
            onCopy();
            return true;
        }
        case KeyEvent.KEYCODE_J:
        case KeyEvent.KEYCODE_P: {
            onPrevious();
            return true;
        }
        case KeyEvent.KEYCODE_N:
        case KeyEvent.KEYCODE_K: {
            onNext();
            return true;
        }
        case KeyEvent.KEYCODE_Z: {
            mHandler.post(new Runnable() {
                public void run() {
                    mMessageView.zoom(event);
                }
            });
            return true;
        }
        case KeyEvent.KEYCODE_H: {
            Toast toast = Toast.makeText(this, R.string.message_help_key, Toast.LENGTH_LONG);
            toast.show();
            return true;
        }
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        // Swallow these events too to avoid the audible notification of a volume change
        if (K9.useVolumeKeysForNavigationEnabled()) {
            if ((keyCode == KeyEvent.KEYCODE_VOLUME_UP) || (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN)) {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""Swallowed key up."");
                return true;
            }
        }
        return super.onKeyUp(keyCode, event);
    }

    @Override
    public void onBackPressed() {
        // This will be called either automatically for you on 2.0
        // or later, or by the code above on earlier versions of the
        // platform.
        if (K9.manageBack()) {
            final ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
            // retrieve the current+previous tasks
            final List<RunningTaskInfo> runningTasks = activityManager.getRunningTasks(2);
            final RunningTaskInfo previousTask = runningTasks.get(1);
            final String originatingActivity = mCreatorIntent.getComponent().getClassName();
            if (originatingActivity.equals(previousTask.topActivity.getClassName())) {
                // we can safely just finish ourself since the most recent task matches our creator
                // this enable us not to worry about restoring the state of our creator
            } else {
                // the previous task top activity doesn't match our creator (previous task is from
                // another app and user used long-pressed-HOME to display MessageView)
                // launching our creator
                startActivity(mCreatorIntent);
            }
            finish();
        } else if (HAS_SUPER_ON_BACK_METHOD) {
            super.onBackPressed();
        } else {
            finish();
        }
    }

    class MessageViewHandler extends Handler {

        public void progress(final boolean progress) {
            runOnUiThread(new Runnable() {
                public void run() {
                    setProgressBarIndeterminateVisibility(progress);
                }
            });
        }

        public void addAttachment(final View attachmentView) {
            runOnUiThread(new Runnable() {
                public void run() {
                    mMessageView.addAttachment(attachmentView);
                }
            });
        }

        /* A helper for a set of ""show a toast"" methods */
        private void showToast(final String message, final int toastLength)  {
            runOnUiThread(new Runnable() {
                public void run() {
                    Toast.makeText(MessageView.this, message, toastLength).show();
                }
            });
        }

        public void networkError() {
            showToast(getString(R.string.status_network_error), Toast.LENGTH_LONG);
        }

        public void invalidIdError() {
            showToast(getString(R.string.status_invalid_id_error), Toast.LENGTH_LONG);
        }


        public void fetchingAttachment() {
            showToast(getString(R.string.message_view_fetching_attachment_toast), Toast.LENGTH_SHORT);
        }


        public void setHeaders(final Message message, final Account account) {
            runOnUiThread(new Runnable() {
                public void run() {
                    mMessageView.setHeaders(message, account);
                }
            });
        }

    }


    public static void actionView(Context context, MessageReference messRef, ArrayList<MessageReference> messReferences, final Intent originatingIntent) {
        actionView(context, messRef, messReferences, null, originatingIntent);
    }

    /**
     * @param context
     * @param messRef
     * @param messReferences
     * @param extras
     * @param originatingIntent
     *            The intent that allow us to get back to the calling screen, for when the 'Manage
     *            BACK' option is enabled. Never {@code null}.
     */
    public static void actionView(Context context, MessageReference messRef, ArrayList<MessageReference> messReferences, Bundle extras, final Intent originatingIntent) {
        Intent i = new Intent(context, MessageView.class);
        i.putExtra(EXTRA_MESSAGE_REFERENCE, messRef);
        i.putParcelableArrayListExtra(EXTRA_MESSAGE_REFERENCES, messReferences);
        i.putExtra(EXTRA_ORIGINATING_INTENT, originatingIntent);
        if (extras != null) {
            i.putExtras(extras);
        }
        context.startActivity(i);
    }

    @Override
    protected void onNewIntent(final Intent intent) {
        mCreatorIntent = intent.getParcelableExtra(EXTRA_ORIGINATING_INTENT);
    }

    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle, false);
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.message_view);

        mTopView = mToggleScrollView = (ToggleScrollView) findViewById(R.id.top_view);
        mMessageView = (SingleMessageView) findViewById(R.id.message_view);

        //set a callback for the attachment view. With this callback the attachmentview
        //request the start of a filebrowser activity.
        mMessageView.setAttachmentCallback(new AttachmentFileDownloadCallback() {

            @Override
            public void showFileBrowser(final AttachmentView caller) {
                FileBrowserHelper.getInstance()
                .showFileBrowserActivity(MessageView.this,
                                         null,
                                         MessageView.ACTIVITY_CHOOSE_DIRECTORY,
                                         callback);
                attachmentTmpStore = caller;
            }
            FileBrowserFailOverCallback callback = new FileBrowserFailOverCallback() {

                @Override
                public void onPathEntered(String path) {
                    attachmentTmpStore.writeFile(new File(path));
                }

                @Override
                public void onCancel() {
                    // canceled, do nothing
                }
            };
        });
        mMessageView.initialize(this);

        setTitle("""");
        final Intent intent = getIntent();

        mCreatorIntent = getIntent().getParcelableExtra(EXTRA_ORIGINATING_INTENT);

        Uri uri = intent.getData();
        if (icicle != null) {
            mMessageReference = icicle.getParcelable(EXTRA_MESSAGE_REFERENCE);
            mMessageReferences = icicle.getParcelableArrayList(EXTRA_MESSAGE_REFERENCES);
            mPgpData = (PgpData) icicle.getSerializable(STATE_PGP_DATA);
        } else {
            if (uri == null) {
                mMessageReference = intent.getParcelableExtra(EXTRA_MESSAGE_REFERENCE);
                mMessageReferences = intent.getParcelableArrayListExtra(EXTRA_MESSAGE_REFERENCES);
            } else {
                List<String> segmentList = uri.getPathSegments();
                if (segmentList.size() != 3) {
                    //TODO: Use ressource to externalize message
                    Toast.makeText(this, ""Invalid intent uri: "" + uri.toString(), Toast.LENGTH_LONG).show();
                    return;
                }

                String accountId = segmentList.get(0);
                Collection<Account> accounts = Preferences.getPreferences(this).getAvailableAccounts();
                boolean found = false;
                for (Account account : accounts) {
                    if (String.valueOf(account.getAccountNumber()).equals(accountId)) {
                        mAccount = account;
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    //TODO: Use ressource to externalize message
                    Toast.makeText(this, ""Invalid account id: "" + accountId, Toast.LENGTH_LONG).show();
                    return;
                }

                mMessageReference = new MessageReference();
                mMessageReference.accountUuid = mAccount.getUuid();
                mMessageReference.folderName = segmentList.get(1);
                mMessageReference.uid = segmentList.get(2);
                mMessageReferences = new ArrayList<MessageReference>();
            }
        }

        mAccount = Preferences.getPreferences(this).getAccount(mMessageReference.accountUuid);


        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""MessageView got message "" + mMessageReference);
        if (intent.getBooleanExtra(EXTRA_NEXT, false)) {
            mNext.requestFocus();
        }

        setupButtonViews();
        displayMessage(mMessageReference);
    }

    private void setupButtonViews() {
        setOnClickListener(R.id.from);
        setOnClickListener(R.id.reply);
        setOnClickListener(R.id.reply_all);
        setOnClickListener(R.id.delete);
        setOnClickListener(R.id.forward);
        setOnClickListener(R.id.next);
        setOnClickListener(R.id.previous);
        setOnClickListener(R.id.archive);
        setOnClickListener(R.id.move);
        setOnClickListener(R.id.spam);
        // To show full header
        setOnClickListener(R.id.header_container);
        setOnClickListener(R.id.reply_scrolling);
//       setOnClickListener(R.id.reply_all_scrolling);
        setOnClickListener(R.id.delete_scrolling);
        setOnClickListener(R.id.forward_scrolling);
        setOnClickListener(R.id.next_scrolling);
        setOnClickListener(R.id.previous_scrolling);
        setOnClickListener(R.id.archive_scrolling);
        setOnClickListener(R.id.move_scrolling);
        setOnClickListener(R.id.spam_scrolling);
        setOnClickListener(R.id.show_pictures);
        setOnClickListener(R.id.download_remainder);


        // Perhaps the ScrollButtons should be global, instead of account-specific
        Account.ScrollButtons scrollButtons = mAccount.getScrollMessageViewButtons();
        if ((Account.ScrollButtons.ALWAYS == scrollButtons)
                || (Account.ScrollButtons.KEYBOARD_AVAILABLE == scrollButtons &&
                    (this.getResources().getConfiguration().hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO))) {
            scrollButtons();
        } else {  // never or the keyboard is open
            staticButtons();
        }
        Account.ScrollButtons scrollMoveButtons = mAccount.getScrollMessageViewMoveButtons();
        if ((Account.ScrollButtons.ALWAYS == scrollMoveButtons)
                || (Account.ScrollButtons.KEYBOARD_AVAILABLE == scrollMoveButtons &&
                    (this.getResources().getConfiguration().hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO))) {
            scrollMoveButtons();
        } else {
            staticMoveButtons();
        }
        if (!mAccount.getEnableMoveButtons()) {
            View buttons = findViewById(R.id.move_buttons);
            if (buttons != null) {
                buttons.setVisibility(View.GONE);
            }
            buttons = findViewById(R.id.scrolling_move_buttons);
            if (buttons != null) {
                buttons.setVisibility(View.GONE);
            }
        }
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        outState.putParcelable(EXTRA_MESSAGE_REFERENCE, mMessageReference);
        outState.putParcelableArrayList(EXTRA_MESSAGE_REFERENCES, mMessageReferences);
        outState.putSerializable(STATE_PGP_DATA, mPgpData);
        outState.putBoolean(SHOW_PICTURES, mMessageView.showPictures());
    }

    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        mPgpData = (PgpData) savedInstanceState.getSerializable(STATE_PGP_DATA);
        mMessageView.updateCryptoLayout(mAccount.getCryptoProvider(), mPgpData, mMessage);
        mMessageView.setLoadPictures(savedInstanceState.getBoolean(SHOW_PICTURES));
    }

    private void displayMessage(MessageReference ref) {
        mMessageReference = ref;
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""MessageView displaying message "" + mMessageReference);
        mAccount = Preferences.getPreferences(this).getAccount(mMessageReference.accountUuid);
        clearMessageDisplay();
        findSurroundingMessagesUid();
        // start with fresh, empty PGP data
        mPgpData = new PgpData();
        mTopView.setVisibility(View.VISIBLE);
        mController.loadMessageForView(mAccount, mMessageReference.folderName, mMessageReference.uid, mListener);
        setupDisplayMessageButtons();
    }

    private void clearMessageDisplay() {
        mTopView.setVisibility(View.GONE);
        mTopView.scrollTo(0, 0);
        mMessageView.resetView();

    }

    private void setupDisplayMessageButtons() {
        mDelete.setEnabled(true);
        mNext.setEnabled(mNextMessage != null);
        mPrevious.setEnabled(mPreviousMessage != null);
        // If moving isn't support at all, then all of them must be disabled anyway.
        if (mController.isMoveCapable(mAccount)) {
            // Only enable the button if the Archive folder is not the current folder and not NONE.
            mArchive.setEnabled(!mMessageReference.folderName.equals(mAccount.getArchiveFolderName()) &&
                                !K9.FOLDER_NONE.equalsIgnoreCase(mAccount.getArchiveFolderName()));
            // Only enable the button if the Spam folder is not the current folder and not NONE.
            mSpam.setEnabled(!mMessageReference.folderName.equals(mAccount.getSpamFolderName()) &&
                             !K9.FOLDER_NONE.equalsIgnoreCase(mAccount.getSpamFolderName()));
            mMove.setEnabled(true);
        } else {
            disableMoveButtons();
        }
    }
    private void staticButtons() {
        View buttons = findViewById(R.id.scrolling_buttons);
        if (buttons != null) {
            buttons.setVisibility(View.GONE);
        }
        mNext = findViewById(R.id.next);
        mPrevious = findViewById(R.id.previous);
        mDelete = findViewById(R.id.delete);
    }

    private void scrollButtons() {
        View buttons = findViewById(R.id.bottom_buttons);
        if (buttons != null) {
            buttons.setVisibility(View.GONE);
        }
        mNext = findViewById(R.id.next_scrolling);
        mPrevious = findViewById(R.id.previous_scrolling);
        mDelete = findViewById(R.id.delete_scrolling);
    }

    private void staticMoveButtons() {
        View buttons = findViewById(R.id.scrolling_move_buttons);
        if (buttons != null) {
            buttons.setVisibility(View.GONE);
        }
        mArchive = findViewById(R.id.archive);
        mMove = findViewById(R.id.move);
        mSpam = findViewById(R.id.spam);
    }

    private void scrollMoveButtons() {
        View buttons = findViewById(R.id.move_buttons);
        if (buttons != null) {
            buttons.setVisibility(View.GONE);
        }
        mArchive = findViewById(R.id.archive_scrolling);
        mMove = findViewById(R.id.move_scrolling);
        mSpam = findViewById(R.id.spam_scrolling);
    }

    private void disableButtons() {
        mMessageView.setLoadPictures(false);
        disableMoveButtons();
        mNext.setEnabled(false);
        mPrevious.setEnabled(false);
        mDelete.setEnabled(false);
    }

    private void disableMoveButtons() {
        mArchive.setEnabled(false);
        mMove.setEnabled(false);
        mSpam.setEnabled(false);
    }

    private void setOnClickListener(int viewCode) {
        View thisView = findViewById(viewCode);
        if (thisView != null) {
            thisView.setOnClickListener(this);
        }
    }

    private void findSurroundingMessagesUid() {
        mNextMessage = mPreviousMessage = null;
        int i = mMessageReferences.indexOf(mMessageReference);
        if (i < 0)
            return;
        if (i != 0)
            mNextMessage = mMessageReferences.get(i - 1);
        if (i != (mMessageReferences.size() - 1))
            mPreviousMessage = mMessageReferences.get(i + 1);
    }

    @Override
    public void onResume() {
        super.onResume();
        if (!mAccount.isAvailable(this)) {
            onAccountUnavailable();
            return;
        }
        StorageManager.getInstance(getApplication()).addListener(mStorageListener);
    }

    @Override
    protected void onPause() {
        StorageManager.getInstance(getApplication()).removeListener(mStorageListener);
        super.onPause();
    }

    protected void onAccountUnavailable() {
        finish();
        // TODO inform user about account unavailability using Toast
        Accounts.listAccounts(this);
    }

    /**
     * Called from UI thread when user select Delete
     */
    private void onDelete() {
        if (K9.confirmDelete()) {
            showDialog(R.id.dialog_confirm_delete);
        } else {
            delete();
        }
    }

    private void delete() {
        if (mMessage != null) {
            // Disable the delete button after it's tapped (to try to prevent
            // accidental clicks)
            disableButtons();
            Message messageToDelete = mMessage;
            showNextMessageOrReturn();
            mController.deleteMessages(new Message[] {messageToDelete}, null);
        }
    }

    private void onRefile(String dstFolder) {
        if (!mController.isMoveCapable(mAccount)) {
            return;
        }
        if (!mController.isMoveCapable(mMessage)) {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }

        if (K9.FOLDER_NONE.equalsIgnoreCase(dstFolder)) {
            return;
        }

        if (mAccount.getSpamFolderName().equals(dstFolder) && K9.confirmSpam()) {
            mDstFolder = dstFolder;
            showDialog(R.id.dialog_confirm_spam);
        } else {
            refileMessage(dstFolder);
        }
    }

    private void refileMessage(String dstFolder) {
        String srcFolder = mMessageReference.folderName;
        Message messageToMove = mMessage;
        showNextMessageOrReturn();
        mController.moveMessage(mAccount, srcFolder, messageToMove, dstFolder, null);
    }

    private void showNextMessageOrReturn() {
        if (K9.messageViewReturnToList()) {
            finish();
        } else {
            showNextMessage();
        }
    }

    private void showNextMessage() {
        findSurroundingMessagesUid();
        mMessageReferences.remove(mMessageReference);
        if (mLastDirection == NEXT && mNextMessage != null) {
            onNext();
        } else if (mLastDirection == PREVIOUS && mPreviousMessage != null) {
            onPrevious();
        } else if (mNextMessage != null) {
            onNext();
        } else if (mPreviousMessage != null) {
            onPrevious();
        } else {
            finish();
        }
    }


    private void onReply() {
        if (mMessage != null) {
            MessageCompose.actionReply(this, mAccount, mMessage, false, mPgpData.getDecryptedData());
            finish();
        }
    }

    private void onReplyAll() {
        if (mMessage != null) {
            MessageCompose.actionReply(this, mAccount, mMessage, true, mPgpData.getDecryptedData());
            finish();
        }
    }

    private void onForward() {
        if (mMessage != null) {
            MessageCompose.actionForward(this, mAccount, mMessage, mPgpData.getDecryptedData());
            finish();
        }
    }

    private void onFlag() {
        if (mMessage != null) {
            mController.setFlag(mAccount,
                                mMessage.getFolder().getName(), new String[] {mMessage.getUid()}, Flag.FLAGGED, !mMessage.isSet(Flag.FLAGGED));
            try {
                mMessage.setFlag(Flag.FLAGGED, !mMessage.isSet(Flag.FLAGGED));
                mMessageView.setHeaders(mMessage, mAccount);
            } catch (MessagingException me) {
                Log.e(K9.LOG_TAG, ""Could not set flag on local message"", me);
            }
        }
    }

    private void onMove() {
        if ((!mController.isMoveCapable(mAccount))
                || (mMessage == null)) {
            return;
        }
        if (!mController.isMoveCapable(mMessage)) {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }

        startRefileActivity(ACTIVITY_CHOOSE_FOLDER_MOVE);
    }

    private void onCopy() {
        if ((!mController.isCopyCapable(mAccount))
                || (mMessage == null)) {
            return;
        }
        if (!mController.isCopyCapable(mMessage)) {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }

        startRefileActivity(ACTIVITY_CHOOSE_FOLDER_COPY);
    }

    private void startRefileActivity(int activity) {
        Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, mMessageReference.folderName);
        intent.putExtra(ChooseFolder.EXTRA_SEL_FOLDER, mAccount.getLastSelectedFolderName());
        intent.putExtra(ChooseFolder.EXTRA_MESSAGE, mMessageReference);
        startActivityForResult(intent, activity);
    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (mAccount.getCryptoProvider().onActivityResult(this, requestCode, resultCode, data, mPgpData)) {
            return;
        }
        if (resultCode != RESULT_OK)
            return;
        switch (requestCode) {
        case ACTIVITY_CHOOSE_DIRECTORY:
            if (resultCode == RESULT_OK && data != null) {
                // obtain the filename
                Uri fileUri = data.getData();
                if (fileUri != null) {
                    String filePath = fileUri.getPath();
                    if (filePath != null) {
                        attachmentTmpStore.writeFile(new File(filePath));
                    }
                }
            }

            break;
        case ACTIVITY_CHOOSE_FOLDER_MOVE:
        case ACTIVITY_CHOOSE_FOLDER_COPY:
            if (data == null)
                return;
            String destFolderName = data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER);
            String srcFolderName = data.getStringExtra(ChooseFolder.EXTRA_CUR_FOLDER);
            MessageReference ref = data.getParcelableExtra(ChooseFolder.EXTRA_MESSAGE);
            if (mMessageReference.equals(ref)) {
                mAccount.setLastSelectedFolderName(destFolderName);
                switch (requestCode) {
                case ACTIVITY_CHOOSE_FOLDER_MOVE:
                    Message messageToMove = mMessage;
                    showNextMessageOrReturn();
                    mController.moveMessage(mAccount, srcFolderName, messageToMove, destFolderName, null);
                    break;
                case ACTIVITY_CHOOSE_FOLDER_COPY:
                    mController.copyMessage(mAccount, srcFolderName, mMessage, destFolderName, null);
                    break;
                }
            }
            break;
        }
    }

    private void onSendAlternate() {
        if (mMessage != null) {
            mController.sendAlternate(this, mAccount, mMessage);
        }
    }

    @Override
    protected void onNext() {
        if (mNextMessage == null) {
            Toast.makeText(this, getString(R.string.end_of_folder), Toast.LENGTH_SHORT).show();
            return;
        }
        mLastDirection = NEXT;
        disableButtons();
        if (K9.showAnimations()) {
            mTopView.startAnimation(outToLeftAnimation());
        }
        displayMessage(mNextMessage);
        mNext.requestFocus();
    }

    @Override
    protected void onPrevious() {
        if (mPreviousMessage == null) {
            Toast.makeText(this, getString(R.string.end_of_folder), Toast.LENGTH_SHORT).show();
            return;
        }
        mLastDirection = PREVIOUS;
        disableButtons();
        if (K9.showAnimations()) {
            mTopView.startAnimation(inFromRightAnimation());
        }
        displayMessage(mPreviousMessage);
        mPrevious.requestFocus();
    }

    private void onMarkAsUnread() {
        if (mMessage != null) {
// (Issue 3319)            mController.setFlag(mAccount, mMessageReference.folderName, new String[] { mMessage.getUid() }, Flag.SEEN, false);
            try {
                mMessage.setFlag(Flag.SEEN, false);
                mMessageView.setHeaders(mMessage, mAccount);
                String subject = mMessage.getSubject();
                setTitle(subject);
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Unable to unset SEEN flag on message"", e);
            }
        }
    }


    private void onDownloadRemainder() {
        if (mMessage.isSet(Flag.X_DOWNLOADED_FULL)) {
            return;
        }
        mMessageView.downloadRemainderButton().setEnabled(false);
        mController.loadMessageForViewRemote(mAccount, mMessageReference.folderName, mMessageReference.uid, mListener);
    }


    public void onClick(View view) {
        switch (view.getId()) {
        case R.id.reply:
        case R.id.reply_scrolling:
            onReply();
            break;
        case R.id.reply_all:
            onReplyAll();
            break;
        case R.id.delete:
        case R.id.delete_scrolling:
            onDelete();
            break;
        case R.id.forward:
        case R.id.forward_scrolling:
            onForward();
            break;
        case R.id.archive:
        case R.id.archive_scrolling:
            onRefile(mAccount.getArchiveFolderName());
            break;
        case R.id.spam:
        case R.id.spam_scrolling:
            onRefile(mAccount.getSpamFolderName());
            break;
        case R.id.move:
        case R.id.move_scrolling:
            onMove();
            break;
        case R.id.next:
        case R.id.next_scrolling:
            onNext();
            break;
        case R.id.previous:
        case R.id.previous_scrolling:
            onPrevious();
            break;
        case R.id.download:
            ((AttachmentView)view).saveFile();
            break;
        case R.id.show_pictures:
            mMessageView.setLoadPictures(true);
            break;
        case R.id.download_remainder:
            onDownloadRemainder();
            break;
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.delete:
            onDelete();
            break;
        case R.id.reply:
            onReply();
            break;
        case R.id.reply_all:
            onReplyAll();
            break;
        case R.id.forward:
            onForward();
            break;
        case R.id.send_alternate:
            onSendAlternate();
            break;
        case R.id.mark_as_unread:
            onMarkAsUnread();
            break;
        case R.id.flag:
            onFlag();
            break;
        case R.id.archive:
            onRefile(mAccount.getArchiveFolderName());
            break;
        case R.id.spam:
            onRefile(mAccount.getSpamFolderName());
            break;
        case R.id.move:
            onMove();
            break;
        case R.id.copy:
            onCopy();
            break;
        case R.id.show_full_header:
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    mMessageView.showAllHeaders();
                }
            });
            break;
        case R.id.select_text:
            mToggleScrollView.setScrolling(false);
            mMessageView.beginSelectingText();
            break;
        default:
            return super.onOptionsItemSelected(item);
        }
        return true;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.message_view_option, menu);
        if (!mController.isCopyCapable(mAccount)) {
            menu.findItem(R.id.copy).setVisible(false);
        }
        if (!mController.isMoveCapable(mAccount)) {
            menu.findItem(R.id.move).setVisible(false);
            menu.findItem(R.id.archive).setVisible(false);
            menu.findItem(R.id.spam).setVisible(false);
        }
        if (K9.FOLDER_NONE.equalsIgnoreCase(mAccount.getArchiveFolderName())) {
            menu.findItem(R.id.archive).setVisible(false);
        }
        if (K9.FOLDER_NONE.equalsIgnoreCase(mAccount.getSpamFolderName())) {
            menu.findItem(R.id.spam).setVisible(false);
        }
        return true;
    }

    // TODO: when switching to API version 8, override onCreateDialog(int, Bundle)

    /**
     * @param id The id of the dialog.
     * @return The dialog. If you return null, the dialog will not be created.
     * @see android.app.Activity#onCreateDialog(int)
     */
    @Override
    protected Dialog onCreateDialog(final int id) {
        switch (id) {
        case R.id.dialog_confirm_delete:
            return ConfirmationDialog.create(this, id,
                                             R.string.dialog_confirm_delete_title,
                                             R.string.dialog_confirm_delete_message,
                                             R.string.dialog_confirm_delete_confirm_button,
                                             R.string.dialog_confirm_delete_cancel_button,
            new Runnable() {
                @Override
                public void run() {
                    delete();
                }
            });
        case R.id.dialog_confirm_spam:
            return ConfirmationDialog.create(this, id,
                                             R.string.dialog_confirm_spam_title,
                                             getResources().getQuantityString(R.plurals.dialog_confirm_spam_message, 1),
                                             R.string.dialog_confirm_spam_confirm_button,
                                             R.string.dialog_confirm_spam_cancel_button,
            new Runnable() {
                @Override
                public void run() {
                    refileMessage(mDstFolder);
                    mDstFolder = null;
                }
            });
        case R.id.dialog_attachment_progress:
            ProgressDialog d = new ProgressDialog(this);
            d.setIndeterminate(true);
            d.setTitle(R.string.dialog_attachment_progress_title);
            return d;
        }
        return super.onCreateDialog(id);
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        if (menu != null) {
            MenuItem flagItem = menu.findItem(R.id.flag);
            if (flagItem != null && mMessage != null) {
                flagItem.setTitle((mMessage.isSet(Flag.FLAGGED) ? R.string.unflag_action : R.string.flag_action));
            }
            MenuItem additionalHeadersItem = menu.findItem(R.id.show_full_header);
            if (additionalHeadersItem != null) {
                additionalHeadersItem.setTitle(mMessageView.additionalHeadersVisible() ?
                                               R.string.hide_full_header_action : R.string.show_full_header_action);
            }
        }
        return super.onPrepareOptionsMenu(menu);
    }

    public void displayMessageBody(final Account account, final String folder, final String uid, final Message message) {
        runOnUiThread(new Runnable() {
            public void run() {
                mTopView.scrollTo(0, 0);
                try {
                    if (MessageView.this.mMessage != null
                            && MessageView.this.mMessage.isSet(Flag.X_DOWNLOADED_PARTIAL)
                    && message.isSet(Flag.X_DOWNLOADED_FULL)) {
                        mMessageView.setHeaders(message, account);
                    }
                    MessageView.this.mMessage = message;
                    mMessageView.displayMessageBody(account, folder, uid, message, mPgpData);
                    mMessageView.renderAttachments(mMessage, 0, mMessage, mAccount, mController, mListener);
                } catch (MessagingException e) {
                    if (Config.LOGV) {
                        Log.v(K9.LOG_TAG, ""loadMessageForViewBodyAvailable"", e);
                    }
                }
            }
        });
    }

    class Listener extends MessagingListener {
        @Override
        public void loadMessageForViewHeadersAvailable(final Account account, String folder, String uid,
                final Message message) {
            if (!mMessageReference.uid.equals(uid) || !mMessageReference.folderName.equals(folder)
                    || !mMessageReference.accountUuid.equals(account.getUuid())) {
                return;
            }
            MessageView.this.mMessage = message;
            runOnUiThread(new Runnable() {
                public void run() {
                    if (!message.isSet(Flag.X_DOWNLOADED_FULL) && !message.isSet(Flag.X_DOWNLOADED_PARTIAL)) {
                        mMessageView.loadBodyFromUrl(""file:///android_asset/downloading.html"");
                    }
                    mMessageView.setHeaders(message, account);
                    mMessageView.setOnFlagListener(new OnClickListener() {
                        @Override
                        public void onClick(View v) {
                            onFlag();
                        }
                    });
                }
            });
        }

        @Override
        public void loadMessageForViewBodyAvailable(Account account, String folder, String uid,
                Message message) {
            if (!mMessageReference.uid.equals(uid) || !mMessageReference.folderName.equals(folder)
                    || !mMessageReference.accountUuid.equals(account.getUuid())) {
                return;
            }

            displayMessageBody(account, folder, uid, message);
        }//loadMessageForViewBodyAvailable



        @Override
        public void loadMessageForViewFailed(Account account, String folder, String uid, final Throwable t) {
            if (!mMessageReference.uid.equals(uid) || !mMessageReference.folderName.equals(folder)
                    || !mMessageReference.accountUuid.equals(account.getUuid())) {
                return;
            }
            mHandler.post(new Runnable() {
                public void run() {
                    setProgressBarIndeterminateVisibility(false);
                    if (t instanceof IllegalArgumentException) {
                        mHandler.invalidIdError();
                    } else {
                        mHandler.networkError();
                    }
                    if ((MessageView.this.mMessage == null) ||
                    !MessageView.this.mMessage.isSet(Flag.X_DOWNLOADED_PARTIAL)) {
                        mMessageView.loadBodyFromUrl(""file:///android_asset/empty.html"");
                    }
                }
            });
        }

        @Override
        public void loadMessageForViewFinished(Account account, String folder, String uid, final Message message) {
            if (!mMessageReference.uid.equals(uid) || !mMessageReference.folderName.equals(folder)
                    || !mMessageReference.accountUuid.equals(account.getUuid())) {
                return;
            }
            mHandler.post(new Runnable() {
                public void run() {
                    setProgressBarIndeterminateVisibility(false);
                    mMessageView.setShowDownloadButton(message);
                }
            });
        }

        @Override
        public void loadMessageForViewStarted(Account account, String folder, String uid) {
            if (!mMessageReference.uid.equals(uid) || !mMessageReference.folderName.equals(folder)
                    || !mMessageReference.accountUuid.equals(account.getUuid())) {
                return;
            }
            mHandler.post(new Runnable() {
                public void run() {
                    setProgressBarIndeterminateVisibility(true);
                }
            });
        }

        @Override
        public void loadAttachmentStarted(Account account, Message message, Part part, Object tag, final boolean requiresDownload) {
            if (mMessage != message) {
                return;
            }
            mHandler.post(new Runnable() {
                public void run() {
                    mMessageView.setAttachmentsEnabled(false);
                    showDialog(R.id.dialog_attachment_progress);
                    if (requiresDownload) {
                        mHandler.fetchingAttachment();
                    }
                }
            });
        }

        @Override
        public void loadAttachmentFinished(Account account, Message message, Part part, final Object tag) {
            if (mMessage != message) {
                return;
            }
            mHandler.post(new Runnable() {
                public void run() {
                    mMessageView.setAttachmentsEnabled(true);
                    removeDialog(R.id.dialog_attachment_progress);
                    Object[] params = (Object[]) tag;
                    boolean download = (Boolean) params[0];
                    AttachmentView attachment = (AttachmentView) params[1];
                    if (download) {
                        attachment.writeFile();
                    } else {
                        attachment.showFile();
                    }
                }
            });
        }

        @Override
        public void loadAttachmentFailed(Account account, Message message, Part part, Object tag, String reason) {
            if (mMessage != message) {
                return;
            }
            mHandler.post(new Runnable() {
                public void run() {
                    mMessageView.setAttachmentsEnabled(true);
                    removeDialog(R.id.dialog_attachment_progress);
                    mHandler.networkError();
                }
            });
        }
    }

    // This REALLY should be in MessageCryptoView
    public void onDecryptDone(PgpData pgpData) {
        // TODO: this might not be enough if the orientation was changed while in APG,
        // sometimes shows the original encrypted content
        mMessageView.loadBodyFromText(mAccount.getCryptoProvider(), mPgpData, mMessage, mPgpData.getDecryptedData(), ""text/plain"");
    }

}
",True,144,0,0,5,65,2,22,L1
66,com.fsck.k9.activity.FolderListFilter.java,"package com.fsck.k9.activity;

import java.util.ArrayList;
import java.util.List;

import android.util.Log;
import android.widget.ArrayAdapter;
import android.widget.Filter;

import com.fsck.k9.K9;

/**
 * Filter to search for occurences of the search-expression in any place of the
 * folder-name instead of doing jsut a prefix-search.
 *
 * @author Marcus@Wolschon.biz
 */
public class FolderListFilter<T> extends Filter {
    /**
     * ArrayAdapter that contains the list of folders displayed in the
     * ListView.
     * This object is modified by {@link #publishResults} to reflect the
     * changes due to the filtering performed by {@link #performFiltering}.
     * This in turn will change the folders displayed in the ListView.
     */
    private ArrayAdapter<T> mFolders;

    /**
     * All folders.
     */
    private ArrayList<T> mOriginalValues = null;

    /**
     * Create a filter for a list of folders.
     *
     * @param folderNames
     */
    public FolderListFilter(final ArrayAdapter<T> folderNames) {
        this.mFolders = folderNames;
    }

    /**
     * Do the actual search.
     * {@inheritDoc}
     *
     * @see #publishResults(CharSequence, FilterResults)
     */
    @Override
    protected FilterResults performFiltering(CharSequence searchTerm) {
        FilterResults results = new FilterResults();

        // Copy the values from mFolders to mOriginalValues if this is the
        // first time this method is called.
        if (mOriginalValues == null) {
            int count = mFolders.getCount();
            mOriginalValues = new ArrayList<T>(count);
            for (int i = 0; i < count; i++) {
                mOriginalValues.add(mFolders.getItem(i));
            }
        }

        if ((searchTerm == null) || (searchTerm.length() == 0)) {
            ArrayList<T> list = new ArrayList<T>(mOriginalValues);
            results.values = list;
            results.count = list.size();
        } else {
            final String searchTermString = searchTerm.toString().toLowerCase();
            final String[] words = searchTermString.split("" "");
            final int wordCount = words.length;

            final ArrayList<T> values = mOriginalValues;

            final ArrayList<T> newValues = new ArrayList<T>();

            for (final T value : values) {
                final String valueText = value.toString().toLowerCase();

                for (int k = 0; k < wordCount; k++) {
                    if (valueText.contains(words[k])) {
                        newValues.add(value);
                        break;
                    }
                }
            }

            results.values = newValues;
            results.count = newValues.size();
        }

        return results;
    }

    /**
     * Publish the results to the user-interface.
     * {@inheritDoc}
     */
    @SuppressWarnings(""unchecked"")
    @Override
    protected void publishResults(CharSequence constraint, FilterResults results) {
        // Don't notify for every change
        mFolders.setNotifyOnChange(false);
        try {

            //noinspection unchecked
            final List<T> folders = (List<T>) results.values;
            mFolders.clear();
            if (folders != null) {
                for (T folder : folders) {
                    if (folder != null) {
                        mFolders.add(folder);
                    }
                }
            } else {
                Log.w(K9.LOG_TAG, ""FolderListFilter.publishResults - null search-result "");
            }

            // Send notification that the data set changed now
            mFolders.notifyDataSetChanged();
        } finally {
            // restore notification status
            mFolders.setNotifyOnChange(true);
        }
    }

    public void invalidate() {
        mOriginalValues = null;
    }
}
",False,144,0,0,7,55,1,1,L1
67,com.fsck.k9.activity.ActivityListener.java,"package com.fsck.k9.activity;

import java.text.DateFormat;

import android.content.Context;

import com.fsck.k9.Account;
import com.fsck.k9.AccountStats;
import com.fsck.k9.R;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.service.MailService;

public class ActivityListener extends MessagingListener {
    private Account mAccount = null;
    private String mLoadingFolderName = null;
    private String mLoadingHeaderFolderName = null;
    private String mLoadingAccountDescription = null;
    private String mSendingAccountDescription = null;
    private int mFolderCompleted = 0;
    private int mFolderTotal = 0;
    private String mProcessingAccountDescription = null;
    private String mProcessingCommandTitle = null;


    public String formatHeader(Context context, String activityPrefix, int unreadMessageCount, DateFormat timeFormat) {
        String operation = null;
        String progress = null;
        if (mLoadingAccountDescription  != null
                || mSendingAccountDescription != null
                || mLoadingHeaderFolderName != null
                || mProcessingAccountDescription != null) {
            progress = (mFolderTotal > 0 ?
                        context.getString(R.string.folder_progress, mFolderCompleted, mFolderTotal) : """");

            if (mLoadingFolderName != null || mLoadingHeaderFolderName != null) {
                String displayName = mLoadingFolderName;
                if ((mAccount != null) && (mAccount.getInboxFolderName() != null) && mAccount.getInboxFolderName().equalsIgnoreCase(displayName)) {
                    displayName = context.getString(R.string.special_mailbox_name_inbox);
                } else if ((mAccount != null) && mAccount.getOutboxFolderName().equals(displayName)) {
                    displayName = context.getString(R.string.special_mailbox_name_outbox);
                }

                if (mLoadingHeaderFolderName != null) {

                    operation = context.getString(R.string.status_loading_account_folder_headers, mLoadingAccountDescription, displayName, progress);
                } else {
                    operation = context.getString(R.string.status_loading_account_folder, mLoadingAccountDescription, displayName, progress);
                }
            }

            else if (mSendingAccountDescription != null) {
                operation = context.getString(R.string.status_sending_account, mSendingAccountDescription, progress);
            } else if (mProcessingAccountDescription != null) {
                operation = context.getString(R.string.status_processing_account, mProcessingAccountDescription,
                                              mProcessingCommandTitle != null ? mProcessingCommandTitle : """",
                                              progress);
            }
        } else {
            long nextPollTime = MailService.getNextPollTime();
            if (nextPollTime != -1) {
                operation = context.getString(R.string.status_next_poll, timeFormat.format(nextPollTime));
            } else if (MailService.isSyncDisabled()) {
                operation = context.getString(R.string.status_syncing_off);
            } else {
                operation = """";
            }
        }

        return context.getString(R.string.activity_header_format, activityPrefix,
                                 (unreadMessageCount > 0 ? context.getString(R.string.activity_unread_count, unreadMessageCount) : """"),
                                 operation);


    }

    public void informUserOfStatus() {
    }

    @Override
    public void synchronizeMailboxFinished(
        Account account,
        String folder,
        int totalMessagesInMailbox,
        int numNewMessages) {
        mLoadingAccountDescription = null;
        mLoadingFolderName = null;
        mAccount = null;
        informUserOfStatus();
    }

    @Override
    public void synchronizeMailboxStarted(Account account, String folder) {
        mLoadingAccountDescription = account.getDescription();
        mLoadingFolderName = folder;
        mAccount = account;
        mFolderCompleted = 0;
        mFolderTotal = 0;
        informUserOfStatus();
    }


    @Override
    public void synchronizeMailboxHeadersStarted(Account account, String folder) {
        mLoadingHeaderFolderName = folder;
        informUserOfStatus();
    }


    @Override
    public void synchronizeMailboxHeadersProgress(Account account, String folder, int completed, int total) {
        mFolderCompleted = completed;
        mFolderTotal = total;
        informUserOfStatus();
    }

    @Override
    public void synchronizeMailboxHeadersFinished(Account account, String folder,
            int total, int completed) {
        mLoadingHeaderFolderName = null;
        mFolderCompleted = 0;
        mFolderTotal = 0;
        informUserOfStatus();
    }


    @Override
    public void synchronizeMailboxProgress(Account account, String folder, int completed, int total) {
        mFolderCompleted = completed;
        mFolderTotal = total;
        informUserOfStatus();
    }

    @Override
    public void synchronizeMailboxFailed(Account account, String folder,
                                         String message) {
        mLoadingAccountDescription = null;
        mLoadingFolderName = null;
        mAccount = null;
        informUserOfStatus();

    }

    @Override
    public void sendPendingMessagesStarted(Account account) {
        mSendingAccountDescription = account.getDescription();
        informUserOfStatus();
    }

    @Override
    public void sendPendingMessagesCompleted(Account account) {
        mSendingAccountDescription = null;
        informUserOfStatus();
    }

    @Override
    public void sendPendingMessagesFailed(Account account) {
        mSendingAccountDescription = null;
        informUserOfStatus();
    }

    @Override
    public void pendingCommandsProcessing(Account account) {
        mProcessingAccountDescription = account.getDescription();
        mFolderCompleted = 0;
        mFolderTotal = 0;
        informUserOfStatus();
    }

    @Override
    public void pendingCommandsFinished(Account account) {
        mProcessingAccountDescription = null;
        informUserOfStatus();
    }

    @Override
    public void pendingCommandStarted(Account account, String commandTitle) {
        mProcessingCommandTitle = commandTitle;
        informUserOfStatus();
    }

    @Override
    public void pendingCommandCompleted(Account account, String commandTitle) {
        mProcessingCommandTitle = null;
        informUserOfStatus();
    }

    @Override
    public void searchStats(AccountStats stats) {
        informUserOfStatus();
    }

    @Override
    public void systemStatusChanged() {
        informUserOfStatus();
    }
    @Override
    public void folderStatusChanged(Account account, String folder, int unreadMessageCount) {
        informUserOfStatus();
    }

    public int getFolderCompleted() {
        return mFolderCompleted;
    }


    public int getFolderTotal() {
        return mFolderTotal;
    }

}
",False,144,0,0,6,46,3,4,L1
68,com.fsck.k9.activity.FolderInfoHolder.java,"package com.fsck.k9.activity;

import android.content.Context;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.R;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.MessagingException;

public class FolderInfoHolder implements Comparable<FolderInfoHolder> {
    public String name;
    public String displayName;
    public long lastChecked;
    public int unreadMessageCount;
    public int flaggedMessageCount;
    public boolean loading;
    public String status;
    public boolean lastCheckFailed;
    public Folder folder;
    public boolean pushActive;

    @Override
    public boolean equals(Object o) {
        return this.name.equals(((FolderInfoHolder)o).name);
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }

    public int compareTo(FolderInfoHolder o) {
        String s1 = this.name;
        String s2 = o.name;

        int ret = s1.compareToIgnoreCase(s2);
        if (ret != 0) {
            return ret;
        } else {
            return s1.compareTo(s2);
        }

    }

    private String truncateStatus(String mess) {
        if (mess != null && mess.length() > 27) {
            mess = mess.substring(0, 27);
        }
        return mess;
    }

    // constructor for an empty object for comparisons
    public FolderInfoHolder() {
    }

    public FolderInfoHolder(Context context, Folder folder, Account account) {
        if (context == null) {
            throw new IllegalArgumentException(""null context given"");
        }
        populate(context, folder, account);
    }

    public FolderInfoHolder(Context context, Folder folder, Account account, int unreadCount) {
        populate(context, folder, account, unreadCount);
    }

    public void populate(Context context, Folder folder, Account account, int unreadCount) {

        try {
            folder.open(Folder.OpenMode.READ_WRITE);
            //  unreadCount = folder.getUnreadMessageCount();
        } catch (MessagingException me) {
            Log.e(K9.LOG_TAG, ""Folder.getUnreadMessageCount() failed"", me);
        }

        populate(context, folder, account);

        this.unreadMessageCount = unreadCount;

        try {
            this.flaggedMessageCount = folder.getFlaggedMessageCount();
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Unable to get flaggedMessageCount"", e);
        }

        folder.close();

    }


    public void populate(Context context, Folder folder, Account account) {
        this.folder = folder;
        this.name = folder.getName();
        this.lastChecked = folder.getLastUpdate();

        this.status = truncateStatus(folder.getStatus());

        if (this.name.equalsIgnoreCase(account.getInboxFolderName())) {
            this.displayName = context.getString(R.string.special_mailbox_name_inbox);
        } else {
            this.displayName = folder.getName();
        }

        if (this.name.equals(account.getOutboxFolderName())) {
            this.displayName = context.getString(R.string.special_mailbox_name_outbox);
        }

        if (this.name.equals(account.getDraftsFolderName())) {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_drafts_fmt), this.name);
        }

        if (this.name.equals(account.getTrashFolderName())) {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_trash_fmt), this.name);
        }

        if (this.name.equals(account.getSentFolderName())) {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_sent_fmt), this.name);
        }

        if (this.name.equals(account.getArchiveFolderName())) {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_archive_fmt), this.name);
        }

        if (this.name.equals(account.getSpamFolderName())) {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_spam_fmt), this.name);
        }
    }
}
",True,145,1,1,6,49,5,4,L1
69,com.fsck.k9.activity.AccessibleEmailContentActivity.java,"/*
 * Copyright (C) 2010 The IDEAL Group
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.activity;

import java.util.ArrayList;
import android.app.ListActivity;
import android.os.Bundle;
import android.text.Html;
import android.text.Spanned;
import android.widget.ArrayAdapter;

public class AccessibleEmailContentActivity extends ListActivity {
    /**
     * Immutable empty String array
     */
    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    /**
     * Called when the activity is first created.
     */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        String htmlSource = getIntent().getStringExtra(""content"");
        Spanned parsedHtml = Html.fromHtml(htmlSource, null, null);
        String[] rawListItems = parsedHtml.toString().split(""\n"");

        ArrayList<String> cleanedList = new ArrayList<String>();
        for (String rawListItem : rawListItems) {
            if (rawListItem.trim().length() > 0) {
                addToCleanedList(cleanedList, rawListItem);
            }
        }

        String[] listItems = cleanedList.toArray(EMPTY_STRING_ARRAY);

        setContentView(com.fsck.k9.R.layout.accessible_email_content);
        setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, listItems));
    }

    private void addToCleanedList(ArrayList<String> cleanedList, String line) {
        if (line.length() < 80) {
            cleanedList.add(line);
        } else {
            while (line.length() > 80) {
                int cutPoint = line.indexOf("" "", 80);
                if ((cutPoint > 0) && (cutPoint < line.length())) {
                    cleanedList.add(line.substring(0, cutPoint));
                    line = line.substring(cutPoint).trim();
                } else {
                    cleanedList.add(line);
                    line = """";
                }
            }
            if (line.length() > 0) {
                cleanedList.add(line);
            }
        }
    }

}
",False,114,9,45,0,0,1,0,L1
70,com.fsck.k9.activity.MessageReference.java,"package com.fsck.k9.activity;

import android.os.Parcel;
import android.os.Parcelable;
import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.MessagingException;

import java.util.StringTokenizer;

public class MessageReference implements Parcelable {
    public String accountUuid;
    public String folderName;
    public String uid;
    public Flag flag = null;

    /**
     * Initialize an empty MessageReference.
     */
    public MessageReference() {
    }

    // Version identifier for use when serializing. This will allow us to introduce future versions
    // if we have to rev MessageReference.
    private static final String IDENTITY_VERSION_1 = ""!"";
    private static final String IDENTITY_SEPARATOR = "":"";

    /**
     * Initialize a MessageReference from a seraialized identity.
     * @param identity Serialized identity.
     * @throws MessagingException On missing or corrupted identity.
     */
    public MessageReference(final String identity) throws MessagingException {
        // Can't be null and must be at least length one so we can check the version.
        if (identity == null || identity.length() < 1) {
            throw new MessagingException(""Null or truncated MessageReference identity."");
        }

        // Version check.
        if (identity.charAt(0) == IDENTITY_VERSION_1.charAt(0)) {
            // Split the identity, stripping away the first two characters representing the version and delimiter.
            StringTokenizer tokens = new StringTokenizer(identity.substring(2), IDENTITY_SEPARATOR, false);
            if (tokens.countTokens() >= 3) {
                accountUuid = Utility.base64Decode(tokens.nextToken());
                folderName = Utility.base64Decode(tokens.nextToken());
                uid = Utility.base64Decode(tokens.nextToken());

                if (tokens.hasMoreTokens()) {
                    final String flagString = tokens.nextToken();
                    try {
                        flag = Flag.valueOf(flagString);
                    } catch (IllegalArgumentException ie) {
                        throw new MessagingException(""Could not thaw message flag '"" + flagString + ""'"", ie);
                    }
                }

                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Thawed "" + toString());
            } else {
                throw new MessagingException(""Invalid MessageReference in "" + identity + "" identity."");
            }
        }
    }

    /**
     * Serialize this MessageReference for storing in a K9 identity.  This is a colon-delimited base64 string.
     *
     * @return Serialized string.
     */
    public String toIdentityString() {
        StringBuilder refString = new StringBuilder();

        refString.append(IDENTITY_VERSION_1);
        refString.append(IDENTITY_SEPARATOR);
        refString.append(Utility.base64Encode(accountUuid));
        refString.append(IDENTITY_SEPARATOR);
        refString.append(Utility.base64Encode(folderName));
        refString.append(IDENTITY_SEPARATOR);
        refString.append(Utility.base64Encode(uid));
        if (flag != null) {
            refString.append(IDENTITY_SEPARATOR);
            refString.append(flag.name());
        }

        return refString.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof MessageReference == false) {
            return false;
        }
        MessageReference other = (MessageReference)o;
        if ((accountUuid == other.accountUuid || (accountUuid != null && accountUuid.equals(other.accountUuid)))
                && (folderName == other.folderName || (folderName != null && folderName.equals(other.folderName)))
                && (uid == other.uid || (uid != null && uid.equals(other.uid)))) {
            return true;
        }
        return false;
    }

    @Override
    public int hashCode() {
        final int MULTIPLIER = 31;

        int result = 1;
        result = MULTIPLIER * result + ((accountUuid == null) ? 0 : accountUuid.hashCode());
        result = MULTIPLIER * result + ((folderName == null) ? 0 : folderName.hashCode());
        result = MULTIPLIER * result + ((uid == null) ? 0 : uid.hashCode());
        return result;
    }

    @Override
    public String toString() {
        return ""MessageReference{"" +
               ""accountUuid='"" + accountUuid + '\'' +
               "", folderName='"" + folderName + '\'' +
               "", uid='"" + uid + '\'' +
               "", flag="" + flag +
               '}';
    }

    public static final Creator<MessageReference> CREATOR = new Creator<MessageReference>() {
        @Override
        public MessageReference createFromParcel(Parcel source) {
            MessageReference ref = new MessageReference();
            ref.uid = source.readString();
            ref.accountUuid = source.readString();
            ref.folderName = source.readString();
            String flag = source.readString();
            if (flag != null) ref.flag = Flag.valueOf(flag);
            return ref;
        }

        @Override
        public MessageReference[] newArray(int size) {
            return new MessageReference[size];
        }
    };

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(uid);
        dest.writeString(accountUuid);
        dest.writeString(folderName);
        dest.writeString(flag == null ? null : flag.name());
    }
}
",True,145,1,1,7,52,6,4,L1
71,com.fsck.k9.activity.ChooseAccount.java,"package com.fsck.k9.activity;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.widget.BaseExpandableListAdapter;
import android.widget.ExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.TextView;

import com.fsck.k9.Account;
import com.fsck.k9.Identity;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;

import java.util.List;

/**
 * Activity displaying list of accounts/identity for user choice
 *
 * @see K9ExpandableListActivity
 */
public class ChooseAccount extends K9ExpandableListActivity {

    /**
     * {@link Intent} extended data name for storing {@link Account#getUuid()
     * account UUID}
     */
    public static final String EXTRA_ACCOUNT = ChooseAccount.class.getName() + ""_account"";

    /**
     * {@link Intent} extended data name for storing serialized {@link Identity}
     */
    public static final String EXTRA_IDENTITY = ChooseAccount.class.getName() + ""_identity"";

    @Override
    protected void onCreate(final Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        setContentView(R.layout.choose_account);

        final ExpandableListView expandableListView = getExpandableListView();
        expandableListView.setItemsCanFocus(false);

        final ExpandableListAdapter adapter = createAdapter();
        setListAdapter(adapter);

        expandableListView.setOnChildClickListener(new ExpandableListView.OnChildClickListener() {
            @Override
            public boolean onChildClick(ExpandableListView parent, View v, int groupPosition,
            int childPosition, long id) {
                final Identity identity = (Identity) adapter.getChild(groupPosition, childPosition);
                final Account account = (Account) adapter.getGroup(groupPosition);

                if (!account.isAvailable(v.getContext())) {
                    Log.i(K9.LOG_TAG, ""Refusing selection of unavailable account"");
                    return true;
                }
                final Intent intent = new Intent();
                intent.putExtra(EXTRA_ACCOUNT, account.getUuid());
                intent.putExtra(EXTRA_IDENTITY, identity);
                setResult(RESULT_OK, intent);

                finish();
                return true;
            }
        });

        final Bundle extras = getIntent().getExtras();
        final String uuid = extras.getString(EXTRA_ACCOUNT);
        if (uuid != null) {
            final Account[] accounts = Preferences.getPreferences(this).getAccounts();
            final int length = accounts.length;
            for (int i = 0; i < length; i++) {
                final Account account = accounts[i];
                if (uuid.equals(account.getUuid())) {
                    // setSelectedChild() doesn't seem to obey the
                    // shouldExpandGroup parameter (2.1), manually expanding
                    // group
                    expandableListView.expandGroup(i);

                    final List<Identity> identities = account.getIdentities();
                    final Identity identity = (Identity) extras.getSerializable(EXTRA_IDENTITY);
                    if (identity == null) {
                        expandableListView.setSelectedChild(i, 0, true);
                        break;
                    }
                    for (int j = 0; j < identities.size(); j++) {
                        final Identity loopIdentity = identities.get(j);
                        if (identity.equals(loopIdentity)) {
                            expandableListView.setSelectedChild(i, j, true);
                            break;
                        }
                    }
                    break;
                }
            }
        }
    }

    private ExpandableListAdapter createAdapter() {
        return new IdentitiesAdapter(this, getLayoutInflater());
    }

    /**
     * Dynamically provides accounts/identities data for
     * {@link ExpandableListView#setAdapter(ExpandableListAdapter)}:
     *
     * <ul>
     * <li>Groups represent {@link Account accounts}</li>
     * <li>Children represent {@link Identity identities} of the parent account</li>
     * </ul>
     */
    public static class IdentitiesAdapter extends BaseExpandableListAdapter {

        private Context mContext;
        private LayoutInflater mLayoutInflater;

        public IdentitiesAdapter(final Context context, final LayoutInflater layoutInflater) {
            mContext = context;
            mLayoutInflater = layoutInflater;
        }

        @Override
        public Object getChild(int groupPosition, int childPosition) {
            return getAccounts()[groupPosition].getIdentity(childPosition);
        }

        @Override
        public long getChildId(int groupPosition, int childPosition) {
            return Integer.valueOf(childPosition).longValue();
        }

        @Override
        public int getChildrenCount(int groupPosition) {
            return getAccounts()[groupPosition].getIdentities().size();
        }

        @Override
        public Object getGroup(int groupPosition) {
            return getAccounts()[groupPosition];
        }

        @Override
        public int getGroupCount() {
            return getAccounts().length;
        }

        @Override
        public long getGroupId(int groupPosition) {
            return Integer.valueOf(groupPosition).longValue();
        }

        @Override
        public View getGroupView(int groupPosition, boolean isExpanded, View convertView,
                                 ViewGroup parent) {
            final View v;
            if (convertView == null) {
                v = mLayoutInflater.inflate(R.layout.choose_account_item, parent, false);
            } else {
                v = convertView;
            }

            final TextView description = (TextView) v.findViewById(R.id.description);
            final Account account = getAccounts()[groupPosition];
            description.setText(account.getDescription());
            description.setTextSize(TypedValue.COMPLEX_UNIT_DIP, K9.getFontSizes().getAccountName());

            // display unavailable accounts translucent
            /*
             * 20101030/fiouzy: NullPointerException on null getBackground()
             *
                        if (account.isAvailable(parent.getContext()))
                        {
                            description.getBackground().setAlpha(255);
                            description.getBackground().setAlpha(255);
                        }
                        else
                        {
                            description.getBackground().setAlpha(127);
                            description.getBackground().setAlpha(127);
                        }
            */

            v.findViewById(R.id.chip).setBackgroundColor(account.getChipColor());

            return v;
        }

        @Override
        public View getChildView(int groupPosition, int childPosition, boolean isLastChild,
                                 View convertView, ViewGroup parent) {
            final Account account = getAccounts()[groupPosition];
            final Identity identity = account.getIdentity(childPosition);

            final View v;
            if (convertView == null) {
                v = mLayoutInflater.inflate(R.layout.choose_identity_item, parent, false);
            } else {
                v = convertView;
            }

            final TextView name = (TextView) v.findViewById(R.id.name);
            final TextView description = (TextView) v.findViewById(R.id.description);
            name.setTextSize(TypedValue.COMPLEX_UNIT_DIP, K9.getFontSizes().getAccountName());
            description.setTextSize(TypedValue.COMPLEX_UNIT_DIP, K9.getFontSizes().getAccountDescription());

            name.setText(identity.getDescription());
            description.setText(String.format(""%s <%s>"", identity.getName(), identity.getEmail()));

            v.findViewById(R.id.chip).setBackgroundColor(account.getChipColor());

            return v;
        }

        @Override
        public boolean hasStableIds() {
            // returning false since accounts/identities are mutable
            return false;
        }

        @Override
        public boolean isChildSelectable(int groupPosition, int childPosition) {
            return true;
        }

        private Account[] getAccounts() {
            return Preferences.getPreferences(mContext).getAccounts();
        }
    }
}
",True,144,0,0,6,51,1,6,L1
72,com.fsck.k9.activity.setup.FolderSettings.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.util.Log;
import android.view.KeyEvent;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9PreferenceActivity;
import com.fsck.k9.mail.Folder.FolderClass;
import com.fsck.k9.mail.Folder.OpenMode;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import com.fsck.k9.service.MailService;

public class FolderSettings extends K9PreferenceActivity {

    private static final String EXTRA_FOLDER_NAME = ""com.fsck.k9.folderName"";
    private static final String EXTRA_ACCOUNT = ""com.fsck.k9.account"";

    private static final String PREFERENCE_TOP_CATERGORY = ""folder_settings"";
    private static final String PREFERENCE_DISPLAY_CLASS = ""folder_settings_folder_display_mode"";
    private static final String PREFERENCE_SYNC_CLASS = ""folder_settings_folder_sync_mode"";
    private static final String PREFERENCE_PUSH_CLASS = ""folder_settings_folder_push_mode"";
    private static final String PREFERENCE_IN_TOP_GROUP = ""folder_settings_in_top_group"";
    private static final String PREFERENCE_INTEGRATE = ""folder_settings_include_in_integrated_inbox"";

    private LocalFolder mFolder;

    private CheckBoxPreference mInTopGroup;
    private CheckBoxPreference mIntegrate;
    private ListPreference mDisplayClass;
    private ListPreference mSyncClass;
    private ListPreference mPushClass;

    public static void actionSettings(Context context, Account account, String folderName) {
        Intent i = new Intent(context, FolderSettings.class);
        i.putExtra(EXTRA_FOLDER_NAME, folderName);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        String folderName = (String)getIntent().getSerializableExtra(EXTRA_FOLDER_NAME);
        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        Account mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        try {
            LocalStore localStore = mAccount.getLocalStore();
            mFolder = localStore.getFolder(folderName);
            mFolder.open(OpenMode.READ_WRITE);
        } catch (MessagingException me) {
            Log.e(K9.LOG_TAG, ""Unable to edit folder "" + folderName + "" preferences"", me);
            return;
        }

        boolean isPushCapable = false;
        Store store = null;
        try {
            store = mAccount.getRemoteStore();
            isPushCapable = store.isPushCapable();
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Could not get remote store"", e);
        }

        addPreferencesFromResource(R.xml.folder_settings_preferences);

        Preference category = findPreference(PREFERENCE_TOP_CATERGORY);
        category.setTitle(folderName);


        mInTopGroup = (CheckBoxPreference)findPreference(PREFERENCE_IN_TOP_GROUP);
        mInTopGroup.setChecked(mFolder.isInTopGroup());
        mIntegrate = (CheckBoxPreference)findPreference(PREFERENCE_INTEGRATE);
        mIntegrate.setChecked(mFolder.isIntegrate());

        mDisplayClass = (ListPreference) findPreference(PREFERENCE_DISPLAY_CLASS);
        mDisplayClass.setValue(mFolder.getDisplayClass().name());
        mDisplayClass.setSummary(mDisplayClass.getEntry());
        mDisplayClass.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mDisplayClass.findIndexOfValue(summary);
                mDisplayClass.setSummary(mDisplayClass.getEntries()[index]);
                mDisplayClass.setValue(summary);
                return false;
            }
        });

        mSyncClass = (ListPreference) findPreference(PREFERENCE_SYNC_CLASS);
        mSyncClass.setValue(mFolder.getRawSyncClass().name());
        mSyncClass.setSummary(mSyncClass.getEntry());
        mSyncClass.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mSyncClass.findIndexOfValue(summary);
                mSyncClass.setSummary(mSyncClass.getEntries()[index]);
                mSyncClass.setValue(summary);
                return false;
            }
        });

        mPushClass = (ListPreference) findPreference(PREFERENCE_PUSH_CLASS);
        mPushClass.setEnabled(isPushCapable);
        mPushClass.setValue(mFolder.getRawPushClass().name());
        mPushClass.setSummary(mPushClass.getEntry());
        mPushClass.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mPushClass.findIndexOfValue(summary);
                mPushClass.setSummary(mPushClass.getEntries()[index]);
                mPushClass.setValue(summary);
                return false;
            }
        });
    }

    @Override
    public void onResume() {
        super.onResume();
    }

    private void saveSettings() throws MessagingException {
        mFolder.setInTopGroup(mInTopGroup.isChecked());
        mFolder.setIntegrate(mIntegrate.isChecked());
        // We call getPushClass() because display class changes can affect push class when push class is set to inherit
        FolderClass oldPushClass = mFolder.getPushClass();
        FolderClass oldDisplayClass = mFolder.getDisplayClass();
        mFolder.setDisplayClass(FolderClass.valueOf(mDisplayClass.getValue()));
        mFolder.setSyncClass(FolderClass.valueOf(mSyncClass.getValue()));
        mFolder.setPushClass(FolderClass.valueOf(mPushClass.getValue()));

        mFolder.save();

        FolderClass newPushClass = mFolder.getPushClass();
        FolderClass newDisplayClass = mFolder.getDisplayClass();

        if (oldPushClass != newPushClass
                || (newPushClass != FolderClass.NO_CLASS && oldDisplayClass != newDisplayClass)) {
            MailService.actionRestartPushers(getApplication(), null);
        }
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            try {
                saveSettings();
            } catch (MessagingException e) {
                Log.e(K9.LOG_TAG, ""Saving folder settings failed "" + e);
            }
        }
        return super.onKeyDown(keyCode, event);
    }


}
",True,144,0,0,6,50,2,9,L1
73,com.fsck.k9.activity.setup.AccountSetupOptions.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.Spinner;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9Activity;
import com.fsck.k9.mail.Store;

public class AccountSetupOptions extends K9Activity implements OnClickListener {
    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_MAKE_DEFAULT = ""makeDefault"";

    private Spinner mCheckFrequencyView;

    private Spinner mDisplayCountView;


    private CheckBox mNotifyView;
    private CheckBox mNotifySyncView;
    private CheckBox mPushEnable;

    private Account mAccount;

    public static void actionOptions(Context context, Account account, boolean makeDefault) {
        Intent i = new Intent(context, AccountSetupOptions.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_options);

        mCheckFrequencyView = (Spinner)findViewById(R.id.account_check_frequency);
        mDisplayCountView = (Spinner)findViewById(R.id.account_display_count);
        mNotifyView = (CheckBox)findViewById(R.id.account_notify);
        mNotifySyncView = (CheckBox)findViewById(R.id.account_notify_sync);
        mPushEnable = (CheckBox)findViewById(R.id.account_enable_push);

        findViewById(R.id.next).setOnClickListener(this);

        SpinnerOption checkFrequencies[] = {
            new SpinnerOption(-1,
            getString(R.string.account_setup_options_mail_check_frequency_never)),
            new SpinnerOption(1,
            getString(R.string.account_setup_options_mail_check_frequency_1min)),
            new SpinnerOption(5,
            getString(R.string.account_setup_options_mail_check_frequency_5min)),
            new SpinnerOption(10,
            getString(R.string.account_setup_options_mail_check_frequency_10min)),
            new SpinnerOption(15,
            getString(R.string.account_setup_options_mail_check_frequency_15min)),
            new SpinnerOption(30,
            getString(R.string.account_setup_options_mail_check_frequency_30min)),
            new SpinnerOption(60,
            getString(R.string.account_setup_options_mail_check_frequency_1hour)),
            new SpinnerOption(120,
            getString(R.string.account_setup_options_mail_check_frequency_2hour)),
            new SpinnerOption(180,
            getString(R.string.account_setup_options_mail_check_frequency_3hour)),
            new SpinnerOption(360,
            getString(R.string.account_setup_options_mail_check_frequency_6hour)),
            new SpinnerOption(720,
            getString(R.string.account_setup_options_mail_check_frequency_12hour)),
            new SpinnerOption(1440,
            getString(R.string.account_setup_options_mail_check_frequency_24hour)),

        };

        ArrayAdapter<SpinnerOption> checkFrequenciesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, checkFrequencies);
        checkFrequenciesAdapter
        .setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mCheckFrequencyView.setAdapter(checkFrequenciesAdapter);

        SpinnerOption displayCounts[] = {
            new SpinnerOption(10, getString(R.string.account_setup_options_mail_display_count_10)),
            new SpinnerOption(25, getString(R.string.account_setup_options_mail_display_count_25)),
            new SpinnerOption(50, getString(R.string.account_setup_options_mail_display_count_50)),
            new SpinnerOption(100, getString(R.string.account_setup_options_mail_display_count_100)),
            new SpinnerOption(250, getString(R.string.account_setup_options_mail_display_count_250)),
            new SpinnerOption(500, getString(R.string.account_setup_options_mail_display_count_500)),
            new SpinnerOption(1000, getString(R.string.account_setup_options_mail_display_count_1000)),
        };

        ArrayAdapter<SpinnerOption> displayCountsAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, displayCounts);
        displayCountsAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mDisplayCountView.setAdapter(displayCountsAdapter);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        mNotifyView.setChecked(mAccount.isNotifyNewMail());
        mNotifySyncView.setChecked(mAccount.isShowOngoing());
        SpinnerOption.setSpinnerOptionValue(mCheckFrequencyView, mAccount
                                            .getAutomaticCheckIntervalMinutes());
        SpinnerOption.setSpinnerOptionValue(mDisplayCountView, mAccount
                                            .getDisplayCount());


        boolean isPushCapable = false;
        try {
            Store store = mAccount.getRemoteStore();
            isPushCapable = store.isPushCapable();
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Could not get remote store"", e);
        }


        if (!isPushCapable) {
            mPushEnable.setVisibility(View.GONE);
        } else {
            mPushEnable.setChecked(true);
        }


    }

    private void onDone() {
        mAccount.setDescription(mAccount.getEmail());
        mAccount.setNotifyNewMail(mNotifyView.isChecked());
        mAccount.setShowOngoing(mNotifySyncView.isChecked());
        mAccount.setAutomaticCheckIntervalMinutes((Integer)((SpinnerOption)mCheckFrequencyView
                .getSelectedItem()).value);
        mAccount.setDisplayCount((Integer)((SpinnerOption)mDisplayCountView
                                           .getSelectedItem()).value);

        if (mPushEnable.isChecked()) {
            mAccount.setFolderPushMode(Account.FolderMode.FIRST_CLASS);
        } else {
            mAccount.setFolderPushMode(Account.FolderMode.NONE);
        }

        mAccount.save(Preferences.getPreferences(this));
        if (mAccount.equals(Preferences.getPreferences(this).getDefaultAccount()) ||
                getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false)) {
            Preferences.getPreferences(this).setDefaultAccount(mAccount);
        }
        K9.setServicesEnabled(this);
        AccountSetupNames.actionSetNames(this, mAccount);
        finish();
    }

    public void onClick(View v) {
        switch (v.getId()) {
        case R.id.next:
            onDone();
            break;
        }
    }
}
",True,144,0,0,6,54,1,7,L1
74,com.fsck.k9.activity.setup.Prefs.java,"package com.fsck.k9.activity.setup;

import java.io.File;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Vector;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.preference.Preference.OnPreferenceClickListener;
import android.view.KeyEvent;
import android.widget.Toast;

import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.activity.Accounts;
import com.fsck.k9.activity.ColorPickerDialog;
import com.fsck.k9.activity.K9PreferenceActivity;
import com.fsck.k9.helper.DateFormatter;
import com.fsck.k9.helper.FileBrowserHelper;
import com.fsck.k9.helper.FileBrowserHelper.FileBrowserFailOverCallback;
import com.fsck.k9.preferences.CheckBoxListPreference;
import com.fsck.k9.preferences.TimePickerPreference;

import com.fsck.k9.service.MailService;


public class Prefs extends K9PreferenceActivity {

    /**
     * Immutable empty {@link CharSequence} array
     */
    private static final CharSequence[] EMPTY_CHAR_SEQUENCE_ARRAY = new CharSequence[0];

    /*
     * Keys of the preferences defined in res/xml/global_preferences.xml
     */
    private static final String PREFERENCE_LANGUAGE = ""language"";
    private static final String PREFERENCE_THEME = ""theme"";
    private static final String PREFERENCE_FONT_SIZE = ""font_size"";
    private static final String PREFERENCE_DATE_FORMAT = ""dateFormat"";
    private static final String PREFERENCE_ANIMATIONS = ""animations"";
    private static final String PREFERENCE_GESTURES = ""gestures"";
    private static final String PREFERENCE_VOLUME_NAVIGATION = ""volumeNavigation"";
    private static final String PREFERENCE_MANAGE_BACK = ""manage_back"";
    private static final String PREFERENCE_START_INTEGRATED_INBOX = ""start_integrated_inbox"";
    private static final String PREFERENCE_CONFIRM_ACTIONS = ""confirm_actions"";
    private static final String PREFERENCE_PRIVACY_MODE = ""privacy_mode"";
    private static final String PREFERENCE_MEASURE_ACCOUNTS = ""measure_accounts"";
    private static final String PREFERENCE_COUNT_SEARCH = ""count_search"";
    private static final String PREFERENCE_HIDE_SPECIAL_ACCOUNTS = ""hide_special_accounts"";
    private static final String PREFERENCE_MESSAGELIST_TOUCHABLE = ""messagelist_touchable"";
    private static final String PREFERENCE_MESSAGELIST_PREVIEW_LINES = ""messagelist_preview_lines"";
    private static final String PREFERENCE_MESSAGELIST_STARS = ""messagelist_stars"";
    private static final String PREFERENCE_MESSAGELIST_CHECKBOXES = ""messagelist_checkboxes"";
    private static final String PREFERENCE_MESSAGELIST_SHOW_CORRESPONDENT_NAMES = ""messagelist_show_correspondent_names"";
    private static final String PREFERENCE_MESSAGELIST_SHOW_CONTACT_NAME = ""messagelist_show_contact_name"";
    private static final String PREFERENCE_MESSAGELIST_CONTACT_NAME_COLOR = ""messagelist_contact_name_color"";
    private static final String PREFERENCE_MESSAGEVIEW_FIXEDWIDTH = ""messageview_fixedwidth_font"";
    private static final String PREFERENCE_COMPACT_LAYOUTS = ""compact_layouts"";

    private static final String PREFERENCE_MESSAGEVIEW_RETURN_TO_LIST = ""messageview_return_to_list"";
    private static final String PREFERENCE_MESSAGEVIEW_ZOOM_CONTROLS_ENABLED = ""messageview_zoom_controls"";
    private static final String PREFERENCE_QUIET_TIME_ENABLED = ""quiet_time_enabled"";
    private static final String PREFERENCE_QUIET_TIME_STARTS = ""quiet_time_starts"";
    private static final String PREFERENCE_QUIET_TIME_ENDS = ""quiet_time_ends"";


    private static final String PREFERENCE_MESSAGEVIEW_MOBILE_LAYOUT = ""messageview_mobile_layout"";
    private static final String PREFERENCE_BACKGROUND_OPS = ""background_ops"";
    private static final String PREFERENCE_GALLERY_BUG_WORKAROUND = ""use_gallery_bug_workaround"";
    private static final String PREFERENCE_DEBUG_LOGGING = ""debug_logging"";
    private static final String PREFERENCE_SENSITIVE_LOGGING = ""sensitive_logging"";

    private static final String PREFERENCE_ATTACHMENT_DEF_PATH = ""attachment_default_path"";

    private static final int ACTIVITY_CHOOSE_FOLDER = 1;
    private ListPreference mLanguage;
    private ListPreference mTheme;
    private ListPreference mDateFormat;
    private CheckBoxPreference mAnimations;
    private CheckBoxPreference mGestures;
    private CheckBoxListPreference mVolumeNavigation;
    private CheckBoxPreference mManageBack;
    private CheckBoxPreference mStartIntegratedInbox;
    private CheckBoxListPreference mConfirmActions;
    private CheckBoxPreference mPrivacyMode;
    private CheckBoxPreference mMeasureAccounts;
    private CheckBoxPreference mCountSearch;
    private CheckBoxPreference mHideSpecialAccounts;
    private CheckBoxPreference mTouchable;
    private ListPreference mPreviewLines;
    private CheckBoxPreference mStars;
    private CheckBoxPreference mCheckboxes;
    private CheckBoxPreference mShowCorrespondentNames;
    private CheckBoxPreference mShowContactName;
    private CheckBoxPreference mChangeContactNameColor;
    private CheckBoxPreference mFixedWidth;
    private CheckBoxPreference mReturnToList;
    private CheckBoxPreference mZoomControlsEnabled;
    private CheckBoxPreference mMobileOptimizedLayout;
    private ListPreference mBackgroundOps;
    private CheckBoxPreference mUseGalleryBugWorkaround;
    private CheckBoxPreference mDebugLogging;
    private CheckBoxPreference mSensitiveLogging;
    private CheckBoxPreference compactLayouts;

    private CheckBoxPreference mQuietTimeEnabled;
    private com.fsck.k9.preferences.TimePickerPreference mQuietTimeStarts;
    private com.fsck.k9.preferences.TimePickerPreference mQuietTimeEnds;
    private Preference mAttachmentPathPreference;


    public static void actionPrefs(Context context) {
        Intent i = new Intent(context, Prefs.class);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        addPreferencesFromResource(R.xml.global_preferences);

        mLanguage = (ListPreference) findPreference(PREFERENCE_LANGUAGE);
        Vector<CharSequence> entryVector = new Vector<CharSequence>(Arrays.asList(mLanguage.getEntries()));
        Vector<CharSequence> entryValueVector = new Vector<CharSequence>(Arrays.asList(mLanguage.getEntryValues()));
        String supportedLanguages[] = getResources().getStringArray(R.array.supported_languages);
        HashSet<String> supportedLanguageSet = new HashSet<String>(Arrays.asList(supportedLanguages));
        for (int i = entryVector.size() - 1; i > -1; --i) {
            if (!supportedLanguageSet.contains(entryValueVector.get(i))) {
                entryVector.remove(i);
                entryValueVector.remove(i);
            }
        }
        initListPreference(mLanguage, K9.getK9Language(),
                           entryVector.toArray(EMPTY_CHAR_SEQUENCE_ARRAY),
                           entryValueVector.toArray(EMPTY_CHAR_SEQUENCE_ARRAY));

        final String theme = (K9.getK9Theme() == android.R.style.Theme) ? ""dark"" : ""light"";
        mTheme = setupListPreference(PREFERENCE_THEME, theme);

        findPreference(PREFERENCE_FONT_SIZE).setOnPreferenceClickListener(
        new Preference.OnPreferenceClickListener() {
            public boolean onPreferenceClick(Preference preference) {
                onFontSizeSettings();
                return true;
            }
        });

        mDateFormat = (ListPreference) findPreference(PREFERENCE_DATE_FORMAT);
        String[] formats = DateFormatter.getFormats(this);
        CharSequence[] entries = new CharSequence[formats.length];
        CharSequence[] values = new CharSequence[formats.length];
        for (int i = 0 ; i < formats.length; i++) {
            String format = formats[i];
            entries[i] = DateFormatter.getSampleDate(this, format);
            values[i] = format;
        }
        initListPreference(mDateFormat, DateFormatter.getFormat(this), entries, values);

        mAnimations = (CheckBoxPreference)findPreference(PREFERENCE_ANIMATIONS);
        mAnimations.setChecked(K9.showAnimations());

        mGestures = (CheckBoxPreference)findPreference(PREFERENCE_GESTURES);
        mGestures.setChecked(K9.gesturesEnabled());

        compactLayouts = (CheckBoxPreference)findPreference(PREFERENCE_COMPACT_LAYOUTS);
        compactLayouts.setChecked(K9.useCompactLayouts());

        mVolumeNavigation = (CheckBoxListPreference)findPreference(PREFERENCE_VOLUME_NAVIGATION);
        mVolumeNavigation.setItems(new CharSequence[] {getString(R.string.volume_navigation_message), getString(R.string.volume_navigation_list)});
        mVolumeNavigation.setCheckedItems(new boolean[] {K9.useVolumeKeysForNavigationEnabled(), K9.useVolumeKeysForListNavigationEnabled()});

        mManageBack = (CheckBoxPreference)findPreference(PREFERENCE_MANAGE_BACK);
        mManageBack.setChecked(K9.manageBack());

        mStartIntegratedInbox = (CheckBoxPreference)findPreference(PREFERENCE_START_INTEGRATED_INBOX);
        mStartIntegratedInbox.setChecked(K9.startIntegratedInbox());

        mConfirmActions = (CheckBoxListPreference) findPreference(PREFERENCE_CONFIRM_ACTIONS);
        mConfirmActions.setItems(new CharSequence[] {
                                     getString(R.string.global_settings_confirm_action_delete),
                                     getString(R.string.global_settings_confirm_action_spam),
                                     getString(R.string.global_settings_confirm_action_mark_all_as_read)
                                 });
        mConfirmActions.setCheckedItems(new boolean[] {
                                            K9.confirmDelete(),
                                            K9.confirmSpam(),
                                            K9.confirmMarkAllAsRead()
                                        });

        mPrivacyMode = (CheckBoxPreference) findPreference(PREFERENCE_PRIVACY_MODE);
        mPrivacyMode.setChecked(K9.keyguardPrivacy());

        mMeasureAccounts = (CheckBoxPreference)findPreference(PREFERENCE_MEASURE_ACCOUNTS);
        mMeasureAccounts.setChecked(K9.measureAccounts());

        mCountSearch = (CheckBoxPreference)findPreference(PREFERENCE_COUNT_SEARCH);
        mCountSearch.setChecked(K9.countSearchMessages());

        mHideSpecialAccounts = (CheckBoxPreference)findPreference(PREFERENCE_HIDE_SPECIAL_ACCOUNTS);
        mHideSpecialAccounts.setChecked(K9.isHideSpecialAccounts());

        mTouchable = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGELIST_TOUCHABLE);
        mTouchable.setChecked(K9.messageListTouchable());

        mPreviewLines = setupListPreference(PREFERENCE_MESSAGELIST_PREVIEW_LINES,
                                            Integer.toString(K9.messageListPreviewLines()));

        mStars = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGELIST_STARS);
        mStars.setChecked(K9.messageListStars());

        mCheckboxes = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGELIST_CHECKBOXES);
        mCheckboxes.setChecked(K9.messageListCheckboxes());

        mShowCorrespondentNames = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGELIST_SHOW_CORRESPONDENT_NAMES);
        mShowCorrespondentNames.setChecked(K9.showCorrespondentNames());

        mShowContactName = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGELIST_SHOW_CONTACT_NAME);
        mShowContactName.setChecked(K9.showContactName());

        mChangeContactNameColor = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGELIST_CONTACT_NAME_COLOR);
        mChangeContactNameColor.setChecked(K9.changeContactNameColor());
        if (K9.changeContactNameColor()) {
            mChangeContactNameColor.setSummary(R.string.global_settings_registered_name_color_changed);
        } else {
            mChangeContactNameColor.setSummary(R.string.global_settings_registered_name_color_default);
        }
        mChangeContactNameColor.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final Boolean checked = (Boolean) newValue;
                if (checked) {
                    onChooseContactNameColor();
                    mChangeContactNameColor.setSummary(R.string.global_settings_registered_name_color_changed);
                } else {
                    mChangeContactNameColor.setSummary(R.string.global_settings_registered_name_color_default);
                }
                mChangeContactNameColor.setChecked(checked);
                return false;
            }
        });

        mFixedWidth = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGEVIEW_FIXEDWIDTH);
        mFixedWidth.setChecked(K9.messageViewFixedWidthFont());

        mReturnToList = (CheckBoxPreference) findPreference(PREFERENCE_MESSAGEVIEW_RETURN_TO_LIST);
        mReturnToList.setChecked(K9.messageViewReturnToList());

        mZoomControlsEnabled = (CheckBoxPreference) findPreference(PREFERENCE_MESSAGEVIEW_ZOOM_CONTROLS_ENABLED);
        mZoomControlsEnabled.setChecked(K9.zoomControlsEnabled());

        mMobileOptimizedLayout = (CheckBoxPreference) findPreference(PREFERENCE_MESSAGEVIEW_MOBILE_LAYOUT);
        if (Integer.parseInt(Build.VERSION.SDK)  <= 7) {
            mMobileOptimizedLayout.setEnabled(false);
        }


        mMobileOptimizedLayout.setChecked(K9.mobileOptimizedLayout());

        mQuietTimeEnabled = (CheckBoxPreference) findPreference(PREFERENCE_QUIET_TIME_ENABLED);
        mQuietTimeEnabled.setChecked(K9.getQuietTimeEnabled());

        mQuietTimeStarts = (TimePickerPreference) findPreference(PREFERENCE_QUIET_TIME_STARTS);
        mQuietTimeStarts.setDefaultValue(K9.getQuietTimeStarts());
        mQuietTimeStarts.setSummary(K9.getQuietTimeStarts());
        mQuietTimeStarts.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String time = (String) newValue;
                mQuietTimeStarts.setSummary(time);
                return false;
            }
        });

        mQuietTimeEnds = (TimePickerPreference) findPreference(PREFERENCE_QUIET_TIME_ENDS);
        mQuietTimeEnds.setSummary(K9.getQuietTimeEnds());
        mQuietTimeEnds.setDefaultValue(K9.getQuietTimeEnds());
        mQuietTimeEnds.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String time = (String) newValue;
                mQuietTimeEnds.setSummary(time);
                return false;
            }
        });




        mBackgroundOps = setupListPreference(PREFERENCE_BACKGROUND_OPS, K9.getBackgroundOps().toString());

        mUseGalleryBugWorkaround = (CheckBoxPreference)findPreference(PREFERENCE_GALLERY_BUG_WORKAROUND);
        mUseGalleryBugWorkaround.setChecked(K9.useGalleryBugWorkaround());

        mDebugLogging = (CheckBoxPreference)findPreference(PREFERENCE_DEBUG_LOGGING);
        mSensitiveLogging = (CheckBoxPreference)findPreference(PREFERENCE_SENSITIVE_LOGGING);

        mDebugLogging.setChecked(K9.DEBUG);
        mSensitiveLogging.setChecked(K9.DEBUG_SENSITIVE);

        mAttachmentPathPreference = findPreference(PREFERENCE_ATTACHMENT_DEF_PATH);
        mAttachmentPathPreference.setSummary(K9.getAttachmentDefaultPath());
        mAttachmentPathPreference
        .setOnPreferenceClickListener(new OnPreferenceClickListener() {
            @Override
            public boolean onPreferenceClick(Preference preference) {
                FileBrowserHelper
                .getInstance()
                .showFileBrowserActivity(Prefs.this,
                                         new File(K9.getAttachmentDefaultPath()),
                                         ACTIVITY_CHOOSE_FOLDER, callback);

                return true;
            }

            FileBrowserFailOverCallback callback = new FileBrowserFailOverCallback() {

                @Override
                public void onPathEntered(String path) {
                    mAttachmentPathPreference.setSummary(path);
                    K9.setAttachmentDefaultPath(path);
                }

                @Override
                public void onCancel() {
                    // canceled, do nothing
                }
            };
        });
    }

    private void saveSettings() {
        SharedPreferences preferences = Preferences.getPreferences(this).getPreferences();

        K9.setK9Language(mLanguage.getValue());
        K9.setK9Theme(mTheme.getValue().equals(""dark"") ? android.R.style.Theme : android.R.style.Theme_Light);
        K9.setAnimations(mAnimations.isChecked());
        K9.setGesturesEnabled(mGestures.isChecked());
        K9.setCompactLayouts(compactLayouts.isChecked());
        K9.setUseVolumeKeysForNavigation(mVolumeNavigation.getCheckedItems()[0]);
        K9.setUseVolumeKeysForListNavigation(mVolumeNavigation.getCheckedItems()[1]);
        K9.setManageBack(mManageBack.isChecked());
        K9.setStartIntegratedInbox(!mHideSpecialAccounts.isChecked() && mStartIntegratedInbox.isChecked());
        K9.setConfirmDelete(mConfirmActions.getCheckedItems()[0]);
        K9.setConfirmSpam(mConfirmActions.getCheckedItems()[1]);
        K9.setConfirmMarkAllAsRead(mConfirmActions.getCheckedItems()[2]);
        K9.setKeyguardPrivacy(mPrivacyMode.isChecked());
        K9.setMeasureAccounts(mMeasureAccounts.isChecked());
        K9.setCountSearchMessages(mCountSearch.isChecked());
        K9.setHideSpecialAccounts(mHideSpecialAccounts.isChecked());
        K9.setMessageListTouchable(mTouchable.isChecked());
        K9.setMessageListPreviewLines(Integer.parseInt(mPreviewLines.getValue()));
        K9.setMessageListStars(mStars.isChecked());
        K9.setMessageListCheckboxes(mCheckboxes.isChecked());
        K9.setShowCorrespondentNames(mShowCorrespondentNames.isChecked());
        K9.setShowContactName(mShowContactName.isChecked());
        K9.setChangeContactNameColor(mChangeContactNameColor.isChecked());
        K9.setMessageViewFixedWidthFont(mFixedWidth.isChecked());
        K9.setMessageViewReturnToList(mReturnToList.isChecked());
        K9.setMobileOptimizedLayout(mMobileOptimizedLayout.isChecked());
        K9.setQuietTimeEnabled(mQuietTimeEnabled.isChecked());

        K9.setQuietTimeStarts(mQuietTimeStarts.getTime());
        K9.setQuietTimeEnds(mQuietTimeEnds.getTime());


        K9.setZoomControlsEnabled(mZoomControlsEnabled.isChecked());
        K9.setAttachmentDefaultPath(mAttachmentPathPreference.getSummary().toString());
        boolean needsRefresh = K9.setBackgroundOps(mBackgroundOps.getValue());
        K9.setUseGalleryBugWorkaround(mUseGalleryBugWorkaround.isChecked());

        if (!K9.DEBUG && mDebugLogging.isChecked()) {
            Toast.makeText(this, R.string.debug_logging_enabled, Toast.LENGTH_LONG).show();
        }
        K9.DEBUG = mDebugLogging.isChecked();
        K9.DEBUG_SENSITIVE = mSensitiveLogging.isChecked();

        Editor editor = preferences.edit();
        K9.save(editor);
        DateFormatter.setDateFormat(editor, mDateFormat.getValue());
        editor.commit();

        if (needsRefresh) {
            MailService.actionReset(this, null);
        }
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            saveSettings();
            if (K9.manageBack()) {
                Accounts.listAccounts(this);
                finish();
                return true;
            }
        }
        return super.onKeyDown(keyCode, event);
    }

    private void onFontSizeSettings() {
        FontSizeSettings.actionEditSettings(this);
    }

    private void onChooseContactNameColor() {
        new ColorPickerDialog(this, new ColorPickerDialog.OnColorChangedListener() {
            public void colorChanged(int color) {
                K9.setContactNameColor(color);
            }
        },
        K9.getContactNameColor()).show();
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
        case ACTIVITY_CHOOSE_FOLDER:
            if (resultCode == RESULT_OK && data != null) {
                // obtain the filename
                Uri fileUri = data.getData();
                if (fileUri != null) {
                    String filePath = fileUri.getPath();
                    if (filePath != null) {
                        mAttachmentPathPreference.setSummary(filePath.toString());
                        K9.setAttachmentDefaultPath(filePath.toString());
                    }
                }
            }
            break;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }
}
",True,144,0,0,6,57,3,11,L1
75,com.fsck.k9.activity.setup.FontSizeSettings.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Bundle;
import android.preference.*;
import android.view.KeyEvent;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9PreferenceActivity;

/**
 * Activity to configure the font size of the information displayed in the
 * account list, folder list, message list and in the message view.
 *
 * @see FontSizes
 */
public class FontSizeSettings extends K9PreferenceActivity {
    /*
     * Keys of the preferences defined in res/xml/font_preferences.xml
     */
    private static final String PREFERENCE_ACCOUNT_NAME_FONT = ""account_name_font"";
    private static final String PREFERENCE_ACCOUNT_DESCRIPTION_FONT = ""account_description_font"";
    private static final String PREFERENCE_FOLDER_NAME_FONT = ""folder_name_font"";
    private static final String PREFERENCE_FOLDER_STATUS_FONT = ""folder_status_font"";
    private static final String PREFERENCE_MESSAGE_LIST_SUBJECT_FONT = ""message_list_subject_font"";
    private static final String PREFERENCE_MESSAGE_LIST_SENDER_FONT = ""message_list_sender_font"";
    private static final String PREFERENCE_MESSAGE_LIST_DATE_FONT = ""message_list_date_font"";
    private static final String PREFERENCE_MESSAGE_LIST_PREVIEW_FONT = ""message_list_preview_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_SENDER_FONT = ""message_view_sender_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_TO_FONT = ""message_view_to_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_CC_FONT = ""message_view_cc_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_ADDITIONAL_HEADERS_FONT = ""message_view_additional_headers_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_SUBJECT_FONT = ""message_view_subject_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_TIME_FONT = ""message_view_time_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_DATE_FONT = ""message_view_date_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_CONTENT_FONT = ""message_view_content_font"";

    private ListPreference mAccountName;
    private ListPreference mAccountDescription;
    private ListPreference mFolderName;
    private ListPreference mFolderStatus;
    private ListPreference mMessageListSubject;
    private ListPreference mMessageListSender;
    private ListPreference mMessageListDate;
    private ListPreference mMessageListPreview;
    private ListPreference mMessageViewSender;
    private ListPreference mMessageViewTo;
    private ListPreference mMessageViewCC;
    private ListPreference mMessageViewAdditionalHeaders;
    private ListPreference mMessageViewSubject;
    private ListPreference mMessageViewTime;
    private ListPreference mMessageViewDate;
    private ListPreference mMessageViewContent;


    /**
     * Start the FontSizeSettings activity.
     *
     * @param context The application context.
     */
    public static void actionEditSettings(Context context) {
        Intent i = new Intent(context, FontSizeSettings.class);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        FontSizes fontSizes = K9.getFontSizes();
        addPreferencesFromResource(R.xml.font_preferences);

        mAccountName = setupListPreference(
                           PREFERENCE_ACCOUNT_NAME_FONT,
                           Integer.toString(fontSizes.getAccountName()));
        mAccountDescription = setupListPreference(
                                  PREFERENCE_ACCOUNT_DESCRIPTION_FONT,
                                  Integer.toString(fontSizes.getAccountDescription()));

        mFolderName = setupListPreference(
                          PREFERENCE_FOLDER_NAME_FONT,
                          Integer.toString(fontSizes.getFolderName()));
        mFolderStatus = setupListPreference(
                            PREFERENCE_FOLDER_STATUS_FONT,
                            Integer.toString(fontSizes.getFolderStatus()));

        mMessageListSubject = setupListPreference(
                                  PREFERENCE_MESSAGE_LIST_SUBJECT_FONT,
                                  Integer.toString(fontSizes.getMessageListSubject()));
        mMessageListSender = setupListPreference(
                                 PREFERENCE_MESSAGE_LIST_SENDER_FONT,
                                 Integer.toString(fontSizes.getMessageListSender()));
        mMessageListDate = setupListPreference(
                               PREFERENCE_MESSAGE_LIST_DATE_FONT,
                               Integer.toString(fontSizes.getMessageListDate()));
        mMessageListPreview = setupListPreference(
                                  PREFERENCE_MESSAGE_LIST_PREVIEW_FONT,
                                  Integer.toString(fontSizes.getMessageListPreview()));

        mMessageViewSender = setupListPreference(
                                 PREFERENCE_MESSAGE_VIEW_SENDER_FONT,
                                 Integer.toString(fontSizes.getMessageViewSender()));
        mMessageViewTo = setupListPreference(
                             PREFERENCE_MESSAGE_VIEW_TO_FONT,
                             Integer.toString(fontSizes.getMessageViewTo()));
        mMessageViewCC = setupListPreference(
                             PREFERENCE_MESSAGE_VIEW_CC_FONT,
                             Integer.toString(fontSizes.getMessageViewCC()));
        mMessageViewAdditionalHeaders = setupListPreference(
                                            PREFERENCE_MESSAGE_VIEW_ADDITIONAL_HEADERS_FONT,
                                            Integer.toString(fontSizes.getMessageViewAdditionalHeaders()));
        mMessageViewSubject = setupListPreference(
                                  PREFERENCE_MESSAGE_VIEW_SUBJECT_FONT,
                                  Integer.toString(fontSizes.getMessageViewSubject()));
        mMessageViewTime = setupListPreference(
                               PREFERENCE_MESSAGE_VIEW_TIME_FONT,
                               Integer.toString(fontSizes.getMessageViewTime()));
        mMessageViewDate = setupListPreference(
                               PREFERENCE_MESSAGE_VIEW_DATE_FONT,
                               Integer.toString(fontSizes.getMessageViewDate()));
        mMessageViewContent = setupListPreference(
                                  PREFERENCE_MESSAGE_VIEW_CONTENT_FONT,
                                  Integer.toString(fontSizes.getMessageViewContentAsInt()));
    }

    /**
     * Update the global FontSize object and permanently store the (possibly
     * changed) font size settings.
     */
    private void saveSettings() {
        FontSizes fontSizes = K9.getFontSizes();

        fontSizes.setAccountName(Integer.parseInt(mAccountName.getValue()));
        fontSizes.setAccountDescription(Integer.parseInt(mAccountDescription.getValue()));

        fontSizes.setFolderName(Integer.parseInt(mFolderName.getValue()));
        fontSizes.setFolderStatus(Integer.parseInt(mFolderStatus.getValue()));

        fontSizes.setMessageListSubject(Integer.parseInt(mMessageListSubject.getValue()));
        fontSizes.setMessageListSender(Integer.parseInt(mMessageListSender.getValue()));
        fontSizes.setMessageListDate(Integer.parseInt(mMessageListDate.getValue()));
        fontSizes.setMessageListPreview(Integer.parseInt(mMessageListPreview.getValue()));

        fontSizes.setMessageViewSender(Integer.parseInt(mMessageViewSender.getValue()));
        fontSizes.setMessageViewTo(Integer.parseInt(mMessageViewTo.getValue()));
        fontSizes.setMessageViewCC(Integer.parseInt(mMessageViewCC.getValue()));
        fontSizes.setMessageViewAdditionalHeaders(Integer.parseInt(mMessageViewAdditionalHeaders.getValue()));
        fontSizes.setMessageViewSubject(Integer.parseInt(mMessageViewSubject.getValue()));
        fontSizes.setMessageViewTime(Integer.parseInt(mMessageViewTime.getValue()));
        fontSizes.setMessageViewDate(Integer.parseInt(mMessageViewDate.getValue()));
        fontSizes.setMessageViewContent(Integer.parseInt(mMessageViewContent.getValue()));

        SharedPreferences preferences = Preferences.getPreferences(this).getPreferences();
        Editor editor = preferences.edit();
        fontSizes.save(editor);
        editor.commit();
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            saveSettings();
        }
        return super.onKeyDown(keyCode, event);
    }
}
",False,144,0,0,7,53,1,4,L1
76,com.fsck.k9.activity.setup.AccountSetupNames.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.text.method.TextKeyListener;
import android.text.method.TextKeyListener.Capitalize;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9Activity;
import com.fsck.k9.helper.Utility;

public class AccountSetupNames extends K9Activity implements OnClickListener {
    private static final String EXTRA_ACCOUNT = ""account"";

    private EditText mDescription;

    private EditText mName;

    private Account mAccount;

    private Button mDoneButton;

    public static void actionSetNames(Context context, Account account) {
        Intent i = new Intent(context, AccountSetupNames.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_names);
        mDescription = (EditText)findViewById(R.id.account_description);
        mName = (EditText)findViewById(R.id.account_name);
        mDoneButton = (Button)findViewById(R.id.done);
        mDoneButton.setOnClickListener(this);

        TextWatcher validationTextWatcher = new TextWatcher() {
            public void afterTextChanged(Editable s) {
                validateFields();
            }

            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
            }

            public void onTextChanged(CharSequence s, int start, int before, int count) {
            }
        };
        mName.addTextChangedListener(validationTextWatcher);

        mName.setKeyListener(TextKeyListener.getInstance(false, Capitalize.WORDS));

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        /*
         * Since this field is considered optional, we don't set this here. If
         * the user fills in a value we'll reset the current value, otherwise we
         * just leave the saved value alone.
         */
        // mDescription.setText(mAccount.getDescription());
        if (mAccount.getName() != null) {
            mName.setText(mAccount.getName());
        }
        if (!Utility.requiredFieldValid(mName)) {
            mDoneButton.setEnabled(false);
        }
    }

    private void validateFields() {
        mDoneButton.setEnabled(Utility.requiredFieldValid(mName));
        Utility.setCompoundDrawablesAlpha(mDoneButton, mDoneButton.isEnabled() ? 255 : 128);
    }

    @Override
    protected void onNext() {
        if (Utility.requiredFieldValid(mDescription)) {
            mAccount.setDescription(mDescription.getText().toString());
        }
        mAccount.setName(mName.getText().toString());
        mAccount.save(Preferences.getPreferences(this));
        finish();
    }

    public void onClick(View v) {
        switch (v.getId()) {
        case R.id.done:
            onNext();
            break;
        }
    }
}
",False,144,0,0,7,40,2,4,L1
77,com.fsck.k9.activity.setup.SpinnerOption.java,"/**
 *
 */

package com.fsck.k9.activity.setup;

import android.widget.Spinner;

public class SpinnerOption {
    public Object value;

    public String label;

    public static void setSpinnerOptionValue(Spinner spinner, Object value) {
        for (int i = 0, count = spinner.getCount(); i < count; i++) {
            SpinnerOption so = (SpinnerOption)spinner.getItemAtPosition(i);
            if (so.value.equals(value)) {
                spinner.setSelection(i, true);
                return;
            }
        }
    }

    public SpinnerOption(Object value, String label) {
        this.value = value;
        this.label = label;
    }

    @Override
    public String toString() {
        return label;
    }
}
",True,113,8,55,0,0,3,0,L1
78,com.fsck.k9.activity.setup.AccountSettings.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Vibrator;
import android.preference.*;
import android.util.Log;
import android.view.KeyEvent;

import java.util.Iterator;
import java.util.Map;
import java.util.LinkedList;
import java.util.List;

import com.fsck.k9.Account;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.Account.QuoteStyle;
import com.fsck.k9.Account.ScrollButtons;
import com.fsck.k9.K9;
import com.fsck.k9.NotificationSetting;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.activity.ChooseFolder;
import com.fsck.k9.activity.ChooseIdentity;
import com.fsck.k9.activity.ColorPickerDialog;
import com.fsck.k9.activity.K9PreferenceActivity;
import com.fsck.k9.activity.ManageIdentities;
import com.fsck.k9.crypto.Apg;
import com.fsck.k9.mail.Store;
import com.fsck.k9.service.MailService;

import com.fsck.k9.mail.store.StorageManager;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;


public class AccountSettings extends K9PreferenceActivity {
    private static final String EXTRA_ACCOUNT = ""account"";

    private static final int SELECT_AUTO_EXPAND_FOLDER = 1;

    private static final int ACTIVITY_MANAGE_IDENTITIES = 2;

    private static final String PREFERENCE_SCREEN_COMPOSING = ""composing"";

    private static final String PREFERENCE_DESCRIPTION = ""account_description"";
    private static final String PREFERENCE_COMPOSITION = ""composition"";
    private static final String PREFERENCE_MANAGE_IDENTITIES = ""manage_identities"";
    private static final String PREFERENCE_FREQUENCY = ""account_check_frequency"";
    private static final String PREFERENCE_DISPLAY_COUNT = ""account_display_count"";
    private static final String PREFERENCE_DEFAULT = ""account_default"";
    private static final String PREFERENCE_HIDE_BUTTONS = ""hide_buttons_enum"";
    private static final String PREFERENCE_HIDE_MOVE_BUTTONS = ""hide_move_buttons_enum"";
    private static final String PREFERENCE_SHOW_PICTURES = ""show_pictures_enum"";
    private static final String PREFERENCE_ENABLE_MOVE_BUTTONS = ""enable_move_buttons"";
    private static final String PREFERENCE_NOTIFY = ""account_notify"";
    private static final String PREFERENCE_NOTIFY_SELF = ""account_notify_self"";
    private static final String PREFERENCE_NOTIFY_SYNC = ""account_notify_sync"";
    private static final String PREFERENCE_VIBRATE = ""account_vibrate"";
    private static final String PREFERENCE_VIBRATE_PATTERN = ""account_vibrate_pattern"";
    private static final String PREFERENCE_VIBRATE_TIMES = ""account_vibrate_times"";
    private static final String PREFERENCE_RINGTONE = ""account_ringtone"";
    private static final String PREFERENCE_NOTIFICATION_LED = ""account_led"";
    private static final String PREFERENCE_INCOMING = ""incoming"";
    private static final String PREFERENCE_OUTGOING = ""outgoing"";
    private static final String PREFERENCE_DISPLAY_MODE = ""folder_display_mode"";
    private static final String PREFERENCE_SYNC_MODE = ""folder_sync_mode"";
    private static final String PREFERENCE_PUSH_MODE = ""folder_push_mode"";
    private static final String PREFERENCE_PUSH_POLL_ON_CONNECT = ""push_poll_on_connect"";
    private static final String PREFERENCE_MAX_PUSH_FOLDERS = ""max_push_folders"";
    private static final String PREFERENCE_IDLE_REFRESH_PERIOD = ""idle_refresh_period"";
    private static final String PREFERENCE_TARGET_MODE = ""folder_target_mode"";
    private static final String PREFERENCE_DELETE_POLICY = ""delete_policy"";
    private static final String PREFERENCE_EXPUNGE_POLICY = ""expunge_policy"";
    private static final String PREFERENCE_AUTO_EXPAND_FOLDER = ""account_setup_auto_expand_folder"";
    private static final String PREFERENCE_SEARCHABLE_FOLDERS = ""searchable_folders"";
    private static final String PREFERENCE_CHIP_COLOR = ""chip_color"";
    private static final String PREFERENCE_LED_COLOR = ""led_color"";
    private static final String PREFERENCE_NOTIFICATION_OPENS_UNREAD = ""notification_opens_unread"";
    private static final String PREFERENCE_NOTIFICATION_UNREAD_COUNT = ""notification_unread_count"";
    private static final String PREFERENCE_MESSAGE_AGE = ""account_message_age"";
    private static final String PREFERENCE_MESSAGE_SIZE = ""account_autodownload_size"";
    private static final String PREFERENCE_SAVE_ALL_HEADERS = ""account_save_all_headers"";
    private static final String PREFERENCE_MESSAGE_FORMAT = ""message_format"";
    private static final String PREFERENCE_QUOTE_PREFIX = ""account_quote_prefix"";
    private static final String PREFERENCE_QUOTE_STYLE = ""quote_style"";
    private static final String PREFERENCE_DEFAULT_QUOTED_TEXT_SHOWN = ""default_quoted_text_shown"";
    private static final String PREFERENCE_REPLY_AFTER_QUOTE = ""reply_after_quote"";
    private static final String PREFERENCE_SYNC_REMOTE_DELETIONS = ""account_sync_remote_deletetions"";
    private static final String PREFERENCE_CRYPTO_APP = ""crypto_app"";
    private static final String PREFERENCE_CRYPTO_AUTO_SIGNATURE = ""crypto_auto_signature"";

    private static final String PREFERENCE_LOCAL_STORAGE_PROVIDER = ""local_storage_provider"";


    private static final String PREFERENCE_ARCHIVE_FOLDER = ""archive_folder"";
    private static final String PREFERENCE_DRAFTS_FOLDER = ""drafts_folder"";
    private static final String PREFERENCE_SENT_FOLDER = ""sent_folder"";
    private static final String PREFERENCE_SPAM_FOLDER = ""spam_folder"";
    private static final String PREFERENCE_TRASH_FOLDER = ""trash_folder"";



    private Account mAccount;
    private boolean mIsMoveCapable = false;
    private boolean mIsPushCapable = false;
    private boolean mIsExpungeCapable = false;

    private PreferenceScreen mComposingScreen;

    private EditTextPreference mAccountDescription;
    private ListPreference mCheckFrequency;
    private ListPreference mDisplayCount;
    private ListPreference mMessageAge;
    private ListPreference mMessageSize;
    private CheckBoxPreference mAccountDefault;
    private CheckBoxPreference mAccountNotify;
    private CheckBoxPreference mAccountNotifySelf;
    private ListPreference mAccountScrollButtons;
    private ListPreference mAccountScrollMoveButtons;
    private ListPreference mAccountShowPictures;
    private CheckBoxPreference mAccountEnableMoveButtons;
    private CheckBoxPreference mAccountNotifySync;
    private CheckBoxPreference mAccountVibrate;
    private CheckBoxPreference mAccountLed;
    private ListPreference mAccountVibratePattern;
    private ListPreference mAccountVibrateTimes;
    private RingtonePreference mAccountRingtone;
    private ListPreference mDisplayMode;
    private ListPreference mSyncMode;
    private ListPreference mPushMode;
    private ListPreference mTargetMode;
    private ListPreference mDeletePolicy;
    private ListPreference mExpungePolicy;
    private ListPreference mSearchableFolders;
    private ListPreference mAutoExpandFolder;
    private Preference mChipColor;
    private Preference mLedColor;
    private boolean mIncomingChanged = false;
    private CheckBoxPreference mNotificationOpensUnread;
    private CheckBoxPreference mNotificationUnreadCount;
    private ListPreference mMessageFormat;
    private ListPreference mQuoteStyle;
    private EditTextPreference mAccountQuotePrefix;
    private CheckBoxPreference mAccountDefaultQuotedTextShown;
    private CheckBoxPreference mReplyAfterQuote;
    private CheckBoxPreference mSyncRemoteDeletions;
    private CheckBoxPreference mSaveAllHeaders;
    private CheckBoxPreference mPushPollOnConnect;
    private ListPreference mIdleRefreshPeriod;
    private ListPreference mMaxPushFolders;
    private ListPreference mCryptoApp;
    private CheckBoxPreference mCryptoAutoSignature;

    private ListPreference mLocalStorageProvider;


    private ListPreference mArchiveFolder;
    private ListPreference mDraftsFolder;
    private ListPreference mSentFolder;
    private ListPreference mSpamFolder;
    private ListPreference mTrashFolder;


    public static void actionSettings(Context context, Account account) {
        Intent i = new Intent(context, AccountSettings.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        try {
            final Store store = mAccount.getRemoteStore();
            mIsMoveCapable = store.isMoveCapable();
            mIsPushCapable = store.isPushCapable();
            mIsExpungeCapable = store.isExpungeCapable();
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Could not get remote store"", e);
        }

        addPreferencesFromResource(R.xml.account_settings_preferences);

        mAccountDescription = (EditTextPreference) findPreference(PREFERENCE_DESCRIPTION);
        mAccountDescription.setSummary(mAccount.getDescription());
        mAccountDescription.setText(mAccount.getDescription());
        mAccountDescription.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                mAccountDescription.setSummary(summary);
                mAccountDescription.setText(summary);
                return false;
            }
        });

        mMessageFormat = (ListPreference) findPreference(PREFERENCE_MESSAGE_FORMAT);
        mMessageFormat.setValue(mAccount.getMessageFormat().name());
        mMessageFormat.setSummary(mMessageFormat.getEntry());
        mMessageFormat.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mMessageFormat.findIndexOfValue(summary);
                mMessageFormat.setSummary(mMessageFormat.getEntries()[index]);
                mMessageFormat.setValue(summary);
                return false;
            }
        });

        mAccountQuotePrefix = (EditTextPreference) findPreference(PREFERENCE_QUOTE_PREFIX);
        mAccountQuotePrefix.setSummary(mAccount.getQuotePrefix());
        mAccountQuotePrefix.setText(mAccount.getQuotePrefix());
        mAccountQuotePrefix.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String value = newValue.toString();
                mAccountQuotePrefix.setSummary(value);
                mAccountQuotePrefix.setText(value);
                return false;
            }
        });

        mAccountDefaultQuotedTextShown = (CheckBoxPreference) findPreference(PREFERENCE_DEFAULT_QUOTED_TEXT_SHOWN);
        mAccountDefaultQuotedTextShown.setChecked(mAccount.isDefaultQuotedTextShown());

        mReplyAfterQuote = (CheckBoxPreference) findPreference(PREFERENCE_REPLY_AFTER_QUOTE);
        mReplyAfterQuote.setChecked(mAccount.isReplyAfterQuote());

        mComposingScreen = (PreferenceScreen) findPreference(PREFERENCE_SCREEN_COMPOSING);

        Preference.OnPreferenceChangeListener quoteStyleListener = new Preference.OnPreferenceChangeListener() {
            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final QuoteStyle style = QuoteStyle.valueOf(newValue.toString());
                int index = mQuoteStyle.findIndexOfValue(newValue.toString());
                mQuoteStyle.setSummary(mQuoteStyle.getEntries()[index]);
                if (style == QuoteStyle.PREFIX) {
                    mComposingScreen.addPreference(mAccountQuotePrefix);
                    mComposingScreen.addPreference(mReplyAfterQuote);
                } else if (style == QuoteStyle.HEADER) {
                    mComposingScreen.removePreference(mAccountQuotePrefix);
                    mComposingScreen.removePreference(mReplyAfterQuote);
                }
                return true;
            }
        };
        mQuoteStyle = (ListPreference) findPreference(PREFERENCE_QUOTE_STYLE);
        mQuoteStyle.setValue(mAccount.getQuoteStyle().name());
        mQuoteStyle.setSummary(mQuoteStyle.getEntry());
        mQuoteStyle.setOnPreferenceChangeListener(quoteStyleListener);
        // Call the onPreferenceChange() handler on startup to update the Preference dialogue based
        // upon the existing quote style setting.
        quoteStyleListener.onPreferenceChange(mQuoteStyle, mAccount.getQuoteStyle().name());

        mCheckFrequency = (ListPreference) findPreference(PREFERENCE_FREQUENCY);
        mCheckFrequency.setValue(String.valueOf(mAccount.getAutomaticCheckIntervalMinutes()));
        mCheckFrequency.setSummary(mCheckFrequency.getEntry());
        mCheckFrequency.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mCheckFrequency.findIndexOfValue(summary);
                mCheckFrequency.setSummary(mCheckFrequency.getEntries()[index]);
                mCheckFrequency.setValue(summary);
                return false;
            }
        });

        mDisplayMode = (ListPreference) findPreference(PREFERENCE_DISPLAY_MODE);
        mDisplayMode.setValue(mAccount.getFolderDisplayMode().name());
        mDisplayMode.setSummary(mDisplayMode.getEntry());
        mDisplayMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mDisplayMode.findIndexOfValue(summary);
                mDisplayMode.setSummary(mDisplayMode.getEntries()[index]);
                mDisplayMode.setValue(summary);
                return false;
            }
        });

        mSyncMode = (ListPreference) findPreference(PREFERENCE_SYNC_MODE);
        mSyncMode.setValue(mAccount.getFolderSyncMode().name());
        mSyncMode.setSummary(mSyncMode.getEntry());
        mSyncMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mSyncMode.findIndexOfValue(summary);
                mSyncMode.setSummary(mSyncMode.getEntries()[index]);
                mSyncMode.setValue(summary);
                return false;
            }
        });

        mPushMode = (ListPreference) findPreference(PREFERENCE_PUSH_MODE);
        mPushMode.setEnabled(mIsPushCapable);
        mPushMode.setValue(mAccount.getFolderPushMode().name());
        mPushMode.setSummary(mPushMode.getEntry());
        mPushMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mPushMode.findIndexOfValue(summary);
                mPushMode.setSummary(mPushMode.getEntries()[index]);
                mPushMode.setValue(summary);
                return false;
            }
        });

        mTargetMode = (ListPreference) findPreference(PREFERENCE_TARGET_MODE);
        mTargetMode.setValue(mAccount.getFolderTargetMode().name());
        mTargetMode.setSummary(mTargetMode.getEntry());
        mTargetMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mTargetMode.findIndexOfValue(summary);
                mTargetMode.setSummary(mTargetMode.getEntries()[index]);
                mTargetMode.setValue(summary);
                return false;
            }
        });

        mDeletePolicy = (ListPreference) findPreference(PREFERENCE_DELETE_POLICY);
        mDeletePolicy.setValue("""" + mAccount.getDeletePolicy());
        mDeletePolicy.setSummary(mDeletePolicy.getEntry());
        mDeletePolicy.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mDeletePolicy.findIndexOfValue(summary);
                mDeletePolicy.setSummary(mDeletePolicy.getEntries()[index]);
                mDeletePolicy.setValue(summary);
                return false;
            }
        });

        mExpungePolicy = (ListPreference) findPreference(PREFERENCE_EXPUNGE_POLICY);
        mExpungePolicy.setEnabled(mIsExpungeCapable);
        mExpungePolicy.setValue(mAccount.getExpungePolicy());
        mExpungePolicy.setSummary(mExpungePolicy.getEntry());
        mExpungePolicy.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mExpungePolicy.findIndexOfValue(summary);
                mExpungePolicy.setSummary(mExpungePolicy.getEntries()[index]);
                mExpungePolicy.setValue(summary);
                return false;
            }
        });

        mSyncRemoteDeletions = (CheckBoxPreference) findPreference(PREFERENCE_SYNC_REMOTE_DELETIONS);
        mSyncRemoteDeletions.setChecked(mAccount.syncRemoteDeletions());

        mSaveAllHeaders = (CheckBoxPreference) findPreference(PREFERENCE_SAVE_ALL_HEADERS);
        mSaveAllHeaders.setChecked(mAccount.saveAllHeaders());

        mSearchableFolders = (ListPreference) findPreference(PREFERENCE_SEARCHABLE_FOLDERS);
        mSearchableFolders.setValue(mAccount.getSearchableFolders().name());
        mSearchableFolders.setSummary(mSearchableFolders.getEntry());
        mSearchableFolders.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mSearchableFolders.findIndexOfValue(summary);
                mSearchableFolders.setSummary(mSearchableFolders.getEntries()[index]);
                mSearchableFolders.setValue(summary);
                return false;
            }
        });

        mDisplayCount = (ListPreference) findPreference(PREFERENCE_DISPLAY_COUNT);
        mDisplayCount.setValue(String.valueOf(mAccount.getDisplayCount()));
        mDisplayCount.setSummary(mDisplayCount.getEntry());
        mDisplayCount.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mDisplayCount.findIndexOfValue(summary);
                mDisplayCount.setSummary(mDisplayCount.getEntries()[index]);
                mDisplayCount.setValue(summary);
                return false;
            }
        });

        mMessageAge = (ListPreference) findPreference(PREFERENCE_MESSAGE_AGE);
        mMessageAge.setValue(String.valueOf(mAccount.getMaximumPolledMessageAge()));
        mMessageAge.setSummary(mMessageAge.getEntry());
        mMessageAge.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mMessageAge.findIndexOfValue(summary);
                mMessageAge.setSummary(mMessageAge.getEntries()[index]);
                mMessageAge.setValue(summary);
                return false;
            }
        });

        mMessageSize = (ListPreference) findPreference(PREFERENCE_MESSAGE_SIZE);
        mMessageSize.setValue(String.valueOf(mAccount.getMaximumAutoDownloadMessageSize()));
        mMessageSize.setSummary(mMessageSize.getEntry());
        mMessageSize.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mMessageSize.findIndexOfValue(summary);
                mMessageSize.setSummary(mMessageSize.getEntries()[index]);
                mMessageSize.setValue(summary);
                return false;
            }
        });

        mAccountDefault = (CheckBoxPreference) findPreference(PREFERENCE_DEFAULT);
        mAccountDefault.setChecked(
            mAccount.equals(Preferences.getPreferences(this).getDefaultAccount()));

        mAccountScrollButtons = (ListPreference) findPreference(PREFERENCE_HIDE_BUTTONS);
        mAccountScrollButtons.setValue("""" + mAccount.getScrollMessageViewButtons());
        mAccountScrollButtons.setSummary(mAccountScrollButtons.getEntry());
        mAccountScrollButtons.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mAccountScrollButtons.findIndexOfValue(summary);
                mAccountScrollButtons.setSummary(mAccountScrollButtons.getEntries()[index]);
                mAccountScrollButtons.setValue(summary);
                return false;
            }
        });

        mAccountEnableMoveButtons = (CheckBoxPreference) findPreference(PREFERENCE_ENABLE_MOVE_BUTTONS);
        mAccountEnableMoveButtons.setEnabled(mIsMoveCapable);
        mAccountEnableMoveButtons.setChecked(mAccount.getEnableMoveButtons());

        mAccountScrollMoveButtons = (ListPreference) findPreference(PREFERENCE_HIDE_MOVE_BUTTONS);
        mAccountScrollMoveButtons.setEnabled(mIsMoveCapable);
        mAccountScrollMoveButtons.setValue("""" + mAccount.getScrollMessageViewMoveButtons());
        mAccountScrollMoveButtons.setSummary(mAccountScrollMoveButtons.getEntry());
        mAccountScrollMoveButtons.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mAccountScrollMoveButtons.findIndexOfValue(summary);
                mAccountScrollMoveButtons.setSummary(mAccountScrollMoveButtons.getEntries()[index]);
                mAccountScrollMoveButtons.setValue(summary);
                return false;
            }
        });

        mAccountShowPictures = (ListPreference) findPreference(PREFERENCE_SHOW_PICTURES);
        mAccountShowPictures.setValue("""" + mAccount.getShowPictures());
        mAccountShowPictures.setSummary(mAccountShowPictures.getEntry());
        mAccountShowPictures.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mAccountShowPictures.findIndexOfValue(summary);
                mAccountShowPictures.setSummary(mAccountShowPictures.getEntries()[index]);
                mAccountShowPictures.setValue(summary);
                return false;
            }
        });


        mLocalStorageProvider = (ListPreference) findPreference(PREFERENCE_LOCAL_STORAGE_PROVIDER);
        {
            final Map<String, String> providers;
            providers = StorageManager.getInstance(K9.app).getAvailableProviders();
            int i = 0;
            final String[] providerLabels = new String[providers.size()];
            final String[] providerIds = new String[providers.size()];
            for (final Map.Entry<String, String> entry : providers.entrySet()) {
                providerIds[i] = entry.getKey();
                providerLabels[i] = entry.getValue();
                i++;
            }
            mLocalStorageProvider.setEntryValues(providerIds);
            mLocalStorageProvider.setEntries(providerLabels);
            mLocalStorageProvider.setValue(mAccount.getLocalStorageProviderId());
            mLocalStorageProvider.setSummary(providers.get(mAccount.getLocalStorageProviderId()));

            mLocalStorageProvider.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                public boolean onPreferenceChange(Preference preference, Object newValue) {
                    mLocalStorageProvider.setSummary(providers.get(newValue));
                    return true;
                }
            });
        }
        // IMAP-specific preferences

        mPushPollOnConnect = (CheckBoxPreference) findPreference(PREFERENCE_PUSH_POLL_ON_CONNECT);
        mIdleRefreshPeriod = (ListPreference) findPreference(PREFERENCE_IDLE_REFRESH_PERIOD);
        mMaxPushFolders = (ListPreference) findPreference(PREFERENCE_MAX_PUSH_FOLDERS);
        if (mIsPushCapable) {
            mPushPollOnConnect.setChecked(mAccount.isPushPollOnConnect());

            mIdleRefreshPeriod.setValue(String.valueOf(mAccount.getIdleRefreshMinutes()));
            mIdleRefreshPeriod.setSummary(mIdleRefreshPeriod.getEntry());
            mIdleRefreshPeriod.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                public boolean onPreferenceChange(Preference preference, Object newValue) {
                    final String summary = newValue.toString();
                    int index = mIdleRefreshPeriod.findIndexOfValue(summary);
                    mIdleRefreshPeriod.setSummary(mIdleRefreshPeriod.getEntries()[index]);
                    mIdleRefreshPeriod.setValue(summary);
                    return false;
                }
            });

            mMaxPushFolders.setValue(String.valueOf(mAccount.getMaxPushFolders()));
            mMaxPushFolders.setSummary(mMaxPushFolders.getEntry());
            mMaxPushFolders.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                public boolean onPreferenceChange(Preference preference, Object newValue) {
                    final String summary = newValue.toString();
                    int index = mMaxPushFolders.findIndexOfValue(summary);
                    mMaxPushFolders.setSummary(mMaxPushFolders.getEntries()[index]);
                    mMaxPushFolders.setValue(summary);
                    return false;
                }
            });
        } else {
            mPushPollOnConnect.setEnabled(false);
            mMaxPushFolders.setEnabled(false);
            mIdleRefreshPeriod.setEnabled(false);
        }

        mAccountNotify = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFY);
        mAccountNotify.setChecked(mAccount.isNotifyNewMail());

        mAccountNotifySelf = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFY_SELF);
        mAccountNotifySelf.setChecked(mAccount.isNotifySelfNewMail());

        mAccountNotifySync = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFY_SYNC);
        mAccountNotifySync.setChecked(mAccount.isShowOngoing());

        mAccountRingtone = (RingtonePreference) findPreference(PREFERENCE_RINGTONE);

        // XXX: The following two lines act as a workaround for the RingtonePreference
        //      which does not let us set/get the value programmatically
        SharedPreferences prefs = mAccountRingtone.getPreferenceManager().getSharedPreferences();
        String currentRingtone = (!mAccount.getNotificationSetting().shouldRing() ? null : mAccount.getNotificationSetting().getRingtone());
        prefs.edit().putString(PREFERENCE_RINGTONE, currentRingtone).commit();

        mAccountVibrate = (CheckBoxPreference) findPreference(PREFERENCE_VIBRATE);
        mAccountVibrate.setChecked(mAccount.getNotificationSetting().shouldVibrate());

        mAccountVibratePattern = (ListPreference) findPreference(PREFERENCE_VIBRATE_PATTERN);
        mAccountVibratePattern.setValue(String.valueOf(mAccount.getNotificationSetting().getVibratePattern()));
        mAccountVibratePattern.setSummary(mAccountVibratePattern.getEntry());
        mAccountVibratePattern.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mAccountVibratePattern.findIndexOfValue(summary);
                mAccountVibratePattern.setSummary(mAccountVibratePattern.getEntries()[index]);
                mAccountVibratePattern.setValue(summary);
                doVibrateTest(preference);
                return false;
            }
        });

        mAccountVibrateTimes = (ListPreference) findPreference(PREFERENCE_VIBRATE_TIMES);
        mAccountVibrateTimes.setValue(String.valueOf(mAccount.getNotificationSetting().getVibrateTimes()));
        mAccountVibrateTimes.setSummary(String.valueOf(mAccount.getNotificationSetting().getVibrateTimes()));
        mAccountVibrateTimes.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String value = newValue.toString();
                mAccountVibrateTimes.setSummary(value);
                mAccountVibrateTimes.setValue(value);
                doVibrateTest(preference);
                return false;
            }
        });

        mAccountLed = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFICATION_LED);
        mAccountLed.setChecked(mAccount.getNotificationSetting().isLed());

        mNotificationOpensUnread = (CheckBoxPreference)findPreference(PREFERENCE_NOTIFICATION_OPENS_UNREAD);
        mNotificationOpensUnread.setChecked(mAccount.goToUnreadMessageSearch());

        mNotificationUnreadCount = (CheckBoxPreference)findPreference(PREFERENCE_NOTIFICATION_UNREAD_COUNT);
        mNotificationUnreadCount.setChecked(mAccount.isNotificationShowsUnreadCount());

        new PopulateFolderPrefsTask().execute();

        mChipColor = findPreference(PREFERENCE_CHIP_COLOR);
        mChipColor.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
            public boolean onPreferenceClick(Preference preference) {
                onChooseChipColor();
                return false;
            }
        });

        mLedColor = findPreference(PREFERENCE_LED_COLOR);
        mLedColor.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
            public boolean onPreferenceClick(Preference preference) {
                onChooseLedColor();
                return false;
            }
        });

        findPreference(PREFERENCE_COMPOSITION).setOnPreferenceClickListener(
        new Preference.OnPreferenceClickListener() {
            public boolean onPreferenceClick(Preference preference) {
                onCompositionSettings();
                return true;
            }
        });

        findPreference(PREFERENCE_MANAGE_IDENTITIES).setOnPreferenceClickListener(
        new Preference.OnPreferenceClickListener() {
            public boolean onPreferenceClick(Preference preference) {
                onManageIdentities();
                return true;
            }
        });

        findPreference(PREFERENCE_INCOMING).setOnPreferenceClickListener(
        new Preference.OnPreferenceClickListener() {
            public boolean onPreferenceClick(Preference preference) {
                mIncomingChanged = true;
                onIncomingSettings();
                return true;
            }
        });

        findPreference(PREFERENCE_OUTGOING).setOnPreferenceClickListener(
        new Preference.OnPreferenceClickListener() {
            public boolean onPreferenceClick(Preference preference) {
                onOutgoingSettings();
                return true;
            }
        });

        mCryptoApp = (ListPreference) findPreference(PREFERENCE_CRYPTO_APP);
        CharSequence cryptoAppEntries[] = mCryptoApp.getEntries();
        if (!new Apg().isAvailable(this)) {
            int apgIndex = mCryptoApp.findIndexOfValue(Apg.NAME);
            if (apgIndex >= 0) {
                cryptoAppEntries[apgIndex] = ""APG ("" + getResources().getString(R.string.account_settings_crypto_app_not_available) + "")"";
                mCryptoApp.setEntries(cryptoAppEntries);
            }
        }
        mCryptoApp.setValue(String.valueOf(mAccount.getCryptoApp()));
        mCryptoApp.setSummary(mCryptoApp.getEntry());
        mCryptoApp.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                String value = newValue.toString();
                int index = mCryptoApp.findIndexOfValue(value);
                mCryptoApp.setSummary(mCryptoApp.getEntries()[index]);
                mCryptoApp.setValue(value);
                handleCryptoAppDependencies();
                if (Apg.NAME.equals(value)) {
                    Apg.createInstance(null).test(AccountSettings.this);
                }
                return false;
            }
        });

        mCryptoAutoSignature = (CheckBoxPreference) findPreference(PREFERENCE_CRYPTO_AUTO_SIGNATURE);
        mCryptoAutoSignature.setChecked(mAccount.getCryptoAutoSignature());

        handleCryptoAppDependencies();
    }

    private void handleCryptoAppDependencies() {
        if ("""".equals(mCryptoApp.getValue())) {
            mCryptoAutoSignature.setEnabled(false);
        } else {
            mCryptoAutoSignature.setEnabled(true);
        }
    }

    @Override
    public void onResume() {
        super.onResume();
    }

    private void saveSettings() {
        if (mAccountDefault.isChecked()) {
            Preferences.getPreferences(this).setDefaultAccount(mAccount);
        }

        mAccount.setDescription(mAccountDescription.getText());
        mAccount.setNotifyNewMail(mAccountNotify.isChecked());
        mAccount.setNotifySelfNewMail(mAccountNotifySelf.isChecked());
        mAccount.setShowOngoing(mAccountNotifySync.isChecked());
        mAccount.setDisplayCount(Integer.parseInt(mDisplayCount.getValue()));
        mAccount.setMaximumPolledMessageAge(Integer.parseInt(mMessageAge.getValue()));
        mAccount.setMaximumAutoDownloadMessageSize(Integer.parseInt(mMessageSize.getValue()));
        mAccount.getNotificationSetting().setVibrate(mAccountVibrate.isChecked());
        mAccount.getNotificationSetting().setVibratePattern(Integer.parseInt(mAccountVibratePattern.getValue()));
        mAccount.getNotificationSetting().setVibrateTimes(Integer.parseInt(mAccountVibrateTimes.getValue()));
        mAccount.getNotificationSetting().setLed(mAccountLed.isChecked());
        mAccount.setGoToUnreadMessageSearch(mNotificationOpensUnread.isChecked());
        mAccount.setNotificationShowsUnreadCount(mNotificationUnreadCount.isChecked());
        mAccount.setFolderTargetMode(Account.FolderMode.valueOf(mTargetMode.getValue()));
        mAccount.setDeletePolicy(Integer.parseInt(mDeletePolicy.getValue()));
        mAccount.setExpungePolicy(mExpungePolicy.getValue());
        mAccount.setSyncRemoteDeletions(mSyncRemoteDeletions.isChecked());
        mAccount.setSaveAllHeaders(mSaveAllHeaders.isChecked());
        mAccount.setSearchableFolders(Account.Searchable.valueOf(mSearchableFolders.getValue()));
        mAccount.setMessageFormat(Account.MessageFormat.valueOf(mMessageFormat.getValue()));
        mAccount.setQuoteStyle(QuoteStyle.valueOf(mQuoteStyle.getValue()));
        mAccount.setQuotePrefix(mAccountQuotePrefix.getText());
        mAccount.setDefaultQuotedTextShown(mAccountDefaultQuotedTextShown.isChecked());
        mAccount.setReplyAfterQuote(mReplyAfterQuote.isChecked());
        mAccount.setCryptoApp(mCryptoApp.getValue());
        mAccount.setCryptoAutoSignature(mCryptoAutoSignature.isChecked());
        mAccount.setLocalStorageProviderId(mLocalStorageProvider.getValue());

        // In webdav account we use the exact folder name also for inbox,
        // since it varies because of internationalization
        if (mAccount.getStoreUri().startsWith(""webdav""))
            mAccount.setAutoExpandFolderName(mAutoExpandFolder.getValue());
        else
            mAccount.setAutoExpandFolderName(reverseTranslateFolder(mAutoExpandFolder.getValue()));

        mAccount.setArchiveFolderName(mArchiveFolder.getValue());
        mAccount.setDraftsFolderName(mDraftsFolder.getValue());
        mAccount.setSentFolderName(mSentFolder.getValue());
        mAccount.setSpamFolderName(mSpamFolder.getValue());
        mAccount.setTrashFolderName(mTrashFolder.getValue());


        if (mIsPushCapable) {
            mAccount.setPushPollOnConnect(mPushPollOnConnect.isChecked());
            mAccount.setIdleRefreshMinutes(Integer.parseInt(mIdleRefreshPeriod.getValue()));
            mAccount.setMaxPushFolders(Integer.parseInt(mMaxPushFolders.getValue()));
        }

        if (!mIsMoveCapable) {
            mAccount.setEnableMoveButtons(false);
            mAccount.setScrollMessageViewMoveButtons(ScrollButtons.NEVER);
        } else {
            mAccount.setEnableMoveButtons(mAccountEnableMoveButtons.isChecked());
            mAccount.setScrollMessageViewMoveButtons(Account.ScrollButtons.valueOf(mAccountScrollMoveButtons.getValue()));
        }

        boolean needsRefresh = mAccount.setAutomaticCheckIntervalMinutes(Integer.parseInt(mCheckFrequency.getValue()));
        needsRefresh |= mAccount.setFolderSyncMode(Account.FolderMode.valueOf(mSyncMode.getValue()));

        boolean needsPushRestart = mAccount.setFolderPushMode(Account.FolderMode.valueOf(mPushMode.getValue()));
        boolean displayModeChanged = mAccount.setFolderDisplayMode(Account.FolderMode.valueOf(mDisplayMode.getValue()));

        if (mAccount.getFolderPushMode() != FolderMode.NONE) {
            needsPushRestart |= displayModeChanged;
            needsPushRestart |= mIncomingChanged;
        }

        SharedPreferences prefs = mAccountRingtone.getPreferenceManager().getSharedPreferences();
        String newRingtone = prefs.getString(PREFERENCE_RINGTONE, null);
        if (newRingtone != null) {
            mAccount.getNotificationSetting().setRing(true);
            mAccount.getNotificationSetting().setRingtone(newRingtone);
        } else {
            if (mAccount.getNotificationSetting().shouldRing()) {
                mAccount.getNotificationSetting().setRingtone(null);
            }
        }

        mAccount.setScrollMessageViewButtons(Account.ScrollButtons.valueOf(mAccountScrollButtons.getValue()));
        mAccount.setShowPictures(Account.ShowPictures.valueOf(mAccountShowPictures.getValue()));
        mAccount.save(Preferences.getPreferences(this));

        if (needsRefresh && needsPushRestart) {
            MailService.actionReset(this, null);
        } else if (needsRefresh) {
            MailService.actionReschedulePoll(this, null);
        } else if (needsPushRestart) {
            MailService.actionRestartPushers(this, null);
        }
        // TODO: refresh folder list here
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (resultCode == RESULT_OK) {
            switch (requestCode) {
            case SELECT_AUTO_EXPAND_FOLDER:
                mAutoExpandFolder.setSummary(translateFolder(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER)));
                break;
            }
        }
        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            saveSettings();
        }
        return super.onKeyDown(keyCode, event);
    }

    private void onCompositionSettings() {
        AccountSetupComposition.actionEditCompositionSettings(this, mAccount);
    }

    private void onManageIdentities() {
        Intent intent = new Intent(this, ManageIdentities.class);
        intent.putExtra(ChooseIdentity.EXTRA_ACCOUNT, mAccount.getUuid());
        startActivityForResult(intent, ACTIVITY_MANAGE_IDENTITIES);
    }

    private void onIncomingSettings() {
        AccountSetupIncoming.actionEditIncomingSettings(this, mAccount);
    }

    private void onOutgoingSettings() {
        AccountSetupOutgoing.actionEditOutgoingSettings(this, mAccount);
    }

    public void onChooseChipColor() {
        new ColorPickerDialog(this, new ColorPickerDialog.OnColorChangedListener() {
            public void colorChanged(int color) {
                mAccount.setChipColor(color);
            }
        },
        mAccount.getChipColor()).show();
    }

    public void onChooseLedColor() {
        new ColorPickerDialog(this, new ColorPickerDialog.OnColorChangedListener() {
            public void colorChanged(int color) {
                mAccount.getNotificationSetting().setLedColor(color);
            }
        },
        mAccount.getNotificationSetting().getLedColor()).show();
    }

    public void onChooseAutoExpandFolder() {
        Intent selectIntent = new Intent(this, ChooseFolder.class);
        selectIntent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());

        selectIntent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, mAutoExpandFolder.getSummary());
        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_CURRENT, ""yes"");
        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_FOLDER_NONE, ""yes"");
        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_DISPLAYABLE_ONLY, ""yes"");
        startActivityForResult(selectIntent, SELECT_AUTO_EXPAND_FOLDER);
    }

    private String translateFolder(String in) {
        if (mAccount.getInboxFolderName().equalsIgnoreCase(in)) {
            return getString(R.string.special_mailbox_name_inbox);
        } else {
            return in;
        }
    }

    private String reverseTranslateFolder(String in) {
        if (getString(R.string.special_mailbox_name_inbox).equals(in)) {
            return mAccount.getInboxFolderName();
        } else {
            return in;
        }
    }

    private void doVibrateTest(Preference preference) {
        // Do the vibration to show the user what it's like.
        Vibrator vibrate = (Vibrator)preference.getContext().getSystemService(Context.VIBRATOR_SERVICE);
        vibrate.vibrate(NotificationSetting.getVibration(
                            Integer.parseInt(mAccountVibratePattern.getValue()),
                            Integer.parseInt(mAccountVibrateTimes.getValue())), -1);
    }

    private class PopulateFolderPrefsTask extends AsyncTask<Void, Void, Void> {
        List <? extends Folder > folders = new LinkedList<LocalFolder>();
        String[] allFolderValues;
        String[] allFolderLabels;

        @Override
        protected Void doInBackground(Void... params) {
            try {
                folders = mAccount.getLocalStore().getPersonalNamespaces(false);
            } catch (Exception e) {
                /// this can't be checked in
            }

            // TODO: In the future the call above should be changed to only return remote folders.
            // For now we just remove the Outbox folder if present.
            Iterator <? extends Folder > iter = folders.iterator();
            while (iter.hasNext()) {
                Folder folder = iter.next();
                if (mAccount.getOutboxFolderName().equals(folder.getName())) {
                    iter.remove();
                }
            }

            allFolderValues = new String[folders.size()+1];
            allFolderLabels = new String[folders.size()+1];

            allFolderValues[0] = K9.FOLDER_NONE;
            allFolderLabels[0] = K9.FOLDER_NONE;

            int i = 1;
            for (Folder folder : folders) {
                allFolderLabels[i] = folder.getName();
                allFolderValues[i] = folder.getName();
                i++;
            }
            return null;
        }

        @Override
        protected void onPreExecute() {
            mAutoExpandFolder = (ListPreference)findPreference(PREFERENCE_AUTO_EXPAND_FOLDER);
            mAutoExpandFolder.setEnabled(false);
            mArchiveFolder = (ListPreference)findPreference(PREFERENCE_ARCHIVE_FOLDER);
            mArchiveFolder.setEnabled(false);
            mDraftsFolder = (ListPreference)findPreference(PREFERENCE_DRAFTS_FOLDER);
            mDraftsFolder.setEnabled(false);
            mSentFolder = (ListPreference)findPreference(PREFERENCE_SENT_FOLDER);
            mSentFolder.setEnabled(false);
            mSpamFolder = (ListPreference)findPreference(PREFERENCE_SPAM_FOLDER);
            mSpamFolder.setEnabled(false);
            mTrashFolder = (ListPreference)findPreference(PREFERENCE_TRASH_FOLDER);
            mTrashFolder.setEnabled(false);

        }

        @Override
        protected void onPostExecute(Void res) {
            initListPreference(mAutoExpandFolder, mAccount.getAutoExpandFolderName(), allFolderLabels, allFolderValues);
            initListPreference(mArchiveFolder, mAccount.getArchiveFolderName(), allFolderLabels, allFolderValues);
            initListPreference(mDraftsFolder, mAccount.getDraftsFolderName(), allFolderLabels, allFolderValues);
            initListPreference(mSentFolder, mAccount.getSentFolderName(), allFolderLabels, allFolderValues);
            initListPreference(mSpamFolder, mAccount.getSpamFolderName(), allFolderLabels, allFolderValues);
            initListPreference(mTrashFolder, mAccount.getTrashFolderName(), allFolderLabels, allFolderValues);
            mAutoExpandFolder.setEnabled(true);
            mArchiveFolder.setEnabled(true);
            mDraftsFolder.setEnabled(true);
            mSentFolder.setEnabled(true);
            mSpamFolder.setEnabled(true);
            mTrashFolder.setEnabled(true);
        }
    }
}
",True,144,0,0,5,59,3,19,L1
79,com.fsck.k9.activity.setup.AccountSetupIncoming.java,"
package com.fsck.k9.activity.setup;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.text.method.DigitsKeyListener;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.*;

import com.fsck.k9.*;
import com.fsck.k9.activity.K9Activity;
import com.fsck.k9.helper.Utility;

import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public class AccountSetupIncoming extends K9Activity implements OnClickListener {
    private static final String EXTRA_ACCOUNT = ""account"";
    private static final String EXTRA_MAKE_DEFAULT = ""makeDefault"";

    private static final int popPorts[] = {
        110, 995, 995, 110, 110
    };
    private static final String popSchemes[] = {
        ""pop3"", ""pop3+ssl"", ""pop3+ssl+"", ""pop3+tls"", ""pop3+tls+""
    };
    private static final int imapPorts[] = {
        143, 993, 993, 143, 143
    };
    private static final String imapSchemes[] = {
        ""imap"", ""imap+ssl"", ""imap+ssl+"", ""imap+tls"", ""imap+tls+""
    };
    private static final int webdavPorts[] = {
        80, 443, 443, 443, 443
    };
    private static final String webdavSchemes[] = {
        ""webdav"", ""webdav+ssl"", ""webdav+ssl+"", ""webdav+tls"", ""webdav+tls+""
    };

    private static final String authTypes[] = {
        ""PLAIN"", ""CRAM_MD5""
    };


    private int mAccountPorts[];
    private String mAccountSchemes[];
    private EditText mUsernameView;
    private EditText mPasswordView;
    private EditText mServerView;
    private EditText mPortView;
    private Spinner mSecurityTypeView;
    private Spinner mAuthTypeView;
    private EditText mImapPathPrefixView;
    private EditText mWebdavPathPrefixView;
    private EditText mWebdavAuthPathView;
    private EditText mWebdavMailboxPathView;
    private Button mNextButton;
    private Account mAccount;
    private boolean mMakeDefault;
    private CheckBox mCompressionMobile;
    private CheckBox mCompressionWifi;
    private CheckBox mCompressionOther;
    private CheckBox mSubscribedFoldersOnly;

    public static void actionIncomingSettings(Activity context, Account account, boolean makeDefault) {
        Intent i = new Intent(context, AccountSetupIncoming.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
        context.startActivity(i);
    }

    public static void actionEditIncomingSettings(Activity context, Account account) {
        Intent i = new Intent(context, AccountSetupIncoming.class);
        i.setAction(Intent.ACTION_EDIT);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_incoming);

        mUsernameView = (EditText)findViewById(R.id.account_username);
        mPasswordView = (EditText)findViewById(R.id.account_password);
        TextView serverLabelView = (TextView) findViewById(R.id.account_server_label);
        mServerView = (EditText)findViewById(R.id.account_server);
        mPortView = (EditText)findViewById(R.id.account_port);
        mSecurityTypeView = (Spinner)findViewById(R.id.account_security_type);
        mAuthTypeView = (Spinner)findViewById(R.id.account_auth_type);
        mImapPathPrefixView = (EditText)findViewById(R.id.imap_path_prefix);
        mWebdavPathPrefixView = (EditText)findViewById(R.id.webdav_path_prefix);
        mWebdavAuthPathView = (EditText)findViewById(R.id.webdav_auth_path);
        mWebdavMailboxPathView = (EditText)findViewById(R.id.webdav_mailbox_path);
        mNextButton = (Button)findViewById(R.id.next);
        mCompressionMobile = (CheckBox)findViewById(R.id.compression_mobile);
        mCompressionWifi = (CheckBox)findViewById(R.id.compression_wifi);
        mCompressionOther = (CheckBox)findViewById(R.id.compression_other);
        mSubscribedFoldersOnly = (CheckBox)findViewById(R.id.subscribed_folders_only);

        mNextButton.setOnClickListener(this);

        SpinnerOption securityTypes[] = {
            new SpinnerOption(0, getString(R.string.account_setup_incoming_security_none_label)),
            new SpinnerOption(1,
            getString(R.string.account_setup_incoming_security_ssl_optional_label)),
            new SpinnerOption(2, getString(R.string.account_setup_incoming_security_ssl_label)),
            new SpinnerOption(3,
            getString(R.string.account_setup_incoming_security_tls_optional_label)),
            new SpinnerOption(4, getString(R.string.account_setup_incoming_security_tls_label)),
        };

        // This needs to be kept in sync with the list at the top of the file.
        // that makes me somewhat unhappy
        SpinnerOption authTypeSpinnerOptions[] = {
            new SpinnerOption(0, ""PLAIN""),
            new SpinnerOption(1, ""CRAM_MD5"")
        };

        ArrayAdapter<SpinnerOption> securityTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, securityTypes);
        securityTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mSecurityTypeView.setAdapter(securityTypesAdapter);

        ArrayAdapter<SpinnerOption> authTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, authTypeSpinnerOptions);
        authTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mAuthTypeView.setAdapter(authTypesAdapter);

        /*
         * Updates the port when the user changes the security type. This allows
         * us to show a reasonable default which the user can change.
         */
        mSecurityTypeView.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                updatePortFromSecurityType();
            }

            public void onNothingSelected(AdapterView<?> parent) {
            }
        });

        /*
         * Calls validateFields() which enables or disables the Next button
         * based on the fields' validity.
         */
        TextWatcher validationTextWatcher = new TextWatcher() {
            public void afterTextChanged(Editable s) {
                validateFields();
            }

            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
            }

            public void onTextChanged(CharSequence s, int start, int before, int count) {
            }
        };
        mUsernameView.addTextChangedListener(validationTextWatcher);
        mPasswordView.addTextChangedListener(validationTextWatcher);
        mServerView.addTextChangedListener(validationTextWatcher);
        mPortView.addTextChangedListener(validationTextWatcher);

        /*
         * Only allow digits in the port field.
         */
        mPortView.setKeyListener(DigitsKeyListener.getInstance(""0123456789""));

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mMakeDefault = getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false);

        /*
         * If we're being reloaded we override the original account with the one
         * we saved
         */
        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT)) {
            accountUuid = savedInstanceState.getString(EXTRA_ACCOUNT);
            mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        }

        try {
            URI uri = new URI(mAccount.getStoreUri());
            String username = null;
            String password = null;
            String authType = null;

            if (uri.getUserInfo() != null) {
                String[] userInfoParts = uri.getUserInfo().split("":"");
                if (userInfoParts.length == 3) {
                    authType = userInfoParts[0];
                    username = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                    password = URLDecoder.decode(userInfoParts[2], ""UTF-8"");
                } else if (userInfoParts.length == 2) {
                    username = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                    password = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                } else if (userInfoParts.length == 1) {
                    username = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                }
            }



            if (username != null) {
                mUsernameView.setText(username);
            }

            if (password != null) {
                mPasswordView.setText(password);
            }

            if (authType != null) {
                for (int i = 0; i < authTypes.length; i++) {
                    if (authTypes[i].equals(authType)) {
                        SpinnerOption.setSpinnerOptionValue(mAuthTypeView, i);
                    }
                }
            }


            if (uri.getScheme().startsWith(""pop3"")) {
                serverLabelView.setText(R.string.account_setup_incoming_pop_server_label);
                mAccountPorts = popPorts;
                mAccountSchemes = popSchemes;
                findViewById(R.id.imap_path_prefix_section).setVisibility(View.GONE);
                findViewById(R.id.webdav_advanced_header).setVisibility(View.GONE);
                findViewById(R.id.webdav_mailbox_alias_section).setVisibility(View.GONE);
                findViewById(R.id.webdav_owa_path_section).setVisibility(View.GONE);
                findViewById(R.id.webdav_auth_path_section).setVisibility(View.GONE);
                findViewById(R.id.compression_section).setVisibility(View.GONE);
                findViewById(R.id.compression_label).setVisibility(View.GONE);
                mSubscribedFoldersOnly.setVisibility(View.GONE);
                mAccount.setDeletePolicy(Account.DELETE_POLICY_NEVER);
            } else if (uri.getScheme().startsWith(""imap"")) {
                serverLabelView.setText(R.string.account_setup_incoming_imap_server_label);
                mAccountPorts = imapPorts;
                mAccountSchemes = imapSchemes;

                if (uri.getPath() != null && uri.getPath().length() > 0) {
                    mImapPathPrefixView.setText(uri.getPath().substring(1));
                }

                findViewById(R.id.webdav_advanced_header).setVisibility(View.GONE);
                findViewById(R.id.webdav_mailbox_alias_section).setVisibility(View.GONE);
                findViewById(R.id.webdav_owa_path_section).setVisibility(View.GONE);
                findViewById(R.id.webdav_auth_path_section).setVisibility(View.GONE);
                mAccount.setDeletePolicy(Account.DELETE_POLICY_ON_DELETE);

                if (!Intent.ACTION_EDIT.equals(getIntent().getAction())) {
                    findViewById(R.id.imap_folder_setup_section).setVisibility(View.GONE);
                }
            } else if (uri.getScheme().startsWith(""webdav"")) {
                serverLabelView.setText(R.string.account_setup_incoming_webdav_server_label);
                mAccountPorts = webdavPorts;
                mAccountSchemes = webdavSchemes;

                /** Hide the unnecessary fields */
                findViewById(R.id.imap_path_prefix_section).setVisibility(View.GONE);
                findViewById(R.id.account_auth_type_label).setVisibility(View.GONE);
                findViewById(R.id.account_auth_type).setVisibility(View.GONE);
                findViewById(R.id.compression_section).setVisibility(View.GONE);
                findViewById(R.id.compression_label).setVisibility(View.GONE);
                mSubscribedFoldersOnly.setVisibility(View.GONE);
                if (uri.getPath() != null && uri.getPath().length() > 0) {
                    String[] pathParts = uri.getPath().split(""\\|"");

                    for (int i = 0, count = pathParts.length; i < count; i++) {
                        if (i == 0) {
                            if (pathParts[0] != null &&
                                    pathParts[0].length() > 1) {
                                mWebdavPathPrefixView.setText(pathParts[0].substring(1));
                            }
                        } else if (i == 1) {
                            if (pathParts[1] != null &&
                                    pathParts[1].length() > 1) {
                                mWebdavAuthPathView.setText(pathParts[1]);
                            }
                        } else if (i == 2) {
                            if (pathParts[2] != null &&
                                    pathParts[2].length() > 1) {
                                mWebdavMailboxPathView.setText(pathParts[2]);
                            }
                        }
                    }
                }
                mAccount.setDeletePolicy(Account.DELETE_POLICY_ON_DELETE);
            } else {
                throw new Exception(""Unknown account type: "" + mAccount.getStoreUri());
            }

            for (int i = 0; i < mAccountSchemes.length; i++) {
                if (mAccountSchemes[i].equals(uri.getScheme())) {
                    SpinnerOption.setSpinnerOptionValue(mSecurityTypeView, i);
                }
            }
            mCompressionMobile.setChecked(mAccount.useCompression(Account.TYPE_MOBILE));
            mCompressionWifi.setChecked(mAccount.useCompression(Account.TYPE_WIFI));
            mCompressionOther.setChecked(mAccount.useCompression(Account.TYPE_OTHER));

            if (uri.getHost() != null) {
                mServerView.setText(uri.getHost());
            }

            if (uri.getPort() != -1) {
                mPortView.setText(Integer.toString(uri.getPort()));
            } else {
                updatePortFromSecurityType();
            }

            mSubscribedFoldersOnly.setChecked(mAccount.subscribedFoldersOnly());

            validateFields();
        } catch (Exception e) {
            failure(e);
        }
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putString(EXTRA_ACCOUNT, mAccount.getUuid());
    }

    private void validateFields() {
        mNextButton
        .setEnabled(Utility.requiredFieldValid(mUsernameView)
                    && Utility.requiredFieldValid(mPasswordView)
                    && Utility.domainFieldValid(mServerView)
                    && Utility.requiredFieldValid(mPortView));
        Utility.setCompoundDrawablesAlpha(mNextButton, mNextButton.isEnabled() ? 255 : 128);
    }

    private void updatePortFromSecurityType() {
        if (mAccountPorts != null) {
            int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
            mPortView.setText(Integer.toString(mAccountPorts[securityType]));
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (resultCode == RESULT_OK) {
            if (Intent.ACTION_EDIT.equals(getIntent().getAction())) {
                mAccount.save(Preferences.getPreferences(this));
                finish();
            } else {
                /*
                 * Set the username and password for the outgoing settings to the username and
                 * password the user just set for incoming.
                 */
                try {
                    String usernameEnc = URLEncoder.encode(mUsernameView.getText().toString(), ""UTF-8"");
                    String passwordEnc = URLEncoder.encode(mPasswordView.getText().toString(), ""UTF-8"");
                    URI oldUri = new URI(mAccount.getTransportUri());
                    URI uri = new URI(
                        oldUri.getScheme(),
                        usernameEnc + "":"" + passwordEnc,
                        oldUri.getHost(),
                        oldUri.getPort(),
                        null,
                        null,
                        null);
                    mAccount.setTransportUri(uri.toString());
                } catch (UnsupportedEncodingException enc) {
                    // This really shouldn't happen since the encoding is hardcoded to UTF-8
                    Log.e(K9.LOG_TAG, ""Couldn't urlencode username or password."", enc);
                } catch (URISyntaxException use) {
                    /*
                     * If we can't set up the URL we just continue. It's only for
                     * convenience.
                     */
                }


                AccountSetupOutgoing.actionOutgoingSettings(this, mAccount, mMakeDefault);
                finish();
            }
        }
    }

    @Override
    protected void onNext() {
        try {
            int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
            String path = null;
            if (mAccountSchemes[securityType].startsWith(""imap"")) {
                path = ""/"" + mImapPathPrefixView.getText();
            } else if (mAccountSchemes[securityType].startsWith(""webdav"")) {
                path = ""/"" + mWebdavPathPrefixView.getText();
                path = path + ""|"" + mWebdavAuthPathView.getText();
                path = path + ""|"" + mWebdavMailboxPathView.getText();
            }

            final String userInfo;
            String user = mUsernameView.getText().toString();
            String password = mPasswordView.getText().toString();
            String userEnc = URLEncoder.encode(user, ""UTF-8"");
            String passwordEnc = URLEncoder.encode(password, ""UTF-8"");

            if (mAccountSchemes[securityType].startsWith(""imap"")) {
                String authType = ((SpinnerOption)mAuthTypeView.getSelectedItem()).label;
                userInfo = authType + "":"" + userEnc + "":"" + passwordEnc;
            } else {
                String authType = ((SpinnerOption)mAuthTypeView.getSelectedItem()).label;
                if (!authType.equalsIgnoreCase(""plain"")) {
                    userInfo = authType + "":"" + userEnc + "":"" + passwordEnc;
                } else {
                    userInfo = userEnc + "":"" + passwordEnc;
                }
            }
            URI uri = new URI(
                mAccountSchemes[securityType],
                userInfo,
                mServerView.getText().toString(),
                Integer.parseInt(mPortView.getText().toString()),
                path, // path
                null, // query
                null);
            mAccount.setStoreUri(uri.toString());


            mAccount.setCompression(Account.TYPE_MOBILE, mCompressionMobile.isChecked());
            mAccount.setCompression(Account.TYPE_WIFI, mCompressionWifi.isChecked());
            mAccount.setCompression(Account.TYPE_OTHER, mCompressionOther.isChecked());
            mAccount.setSubscribedFoldersOnly(mSubscribedFoldersOnly.isChecked());

            AccountSetupCheckSettings.actionCheckSettings(this, mAccount, true, false);
        } catch (Exception e) {
            failure(e);
        }

    }

    public void onClick(View v) {
        try {
            switch (v.getId()) {
            case R.id.next:
                onNext();
                break;
            }
        } catch (Exception e) {
            failure(e);
        }
    }

    private void failure(Exception use) {
        Log.e(K9.LOG_TAG, ""Failure"", use);
        String toastText = getString(R.string.account_setup_bad_uri, use.getMessage());

        Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
        toast.show();
    }
}
",True,144,0,0,6,56,2,8,L1
80,com.fsck.k9.activity.setup.AccountSetupOutgoing.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.text.method.DigitsKeyListener;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.*;
import android.widget.CompoundButton.OnCheckedChangeListener;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9Activity;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.transport.SmtpTransport;

import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public class AccountSetupOutgoing extends K9Activity implements OnClickListener,
    OnCheckedChangeListener {
    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_MAKE_DEFAULT = ""makeDefault"";

    private static final int smtpPorts[] = {
        587, 465, 465, 587, 587
    };

    private static final String smtpSchemes[] = {
        ""smtp"", ""smtp+ssl"", ""smtp+ssl+"", ""smtp+tls"", ""smtp+tls+""
    };
    /*
    private static final int webdavPorts[] =
    {
        80, 443, 443, 443, 443
    };
    private static final String webdavSchemes[] =
    {
        ""webdav"", ""webdav+ssl"", ""webdav+ssl+"", ""webdav+tls"", ""webdav+tls+""
    };
    */
    private static final String authTypes[] = {
        SmtpTransport.AUTH_AUTOMATIC,
        SmtpTransport.AUTH_LOGIN,
        SmtpTransport.AUTH_PLAIN,
        SmtpTransport.AUTH_CRAM_MD5,
    };

    private EditText mUsernameView;
    private EditText mPasswordView;
    private EditText mServerView;
    private EditText mPortView;
    private CheckBox mRequireLoginView;
    private ViewGroup mRequireLoginSettingsView;
    private Spinner mSecurityTypeView;
    private Spinner mAuthTypeView;
    private Button mNextButton;
    private Account mAccount;
    private boolean mMakeDefault;

    public static void actionOutgoingSettings(Context context, Account account, boolean makeDefault) {
        Intent i = new Intent(context, AccountSetupOutgoing.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
        context.startActivity(i);
    }

    public static void actionEditOutgoingSettings(Context context, Account account) {
        Intent i = new Intent(context, AccountSetupOutgoing.class);
        i.setAction(Intent.ACTION_EDIT);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_outgoing);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        try {
            if (new URI(mAccount.getStoreUri()).getScheme().startsWith(""webdav"")) {
                mAccount.setTransportUri(mAccount.getStoreUri());
                AccountSetupCheckSettings.actionCheckSettings(this, mAccount, false, true);
            }
        } catch (URISyntaxException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }


        mUsernameView = (EditText)findViewById(R.id.account_username);
        mPasswordView = (EditText)findViewById(R.id.account_password);
        mServerView = (EditText)findViewById(R.id.account_server);
        mPortView = (EditText)findViewById(R.id.account_port);
        mRequireLoginView = (CheckBox)findViewById(R.id.account_require_login);
        mRequireLoginSettingsView = (ViewGroup)findViewById(R.id.account_require_login_settings);
        mSecurityTypeView = (Spinner)findViewById(R.id.account_security_type);
        mAuthTypeView = (Spinner)findViewById(R.id.account_auth_type);
        mNextButton = (Button)findViewById(R.id.next);

        mNextButton.setOnClickListener(this);
        mRequireLoginView.setOnCheckedChangeListener(this);

        SpinnerOption securityTypes[] = {
            new SpinnerOption(0, getString(R.string.account_setup_incoming_security_none_label)),
            new SpinnerOption(1,
            getString(R.string.account_setup_incoming_security_ssl_optional_label)),
            new SpinnerOption(2, getString(R.string.account_setup_incoming_security_ssl_label)),
            new SpinnerOption(3,
            getString(R.string.account_setup_incoming_security_tls_optional_label)),
            new SpinnerOption(4, getString(R.string.account_setup_incoming_security_tls_label)),
        };

        SpinnerOption authTypeSpinnerOptions[] = new SpinnerOption[authTypes.length];
        for (int i = 0; i < authTypes.length; i++) {
            authTypeSpinnerOptions[i] = new SpinnerOption(i, authTypes[i]);
        }

        ArrayAdapter<SpinnerOption> securityTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, securityTypes);
        securityTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mSecurityTypeView.setAdapter(securityTypesAdapter);

        ArrayAdapter<SpinnerOption> authTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, authTypeSpinnerOptions);
        authTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mAuthTypeView.setAdapter(authTypesAdapter);

        /*
         * Updates the port when the user changes the security type. This allows
         * us to show a reasonable default which the user can change.
         */
        mSecurityTypeView.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                updatePortFromSecurityType();
            }

            public void onNothingSelected(AdapterView<?> parent) {
            }
        });

        /*
         * Calls validateFields() which enables or disables the Next button
         * based on the fields' validity.
         */
        TextWatcher validationTextWatcher = new TextWatcher() {
            public void afterTextChanged(Editable s) {
                validateFields();
            }

            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
            }

            public void onTextChanged(CharSequence s, int start, int before, int count) {
            }
        };
        mUsernameView.addTextChangedListener(validationTextWatcher);
        mPasswordView.addTextChangedListener(validationTextWatcher);
        mServerView.addTextChangedListener(validationTextWatcher);
        mPortView.addTextChangedListener(validationTextWatcher);

        /*
         * Only allow digits in the port field.
         */
        mPortView.setKeyListener(DigitsKeyListener.getInstance(""0123456789""));

        //FIXME: get Account object again?
        accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mMakeDefault = getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false);

        /*
         * If we're being reloaded we override the original account with the one
         * we saved
         */
        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT)) {
            accountUuid = savedInstanceState.getString(EXTRA_ACCOUNT);
            mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        }

        try {
            URI uri = new URI(mAccount.getTransportUri());
            String username = null;
            String password = null;
            String authType = null;
            if (uri.getUserInfo() != null) {
                String[] userInfoParts = uri.getUserInfo().split("":"");

                username = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                if (userInfoParts.length > 1) {
                    password = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
                if (userInfoParts.length > 2) {
                    authType = userInfoParts[2];
                }
            }

            if (username != null) {
                mUsernameView.setText(username);
                mRequireLoginView.setChecked(true);
            }

            if (password != null) {
                mPasswordView.setText(password);
            }

            if (authType != null) {
                for (int i = 0; i < authTypes.length; i++) {
                    if (authTypes[i].equals(authType)) {
                        SpinnerOption.setSpinnerOptionValue(mAuthTypeView, i);
                    }
                }
            }


            for (int i = 0; i < smtpSchemes.length; i++) {
                if (smtpSchemes[i].equals(uri.getScheme())) {
                    SpinnerOption.setSpinnerOptionValue(mSecurityTypeView, i);
                }
            }

            if (uri.getHost() != null) {
                mServerView.setText(uri.getHost());
            }

            if (uri.getPort() != -1) {
                mPortView.setText(Integer.toString(uri.getPort()));
            } else {
                updatePortFromSecurityType();
            }

            validateFields();
        } catch (Exception e) {
            /*
             * We should always be able to parse our own settings.
             */
            failure(e);
        }

    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putString(EXTRA_ACCOUNT, mAccount.getUuid());
    }

    private void validateFields() {
        mNextButton
        .setEnabled(
            Utility.domainFieldValid(mServerView) &&
            Utility.requiredFieldValid(mPortView) &&
            (!mRequireLoginView.isChecked() ||
             (Utility.requiredFieldValid(mUsernameView) &&
              Utility.requiredFieldValid(mPasswordView))));
        Utility.setCompoundDrawablesAlpha(mNextButton, mNextButton.isEnabled() ? 255 : 128);
    }

    private void updatePortFromSecurityType() {
        int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
        mPortView.setText(Integer.toString(smtpPorts[securityType]));
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (resultCode == RESULT_OK) {
            if (Intent.ACTION_EDIT.equals(getIntent().getAction())) {
                mAccount.save(Preferences.getPreferences(this));
                finish();
            } else {
                AccountSetupOptions.actionOptions(this, mAccount, mMakeDefault);
                finish();
            }
        }
    }

    @Override
    protected void onNext() {
        int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
        URI uri;
        try {
            String usernameEnc = URLEncoder.encode(mUsernameView.getText().toString(), ""UTF-8"");
            String passwordEnc = URLEncoder.encode(mPasswordView.getText().toString(), ""UTF-8"");

            String userInfo = null;
            String authType = ((SpinnerOption)mAuthTypeView.getSelectedItem()).label;
            if (mRequireLoginView.isChecked()) {
                userInfo = usernameEnc + "":"" + passwordEnc + "":"" + authType;
            }
            uri = new URI(smtpSchemes[securityType], userInfo, mServerView.getText().toString(),
                          Integer.parseInt(mPortView.getText().toString()), null, null, null);
            mAccount.setTransportUri(uri.toString());
            AccountSetupCheckSettings.actionCheckSettings(this, mAccount, false, true);
        } catch (UnsupportedEncodingException enc) {
            // This really shouldn't happen since the encoding is hardcoded to UTF-8
            Log.e(K9.LOG_TAG, ""Couldn't urlencode username or password."", enc);
        } catch (Exception e) {
            /*
             * It's unrecoverable if we cannot create a URI from components that
             * we validated to be safe.
             */
            failure(e);
        }

    }

    public void onClick(View v) {
        switch (v.getId()) {
        case R.id.next:
            onNext();
            break;
        }
    }

    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        mRequireLoginSettingsView.setVisibility(isChecked ? View.VISIBLE : View.GONE);
        validateFields();
    }
    private void failure(Exception use) {
        Log.e(K9.LOG_TAG, ""Failure"", use);
        String toastText = getString(R.string.account_setup_bad_uri, use.getMessage());

        Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
        toast.show();
    }
}
",True,144,0,0,6,51,2,9,L1
81,com.fsck.k9.activity.setup.SpinnerHelper.java,"package com.fsck.k9.activity.setup;
/*
 * SpinnerHelper donated to K-9 Mail by Boutique Software
 */

import android.content.Context;
import android.widget.ArrayAdapter;
import android.widget.Spinner;

public class SpinnerHelper {
    public static void initSpinner(Context context, Spinner spinner, int entryRes, int valueRes, String curVal) {
        String[] entryArray = context.getResources().getStringArray(entryRes);
        String[] valueArray = context.getResources().getStringArray(valueRes);
        initSpinner(context, spinner, entryArray, valueArray, curVal);
    }
    public static void initSpinner(Context context, Spinner spinner, String[] entryArray, String[] valueArray, String curVal) {

        if (entryArray.length != valueArray.length) {
            throw new RuntimeException(""Entry and value arrays are of unequal lenght"");
        }

        EntryValue[] entryValues = new EntryValue[entryArray.length];
        int curSelection = 0;
        for (int i = 0; i < entryArray.length; i++) {
            entryValues[i] = new EntryValue(entryArray[i], valueArray[i]);
            if (valueArray[i].equals(curVal)) {
                curSelection = i;
            }
        }

        ArrayAdapter<EntryValue> entryValuesAdapter = new ArrayAdapter<EntryValue>(context, android.R.layout.simple_spinner_item, entryValues);
        entryValuesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        spinner.setAdapter(entryValuesAdapter);
        spinner.setSelection(curSelection);
    }

    public static String getSpinnerValue(Spinner spinner) {
        EntryValue entryValue = (EntryValue)spinner.getSelectedItem();
        if (entryValue != null) {
            return entryValue.getValue();
        } else {
            return null;
        }
    }
    public static String getSpinnerEntry(Spinner spinner) {
        EntryValue entryValue = (EntryValue)spinner.getSelectedItem();
        if (entryValue != null) {
            return entryValue.getEntry();
        } else {
            return null;
        }
    }
    private static class EntryValue {
        final String entry;
        final String value;
        EntryValue(String entry, String value) {
            this.entry = entry;
            this.value = value;
        }
        @Override
        public String toString() {
            return entry;
        }
        public String getEntry() {
            return entry;
        }
        public String getValue() {
            return value;
        }
    }
}
",False,1,0,0,0,0,0,0,I0
82,com.fsck.k9.activity.setup.AccountSetupCheckSettings.java,"
package com.fsck.k9.activity.setup;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Process;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.TextView;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9Activity;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.mail.AuthenticationFailedException;
import com.fsck.k9.mail.CertificateValidationException;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.Transport;
import com.fsck.k9.mail.store.TrustManagerFactory;
import com.fsck.k9.mail.store.WebDavStore;
import com.fsck.k9.mail.filter.Hex;

import java.security.cert.CertificateException;
import java.security.cert.CertificateEncodingException;
import java.security.cert.X509Certificate;
import java.security.NoSuchAlgorithmException;
import java.security.MessageDigest;
import java.util.Collection;
import java.util.List;

/**
 * Checks the given settings to make sure that they can be used to send and
 * receive mail.
 *
 * XXX NOTE: The manifest for this app has it ignore config changes, because
 * it doesn't correctly deal with restarting while its thread is running.
 */
public class AccountSetupCheckSettings extends K9Activity implements OnClickListener {

    public static final int ACTIVITY_REQUEST_CODE = 1;

    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_CHECK_INCOMING = ""checkIncoming"";

    private static final String EXTRA_CHECK_OUTGOING = ""checkOutgoing"";

    private Handler mHandler = new Handler();

    private ProgressBar mProgressBar;

    private TextView mMessageView;

    private Account mAccount;

    private boolean mCheckIncoming;

    private boolean mCheckOutgoing;

    private boolean mCanceled;

    private boolean mDestroyed;

    public static void actionCheckSettings(Activity context, Account account,
                                           boolean checkIncoming, boolean checkOutgoing) {
        Intent i = new Intent(context, AccountSetupCheckSettings.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_CHECK_INCOMING, checkIncoming);
        i.putExtra(EXTRA_CHECK_OUTGOING, checkOutgoing);
        context.startActivityForResult(i, ACTIVITY_REQUEST_CODE);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_check_settings);
        mMessageView = (TextView)findViewById(R.id.message);
        mProgressBar = (ProgressBar)findViewById(R.id.progress);
        ((Button)findViewById(R.id.cancel)).setOnClickListener(this);

        setMessage(R.string.account_setup_check_settings_retr_info_msg);
        mProgressBar.setIndeterminate(true);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mCheckIncoming = getIntent().getBooleanExtra(EXTRA_CHECK_INCOMING, false);
        mCheckOutgoing = getIntent().getBooleanExtra(EXTRA_CHECK_OUTGOING, false);

        new Thread() {
            @Override
            public void run() {
                Store store = null;
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                try {
                    if (mDestroyed) {
                        return;
                    }
                    if (mCanceled) {
                        finish();
                        return;
                    }
                    if (mCheckIncoming) {
                        store = mAccount.getRemoteStore();

                        if (store instanceof WebDavStore) {
                            setMessage(R.string.account_setup_check_settings_authenticate);
                        } else {
                            setMessage(R.string.account_setup_check_settings_check_incoming_msg);
                        }
                        store.checkSettings();

                        if (store instanceof WebDavStore) {
                            setMessage(R.string.account_setup_check_settings_fetch);
                        }
                        MessagingController.getInstance(getApplication()).listFoldersSynchronous(mAccount, true, null);
                        MessagingController.getInstance(getApplication()).synchronizeMailbox(mAccount, mAccount.getInboxFolderName(), null, null);
                    }
                    if (mDestroyed) {
                        return;
                    }
                    if (mCanceled) {
                        finish();
                        return;
                    }
                    if (mCheckOutgoing) {
                        if (!(mAccount.getRemoteStore() instanceof WebDavStore)) {
                            setMessage(R.string.account_setup_check_settings_check_outgoing_msg);
                        }
                        Transport transport = Transport.getInstance(mAccount);
                        transport.close();
                        transport.open();
                        transport.close();
                    }
                    if (mDestroyed) {
                        return;
                    }
                    if (mCanceled) {
                        finish();
                        return;
                    }
                    setResult(RESULT_OK);
                    finish();
                } catch (final AuthenticationFailedException afe) {
                    Log.e(K9.LOG_TAG, ""Error while testing settings"", afe);
                    showErrorDialog(
                        R.string.account_setup_failed_dlg_auth_message_fmt,
                        afe.getMessage() == null ? """" : afe.getMessage());
                } catch (final CertificateValidationException cve) {
                    Log.e(K9.LOG_TAG, ""Error while testing settings"", cve);
                    acceptKeyDialog(
                        R.string.account_setup_failed_dlg_certificate_message_fmt,
                        cve);
                } catch (final Throwable t) {
                    Log.e(K9.LOG_TAG, ""Error while testing settings"", t);
                    showErrorDialog(
                        R.string.account_setup_failed_dlg_server_message_fmt,
                        (t.getMessage() == null ? """" : t.getMessage()));

                }
            }

        }
        .start();
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        mDestroyed = true;
        mCanceled = true;
    }

    private void setMessage(final int resId) {
        mHandler.post(new Runnable() {
            public void run() {
                if (mDestroyed) {
                    return;
                }
                mMessageView.setText(getString(resId));
            }
        });
    }

    private void showErrorDialog(final int msgResId, final Object... args) {
        mHandler.post(new Runnable() {
            public void run() {
                if (mDestroyed) {
                    return;
                }
                mProgressBar.setIndeterminate(false);
                new AlertDialog.Builder(AccountSetupCheckSettings.this)
                .setTitle(getString(R.string.account_setup_failed_dlg_title))
                .setMessage(getString(msgResId, args))
                .setCancelable(true)
                .setNegativeButton(
                    getString(R.string.account_setup_failed_dlg_continue_action),

                new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        mCanceled = false;
                        setResult(RESULT_OK);
                        finish();
                    }
                })
                .setPositiveButton(
                    getString(R.string.account_setup_failed_dlg_edit_details_action),
                new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                })
                .show();
            }
        });
    }
    private void acceptKeyDialog(final int msgResId, final Object... args) {
        mHandler.post(new Runnable() {
            public void run() {
                if (mDestroyed) {
                    return;
                }
                final X509Certificate[] chain = TrustManagerFactory.getLastCertChain();
                String exMessage = ""Unknown Error"";

                Exception ex = ((Exception)args[0]);
                if (ex != null) {
                    if (ex.getCause() != null) {
                        if (ex.getCause().getCause() != null) {
                            exMessage = ex.getCause().getCause().getMessage();

                        } else {
                            exMessage = ex.getCause().getMessage();
                        }
                    } else {
                        exMessage = ex.getMessage();
                    }
                }

                mProgressBar.setIndeterminate(false);
                StringBuffer chainInfo = new StringBuffer(100);
                MessageDigest sha1 = null;
                try {
                    sha1 = MessageDigest.getInstance(""SHA-1"");
                } catch (NoSuchAlgorithmException e) {
                    Log.e(K9.LOG_TAG, ""Error while initializing MessageDigest"", e);
                }
                for (int i = 0; i < chain.length; i++) {
                    // display certificate chain information
                    //TODO: localize this strings
                    chainInfo.append(""Certificate chain["" + i + ""]:\n"");
                    chainInfo.append(""Subject: "" + chain[i].getSubjectDN().toString() + ""\n"");

                    // display SubjectAltNames too
                    // (the user may be mislead into mistrusting a certificate
                    //  by a subjectDN not matching the server even though a
                    //  SubjectAltName matches)
                    try {
                        final Collection < List<? >> subjectAlternativeNames = chain[i].getSubjectAlternativeNames();
                        if (subjectAlternativeNames != null) {
                            // The list of SubjectAltNames may be very long
                            //TODO: localize this string
                            StringBuffer altNamesText = new StringBuffer(""Subject has "" + subjectAlternativeNames.size() + "" alternative names\n"");

                            // we need these for matching
                            String storeURIHost = (Uri.parse(mAccount.getStoreUri())).getHost();
                            String transportURIHost = (Uri.parse(mAccount.getTransportUri())).getHost();

                            for (List<?> subjectAlternativeName : subjectAlternativeNames) {
                                Integer type = (Integer)subjectAlternativeName.get(0);
                                Object value = subjectAlternativeName.get(1);
                                String name = """";
                                switch (type.intValue()) {
                                case 0:
                                    Log.w(K9.LOG_TAG, ""SubjectAltName of type OtherName not supported."");
                                    continue;
                                case 1: // RFC822Name
                                    name = (String)value;
                                    break;
                                case 2:  // DNSName
                                    name = (String)value;
                                    break;
                                case 3:
                                    Log.w(K9.LOG_TAG, ""unsupported SubjectAltName of type x400Address"");
                                    continue;
                                case 4:
                                    Log.w(K9.LOG_TAG, ""unsupported SubjectAltName of type directoryName"");
                                    continue;
                                case 5:
                                    Log.w(K9.LOG_TAG, ""unsupported SubjectAltName of type ediPartyName"");
                                    continue;
                                case 6:  // Uri
                                    name = (String)value;
                                    break;
                                case 7: // ip-address
                                    name = (String)value;
                                    break;
                                default:
                                    Log.w(K9.LOG_TAG, ""unsupported SubjectAltName of unknown type"");
                                    continue;
                                }

                                // if some of the SubjectAltNames match the store or transport -host,
                                // display them
                                if (name.equalsIgnoreCase(storeURIHost) || name.equalsIgnoreCase(transportURIHost)) {
                                    //TODO: localize this string
                                    altNamesText.append(""Subject(alt): "" + name + "",...\n"");
                                } else if (name.startsWith(""*."")) {
                                    if (storeURIHost.endsWith(name.substring(2)) || transportURIHost.endsWith(name.substring(2))) {
                                        //TODO: localize this string
                                        altNamesText.append(""Subject(alt): "" + name + "",...\n"");
                                    }
                                }
                            }
                            chainInfo.append(altNamesText);
                        }
                    } catch (Exception e1) {
                        // don't fail just because of subjectAltNames
                        Log.w(K9.LOG_TAG, ""cannot display SubjectAltNames in dialog"", e1);
                    }

                    chainInfo.append(""Issuer: "" + chain[i].getIssuerDN().toString() + ""\n"");
                    if (sha1 != null) {
                        sha1.reset();
                        try {
                            char[] sha1sum = Hex.encodeHex(sha1.digest(chain[i].getEncoded()));
                            chainInfo.append(""Fingerprint (SHA-1): "" + new String(sha1sum) + ""\n"");
                        } catch (CertificateEncodingException e) {
                            Log.e(K9.LOG_TAG, ""Error while encoding certificate"", e);
                        }
                    }
                }

                new AlertDialog.Builder(AccountSetupCheckSettings.this)
                .setTitle(getString(R.string.account_setup_failed_dlg_invalid_certificate_title))
                //.setMessage(getString(R.string.account_setup_failed_dlg_invalid_certificate)
                .setMessage(getString(msgResId, exMessage)
                            + "" "" + chainInfo.toString()
                           )
                .setCancelable(true)
                .setPositiveButton(
                    getString(R.string.account_setup_failed_dlg_invalid_certificate_accept),
                new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        try {
                            String alias = mAccount.getUuid();
                            if (mCheckIncoming) {
                                alias = alias + "".incoming"";
                            }
                            if (mCheckOutgoing) {
                                alias = alias + "".outgoing"";
                            }
                            TrustManagerFactory.addCertificateChain(alias, chain);
                        } catch (CertificateException e) {
                            showErrorDialog(
                                R.string.account_setup_failed_dlg_certificate_message_fmt,
                                e.getMessage() == null ? """" : e.getMessage());
                        }
                        AccountSetupCheckSettings.actionCheckSettings(AccountSetupCheckSettings.this, mAccount,
                                mCheckIncoming, mCheckOutgoing);
                    }
                })
                .setNegativeButton(
                    getString(R.string.account_setup_failed_dlg_invalid_certificate_reject),
                new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                })
                .show();
            }
        });
    }

    @Override
    public void onActivityResult(int reqCode, int resCode, Intent data) {
        setResult(resCode);
        finish();
    }


    private void onCancel() {
        mCanceled = true;
        setMessage(R.string.account_setup_check_settings_canceling_msg);
    }

    public void onClick(View v) {
        switch (v.getId()) {
        case R.id.cancel:
            onCancel();
            break;
        }
    }
}
",True,144,0,0,6,51,3,12,L1
83,com.fsck.k9.activity.setup.AccountSetupAccountType.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.Toast;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.activity.K9Activity;
import java.net.URI;

/**
 * Prompts the user to select an account type. The account type, along with the
 * passed in email address, password and makeDefault are then passed on to the
 * AccountSetupIncoming activity.
 */
public class AccountSetupAccountType extends K9Activity implements OnClickListener {
    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_MAKE_DEFAULT = ""makeDefault"";

    private Account mAccount;

    private boolean mMakeDefault;

    public static void actionSelectAccountType(Context context, Account account, boolean makeDefault) {
        Intent i = new Intent(context, AccountSetupAccountType.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_account_type);
        ((Button)findViewById(R.id.pop)).setOnClickListener(this);
        ((Button)findViewById(R.id.imap)).setOnClickListener(this);
        ((Button)findViewById(R.id.webdav)).setOnClickListener(this);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mMakeDefault = getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false);
    }

    private void onPop() {
        try {
            URI uri = new URI(mAccount.getStoreUri());
            uri = new URI(""pop3"", uri.getUserInfo(), uri.getHost(), uri.getPort(), null, null, null);
            mAccount.setStoreUri(uri.toString());
            AccountSetupIncoming.actionIncomingSettings(this, mAccount, mMakeDefault);
            finish();
        } catch (Exception use) {
            failure(use);
        }

    }

    private void onImap() {
        try {
            URI uri = new URI(mAccount.getStoreUri());
            uri = new URI(""imap"", uri.getUserInfo(), uri.getHost(), uri.getPort(), null, null, null);
            mAccount.setStoreUri(uri.toString());
            AccountSetupIncoming.actionIncomingSettings(this, mAccount, mMakeDefault);
            finish();
        } catch (Exception use) {
            failure(use);
        }

    }

    private void onWebDav() {
        try {
            URI uri = new URI(mAccount.getStoreUri());
            uri = new URI(""webdav"", uri.getUserInfo(), uri.getHost(), uri.getPort(), null, null, null);
            mAccount.setStoreUri(uri.toString());
            AccountSetupIncoming.actionIncomingSettings(this, mAccount, mMakeDefault);
            finish();
        } catch (Exception use) {
            failure(use);
        }

    }

    public void onClick(View v) {
        switch (v.getId()) {
        case R.id.pop:
            onPop();
            break;
        case R.id.imap:
            onImap();
            break;
        case R.id.webdav:
            onWebDav();
            break;
        }
    }
    private void failure(Exception use) {
        Log.e(K9.LOG_TAG, ""Failure"", use);
        String toastText = getString(R.string.account_setup_bad_uri, use.getMessage());

        Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
        toast.show();
    }
}
",True,144,0,0,6,57,1,5,L1
84,com.fsck.k9.activity.setup.AccountSetupComposition.java,"package com.fsck.k9.activity.setup;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.KeyEvent;
import android.view.View;
import android.widget.CompoundButton;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.RadioButton;
import com.fsck.k9.Account;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.activity.K9Activity;

public class AccountSetupComposition extends K9Activity {

    private static final String EXTRA_ACCOUNT = ""account"";

    private Account mAccount;

    private EditText mAccountSignature;
    private EditText mAccountEmail;
    private EditText mAccountAlwaysBcc;
    private EditText mAccountName;
    private CheckBox mAccountSignatureUse;
    private RadioButton mAccountSignatureBeforeLocation;
    private RadioButton mAccountSignatureAfterLocation;
    private LinearLayout mAccountSignatureLayout;

    public static void actionEditCompositionSettings(Activity context, Account account) {
        Intent i = new Intent(context, AccountSetupComposition.class);
        i.setAction(Intent.ACTION_EDIT);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }


    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        setContentView(R.layout.account_setup_composition);

        /*
         * If we're being reloaded we override the original account with the one
         * we saved
         */
        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT)) {
            accountUuid = savedInstanceState.getString(EXTRA_ACCOUNT);
            mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        }

        mAccountName = (EditText)findViewById(R.id.account_name);
        mAccountName.setText(mAccount.getName());

        mAccountEmail = (EditText)findViewById(R.id.account_email);
        mAccountEmail.setText(mAccount.getEmail());

        mAccountAlwaysBcc = (EditText)findViewById(R.id.account_always_bcc);
        mAccountAlwaysBcc.setText(mAccount.getAlwaysBcc());

        mAccountSignatureLayout = (LinearLayout)findViewById(R.id.account_signature_layout);

        mAccountSignatureUse = (CheckBox)findViewById(R.id.account_signature_use);
        boolean useSignature = mAccount.getSignatureUse();
        mAccountSignatureUse.setChecked(useSignature);
        mAccountSignatureUse.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                if (isChecked) {
                    mAccountSignatureLayout.setVisibility(View.VISIBLE);
                    mAccountSignature.setText(mAccount.getSignature());
                    boolean isSignatureBeforeQuotedText = mAccount.isSignatureBeforeQuotedText();
                    mAccountSignatureBeforeLocation.setChecked(isSignatureBeforeQuotedText);
                    mAccountSignatureAfterLocation.setChecked(!isSignatureBeforeQuotedText);
                } else {
                    mAccountSignatureLayout.setVisibility(View.GONE);
                }
            }
        });

        mAccountSignature = (EditText)findViewById(R.id.account_signature);

        mAccountSignatureBeforeLocation = (RadioButton)findViewById(R.id.account_signature_location_before_quoted_text);
        mAccountSignatureAfterLocation = (RadioButton)findViewById(R.id.account_signature_location_after_quoted_text);

        if (useSignature) {
            mAccountSignature.setText(mAccount.getSignature());

            boolean isSignatureBeforeQuotedText = mAccount.isSignatureBeforeQuotedText();
            mAccountSignatureBeforeLocation.setChecked(isSignatureBeforeQuotedText);
            mAccountSignatureAfterLocation.setChecked(!isSignatureBeforeQuotedText);
        } else {
            mAccountSignatureLayout.setVisibility(View.GONE);
        }
    }

    @Override
    public void onResume() {
        super.onResume();
        //mAccount.refresh(Preferences.getPreferences(this));
    }

    private void saveSettings() {
        mAccount.setEmail(mAccountEmail.getText().toString());
        mAccount.setAlwaysBcc(mAccountAlwaysBcc.getText().toString());
        mAccount.setName(mAccountName.getText().toString());
        mAccount.setSignatureUse(mAccountSignatureUse.isChecked());
        if (mAccountSignatureUse.isChecked()) {
            mAccount.setSignature(mAccountSignature.getText().toString());
            boolean isSignatureBeforeQuotedText = mAccountSignatureBeforeLocation.isChecked();
            mAccount.setSignatureBeforeQuotedText(isSignatureBeforeQuotedText);
        }

        mAccount.save(Preferences.getPreferences(this));
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            saveSettings();
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putSerializable(EXTRA_ACCOUNT, mAccount.getUuid());
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        mAccount.save(Preferences.getPreferences(this));
        finish();
    }
}
",False,144,0,0,7,40,1,3,L1
85,com.fsck.k9.activity.setup.AccountSetupBasics.java,"
package com.fsck.k9.activity.setup;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.XmlResourceParser;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9Activity;
import com.fsck.k9.helper.Utility;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLEncoder;

/**
 * Prompts the user for the email address and password. Also prompts for
 * ""Use this account as default"" if this is the 2nd+ account being set up.
 * Attempts to lookup default settings for the domain the user specified. If the
 * domain is known the settings are handed off to the AccountSetupCheckSettings
 * activity. If no settings are found the settings are handed off to the
 * AccountSetupAccountType activity.
 */
public class AccountSetupBasics extends K9Activity
    implements OnClickListener, TextWatcher {
    private final static String EXTRA_ACCOUNT = ""com.fsck.k9.AccountSetupBasics.account"";
    private final static int DIALOG_NOTE = 1;
    private final static String STATE_KEY_PROVIDER =
        ""com.fsck.k9.AccountSetupBasics.provider"";

    private Preferences mPrefs;
    private EditText mEmailView;
    private EditText mPasswordView;
    private CheckBox mDefaultView;
    private Button mNextButton;
    private Button mManualSetupButton;
    private Account mAccount;
    private Provider mProvider;

    private EmailAddressValidator mEmailValidator = new EmailAddressValidator();

    public static void actionNewAccount(Context context) {
        Intent i = new Intent(context, AccountSetupBasics.class);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_basics);
        mPrefs = Preferences.getPreferences(this);
        mEmailView = (EditText)findViewById(R.id.account_email);
        mPasswordView = (EditText)findViewById(R.id.account_password);
        mDefaultView = (CheckBox)findViewById(R.id.account_default);
        mNextButton = (Button)findViewById(R.id.next);
        mManualSetupButton = (Button)findViewById(R.id.manual_setup);

        mNextButton.setOnClickListener(this);
        mManualSetupButton.setOnClickListener(this);

        mEmailView.addTextChangedListener(this);
        mPasswordView.addTextChangedListener(this);

        if (mPrefs.getAccounts().length > 0) {
            mDefaultView.setVisibility(View.VISIBLE);
        }

        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT)) {
            String accountUuid = savedInstanceState.getString(EXTRA_ACCOUNT);
            mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        }

        if (savedInstanceState != null && savedInstanceState.containsKey(STATE_KEY_PROVIDER)) {
            mProvider = (Provider)savedInstanceState.getSerializable(STATE_KEY_PROVIDER);
        }
    }

    @Override
    public void onResume() {
        super.onResume();
        validateFields();
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        if (mAccount != null) {
            outState.putString(EXTRA_ACCOUNT, mAccount.getUuid());
        }
        if (mProvider != null) {
            outState.putSerializable(STATE_KEY_PROVIDER, mProvider);
        }
    }

    public void afterTextChanged(Editable s) {
        validateFields();
    }

    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
    }

    public void onTextChanged(CharSequence s, int start, int before, int count) {
    }

    private void validateFields() {
        String email = mEmailView.getText().toString();
        boolean valid = Utility.requiredFieldValid(mEmailView)
                        && Utility.requiredFieldValid(mPasswordView)
                        && mEmailValidator.isValidAddressOnly(email);

        mNextButton.setEnabled(valid);
        mManualSetupButton.setEnabled(valid);
        /*
         * Dim the next button's icon to 50% if the button is disabled.
         * TODO this can probably be done with a stateful drawable. Check into it.
         * android:state_enabled
         */
        Utility.setCompoundDrawablesAlpha(mNextButton, mNextButton.isEnabled() ? 255 : 128);
    }

    private String getOwnerName() {
        String name = null;
        try {
            name = getDefaultAccountName();
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Could not get default account name"", e);
        }

        if (name == null) {
            name = """";
        }
        return name;
    }

    private String getDefaultAccountName() {
        String name = null;
        Account account = Preferences.getPreferences(this).getDefaultAccount();
        if (account != null) {
            name = account.getName();
        }
        return name;
    }

    @Override
    public Dialog onCreateDialog(int id) {
        if (id == DIALOG_NOTE) {
            if (mProvider != null && mProvider.note != null) {
                return new AlertDialog.Builder(this)
                       .setMessage(mProvider.note)
                       .setPositiveButton(
                           getString(R.string.okay_action),
                new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finishAutoSetup();
                    }
                })
                       .setNegativeButton(
                           getString(R.string.cancel_action),
                           null)
                       .create();
            }
        }
        return null;
    }

    private void finishAutoSetup() {
        String email = mEmailView.getText().toString();
        String password = mPasswordView.getText().toString();
        String[] emailParts = splitEmail(email);
        String user = emailParts[0];
        String domain = emailParts[1];
        URI incomingUri = null;
        URI outgoingUri = null;
        try {
            String userEnc = URLEncoder.encode(user, ""UTF-8"");
            String passwordEnc = URLEncoder.encode(password, ""UTF-8"");

            String incomingUsername = mProvider.incomingUsernameTemplate;
            incomingUsername = incomingUsername.replaceAll(""\\$email"", email);
            incomingUsername = incomingUsername.replaceAll(""\\$user"", userEnc);
            incomingUsername = incomingUsername.replaceAll(""\\$domain"", domain);

            URI incomingUriTemplate = mProvider.incomingUriTemplate;
            incomingUri = new URI(incomingUriTemplate.getScheme(), incomingUsername + "":""
                                  + passwordEnc, incomingUriTemplate.getHost(), incomingUriTemplate.getPort(), null,
                                  null, null);

            String outgoingUsername = mProvider.outgoingUsernameTemplate;

            URI outgoingUriTemplate = mProvider.outgoingUriTemplate;


            if (outgoingUsername != null) {
                outgoingUsername = outgoingUsername.replaceAll(""\\$email"", email);
                outgoingUsername = outgoingUsername.replaceAll(""\\$user"", userEnc);
                outgoingUsername = outgoingUsername.replaceAll(""\\$domain"", domain);
                outgoingUri = new URI(outgoingUriTemplate.getScheme(), outgoingUsername + "":""
                                      + passwordEnc, outgoingUriTemplate.getHost(), outgoingUriTemplate.getPort(), null,
                                      null, null);

            } else {
                outgoingUri = new URI(outgoingUriTemplate.getScheme(),
                                      null, outgoingUriTemplate.getHost(), outgoingUriTemplate.getPort(), null,
                                      null, null);


            }
            mAccount = Preferences.getPreferences(this).newAccount();
            mAccount.setName(getOwnerName());
            mAccount.setEmail(email);
            mAccount.setStoreUri(incomingUri.toString());
            mAccount.setTransportUri(outgoingUri.toString());
            mAccount.setDraftsFolderName(getString(R.string.special_mailbox_name_drafts));
            mAccount.setTrashFolderName(getString(R.string.special_mailbox_name_trash));
            mAccount.setArchiveFolderName(getString(R.string.special_mailbox_name_archive));
            mAccount.setSpamFolderName(getString(R.string.special_mailbox_name_spam));
            mAccount.setSentFolderName(getString(R.string.special_mailbox_name_sent));
            AccountSetupCheckSettings.actionCheckSettings(this, mAccount, true, true);
        } catch (UnsupportedEncodingException enc) {
            // This really shouldn't happen since the encoding is hardcoded to UTF-8
            Log.e(K9.LOG_TAG, ""Couldn't urlencode username or password."", enc);
        } catch (URISyntaxException use) {
            /*
             * If there is some problem with the URI we give up and go on to
             * manual setup.
             */
            onManualSetup();
        }
    }

    @Override
    protected void onNext() {
        String email = mEmailView.getText().toString();
        String[] emailParts = splitEmail(email);
        String domain = emailParts[1];
        mProvider = findProviderForDomain(domain);
        if (mProvider == null) {
            /*
             * We don't have default settings for this account, start the manual
             * setup process.
             */
            onManualSetup();
            return;
        }

        if (mProvider.note != null) {
            showDialog(DIALOG_NOTE);
        } else {
            finishAutoSetup();
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (resultCode == RESULT_OK) {
            mAccount.setDescription(mAccount.getEmail());
            mAccount.save(Preferences.getPreferences(this));
            if (mDefaultView.isChecked()) {
                Preferences.getPreferences(this).setDefaultAccount(mAccount);
            }
            K9.setServicesEnabled(this);
            AccountSetupNames.actionSetNames(this, mAccount);
            finish();
        }
    }

    private void onManualSetup() {
        String email = mEmailView.getText().toString();
        String password = mPasswordView.getText().toString();
        String[] emailParts = splitEmail(email);
        String user = emailParts[0];
        String domain = emailParts[1];

        mAccount = Preferences.getPreferences(this).newAccount();
        mAccount.setName(getOwnerName());
        mAccount.setEmail(email);
        try {
            String userEnc = URLEncoder.encode(user, ""UTF-8"");
            String passwordEnc = URLEncoder.encode(password, ""UTF-8"");

            URI uri = new URI(""placeholder"", userEnc + "":"" + passwordEnc, ""mail."" + domain, -1, null,
                              null, null);
            mAccount.setStoreUri(uri.toString());
            mAccount.setTransportUri(uri.toString());
        } catch (UnsupportedEncodingException enc) {
            // This really shouldn't happen since the encoding is hardcoded to UTF-8
            Log.e(K9.LOG_TAG, ""Couldn't urlencode username or password."", enc);
        } catch (URISyntaxException use) {
            /*
             * If we can't set up the URL we just continue. It's only for
             * convenience.
             */
        }
        mAccount.setDraftsFolderName(getString(R.string.special_mailbox_name_drafts));
        mAccount.setTrashFolderName(getString(R.string.special_mailbox_name_trash));
        mAccount.setSentFolderName(getString(R.string.special_mailbox_name_sent));

        AccountSetupAccountType.actionSelectAccountType(this, mAccount, mDefaultView.isChecked());
        finish();
    }

    public void onClick(View v) {
        switch (v.getId()) {
        case R.id.next:
            onNext();
            break;
        case R.id.manual_setup:
            onManualSetup();
            break;
        }
    }

    /**
     * Attempts to get the given attribute as a String resource first, and if it fails
     * returns the attribute as a simple String value.
     * @param xml
     * @param name
     * @return
     */
    private String getXmlAttribute(XmlResourceParser xml, String name) {
        int resId = xml.getAttributeResourceValue(null, name, 0);
        if (resId == 0) {
            return xml.getAttributeValue(null, name);
        } else {
            return getString(resId);
        }
    }

    private Provider findProviderForDomain(String domain) {
        try {
            XmlResourceParser xml = getResources().getXml(R.xml.providers);
            int xmlEventType;
            Provider provider = null;
            while ((xmlEventType = xml.next()) != XmlResourceParser.END_DOCUMENT) {
                if (xmlEventType == XmlResourceParser.START_TAG
                        && ""provider"".equals(xml.getName())
                        && domain.equalsIgnoreCase(getXmlAttribute(xml, ""domain""))) {
                    provider = new Provider();
                    provider.id = getXmlAttribute(xml, ""id"");
                    provider.label = getXmlAttribute(xml, ""label"");
                    provider.domain = getXmlAttribute(xml, ""domain"");
                    provider.note = getXmlAttribute(xml, ""note"");
                } else if (xmlEventType == XmlResourceParser.START_TAG
                           && ""incoming"".equals(xml.getName())
                           && provider != null) {
                    provider.incomingUriTemplate = new URI(getXmlAttribute(xml, ""uri""));
                    provider.incomingUsernameTemplate = getXmlAttribute(xml, ""username"");
                } else if (xmlEventType == XmlResourceParser.START_TAG
                           && ""outgoing"".equals(xml.getName())
                           && provider != null) {
                    provider.outgoingUriTemplate = new URI(getXmlAttribute(xml, ""uri""));
                    provider.outgoingUsernameTemplate = getXmlAttribute(xml, ""username"");
                } else if (xmlEventType == XmlResourceParser.END_TAG
                           && ""provider"".equals(xml.getName())
                           && provider != null) {
                    return provider;
                }
            }
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Error while trying to load provider settings."", e);
        }
        return null;
    }

    private String[] splitEmail(String email) {
        String[] retParts = new String[2];
        String[] emailParts = email.split(""@"");
        retParts[0] = (emailParts.length > 0) ? emailParts[0] : """";
        retParts[1] = (emailParts.length > 1) ? emailParts[1] : """";
        return retParts;
    }

    static class Provider implements Serializable {
        private static final long serialVersionUID = 8511656164616538989L;

        public String id;

        public String label;

        public String domain;

        public URI incomingUriTemplate;

        public String incomingUsernameTemplate;

        public URI outgoingUriTemplate;

        public String outgoingUsernameTemplate;

        public String note;
    }
}
",True,144,0,0,6,53,1,9,L1
86,com.fsck.k9.remotecontrol.K9RemoteControl.java,"package com.fsck.k9.remotecontrol;


import android.app.Activity;
import android.content.Context;
import android.content.Intent;

/**
 * Utillity definitions for Android applications to control the behavior of K-9 Mail.  All such applications must declare the following permission:
 * <uses-permission android:name=""com.fsck.k9.permission.REMOTE_CONTROL""/>
 * in their AndroidManifest.xml  In addition, all applications sending remote control messages to K-9 Mail must
 *
 * An application that wishes to act on a particular Account in K-9 needs to fetch the list of configured Accounts by broadcasting an
 * {@link Intent} using K9_REQUEST_ACCOUNTS as the Action.  The broadcast must be made using the {@link ContextWrapper}
 * sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver,
 * Handler scheduler, int initialCode, String initialData, Bundle initialExtras).sendOrderedBroadcast}
 * method in order to receive the list of Account UUIDs and descriptions that K-9 will provide.
 *
 * @author Daniel I. Applebaum
 *
 */
public class K9RemoteControl {
    /**
     * Permission that every application sending a broadcast to K-9 for Remote Control purposes should send on every broadcast.
     * Prevent other applications from intercepting the broadcasts.
     */
    public final static String K9_REMOTE_CONTROL_PERMISSION = ""com.fsck.k9.permission.REMOTE_CONTROL"";
    /**
     * {@link Intent} Action to be sent to K-9 using {@link ContextWrapper.sendOrderedBroadcast} in order to fetch the list of configured Accounts.
     * The responseData will contain two String[] with keys K9_ACCOUNT_UUIDS and K9_ACCOUNT_DESCRIPTIONS
     */
    public final static String K9_REQUEST_ACCOUNTS = ""com.fsck.k9.K9RemoteControl.requestAccounts"";
    public final static String K9_ACCOUNT_UUIDS = ""com.fsck.k9.K9RemoteControl.accountUuids"";
    public final static String K9_ACCOUNT_DESCRIPTIONS = ""com.fsck.k9.K9RemoteControl.accountDescriptions"";

    /**
     * The {@link {@link Intent}} Action to set in order to cause K-9 to check mail.  (Not yet implemented)
     */
    //public final static String K9_CHECK_MAIL = ""com.fsck.k9.K9RemoteControl.checkMail"";

    /**
     * The {@link {@link Intent}} Action to set when remotely changing K-9 Mail settings
     */
    public final static String K9_SET = ""com.fsck.k9.K9RemoteControl.set"";
    /**
     * The key of the {@link Intent} Extra to set to hold the UUID of a single Account's settings to change.  Used only if K9_ALL_ACCOUNTS
     * is absent or false.
     */
    public final static String K9_ACCOUNT_UUID = ""com.fsck.k9.K9RemoteControl.accountUuid"";
    /**
     * The key of the {@link Intent} Extra to set to control if the settings will apply to all Accounts, or to the one
     * specified with K9_ACCOUNT_UUID
     */
    public final static String K9_ALL_ACCOUNTS = ""com.fsck.k9.K9RemoteControl.allAccounts"";

    public final static String K9_ENABLED = ""true"";
    public final static String K9_DISABLED = ""false"";

    /*
     * Key for the {@link Intent} Extra for controlling whether notifications will be generated for new unread mail.
     * Acceptable values are K9_ENABLED and K9_DISABLED
     */
    public final static String K9_NOTIFICATION_ENABLED = ""com.fsck.k9.K9RemoteControl.notificationEnabled"";
    /*
     * Key for the {@link Intent} Extra for controlling whether K-9 will sound the ringtone for new unread mail.
     * Acceptable values are K9_ENABLED and K9_DISABLED
     */
    public final static String K9_RING_ENABLED = ""com.fsck.k9.K9RemoteControl.ringEnabled"";
    /*
     * Key for the {@link Intent} Extra for controlling whether K-9 will activate the vibrator for new unread mail.
     * Acceptable values are K9_ENABLED and K9_DISABLED
     */
    public final static String K9_VIBRATE_ENABLED = ""com.fsck.k9.K9RemoteControl.vibrateEnabled"";

    public final static String K9_FOLDERS_NONE = ""NONE"";
    public final static String K9_FOLDERS_ALL = ""ALL"";
    public final static String K9_FOLDERS_FIRST_CLASS = ""FIRST_CLASS"";
    public final static String K9_FOLDERS_FIRST_AND_SECOND_CLASS = ""FIRST_AND_SECOND_CLASS"";
    public final static String K9_FOLDERS_NOT_SECOND_CLASS = ""NOT_SECOND_CLASS"";
    /**
     * Key for the {@link Intent} Extra to set for controlling which folders to be synchronized with Push.
     * Acceptable values are K9_FOLDERS_ALL, K9_FOLDERS_FIRST_CLASS, K9_FOLDERS_FIRST_AND_SECOND_CLASS,
     * K9_FOLDERS_NOT_SECOND_CLASS, K9_FOLDERS_NONE
     */
    public final static String K9_PUSH_CLASSES = ""com.fsck.k9.K9RemoteControl.pushClasses"";
    /**
     * Key for the {@link Intent} Extra to set for controlling which folders to be synchronized with Poll.
     * Acceptable values are K9_FOLDERS_ALL, K9_FOLDERS_FIRST_CLASS, K9_FOLDERS_FIRST_AND_SECOND_CLASS,
     * K9_FOLDERS_NOT_SECOND_CLASS, K9_FOLDERS_NONE
     */
    public final static String K9_POLL_CLASSES = ""com.fsck.k9.K9RemoteControl.pollClasses"";

    public final static String[] K9_POLL_FREQUENCIES = { ""-1"", ""1"", ""5"", ""10"", ""15"", ""30"", ""60"", ""120"", ""180"", ""360"", ""720"", ""1440""};
    /**
     * Key for the {@link Intent} Extra to set with the desired poll frequency.  The value is a String representing a number of minutes.
     * Acceptable values are available in K9_POLL_FREQUENCIES
     */
    public final static String K9_POLL_FREQUENCY = ""com.fsck.k9.K9RemoteControl.pollFrequency"";

    /**
     * Key for the {@link Intent} Extra to set for controlling K-9's global ""Background sync"" setting.
     * Acceptable values are K9_BACKGROUND_OPERATIONS_ALWAYS, K9_BACKGROUND_OPERATIONS_NEVER
     * K9_BACKGROUND_OPERATIONS_WHEN_CHECKED
     */
    public final static String K9_BACKGROUND_OPERATIONS = ""com.fsck.k9.K9RemoteControl.backgroundOperations"";
    public final static String K9_BACKGROUND_OPERATIONS_WHEN_CHECKED = ""WHEN_CHECKED"";
    public final static String K9_BACKGROUND_OPERATIONS_ALWAYS = ""ALWAYS"";
    public final static String K9_BACKGROUND_OPERATIONS_NEVER = ""NEVER"";
    public final static String K9_BACKGROUND_OPERATIONS_WHEN_CHECKED_AUTO_SYNC = ""WHEN_CHECKED_AUTO_SYNC"";

    /**
     * Key for the {@link Intent} Extra to set for controlling which display theme K-9 will use.  Acceptable values are
     * K9_THEME_LIGHT, K9_THEME_DARK
     */
    public final static String K9_THEME = ""com.fsck.k9.K9RemoteControl.theme"";
    public final static String K9_THEME_LIGHT = ""LIGHT"";
    public final static String K9_THEME_DARK = ""DARK"";

    protected static String LOG_TAG = ""K9RemoteControl"";

    public static void set(Context context, Intent broadcastIntent) {
        broadcastIntent.setAction(K9RemoteControl.K9_SET);
        context.sendBroadcast(broadcastIntent, K9RemoteControl.K9_REMOTE_CONTROL_PERMISSION);
    }

    public static void fetchAccounts(Context context, K9AccountReceptor receptor) {
        Intent accountFetchIntent = new Intent();
        accountFetchIntent.setAction(K9RemoteControl.K9_REQUEST_ACCOUNTS);
        AccountReceiver receiver = new AccountReceiver(receptor);
        context.sendOrderedBroadcast(accountFetchIntent, K9RemoteControl.K9_REMOTE_CONTROL_PERMISSION, receiver, null, Activity.RESULT_OK, null, null);
    }

}


",False,5,1,2,1,2,3,2,L2
87,com.fsck.k9.remotecontrol.K9AccountReceptor.java,"package com.fsck.k9.remotecontrol;
/**
 *
 * @author Daniel I. Applebaum
 * The interface to implement in order to accept the arrays containing the UUIDs and descriptions of
 * the accounts configured in K-9 Mail.  Should be passed to fetchAccounts(Context, K9AccountReceptor)
 */
public interface K9AccountReceptor {
    public void accounts(String[] uuids, String[] descriptions);
}",False,5,2,2,0,0,2,0,L2
88,com.fsck.k9.remotecontrol.AccountReceiver.java,"package com.fsck.k9.remotecontrol;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

class AccountReceiver extends BroadcastReceiver {
    K9AccountReceptor receptor = null;

    protected AccountReceiver(K9AccountReceptor nReceptor) {
        receptor = nReceptor;
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        if (K9RemoteControl.K9_REQUEST_ACCOUNTS.equals(intent.getAction())) {
            Bundle bundle = getResultExtras(false);
            if (bundle == null) {
                Log.w(K9RemoteControl.LOG_TAG, ""Response bundle is empty"");
                return;
            }
            receptor.accounts(bundle.getStringArray(K9RemoteControl.K9_ACCOUNT_UUIDS), bundle.getStringArray(K9RemoteControl.K9_ACCOUNT_DESCRIPTIONS));
        }
    }

}
",False,3,0,0,1,2,1,2,L2
89,com.fsck.k9.provider.MessageProvider.java,"package com.fsck.k9.provider;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.Semaphore;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.UriMatcher;
import android.database.CharArrayBuffer;
import android.database.ContentObserver;
import android.database.CrossProcessCursor;
import android.database.Cursor;
import android.database.CursorWindow;
import android.database.DataSetObserver;
import android.database.MatrixCursor;
import android.net.Uri;
import android.os.Bundle;
import android.provider.BaseColumns;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.AccountStats;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.SearchAccount;
import com.fsck.k9.activity.FolderInfoHolder;
import com.fsck.k9.activity.MessageInfoHolder;
import com.fsck.k9.activity.MessageList;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.helper.MessageHelper;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.store.LocalStore;

public class MessageProvider extends ContentProvider {

    public static interface MessageColumns extends BaseColumns {
        /**
         * The number of milliseconds since Jan. 1, 1970, midnight GMT.
         *
         * <P>Type: INTEGER (long)</P>
         */
        String SEND_DATE = ""date"";

        /**
         * <P>Type: TEXT</P>
         */
        String SENDER = ""sender"";

        /**
         * <P>Type: TEXT</P>
         */
        String SUBJECT = ""subject"";

        /**
         * <P>Type: TEXT</P>
         */
        String PREVIEW = ""preview"";

        /**
         * <P>Type: BOOLEAN</P>
         */
        String UNREAD = ""unread"";

        String ACCOUNT = ""account"";
        String URI = ""uri"";
        String DELETE_URI = ""delUri"";

        /**
         * @deprecated the field value is misnamed/misleading - present for compatibility purpose only. To be removed.
         */
        @Deprecated
        String INCREMENT = ""id"";
    }

    protected static interface QueryHandler {
        /**
         * The path this instance is able to respond to.
         *
         * @return Never <code>null</code>.
         */
        String getPath();

        /**
         * @param uri
         * @param projection
         * @param selection
         * @param selectionArgs
         * @param sortOrder
         * @return
         * @throws Exception
         * @see {@link ContentProvider#query(Uri, String[], String, String[], String)}
         */
        Cursor query(Uri uri, String[] projection,
                     String selection, String[] selectionArgs, String sortOrder) throws Exception;
    }

    /**
     * Extracts a value from an object.
     *
     * @param <T>
     * @param <K>
     */
    public static interface FieldExtractor<T, K> {
        K getField(T source);
    }

    /**
     * Extracts the {@link LocalStore.LocalMessage#getId() ID} from the given
     * {@link MessageInfoHolder}. The underlying {@link Message} is expected to
     * be a {@link LocalStore.LocalMessage}.
     */
    public static class IdExtractor implements FieldExtractor<MessageInfoHolder, Long> {
        @Override
        public Long getField(final MessageInfoHolder source) {
            return source.message.getId();
        }
    }
    public static class CountExtractor<T> implements FieldExtractor<T, Integer> {
        private Integer mCount;
        public CountExtractor(final int count) {
            mCount = count;
        }
        @Override
        public Integer getField(final T source) {
            return mCount;
        }
    }
    public static class SubjectExtractor implements FieldExtractor<MessageInfoHolder, String> {
        @Override
        public String getField(final MessageInfoHolder source) {
            return source.message.getSubject();
        }
    }
    public static class SendDateExtractor implements FieldExtractor<MessageInfoHolder, Long> {
        @Override
        public Long getField(final MessageInfoHolder source) {
            return source.message.getSentDate().getTime();
        }
    }
    public static class PreviewExtractor implements FieldExtractor<MessageInfoHolder, String> {
        @Override
        public String getField(final MessageInfoHolder source) {
            return source.message.getPreview();
        }
    }
    public static class UriExtractor implements FieldExtractor<MessageInfoHolder, String> {
        @Override
        public String getField(final MessageInfoHolder source) {
            return source.uri;
        }
    }
    public static class DeleteUriExtractor implements FieldExtractor<MessageInfoHolder, String> {
        @Override
        public String getField(final MessageInfoHolder source) {
            final Message message = source.message;
            return CONTENT_URI + ""/delete_message/""
                   + message.getFolder().getAccount().getAccountNumber() + ""/""
                   + message.getFolder().getName() + ""/"" + message.getUid();
        }
    }
    public static class SenderExtractor implements FieldExtractor<MessageInfoHolder, CharSequence> {
        @Override
        public CharSequence getField(final MessageInfoHolder source) {
            return source.sender;
        }
    }
    public static class AccountExtractor implements FieldExtractor<MessageInfoHolder, String> {
        @Override
        public String getField(final MessageInfoHolder source) {
            return source.message.getFolder().getAccount().getDescription();
        }
    }

    public static class UnreadExtractor implements FieldExtractor<MessageInfoHolder, Boolean> {
        @Override
        public Boolean getField(final MessageInfoHolder source) {
            return Boolean.valueOf(!source.read); // avoid autoboxing
        }
    }

    /**
     * @deprecated having an incremential value has no real interest,
     *             implemented for compatibility only
     */
    @Deprecated
    // TODO remove
    public static class IncrementExtractor implements FieldExtractor<MessageInfoHolder, Integer> {
        private int count = 0;
        @Override
        public Integer getField(final MessageInfoHolder source) {
            return count++;
        }
    }

    /**
     * Retrieve messages from the integrated inbox.
     */
    protected class MessagesQueryHandler implements QueryHandler {

        @Override
        public String getPath() {
            return ""inbox_messages/"";
        }

        @Override
        public Cursor query(final Uri uri, final String[] projection, final String selection,
                            final String[] selectionArgs, final String sortOrder) throws Exception {
            return getMessages(projection);
        }

        /**
         * @param projection
         *            Projection to use. If <code>null</code>, use the default
         *            projection.
         * @return Never <code>null</code>.
         * @throws InterruptedException
         */
        protected MatrixCursor getMessages(final String[] projection) throws InterruptedException {
            final BlockingQueue<List<MessageInfoHolder>> queue = new SynchronousQueue<List<MessageInfoHolder>>();

            // new code for integrated inbox, only execute this once as it will be processed afterwards via the listener
            final SearchAccount integratedInboxAccount = new SearchAccount(getContext(), true, null, null);
            final MessagingController msgController = MessagingController.getInstance(K9.app);

            msgController.searchLocalMessages(integratedInboxAccount, null,
                                              new MesssageInfoHolderRetrieverListener(queue));

            final List<MessageInfoHolder> holders = queue.take();

            // TODO add sort order parameter
            Collections.sort(holders, new MessageList.ReverseComparator<MessageInfoHolder>(
                                 new MessageList.DateComparator()));

            final String[] projectionToUse;
            if (projection == null) {
                projectionToUse = DEFAULT_MESSAGE_PROJECTION;
            } else {
                projectionToUse = projection;
            }

            final LinkedHashMap < String, FieldExtractor < MessageInfoHolder, ? >> extractors = resolveMessageExtractors(projectionToUse, holders.size());
            final int fieldCount = extractors.size();

            final String[] actualProjection = extractors.keySet().toArray(new String[fieldCount]);
            final MatrixCursor cursor = new MatrixCursor(actualProjection);

            for (final MessageInfoHolder holder : holders) {
                final Object[] o = new Object[fieldCount];

                int i = 0;
                for (final FieldExtractor < MessageInfoHolder, ? > extractor : extractors.values()) {
                    o[i] = extractor.getField(holder);
                    i += 1;
                }

                cursor.addRow(o);
            }

            return cursor;
        }

        // returns LinkedHashMap (rather than Map) to emphasize the inner element ordering
        protected LinkedHashMap < String, FieldExtractor < MessageInfoHolder, ? >> resolveMessageExtractors(final String[] projection, int count) {
            final LinkedHashMap < String, FieldExtractor < MessageInfoHolder, ? >> extractors = new LinkedHashMap < String, FieldExtractor < MessageInfoHolder, ? >> ();

            for (final String field : projection) {
                if (extractors.containsKey(field)) {
                    continue;
                }
                if (MessageColumns._ID.equals(field)) {
                    extractors.put(field, new IdExtractor());
                } else if (MessageColumns._COUNT.equals(field)) {
                    extractors.put(field, new CountExtractor<MessageInfoHolder>(count));
                } else if (MessageColumns.SUBJECT.equals(field)) {
                    extractors.put(field, new SubjectExtractor());
                } else if (MessageColumns.SENDER.equals(field)) {
                    extractors.put(field, new SenderExtractor());
                } else if (MessageColumns.SEND_DATE.equals(field)) {
                    extractors.put(field, new SendDateExtractor());
                } else if (MessageColumns.PREVIEW.equals(field)) {
                    extractors.put(field, new PreviewExtractor());
                } else if (MessageColumns.URI.equals(field)) {
                    extractors.put(field, new UriExtractor());
                } else if (MessageColumns.DELETE_URI.equals(field)) {
                    extractors.put(field, new DeleteUriExtractor());
                } else if (MessageColumns.ACCOUNT.equals(field)) {
                    extractors.put(field, new AccountExtractor());
                } else if (MessageColumns.UNREAD.equals(field)) {
                    extractors.put(field, new UnreadExtractor());
                } else if (MessageColumns.INCREMENT.equals(field)) {
                    extractors.put(field, new IncrementExtractor());
                }
            }
            return extractors;
        }

    }

    /**
     * Retrieve the account list.
     */
    protected class AccountsQueryHandler implements QueryHandler {

        @Override
        public String getPath() {
            return ""accounts"";
        }

        @Override
        public Cursor query(final Uri uri, String[] projection, String selection,
                            String[] selectionArgs, String sortOrder) throws Exception {
            return getAllAccounts();
        }

        public Cursor getAllAccounts() {
            String[] projection = new String[] { ""accountNumber"", ""accountName"" };

            MatrixCursor ret = new MatrixCursor(projection);

            for (Account account : Preferences.getPreferences(getContext()).getAccounts()) {
                Object[] values = new Object[2];
                values[0] = account.getAccountNumber();
                values[1] = account.getDescription();
                ret.addRow(values);
            }

            return ret;
        }

    }

    /**
     * Retrieve the unread message count for a given account specified by its
     * {@link Account#getAccountNumber() number}.
     */
    protected class UnreadQueryHandler implements QueryHandler {

        @Override
        public String getPath() {
            return ""account_unread/#"";
        }

        @Override
        public Cursor query(final Uri uri, String[] projection, String selection,
                            String[] selectionArgs, String sortOrder) throws Exception {
            List<String> segments = null;
            int accountId = -1;
            segments = uri.getPathSegments();
            accountId = Integer.parseInt(segments.get(1));
            return getAccountUnread(accountId);
        }

        public Cursor getAccountUnread(int accountNumber) {
            String[] projection = new String[] { ""accountName"", ""unread"" };

            MatrixCursor ret = new MatrixCursor(projection);

            Account myAccount;
            AccountStats myAccountStats = null;

            Object[] values = new Object[2];

            for (Account account : Preferences.getPreferences(getContext()).getAvailableAccounts()) {
                if (account.getAccountNumber() == accountNumber) {
                    myAccount = account;
                    try {
                        myAccountStats = account.getStats(getContext());
                        values[0] = myAccount.getDescription();
                        if (myAccountStats == null) {
                            values[1] = 0;
                        } else {
                            values[1] = myAccountStats.unreadMessageCount;
                        }

                        ret.addRow(values);
                    } catch (MessagingException e) {
                        Log.e(K9.LOG_TAG, e.getMessage());
                        values[0] = ""Unknown"";
                        values[1] = 0;
                    }
                }
            }

            return ret;
        }
    }

    /**
     * Cursor wrapper that release a semaphore on close. Close is also triggered
     * on {@link #finalize()}.
     */
    protected static class MonitoredCursor implements CrossProcessCursor {
        /**
         * The underlying cursor implementation that handles regular
         * requests
         */
        private CrossProcessCursor mCursor;

        /**
         * Whether {@link #close()} was invoked
         */
        private AtomicBoolean mClosed = new AtomicBoolean(false);

        private Semaphore mSemaphore;

        /**
         * @param cursor
         *            Never <code>null</code>.
         * @param semaphore
         *            The semaphore to release on close. Never
         *            <code>null</code>.
         */
        protected MonitoredCursor(final CrossProcessCursor cursor, final Semaphore semaphore) {
            this.mCursor = cursor;
            this.mSemaphore = semaphore;
        }

        /* (non-Javadoc)
         *
         * Close the underlying cursor and dereference it.
         *
         * @see android.database.Cursor#close()
         */
        @Override
        public void close() {
            if (mClosed.compareAndSet(false, true)) {
                mCursor.close();
                Log.d(K9.LOG_TAG, ""Cursor closed, null'ing & releasing semaphore"");
                mCursor = null;
                mSemaphore.release();
            }
        }

        @Override
        public boolean isClosed() {
            return mClosed.get() || mCursor.isClosed();
        }

        /* (non-Javadoc)
         *
         * Making sure cursor gets closed on garbage collection
         *
         * @see java.lang.Object#finalize()
         */
        @Override
        protected void finalize() throws Throwable {
            close();
            super.finalize();
        }

        protected void checkClosed() throws IllegalStateException {
            if (mClosed.get()) {
                throw new IllegalStateException(""Cursor was closed"");
            }
        }

        @Override
        public void fillWindow(int pos, CursorWindow winow) {
            checkClosed();
            mCursor.fillWindow(pos, winow);
        }

        @Override
        public CursorWindow getWindow() {
            checkClosed();
            return mCursor.getWindow();
        }

        @Override
        public boolean onMove(int oldPosition, int newPosition) {
            checkClosed();
            return mCursor.onMove(oldPosition, newPosition);
        }

        @Override
        public void copyStringToBuffer(int columnIndex, CharArrayBuffer buffer) {
            checkClosed();
            mCursor.copyStringToBuffer(columnIndex, buffer);
        }

        @Override
        public void deactivate() {
            checkClosed();
            mCursor.deactivate();
        }

        @Override
        public byte[] getBlob(int columnIndex) {
            checkClosed();
            return mCursor.getBlob(columnIndex);
        }

        @Override
        public int getColumnCount() {
            checkClosed();
            return mCursor.getColumnCount();
        }

        @Override
        public int getColumnIndex(String columnName) {
            checkClosed();
            return mCursor.getColumnIndex(columnName);
        }

        @Override
        public int getColumnIndexOrThrow(String columnName) throws IllegalArgumentException {
            checkClosed();
            return mCursor.getColumnIndexOrThrow(columnName);
        }

        @Override
        public String getColumnName(int columnIndex) {
            checkClosed();
            return mCursor.getColumnName(columnIndex);
        }

        @Override
        public String[] getColumnNames() {
            checkClosed();
            return mCursor.getColumnNames();
        }

        @Override
        public int getCount() {
            checkClosed();
            return mCursor.getCount();
        }

        @Override
        public double getDouble(int columnIndex) {
            checkClosed();
            return mCursor.getDouble(columnIndex);
        }

        @Override
        public Bundle getExtras() {
            checkClosed();
            return mCursor.getExtras();
        }

        @Override
        public float getFloat(int columnIndex) {
            checkClosed();
            return mCursor.getFloat(columnIndex);
        }

        @Override
        public int getInt(int columnIndex) {
            checkClosed();
            return mCursor.getInt(columnIndex);
        }

        @Override
        public long getLong(int columnIndex) {
            checkClosed();
            return mCursor.getLong(columnIndex);
        }

        @Override
        public int getPosition() {
            checkClosed();
            return mCursor.getPosition();
        }

        @Override
        public short getShort(int columnIndex) {
            checkClosed();
            return mCursor.getShort(columnIndex);
        }

        @Override
        public String getString(int columnIndex) {
            checkClosed();
            return mCursor.getString(columnIndex);
        }

        @Override
        public boolean getWantsAllOnMoveCalls() {
            checkClosed();
            return mCursor.getWantsAllOnMoveCalls();
        }

        @Override
        public boolean isAfterLast() {
            checkClosed();
            return mCursor.isAfterLast();
        }

        @Override
        public boolean isBeforeFirst() {
            checkClosed();
            return mCursor.isBeforeFirst();
        }

        @Override
        public boolean isFirst() {
            checkClosed();
            return mCursor.isFirst();
        }

        public boolean isLast() {
            checkClosed();
            return mCursor.isLast();
        }

        @Override
        public boolean isNull(int columnIndex) {
            checkClosed();
            return mCursor.isNull(columnIndex);
        }

        @Override
        public boolean move(int offset) {
            checkClosed();
            return mCursor.move(offset);
        }

        @Override
        public boolean moveToFirst() {
            checkClosed();
            return mCursor.moveToFirst();
        }

        @Override
        public boolean moveToLast() {
            checkClosed();
            return mCursor.moveToLast();
        }

        @Override
        public boolean moveToNext() {
            checkClosed();
            return mCursor.moveToNext();
        }

        @Override
        public boolean moveToPosition(int position) {
            checkClosed();
            return mCursor.moveToPosition(position);
        }

        @Override
        public boolean moveToPrevious() {
            checkClosed();
            return mCursor.moveToPrevious();
        }

        @Override
        public void registerContentObserver(ContentObserver observer) {
            checkClosed();
            mCursor.registerContentObserver(observer);
        }

        @Override
        public void registerDataSetObserver(DataSetObserver observer) {
            checkClosed();
            mCursor.registerDataSetObserver(observer);
        }

        @Override
        public boolean requery() {
            checkClosed();
            return mCursor.requery();
        }

        @Override
        public Bundle respond(Bundle extras) {
            checkClosed();
            return mCursor.respond(extras);
        }

        @Override
        public void setNotificationUri(ContentResolver cr, Uri uri) {
            checkClosed();
            mCursor.setNotificationUri(cr, uri);
        }

        @Override
        public void unregisterContentObserver(ContentObserver observer) {
            checkClosed();
            mCursor.unregisterContentObserver(observer);
        }

        @Override
        public void unregisterDataSetObserver(DataSetObserver observer) {
            checkClosed();
            mCursor.unregisterDataSetObserver(observer);
        }
    }

    protected class ThrottlingQueryHandler implements QueryHandler {

        private QueryHandler mDelegate;

        public ThrottlingQueryHandler(final QueryHandler delegate) {
            mDelegate = delegate;
        }

        @Override
        public String getPath() {
            return mDelegate.getPath();
        }

        @Override
        public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
                            String sortOrder) throws Exception {
            mSemaphore.acquire();

            final Cursor cursor;
            cursor = mDelegate.query(uri, projection, selection, selectionArgs, sortOrder);

            /* Android content resolvers can only process CrossProcessCursor instances */
            if (!(cursor instanceof CrossProcessCursor)) {
                Log.w(K9.LOG_TAG, ""Unsupported cursor, returning null: "" + cursor);
                return null;
            }

            final MonitoredCursor wrapped = new MonitoredCursor((CrossProcessCursor) cursor, mSemaphore);

            /* use a weak reference not to actively prevent garbage collection */
            final WeakReference<MonitoredCursor> weakReference = new WeakReference<MonitoredCursor>(wrapped);

            /* make sure the cursor is closed after 30 seconds */
            mScheduledPool.schedule(new Runnable() {

                @Override
                public void run() {
                    final MonitoredCursor monitored = weakReference.get();
                    if (monitored != null && !monitored.isClosed()) {
                        Log.w(K9.LOG_TAG, ""Forcibly closing remotely exposed cursor"");
                        try {
                            monitored.close();
                        } catch (Exception e) {
                            Log.w(K9.LOG_TAG, ""Exception while forcibly closing cursor"", e);
                        }
                    }
                }
            }, 30, TimeUnit.SECONDS);

            return wrapped;
        }

    }

    /**
     * Synchronized listener used to retrieve {@link MessageInfoHolder}s using a
     * given {@link BlockingQueue}.
     */
    protected class MesssageInfoHolderRetrieverListener extends MessagingListener {
        private final BlockingQueue<List<MessageInfoHolder>> queue;

        private List<MessageInfoHolder> mHolders = new ArrayList<MessageInfoHolder>();

        /**
         * @param queue
         *            Never <code>null</code>. The synchronized channel to use
         *            to retrieve {@link MessageInfoHolder}s.
         */
        public MesssageInfoHolderRetrieverListener(final BlockingQueue<List<MessageInfoHolder>> queue) {
            this.queue = queue;
        }

        @Override
        public void listLocalMessagesAddMessages(final Account account,
                final String folderName, final List<Message> messages) {
            // cache fields into local variables for faster access on JVM without JIT
            final MessageHelper helper = mMessageHelper;
            final List<MessageInfoHolder> holders = mHolders;

            final Context context = getContext();

            for (final Message message : messages) {
                final MessageInfoHolder messageInfoHolder = new MessageInfoHolder();
                final Folder messageFolder = message.getFolder();
                final Account messageAccount = messageFolder.getAccount();

                helper.populate(messageInfoHolder, message, new FolderInfoHolder(context,
                                messageFolder, messageAccount), messageAccount);

                holders.add(messageInfoHolder);
            }
        }

        @Override
        public void searchStats(AccountStats stats) {
            try {
                queue.put(mHolders);
            } catch (InterruptedException e) {
                Log.e(K9.LOG_TAG, ""Unable to return message list back to caller"", e);
            }
        }
    }

    public static final String AUTHORITY = ""com.fsck.k9.messageprovider"";

    public static final Uri CONTENT_URI = Uri.parse(""content://"" + AUTHORITY);

    private static final String[] DEFAULT_MESSAGE_PROJECTION = new String[] {
        MessageColumns._ID,
        MessageColumns.SEND_DATE,
        MessageColumns.SENDER,
        MessageColumns.SUBJECT,
        MessageColumns.PREVIEW,
        MessageColumns.ACCOUNT,
        MessageColumns.URI,
        MessageColumns.DELETE_URI
    };

    /**
     * URI matcher used for
     * {@link #query(Uri, String[], String, String[], String)}
     */
    private UriMatcher mUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);

    /**
     * Handlers registered to respond to
     * {@link #query(Uri, String[], String, String[], String)}
     */
    private List<QueryHandler> mQueryHandlers = new ArrayList<QueryHandler>();

    private MessageHelper mMessageHelper;

    /**
     * How many simultaneous cursors we can affort to expose at once
     */
    /* package */
    Semaphore mSemaphore = new Semaphore(1);

    /* package */
    ScheduledExecutorService mScheduledPool = Executors.newScheduledThreadPool(1);

    @Override
    public boolean onCreate() {
        mMessageHelper = MessageHelper.getInstance(getContext());

        registerQueryHandler(new ThrottlingQueryHandler(new AccountsQueryHandler()));
        registerQueryHandler(new ThrottlingQueryHandler(new MessagesQueryHandler()));
        registerQueryHandler(new ThrottlingQueryHandler(new UnreadQueryHandler()));

        K9.registerApplicationAware(new K9.ApplicationAware() {
            @Override
            public void initializeComponent(final K9 application) {
                Log.v(K9.LOG_TAG, ""Registering content resolver notifier"");

                MessagingController.getInstance(application).addListener(new MessagingListener() {
                    @Override
                    public void searchStats(final AccountStats stats) {
                        application.getContentResolver().notifyChange(CONTENT_URI, null);
                    }
                });
            }
        });

        return true;
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        if (K9.app == null) {
            return 0;
        }

        if (K9.DEBUG) {
            Log.v(K9.LOG_TAG, ""MessageProvider/delete: "" + uri);
        }

        // Nota : can only delete a message

        List<String> segments = null;
        int accountId = -1;
        String folderName = null;
        String msgUid = null;

        segments = uri.getPathSegments();
        accountId = Integer.parseInt(segments.get(1));
        folderName = segments.get(2);
        msgUid = segments.get(3);

        // get account
        Account myAccount = null;
        for (Account account : Preferences.getPreferences(getContext()).getAccounts()) {
            if (account.getAccountNumber() == accountId) {
                myAccount = account;
                if (!account.isAvailable(getContext())) {
                    Log.w(K9.LOG_TAG, ""not deleting messages because account is unavailable at the moment"");
                    return 0;
                }
            }
        }

        // get localstore parameter
        Message msg = null;
        try {
            Folder lf = LocalStore.getLocalInstance(myAccount, K9.app).getFolder(folderName);
            int msgCount = lf.getMessageCount();
            if (K9.DEBUG) {
                Log.d(K9.LOG_TAG, ""folder msg count = "" + msgCount);
            }
            msg = lf.getMessage(msgUid);
        } catch (MessagingException e) {
            Log.e(K9.LOG_TAG, ""Unable to retrieve message"", e);
        }

        // launch command to delete the message
        if ((myAccount != null) && (msg != null)) {
            MessagingController.getInstance(K9.app).deleteMessages(new Message[] { msg }, null);
        }

        // FIXME return the actual number of deleted messages
        return 0;
    }

    @Override
    public String getType(Uri uri) {
        if (K9.app == null) {
            return null;
        }

        if (K9.DEBUG) {
            Log.v(K9.LOG_TAG, ""MessageProvider/getType: "" + uri);
        }

        return null;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        if (K9.app == null) {
            return null;
        }

        if (K9.DEBUG) {
            Log.v(K9.LOG_TAG, ""MessageProvider/insert: "" + uri);
        }

        return null;
    }

    @Override
    public Cursor query(final Uri uri, final String[] projection, final String selection,
                        final String[] selectionArgs, final String sortOrder) {
        if (K9.app == null) {
            return null;
        }

        if (K9.DEBUG) {
            Log.v(K9.LOG_TAG, ""MessageProvider/query: "" + uri);
        }

        final Cursor cursor;

        final int code = mUriMatcher.match(uri);

        if (code == -1) {
            throw new IllegalStateException(""Unrecognized URI: "" + uri);
        }

        try {
            // since we used the list index as the UriMatcher code, using it
            // back to retrieve the handler from the list
            final QueryHandler handler = mQueryHandlers.get(code);
            cursor = handler.query(uri, projection, selection, selectionArgs, sortOrder);
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Unable to execute query for URI: "" + uri, e);
            return null;
        }

        return cursor;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        if (K9.app == null) {
            return 0;
        }

        if (K9.DEBUG) {
            Log.v(K9.LOG_TAG, ""MessageProvider/update: "" + uri);
        }

//TBD

        return 0;
    }

    /**
     * Register a {@link QueryHandler} to handle a certain {@link Uri} for
     * {@link #query(Uri, String[], String, String[], String)}
     *
     * @param handler
     *            Never <code>null</code>.
     */
    protected void registerQueryHandler(final QueryHandler handler) {
        if (mQueryHandlers.contains(handler)) {
            return;
        }
        mQueryHandlers.add(handler);

        // use the index inside the list as the UriMatcher code for that handler
        final int code = mQueryHandlers.indexOf(handler);
        mUriMatcher.addURI(AUTHORITY, handler.getPath(), code);
    }

}
",True,145,0,0,5,61,0,17,L2
90,com.fsck.k9.provider.AttachmentProvider.java,"package com.fsck.k9.provider;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.os.ParcelFileDescriptor;
import android.util.Log;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.AttachmentInfo;
import com.fsck.k9.mail.store.StorageManager;

import java.io.*;
import java.util.List;

/**
 * A simple ContentProvider that allows file access to Email's attachments.<br/>
 * Warning! We make heavy assumptions about the Uris used by the {@link LocalStore} for an {@link Account} here.
 */
public class AttachmentProvider extends ContentProvider {
    public static final Uri CONTENT_URI = Uri.parse(""content://com.fsck.k9.attachmentprovider"");

    private static final String FORMAT_RAW = ""RAW"";
    private static final String FORMAT_VIEW = ""VIEW"";
    private static final String FORMAT_THUMBNAIL = ""THUMBNAIL"";

    public static class AttachmentProviderColumns {
        public static final String _ID = ""_id"";
        public static final String DATA = ""_data"";
        public static final String DISPLAY_NAME = ""_display_name"";
        public static final String SIZE = ""_size"";
    }

    public static Uri getAttachmentUri(Account account, long id) {
        return getAttachmentUri(account.getUuid(), id, true);
    }

    public static Uri getAttachmentUriForViewing(Account account, long id) {
        return getAttachmentUri(account.getUuid(), id, false);
    }

    public static Uri getAttachmentThumbnailUri(Account account, long id, int width, int height) {
        return CONTENT_URI.buildUpon()
               .appendPath(account.getUuid())
               .appendPath(Long.toString(id))
               .appendPath(FORMAT_THUMBNAIL)
               .appendPath(Integer.toString(width))
               .appendPath(Integer.toString(height))
               .build();
    }

    private static Uri getAttachmentUri(String db, long id, boolean raw) {
        return CONTENT_URI.buildUpon()
               .appendPath(db)
               .appendPath(Long.toString(id))
               .appendPath(raw ? FORMAT_RAW : FORMAT_VIEW)
               .build();
    }

    @Override
    public boolean onCreate() {
        /*
         * We use the cache dir as a temporary directory (since Android doesn't give us one) so
         * on startup we'll clean up any .tmp files from the last run.
         */
        final File cacheDir = getContext().getCacheDir();
        if (cacheDir == null) {
            return true;
        }
        File[] files = cacheDir.listFiles();
        if (files == null) {
            return true;
        }
        for (File file : files) {
            if (file.getName().endsWith("".tmp"")) {
                file.delete();
            }
        }

        return true;
    }

    public static void clear(Context lContext) {
        /*
         * We use the cache dir as a temporary directory (since Android doesn't give us one) so
         * on startup we'll clean up any .tmp files from the last run.
         */
        File[] files = lContext.getCacheDir().listFiles();
        for (File file : files) {
            try {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Deleting file "" + file.getCanonicalPath());
            } catch (IOException ioe) {} // No need to log failure to log
            file.delete();
        }
    }

    @Override
    public String getType(Uri uri) {
        List<String> segments = uri.getPathSegments();
        String dbName = segments.get(0);
        String id = segments.get(1);
        String format = segments.get(2);

        return getType(dbName, id, format);
    }

    private String getType(String dbName, String id, String format) {
        if (FORMAT_THUMBNAIL.equals(format)) {
            return ""image/png"";
        } else {
            final Account account = Preferences.getPreferences(getContext()).getAccount(dbName);

            try {
                final LocalStore localStore = LocalStore.getLocalInstance(account, K9.app);

                AttachmentInfo attachmentInfo = localStore.getAttachmentInfo(id);
                if (FORMAT_VIEW.equals(format)) {
                    return MimeUtility.getMimeTypeForViewing(attachmentInfo.type, attachmentInfo.name);
                } else {
                    // When accessing the ""raw"" message we deliver the original MIME type.
                    return attachmentInfo.type;
                }
            } catch (MessagingException e) {
                Log.e(K9.LOG_TAG, ""Unable to retrieve LocalStore for "" + account, e);
                return null;
            }
        }
    }

    private File getFile(String dbName, String id)
    throws FileNotFoundException {
        try {
            final Account account = Preferences.getPreferences(getContext()).getAccount(dbName);
            final File attachmentsDir;
            attachmentsDir = StorageManager.getInstance(K9.app).getAttachmentDirectory(dbName,
                             account.getLocalStorageProviderId());
            final File file = new File(attachmentsDir, id);
            if (!file.exists()) {
                throw new FileNotFoundException(file.getAbsolutePath());
            }
            return file;
        } catch (IOException e) {
            Log.w(K9.LOG_TAG, null, e);
            throw new FileNotFoundException(e.getMessage());
        }
    }

    @Override
    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
        List<String> segments = uri.getPathSegments();
        String dbName = segments.get(0); // ""/sdcard/..."" is URL-encoded and makes up only 1 segment
        String id = segments.get(1);
        String format = segments.get(2);
        if (FORMAT_THUMBNAIL.equals(format)) {
            int width = Integer.parseInt(segments.get(3));
            int height = Integer.parseInt(segments.get(4));
            String filename = ""thmb_"" + dbName + ""_"" + id + "".tmp"";
            int index = dbName.lastIndexOf('/');
            if (index >= 0) {
                filename = /*dbName.substring(0, index + 1) + */""thmb_"" + dbName.substring(index + 1) + ""_"" + id + "".tmp"";
            }
            File dir = getContext().getCacheDir();
            File file = new File(dir, filename);
            if (!file.exists()) {
                String type = getType(dbName, id, FORMAT_VIEW);
                try {
                    FileInputStream in = new FileInputStream(getFile(dbName, id));
                    try {
                        Bitmap thumbnail = createThumbnail(type, in);
                        if (thumbnail != null) {
                            thumbnail = Bitmap.createScaledBitmap(thumbnail, width, height, true);
                            FileOutputStream out = new FileOutputStream(file);
                            thumbnail.compress(Bitmap.CompressFormat.PNG, 100, out);
                            out.close();
                        }
                    } finally {
                        in.close();
                    }
                } catch (IOException ioe) {
                    return null;
                }
            }
            return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
        } else {
            return ParcelFileDescriptor.open(
                       getFile(dbName, id),
                       ParcelFileDescriptor.MODE_READ_ONLY);
        }
    }

    @Override
    public int delete(Uri uri, String arg1, String[] arg2) {
        return 0;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        return null;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
                        String sortOrder) {
        if (projection == null) {
            projection =
                new String[] {
                AttachmentProviderColumns._ID,
                AttachmentProviderColumns.DATA,
            };
        }

        List<String> segments = uri.getPathSegments();
        String dbName = segments.get(0);
        String id = segments.get(1);

        // Versions of K-9 before 3.400 had a database name here, not an
        // account UID, so implement a bit of backcompat
        if (dbName.endsWith("".db"")) {
            dbName = dbName.substring(0, dbName.length() - 3);
        }

        //String format = segments.get(2);
        final AttachmentInfo attachmentInfo;
        try {
            final Account account = Preferences.getPreferences(getContext()).getAccount(dbName);
            attachmentInfo = LocalStore.getLocalInstance(account, K9.app).getAttachmentInfo(id);
        } catch (MessagingException e) {
            Log.e(K9.LOG_TAG, ""Unable to retrieve attachment info from local store for ID: "" + id, e);
            return null;
        }

        MatrixCursor ret = new MatrixCursor(projection);
        Object[] values = new Object[projection.length];
        for (int i = 0, count = projection.length; i < count; i++) {
            String column = projection[i];
            if (AttachmentProviderColumns._ID.equals(column)) {
                values[i] = id;
            } else if (AttachmentProviderColumns.DATA.equals(column)) {
                values[i] = uri.toString();
            } else if (AttachmentProviderColumns.DISPLAY_NAME.equals(column)) {
                values[i] = attachmentInfo.name;
            } else if (AttachmentProviderColumns.SIZE.equals(column)) {
                values[i] = attachmentInfo.size;
            }
        }
        ret.addRow(values);
        return ret;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        return 0;
    }

    private Bitmap createThumbnail(String type, InputStream data) {
        if (MimeUtility.mimeTypeMatches(type, ""image/*"")) {
            return createImageThumbnail(data);
        }
        return null;
    }

    private Bitmap createImageThumbnail(InputStream data) {
        try {
            Bitmap bitmap = BitmapFactory.decodeStream(data);
            return bitmap;
        } catch (OutOfMemoryError oome) {
            /*
             * Improperly downloaded images, corrupt bitmaps and the like can commonly
             * cause OOME due to invalid allocation sizes. We're happy with a null bitmap in
             * that case. If the system is really out of memory we'll know about it soon
             * enough.
             */
            return null;
        } catch (Exception e) {
            return null;
        }
    }
}
",True,144,0,0,6,46,2,8,L1
91,com.fsck.k9.service.PollService.java,"package com.fsck.k9.service;

import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.os.PowerManager;
import android.util.Log;
import com.fsck.k9.*;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.helper.power.TracingPowerManager;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;

import java.util.HashMap;

public class PollService extends CoreService {
    private static String START_SERVICE = ""com.fsck.k9.service.PollService.startService"";
    private static String STOP_SERVICE = ""com.fsck.k9.service.PollService.stopService"";

    private Listener mListener = new Listener();

    public static void startService(Context context) {
        Intent i = new Intent();
        i.setClass(context, PollService.class);
        i.setAction(PollService.START_SERVICE);
        addWakeLock(context, i);
        context.startService(i);
    }

    public static void stopService(Context context) {
        Intent i = new Intent();
        i.setClass(context, PollService.class);
        i.setAction(PollService.STOP_SERVICE);
        addWakeLock(context, i);
        context.startService(i);
    }

    @Override
    public void startService(Intent intent, int startId) {
        if (START_SERVICE.equals(intent.getAction())) {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PollService started with startId = "" + startId);

            MessagingController controller = MessagingController.getInstance(getApplication());
            Listener listener = (Listener)controller.getCheckMailListener();
            if (listener == null) {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""***** PollService *****: starting new check"");
                mListener.setStartId(startId);
                mListener.wakeLockAcquire();
                controller.setCheckMailListener(mListener);
                controller.checkMail(this, null, false, false, mListener);
            } else {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""***** PollService *****: renewing WakeLock"");
                listener.setStartId(startId);
                listener.wakeLockAcquire();
            }
        } else if (STOP_SERVICE.equals(intent.getAction())) {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PollService stopping"");
            stopSelf();
        }

    }

    @Override
    public IBinder onBind(Intent arg0) {
        return null;
    }

    class Listener extends MessagingListener {
        HashMap<String, Integer> accountsChecked = new HashMap<String, Integer>();
        private TracingWakeLock wakeLock = null;
        private int startId = -1;

        // wakelock strategy is to be very conservative.  If there is any reason to release, then release
        // don't want to take the chance of running wild
        public synchronized void wakeLockAcquire() {
            TracingWakeLock oldWakeLock = wakeLock;

            TracingPowerManager pm = TracingPowerManager.getPowerManager(PollService.this);
            wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""PollService wakeLockAcquire"");
            wakeLock.setReferenceCounted(false);
            wakeLock.acquire(K9.WAKE_LOCK_TIMEOUT);

            if (oldWakeLock != null) {
                oldWakeLock.release();
            }

        }
        public synchronized void wakeLockRelease() {
            if (wakeLock != null) {
                wakeLock.release();
                wakeLock = null;
            }
        }
        @Override
        public void checkMailStarted(Context context, Account account) {
            accountsChecked.clear();
        }

        @Override
        public void checkMailFailed(Context context, Account account, String reason) {
            release();
        }

        @Override
        public void synchronizeMailboxFinished(
            Account account,
            String folder,
            int totalMessagesInMailbox,
            int numNewMessages) {
            if (account.isNotifyNewMail()) {
                Integer existingNewMessages = accountsChecked.get(account.getUuid());
                if (existingNewMessages == null) {
                    existingNewMessages = 0;
                }
                accountsChecked.put(account.getUuid(), existingNewMessages + numNewMessages);
            }
        }

        private void release() {

            MessagingController controller = MessagingController.getInstance(getApplication());
            controller.setCheckMailListener(null);
            MailService.saveLastCheckEnd(getApplication());

            MailService.actionReschedulePoll(PollService.this, null);
            wakeLockRelease();
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PollService stopping with startId = "" + startId);

            stopSelf(startId);
        }

        @Override
        public void checkMailFinished(Context context, Account account) {

            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""***** PollService *****: checkMailFinished"");
            release();
        }
        public int getStartId() {
            return startId;
        }
        public void setStartId(int startId) {
            this.startId = startId;
        }
    }

}
",False,144,0,0,6,49,1,7,L1
92,com.fsck.k9.service.PushService.java,"package com.fsck.k9.service;

import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.util.Log;
import com.fsck.k9.K9;

public class PushService extends CoreService {
    private static String START_SERVICE = ""com.fsck.k9.service.PushService.startService"";
    private static String STOP_SERVICE = ""com.fsck.k9.service.PushService.stopService"";

    public static void startService(Context context) {
        Intent i = new Intent();
        i.setClass(context, PushService.class);
        i.setAction(PushService.START_SERVICE);
        addWakeLock(context, i);
        context.startService(i);
    }

    public static void stopService(Context context) {
        Intent i = new Intent();
        i.setClass(context, PushService.class);
        i.setAction(PushService.STOP_SERVICE);
        addWakeLock(context, i);
        context.startService(i);
    }

    @Override
    public void startService(Intent intent, int startId) {
        if (START_SERVICE.equals(intent.getAction())) {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PushService started with startId = "" + startId);
        } else if (STOP_SERVICE.equals(intent.getAction())) {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PushService stopping with startId = "" + startId);
            stopSelf(startId);
        }

    }

    @Override
    public IBinder onBind(Intent arg0) {
        // TODO Auto-generated method stub
        return null;
    }
}
",False,144,0,0,7,51,1,2,L1
93,com.fsck.k9.service.RemoteControlReceiver.java,"
package com.fsck.k9.service;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.remotecontrol.K9RemoteControl;
import com.fsck.k9.Preferences;

import static com.fsck.k9.remotecontrol.K9RemoteControl.*;

public class RemoteControlReceiver extends CoreReceiver {
    @Override
    public Integer receive(Context context, Intent intent, Integer tmpWakeLockId) {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""RemoteControlReceiver.onReceive"" + intent);

        if (K9RemoteControl.K9_SET.equals(intent.getAction())) {
            RemoteControlService.set(context, intent, tmpWakeLockId);
            tmpWakeLockId = null;
        } else if (K9RemoteControl.K9_REQUEST_ACCOUNTS.equals(intent.getAction())) {
            try {
                Preferences preferences = Preferences.getPreferences(context);
                Account[] accounts = preferences.getAccounts();
                String[] uuids = new String[accounts.length];
                String[] descriptions = new String[accounts.length];
                for (int i = 0; i < accounts.length; i++) {
                    //warning: account may not be isAvailable()
                    Account account = accounts[i];

                    uuids[i] = account.getUuid();
                    descriptions[i] = account.getDescription();
                }
                Bundle bundle = getResultExtras(true);
                bundle.putStringArray(K9_ACCOUNT_UUIDS, uuids);
                bundle.putStringArray(K9_ACCOUNT_DESCRIPTIONS, descriptions);
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Could not handle K9_RESPONSE_INTENT"", e);
            }

        }

        return tmpWakeLockId;
    }

}
",True,149,0,0,6,49,0,6,L2
94,com.fsck.k9.service.RemoteControlService.java,"package com.fsck.k9.service;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.remotecontrol.K9RemoteControl;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.K9.BACKGROUND_OPS;

import static com.fsck.k9.remotecontrol.K9RemoteControl.*;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.util.Log;
import android.widget.Toast;

public class RemoteControlService extends CoreService {
    private final static String RESCHEDULE_ACTION = ""com.fsck.k9.service.RemoteControlService.RESCHEDULE_ACTION"";
    private final static String PUSH_RESTART_ACTION = ""com.fsck.k9.service.RemoteControlService.PUSH_RESTART_ACTION"";

    private final static String SET_ACTION = ""com.fsck.k9.service.RemoteControlService.SET_ACTION"";

    public static void set(Context context, Intent i, Integer wakeLockId) {
        //  Intent i = new Intent();
        i.setClass(context, RemoteControlService.class);
        i.setAction(RemoteControlService.SET_ACTION);
        addWakeLockId(i, wakeLockId);
        if (wakeLockId == null) {
            addWakeLock(context, i);
        }
        context.startService(i);
    }

    public static final int REMOTE_CONTROL_SERVICE_WAKE_LOCK_TIMEOUT = 20000;

    @Override
    public void startService(final Intent intent, final int startId) {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""RemoteControlService started with startId = "" + startId);
        final Preferences preferences = Preferences.getPreferences(this);

        if (RESCHEDULE_ACTION.equals(intent.getAction())) {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""RemoteControlService requesting MailService poll reschedule"");
            MailService.actionReschedulePoll(this, null);
        }
        if (PUSH_RESTART_ACTION.equals(intent.getAction())) {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""RemoteControlService requesting MailService push restart"");
            MailService.actionRestartPushers(this, null);
        } else if (RemoteControlService.SET_ACTION.equals(intent.getAction())) {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""RemoteControlService got request to change settings"");
            execute(getApplication(), new Runnable() {
                public void run() {
                    try {
                        boolean needsReschedule = false;
                        boolean needsPushRestart = false;
                        String uuid = intent.getStringExtra(K9_ACCOUNT_UUID);
                        boolean allAccounts = intent.getBooleanExtra(K9_ALL_ACCOUNTS, false);
                        if (K9.DEBUG) {
                            if (allAccounts) {
                                Log.i(K9.LOG_TAG, ""RemoteControlService changing settings for all accounts"");
                            } else {
                                Log.i(K9.LOG_TAG, ""RemoteControlService changing settings for account with UUID "" + uuid);
                            }
                        }
                        Account[] accounts = preferences.getAccounts();
                        for (Account account : accounts) {
                            //warning: account may not be isAvailable()
                            if (allAccounts || account.getUuid().equals(uuid)) {

                                if (K9.DEBUG)
                                    Log.i(K9.LOG_TAG, ""RemoteControlService changing settings for account "" + account.getDescription());

                                String notificationEnabled = intent.getStringExtra(K9_NOTIFICATION_ENABLED);
                                String ringEnabled = intent.getStringExtra(K9_RING_ENABLED);
                                String vibrateEnabled = intent.getStringExtra(K9_VIBRATE_ENABLED);
                                String pushClasses = intent.getStringExtra(K9_PUSH_CLASSES);
                                String pollClasses = intent.getStringExtra(K9_POLL_CLASSES);
                                String pollFrequency = intent.getStringExtra(K9_POLL_FREQUENCY);

                                if (notificationEnabled != null) {
                                    account.setNotifyNewMail(Boolean.parseBoolean(notificationEnabled));
                                }
                                if (ringEnabled != null) {
                                    account.getNotificationSetting().setRing(Boolean.parseBoolean(ringEnabled));
                                }
                                if (vibrateEnabled != null) {
                                    account.getNotificationSetting().setVibrate(Boolean.parseBoolean(vibrateEnabled));
                                }
                                if (pushClasses != null) {
                                    needsPushRestart |= account.setFolderPushMode(FolderMode.valueOf(pushClasses));
                                }
                                if (pollClasses != null) {
                                    needsReschedule |= account.setFolderSyncMode(FolderMode.valueOf(pollClasses));
                                }
                                if (pollFrequency != null) {
                                    String[] allowedFrequencies = getResources().getStringArray(R.array.account_settings_check_frequency_values);
                                    for (String allowedFrequency : allowedFrequencies) {
                                        if (allowedFrequency.equals(pollFrequency)) {
                                            Integer newInterval = Integer.parseInt(allowedFrequency);
                                            needsReschedule |= account.setAutomaticCheckIntervalMinutes(newInterval);
                                        }
                                    }
                                }
                                account.save(Preferences.getPreferences(RemoteControlService.this));
                            }
                        }
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""RemoteControlService changing global settings"");

                        String backgroundOps = intent.getStringExtra(K9_BACKGROUND_OPERATIONS);
                        if (K9RemoteControl.K9_BACKGROUND_OPERATIONS_ALWAYS.equals(backgroundOps)
                                || K9RemoteControl.K9_BACKGROUND_OPERATIONS_NEVER.equals(backgroundOps)
                                || K9RemoteControl.K9_BACKGROUND_OPERATIONS_WHEN_CHECKED.equals(backgroundOps)
                        || K9RemoteControl.K9_BACKGROUND_OPERATIONS_WHEN_CHECKED_AUTO_SYNC.equals(backgroundOps)) {
                            BACKGROUND_OPS newBackgroundOps = BACKGROUND_OPS.valueOf(backgroundOps);
                            boolean needsReset = K9.setBackgroundOps(newBackgroundOps);
                            needsPushRestart |= needsReset;
                            needsReschedule |= needsReset;
                        }

                        String theme = intent.getStringExtra(K9_THEME);
                        if (theme != null) {
                            K9.setK9Theme(K9RemoteControl.K9_THEME_DARK.equals(theme) ? android.R.style.Theme : android.R.style.Theme_Light);
                        }

                        SharedPreferences sPrefs = preferences.getPreferences();

                        Editor editor = sPrefs.edit();
                        K9.save(editor);
                        editor.commit();

                        if (needsReschedule) {
                            Intent i = new Intent();
                            i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.RemoteControlService"");
                            i.setAction(RESCHEDULE_ACTION);
                            long nextTime = System.currentTimeMillis() + 10000;
                            BootReceiver.scheduleIntent(RemoteControlService.this, nextTime, i);
                        }
                        if (needsPushRestart) {
                            Intent i = new Intent();
                            i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.RemoteControlService"");
                            i.setAction(PUSH_RESTART_ACTION);
                            long nextTime = System.currentTimeMillis() + 10000;
                            BootReceiver.scheduleIntent(RemoteControlService.this, nextTime, i);
                        }
                    } catch (Exception e) {
                        Log.e(K9.LOG_TAG, ""Could not handle K9_SET"", e);
                        Toast toast = Toast.makeText(RemoteControlService.this, e.getMessage(), Toast.LENGTH_LONG);
                        toast.show();
                    }
                }
            }
            , RemoteControlService.REMOTE_CONTROL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
        }
    }

}
",True,149,1,1,6,46,1,8,L2
95,com.fsck.k9.service.SleepService.java,"package com.fsck.k9.service;

import android.content.Context;
import android.content.Intent;
import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class SleepService extends CoreService {

    private static String ALARM_FIRED = ""com.fsck.k9.service.SleepService.ALARM_FIRED"";
    private static String LATCH_ID = ""com.fsck.k9.service.SleepService.LATCH_ID_EXTRA"";


    private static ConcurrentHashMap<Integer, SleepDatum> sleepData = new ConcurrentHashMap<Integer, SleepDatum>();

    private static AtomicInteger latchId = new AtomicInteger();

    public static void sleep(Context context, long sleepTime, TracingWakeLock wakeLock, long wakeLockTimeout) {
        Integer id = latchId.getAndIncrement();
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SleepService Preparing CountDownLatch with id = "" + id + "", thread "" + Thread.currentThread().getName());
        SleepDatum sleepDatum = new SleepDatum();
        CountDownLatch latch = new CountDownLatch(1);
        sleepDatum.latch = latch;
        sleepDatum.reacquireLatch = new CountDownLatch(1);
        sleepData.put(id, sleepDatum);

        Intent i = new Intent();
        i.setClassName(context.getPackageName(), ""com.fsck.k9.service.SleepService"");
        i.putExtra(LATCH_ID, id);
        i.setAction(ALARM_FIRED + ""."" + id);
        long startTime = System.currentTimeMillis();
        long nextTime = startTime + sleepTime;
        BootReceiver.scheduleIntent(context, nextTime, i);
        if (wakeLock != null) {
            sleepDatum.wakeLock = wakeLock;
            sleepDatum.timeout = wakeLockTimeout;
            wakeLock.release();
        }
        try {
            boolean countedDown = latch.await(sleepTime, TimeUnit.MILLISECONDS);
            if (!countedDown) {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SleepService latch timed out for id = "" + id + "", thread "" + Thread.currentThread().getName());
            }
        } catch (InterruptedException ie) {
            Log.e(K9.LOG_TAG, ""SleepService Interrupted while awaiting latch"", ie);
        }
        SleepDatum releaseDatum = sleepData.remove(id);
        if (releaseDatum == null) {
            try {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SleepService waiting for reacquireLatch for id = "" + id + "", thread "" + Thread.currentThread().getName());
                if (!sleepDatum.reacquireLatch.await(5000, TimeUnit.MILLISECONDS)) {
                    Log.w(K9.LOG_TAG, ""SleepService reacquireLatch timed out for id = "" + id + "", thread "" + Thread.currentThread().getName());
                } else if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SleepService reacquireLatch finished for id = "" + id + "", thread "" + Thread.currentThread().getName());
            } catch (InterruptedException ie) {
                Log.e(K9.LOG_TAG, ""SleepService Interrupted while awaiting reacquireLatch"", ie);
            }
        } else {
            reacquireWakeLock(releaseDatum);
        }

        long endTime = System.currentTimeMillis();
        long actualSleep = endTime - startTime;

        if (actualSleep < sleepTime) {
            Log.w(K9.LOG_TAG, ""SleepService sleep time too short: requested was "" + sleepTime + "", actual was "" + actualSleep);
        } else {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""SleepService requested sleep time was "" + sleepTime + "", actual was "" + actualSleep);
        }
    }

    private static void endSleep(Integer id) {
        if (id != -1) {
            SleepDatum sleepDatum = sleepData.remove(id);
            if (sleepDatum != null) {
                CountDownLatch latch = sleepDatum.latch;
                if (latch == null) {
                    Log.e(K9.LOG_TAG, ""SleepService No CountDownLatch available with id = "" + id);
                } else {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""SleepService Counting down CountDownLatch with id = "" + id);
                    latch.countDown();
                }
                reacquireWakeLock(sleepDatum);
                sleepDatum.reacquireLatch.countDown();
            } else {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SleepService Sleep for id "" + id + "" already finished"");
            }
        }
    }

    private static void reacquireWakeLock(SleepDatum sleepDatum) {
        TracingWakeLock wakeLock = sleepDatum.wakeLock;
        if (wakeLock != null) {
            synchronized (wakeLock) {
                long timeout = sleepDatum.timeout;
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SleepService Acquiring wakeLock for "" + timeout + ""ms"");
                wakeLock.acquire(timeout);
            }
        }
    }

    @Override
    public void startService(Intent intent, int startId) {
        if (intent.getAction().startsWith(ALARM_FIRED)) {
            Integer id = intent.getIntExtra(LATCH_ID, -1);
            endSleep(id);
        }
        stopSelf(startId);
    }

    private static class SleepDatum {
        CountDownLatch latch;
        TracingWakeLock wakeLock;
        long timeout;
        CountDownLatch reacquireLatch;
    }

}
",False,144,0,0,7,52,1,4,L1
96,com.fsck.k9.service.MailService.java,"
package com.fsck.k9.service;

import java.util.Collection;
import java.util.Date;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.NetworkInfo.State;
import android.os.IBinder;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.helper.AutoSyncHelper;
import com.fsck.k9.mail.Pusher;

/**
 */
public class MailService extends CoreService {
    private static final String ACTION_CHECK_MAIL = ""com.fsck.k9.intent.action.MAIL_SERVICE_WAKEUP"";
    private static final String ACTION_RESET = ""com.fsck.k9.intent.action.MAIL_SERVICE_RESET"";
    private static final String ACTION_RESCHEDULE_POLL = ""com.fsck.k9.intent.action.MAIL_SERVICE_RESCHEDULE_POLL"";
    private static final String ACTION_CANCEL = ""com.fsck.k9.intent.action.MAIL_SERVICE_CANCEL"";
    private static final String ACTION_REFRESH_PUSHERS = ""com.fsck.k9.intent.action.MAIL_SERVICE_REFRESH_PUSHERS"";
    private static final String ACTION_RESTART_PUSHERS = ""com.fsck.k9.intent.action.MAIL_SERVICE_RESTART_PUSHERS"";
    private static final String CONNECTIVITY_CHANGE = ""com.fsck.k9.intent.action.MAIL_SERVICE_CONNECTIVITY_CHANGE"";
    private static final String CANCEL_CONNECTIVITY_NOTICE = ""com.fsck.k9.intent.action.MAIL_SERVICE_CANCEL_CONNECTIVITY_NOTICE"";

    private static long nextCheck = -1;
    private static boolean pushingRequested = false;
    private static boolean pollingRequested = false;
    private static boolean syncBlocked = false;

    public static void actionReset(Context context, Integer wakeLockId) {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_RESET);
        addWakeLockId(i, wakeLockId);
        if (wakeLockId == null) {
            addWakeLock(context, i);
        }
        context.startService(i);
    }

    public static void actionRestartPushers(Context context, Integer wakeLockId) {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_RESTART_PUSHERS);
        addWakeLockId(i, wakeLockId);
        if (wakeLockId == null) {
            addWakeLock(context, i);
        }
        context.startService(i);
    }

    public static void actionReschedulePoll(Context context, Integer wakeLockId) {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_RESCHEDULE_POLL);
        addWakeLockId(i, wakeLockId);
        if (wakeLockId == null) {
            addWakeLock(context, i);
        }
        context.startService(i);
    }

    public static void actionCancel(Context context, Integer wakeLockId) {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_CANCEL);
        addWakeLockId(i, wakeLockId);
        context.startService(i);
    }

    public static void connectivityChange(Context context, Integer wakeLockId) {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.CONNECTIVITY_CHANGE);
        addWakeLockId(i, wakeLockId);
        context.startService(i);
    }

    @Override
    public void onCreate() {
        super.onCreate();
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""***** MailService *****: onCreate"");
    }

    @Override
    public void startService(Intent intent, int startId) {
        Integer startIdObj = startId;
        long startTime = System.currentTimeMillis();
        try {
            boolean oldIsSyncDisabled = isSyncDisabled();
            ConnectivityManager connectivityManager = (ConnectivityManager)getApplication().getSystemService(Context.CONNECTIVITY_SERVICE);
            boolean doBackground = true;
            boolean hasConnectivity = false;

            if (connectivityManager != null) {
                NetworkInfo netInfo = connectivityManager.getActiveNetworkInfo();
                if (netInfo != null) {
                    State state = netInfo.getState();
                    hasConnectivity = state == State.CONNECTED;
                }
                boolean backgroundData = connectivityManager.getBackgroundDataSetting();
                boolean autoSync = true;
                if (AutoSyncHelper.isAvailable()) {
                    autoSync = AutoSyncHelper.getMasterSyncAutomatically();

                    Log.i(K9.LOG_TAG, ""AutoSync help is available, autoSync = "" + autoSync);
                }

                K9.BACKGROUND_OPS bOps = K9.getBackgroundOps();

                switch (bOps) {
                case NEVER:
                    doBackground = false;
                    break;
                case ALWAYS:
                    doBackground = true;
                    break;
                case WHEN_CHECKED:
                    doBackground = backgroundData;
                    break;
                case WHEN_CHECKED_AUTO_SYNC:
                    doBackground = backgroundData & autoSync;
                    break;
                }

            }

            syncBlocked = !(doBackground && hasConnectivity);

            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""MailService.onStart("" + intent + "", "" + startId
                      + ""), hasConnectivity = "" + hasConnectivity + "", doBackground = "" + doBackground);

            // MessagingController.getInstance(getApplication()).addListener(mListener);
            if (ACTION_CHECK_MAIL.equals(intent.getAction())) {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""***** MailService *****: checking mail"");

                if (hasConnectivity && doBackground) {
                    PollService.startService(this);
                }
                reschedulePoll(hasConnectivity, doBackground, startIdObj, false);
                startIdObj = null;
            } else if (ACTION_CANCEL.equals(intent.getAction())) {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""***** MailService *****: cancel"");

                cancel();
            } else if (ACTION_RESET.equals(intent.getAction())) {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""***** MailService *****: reschedule"");

                rescheduleAll(hasConnectivity, doBackground, startIdObj);
                startIdObj = null;

            } else if (ACTION_RESTART_PUSHERS.equals(intent.getAction())) {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""***** MailService *****: restarting pushers"");
                reschedulePushers(hasConnectivity, doBackground, startIdObj);
                startIdObj = null;

            } else if (ACTION_RESCHEDULE_POLL.equals(intent.getAction())) {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""***** MailService *****: rescheduling poll"");
                reschedulePoll(hasConnectivity, doBackground, startIdObj, true);
                startIdObj = null;

            } else if (ACTION_REFRESH_PUSHERS.equals(intent.getAction())) {
                if (hasConnectivity && doBackground) {
                    refreshPushers(null);
                    schedulePushers(startIdObj);
                    startIdObj = null;
                }
            } else if (CONNECTIVITY_CHANGE.equals(intent.getAction())) {
                rescheduleAll(hasConnectivity, doBackground, startIdObj);
                startIdObj = null;
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Got connectivity action with hasConnectivity = "" + hasConnectivity + "", doBackground = "" + doBackground);
            } else if (CANCEL_CONNECTIVITY_NOTICE.equals(intent.getAction())) {
            }
            if (isSyncDisabled() != oldIsSyncDisabled) {
                MessagingController.getInstance(getApplication()).systemStatusChanged();
            }
        } finally {
            if (startIdObj != null) {
                stopSelf(startId);
            }
        }
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""MailService.onStart took "" + (System.currentTimeMillis() - startTime) + ""ms"");
    }

    private void rescheduleAll(final boolean hasConnectivity, final boolean doBackground, final Integer startId) {
        reschedulePoll(hasConnectivity, doBackground, null, true);
        reschedulePushers(hasConnectivity, doBackground, startId);

    }


    @Override
    public void onDestroy() {
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""***** MailService *****: onDestroy()"");
        super.onDestroy();
        //     MessagingController.getInstance(getApplication()).removeListener(mListener);
    }

    private void cancel() {
        Intent i = new Intent();
        i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.MailService"");
        i.setAction(ACTION_CHECK_MAIL);
        BootReceiver.cancelIntent(this, i);
    }

    private final static String PREVIOUS_INTERVAL = ""MailService.previousInterval"";
    private final static String LAST_CHECK_END = ""MailService.lastCheckEnd"";

    public static void saveLastCheckEnd(Context context) {

        long lastCheckEnd = System.currentTimeMillis();
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Saving lastCheckEnd = "" + new Date(lastCheckEnd));
        Preferences prefs = Preferences.getPreferences(context);
        SharedPreferences sPrefs = prefs.getPreferences();
        SharedPreferences.Editor editor = sPrefs.edit();
        editor.putLong(LAST_CHECK_END, lastCheckEnd);
        editor.commit();
    }

    private void reschedulePoll(final boolean hasConnectivity, final boolean doBackground, Integer startId, final boolean considerLastCheckEnd) {
        if (hasConnectivity && doBackground) {
            execute(getApplication(), new Runnable() {
                public void run() {
                    int shortestInterval = -1;

                    Preferences prefs = Preferences.getPreferences(MailService.this);
                    SharedPreferences sPrefs = prefs.getPreferences();
                    int previousInterval = sPrefs.getInt(PREVIOUS_INTERVAL, -1);
                    long lastCheckEnd = sPrefs.getLong(LAST_CHECK_END, -1);
                    for (Account account : prefs.getAccounts()) {
                        if (account.getAutomaticCheckIntervalMinutes() != -1
                                && account.getFolderSyncMode() != FolderMode.NONE
                        && (account.getAutomaticCheckIntervalMinutes() < shortestInterval || shortestInterval == -1)) {
                            shortestInterval = account.getAutomaticCheckIntervalMinutes();
                        }
                    }
                    SharedPreferences.Editor editor = sPrefs.edit();
                    editor.putInt(PREVIOUS_INTERVAL, shortestInterval);
                    editor.commit();

                    if (shortestInterval == -1) {
                        nextCheck = -1;
                        pollingRequested = false;
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""No next check scheduled for package "" + getApplication().getPackageName());
                        cancel();
                    } else {
                        long delay = (shortestInterval * (60 * 1000));
                        long base = (previousInterval == -1 || lastCheckEnd == -1 || !considerLastCheckEnd ? System.currentTimeMillis() : lastCheckEnd);
                        long nextTime = base + delay;
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG,
                                  ""previousInterval = "" + previousInterval
                                  + "", shortestInterval = "" + shortestInterval
                                  + "", lastCheckEnd = "" + new Date(lastCheckEnd)
                                  + "", considerLastCheckEnd = "" + considerLastCheckEnd);
                        nextCheck = nextTime;
                        pollingRequested = true;
                        try {
                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Next check for package "" + getApplication().getPackageName() + "" scheduled for "" + new Date(nextTime));
                        } catch (Exception e) {
                            // I once got a NullPointerException deep in new Date();
                            Log.e(K9.LOG_TAG, ""Exception while logging"", e);
                        }

                        Intent i = new Intent();
                        i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.MailService"");
                        i.setAction(ACTION_CHECK_MAIL);
                        BootReceiver.scheduleIntent(MailService.this, nextTime, i);

                    }
                }
            }
            , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
        } else {
            nextCheck = -1;
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""No connectivity, canceling check for "" + getApplication().getPackageName());
            cancel();
        }
    }

    public static boolean isSyncDisabled() {
        return  syncBlocked || (!pollingRequested && !pushingRequested);
    }

    private void stopPushers(final Integer startId) {
        execute(getApplication(), new Runnable() {
            public void run() {
                MessagingController.getInstance(getApplication()).stopAllPushing();
                PushService.stopService(MailService.this);
            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
    }

    private void reschedulePushers(final boolean hasConnectivity, final boolean doBackground, final Integer startId) {
        execute(getApplication(), new Runnable() {
            public void run() {

                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Rescheduling pushers"");
                stopPushers(null);
                if (hasConnectivity && doBackground) {
                    setupPushers(null);
                    schedulePushers(startId);
                } else {
                    if (K9.DEBUG) {
                        Log.i(K9.LOG_TAG, ""Not scheduling pushers:  connectivity? "" + hasConnectivity + "" -- doBackground? "" + doBackground);

                    }
                }

            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, null);
    }

    private void setupPushers(final Integer startId) {
        execute(getApplication(), new Runnable() {
            public void run() {
                boolean pushing = false;
                for (Account account : Preferences.getPreferences(MailService.this).getAccounts()) {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Setting up pushers for account "" + account.getDescription());
                    if (account.isAvailable(getApplicationContext())) {
                        pushing |= MessagingController.getInstance(getApplication()).setupPushing(account);
                    } else {
                        //TODO: setupPushing of unavailable accounts when they become available (sd-card inserted)
                    }
                }
                if (pushing) {
                    PushService.startService(MailService.this);
                }
                pushingRequested = pushing;
            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
    }

    private void refreshPushers(final Integer startId) {
        execute(getApplication(), new Runnable() {
            public void run() {
                try {
                    long nowTime = System.currentTimeMillis();
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Refreshing pushers"");
                    Collection<Pusher> pushers = MessagingController.getInstance(getApplication()).getPushers();
                    for (Pusher pusher : pushers) {
                        long lastRefresh = pusher.getLastRefresh();
                        int refreshInterval = pusher.getRefreshInterval();
                        long sinceLast = nowTime - lastRefresh;
                        if (sinceLast + 10000 > refreshInterval) { // Add 10 seconds to keep pushers in sync, avoid drift
                            if (K9.DEBUG) {
                                Log.d(K9.LOG_TAG, ""PUSHREFRESH: refreshing lastRefresh = "" + lastRefresh + "", interval = "" + refreshInterval
                                      + "", nowTime = "" + nowTime + "", sinceLast = "" + sinceLast);
                            }
                            pusher.refresh();
                            pusher.setLastRefresh(nowTime);
                        } else {
                            if (K9.DEBUG) {
                                Log.d(K9.LOG_TAG, ""PUSHREFRESH: NOT refreshing lastRefresh = "" + lastRefresh + "", interval = "" + refreshInterval
                                      + "", nowTime = "" + nowTime + "", sinceLast = "" + sinceLast);
                            }
                        }
                    }
                    // Whenever we refresh our pushers, send any unsent messages
                    if (K9.DEBUG) {
                        Log.d(K9.LOG_TAG, ""PUSHREFRESH:  trying to send mail in all folders!"");
                    }

                    MessagingController.getInstance(getApplication()).sendPendingMessages(null);

                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Exception while refreshing pushers"", e);
                }
            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
    }

    private void schedulePushers(final Integer startId) {
        execute(getApplication(), new Runnable() {
            public void run() {
                int minInterval = -1;

                Collection<Pusher> pushers = MessagingController.getInstance(getApplication()).getPushers();
                for (Pusher pusher : pushers) {
                    int interval = pusher.getRefreshInterval();
                    if (interval > 0 && (interval < minInterval || minInterval == -1)) {
                        minInterval = interval;
                    }
                }
                if (K9.DEBUG) {
                    Log.v(K9.LOG_TAG, ""Pusher refresh interval = "" + minInterval);
                }
                if (minInterval > 0) {
                    long nextTime = System.currentTimeMillis() + minInterval;
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Next pusher refresh scheduled for "" + new Date(nextTime));
                    Intent i = new Intent();
                    i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.MailService"");
                    i.setAction(ACTION_REFRESH_PUSHERS);
                    BootReceiver.scheduleIntent(MailService.this, nextTime, i);
                }
            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
    }


    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    public static long getNextPollTime() {
        return nextCheck;
    }


}
",True,146,2,1,6,46,10,10,L1
97,com.fsck.k9.service.CoreReceiver.java,"
package com.fsck.k9.service;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.PowerManager;
import android.util.Log;

import com.fsck.k9.K9;
import com.fsck.k9.helper.power.TracingPowerManager;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;

public class CoreReceiver extends BroadcastReceiver {

    public static String WAKE_LOCK_RELEASE = ""com.fsck.k9.service.CoreReceiver.wakeLockRelease"";

    public static String WAKE_LOCK_ID = ""com.fsck.k9.service.CoreReceiver.wakeLockId"";

    private static ConcurrentHashMap<Integer, TracingWakeLock> wakeLocks = new ConcurrentHashMap<Integer, TracingWakeLock>();
    private static AtomicInteger wakeLockSeq = new AtomicInteger(0);

    private static Integer getWakeLock(Context context) {
        TracingPowerManager pm = TracingPowerManager.getPowerManager(context);
        TracingWakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""CoreReceiver getWakeLock"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(K9.BOOT_RECEIVER_WAKE_LOCK_TIMEOUT);
        Integer tmpWakeLockId = wakeLockSeq.getAndIncrement();
        wakeLocks.put(tmpWakeLockId, wakeLock);
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""CoreReceiver Created wakeLock "" + tmpWakeLockId);
        return tmpWakeLockId;
    }

    private static void releaseWakeLock(Integer wakeLockId) {
        if (wakeLockId != null) {
            TracingWakeLock wl = wakeLocks.remove(wakeLockId);
            if (wl != null) {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""CoreReceiver Releasing wakeLock "" + wakeLockId);
                wl.release();
            } else {
                Log.w(K9.LOG_TAG, ""BootReceiver WakeLock "" + wakeLockId + "" doesn't exist"");
            }
        }
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        Integer tmpWakeLockId = CoreReceiver.getWakeLock(context);
        try {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""CoreReceiver.onReceive"" + intent);
            if (CoreReceiver.WAKE_LOCK_RELEASE.equals(intent.getAction())) {
                Integer wakeLockId = intent.getIntExtra(WAKE_LOCK_ID, -1);
                if (wakeLockId != -1) {
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""CoreReceiver Release wakeLock "" + wakeLockId);
                    CoreReceiver.releaseWakeLock(wakeLockId);
                }
            } else {
                tmpWakeLockId = receive(context, intent, tmpWakeLockId);
            }
        } finally {
            CoreReceiver.releaseWakeLock(tmpWakeLockId);
        }
    }

    public Integer receive(Context context, Intent intent, Integer wakeLockId) {
        return wakeLockId;
    }

    public static void releaseWakeLock(Context context, int wakeLockId) {
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""CoreReceiver Got request to release wakeLock "" + wakeLockId);
        Intent i = new Intent();
        i.setClass(context, CoreReceiver.class);
        i.setAction(WAKE_LOCK_RELEASE);
        i.putExtra(WAKE_LOCK_ID, wakeLockId);
        context.sendBroadcast(i);
    }
}
",True,145,1,1,7,53,3,2,L1
98,com.fsck.k9.service.StorageGoneReceiver.java,"package com.fsck.k9.service;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.util.Log;

import com.fsck.k9.K9;
import com.fsck.k9.mail.store.StorageManager;

/**
 * That BroadcastReceiver is only interested in UNMOUNT events.
 *
 * <p>
 * Code was separated from {@link StorageReceiver} because we don't want that
 * receiver to be statically defined in manifest.
 * </p>
 */
public class StorageGoneReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(final Context context, final Intent intent) {
        final String action = intent.getAction();
        final Uri uri = intent.getData();

        if (uri == null || uri.getPath() == null) {
            return;
        }

        if (K9.DEBUG) {
            Log.v(K9.LOG_TAG, ""StorageGoneReceiver: "" + intent.toString());
        }

        final String path = uri.getPath();

        if (Intent.ACTION_MEDIA_EJECT.equals(action)) {
            StorageManager.getInstance(K9.app).onBeforeUnmount(path);
        } else if (Intent.ACTION_MEDIA_UNMOUNTED.equals(action)) {
            StorageManager.getInstance(K9.app).onAfterUnmount(path);
        }
    }

}
",True,144,0,0,7,53,1,2,L1
99,com.fsck.k9.service.ShutdownReceiver.java,"package com.fsck.k9.service;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;

import com.fsck.k9.K9;

/**
 * Capture the system shutdown event in order to properly free resources.
 *
 * <p>
 * It is advised not to statically register (from AndroidManifest.xml) this
 * receiver in order to avoid unecessary K-9 launch (which would defeat the
 * purpose of that receiver). Using AndroidManifest.xml instructs Android to
 * launch K-9 if not running, defeating the purpose of this receiver. <br>
 * The recommended way is to register this receiver using
 * {@link Context#registerReceiver(BroadcastReceiver, android.content.IntentFilter)}
 * </p>
 */
public class ShutdownReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(final Context context, final Intent intent) {
        if (Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
            Log.i(K9.LOG_TAG, ""System is shutting down, releasing resources"");

            // prevent any scheduled intent from waking up K-9
            BootReceiver.purgeSchedule(context);

            /*
             * TODO invoke proper shutdown methods (stop any running thread)
             *
             * 20101111: this can't be done now as we don't have proper
             * startup/shutdown sequences
             */
        }
    }

}
",False,144,0,0,7,54,1,2,L1
100,com.fsck.k9.service.CoreService.java,"package com.fsck.k9.service;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicInteger;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.os.PowerManager;
import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.helper.power.TracingPowerManager;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;

public abstract class CoreService extends Service {

    public static String WAKE_LOCK_ID = ""com.fsck.k9.service.CoreService.wakeLockId"";
    private static ConcurrentHashMap<Integer, TracingWakeLock> wakeLocks = new ConcurrentHashMap<Integer, TracingWakeLock>();
    private static AtomicInteger wakeLockSeq = new AtomicInteger(0);
    private ExecutorService threadPool = null;
    private final String className = getClass().getName();
    private volatile boolean mShutdown = false;

    @Override
    public void onCreate() {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""CoreService: "" + className + "".onCreate()"");
        threadPool = Executors.newFixedThreadPool(1);  // Must be single threaded
        super.onCreate();

    }

    protected static void addWakeLockId(Intent i, Integer wakeLockId) {
        if (wakeLockId != null) {
            i.putExtra(BootReceiver.WAKE_LOCK_ID, wakeLockId);
        }
    }

    protected static void addWakeLock(Context context, Intent i) {
        TracingPowerManager pm = TracingPowerManager.getPowerManager(context);
        TracingWakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""CoreService addWakeLock"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT);

        Integer tmpWakeLockId = wakeLockSeq.getAndIncrement();
        wakeLocks.put(tmpWakeLockId, wakeLock);

        i.putExtra(WAKE_LOCK_ID, tmpWakeLockId);
    }



    @Override
    public void onStart(Intent intent, int startId) {
        TracingPowerManager pm = TracingPowerManager.getPowerManager(this);
        TracingWakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""CoreService onStart"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT);

        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""CoreService: "" + className + "".onStart("" + intent + "", "" + startId);

        int wakeLockId = intent.getIntExtra(BootReceiver.WAKE_LOCK_ID, -1);
        if (wakeLockId != -1) {
            BootReceiver.releaseWakeLock(this, wakeLockId);
        }
        Integer coreWakeLockId = intent.getIntExtra(WAKE_LOCK_ID, -1);
        if (coreWakeLockId != null && coreWakeLockId != -1) {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Got core wake lock id "" + coreWakeLockId);
            TracingWakeLock coreWakeLock = wakeLocks.remove(coreWakeLockId);
            if (coreWakeLock != null) {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Found core wake lock with id "" + coreWakeLockId + "", releasing"");
                coreWakeLock.release();
            }
        }

        try {
            super.onStart(intent, startId);
            startService(intent, startId);
        } finally {
            wakeLock.release();
        }
    }

    public void execute(Context context, final Runnable runner, int wakeLockTime, final Integer startId) {

        TracingPowerManager pm = TracingPowerManager.getPowerManager(context);
        final TracingWakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""CoreService execute"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(wakeLockTime);

        Runnable myRunner = new Runnable() {
            public void run() {
                try {
                    boolean oldIsSyncDisabled = MailService.isSyncDisabled();
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""CoreService ("" + className + "") running Runnable "" + runner.hashCode() + "" with startId "" + startId);
                    runner.run();
                    if (MailService.isSyncDisabled() != oldIsSyncDisabled) {
                        MessagingController.getInstance(getApplication()).systemStatusChanged();
                    }
                } finally {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""CoreService ("" + className + "") completed Runnable "" + runner.hashCode() + "" with startId "" + startId);
                    wakeLock.release();
                    if (startId != null) {
                        stopSelf(startId);
                    }
                }
            }

        };
        if (threadPool == null) {
            Log.e(K9.LOG_TAG, ""CoreService.execute ("" + className + "") called with no threadPool available; running Runnable "" + runner.hashCode() + "" in calling thread"", new Throwable());
            synchronized (this) {
                myRunner.run();
            }
        } else {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""CoreService ("" + className + "") queueing Runnable "" + runner.hashCode() + "" with startId "" + startId);
            try {
                threadPool.execute(myRunner);
            } catch (RejectedExecutionException e) {
                if (!mShutdown) {
                    throw e;
                }
                Log.i(K9.LOG_TAG, ""CoreService: "" + className + "" is shutting down, ignoring rejected execution exception: "" + e.getMessage());
            }
        }
    }

    public abstract void startService(Intent intent, int startId);

    @Override
    public IBinder onBind(Intent arg0) {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public void onLowMemory() {
        Log.w(K9.LOG_TAG, ""CoreService: "" + className + "".onLowMemory() - Running low on memory"");
    }

    @Override
    public void onDestroy() {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""CoreService: "" + className + "".onDestroy()"");
        mShutdown = true;
        threadPool.shutdown();
        super.onDestroy();
        //     MessagingController.getInstance(getApplication()).removeListener(mListener);
    }
}
",True,146,2,1,6,54,5,5,L1
101,com.fsck.k9.service.StorageReceiver.java,"package com.fsck.k9.service;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.util.Log;

import com.fsck.k9.K9;
import com.fsck.k9.mail.store.StorageManager;

/**
 * That BroadcastReceiver is only interested in MOUNT events.
 */
public class StorageReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(final Context context, final Intent intent) {
        final String action = intent.getAction();
        final Uri uri = intent.getData();

        if (uri == null || uri.getPath() == null) {
            return;
        }

        if (K9.DEBUG) {
            Log.v(K9.LOG_TAG, ""StorageReceiver: "" + intent.toString());
        }

        final String path = uri.getPath();

        if (Intent.ACTION_MEDIA_MOUNTED.equals(action)) {
            StorageManager.getInstance(K9.app).onMount(path,
                    intent.getBooleanExtra(""read-only"", true));
        }
    }

}
",True,145,0,0,7,53,0,2,L2
102,com.fsck.k9.service.BootReceiver.java,"
package com.fsck.k9.service;

import java.util.Date;

import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.net.ConnectivityManager;
import android.net.Uri;
import android.util.Log;

import com.fsck.k9.K9;
import com.fsck.k9.helper.AutoSyncHelper;

public class BootReceiver extends CoreReceiver {

    public static String FIRE_INTENT = ""com.fsck.k9.service.BroadcastReceiver.fireIntent"";
    public static String SCHEDULE_INTENT = ""com.fsck.k9.service.BroadcastReceiver.scheduleIntent"";
    public static String CANCEL_INTENT = ""com.fsck.k9.service.BroadcastReceiver.cancelIntent"";

    public static String ALARMED_INTENT = ""com.fsck.k9.service.BroadcastReceiver.pendingIntent"";
    public static String AT_TIME = ""com.fsck.k9.service.BroadcastReceiver.atTime"";

    @Override
    public Integer receive(Context context, Intent intent, Integer tmpWakeLockId) {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""BootReceiver.onReceive"" + intent);

        final String action = intent.getAction();
        if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
            //K9.setServicesEnabled(context, tmpWakeLockId);
            //tmpWakeLockId = null;
        } else if (Intent.ACTION_DEVICE_STORAGE_LOW.equals(action)) {
            MailService.actionCancel(context, tmpWakeLockId);
            tmpWakeLockId = null;
        } else if (Intent.ACTION_DEVICE_STORAGE_OK.equals(action)) {
            MailService.actionReset(context, tmpWakeLockId);
            tmpWakeLockId = null;
        } else if (ConnectivityManager.CONNECTIVITY_ACTION.equals(action)) {
            MailService.connectivityChange(context, tmpWakeLockId);
            tmpWakeLockId = null;
        } else if (AutoSyncHelper.SYNC_CONN_STATUS_CHANGE.equals(action)) {
            K9.BACKGROUND_OPS bOps = K9.getBackgroundOps();
            if (bOps == K9.BACKGROUND_OPS.WHEN_CHECKED_AUTO_SYNC) {
                MailService.actionReset(context, tmpWakeLockId);
                tmpWakeLockId = null;
            }
        } else if (ConnectivityManager.ACTION_BACKGROUND_DATA_SETTING_CHANGED.equals(action)) {
            K9.BACKGROUND_OPS bOps = K9.getBackgroundOps();
            if (bOps == K9.BACKGROUND_OPS.WHEN_CHECKED || bOps == K9.BACKGROUND_OPS.WHEN_CHECKED_AUTO_SYNC) {
                MailService.actionReset(context, tmpWakeLockId);
                tmpWakeLockId = null;
            }
        } else if (FIRE_INTENT.equals(action)) {
            Intent alarmedIntent = intent.getParcelableExtra(ALARMED_INTENT);
            String alarmedAction = alarmedIntent.getAction();
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""BootReceiver Got alarm to fire alarmedIntent "" + alarmedAction);
            alarmedIntent.putExtra(WAKE_LOCK_ID, tmpWakeLockId);
            tmpWakeLockId = null;
            context.startService(alarmedIntent);
        } else if (SCHEDULE_INTENT.equals(action)) {
            long atTime = intent.getLongExtra(AT_TIME, -1);
            Intent alarmedIntent = intent.getParcelableExtra(ALARMED_INTENT);
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""BootReceiver Scheduling intent "" + alarmedIntent + "" for "" + new Date(atTime));

            PendingIntent pi = buildPendingIntent(context, intent);
            AlarmManager alarmMgr = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);

            alarmMgr.set(AlarmManager.RTC_WAKEUP, atTime, pi);
        } else if (CANCEL_INTENT.equals(action)) {
            Intent alarmedIntent = intent.getParcelableExtra(ALARMED_INTENT);
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""BootReceiver Canceling alarmedIntent "" + alarmedIntent);

            PendingIntent pi = buildPendingIntent(context, intent);

            AlarmManager alarmMgr = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
            alarmMgr.cancel(pi);
        }


        return tmpWakeLockId;
    }

    private PendingIntent buildPendingIntent(Context context, Intent intent) {
        Intent alarmedIntent = intent.getParcelableExtra(ALARMED_INTENT);
        String alarmedAction = alarmedIntent.getAction();

        Intent i = new Intent(context, BootReceiver.class);
        i.setAction(FIRE_INTENT);
        i.putExtra(ALARMED_INTENT, alarmedIntent);
        Uri uri = Uri.parse(""action://"" + alarmedAction);
        i.setData(uri);
        PendingIntent pi = PendingIntent.getBroadcast(context, 0, i, 0);
        return pi;
    }

    public static void scheduleIntent(Context context, long atTime, Intent alarmedIntent) {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""BootReceiver Got request to schedule alarmedIntent "" + alarmedIntent.getAction());
        Intent i = new Intent();
        i.setClass(context, BootReceiver.class);
        i.setAction(SCHEDULE_INTENT);
        i.putExtra(ALARMED_INTENT, alarmedIntent);
        i.putExtra(AT_TIME, atTime);
        context.sendBroadcast(i);
    }

    public static void cancelIntent(Context context, Intent alarmedIntent) {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""BootReceiver Got request to cancel alarmedIntent "" + alarmedIntent.getAction());
        Intent i = new Intent();
        i.setClass(context, BootReceiver.class);
        i.setAction(CANCEL_INTENT);
        i.putExtra(ALARMED_INTENT, alarmedIntent);
        context.sendBroadcast(i);
    }

    /**
     * Cancel any scheduled alarm.
     *
     * @param context
     */
    public static void purgeSchedule(final Context context) {
        final AlarmManager alarmService = (AlarmManager) context
                                          .getSystemService(Context.ALARM_SERVICE);
        alarmService.cancel(PendingIntent.getBroadcast(context, 0, new Intent() {
            @Override
            public boolean filterEquals(final Intent other) {
                // we want to match all intents
                return true;
            }
        }, 0));
    }

}
",True,146,2,1,7,48,5,4,L1
103,com.fsck.k9.mail.CertificateValidationException.java,"
package com.fsck.k9.mail;

public class CertificateValidationException extends MessagingException {
    public static final long serialVersionUID = -1;

    public CertificateValidationException(String message) {
        super(message);
    }

    public CertificateValidationException(String message, Throwable throwable) {
        super(message, throwable);
    }
}",False,114,7,46,1,1,5,1,L1
104,com.fsck.k9.mail.Folder.java,"package com.fsck.k9.mail;

import java.util.Date;

import android.util.Log;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.controller.MessageRetrievalListener;


public abstract class Folder {
    protected final Account mAccount;

    private String status = null;
    private long lastChecked = 0;
    private long lastPush = 0;
    public enum OpenMode {
        READ_WRITE, READ_ONLY,
    }
    // NONE is obsolete, it will be translated to NO_CLASS for display and to INHERITED for sync and push
    public enum FolderClass {
        NONE, NO_CLASS, INHERITED, FIRST_CLASS, SECOND_CLASS
    }

    public enum FolderType {
        HOLDS_FOLDERS, HOLDS_MESSAGES,
    }

    protected Folder(Account account) {
        mAccount = account;
    }

    /**
     * Forces an open of the MailProvider. If the provider is already open this
     * function returns without doing anything.
     *
     * @param mode READ_ONLY or READ_WRITE
     */
    public abstract void open(OpenMode mode) throws MessagingException;

    /**
     * Forces a close of the MailProvider. Any further access will attempt to
     * reopen the MailProvider.
     */
    public abstract void close();

    /**
     * @return True if further commands are not expected to have to open the
     *         connection.
     */
    public abstract boolean isOpen();

    /**
     * Get the mode the folder was opened with. This may be different than the mode the open
     * was requested with.
     * @return
     */
    public abstract OpenMode getMode();

    public abstract boolean create(FolderType type) throws MessagingException;

    /**
     * Create a new folder with a specified display limit.  Not abstract to allow
     * remote folders to not override or worry about this call if they don't care to.
     */
    public boolean create(FolderType type, int displayLimit) throws MessagingException {
        return create(type);
    }

    public abstract boolean exists() throws MessagingException;

    /**
     * @return A count of the messages in the selected folder.
     */
    public abstract int getMessageCount() throws MessagingException;

    public abstract int getUnreadMessageCount() throws MessagingException;
    public abstract int getFlaggedMessageCount() throws MessagingException;

    public abstract Message getMessage(String uid) throws MessagingException;

    public abstract Message[] getMessages(int start, int end, Date earliestDate, MessageRetrievalListener listener)
    throws MessagingException;

    /**
     * Fetches the given list of messages. The specified listener is notified as
     * each fetch completes. Messages are downloaded as (as) lightweight (as
     * possible) objects to be filled in with later requests. In most cases this
     * means that only the UID is downloaded.
     *
     * @param uids
     * @param listener
     */
    public abstract Message[] getMessages(MessageRetrievalListener listener)
    throws MessagingException;

    public Message[] getMessages(MessageRetrievalListener listener, boolean includeDeleted) throws MessagingException {
        return getMessages(listener);
    }

    public abstract Message[] getMessages(String[] uids, MessageRetrievalListener listener)
    throws MessagingException;

    public abstract void appendMessages(Message[] messages) throws MessagingException;

    public void copyMessages(Message[] msgs, Folder folder) throws MessagingException {}

    public void moveMessages(Message[] msgs, Folder folder) throws MessagingException {}

    public void delete(Message[] msgs, String trashFolderName) throws MessagingException {
        for (Message message : msgs) {
            Message myMessage = getMessage(message.getUid());
            myMessage.delete(trashFolderName);
        }
    }

    public abstract void setFlags(Message[] messages, Flag[] flags, boolean value)
    throws MessagingException;

    public abstract void setFlags(Flag[] flags, boolean value) throws MessagingException;

    public abstract String getUidFromMessageId(Message message) throws MessagingException;

    public void expunge() throws MessagingException
        {}

    public abstract void fetch(Message[] messages, FetchProfile fp,
                               MessageRetrievalListener listener) throws MessagingException;

    public void fetchPart(Message message, Part part,
                          MessageRetrievalListener listener) throws MessagingException {
        // This is causing trouble. Disabled for now. See issue 1733
        //throw new RuntimeException(""fetchPart() not implemented."");

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""fetchPart() not implemented."");
    }

    public abstract void delete(boolean recurse) throws MessagingException;

    public abstract String getName();

    public abstract Flag[] getPermanentFlags();

    /**
     *
     * @param oldPushState
     * @param message
     * @return empty string to clear the pushState, null to leave the state as-is
     */
    public String getNewPushState(String oldPushState, Message message) {
        return null;
    }

    public boolean isFlagSupported(Flag flag) {
        return true;
    }

    public boolean supportsFetchingFlags() {
        return true;
    }

    @Override
    public String toString() {
        return getName();
    }

    public long getLastChecked() {
        return lastChecked;
    }

    public void setLastChecked(long lastChecked) throws MessagingException {
        this.lastChecked = lastChecked;
    }

    public long getLastPush() {
        return lastPush;
    }

    public void setLastPush(long lastCheckedDisplay) throws MessagingException {
        this.lastPush = lastCheckedDisplay;
    }

    public long getLastUpdate() {
        return Math.max(getLastChecked(), getLastPush());
    }

    public FolderClass getDisplayClass() {
        return FolderClass.NO_CLASS;
    }

    public FolderClass getSyncClass() {
        return getDisplayClass();
    }
    public FolderClass getPushClass() {
        return getSyncClass();
    }

    public void refresh(Preferences preferences) throws MessagingException {

    }

    public boolean isInTopGroup() {
        return false;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) throws MessagingException {
        this.status = status;
    }

    public Account getAccount() {
        return mAccount;
    }
}
",False,145,1,1,6,42,19,9,L1
105,com.fsck.k9.mail.FetchProfile.java,"
package com.fsck.k9.mail;

import java.util.ArrayList;

/**
 * <pre>
 * A FetchProfile is a list of items that should be downloaded in bulk for a set of messages.
 * FetchProfile can contain the following objects:
 *      FetchProfile.Item:      Described below.
 *      Message:                Indicates that the body of the entire message should be fetched.
 *                              Synonymous with FetchProfile.Item.BODY.
 *      Part:                   Indicates that the given Part should be fetched. The provider
 *                              is expected have previously created the given BodyPart and stored
 *                              any information it needs to download the content.
 * </pre>
 */
public class FetchProfile extends ArrayList<FetchProfile.Item> {
    private static final long serialVersionUID = -5520076119120964166L;

    /**
     * Default items available for pre-fetching. It should be expected that any
     * item fetched by using these items could potentially include all of the
     * previous items.
     */
    public enum Item {
        /**
         * Download the flags of the message.
         */
        FLAGS,

        /**
         * Download the envelope of the message. This should include at minimum
         * the size and the following headers: date, subject, from, content-type, to, cc
         */
        ENVELOPE,

        /**
         * Download the structure of the message. This maps directly to IMAP's BODYSTRUCTURE
         * and may map to other providers.
         * The provider should, if possible, fill in a properly formatted MIME structure in
         * the message without actually downloading any message data. If the provider is not
         * capable of this operation it should specifically set the body of the message to null
         * so that upper levels can detect that a full body download is needed.
         */
        STRUCTURE,

        /**
         * A sane portion of the entire message, cut off at a provider determined limit.
         * This should generaly be around 50kB.
         */
        BODY_SANE,

        /**
         * The entire message.
         */
        BODY,
    }
}
",False,113,5,63,0,0,6,0,L1
106,com.fsck.k9.mail.PushReceiver.java,"package com.fsck.k9.mail;

import java.util.List;

import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;

import android.content.Context;

public interface PushReceiver {
    public Context getContext();
    public void syncFolder(Folder folder);
    public void messagesArrived(Folder folder, List<Message> mess);
    public void messagesFlagsChanged(Folder folder, List<Message> mess);
    public void messagesRemoved(Folder folder, List<Message> mess);
    public String getPushState(String folderName);
    public void pushError(String errorMessage, Exception e);
    public void setPushActive(String folderName, boolean enabled);
    public void sleep(TracingWakeLock wakeLock, long millis);
}
",False,144,0,0,7,39,4,3,L1
107,com.fsck.k9.mail.Part.java,"
package com.fsck.k9.mail;

import java.io.IOException;
import java.io.OutputStream;

public interface Part {
    public void addHeader(String name, String value) throws MessagingException;

    public void removeHeader(String name) throws MessagingException;

    public void setHeader(String name, String value) throws MessagingException;

    public Body getBody();

    public String getContentType() throws MessagingException;

    public String getDisposition() throws MessagingException;

    public String getContentId() throws MessagingException;

    public String[] getHeader(String name) throws MessagingException;

    public int getSize();

    public boolean isMimeType(String mimeType) throws MessagingException;

    public String getMimeType() throws MessagingException;

    public void setBody(Body body) throws MessagingException;

    public void writeTo(OutputStream out) throws IOException, MessagingException;
}
",False,115,4,51,1,2,19,2,L1
108,com.fsck.k9.mail.Authentication.java,"package com.fsck.k9.mail;

import java.security.MessageDigest;

import com.fsck.k9.mail.filter.Base64;
import com.fsck.k9.mail.filter.Hex;

public class Authentication {
    private static final String US_ASCII = ""US-ASCII"";

    /**
     * Computes the response for CRAM-MD5 authentication mechanism given the user credentials and
     * the server-provided nonce.
     *
     * @param username The username.
     * @param password The password.
     * @param b64Nonce The nonce as base64-encoded string.
     * @return The CRAM-MD5 response.
     *
     * @throws AuthenticationFailedException If something went wrong.
     *
     * @see Authentication#computeCramMd5Bytes(String, String, byte[])
     */
    public static String computeCramMd5(String username, String password, String b64Nonce)
    throws AuthenticationFailedException {

        try {
            byte[] b64NonceBytes = b64Nonce.getBytes(US_ASCII);
            byte[] b64CRAM = computeCramMd5Bytes(username, password, b64NonceBytes);
            return new String(b64CRAM, US_ASCII);
        } catch (AuthenticationFailedException e) {
            throw e;
        } catch (Exception e) {
            throw new AuthenticationFailedException(""This shouldn't happen"", e);
        }
    }

    /**
     * Computes the response for CRAM-MD5 authentication mechanism given the user credentials and
     * the server-provided nonce.
     *
     * @param username The username.
     * @param password The password.
     * @param b64Nonce The nonce as base64-encoded byte array.
     * @return The CRAM-MD5 response as byte array.
     *
     * @throws AuthenticationFailedException If something went wrong.
     *
     * @see <a href=""https://tools.ietf.org/html/rfc2195"">RFC 2195</a>
     */
    public static byte[] computeCramMd5Bytes(String username, String password, byte[] b64Nonce)
    throws AuthenticationFailedException {

        try {
            byte[] nonce = Base64.decodeBase64(b64Nonce);

            byte[] secretBytes = password.getBytes(US_ASCII);
            MessageDigest md = MessageDigest.getInstance(""MD5"");
            if (secretBytes.length > 64) {
                secretBytes = md.digest(secretBytes);
            }

            byte[] ipad = new byte[64];
            byte[] opad = new byte[64];
            System.arraycopy(secretBytes, 0, ipad, 0, secretBytes.length);
            System.arraycopy(secretBytes, 0, opad, 0, secretBytes.length);
            for (int i = 0; i < ipad.length; i++) ipad[i] ^= 0x36;
            for (int i = 0; i < opad.length; i++) opad[i] ^= 0x5c;

            md.update(ipad);
            byte[] firstPass = md.digest(nonce);

            md.update(opad);
            byte[] result = md.digest(firstPass);

            String plainCRAM = username + "" "" + new String(Hex.encodeHex(result));
            byte[] b64CRAM = Base64.encodeBase64(plainCRAM.getBytes(US_ASCII));

            return b64CRAM;

        } catch (Exception e) {
            throw new AuthenticationFailedException(""Something went wrong during CRAM-MD5 computation"", e);
        }
    }
}
",True,117,7,48,2,3,3,3,L1
109,com.fsck.k9.mail.Flag.java,"
package com.fsck.k9.mail;

/**
 * Flags that can be applied to Messages.
 */
public enum Flag {
    DELETED,
    SEEN,
    ANSWERED,
    FLAGGED,
    DRAFT,
    RECENT,

    /*
     * The following flags are for internal library use only.
     */
    /**
     * Delete and remove from the LocalStore immediately.
     */
    X_DESTROYED,

    /**
     * Sending of an unsent message failed. It will be retried. Used to show status.
     */
    X_SEND_FAILED,

    /**
     * Sending of an unsent message is in progress.
     */
    X_SEND_IN_PROGRESS,

    /**
     * Indicates that a message is fully downloaded from the server and can be viewed normally.
     * This does not include attachments, which are never downloaded fully.
     */
    X_DOWNLOADED_FULL,

    /**
     * Indicates that a message is partially downloaded from the server and can be viewed but
     * more content is available on the server.
     * This does not include attachments, which are never downloaded fully.
     */
    X_DOWNLOADED_PARTIAL,

    /**
     * Indicates that the copy of a message to the Sent folder has started.
     */
    X_REMOTE_COPY_STARTED,

    /**
     * Indicates that all headers of the message have been stored in the
     * database. If this is false, additional headers might be retrieved from
     * the server (if the message is still there).
     */
    X_GOT_ALL_HEADERS,
}
",False,115,4,52,0,0,20,0,L1
110,com.fsck.k9.mail.Pusher.java,"package com.fsck.k9.mail;

import java.util.List;


public interface Pusher {
    public void start(List<String> folderNames);
    public void refresh();
    public void stop();
    /**
     *
     * @return milliseconds of required refresh interval
     */
    public int getRefreshInterval();
    public void setLastRefresh(long lastRefresh);
    public long getLastRefresh();
}
",False,113,5,61,0,0,4,0,L1
111,com.fsck.k9.mail.AuthenticationFailedException.java,"
package com.fsck.k9.mail;

public class AuthenticationFailedException extends MessagingException {
    public static final long serialVersionUID = -1;

    public AuthenticationFailedException(String message) {
        super(message);
    }

    public AuthenticationFailedException(String message, Throwable throwable) {
        super(message, throwable);
    }
}
",False,115,7,46,1,1,5,1,L1
112,com.fsck.k9.mail.Message.java,"
package com.fsck.k9.mail;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;
import java.io.IOException;

import android.util.Log;

import com.fsck.k9.activity.MessageReference;
import com.fsck.k9.mail.filter.CountingOutputStream;
import com.fsck.k9.mail.filter.EOLConvertingOutputStream;

import com.fsck.k9.mail.store.UnavailableStorageException;
import com.fsck.k9.K9;


public abstract class Message implements Part, Body {
    private static final Flag[] EMPTY_FLAG_ARRAY = new Flag[0];

    private MessageReference mReference = null;

    public enum RecipientType {
        TO, CC, BCC,
    }

    protected String mUid;

    protected HashSet<Flag> mFlags = new HashSet<Flag>();

    protected Date mInternalDate;

    protected Folder mFolder;

    public boolean olderThan(Date earliestDate) {
        if (earliestDate == null) {
            return false;
        }
        Date myDate = getSentDate();
        if (myDate == null) {
            myDate = getInternalDate();
        }
        if (myDate != null) {
            return myDate.before(earliestDate);
        }
        return false;
    }
    @Override
    public boolean equals(Object o) {
        if (o == null || !(o instanceof Message)) {
            return false;
        }
        Message other = (Message)o;
        return (mFolder.getName().equals(other.getFolder().getName())
                && mFolder.getAccount().getUuid().equals(other.getFolder().getAccount().getUuid())
                && mUid.equals(other.getUid()));
    }

    @Override
    public int hashCode() {
        final int MULTIPLIER = 31;

        int result = 1;
        result = MULTIPLIER * result + mFolder.getName().hashCode();
        result = MULTIPLIER * result + mFolder.getAccount().getUuid().hashCode();
        result = MULTIPLIER * result + mUid.hashCode();
        return result;
    }

    public String getUid() {
        return mUid;
    }

    public void setUid(String uid) {
        mReference = null;
        this.mUid = uid;
    }

    public Folder getFolder() {
        return mFolder;
    }

    public abstract String getSubject();

    public abstract void setSubject(String subject) throws MessagingException;

    public Date getInternalDate() {
        return mInternalDate;
    }

    public void setInternalDate(Date internalDate) {
        this.mInternalDate = internalDate;
    }

    public abstract Date getSentDate();

    public abstract void setSentDate(Date sentDate) throws MessagingException;

    public abstract Address[] getRecipients(RecipientType type) throws MessagingException;

    public abstract void setRecipients(RecipientType type, Address[] addresses)
    throws MessagingException;

    public void setRecipient(RecipientType type, Address address) throws MessagingException {
        setRecipients(type, new Address[] {
                          address
                      });
    }

    public abstract Address[] getFrom();

    public abstract void setFrom(Address from) throws MessagingException;

    public abstract Address[] getReplyTo();

    public abstract void setReplyTo(Address[] from) throws MessagingException;

    public abstract String getMessageId() throws MessagingException;

    public abstract void setInReplyTo(String inReplyTo) throws MessagingException;

    public abstract String[] getReferences() throws MessagingException;

    public abstract void setReferences(String references) throws MessagingException;

    public abstract Body getBody();

    public abstract String getContentType() throws MessagingException;

    public abstract void addHeader(String name, String value) throws MessagingException;

    public abstract void setHeader(String name, String value) throws MessagingException;

    public abstract String[] getHeader(String name) throws MessagingException;

    public abstract Set<String> getHeaderNames() throws UnavailableStorageException;

    public abstract void removeHeader(String name) throws MessagingException;

    public abstract void setBody(Body body) throws MessagingException;

    public boolean isMimeType(String mimeType) throws MessagingException {
        return getContentType().startsWith(mimeType);
    }

    public void delete(String trashFolderName) throws MessagingException {}

    /*
     * TODO Refactor Flags at some point to be able to store user defined flags.
     */
    public Flag[] getFlags() {
        return mFlags.toArray(EMPTY_FLAG_ARRAY);
    }

    /**
     * @param flag
     *            Flag to set. Never <code>null</code>.
     * @param set
     *            If <code>true</code>, the flag is added. If <code>false</code>
     *            , the flag is removed.
     * @throws MessagingException
     */
    public void setFlag(Flag flag, boolean set) throws MessagingException {
        if (set) {
            mFlags.add(flag);
        } else {
            mFlags.remove(flag);
        }
    }

    /**
     * This method calls setFlag(Flag, boolean)
     * @param flags
     * @param set
     */
    public void setFlags(Flag[] flags, boolean set) throws MessagingException {
        for (Flag flag : flags) {
            setFlag(flag, set);
        }
    }

    public boolean isSet(Flag flag) {
        return mFlags.contains(flag);
    }


    public void destroy() throws MessagingException {}

    public abstract void saveChanges() throws MessagingException;

    public abstract void setEncoding(String encoding) throws UnavailableStorageException;

    public abstract void setCharset(String charset) throws MessagingException;

    public MessageReference makeMessageReference() {
        if (mReference == null) {
            mReference = new MessageReference();
            mReference.accountUuid = getFolder().getAccount().getUuid();
            mReference.folderName = getFolder().getName();
            mReference.uid = mUid;
        }
        return mReference;
    }

    public boolean equalsReference(MessageReference ref) {
        MessageReference tmpReference = makeMessageReference();
        return tmpReference.equals(ref);
    }

    public long calculateSize() {
        try {

            CountingOutputStream out = new CountingOutputStream();
            EOLConvertingOutputStream eolOut = new EOLConvertingOutputStream(out);
            writeTo(eolOut);
            eolOut.flush();
            return out.getCount();
        } catch (IOException e) {
            Log.e(K9.LOG_TAG, ""Failed to calculate a message size: "" + e);
        } catch (MessagingException e) {
            Log.e(K9.LOG_TAG, ""Failed to calculate a message size: "" + e);
        }
        return 0;
    }

}
",True,146,1,2,6,43,34,12,L1
113,com.fsck.k9.mail.Body.java,"
package com.fsck.k9.mail;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public interface Body {
    public InputStream getInputStream() throws MessagingException;
    public void writeTo(OutputStream out) throws IOException, MessagingException;
}
",False,117,4,58,1,1,11,1,L1
114,com.fsck.k9.mail.Transport.java,"
package com.fsck.k9.mail;

import com.fsck.k9.Account;
import com.fsck.k9.mail.transport.SmtpTransport;
import com.fsck.k9.mail.transport.WebDavTransport;

public abstract class Transport {
    protected static final int SOCKET_CONNECT_TIMEOUT = 10000;

    // RFC 1047
    protected static final int SOCKET_READ_TIMEOUT = 300000;

    public synchronized static Transport getInstance(Account account) throws MessagingException {
        String uri = account.getTransportUri();
        if (uri.startsWith(""smtp"")) {
            return new SmtpTransport(uri);
        } else if (uri.startsWith(""webdav"")) {
            return new WebDavTransport(account);
        } else {
            throw new MessagingException(""Unable to locate an applicable Transport for "" + uri);
        }
    }

    public abstract void open() throws MessagingException;

    public abstract void sendMessage(Message message) throws MessagingException;

    public abstract void close();
}
",False,144,0,0,7,38,4,5,L1
115,com.fsck.k9.mail.BodyPart.java,"
package com.fsck.k9.mail;

public abstract class BodyPart implements Part {
    private Multipart mParent;

    public Multipart getParent() {
        return mParent;
    }

    public void setParent(Multipart parent) {
        mParent = parent;
    }
}
",False,144,0,0,9,40,5,2,L1
116,com.fsck.k9.mail.Store.java,"
package com.fsck.k9.mail;

import android.app.Application;
import android.content.Context;

import com.fsck.k9.Account;
import com.fsck.k9.mail.store.ImapStore;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.Pop3Store;
import com.fsck.k9.mail.store.WebDavStore;
import com.fsck.k9.mail.store.StorageManager.StorageProvider;

import java.util.HashMap;
import java.util.List;

/**
 * Store is the access point for an email message store. It's location can be
 * local or remote and no specific protocol is defined. Store is intended to
 * loosely model in combination the JavaMail classes javax.mail.Store and
 * javax.mail.Folder along with some additional functionality to improve
 * performance on mobile devices. Implementations of this class should focus on
 * making as few network connections as possible.
 */
public abstract class Store {
    protected static final int SOCKET_CONNECT_TIMEOUT = 30000;
    protected static final int SOCKET_READ_TIMEOUT = 60000;

    /**
     * Remote stores indexed by Uri.
     */
    private static HashMap<String, Store> mStores = new HashMap<String, Store>();
    /**
     * Local stores indexed by UUid because the Uri may change due to migration to/from SD-card.
     */
    private static HashMap<String, Store> mLocalStores = new HashMap<String, Store>();

    protected final Account mAccount;

    protected Store(Account account) {
        mAccount = account;
    }

    /**
     * Get an instance of a remote mail store.
     */
    public synchronized static Store getRemoteInstance(Account account) throws MessagingException {
        String uri = account.getStoreUri();

        if (uri.startsWith(""local"")) {
            throw new RuntimeException(""Asked to get non-local Store object but given LocalStore URI"");
        }

        Store store = mStores.get(uri);
        if (store == null) {
            if (uri.startsWith(""imap"")) {
                store = new ImapStore(account);
            } else if (uri.startsWith(""pop3"")) {
                store = new Pop3Store(account);
            } else if (uri.startsWith(""webdav"")) {
                store = new WebDavStore(account);
            }

            if (store != null) {
                mStores.put(uri, store);
            }
        }

        if (store == null) {
            throw new MessagingException(""Unable to locate an applicable Store for "" + uri);
        }

        return store;
    }

    /**
     * Get an instance of a local mail store.
     * @throws UnavailableStorageException if not {@link StorageProvider#isReady(Context)}
     */
    public synchronized static LocalStore getLocalInstance(Account account, Application application) throws MessagingException {
        Store store = mLocalStores.get(account.getUuid());
        if (store == null) {
            store = new LocalStore(account, application);
            mLocalStores.put(account.getUuid(), store);
        }

        return (LocalStore) store;
    }

    public abstract Folder getFolder(String name);

    public abstract List <? extends Folder > getPersonalNamespaces(boolean forceListAll) throws MessagingException;

    public abstract void checkSettings() throws MessagingException;

    public boolean isCopyCapable() {
        return false;
    }
    public boolean isMoveCapable() {
        return false;
    }
    public boolean isPushCapable() {
        return false;
    }
    public boolean isSendCapable() {
        return false;
    }
    public boolean isExpungeCapable() {
        return false;
    }


    public void sendMessages(Message[] messages) throws MessagingException {
    }

    public Pusher getPusher(PushReceiver receiver) {
        return null;
    }

    public Account getAccount() {
        return mAccount;
    }
}
",False,145,1,1,7,43,12,11,L1
117,com.fsck.k9.mail.Address.java,"
package com.fsck.k9.mail;

import android.text.Spannable;
import android.text.SpannableString;
import android.text.SpannableStringBuilder;
import android.text.style.ForegroundColorSpan;
import android.text.util.Rfc822Token;
import android.text.util.Rfc822Tokenizer;
import android.util.Log;

import com.fsck.k9.K9;
import com.fsck.k9.helper.Contacts;
import com.fsck.k9.helper.Utility;
import org.apache.james.mime4j.codec.EncoderUtil;
import org.apache.james.mime4j.dom.address.Mailbox;
import org.apache.james.mime4j.dom.address.MailboxList;
import org.apache.james.mime4j.field.address.parser.AddressBuilder;
import org.apache.james.mime4j.MimeException;

import java.util.ArrayList;
import java.util.List;


public class Address {
    /**
     * If the number of addresses exceeds this value the addresses aren't
     * resolved to the names of Android contacts.
     *
     * <p>
     * TODO: This number was chosen arbitrarily and should be determined by
     * performance tests.
     * </p>
     *
     * @see Address#toFriendly(Address[], Contacts)
     */
    private static final int TOO_MANY_ADDRESSES = 50;

    /**
     * Immutable empty {@link Address} array
     */
    private static final Address[] EMPTY_ADDRESS_ARRAY = new Address[0];

    String mAddress;

    String mPersonal;

    public Address(String address, String personal) {
        this(address, personal, true);
    }

    public Address(String address) {
        this(address, null);
    }

    private Address(String address, String personal, boolean parse) {
        if (parse) {
            Rfc822Token[] tokens =  Rfc822Tokenizer.tokenize(address);
            if (tokens.length > 0) {
                Rfc822Token token = tokens[0];
                mAddress = token.getAddress();
                String name = token.getName();
                if ((name != null) && !("""".equals(name))) {
                    /*
                     * Don't use the ""personal"" argument if ""address"" is of the form:
                     * James Bond <james.bond@mi6.uk>
                     *
                     * See issue 2920
                     */
                    mPersonal = name;
                } else {
                    mPersonal = (personal == null) ? null : personal.trim();
                }
            } else {
                // This should be an error
            }
        } else {
            mAddress = address;
            mPersonal = personal;
        }
    }

    public String getAddress() {
        return mAddress;
    }

    public void setAddress(String address) {
        this.mAddress = address;
    }

    public String getPersonal() {
        return mPersonal;
    }

    public void setPersonal(String personal) {
        if ("""".equals(personal)) {
            personal = null;
        }
        if (personal != null) {
            personal = personal.trim();
        }
        this.mPersonal = personal;
    }

    /**
     * Parse a comma separated list of email addresses in human readable format and return an
     * array of Address objects, RFC-822 encoded.
     *
     * @param addressList
     * @return An array of 0 or more Addresses.
     */
    public static Address[] parseUnencoded(String addressList) {
        List<Address> addresses = new ArrayList<Address>();
        if ((addressList != null) && !("""".equals(addressList))) {
            Rfc822Token[] tokens = Rfc822Tokenizer.tokenize(addressList);
            for (Rfc822Token token : tokens) {
                String address = token.getAddress();
                if ((address != null) && !("""".equals(address))) {
                    addresses.add(new Address(token.getAddress(), token.getName(), false));
                }
            }
        }
        return addresses.toArray(EMPTY_ADDRESS_ARRAY);
    }

    /**
     * Parse a comma separated list of addresses in RFC-822 format and return an
     * array of Address objects.
     *
     * @param addressList
     * @return An array of 0 or more Addresses.
     */
    public static Address[] parse(String addressList) {
        ArrayList<Address> addresses = new ArrayList<Address>();
        if ((addressList == null) && !("""".equals(addressList))) {
            return EMPTY_ADDRESS_ARRAY;
        }
        try {
            MailboxList parsedList = AddressBuilder.parseAddressList(addressList).flatten();
            for (int i = 0, count = parsedList.size(); i < count; i++) {
                org.apache.james.mime4j.dom.address.Address address = parsedList.get(i);
                if (address instanceof Mailbox) {
                    Mailbox mailbox = (Mailbox)address;
                    addresses.add(new Address(mailbox.getLocalPart() + ""@"" + mailbox.getDomain(), mailbox.getName(), false));
                } else {
                    Log.e(K9.LOG_TAG, ""Unknown address type from Mime4J: ""
                          + address.getClass().toString());
                }
            }
        } catch (MimeException pe) {
            Log.e(K9.LOG_TAG, ""MimeException in Address.parse()"", pe);
        }
        return addresses.toArray(EMPTY_ADDRESS_ARRAY);
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof Address) {
            return getAddress().equals(((Address) o).getAddress());
        }
        return super.equals(o);
    }

    @Override
    public int hashCode() {
        return getAddress().hashCode();
    }

    @Override
    public String toString() {
        if (mPersonal != null && !mPersonal.equals("""")) {
            return Utility.quoteAtoms(mPersonal) + "" <"" + mAddress + "">"";
        } else {
            return mAddress;
        }
    }

    public static String toString(Address[] addresses) {
        if (addresses == null) {
            return null;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < addresses.length; i++) {
            sb.append(addresses[i].toString());
            if (i < addresses.length - 1) {
                sb.append("", "");
            }
        }
        return sb.toString();
    }

    public String toEncodedString() {
        if (mPersonal != null && !mPersonal.equals("""")) {
            return EncoderUtil.encodeAddressDisplayName(mPersonal) + "" <"" + mAddress + "">"";
        } else {
            return mAddress;
        }
    }

    public static String toEncodedString(Address[] addresses) {
        if (addresses == null) {
            return null;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < addresses.length; i++) {
            sb.append(addresses[i].toEncodedString());
            if (i < addresses.length - 1) {
                sb.append(',');
            }
        }
        return sb.toString();
    }

    /**
     * Returns either the personal portion of the Address or the address portion if the personal
     * is not available.
     * @return
     */
    public CharSequence toFriendly() {
        return toFriendly((Contacts)null);
    }

    /**
     * Returns the name of the contact this email address belongs to if
     * the {@link Contacts contacts} parameter is not {@code null} and a
     * contact is found. Otherwise the personal portion of the {@link Address}
     * is returned. If that isn't available either, the email address is
     * returned.
     *
     * @param contacts
     *         A {@link Contacts} instance or {@code null}.
     * @return
     *         A ""friendly"" name for this {@link Address}.
     */
    public CharSequence toFriendly(final Contacts contacts) {
        if (!K9.showCorrespondentNames()) {
            return mAddress;

        } else if (contacts != null) {
            final String name = contacts.getNameForAddress(mAddress);

            // TODO: The results should probably be cached for performance reasons.

            if (name != null) {
                if (K9.changeContactNameColor()) {
                    final SpannableString coloredName = new SpannableString(name);
                    coloredName.setSpan(new ForegroundColorSpan(K9.getContactNameColor()),
                                        0,
                                        coloredName.length(),
                                        Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                                       );
                    return coloredName;
                } else {
                    return name;
                }
            }
        }

        return ((mPersonal != null) && (mPersonal.length() > 0)) ? mPersonal : mAddress;
    }

    public static CharSequence toFriendly(Address[] addresses) {
        return toFriendly(addresses, null);
    }

    public static CharSequence toFriendly(Address[] addresses, Contacts contacts) {
        if (addresses == null) {
            return null;
        }

        if (addresses.length >= TOO_MANY_ADDRESSES) {
            // Don't look up contacts if the number of addresses is very high.
            contacts = null;
        }

        SpannableStringBuilder sb = new SpannableStringBuilder();
        for (int i = 0; i < addresses.length; i++) {
            sb.append(addresses[i].toFriendly(contacts));
            if (i < addresses.length - 1) {
                sb.append(',');
            }
        }
        return sb;
    }

    /**
     * Unpacks an address list previously packed with packAddressList()
     * @param addressList Packed address list.
     * @return Unpacked list.
     */
    public static Address[] unpack(String addressList) {
        if (addressList == null) {
            return new Address[] { };
        }
        ArrayList<Address> addresses = new ArrayList<Address>();
        int length = addressList.length();
        int pairStartIndex = 0;
        int pairEndIndex = 0;
        int addressEndIndex = 0;
        while (pairStartIndex < length) {
            pairEndIndex = addressList.indexOf("",\u0000"", pairStartIndex);
            if (pairEndIndex == -1) {
                pairEndIndex = length;
            }
            addressEndIndex = addressList.indexOf("";\u0000"", pairStartIndex);
            String address = null;
            String personal = null;
            if (addressEndIndex == -1 || addressEndIndex > pairEndIndex) {
                address = addressList.substring(pairStartIndex, pairEndIndex);
            } else {
                address = addressList.substring(pairStartIndex, addressEndIndex);
                personal = addressList.substring(addressEndIndex + 2, pairEndIndex);
            }
            addresses.add(new Address(address, personal, false));
            pairStartIndex = pairEndIndex + 2;
        }
        return addresses.toArray(new Address[addresses.size()]);
    }

    /**
     * Packs an address list into a String that is very quick to read
     * and parse. Packed lists can be unpacked with unpackAddressList()
     * The packed list is a "",\u0000"" separated list of:
     * address;\u0000personal
     * @param addresses Array of addresses to pack.
     * @return Packed addresses.
     */
    public static String pack(Address[] addresses) {
        if (addresses == null) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0, count = addresses.length; i < count; i++) {
            Address address = addresses[i];
            sb.append(address.getAddress());
            String personal = address.getPersonal();
            if (personal != null) {
                sb.append("";\u0000"");
                // Escape quotes in the address part on the way in
                personal = personal.replaceAll(""\"""", ""\\\"""");
                sb.append(personal);
            }
            if (i < count - 1) {
                sb.append("",\u0000"");
            }
        }
        return sb.toString();
    }
}
",False,147,2,2,7,53,16,3,L1
118,com.fsck.k9.mail.MessagingException.java,"
package com.fsck.k9.mail;

public class MessagingException extends Exception {
    public static final long serialVersionUID = -1;

    boolean permanentFailure = false;

    public MessagingException(String message) {
        super(message);
    }

    public MessagingException(String message, boolean perm) {
        super(message);
        permanentFailure = perm;
    }

    public MessagingException(String message, Throwable throwable) {
        super(message, throwable);
    }

    public MessagingException(String message, boolean perm, Throwable throwable) {
        super(message, throwable);
        permanentFailure = perm;
    }

    public boolean isPermanentFailure() {
        return permanentFailure;
    }

    public void setPermanentFailure(boolean permanentFailure) {
        this.permanentFailure = permanentFailure;
    }


}
",True,122,3,70,0,0,43,0,L1
119,com.fsck.k9.mail.Multipart.java,"
package com.fsck.k9.mail;

import java.util.ArrayList;

import com.fsck.k9.mail.internet.MimeHeader;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.internet.TextBody;

public abstract class Multipart implements Body {
    protected Part mParent;

    protected ArrayList<BodyPart> mParts = new ArrayList<BodyPart>();

    protected String mContentType;

    public void addBodyPart(BodyPart part) {
        mParts.add(part);
        part.setParent(this);
    }

    public void addBodyPart(BodyPart part, int index) {
        mParts.add(index, part);
        part.setParent(this);
    }

    public BodyPart getBodyPart(int index) {
        return mParts.get(index);
    }

    public String getContentType() {
        return mContentType;
    }

    public int getCount() {
        return mParts.size();
    }

    public boolean removeBodyPart(BodyPart part) {
        part.setParent(null);
        return mParts.remove(part);
    }

    public void removeBodyPart(int index) {
        mParts.get(index).setParent(null);
        mParts.remove(index);
    }

    public Part getParent() {
        return mParent;
    }

    public void setParent(Part parent) {
        this.mParent = parent;
    }

    public void setEncoding(String encoding) {
        for (BodyPart part : mParts) {
            try {
                Body body = part.getBody();
                if (body instanceof TextBody) {
                    part.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, encoding);
                    ((TextBody)body).setEncoding(encoding);
                }
            } catch (MessagingException e) {
                // Ignore
            }
        }

    }

    public void setCharset(String charset) throws MessagingException {
        if (mParts.isEmpty())
            return;

        BodyPart part = mParts.get(0);
        Body body = part.getBody();
        if (body instanceof TextBody) {
            MimeUtility.setCharset(charset, part);
            ((TextBody)body).setCharset(charset);
        }
    }
}
",True,144,0,0,8,40,9,7,L1
120,com.fsck.k9.mail.transport.WebDavTransport.java,"
package com.fsck.k9.mail.transport;

import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Transport;
import com.fsck.k9.mail.store.WebDavStore;

public class WebDavTransport extends Transport {
    private WebDavStore store;

    public WebDavTransport(Account account) throws MessagingException {
        if (account.getRemoteStore() instanceof WebDavStore) {
            store = (WebDavStore) account.getRemoteStore();
        } else {
            store = new WebDavStore(account);
        }

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, "">>> New WebDavTransport creation complete"");
    }

    @Override
    public void open() throws MessagingException {
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, "">>> open called on WebDavTransport "");

        store.getHttpClient();
    }

    @Override
    public void close() {
    }

    @Override
    public void sendMessage(Message message) throws MessagingException {
        store.sendMessages(new Message[] { message });
    }
}
",False,144,0,0,6,47,1,6,L1
121,com.fsck.k9.mail.transport.TrustedSocketFactory.java,"package com.fsck.k9.mail.transport;

import com.fsck.k9.mail.store.TrustManagerFactory;
import org.apache.http.conn.ConnectTimeoutException;
import org.apache.http.conn.scheme.LayeredSocketFactory;
import org.apache.http.params.HttpParams;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

public class TrustedSocketFactory implements LayeredSocketFactory {
    private SSLSocketFactory mSocketFactory;
    private org.apache.http.conn.ssl.SSLSocketFactory mSchemeSocketFactory;

    public TrustedSocketFactory(String host, boolean secure) throws NoSuchAlgorithmException, KeyManagementException {
        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, new TrustManager[] {
                            TrustManagerFactory.get(host, secure)
                        }, new SecureRandom());
        mSocketFactory = sslContext.getSocketFactory();
        mSchemeSocketFactory = org.apache.http.conn.ssl.SSLSocketFactory.getSocketFactory();
        mSchemeSocketFactory.setHostnameVerifier(
            org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
    }

    public Socket connectSocket(Socket sock, String host, int port,
                                InetAddress localAddress, int localPort, HttpParams params)
    throws IOException, UnknownHostException, ConnectTimeoutException {
        return mSchemeSocketFactory.connectSocket(sock, host, port, localAddress, localPort, params);
    }

    public Socket createSocket() throws IOException {
        return mSocketFactory.createSocket();
    }

    public boolean isSecure(Socket sock) throws IllegalArgumentException {
        return mSchemeSocketFactory.isSecure(sock);
    }
    public Socket createSocket(
        final Socket socket,
        final String host,
        final int port,
        final boolean autoClose
    ) throws IOException, UnknownHostException {
        SSLSocket sslSocket = (SSLSocket) mSocketFactory.createSocket(
                                  socket,
                                  host,
                                  port,
                                  autoClose
                              );
        //hostnameVerifier.verify(host, sslSocket);
        // verifyHostName() didn't blowup - good!
        return sslSocket;
    }
}
",False,144,0,0,8,55,1,1,L1
122,com.fsck.k9.mail.transport.SmtpTransport.java,"
package com.fsck.k9.mail.transport;

import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.filter.Base64;
import com.fsck.k9.mail.filter.EOLConvertingOutputStream;
import com.fsck.k9.mail.filter.LineWrapOutputStream;
import com.fsck.k9.mail.filter.PeekableInputStream;
import com.fsck.k9.mail.filter.SmtpDataStuffing;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.store.TrustManagerFactory;
import com.fsck.k9.mail.store.LocalStore.LocalMessage;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.TrustManager;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.*;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;

import java.util.*;

public class SmtpTransport extends Transport {
    public static final int CONNECTION_SECURITY_NONE = 0;

    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;

    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;

    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;

    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

    public static final String AUTH_PLAIN = ""PLAIN"";

    public static final String AUTH_CRAM_MD5 = ""CRAM_MD5"";

    public static final String AUTH_LOGIN = ""LOGIN"";

    public static final String AUTH_AUTOMATIC = ""AUTOMATIC"";

    String mHost;

    int mPort;

    String mUsername;

    String mPassword;

    String mAuthType;

    int mConnectionSecurity;

    boolean mSecure;

    Socket mSocket;

    PeekableInputStream mIn;

    OutputStream mOut;
    private boolean m8bitEncodingAllowed;

    private int mLargestAcceptableMessage;

    /**
     * smtp://user:password@server:port CONNECTION_SECURITY_NONE
     * smtp+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * smtp+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * smtp+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * smtp+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     *
     * @param _uri
     */
    public SmtpTransport(String _uri) throws MessagingException {
        URI uri;
        try {
            uri = new URI(_uri);
        } catch (URISyntaxException use) {
            throw new MessagingException(""Invalid SmtpTransport URI"", use);
        }

        String scheme = uri.getScheme();
        if (scheme.equals(""smtp"")) {
            mConnectionSecurity = CONNECTION_SECURITY_NONE;
            mPort = 25;
        } else if (scheme.equals(""smtp+tls"")) {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
            mPort = 25;
        } else if (scheme.equals(""smtp+tls+"")) {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
            mPort = 25;
        } else if (scheme.equals(""smtp+ssl+"")) {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
            mPort = 465;
        } else if (scheme.equals(""smtp+ssl"")) {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
            mPort = 465;
        } else {
            throw new MessagingException(""Unsupported protocol"");
        }

        mHost = uri.getHost();

        if (uri.getPort() != -1) {
            mPort = uri.getPort();
        }

        if (uri.getUserInfo() != null) {
            try {
                String[] userInfoParts = uri.getUserInfo().split("":"");
                mUsername = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                if (userInfoParts.length > 1) {
                    mPassword = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
                if (userInfoParts.length > 2) {
                    mAuthType = userInfoParts[2];
                }
            } catch (UnsupportedEncodingException enc) {
                // This shouldn't happen since the encoding is hardcoded to UTF-8
                Log.e(K9.LOG_TAG, ""Couldn't urldecode username or password."", enc);
            }
        }
    }

    @Override
    public void open() throws MessagingException {
        try {
            InetAddress[] addresses = InetAddress.getAllByName(mHost);
            for (int i = 0; i < addresses.length; i++) {
                try {
                    SocketAddress socketAddress = new InetSocketAddress(addresses[i], mPort);
                    if (mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
                            mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL) {
                        SSLContext sslContext = SSLContext.getInstance(""TLS"");
                        boolean secure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
                        sslContext.init(null, new TrustManager[] {
                                            TrustManagerFactory.get(mHost, secure)
                                        }, new SecureRandom());
                        mSocket = sslContext.getSocketFactory().createSocket();
                        mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                        mSecure = true;
                    } else {
                        mSocket = new Socket();
                        mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                    }
                } catch (ConnectException e) {
                    if (i < (addresses.length - 1)) {
                        // there are still other addresses for that host to try
                        continue;
                    }
                    throw new MessagingException(""Cannot connect to host"", e);
                }
                break; // connection success
            }

            // RFC 1047
            mSocket.setSoTimeout(SOCKET_READ_TIMEOUT);

            mIn = new PeekableInputStream(new BufferedInputStream(mSocket.getInputStream(), 1024));
            mOut = mSocket.getOutputStream();

            // Eat the banner
            executeSimpleCommand(null);

            InetAddress localAddress = mSocket.getLocalAddress();
            String localHost = localAddress.getCanonicalHostName();
            String ipAddr = localAddress.getHostAddress();

            if (localHost.equals("""") || localHost.equals(ipAddr) || localHost.contains(""_"")) {
                // We don't have a FQDN or the hostname contains invalid
                // characters (see issue 2143), so use IP address.
                if (!ipAddr.equals("""")) {
                    if (localAddress instanceof Inet6Address) {
                        localHost = ""[IPV6:"" + ipAddr + ""]"";
                    } else {
                        localHost = ""["" + ipAddr + ""]"";
                    }
                } else {
                    // If the IP address is no good, set a sane default (see issue 2750).
                    localHost = ""android"";
                }
            }

            List<String> results = executeSimpleCommand(""EHLO "" + localHost);

            m8bitEncodingAllowed = results.contains(""8BITMIME"");



            /*
             * TODO may need to add code to fall back to HELO I switched it from
             * using HELO on non STARTTLS connections because of AOL's mail
             * server. It won't let you use AUTH without EHLO.
             * We should really be paying more attention to the capabilities
             * and only attempting auth if it's available, and warning the user
             * if not.
             */
            if (mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL
                    || mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED) {
                if (results.contains(""STARTTLS"")) {
                    executeSimpleCommand(""STARTTLS"");

                    SSLContext sslContext = SSLContext.getInstance(""TLS"");
                    boolean secure = mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED;
                    sslContext.init(null, new TrustManager[] {
                                        TrustManagerFactory.get(mHost, secure)
                                    }, new SecureRandom());
                    mSocket = sslContext.getSocketFactory().createSocket(mSocket, mHost, mPort,
                              true);
                    mIn = new PeekableInputStream(new BufferedInputStream(mSocket.getInputStream(),
                                                  1024));
                    mOut = mSocket.getOutputStream();
                    mSecure = true;
                    /*
                     * Now resend the EHLO. Required by RFC2487 Sec. 5.2, and more specifically,
                     * Exim.
                     */
                    results = executeSimpleCommand(""EHLO "" + localHost);
                } else if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED) {
                    throw new MessagingException(""TLS not supported but required"");
                }
            }

            boolean useAuthLogin = AUTH_LOGIN.equals(mAuthType);
            boolean useAuthPlain = AUTH_PLAIN.equals(mAuthType);
            boolean useAuthCramMD5 = AUTH_CRAM_MD5.equals(mAuthType);

            // Automatically choose best authentication method if none was explicitly selected
            boolean useAutomaticAuth = !(useAuthLogin || useAuthPlain || useAuthCramMD5);

            boolean authLoginSupported = false;
            boolean authPlainSupported = false;
            boolean authCramMD5Supported = false;
            for (String result : results) {
                if (result.matches("".*AUTH.*LOGIN.*$"")) {
                    authLoginSupported = true;
                }
                if (result.matches("".*AUTH.*PLAIN.*$"")) {
                    authPlainSupported = true;
                }
                if (result.matches("".*AUTH.*CRAM-MD5.*$"")) {
                    authCramMD5Supported = true;
                }
                if (result.matches("".*SIZE \\d*$"")) {
                    try {
                        mLargestAcceptableMessage = Integer.parseInt(result.substring(result.lastIndexOf(' ') + 1));
                    } catch (Exception e) {
                        if (K9.DEBUG && K9.DEBUG_PROTOCOL_SMTP) {
                            Log.d(K9.LOG_TAG, ""Tried to parse "" + result + "" and get an int out of the last word: "" + e);
                        }
                    }
                }
            }

            if (mUsername != null && mUsername.length() > 0 &&
                    mPassword != null && mPassword.length() > 0) {
                if (useAuthCramMD5 || (useAutomaticAuth && authCramMD5Supported)) {
                    if (!authCramMD5Supported && K9.DEBUG && K9.DEBUG_PROTOCOL_SMTP) {
                        Log.d(K9.LOG_TAG, ""Using CRAM_MD5 as authentication method although the "" +
                              ""server didn't advertise support for it in EHLO response."");
                    }
                    saslAuthCramMD5(mUsername, mPassword);
                } else if (useAuthPlain || (useAutomaticAuth && authPlainSupported)) {
                    if (!authPlainSupported && K9.DEBUG && K9.DEBUG_PROTOCOL_SMTP) {
                        Log.d(K9.LOG_TAG, ""Using PLAIN as authentication method although the "" +
                              ""server didn't advertise support for it in EHLO response."");
                    }
                    try {
                        saslAuthPlain(mUsername, mPassword);
                    } catch (MessagingException ex) {
                        // PLAIN is a special case.  Historically, PLAIN has represented both PLAIN and LOGIN; only the
                        // protocol being advertised by the server would be used, with PLAIN taking precedence.  Instead
                        // of using only the requested protocol, we'll try PLAIN and then try LOGIN.
                        if (useAuthPlain && authLoginSupported) {
                            if (K9.DEBUG && K9.DEBUG_PROTOCOL_SMTP) {
                                Log.d(K9.LOG_TAG, ""Using legacy PLAIN authentication behavior and trying LOGIN."");
                            }
                            saslAuthLogin(mUsername, mPassword);
                        } else {
                            // If it was auto detected and failed, continue throwing the exception back up.
                            throw ex;
                        }
                    }
                } else if (useAuthLogin || (useAutomaticAuth && authLoginSupported)) {
                    if (!authPlainSupported && K9.DEBUG && K9.DEBUG_PROTOCOL_SMTP) {
                        Log.d(K9.LOG_TAG, ""Using LOGIN as authentication method although the "" +
                              ""server didn't advertise support for it in EHLO response."");
                    }
                    saslAuthLogin(mUsername, mPassword);
                } else {
                    throw new MessagingException(""No valid authentication mechanism found."");
                }
            }
        } catch (SSLException e) {
            throw new CertificateValidationException(e.getMessage(), e);
        } catch (GeneralSecurityException gse) {
            throw new MessagingException(
                ""Unable to open connection to SMTP server due to security error."", gse);
        } catch (IOException ioe) {
            throw new MessagingException(""Unable to open connection to SMTP server."", ioe);
        }
    }

    @Override
    public void sendMessage(Message message) throws MessagingException {
        ArrayList<Address> addresses = new ArrayList<Address>();
        {
            addresses.addAll(Arrays.asList(message.getRecipients(RecipientType.TO)));
            addresses.addAll(Arrays.asList(message.getRecipients(RecipientType.CC)));
            addresses.addAll(Arrays.asList(message.getRecipients(RecipientType.BCC)));
        }
        message.setRecipients(RecipientType.BCC, null);

        HashMap<String, ArrayList<String>> charsetAddressesMap =
            new HashMap<String, ArrayList<String>>();
        for (Address address : addresses) {
            String addressString = address.getAddress();
            String charset = MimeUtility.getCharsetFromAddress(addressString);
            ArrayList<String> addressesOfCharset = charsetAddressesMap.get(charset);
            if (addressesOfCharset == null) {
                addressesOfCharset = new ArrayList<String>();
                charsetAddressesMap.put(charset, addressesOfCharset);
            }
            addressesOfCharset.add(addressString);
        }

        for (Map.Entry<String, ArrayList<String>> charsetAddressesMapEntry :
                charsetAddressesMap.entrySet()) {
            String charset = charsetAddressesMapEntry.getKey();
            ArrayList<String> addressesOfCharset = charsetAddressesMapEntry.getValue();
            message.setCharset(charset);
            sendMessageTo(addressesOfCharset, message);
        }
    }

    private void sendMessageTo(ArrayList<String> addresses, Message message)
    throws MessagingException {
        boolean possibleSend = false;

        close();
        open();

        message.setEncoding(m8bitEncodingAllowed ? ""8bit"" : null);
        // If the message has attachments and our server has told us about a limit on
        // the size of messages, count the message's size before sending it
        if (mLargestAcceptableMessage > 0 && ((LocalMessage)message).hasAttachments()) {
            if (message.calculateSize() > mLargestAcceptableMessage) {
                MessagingException me = new MessagingException(""Message too large for server"");
                me.setPermanentFailure(possibleSend);
                throw me;
            }
        }

        Address[] from = message.getFrom();
        try {
            //TODO: Add BODY=8BITMIME parameter if appropriate?
            executeSimpleCommand(""MAIL FROM:"" + ""<"" + from[0].getAddress() + "">"");
            for (String address : addresses) {
                executeSimpleCommand(""RCPT TO:"" + ""<"" + address + "">"");
            }
            executeSimpleCommand(""DATA"");

            EOLConvertingOutputStream msgOut = new EOLConvertingOutputStream(
                new SmtpDataStuffing(
                    new LineWrapOutputStream(
                        new BufferedOutputStream(mOut, 1024),
                        1000)));

            message.writeTo(msgOut);

            // We use BufferedOutputStream. So make sure to call flush() !
            msgOut.flush();

            possibleSend = true; // After the ""\r\n."" is attempted, we may have sent the message
            executeSimpleCommand(""\r\n."");
        } catch (Exception e) {
            MessagingException me = new MessagingException(""Unable to send message"", e);

            // ""5xx text"" -responses are permanent failures
            String msg = e.getMessage();
            if (msg != null && msg.startsWith(""5"")) {
                Log.w(K9.LOG_TAG, ""handling 5xx SMTP error code as a permanent failure"");
                possibleSend = false;
            }

            me.setPermanentFailure(possibleSend);
            throw me;
        } finally {
            close();
        }



    }

    @Override
    public void close() {
        try {
            executeSimpleCommand(""QUIT"");
        } catch (Exception e) {

        }
        try {
            mIn.close();
        } catch (Exception e) {

        }
        try {
            mOut.close();
        } catch (Exception e) {

        }
        try {
            mSocket.close();
        } catch (Exception e) {

        }
        mIn = null;
        mOut = null;
        mSocket = null;
    }

    private String readLine() throws IOException {
        StringBuffer sb = new StringBuffer();
        int d;
        while ((d = mIn.read()) != -1) {
            if (((char)d) == '\r') {
                continue;
            } else if (((char)d) == '\n') {
                break;
            } else {
                sb.append((char)d);
            }
        }
        String ret = sb.toString();
        if (K9.DEBUG && K9.DEBUG_PROTOCOL_SMTP)
            Log.d(K9.LOG_TAG, ""SMTP <<< "" + ret);

        return ret;
    }

    private void writeLine(String s, boolean sensitive) throws IOException {
        if (K9.DEBUG && K9.DEBUG_PROTOCOL_SMTP) {
            final String commandToLog;
            if (sensitive && !K9.DEBUG_SENSITIVE) {
                commandToLog = ""SMTP >>> *sensitive*"";
            } else {
                commandToLog = ""SMTP >>> "" + s;
            }
            Log.d(K9.LOG_TAG, commandToLog);
        }

        byte[] data = s.concat(""\r\n"").getBytes();

        /*
         * Important: Send command + CRLF using just one write() call. Using
         * multiple calls will likely result in multiple TCP packets and some
         * SMTP servers misbehave if CR and LF arrive in separate pakets.
         * See issue 799.
         */
        mOut.write(data);
        mOut.flush();
    }

    private void checkLine(String line) throws MessagingException {
        if (line.length() < 1) {
            throw new MessagingException(""SMTP response is 0 length"");
        }
        char c = line.charAt(0);
        if ((c == '4') || (c == '5')) {
            throw new MessagingException(line);
        }
    }

    private List<String> executeSimpleCommand(String command) throws IOException, MessagingException {
        return executeSimpleCommand(command, false);
    }

    private List<String> executeSimpleCommand(String command, boolean sensitive)
    throws IOException, MessagingException {
        List<String> results = new ArrayList<String>();
        if (command != null) {
            writeLine(command, sensitive);
        }

        /*
         * Read lines as long as the length is 4 or larger, e.g. ""220-banner text here"".
         * Shorter lines are either errors of contain only a reply code. Those cases will
         * be handled by checkLine() below.
         */
        String line = readLine();
        while (line.length() >= 4) {
            if (line.length() > 4) {
                // Everything after the first four characters goes into the results array.
                results.add(line.substring(4));
            }

            if (line.charAt(3) != '-') {
                // If the fourth character isn't ""-"" this is the last line of the response.
                break;
            }
            line = readLine();
        }

        // Check if the reply code indicates an error.
        checkLine(line);

        return results;
    }


//    C: AUTH LOGIN
//    S: 334 VXNlcm5hbWU6
//    C: d2VsZG9u
//    S: 334 UGFzc3dvcmQ6
//    C: dzNsZDBu
//    S: 235 2.0.0 OK Authenticated
//
//    Lines 2-5 of the conversation contain base64-encoded information. The same conversation, with base64 strings decoded, reads:
//
//
//    C: AUTH LOGIN
//    S: 334 Username:
//    C: weldon
//    S: 334 Password:
//    C: w3ld0n
//    S: 235 2.0.0 OK Authenticated

    private void saslAuthLogin(String username, String password) throws MessagingException,
        AuthenticationFailedException, IOException {
        try {
            executeSimpleCommand(""AUTH LOGIN"");
            executeSimpleCommand(new String(Base64.encodeBase64(username.getBytes())), true);
            executeSimpleCommand(new String(Base64.encodeBase64(password.getBytes())), true);
        } catch (MessagingException me) {
            if (me.getMessage().length() > 1 && me.getMessage().charAt(1) == '3') {
                throw new AuthenticationFailedException(""AUTH LOGIN failed ("" + me.getMessage()
                                                        + "")"");
            }
            throw me;
        }
    }

    private void saslAuthPlain(String username, String password) throws MessagingException,
        AuthenticationFailedException, IOException {
        byte[] data = (""\000"" + username + ""\000"" + password).getBytes();
        data = new Base64().encode(data);
        try {
            executeSimpleCommand(""AUTH PLAIN "" + new String(data), true);
        } catch (MessagingException me) {
            if (me.getMessage().length() > 1 && me.getMessage().charAt(1) == '3') {
                throw new AuthenticationFailedException(""AUTH PLAIN failed ("" + me.getMessage()
                                                        + "")"");
            }
            throw me;
        }
    }

    private void saslAuthCramMD5(String username, String password) throws MessagingException,
        AuthenticationFailedException, IOException {

        List<String> respList = executeSimpleCommand(""AUTH CRAM-MD5"");
        if (respList.size() != 1) {
            throw new AuthenticationFailedException(""Unable to negotiate CRAM-MD5"");
        }

        String b64Nonce = respList.get(0);
        String b64CRAMString = Authentication.computeCramMd5(mUsername, mPassword, b64Nonce);

        try {
            executeSimpleCommand(b64CRAMString, true);
        } catch (MessagingException me) {
            throw new AuthenticationFailedException(""Unable to negotiate MD5 CRAM"");
        }
    }
}
",True,144,0,0,7,42,2,16,L1
123,com.fsck.k9.mail.transport.imap.ImapSettings.java,"package com.fsck.k9.mail.transport.imap;

import com.fsck.k9.mail.store.ImapStore;
import com.fsck.k9.mail.store.ImapStore.AuthType;
import com.fsck.k9.mail.store.ImapStore.ImapConnection;

/**
 * Settings source for IMAP. Implemented in order to remove coupling between {@link ImapStore} and {@link ImapConnection}.
 */
public interface ImapSettings {
    String getHost();

    int getPort();

    int getConnectionSecurity();

    AuthType getAuthType();

    String getUsername();

    String getPassword();

    boolean useCompression(int type);

    String getPathPrefix();

    void setPathPrefix(String prefix);

    String getPathDelimeter();

    void setPathDelimeter(String delimeter);

    String getCombinedPrefix();

    void setCombinedPrefix(String prefix);

}
",False,144,0,0,7,33,1,1,L1
124,com.fsck.k9.mail.filter.EOLConvertingOutputStream.java,"package com.fsck.k9.mail.filter;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class EOLConvertingOutputStream extends FilterOutputStream {
    private int lastChar;
    private boolean ignoreNextIfLF = false;

    public EOLConvertingOutputStream(OutputStream out) {
        super(out);
    }

    @Override
    public void write(int oneByte) throws IOException {
        if (!ignoreNextIfLF) {
            if ((oneByte == '\n') && (lastChar != '\r')) {
                super.write('\r');
            }
            super.write(oneByte);
            lastChar = oneByte;
        }
        ignoreNextIfLF = false;
    }

    @Override
    public void flush() throws IOException {
        if (lastChar == '\r') {
            super.write('\n');
            lastChar = '\n';

            // We have to ignore the next character if it is <LF>. Otherwise it
            // will be expanded to an additional <CR><LF> sequence although it
            // belongs to the one just completed.
            ignoreNextIfLF = true;
        }
        super.flush();
    }
}
",False,113,4,59,0,0,4,0,L1
125,com.fsck.k9.mail.filter.StatusOutputStream.java,"package com.fsck.k9.mail.filter;

import android.util.Config;
import android.util.Log;
import com.fsck.k9.K9;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class StatusOutputStream extends FilterOutputStream {
    private long mCount = 0;

    public StatusOutputStream(OutputStream out) {
        super(out);
    }

    @Override
    public void write(int oneByte) throws IOException {
        super.write(oneByte);
        mCount++;
        if (Config.LOGV) {
            if (mCount % 1024 == 0) {
                Log.v(K9.LOG_TAG, ""# "" + mCount);
            }
        }
    }
}
",False,145,0,0,7,55,0,1,L2
126,com.fsck.k9.mail.filter.CountingOutputStream.java,"package com.fsck.k9.mail.filter;

import java.io.IOException;
import java.io.OutputStream;

/**
 * A simple OutputStream that does nothing but count how many bytes are written to it and
 * makes that count available to callers.
 */
public class CountingOutputStream extends OutputStream {
    private long mCount;

    public CountingOutputStream() {
    }

    public long getCount() {
        return mCount;
    }

    @Override
    public void write(int oneByte) throws IOException {
        mCount++;
    }

    @Override
    public void write(byte b[], int offset, int len) throws IOException {
        mCount += len;
    }

    @Override
    public void write(byte[] b) throws IOException {
        mCount += b.length;
    }
}
",False,113,4,62,0,0,1,0,L1
127,com.fsck.k9.mail.filter.Base64OutputStream.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.mail.filter;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

/**
 * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).
 * When encoding the default lineLength is 76 characters and the default
 * lineEnding is CRLF, but these can be overridden by using the appropriate
 * constructor.
 * <p>
 * The default behaviour of the Base64OutputStream is to ENCODE, whereas the
 * default behaviour of the Base64InputStream is to DECODE.  But this behaviour
 * can be overridden by using a different constructor.
 * </p><p>
 * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
 * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
 * </p>
 *
 * @author Apache Software Foundation
 * @version $Id $
 * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045</a>
 * @since 1.0-dev
 */
public class Base64OutputStream extends FilterOutputStream {
    private final boolean doEncode;
    private final Base64 base64;
    private final byte[] singleByte = new byte[1];

    /**
     * Creates a Base64OutputStream such that all data written is Base64-encoded
     * to the original provided OutputStream.
     *
     * @param out OutputStream to wrap.
     */
    public Base64OutputStream(OutputStream out) {
        this(out, true);
    }

    /**
     * Creates a Base64OutputStream such that all data written is either
     * Base64-encoded or Base64-decoded to the original provided OutputStream.
     *
     * @param out      OutputStream to wrap.
     * @param doEncode true if we should encode all data written to us,
     *                 false if we should decode.
     */
    public Base64OutputStream(OutputStream out, boolean doEncode) {
        super(out);
        this.doEncode = doEncode;
        this.base64 = new Base64();
    }

    /**
     * Creates a Base64OutputStream such that all data written is either
     * Base64-encoded or Base64-decoded to the original provided OutputStream.
     *
     * @param out           OutputStream to wrap.
     * @param doEncode      true if we should encode all data written to us,
     *                      false if we should decode.
     * @param lineLength    If doEncode is true, each line of encoded
     *                      data will contain lineLength characters.
     *                      If lineLength <=0, the encoded data is not divided into lines.
     *                      If doEncode is false, lineLength is ignored.
     * @param lineSeparator If doEncode is true, each line of encoded
     *                      data will be terminated with this byte sequence (e.g. \r\n).
     *                      If lineLength <= 0, the lineSeparator is not used.
     *                      If doEncode is false lineSeparator is ignored.
     */
    public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {
        super(out);
        this.doEncode = doEncode;
        this.base64 = new Base64(lineLength, lineSeparator);
    }

    /**
     * Writes the specified <code>byte</code> to this output stream.
     */
    @Override
    public void write(int i) throws IOException {
        singleByte[0] = (byte) i;
        write(singleByte, 0, 1);
    }

    /**
     * Writes <code>len</code> bytes from the specified
     * <code>b</code> array starting at <code>offset</code> to
     * this output stream.
     *
     * @param b source byte array
     * @param offset where to start reading the bytes
     * @param len maximum number of bytes to write
     *
     * @throws IOException if an I/O error occurs.
     * @throws NullPointerException if the byte array parameter is null
     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid
     */
    @Override
    public void write(byte b[], int offset, int len) throws IOException {
        if (b == null) {
            throw new NullPointerException();
        } else if (offset < 0 || len < 0 || offset + len < 0) {
            throw new IndexOutOfBoundsException();
        } else if (offset > b.length || offset + len > b.length) {
            throw new IndexOutOfBoundsException();
        } else if (len > 0) {
            if (doEncode) {
                base64.encode(b, offset, len);
            } else {
                base64.decode(b, offset, len);
            }
            flush(false);
        }
    }

    /**
     * Flushes this output stream and forces any buffered output bytes
     * to be written out to the stream.  If propogate is true, the wrapped
     * stream will also be flushed.
     *
     * @param propogate boolean flag to indicate whether the wrapped
     *                  OutputStream should also be flushed.
     * @throws IOException if an I/O error occurs.
     */
    private void flush(boolean propogate) throws IOException {
        int avail = base64.avail();
        if (avail > 0) {
            byte[] buf = new byte[avail];
            int c = base64.readResults(buf, 0, avail);
            if (c > 0) {
                out.write(buf, 0, c);
            }
        }
        if (propogate) {
            out.flush();
        }
    }

    /**
     * Flushes this output stream and forces any buffered output bytes
     * to be written out to the stream.
     *
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void flush() throws IOException {
        flush(true);
    }

    /**
     * Closes this output stream, flushing any remaining bytes that must be encoded. The
     * underlying stream is flushed but not closed.
     */
    @Override
    public void close() throws IOException {
        // Notify encoder of EOF (-1).
        if (doEncode) {
            base64.encode(singleByte, 0, -1);
        } else {
            base64.decode(singleByte, 0, -1);
        }
        flush();
    }

}
",False,115,4,76,1,1,2,1,L1
128,com.fsck.k9.mail.filter.PeekableInputStream.java,"
package com.fsck.k9.mail.filter;

import java.io.IOException;
import java.io.InputStream;

/**
 * A filtering InputStream that allows single byte ""peeks"" without consuming the byte. The
 * client of this stream can call peek() to see the next available byte in the stream
 * and a subsequent read will still return the peeked byte.
 */
public class PeekableInputStream extends InputStream {
    private InputStream mIn;
    private boolean mPeeked;
    private int mPeekedByte;

    public PeekableInputStream(InputStream in) {
        this.mIn = in;
    }

    @Override
    public int read() throws IOException {
        if (!mPeeked) {
            return mIn.read();
        } else {
            mPeeked = false;
            return mPeekedByte;
        }
    }

    public int peek() throws IOException {
        if (!mPeeked) {
            mPeekedByte = mIn.read();
            mPeeked = true;
        }
        return mPeekedByte;
    }

    @Override
    public int read(byte[] b, int offset, int length) throws IOException {
        if (!mPeeked) {
            return mIn.read(b, offset, length);
        } else {
            b[0] = (byte)mPeekedByte;
            mPeeked = false;
            int r = mIn.read(b, offset + 1, length - 1);
            if (r == -1) {
                return 1;
            } else {
                return r + 1;
            }
        }
    }

    @Override
    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }

    @Override
    public String toString() {
        return String.format(""PeekableInputStream(in=%s, peeked=%b, peekedByte=%d)"",
                             mIn.toString(), mPeeked, mPeekedByte);
    }
}
",True,114,7,48,0,0,3,0,L1
129,com.fsck.k9.mail.filter.Hex.java,"/*
 * Copyright 2001-2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.mail.filter;

/**
 * This code was copied from the Apache Commons project.
 * The unnecessary parts have been left out.
 */
public class Hex {
    /**
     * Used building output as Hex
     */
    private static final char[] DIGITS = {
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
    };

    /**
     * Converts an array of bytes into an array of characters representing the hexidecimal values of each byte in order.
     * The returned array will be double the length of the passed array, as it takes two characters to represent any
     * given byte.
     *
     * @param data
     *                  a byte[] to convert to Hex characters
     * @return A char[] containing hexidecimal characters
     */
    public static char[] encodeHex(byte[] data) {

        int l = data.length;

        char[] out = new char[l << 1];

        // two characters form the hex value.
        for (int i = 0, j = 0; i < l; i++) {
            out[j++] = DIGITS[(0xF0 & data[i]) >>> 4 ];
            out[j++] = DIGITS[ 0x0F & data[i] ];
        }

        return out;
    }

}
",False,114,8,44,0,0,2,0,L1
130,com.fsck.k9.mail.filter.LineWrapOutputStream.java,"package com.fsck.k9.mail.filter;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class LineWrapOutputStream extends FilterOutputStream {
    private static final byte[] CRLF = new byte[] {'\r', '\n'};

    private byte[] buffer;
    private int bufferStart = 0;
    private int lineLength = 0;
    private int endOfLastWord = 0;


    public LineWrapOutputStream(OutputStream out, int maxLineLength) {
        super(out);
        buffer = new byte[maxLineLength - 2];
    }

    @Override
    public void write(int oneByte) throws IOException {
        // Buffer full?
        if (lineLength == buffer.length) {
            // Usable word-boundary found earlier?
            if (endOfLastWord > 0) {
                // Yes, so output everything up to that word-boundary
                out.write(buffer, bufferStart, endOfLastWord - bufferStart);
                out.write(CRLF);

                bufferStart = 0;

                // Skip the <SPACE> in the buffer
                endOfLastWord++;
                lineLength = buffer.length - endOfLastWord;
                if (lineLength > 0) {
                    // Copy rest of the buffer to the front
                    System.arraycopy(buffer, endOfLastWord + 0, buffer, 0, lineLength);
                }
                endOfLastWord = 0;
            } else {
                // No word-boundary found, so output whole buffer
                out.write(buffer, bufferStart, buffer.length - bufferStart);
                out.write(CRLF);
                lineLength = 0;
                bufferStart = 0;
            }
        }

        if ((oneByte == '\n') || (oneByte == '\r')) {
            // <CR> or <LF> character found, so output buffer ...
            if (lineLength - bufferStart > 0) {
                out.write(buffer, bufferStart, lineLength - bufferStart);
            }
            // ... and that character
            out.write(oneByte);
            lineLength = 0;
            bufferStart = 0;
            endOfLastWord = 0;
        } else {
            // Remember this position as last word-boundary if <SPACE> found
            if (oneByte == ' ') {
                endOfLastWord = lineLength;
            }

            // Write character to the buffer
            buffer[lineLength] = (byte)oneByte;
            lineLength++;
        }
    }

    @Override
    public void flush() throws IOException {
        // Buffer empty?
        if (lineLength > bufferStart) {
            // Output everything we have up till now
            out.write(buffer, bufferStart, lineLength - bufferStart);

            // Mark current position as new start of the buffer
            bufferStart = (lineLength == buffer.length) ? 0 : lineLength;
            endOfLastWord = 0;
        }
        out.flush();
    }
}
",False,113,7,58,0,0,1,0,L1
131,com.fsck.k9.mail.filter.FixedLengthInputStream.java,"
package com.fsck.k9.mail.filter;

import java.io.IOException;
import java.io.InputStream;

/**
 * A filtering InputStream that stops allowing reads after the given length has been read. This
 * is used to allow a client to read directly from an underlying protocol stream without reading
 * past where the protocol handler intended the client to read.
 */
public class FixedLengthInputStream extends InputStream {
    private InputStream mIn;
    private int mLength;
    private int mCount;

    public FixedLengthInputStream(InputStream in, int length) {
        this.mIn = in;
        this.mLength = length;
    }

    @Override
    public int available() throws IOException {
        return mLength - mCount;
    }

    @Override
    public int read() throws IOException {
        if (mCount < mLength) {
            mCount++;
            return mIn.read();
        } else {
            return -1;
        }
    }

    @Override
    public int read(byte[] b, int offset, int length) throws IOException {
        if (mCount < mLength) {
            int d = mIn.read(b, offset, Math.min(mLength - mCount, length));
            if (d == -1) {
                return -1;
            } else {
                mCount += d;
                return d;
            }
        } else {
            return -1;
        }
    }

    @Override
    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }

    @Override
    public String toString() {
        return String.format(""FixedLengthInputStream(in=%s, length=%d)"", mIn.toString(), mLength);
    }
}
",True,114,7,48,0,0,2,0,L1
132,com.fsck.k9.mail.filter.Base64.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.mail.filter;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;

/**
 * Provides Base64 encoding and decoding as defined by RFC 2045.
 *
 * <p>
 * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
 * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
 * </p>
 *
 * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045</a>
 * @author Apache Software Foundation
 * @since 1.0-dev
 * @version $Id$
 */
public class Base64 {
    /**
     * Chunk size per RFC 2045 section 6.8.
     *
     * <p>
     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any
     * equal signs.
     * </p>
     *
     * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045 section 6.8</a>
     */
    static final int CHUNK_SIZE = 76;

    /**
     * Chunk separator per RFC 2045 section 2.1.
     *
     * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045 section 2.1</a>
     */
    static final byte[] CHUNK_SEPARATOR = {'\r', '\n'};

    /**
     * This array is a lookup table that translates 6-bit positive integer
     * index values into their ""Base64 Alphabet"" equivalents as specified
     * in Table 1 of RFC 2045.
     *
     * Thanks to ""commons"" project in ws.apache.org for this code.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     */
    private static final byte[] intToBase64 = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
    };

    /**
     * Byte used to pad output.
     */
    private static final byte PAD = '=';

    /**
     * This array is a lookup table that translates unicode characters
     * drawn from the ""Base64 Alphabet"" (as specified in Table 1 of RFC 2045)
     * into their 6-bit positive integer equivalents.  Characters that
     * are not in the Base64 alphabet but fall within the bounds of the
     * array are translated to -1.
     *
     * Thanks to ""commons"" project in ws.apache.org for this code.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     */
    private static final byte[] base64ToInt = {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,
        55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,
        5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
        24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,
        35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
    };

    /** Mask used to extract 6 bits, used when encoding */
    private static final int MASK_6BITS = 0x3f;

    /** Mask used to extract 8 bits, used in decoding base64 bytes */
    private static final int MASK_8BITS = 0xff;

    // The static final fields above are used for the original static byte[] methods on Base64.
    // The private member fields below are used with the new streaming approach, which requires
    // some state be preserved between calls of encode() and decode().


    /**
     * Line length for encoding.  Not used when decoding.  A value of zero or less implies
     * no chunking of the base64 encoded data.
     */
    private final int lineLength;

    /**
     * Line separator for encoding.  Not used when decoding.  Only used if lineLength > 0.
     */
    private final byte[] lineSeparator;

    /**
     * Convenience variable to help us determine when our buffer is going to run out of
     * room and needs resizing.  <code>decodeSize = 3 + lineSeparator.length;</code>
     */
    private final int decodeSize;

    /**
     * Convenience variable to help us determine when our buffer is going to run out of
     * room and needs resizing.  <code>encodeSize = 4 + lineSeparator.length;</code>
     */
    private final int encodeSize;

    /**
     * Buffer for streaming.
     */
    private byte[] buf;

    /**
     * Position where next character should be written in the buffer.
     */
    private int pos;

    /**
     * Position where next character should be read from the buffer.
     */
    private int readPos;

    /**
     * Variable tracks how many characters have been written to the current line.
     * Only used when encoding.  We use it to make sure each encoded line never
     * goes beyond lineLength (if lineLength > 0).
     */
    private int currentLinePos;

    /**
     * Writes to the buffer only occur after every 3 reads when encoding, an
     * every 4 reads when decoding.  This variable helps track that.
     */
    private int modulus;

    /**
     * Boolean flag to indicate the EOF has been reached.  Once EOF has been
     * reached, this Base64 object becomes useless, and must be thrown away.
     */
    private boolean eof;

    /**
     * Place holder for the 3 bytes we're dealing with for our base64 logic.
     * Bitwise operations store and extract the base64 encoding or decoding from
     * this variable.
     */
    private int x;

    /**
     * Default constructor:  lineLength is 76, and the lineSeparator is CRLF
     * when encoding, and all forms can be decoded.
     */
    public Base64() {
        this(CHUNK_SIZE, CHUNK_SEPARATOR);
    }

    /**
     * <p>
     * Consumer can use this constructor to choose a different lineLength
     * when encoding (lineSeparator is still CRLF).  All forms of data can
     * be decoded.
     * </p><p>
     * Note:  lineLengths that aren't multiples of 4 will still essentially
     * end up being multiples of 4 in the encoded data.
     * </p>
     *
     * @param lineLength each line of encoded data will be at most this long
     * (rounded up to nearest multiple of 4).
     * If lineLength <= 0, then the output will not be divided into lines (chunks).
     * Ignored when decoding.
     */
    public Base64(int lineLength) {
        this(lineLength, CHUNK_SEPARATOR);
    }

    /**
     * <p>
     * Consumer can use this constructor to choose a different lineLength
     * and lineSeparator when encoding.  All forms of data can
     * be decoded.
     * </p><p>
     * Note:  lineLengths that aren't multiples of 4 will still essentially
     * end up being multiples of 4 in the encoded data.
     * </p>
     * @param lineLength    Each line of encoded data will be at most this long
     *                      (rounded up to nearest multiple of 4).  Ignored when decoding.
     *                      If <= 0, then output will not be divided into lines (chunks).
     * @param lineSeparator Each line of encoded data will end with this
     *                      sequence of bytes.
     *                      If lineLength <= 0, then the lineSeparator is not used.
     * @throws IllegalArgumentException The provided lineSeparator included
     *                                  some base64 characters.  That's not going to work!
     */
    public Base64(int lineLength, byte[] lineSeparator) {
        this.lineLength = lineLength;
        this.lineSeparator = new byte[lineSeparator.length];
        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
        if (lineLength > 0) {
            this.encodeSize = 4 + lineSeparator.length;
        } else {
            this.encodeSize = 4;
        }
        this.decodeSize = encodeSize - 1;
        if (containsBase64Byte(lineSeparator)) {
            String sep;
            try {
                sep = new String(lineSeparator, ""UTF-8"");
            } catch (UnsupportedEncodingException uee) {
                sep = new String(lineSeparator);
            }
            throw new IllegalArgumentException(""lineSeperator must not contain base64 characters: ["" + sep + ""]"");
        }
    }

    /**
     * Returns true if this Base64 object has buffered data for reading.
     *
     * @return true if there is Base64 object still available for reading.
     */
    boolean hasData() {
        return buf != null;
    }

    /**
     * Returns the amount of buffered data available for reading.
     *
     * @return The amount of buffered data available for reading.
     */
    int avail() {
        return buf != null ? pos - readPos : 0;
    }

    /** Doubles our buffer. */
    private void resizeBuf() {
        if (buf == null) {
            buf = new byte[8192];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buf.length * 2];
            System.arraycopy(buf, 0, b, 0, buf.length);
            buf = b;
        }
    }

    /**
     * Extracts buffered data into the provided byte[] array, starting
     * at position bPos, up to a maximum of bAvail bytes.  Returns how
     * many bytes were actually extracted.
     *
     * @param b      byte[] array to extract the buffered data into.
     * @param bPos   position in byte[] array to start extraction at.
     * @param bAvail amount of bytes we're allowed to extract.  We may extract
     *               fewer (if fewer are available).
     * @return The number of bytes successfully extracted into the provided
     *         byte[] array.
     */
    int readResults(byte[] b, int bPos, int bAvail) {
        if (buf != null) {
            int len = Math.min(avail(), bAvail);
            if (buf != b) {
                System.arraycopy(buf, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buf = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buf = null;
            }
            return len;
        } else {
            return eof ? -1 : 0;
        }
    }

    /**
     * Small optimization where we try to buffer directly to the consumer's
     * output array for one round (if consumer calls this method first!) instead
     * of starting our own buffer.
     *
     * @param out byte[] array to buffer directly to.
     * @param outPos Position to start buffering into.
     * @param outAvail Amount of bytes available for direct buffering.
     */
    void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buf = out;
            pos = outPos;
            readPos = outPos;
        }
    }

    /**
     * <p>
     * Encodes all of the provided data, starting at inPos, for inAvail bytes.
     * Must be called at least twice:  once with the data to encode, and once
     * with inAvail set to ""-1"" to alert encoder that EOF has been reached,
     * so flush last remaining bytes (if not multiple of 3).
     * </p><p>
     * Thanks to ""commons"" project in ws.apache.org for the bitwise operations,
     * and general approach.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * </p>
     *
     * @param in byte[] array of binary data to base64 encode.
     * @param inPos Position to start reading data from.
     * @param inAvail Amount of bytes available from input for encoding.
     */
    void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }

        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buf == null || buf.length - pos < encodeSize) {
                resizeBuf();
            }
            switch (modulus) {
            case 1:
                buf[pos++] = intToBase64[(x >> 2) & MASK_6BITS];
                buf[pos++] = intToBase64[(x << 4) & MASK_6BITS];
                buf[pos++] = PAD;
                buf[pos++] = PAD;
                break;

            case 2:
                buf[pos++] = intToBase64[(x >> 10) & MASK_6BITS];
                buf[pos++] = intToBase64[(x >> 4) & MASK_6BITS];
                buf[pos++] = intToBase64[(x << 2) & MASK_6BITS];
                buf[pos++] = PAD;
                break;
            }
            if (lineLength > 0) {
                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buf == null || buf.length - pos < encodeSize) {
                    resizeBuf();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buf[pos++] = intToBase64[(x >> 18) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x >> 12) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x >> 6) & MASK_6BITS];
                    buf[pos++] = intToBase64[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }

    /**
     * <p>
     * Decodes all of the provided data, starting at inPos, for inAvail bytes.
     * Should be called at least twice:  once with the data to decode, and once
     * with inAvail set to ""-1"" to alert decoder that EOF has been reached.
     * The ""-1"" call is not necessary when decoding, but it doesn't hurt, either.
     * </p><p>
     * Ignores all non-base64 characters.  This is how chunked (e.g. 76 character)
     * data is handled, since CR and LF are silently ignored, but has implications
     * for other bytes, too.  This method subscribes to the garbage-in, garbage-out
     * philosophy:  it will not check the provided data for validity.
     * </p><p>
     * Thanks to ""commons"" project in ws.apache.org for the bitwise operations,
     * and general approach.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * </p>

     * @param in byte[] array of ascii data to base64 decode.
     * @param inPos Position to start reading data from.
     * @param inAvail Amount of bytes available from input for encoding.
     */
    void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buf == null || buf.length - pos < decodeSize) {
                resizeBuf();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                x = x << 6;
                switch (modulus) {
                case 2:
                    x = x << 6;
                    buf[pos++] = (byte)((x >> 16) & MASK_8BITS);
                    break;
                case 3:
                    buf[pos++] = (byte)((x >> 16) & MASK_8BITS);
                    buf[pos++] = (byte)((x >> 8) & MASK_8BITS);
                    break;
                }
                // WE'RE DONE!!!!
                eof = true;
                return;
            } else {
                if (b >= 0 && b < base64ToInt.length) {
                    int result = base64ToInt[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buf[pos++] = (byte)((x >> 16) & MASK_8BITS);
                            buf[pos++] = (byte)((x >> 8) & MASK_8BITS);
                            buf[pos++] = (byte)(x & MASK_8BITS);
                        }
                    }
                }
            }
        }
    }

    /**
     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
     *
     * @param octet
     *            The value to test
     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
     */
    public static boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < base64ToInt.length && base64ToInt[octet] != -1);
    }

    /**
     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.
     * Currently the method treats whitespace as valid.
     *
     * @param arrayOctet
     *            byte array to test
     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is
     *         empty; false, otherwise
     */
    public static boolean isArrayByteBase64(byte[] arrayOctet) {
        for (byte anArrayOctet : arrayOctet) {
            if (!isBase64(anArrayOctet) && !isWhiteSpace(anArrayOctet)) {
                return false;
            }
        }
        return true;
    }

    /*
     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.
     *
     * @param arrayOctet
     *            byte array to test
     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise
     */
    private static boolean containsBase64Byte(byte[] arrayOctet) {
        for (byte element : arrayOctet) {
            if (isBase64(element)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Encodes binary data using the base64 algorithm but does not chunk the output.
     *
     * @param binaryData
     *            binary data to encode
     * @return Base64 characters
     */
    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }

    /**
     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
     *
     * @param binaryData
     *            binary data to encode
     * @return Base64 characters chunked in 76 character blocks
     */
    public static byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData, true);
    }

    /**
     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[].
     *
     * @param pObject
     *            Object to decode
     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] supplied.
     * @throws DecoderException
     *             if the parameter supplied is not of type byte[]
     */
    public Object decode(Object pObject) throws DecoderException {
        if (!(pObject instanceof byte[])) {
            throw new DecoderException(""Parameter supplied to Base64 decode is not a byte[]"");
        }
        return decode((byte[]) pObject);
    }

    /**
     * Decodes a byte[] containing containing characters in the Base64 alphabet.
     *
     * @param pArray
     *            A byte array containing Base64 character data
     * @return a byte array containing binary data
     */
    public byte[] decode(byte[] pArray) {
        return decodeBase64(pArray);
    }

    /**
     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
     *
     * @param binaryData
     *            Array containing binary data to encode.
     * @param isChunked
     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
     * @return Base64-encoded data.
     * @throws IllegalArgumentException
     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
     */
    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }
        Base64 b64 = isChunked ? new Base64() : new Base64(0);

        long len = (binaryData.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (isChunked) {
            len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;
        }

        if (len > Integer.MAX_VALUE) {
            throw new IllegalArgumentException(
                ""Input array too big, output array would be bigger than Integer.MAX_VALUE="" + Integer.MAX_VALUE);
        }
        byte[] buf = new byte[(int) len];
        b64.setInitialBuffer(buf, 0, buf.length);
        b64.encode(binaryData, 0, binaryData.length);
        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.

        // Encoder might have resized, even though it was unnecessary.
        if (b64.buf != buf) {
            b64.readResults(buf, 0, buf.length);
        }
        return buf;
    }

    /**
     * Decodes Base64 data into octets
     *
     * @param base64Data Byte array containing Base64 data
     * @return Array containing decoded data.
     */
    public static byte[] decodeBase64(byte[] base64Data) {
        if (base64Data == null || base64Data.length == 0) {
            return base64Data;
        }
        Base64 b64 = new Base64();

        long len = (base64Data.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        b64.setInitialBuffer(buf, 0, buf.length);
        b64.decode(base64Data, 0, base64Data.length);
        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.

        // We have no idea what the line-length was, so we
        // cannot know how much of our array wasn't used.
        byte[] result = new byte[b64.pos];
        b64.readResults(result, 0, result.length);
        return result;
    }

    /**
     * Check if a byte value is whitespace or not.
     *
     * @param byteToCheck the byte to check
     * @return true if byte is whitespace, false otherwise
     */
    private static boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
        case ' ' :
        case '\n' :
        case '\r' :
        case '\t' :
            return true;
        default :
            return false;
        }
    }

    /**
     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - ""Any
     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.""
     *
     * @param data
     *            The base-64 encoded data to groom
     * @return The data, less non-base64 characters (see RFC 2045).
     */
    static byte[] discardNonBase64(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;

        for (byte element : data) {
            if (isBase64(element)) {
                groomedData[bytesCopied++] = element;
            }
        }

        byte packedData[] = new byte[bytesCopied];

        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);

        return packedData;
    }

    // Implementation of the Encoder Interface

    /**
     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].
     *
     * @param pObject
     *            Object to encode
     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.
     * @throws EncoderException
     *             if the parameter supplied is not of type byte[]
     */
    public Object encode(Object pObject) throws EncoderException {
        if (!(pObject instanceof byte[])) {
            throw new EncoderException(""Parameter supplied to Base64 encode is not a byte[]"");
        }
        return encode((byte[]) pObject);
    }

    /**
     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.
     *
     * @param pArray
     *            a byte array containing binary data
     * @return A byte array containing only Base64 character data
     */
    public byte[] encode(byte[] pArray) {
        return encodeBase64(pArray, false);
    }

    // Implementation of integer encoding used for crypto
    /**
     * Decode a byte64-encoded integer according to crypto
     * standards such as W3C's XML-Signature
     *
     * @param pArray a byte array containing base64 character data
     * @return A BigInteger
     */
    public static BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(pArray));
    }

    /**
     * Encode to a byte64-encoded integer according to crypto
     * standards such as W3C's XML-Signature
     *
     * @param bigInt a BigInteger
     * @return A byte array containing base64 character data
     * @throws NullPointerException if null is passed in
     */
    public static byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }

        return encodeBase64(toIntegerBytes(bigInt), false);
    }

    /**
     * Returns a byte-array representation of a <code>BigInteger</code>
     * without sign bit.
     *
     * @param bigInt <code>BigInteger</code> to be converted
     * @return a byte array representation of the BigInteger parameter
     */
    static byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) &&
                (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }

        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }

        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];

        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);

        return resizedBytes;
    }

    static class DecoderException extends Exception {
        DecoderException(String error) {
            super(error);
        }
    }

    static class EncoderException extends Exception {
        EncoderException(String error) {
            super(error);
        }
    }
}
",False,116,5,48,0,0,4,0,L1
133,com.fsck.k9.mail.filter.SmtpDataStuffing.java,"package com.fsck.k9.mail.filter;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class SmtpDataStuffing extends FilterOutputStream {
    private static final int STATE_NORMAL = 0;
    private static final int STATE_CR = 1;
    private static final int STATE_CRLF = 2;

    private int state = STATE_NORMAL;

    public SmtpDataStuffing(OutputStream out) {
        super(out);
    }

    @Override
    public void write(int oneByte) throws IOException {
        if (oneByte == '\r') {
            state = STATE_CR;
        } else if ((state == STATE_CR) && (oneByte == '\n')) {
            state = STATE_CRLF;
        } else if ((state == STATE_CRLF) && (oneByte == '.')) {
            // Read <CR><LF><DOT> so this line needs an additional period.
            super.write('.');
            state = STATE_NORMAL;
        } else {
            state = STATE_NORMAL;
        }
        super.write(oneByte);
    }
}
",False,113,7,58,0,0,1,0,L1
134,com.fsck.k9.mail.internet.TextBody.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.Body;
import com.fsck.k9.mail.MessagingException;

import java.io.*;

import org.apache.james.mime4j.codec.QuotedPrintableOutputStream;

public class TextBody implements Body {

    /**
     * Immutable empty byte array
     */
    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];

    private String mBody;
    private String mEncoding;
    private String mCharset = ""UTF-8"";
    // Length of the message composed (as opposed to quoted). I don't like the name of this variable and am open to
    // suggestions as to what it should otherwise be. -achen 20101207
    private Integer mComposedMessageLength;
    // Offset from position 0 where the composed message begins.
    private Integer mComposedMessageOffset;

    public TextBody(String body) {
        this.mBody = body;
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException {
        if (mBody != null) {
            byte[] bytes = mBody.getBytes(mCharset);
            if (""8bit"".equals(mEncoding)) {
                out.write(bytes);
            } else {
                QuotedPrintableOutputStream qp = new QuotedPrintableOutputStream(out, false);
                qp.write(bytes);
                qp.flush();
            }
        }
    }

    /**
     * Get the text of the body in it's unencoded format.
     * @return
     */
    public String getText() {
        return mBody;
    }

    /**
     * Returns an InputStream that reads this body's text.
     */
    public InputStream getInputStream() throws MessagingException {
        try {
            byte[] b;
            if (mBody != null) {
                b = mBody.getBytes(mCharset);
            } else {
                b = EMPTY_BYTE_ARRAY;
            }
            return new ByteArrayInputStream(b);
        } catch (UnsupportedEncodingException usee) {
            return null;
        }
    }

    public void setEncoding(String encoding) {
        mEncoding = encoding;
    }

    public void setCharset(String charset) {
        mCharset = charset;
    }

    public Integer getComposedMessageLength() {
        return mComposedMessageLength;
    }

    public void setComposedMessageLength(Integer composedMessageLength) {
        this.mComposedMessageLength = composedMessageLength;
    }

    public Integer getComposedMessageOffset() {
        return mComposedMessageOffset;
    }

    public void setComposedMessageOffset(Integer composedMessageOffset) {
        this.mComposedMessageOffset = composedMessageOffset;
    }
}
",False,115,4,60,1,2,7,2,L1
135,com.fsck.k9.mail.internet.MimeMessage.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.*;
import com.fsck.k9.mail.store.UnavailableStorageException;

import org.apache.james.mime4j.stream.BodyDescriptor;
import org.apache.james.mime4j.stream.RawField;
import org.apache.james.mime4j.parser.ContentHandler;
import org.apache.james.mime4j.io.EOLConvertingInputStream;
import org.apache.james.mime4j.parser.MimeStreamParser;
import org.apache.james.mime4j.stream.MimeEntityConfig;
import org.apache.james.mime4j.dom.field.DateTimeField;
import org.apache.james.mime4j.dom.field.Field;
import org.apache.james.mime4j.field.DefaultFieldParser;

import org.apache.james.mime4j.MimeException;

import java.io.*;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * An implementation of Message that stores all of it's metadata in RFC 822 and
 * RFC 2045 style headers.
 */
public class MimeMessage extends Message {
    protected MimeHeader mHeader = new MimeHeader();
    protected Address[] mFrom;
    protected Address[] mTo;
    protected Address[] mCc;
    protected Address[] mBcc;
    protected Address[] mReplyTo;

    protected String mMessageId;
    protected String[] mReferences;
    protected String[] mInReplyTo;

    protected Date mSentDate;
    protected SimpleDateFormat mDateFormat;

    protected Body mBody;
    protected int mSize;

    public MimeMessage() {
    }


    /**
     * Parse the given InputStream using Apache Mime4J to build a MimeMessage.
     *
     * @param in
     * @throws IOException
     * @throws MessagingException
     */
    public MimeMessage(InputStream in) throws IOException, MessagingException {
        parse(in);
    }

    protected void parse(InputStream in) throws IOException, MessagingException {
        mHeader.clear();
        mFrom = null;
        mTo = null;
        mCc = null;
        mBcc = null;
        mReplyTo = null;

        mMessageId = null;
        mReferences = null;
        mInReplyTo = null;

        mSentDate = null;

        mBody = null;

        MimeEntityConfig parserConfig  = new MimeEntityConfig();
        parserConfig.setMaxHeaderLen(-1); // The default is a mere 10k
        parserConfig.setMaxLineLen(-1); // The default is 1000 characters. Some MUAs generate
        // REALLY long References: headers
        MimeStreamParser parser = new MimeStreamParser(parserConfig);
        parser.setContentHandler(new MimeMessageBuilder());
        try {
            parser.parse(new EOLConvertingInputStream(in));
        } catch (MimeException me) {
            throw new Error(me);

        }
    }

    @Override
    public Date getSentDate() {
        if (mSentDate == null) {
            try {
                DateTimeField field = (DateTimeField)DefaultFieldParser.parse(""Date: ""
                                      + MimeUtility.unfoldAndDecode(getFirstHeader(""Date"")));
                mSentDate = field.getDate();
            } catch (Exception e) {

            }
        }
        return mSentDate;
    }

    /**
     * Sets the sent date object member as well as *adds* the 'Date' header
     * instead of setting it (for performance reasons).
     *
     * @see #mSentDate
     * @param sentDate
     * @throws com.fsck.k9.mail.MessagingException
     */
    public void addSentDate(Date sentDate) throws MessagingException {
        if (mDateFormat == null) {
            mDateFormat = new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss Z"", Locale.US);
        }
        addHeader(""Date"", mDateFormat.format(sentDate));
        setInternalSentDate(sentDate);
    }

    @Override
    public void setSentDate(Date sentDate) throws MessagingException {
        removeHeader(""Date"");
        addSentDate(sentDate);
    }

    public void setInternalSentDate(Date sentDate) {
        this.mSentDate = sentDate;
    }

    @Override
    public String getContentType() throws MessagingException {
        String contentType = getFirstHeader(MimeHeader.HEADER_CONTENT_TYPE);
        return (contentType == null) ? ""text/plain"" : contentType.toLowerCase();
    }

    public String getDisposition() throws MessagingException {
        return getFirstHeader(MimeHeader.HEADER_CONTENT_DISPOSITION);
    }
    public String getContentId() throws MessagingException {
        return null;
    }
    public String getMimeType() throws MessagingException {
        return MimeUtility.getHeaderParameter(getContentType(), null);
    }

    public int getSize() {
        return mSize;
    }

    /**
     * Returns a list of the given recipient type from this message. If no addresses are
     * found the method returns an empty array.
     */
    @Override
    public Address[] getRecipients(RecipientType type) throws MessagingException {
        if (type == RecipientType.TO) {
            if (mTo == null) {
                mTo = Address.parse(MimeUtility.unfold(getFirstHeader(""To"")));
            }
            return mTo;
        } else if (type == RecipientType.CC) {
            if (mCc == null) {
                mCc = Address.parse(MimeUtility.unfold(getFirstHeader(""CC"")));
            }
            return mCc;
        } else if (type == RecipientType.BCC) {
            if (mBcc == null) {
                mBcc = Address.parse(MimeUtility.unfold(getFirstHeader(""BCC"")));
            }
            return mBcc;
        } else {
            throw new MessagingException(""Unrecognized recipient type."");
        }
    }

    @Override
    public void setRecipients(RecipientType type, Address[] addresses) throws MessagingException {
        if (type == RecipientType.TO) {
            if (addresses == null || addresses.length == 0) {
                removeHeader(""To"");
                this.mTo = null;
            } else {
                setHeader(""To"", Address.toEncodedString(addresses));
                this.mTo = addresses;
            }
        } else if (type == RecipientType.CC) {
            if (addresses == null || addresses.length == 0) {
                removeHeader(""CC"");
                this.mCc = null;
            } else {
                setHeader(""CC"", Address.toEncodedString(addresses));
                this.mCc = addresses;
            }
        } else if (type == RecipientType.BCC) {
            if (addresses == null || addresses.length == 0) {
                removeHeader(""BCC"");
                this.mBcc = null;
            } else {
                setHeader(""BCC"", Address.toEncodedString(addresses));
                this.mBcc = addresses;
            }
        } else {
            throw new MessagingException(""Unrecognized recipient type."");
        }
    }

    /**
     * Returns the unfolded, decoded value of the Subject header.
     */
    @Override
    public String getSubject() {
        return MimeUtility.unfoldAndDecode(getFirstHeader(""Subject""), this);
    }

    @Override
    public void setSubject(String subject) throws MessagingException {
        setHeader(""Subject"", subject);
    }

    @Override
    public Address[] getFrom() {
        if (mFrom == null) {
            String list = MimeUtility.unfold(getFirstHeader(""From""));
            if (list == null || list.length() == 0) {
                list = MimeUtility.unfold(getFirstHeader(""Sender""));
            }
            mFrom = Address.parse(list);
        }
        return mFrom;
    }

    @Override
    public void setFrom(Address from) throws MessagingException {
        if (from != null) {
            setHeader(""From"", from.toEncodedString());
            this.mFrom = new Address[] {
                from
            };
        } else {
            this.mFrom = null;
        }
    }

    @Override
    public Address[] getReplyTo() {
        if (mReplyTo == null) {
            mReplyTo = Address.parse(MimeUtility.unfold(getFirstHeader(""Reply-to"")));
        }
        return mReplyTo;
    }

    @Override
    public void setReplyTo(Address[] replyTo) throws MessagingException {
        if (replyTo == null || replyTo.length == 0) {
            removeHeader(""Reply-to"");
            mReplyTo = null;
        } else {
            setHeader(""Reply-to"", Address.toEncodedString(replyTo));
            mReplyTo = replyTo;
        }
    }

    @Override
    public String getMessageId() throws MessagingException {
        if (mMessageId == null) {
            mMessageId = getFirstHeader(""Message-ID"");
        }
        if (mMessageId == null) { //  even after checking the header
            setMessageId(generateMessageId());
        }
        return mMessageId;
    }

    private String generateMessageId() {
        return ""<"" + UUID.randomUUID().toString() + ""@email.android.com>"";
    }

    public void setMessageId(String messageId) throws UnavailableStorageException {
        setHeader(""Message-ID"", messageId);
        mMessageId = messageId;
    }

    @Override
    public void setInReplyTo(String inReplyTo) throws MessagingException {
        setHeader(""In-Reply-To"", inReplyTo);
    }

    @Override
    public String[] getReferences() throws MessagingException {
        if (mReferences == null) {
            mReferences = getHeader(""References"");
        }
        return mReferences;
    }

    @Override
    public void setReferences(String references) throws MessagingException {
        /*
         * Make sure the References header doesn't exceed the maximum header
         * line length and won't get (Q-)encoded later. Otherwise some clients
         * will break threads apart.
         *
         * For more information see issue 1559.
         */

        // Make sure separator is SPACE to prevent Q-encoding when TAB is encountered
        references = references.replaceAll(""\\s+"", "" "");

        /*
         * NOTE: Usually the maximum header line is 998 + CRLF = 1000 characters.
         * But at least one implementations seems to have problems with 998
         * characters, so we adjust for that fact.
         */
        final int limit = 1000 - 2 /* CRLF */ - 12 /* ""References: "" */ - 1 /* Off-by-one bugs */;
        final int originalLength = references.length();
        if (originalLength >= limit) {
            // Find start of first reference
            final int start = references.indexOf('<');

            // First reference + SPACE
            final String firstReference = references.substring(start,
                                          references.indexOf('<', start + 1));

            // Find longest tail
            final String tail = references.substring(references.indexOf('<',
                                firstReference.length() + originalLength - limit));

            references = firstReference + tail;
        }
        setHeader(""References"", references);
    }

    @Override
    public void saveChanges() throws MessagingException {
        throw new MessagingException(""saveChanges not yet implemented"");
    }

    @Override
    public Body getBody() {
        return mBody;
    }

    @Override
    public void setBody(Body body) throws MessagingException {
        this.mBody = body;
        setHeader(""MIME-Version"", ""1.0"");
        if (body instanceof Multipart) {
            Multipart multipart = ((Multipart)body);
            multipart.setParent(this);
            setHeader(MimeHeader.HEADER_CONTENT_TYPE, multipart.getContentType());
        } else if (body instanceof TextBody) {
            setHeader(MimeHeader.HEADER_CONTENT_TYPE, String.format(""%s;\n charset=utf-8"",
                      getMimeType()));
            setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, ""quoted-printable"");
        }
    }

    protected String getFirstHeader(String name) {
        return mHeader.getFirstHeader(name);
    }

    @Override
    public void addHeader(String name, String value) throws UnavailableStorageException {
        mHeader.addHeader(name, value);
    }

    @Override
    public void setHeader(String name, String value) throws UnavailableStorageException {
        mHeader.setHeader(name, value);
    }

    @Override
    public String[] getHeader(String name) throws UnavailableStorageException {
        return mHeader.getHeader(name);
    }

    @Override
    public void removeHeader(String name) throws UnavailableStorageException {
        mHeader.removeHeader(name);
    }

    @Override
    public Set<String> getHeaderNames() throws UnavailableStorageException {
        return mHeader.getHeaderNames();
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException {

        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out), 1024);
        mHeader.writeTo(out);
        writer.write(""\r\n"");
        writer.flush();
        if (mBody != null) {
            mBody.writeTo(out);
        }
    }

    public InputStream getInputStream() throws MessagingException {
        return null;
    }

    @Override
    public void setEncoding(String encoding) throws UnavailableStorageException {
        if (mBody instanceof Multipart) {
            ((Multipart)mBody).setEncoding(encoding);
        } else if (mBody instanceof TextBody) {
            setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, encoding);
            ((TextBody)mBody).setEncoding(encoding);
        }
    }

    @Override
    public void setCharset(String charset) throws MessagingException {
        mHeader.setCharset(charset);
        if (mBody instanceof Multipart) {
            ((Multipart)mBody).setCharset(charset);
        } else if (mBody instanceof TextBody) {
            MimeUtility.setCharset(charset, this);
            ((TextBody)mBody).setCharset(charset);
        }
    }

    class MimeMessageBuilder implements ContentHandler {
        private Stack<Object> stack = new Stack<Object>();

        public MimeMessageBuilder() {
        }

        private void expect(Class<?> c) {
            if (!c.isInstance(stack.peek())) {
                throw new IllegalStateException(""Internal stack error: "" + ""Expected '""
                                                + c.getName() + ""' found '"" + stack.peek().getClass().getName() + ""'"");
            }
        }

        public void startMessage() {
            if (stack.isEmpty()) {
                stack.push(MimeMessage.this);
            } else {
                expect(Part.class);
                try {
                    MimeMessage m = new MimeMessage();
                    ((Part)stack.peek()).setBody(m);
                    stack.push(m);
                } catch (MessagingException me) {
                    throw new Error(me);
                }
            }
        }

        public void endMessage() {
            expect(MimeMessage.class);
            stack.pop();
        }

        public void startHeader() {
            expect(Part.class);
        }

        public void field(RawField field) {
            expect(Part.class);
            try {
                Field parsedField = DefaultFieldParser.parse(field.getRaw(), null);
                ((Part)stack.peek()).addHeader(parsedField.getName(), parsedField.getBody().trim());
            } catch (MessagingException me) {
                throw new Error(me);
            } catch (MimeException me) {
                throw new Error(me);
            }
        }

        public void field(String fieldData) {
            expect(Part.class);
            try {
                String[] tokens = fieldData.split("":"", 2);
                ((Part)stack.peek()).addHeader(tokens[0], tokens[1].trim());
            } catch (MessagingException me) {
                throw new Error(me);
            }
        }

        public void endHeader() {
            expect(Part.class);
        }

        public void startMultipart(BodyDescriptor bd) {
            expect(Part.class);

            Part e = (Part)stack.peek();
            try {
                MimeMultipart multiPart = new MimeMultipart(e.getContentType());
                e.setBody(multiPart);
                stack.push(multiPart);
            } catch (MessagingException me) {
                throw new Error(me);
            }
        }

        public void body(BodyDescriptor bd, InputStream in) throws IOException {
            expect(Part.class);
            Body body = MimeUtility.decodeBody(in, bd.getTransferEncoding());
            try {
                ((Part)stack.peek()).setBody(body);
            } catch (MessagingException me) {
                throw new Error(me);
            }
        }

        public void endMultipart() {
            stack.pop();
        }

        public void startBodyPart() {
            expect(MimeMultipart.class);

            try {
                MimeBodyPart bodyPart = new MimeBodyPart();
                ((MimeMultipart)stack.peek()).addBodyPart(bodyPart);
                stack.push(bodyPart);
            } catch (MessagingException me) {
                throw new Error(me);
            }
        }

        public void endBodyPart() {
            expect(BodyPart.class);
            stack.pop();
        }

        public void epilogue(InputStream is) throws IOException {
            expect(MimeMultipart.class);
            StringBuffer sb = new StringBuffer();
            int b;
            while ((b = is.read()) != -1) {
                sb.append((char)b);
            }
            // ((Multipart) stack.peek()).setEpilogue(sb.toString());
        }

        public void preamble(InputStream is) throws IOException {
            expect(MimeMultipart.class);
            StringBuffer sb = new StringBuffer();
            int b;
            while ((b = is.read()) != -1) {
                sb.append((char)b);
            }
            ((MimeMultipart)stack.peek()).setPreamble(sb.toString());

        }

        public void raw(InputStream is) throws IOException {
            throw new UnsupportedOperationException(""Not supported"");
        }
    }
}
",True,145,1,1,7,33,9,12,L1
136,com.fsck.k9.mail.internet.MimeHeader.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.helper.Utility;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.util.*;

public class MimeHeader {
    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    /**
     * Application specific header that contains Store specific information about an attachment.
     * In IMAP this contains the IMAP BODYSTRUCTURE part id so that the ImapStore can later
     * retrieve the attachment at will from the server.
     * The info is recorded from this header on LocalStore.appendMessages and is put back
     * into the MIME data by LocalStore.fetch.
     */
    public static final String HEADER_ANDROID_ATTACHMENT_STORE_DATA = ""X-Android-Attachment-StoreData"";

    public static final String HEADER_CONTENT_TYPE = ""Content-Type"";
    public static final String HEADER_CONTENT_TRANSFER_ENCODING = ""Content-Transfer-Encoding"";
    public static final String HEADER_CONTENT_DISPOSITION = ""Content-Disposition"";
    public static final String HEADER_CONTENT_ID = ""Content-ID"";

    /**
     * Fields that should be omitted when writing the header using writeTo()
     */
    private static final String[] writeOmitFields = {
//        HEADER_ANDROID_ATTACHMENT_DOWNLOADED,
//        HEADER_ANDROID_ATTACHMENT_ID,
        HEADER_ANDROID_ATTACHMENT_STORE_DATA
    };

    protected ArrayList<Field> mFields = new ArrayList<Field>();
    private String mCharset = null;

    public void clear() {
        mFields.clear();
    }

    public String getFirstHeader(String name) {
        String[] header = getHeader(name);
        if (header == null) {
            return null;
        }
        return header[0];
    }

    public void addHeader(String name, String value) {
        mFields.add(new Field(name, MimeUtility.foldAndEncode(value)));
    }

    public void setHeader(String name, String value) {
        if (name == null || value == null) {
            return;
        }
        removeHeader(name);
        addHeader(name, value);
    }

    public Set<String> getHeaderNames() {
        Set<String> names = new HashSet<String>();
        for (Field field : mFields) {
            names.add(field.name);
        }
        return names;
    }

    public String[] getHeader(String name) {
        ArrayList<String> values = new ArrayList<String>();
        for (Field field : mFields) {
            if (field.name.equalsIgnoreCase(name)) {
                values.add(field.value);
            }
        }
        if (values.size() == 0) {
            return null;
        }
        return values.toArray(EMPTY_STRING_ARRAY);
    }

    public void removeHeader(String name) {
        ArrayList<Field> removeFields = new ArrayList<Field>();
        for (Field field : mFields) {
            if (field.name.equalsIgnoreCase(name)) {
                removeFields.add(field);
            }
        }
        mFields.removeAll(removeFields);
    }

    public void writeTo(OutputStream out) throws IOException {
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out), 1024);
        for (Field field : mFields) {
            if (!Utility.arrayContains(writeOmitFields, field.name)) {
                String v = field.value;

                if (hasToBeEncoded(v)) {
                    Charset charset = null;

                    if (mCharset != null) {
                        charset = Charset.forName(mCharset);
                    }
                    v = EncoderUtil.encodeEncodedWord(field.value, charset);
                }

                writer.write(field.name + "": "" + v + ""\r\n"");
            }
        }
        writer.flush();
    }

    // encode non printable characters except LF/CR codes.
    public boolean hasToBeEncoded(String text) {
        for (int i = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            if (c < 0x20 || 0x7e < c) { // non printable
                if (c != 0x0a && c != 0x0d) { // non LF/CR
                    return true;
                }
            }
        }

        return false;
    }

    static class Field {
        String name;

        String value;

        public Field(String name, String value) {
            this.name = name;
            this.value = value;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder(""("");
            sb.append(name).append('=').append(value).append(')');
            return sb.toString();
        }
    }

    public void setCharset(String charset) {
        mCharset = charset;
    }
}
",False,144,0,0,8,40,7,3,L1
137,com.fsck.k9.mail.internet.MimeBodyPart.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.Body;
import com.fsck.k9.mail.BodyPart;
import com.fsck.k9.mail.MessagingException;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

/**
 * TODO this is a close approximation of Message, need to update along with
 * Message.
 */
public class MimeBodyPart extends BodyPart {
    protected MimeHeader mHeader = new MimeHeader();
    protected Body mBody;
    protected int mSize;

    public MimeBodyPart() throws MessagingException {
        this(null);
    }

    public MimeBodyPart(Body body) throws MessagingException {
        this(body, null);
    }

    public MimeBodyPart(Body body, String mimeType) throws MessagingException {
        if (mimeType != null) {
            addHeader(MimeHeader.HEADER_CONTENT_TYPE, mimeType);
        }
        setBody(body);
    }

    protected String getFirstHeader(String name) {
        return mHeader.getFirstHeader(name);
    }

    public void addHeader(String name, String value) throws MessagingException {
        mHeader.addHeader(name, value);
    }

    public void setHeader(String name, String value) throws MessagingException {
        mHeader.setHeader(name, value);
    }

    public String[] getHeader(String name) throws MessagingException {
        return mHeader.getHeader(name);
    }

    public void removeHeader(String name) throws MessagingException {
        mHeader.removeHeader(name);
    }

    public Body getBody() {
        return mBody;
    }

    public void setBody(Body body) throws MessagingException {
        this.mBody = body;
        if (body instanceof com.fsck.k9.mail.Multipart) {
            com.fsck.k9.mail.Multipart multipart = ((com.fsck.k9.mail.Multipart)body);
            multipart.setParent(this);
            setHeader(MimeHeader.HEADER_CONTENT_TYPE, multipart.getContentType());
        } else if (body instanceof TextBody) {
            String contentType = String.format(""%s;\n charset=utf-8"", getMimeType());
            String name = MimeUtility.getHeaderParameter(getContentType(), ""name"");
            if (name != null) {
                contentType += String.format("";\n name=\""%s\"""", name);
            }
            setHeader(MimeHeader.HEADER_CONTENT_TYPE, contentType);
            setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, ""quoted-printable"");
        }
    }

    public String getContentType() throws MessagingException {
        String contentType = getFirstHeader(MimeHeader.HEADER_CONTENT_TYPE);
        return (contentType == null) ? ""text/plain"" : contentType;
    }

    public String getDisposition() throws MessagingException {
        return getFirstHeader(MimeHeader.HEADER_CONTENT_DISPOSITION);
    }

    public String getContentId() throws MessagingException {
        String contentId = getFirstHeader(MimeHeader.HEADER_CONTENT_ID);
        if (contentId == null) {
            return null;
        }

        int first = contentId.indexOf('<');
        int last = contentId.lastIndexOf('>');

        return (first != -1 && last != -1) ?
               contentId.substring(first + 1, last) :
               contentId;
    }

    public String getMimeType() throws MessagingException {
        return MimeUtility.getHeaderParameter(getContentType(), null);
    }

    public boolean isMimeType(String mimeType) throws MessagingException {
        return getMimeType().equals(mimeType);
    }

    public int getSize() {
        return mSize;
    }

    /**
     * Write the MimeMessage out in MIME format.
     */
    public void writeTo(OutputStream out) throws IOException, MessagingException {
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out), 1024);
        mHeader.writeTo(out);
        writer.write(""\r\n"");
        writer.flush();
        if (mBody != null) {
            mBody.writeTo(out);
        }
    }
}
",False,144,0,0,8,39,5,7,L1
138,com.fsck.k9.mail.internet.BinaryTempFileBody.java,"package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.Body;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.filter.Base64OutputStream;
import org.apache.commons.io.IOUtils;

import java.io.*;

/**
 * A Body that is backed by a temp file. The Body exposes a getOutputStream method that allows
 * the user to write to the temp file. After the write the body is available via getInputStream
 * and writeTo one time. After writeTo is called, or the InputStream returned from
 * getInputStream is closed the file is deleted and the Body should be considered disposed of.
 */
public class BinaryTempFileBody implements Body {
    private static File mTempDirectory;

    private File mFile;

    public static void setTempDirectory(File tempDirectory) {
        mTempDirectory = tempDirectory;
    }

    public BinaryTempFileBody() {
        if (mTempDirectory == null) {
            throw new
            RuntimeException(""setTempDirectory has not been called on BinaryTempFileBody!"");
        }
    }

    public OutputStream getOutputStream() throws IOException {
        mFile = File.createTempFile(""body"", null, mTempDirectory);
        mFile.deleteOnExit();
        return new FileOutputStream(mFile);
    }

    public InputStream getInputStream() throws MessagingException {
        try {
            return new BinaryTempFileBodyInputStream(new FileInputStream(mFile));
        } catch (IOException ioe) {
            throw new MessagingException(""Unable to open body"", ioe);
        }
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException {
        InputStream in = getInputStream();
        Base64OutputStream base64Out = new Base64OutputStream(out);
        IOUtils.copy(in, base64Out);
        base64Out.close();
        mFile.delete();
    }

    class BinaryTempFileBodyInputStream extends FilterInputStream {
        public BinaryTempFileBodyInputStream(InputStream in) {
            super(in);
        }

        @Override
        public void close() throws IOException {
            super.close();
            mFile.delete();
        }
    }
}
",True,117,3,82,2,3,2,3,L1
139,com.fsck.k9.mail.internet.MimeUtility.java,"
package com.fsck.k9.mail.internet;

import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.mail.*;
import org.apache.commons.io.IOUtils;
import org.apache.james.mime4j.codec.Base64InputStream;
import org.apache.james.mime4j.codec.QuotedPrintableInputStream;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;


public class MimeUtility {
    public static final String DEFAULT_ATTACHMENT_MIME_TYPE = ""application/octet-stream"";



    /*
     * http://www.w3schools.com/media/media_mimeref.asp
     * +
     * http://www.stdicon.com/mimetypes
     */
    public static final String[][] MIME_TYPE_BY_EXTENSION_MAP = new String[][] {
        { """", ""application/octet-stream"" },
        { ""123"", ""application/vnd.lotus-1-2-3""},
        { ""323"", ""text/h323""},
        { ""3dml"", ""text/vnd.in3d.3dml""},
        { ""3g2"", ""video/3gpp2""},
        { ""3gp"", ""video/3gpp""},
        { ""aab"", ""application/x-authorware-bin""},
        { ""aac"", ""audio/x-aac""},
        { ""aam"", ""application/x-authorware-map""},
        { ""a"", ""application/octet-stream""},
        { ""aas"", ""application/x-authorware-seg""},
        { ""abw"", ""application/x-abiword""},
        { ""acc"", ""application/vnd.americandynamics.acc""},
        { ""ace"", ""application/x-ace-compressed""},
        { ""acu"", ""application/vnd.acucobol""},
        { ""acutc"", ""application/vnd.acucorp""},
        { ""acx"", ""application/internet-property-stream""},
        { ""adp"", ""audio/adpcm""},
        { ""aep"", ""application/vnd.audiograph""},
        { ""afm"", ""application/x-font-type1""},
        { ""afp"", ""application/vnd.ibm.modcap""},
        { ""ai"", ""application/postscript""},
        { ""aif"", ""audio/x-aiff""},
        { ""aifc"", ""audio/x-aiff""},
        { ""aiff"", ""audio/x-aiff""},
        { ""air"", ""application/vnd.adobe.air-application-installer-package+zip""},
        { ""ami"", ""application/vnd.amiga.ami""},
        { ""apk"", ""application/vnd.android.package-archive""},
        { ""application"", ""application/x-ms-application""},
        { ""apr"", ""application/vnd.lotus-approach""},
        { ""asc"", ""application/pgp-signature""},
        { ""asf"", ""video/x-ms-asf""},
        { ""asm"", ""text/x-asm""},
        { ""aso"", ""application/vnd.accpac.simply.aso""},
        { ""asr"", ""video/x-ms-asf""},
        { ""asx"", ""video/x-ms-asf""},
        { ""atc"", ""application/vnd.acucorp""},
        { ""atom"", ""application/atom+xml""},
        { ""atomcat"", ""application/atomcat+xml""},
        { ""atomsvc"", ""application/atomsvc+xml""},
        { ""atx"", ""application/vnd.antix.game-component""},
        { ""au"", ""audio/basic""},
        { ""avi"", ""video/x-msvideo""},
        { ""aw"", ""application/applixware""},
        { ""axs"", ""application/olescript""},
        { ""azf"", ""application/vnd.airzip.filesecure.azf""},
        { ""azs"", ""application/vnd.airzip.filesecure.azs""},
        { ""azw"", ""application/vnd.amazon.ebook""},
        { ""bas"", ""text/plain""},
        { ""bat"", ""application/x-msdownload""},
        { ""bcpio"", ""application/x-bcpio""},
        { ""bdf"", ""application/x-font-bdf""},
        { ""bdm"", ""application/vnd.syncml.dm+wbxml""},
        { ""bh2"", ""application/vnd.fujitsu.oasysprs""},
        { ""bin"", ""application/octet-stream""},
        { ""bmi"", ""application/vnd.bmi""},
        { ""bmp"", ""image/bmp""},
        { ""book"", ""application/vnd.framemaker""},
        { ""box"", ""application/vnd.previewsystems.box""},
        { ""boz"", ""application/x-bzip2""},
        { ""bpk"", ""application/octet-stream""},
        { ""btif"", ""image/prs.btif""},
        { ""bz2"", ""application/x-bzip2""},
        { ""bz"", ""application/x-bzip""},
        { ""c4d"", ""application/vnd.clonk.c4group""},
        { ""c4f"", ""application/vnd.clonk.c4group""},
        { ""c4g"", ""application/vnd.clonk.c4group""},
        { ""c4p"", ""application/vnd.clonk.c4group""},
        { ""c4u"", ""application/vnd.clonk.c4group""},
        { ""cab"", ""application/vnd.ms-cab-compressed""},
        { ""car"", ""application/vnd.curl.car""},
        { ""cat"", ""application/vnd.ms-pki.seccat""},
        { ""cct"", ""application/x-director""},
        { ""cc"", ""text/x-c""},
        { ""ccxml"", ""application/ccxml+xml""},
        { ""cdbcmsg"", ""application/vnd.contact.cmsg""},
        { ""cdf"", ""application/x-cdf""},
        { ""cdkey"", ""application/vnd.mediastation.cdkey""},
        { ""cdx"", ""chemical/x-cdx""},
        { ""cdxml"", ""application/vnd.chemdraw+xml""},
        { ""cdy"", ""application/vnd.cinderella""},
        { ""cer"", ""application/x-x509-ca-cert""},
        { ""cgm"", ""image/cgm""},
        { ""chat"", ""application/x-chat""},
        { ""chm"", ""application/vnd.ms-htmlhelp""},
        { ""chrt"", ""application/vnd.kde.kchart""},
        { ""cif"", ""chemical/x-cif""},
        { ""cii"", ""application/vnd.anser-web-certificate-issue-initiation""},
        { ""cla"", ""application/vnd.claymore""},
        { ""class"", ""application/java-vm""},
        { ""clkk"", ""application/vnd.crick.clicker.keyboard""},
        { ""clkp"", ""application/vnd.crick.clicker.palette""},
        { ""clkt"", ""application/vnd.crick.clicker.template""},
        { ""clkw"", ""application/vnd.crick.clicker.wordbank""},
        { ""clkx"", ""application/vnd.crick.clicker""},
        { ""clp"", ""application/x-msclip""},
        { ""cmc"", ""application/vnd.cosmocaller""},
        { ""cmdf"", ""chemical/x-cmdf""},
        { ""cml"", ""chemical/x-cml""},
        { ""cmp"", ""application/vnd.yellowriver-custom-menu""},
        { ""cmx"", ""image/x-cmx""},
        { ""cod"", ""application/vnd.rim.cod""},
        { ""com"", ""application/x-msdownload""},
        { ""conf"", ""text/plain""},
        { ""cpio"", ""application/x-cpio""},
        { ""cpp"", ""text/x-c""},
        { ""cpt"", ""application/mac-compactpro""},
        { ""crd"", ""application/x-mscardfile""},
        { ""crl"", ""application/pkix-crl""},
        { ""crt"", ""application/x-x509-ca-cert""},
        { ""csh"", ""application/x-csh""},
        { ""csml"", ""chemical/x-csml""},
        { ""csp"", ""application/vnd.commonspace""},
        { ""css"", ""text/css""},
        { ""cst"", ""application/x-director""},
        { ""csv"", ""text/csv""},
        { ""c"", ""text/plain""},
        { ""cu"", ""application/cu-seeme""},
        { ""curl"", ""text/vnd.curl""},
        { ""cww"", ""application/prs.cww""},
        { ""cxt"", ""application/x-director""},
        { ""cxx"", ""text/x-c""},
        { ""daf"", ""application/vnd.mobius.daf""},
        { ""dataless"", ""application/vnd.fdsn.seed""},
        { ""davmount"", ""application/davmount+xml""},
        { ""dcr"", ""application/x-director""},
        { ""dcurl"", ""text/vnd.curl.dcurl""},
        { ""dd2"", ""application/vnd.oma.dd2+xml""},
        { ""ddd"", ""application/vnd.fujixerox.ddd""},
        { ""deb"", ""application/x-debian-package""},
        { ""def"", ""text/plain""},
        { ""deploy"", ""application/octet-stream""},
        { ""der"", ""application/x-x509-ca-cert""},
        { ""dfac"", ""application/vnd.dreamfactory""},
        { ""dic"", ""text/x-c""},
        { ""diff"", ""text/plain""},
        { ""dir"", ""application/x-director""},
        { ""dis"", ""application/vnd.mobius.dis""},
        { ""dist"", ""application/octet-stream""},
        { ""distz"", ""application/octet-stream""},
        { ""djv"", ""image/vnd.djvu""},
        { ""djvu"", ""image/vnd.djvu""},
        { ""dll"", ""application/x-msdownload""},
        { ""dmg"", ""application/octet-stream""},
        { ""dms"", ""application/octet-stream""},
        { ""dna"", ""application/vnd.dna""},
        { ""doc"", ""application/msword""},
        { ""docm"", ""application/vnd.ms-word.document.macroenabled.12""},
        { ""docx"", ""application/vnd.openxmlformats-officedocument.wordprocessingml.document""},
        { ""dot"", ""application/msword""},
        { ""dotm"", ""application/vnd.ms-word.template.macroenabled.12""},
        { ""dotx"", ""application/vnd.openxmlformats-officedocument.wordprocessingml.template""},
        { ""dp"", ""application/vnd.osgi.dp""},
        { ""dpg"", ""application/vnd.dpgraph""},
        { ""dsc"", ""text/prs.lines.tag""},
        { ""dtb"", ""application/x-dtbook+xml""},
        { ""dtd"", ""application/xml-dtd""},
        { ""dts"", ""audio/vnd.dts""},
        { ""dtshd"", ""audio/vnd.dts.hd""},
        { ""dump"", ""application/octet-stream""},
        { ""dvi"", ""application/x-dvi""},
        { ""dwf"", ""model/vnd.dwf""},
        { ""dwg"", ""image/vnd.dwg""},
        { ""dxf"", ""image/vnd.dxf""},
        { ""dxp"", ""application/vnd.spotfire.dxp""},
        { ""dxr"", ""application/x-director""},
        { ""ecelp4800"", ""audio/vnd.nuera.ecelp4800""},
        { ""ecelp7470"", ""audio/vnd.nuera.ecelp7470""},
        { ""ecelp9600"", ""audio/vnd.nuera.ecelp9600""},
        { ""ecma"", ""application/ecmascript""},
        { ""edm"", ""application/vnd.novadigm.edm""},
        { ""edx"", ""application/vnd.novadigm.edx""},
        { ""efif"", ""application/vnd.picsel""},
        { ""ei6"", ""application/vnd.pg.osasli""},
        { ""elc"", ""application/octet-stream""},
        { ""eml"", ""message/rfc822""},
        { ""emma"", ""application/emma+xml""},
        { ""eol"", ""audio/vnd.digital-winds""},
        { ""eot"", ""application/vnd.ms-fontobject""},
        { ""eps"", ""application/postscript""},
        { ""epub"", ""application/epub+zip""},
        { ""es3"", ""application/vnd.eszigno3+xml""},
        { ""esf"", ""application/vnd.epson.esf""},
        { ""et3"", ""application/vnd.eszigno3+xml""},
        { ""etx"", ""text/x-setext""},
        { ""evy"", ""application/envoy""},
        { ""exe"", ""application/octet-stream""},
        { ""ext"", ""application/vnd.novadigm.ext""},
        { ""ez2"", ""application/vnd.ezpix-album""},
        { ""ez3"", ""application/vnd.ezpix-package""},
        { ""ez"", ""application/andrew-inset""},
        { ""f4v"", ""video/x-f4v""},
        { ""f77"", ""text/x-fortran""},
        { ""f90"", ""text/x-fortran""},
        { ""fbs"", ""image/vnd.fastbidsheet""},
        { ""fdf"", ""application/vnd.fdf""},
        { ""fe_launch"", ""application/vnd.denovo.fcselayout-link""},
        { ""fg5"", ""application/vnd.fujitsu.oasysgp""},
        { ""fgd"", ""application/x-director""},
        { ""fh4"", ""image/x-freehand""},
        { ""fh5"", ""image/x-freehand""},
        { ""fh7"", ""image/x-freehand""},
        { ""fhc"", ""image/x-freehand""},
        { ""fh"", ""image/x-freehand""},
        { ""fif"", ""application/fractals""},
        { ""fig"", ""application/x-xfig""},
        { ""fli"", ""video/x-fli""},
        { ""flo"", ""application/vnd.micrografx.flo""},
        { ""flr"", ""x-world/x-vrml""},
        { ""flv"", ""video/x-flv""},
        { ""flw"", ""application/vnd.kde.kivio""},
        { ""flx"", ""text/vnd.fmi.flexstor""},
        { ""fly"", ""text/vnd.fly""},
        { ""fm"", ""application/vnd.framemaker""},
        { ""fnc"", ""application/vnd.frogans.fnc""},
        { ""for"", ""text/x-fortran""},
        { ""fpx"", ""image/vnd.fpx""},
        { ""frame"", ""application/vnd.framemaker""},
        { ""fsc"", ""application/vnd.fsc.weblaunch""},
        { ""fst"", ""image/vnd.fst""},
        { ""ftc"", ""application/vnd.fluxtime.clip""},
        { ""f"", ""text/x-fortran""},
        { ""fti"", ""application/vnd.anser-web-funds-transfer-initiation""},
        { ""fvt"", ""video/vnd.fvt""},
        { ""fzs"", ""application/vnd.fuzzysheet""},
        { ""g3"", ""image/g3fax""},
        { ""gac"", ""application/vnd.groove-account""},
        { ""gdl"", ""model/vnd.gdl""},
        { ""geo"", ""application/vnd.dynageo""},
        { ""gex"", ""application/vnd.geometry-explorer""},
        { ""ggb"", ""application/vnd.geogebra.file""},
        { ""ggt"", ""application/vnd.geogebra.tool""},
        { ""ghf"", ""application/vnd.groove-help""},
        { ""gif"", ""image/gif""},
        { ""gim"", ""application/vnd.groove-identity-message""},
        { ""gmx"", ""application/vnd.gmx""},
        { ""gnumeric"", ""application/x-gnumeric""},
        { ""gph"", ""application/vnd.flographit""},
        { ""gqf"", ""application/vnd.grafeq""},
        { ""gqs"", ""application/vnd.grafeq""},
        { ""gram"", ""application/srgs""},
        { ""gre"", ""application/vnd.geometry-explorer""},
        { ""grv"", ""application/vnd.groove-injector""},
        { ""grxml"", ""application/srgs+xml""},
        { ""gsf"", ""application/x-font-ghostscript""},
        { ""gtar"", ""application/x-gtar""},
        { ""gtm"", ""application/vnd.groove-tool-message""},
        { ""gtw"", ""model/vnd.gtw""},
        { ""gv"", ""text/vnd.graphviz""},
        { ""gz"", ""application/x-gzip""},
        { ""h261"", ""video/h261""},
        { ""h263"", ""video/h263""},
        { ""h264"", ""video/h264""},
        { ""hbci"", ""application/vnd.hbci""},
        { ""hdf"", ""application/x-hdf""},
        { ""hh"", ""text/x-c""},
        { ""hlp"", ""application/winhlp""},
        { ""hpgl"", ""application/vnd.hp-hpgl""},
        { ""hpid"", ""application/vnd.hp-hpid""},
        { ""hps"", ""application/vnd.hp-hps""},
        { ""hqx"", ""application/mac-binhex40""},
        { ""hta"", ""application/hta""},
        { ""htc"", ""text/x-component""},
        { ""h"", ""text/plain""},
        { ""htke"", ""application/vnd.kenameaapp""},
        { ""html"", ""text/html""},
        { ""htm"", ""text/html""},
        { ""htt"", ""text/webviewhtml""},
        { ""hvd"", ""application/vnd.yamaha.hv-dic""},
        { ""hvp"", ""application/vnd.yamaha.hv-voice""},
        { ""hvs"", ""application/vnd.yamaha.hv-script""},
        { ""icc"", ""application/vnd.iccprofile""},
        { ""ice"", ""x-conference/x-cooltalk""},
        { ""icm"", ""application/vnd.iccprofile""},
        { ""ico"", ""image/x-icon""},
        { ""ics"", ""text/calendar""},
        { ""ief"", ""image/ief""},
        { ""ifb"", ""text/calendar""},
        { ""ifm"", ""application/vnd.shana.informed.formdata""},
        { ""iges"", ""model/iges""},
        { ""igl"", ""application/vnd.igloader""},
        { ""igs"", ""model/iges""},
        { ""igx"", ""application/vnd.micrografx.igx""},
        { ""iif"", ""application/vnd.shana.informed.interchange""},
        { ""iii"", ""application/x-iphone""},
        { ""imp"", ""application/vnd.accpac.simply.imp""},
        { ""ims"", ""application/vnd.ms-ims""},
        { ""ins"", ""application/x-internet-signup""},
        { ""in"", ""text/plain""},
        { ""ipk"", ""application/vnd.shana.informed.package""},
        { ""irm"", ""application/vnd.ibm.rights-management""},
        { ""irp"", ""application/vnd.irepository.package+xml""},
        { ""iso"", ""application/octet-stream""},
        { ""isp"", ""application/x-internet-signup""},
        { ""itp"", ""application/vnd.shana.informed.formtemplate""},
        { ""ivp"", ""application/vnd.immervision-ivp""},
        { ""ivu"", ""application/vnd.immervision-ivu""},
        { ""jad"", ""text/vnd.sun.j2me.app-descriptor""},
        { ""jam"", ""application/vnd.jam""},
        { ""jar"", ""application/java-archive""},
        { ""java"", ""text/x-java-source""},
        { ""jfif"", ""image/pipeg""},
        { ""jisp"", ""application/vnd.jisp""},
        { ""jlt"", ""application/vnd.hp-jlyt""},
        { ""jnlp"", ""application/x-java-jnlp-file""},
        { ""joda"", ""application/vnd.joost.joda-archive""},
        { ""jpeg"", ""image/jpeg""},
        { ""jpe"", ""image/jpeg""},
        { ""jpg"", ""image/jpeg""},
        { ""jpgm"", ""video/jpm""},
        { ""jpgv"", ""video/jpeg""},
        { ""jpm"", ""video/jpm""},
        { ""js"", ""application/x-javascript""},
        { ""json"", ""application/json""},
        { ""kar"", ""audio/midi""},
        { ""karbon"", ""application/vnd.kde.karbon""},
        { ""kfo"", ""application/vnd.kde.kformula""},
        { ""kia"", ""application/vnd.kidspiration""},
        { ""kil"", ""application/x-killustrator""},
        { ""kml"", ""application/vnd.google-earth.kml+xml""},
        { ""kmz"", ""application/vnd.google-earth.kmz""},
        { ""kne"", ""application/vnd.kinar""},
        { ""knp"", ""application/vnd.kinar""},
        { ""kon"", ""application/vnd.kde.kontour""},
        { ""kpr"", ""application/vnd.kde.kpresenter""},
        { ""kpt"", ""application/vnd.kde.kpresenter""},
        { ""ksh"", ""text/plain""},
        { ""ksp"", ""application/vnd.kde.kspread""},
        { ""ktr"", ""application/vnd.kahootz""},
        { ""ktz"", ""application/vnd.kahootz""},
        { ""kwd"", ""application/vnd.kde.kword""},
        { ""kwt"", ""application/vnd.kde.kword""},
        { ""latex"", ""application/x-latex""},
        { ""lbd"", ""application/vnd.llamagraphics.life-balance.desktop""},
        { ""lbe"", ""application/vnd.llamagraphics.life-balance.exchange+xml""},
        { ""les"", ""application/vnd.hhe.lesson-player""},
        { ""lha"", ""application/octet-stream""},
        { ""link66"", ""application/vnd.route66.link66+xml""},
        { ""list3820"", ""application/vnd.ibm.modcap""},
        { ""listafp"", ""application/vnd.ibm.modcap""},
        { ""list"", ""text/plain""},
        { ""log"", ""text/plain""},
        { ""lostxml"", ""application/lost+xml""},
        { ""lrf"", ""application/octet-stream""},
        { ""lrm"", ""application/vnd.ms-lrm""},
        { ""lsf"", ""video/x-la-asf""},
        { ""lsx"", ""video/x-la-asf""},
        { ""ltf"", ""application/vnd.frogans.ltf""},
        { ""lvp"", ""audio/vnd.lucent.voice""},
        { ""lwp"", ""application/vnd.lotus-wordpro""},
        { ""lzh"", ""application/octet-stream""},
        { ""m13"", ""application/x-msmediaview""},
        { ""m14"", ""application/x-msmediaview""},
        { ""m1v"", ""video/mpeg""},
        { ""m2a"", ""audio/mpeg""},
        { ""m2v"", ""video/mpeg""},
        { ""m3a"", ""audio/mpeg""},
        { ""m3u"", ""audio/x-mpegurl""},
        { ""m4u"", ""video/vnd.mpegurl""},
        { ""m4v"", ""video/x-m4v""},
        { ""ma"", ""application/mathematica""},
        { ""mag"", ""application/vnd.ecowin.chart""},
        { ""maker"", ""application/vnd.framemaker""},
        { ""man"", ""text/troff""},
        { ""mathml"", ""application/mathml+xml""},
        { ""mb"", ""application/mathematica""},
        { ""mbk"", ""application/vnd.mobius.mbk""},
        { ""mbox"", ""application/mbox""},
        { ""mc1"", ""application/vnd.medcalcdata""},
        { ""mcd"", ""application/vnd.mcd""},
        { ""mcurl"", ""text/vnd.curl.mcurl""},
        { ""mdb"", ""application/x-msaccess""},
        { ""mdi"", ""image/vnd.ms-modi""},
        { ""mesh"", ""model/mesh""},
        { ""me"", ""text/troff""},
        { ""mfm"", ""application/vnd.mfmp""},
        { ""mgz"", ""application/vnd.proteus.magazine""},
        { ""mht"", ""message/rfc822""},
        { ""mhtml"", ""message/rfc822""},
        { ""mid"", ""audio/midi""},
        { ""midi"", ""audio/midi""},
        { ""mif"", ""application/vnd.mif""},
        { ""mime"", ""message/rfc822""},
        { ""mj2"", ""video/mj2""},
        { ""mjp2"", ""video/mj2""},
        { ""mlp"", ""application/vnd.dolby.mlp""},
        { ""mmd"", ""application/vnd.chipnuts.karaoke-mmd""},
        { ""mmf"", ""application/vnd.smaf""},
        { ""mmr"", ""image/vnd.fujixerox.edmics-mmr""},
        { ""mny"", ""application/x-msmoney""},
        { ""mobi"", ""application/x-mobipocket-ebook""},
        { ""movie"", ""video/x-sgi-movie""},
        { ""mov"", ""video/quicktime""},
        { ""mp2a"", ""audio/mpeg""},
        { ""mp2"", ""video/mpeg""},
        { ""mp3"", ""audio/mpeg""},
        { ""mp4a"", ""audio/mp4""},
        { ""mp4s"", ""application/mp4""},
        { ""mp4"", ""video/mp4""},
        { ""mp4v"", ""video/mp4""},
        { ""mpa"", ""video/mpeg""},
        { ""mpc"", ""application/vnd.mophun.certificate""},
        { ""mpeg"", ""video/mpeg""},
        { ""mpe"", ""video/mpeg""},
        { ""mpg4"", ""video/mp4""},
        { ""mpga"", ""audio/mpeg""},
        { ""mpg"", ""video/mpeg""},
        { ""mpkg"", ""application/vnd.apple.installer+xml""},
        { ""mpm"", ""application/vnd.blueice.multipass""},
        { ""mpn"", ""application/vnd.mophun.application""},
        { ""mpp"", ""application/vnd.ms-project""},
        { ""mpt"", ""application/vnd.ms-project""},
        { ""mpv2"", ""video/mpeg""},
        { ""mpy"", ""application/vnd.ibm.minipay""},
        { ""mqy"", ""application/vnd.mobius.mqy""},
        { ""mrc"", ""application/marc""},
        { ""mscml"", ""application/mediaservercontrol+xml""},
        { ""mseed"", ""application/vnd.fdsn.mseed""},
        { ""mseq"", ""application/vnd.mseq""},
        { ""msf"", ""application/vnd.epson.msf""},
        { ""msh"", ""model/mesh""},
        { ""msi"", ""application/x-msdownload""},
        { ""ms"", ""text/troff""},
        { ""msty"", ""application/vnd.muvee.style""},
        { ""mts"", ""model/vnd.mts""},
        { ""mus"", ""application/vnd.musician""},
        { ""musicxml"", ""application/vnd.recordare.musicxml+xml""},
        { ""mvb"", ""application/x-msmediaview""},
        { ""mxf"", ""application/mxf""},
        { ""mxl"", ""application/vnd.recordare.musicxml""},
        { ""mxml"", ""application/xv+xml""},
        { ""mxs"", ""application/vnd.triscape.mxs""},
        { ""mxu"", ""video/vnd.mpegurl""},
        { ""nb"", ""application/mathematica""},
        { ""nc"", ""application/x-netcdf""},
        { ""ncx"", ""application/x-dtbncx+xml""},
        { ""n-gage"", ""application/vnd.nokia.n-gage.symbian.install""},
        { ""ngdat"", ""application/vnd.nokia.n-gage.data""},
        { ""nlu"", ""application/vnd.neurolanguage.nlu""},
        { ""nml"", ""application/vnd.enliven""},
        { ""nnd"", ""application/vnd.noblenet-directory""},
        { ""nns"", ""application/vnd.noblenet-sealer""},
        { ""nnw"", ""application/vnd.noblenet-web""},
        { ""npx"", ""image/vnd.net-fpx""},
        { ""nsf"", ""application/vnd.lotus-notes""},
        { ""nws"", ""message/rfc822""},
        { ""oa2"", ""application/vnd.fujitsu.oasys2""},
        { ""oa3"", ""application/vnd.fujitsu.oasys3""},
        { ""o"", ""application/octet-stream""},
        { ""oas"", ""application/vnd.fujitsu.oasys""},
        { ""obd"", ""application/x-msbinder""},
        { ""obj"", ""application/octet-stream""},
        { ""oda"", ""application/oda""},
        { ""odb"", ""application/vnd.oasis.opendocument.database""},
        { ""odc"", ""application/vnd.oasis.opendocument.chart""},
        { ""odf"", ""application/vnd.oasis.opendocument.formula""},
        { ""odft"", ""application/vnd.oasis.opendocument.formula-template""},
        { ""odg"", ""application/vnd.oasis.opendocument.graphics""},
        { ""odi"", ""application/vnd.oasis.opendocument.image""},
        { ""odp"", ""application/vnd.oasis.opendocument.presentation""},
        { ""ods"", ""application/vnd.oasis.opendocument.spreadsheet""},
        { ""odt"", ""application/vnd.oasis.opendocument.text""},
        { ""oga"", ""audio/ogg""},
        { ""ogg"", ""audio/ogg""},
        { ""ogv"", ""video/ogg""},
        { ""ogx"", ""application/ogg""},
        { ""onepkg"", ""application/onenote""},
        { ""onetmp"", ""application/onenote""},
        { ""onetoc2"", ""application/onenote""},
        { ""onetoc"", ""application/onenote""},
        { ""opf"", ""application/oebps-package+xml""},
        { ""oprc"", ""application/vnd.palm""},
        { ""org"", ""application/vnd.lotus-organizer""},
        { ""osf"", ""application/vnd.yamaha.openscoreformat""},
        { ""osfpvg"", ""application/vnd.yamaha.openscoreformat.osfpvg+xml""},
        { ""otc"", ""application/vnd.oasis.opendocument.chart-template""},
        { ""otf"", ""application/x-font-otf""},
        { ""otg"", ""application/vnd.oasis.opendocument.graphics-template""},
        { ""oth"", ""application/vnd.oasis.opendocument.text-web""},
        { ""oti"", ""application/vnd.oasis.opendocument.image-template""},
        { ""otm"", ""application/vnd.oasis.opendocument.text-master""},
        { ""otp"", ""application/vnd.oasis.opendocument.presentation-template""},
        { ""ots"", ""application/vnd.oasis.opendocument.spreadsheet-template""},
        { ""ott"", ""application/vnd.oasis.opendocument.text-template""},
        { ""oxt"", ""application/vnd.openofficeorg.extension""},
        { ""p10"", ""application/pkcs10""},
        { ""p12"", ""application/x-pkcs12""},
        { ""p7b"", ""application/x-pkcs7-certificates""},
        { ""p7c"", ""application/x-pkcs7-mime""},
        { ""p7m"", ""application/x-pkcs7-mime""},
        { ""p7r"", ""application/x-pkcs7-certreqresp""},
        { ""p7s"", ""application/x-pkcs7-signature""},
        { ""pas"", ""text/x-pascal""},
        { ""pbd"", ""application/vnd.powerbuilder6""},
        { ""pbm"", ""image/x-portable-bitmap""},
        { ""pcf"", ""application/x-font-pcf""},
        { ""pcl"", ""application/vnd.hp-pcl""},
        { ""pclxl"", ""application/vnd.hp-pclxl""},
        { ""pct"", ""image/x-pict""},
        { ""pcurl"", ""application/vnd.curl.pcurl""},
        { ""pcx"", ""image/x-pcx""},
        { ""pdb"", ""application/vnd.palm""},
        { ""pdf"", ""application/pdf""},
        { ""pfa"", ""application/x-font-type1""},
        { ""pfb"", ""application/x-font-type1""},
        { ""pfm"", ""application/x-font-type1""},
        { ""pfr"", ""application/font-tdpfr""},
        { ""pfx"", ""application/x-pkcs12""},
        { ""pgm"", ""image/x-portable-graymap""},
        { ""pgn"", ""application/x-chess-pgn""},
        { ""pgp"", ""application/pgp-encrypted""},
        { ""pic"", ""image/x-pict""},
        { ""pkg"", ""application/octet-stream""},
        { ""pki"", ""application/pkixcmp""},
        { ""pkipath"", ""application/pkix-pkipath""},
        { ""pko"", ""application/ynd.ms-pkipko""},
        { ""plb"", ""application/vnd.3gpp.pic-bw-large""},
        { ""plc"", ""application/vnd.mobius.plc""},
        { ""plf"", ""application/vnd.pocketlearn""},
        { ""pls"", ""application/pls+xml""},
        { ""pl"", ""text/plain""},
        { ""pma"", ""application/x-perfmon""},
        { ""pmc"", ""application/x-perfmon""},
        { ""pml"", ""application/x-perfmon""},
        { ""pmr"", ""application/x-perfmon""},
        { ""pmw"", ""application/x-perfmon""},
        { ""png"", ""image/png""},
        { ""pnm"", ""image/x-portable-anymap""},
        { ""portpkg"", ""application/vnd.macports.portpkg""},
        { ""pot,"", ""application/vnd.ms-powerpoint""},
        { ""pot"", ""application/vnd.ms-powerpoint""},
        { ""potm"", ""application/vnd.ms-powerpoint.template.macroenabled.12""},
        { ""potx"", ""application/vnd.openxmlformats-officedocument.presentationml.template""},
        { ""ppa"", ""application/vnd.ms-powerpoint""},
        { ""ppam"", ""application/vnd.ms-powerpoint.addin.macroenabled.12""},
        { ""ppd"", ""application/vnd.cups-ppd""},
        { ""ppm"", ""image/x-portable-pixmap""},
        { ""pps"", ""application/vnd.ms-powerpoint""},
        { ""ppsm"", ""application/vnd.ms-powerpoint.slideshow.macroenabled.12""},
        { ""ppsx"", ""application/vnd.openxmlformats-officedocument.presentationml.slideshow""},
        { ""ppt"", ""application/vnd.ms-powerpoint""},
        { ""pptm"", ""application/vnd.ms-powerpoint.presentation.macroenabled.12""},
        { ""pptx"", ""application/vnd.openxmlformats-officedocument.presentationml.presentation""},
        { ""pqa"", ""application/vnd.palm""},
        { ""prc"", ""application/x-mobipocket-ebook""},
        { ""pre"", ""application/vnd.lotus-freelance""},
        { ""prf"", ""application/pics-rules""},
        { ""ps"", ""application/postscript""},
        { ""psb"", ""application/vnd.3gpp.pic-bw-small""},
        { ""psd"", ""image/vnd.adobe.photoshop""},
        { ""psf"", ""application/x-font-linux-psf""},
        { ""p"", ""text/x-pascal""},
        { ""ptid"", ""application/vnd.pvi.ptid1""},
        { ""pub"", ""application/x-mspublisher""},
        { ""pvb"", ""application/vnd.3gpp.pic-bw-var""},
        { ""pwn"", ""application/vnd.3m.post-it-notes""},
        { ""pwz"", ""application/vnd.ms-powerpoint""},
        { ""pya"", ""audio/vnd.ms-playready.media.pya""},
        { ""pyc"", ""application/x-python-code""},
        { ""pyo"", ""application/x-python-code""},
        { ""py"", ""text/x-python""},
        { ""pyv"", ""video/vnd.ms-playready.media.pyv""},
        { ""qam"", ""application/vnd.epson.quickanime""},
        { ""qbo"", ""application/vnd.intu.qbo""},
        { ""qfx"", ""application/vnd.intu.qfx""},
        { ""qps"", ""application/vnd.publishare-delta-tree""},
        { ""qt"", ""video/quicktime""},
        { ""qwd"", ""application/vnd.quark.quarkxpress""},
        { ""qwt"", ""application/vnd.quark.quarkxpress""},
        { ""qxb"", ""application/vnd.quark.quarkxpress""},
        { ""qxd"", ""application/vnd.quark.quarkxpress""},
        { ""qxl"", ""application/vnd.quark.quarkxpress""},
        { ""qxt"", ""application/vnd.quark.quarkxpress""},
        { ""ra"", ""audio/x-pn-realaudio""},
        { ""ram"", ""audio/x-pn-realaudio""},
        { ""rar"", ""application/x-rar-compressed""},
        { ""ras"", ""image/x-cmu-raster""},
        { ""rcprofile"", ""application/vnd.ipunplugged.rcprofile""},
        { ""rdf"", ""application/rdf+xml""},
        { ""rdz"", ""application/vnd.data-vision.rdz""},
        { ""rep"", ""application/vnd.businessobjects""},
        { ""res"", ""application/x-dtbresource+xml""},
        { ""rgb"", ""image/x-rgb""},
        { ""rif"", ""application/reginfo+xml""},
        { ""rl"", ""application/resource-lists+xml""},
        { ""rlc"", ""image/vnd.fujixerox.edmics-rlc""},
        { ""rld"", ""application/resource-lists-diff+xml""},
        { ""rm"", ""application/vnd.rn-realmedia""},
        { ""rmi"", ""audio/midi""},
        { ""rmp"", ""audio/x-pn-realaudio-plugin""},
        { ""rms"", ""application/vnd.jcp.javame.midlet-rms""},
        { ""rnc"", ""application/relax-ng-compact-syntax""},
        { ""roff"", ""text/troff""},
        { ""rpm"", ""application/x-rpm""},
        { ""rpss"", ""application/vnd.nokia.radio-presets""},
        { ""rpst"", ""application/vnd.nokia.radio-preset""},
        { ""rq"", ""application/sparql-query""},
        { ""rs"", ""application/rls-services+xml""},
        { ""rsd"", ""application/rsd+xml""},
        { ""rss"", ""application/rss+xml""},
        { ""rtf"", ""application/rtf""},
        { ""rtx"", ""text/richtext""},
        { ""saf"", ""application/vnd.yamaha.smaf-audio""},
        { ""sbml"", ""application/sbml+xml""},
        { ""sc"", ""application/vnd.ibm.secure-container""},
        { ""scd"", ""application/x-msschedule""},
        { ""scm"", ""application/vnd.lotus-screencam""},
        { ""scq"", ""application/scvp-cv-request""},
        { ""scs"", ""application/scvp-cv-response""},
        { ""sct"", ""text/scriptlet""},
        { ""scurl"", ""text/vnd.curl.scurl""},
        { ""sda"", ""application/vnd.stardivision.draw""},
        { ""sdc"", ""application/vnd.stardivision.calc""},
        { ""sdd"", ""application/vnd.stardivision.impress""},
        { ""sdkd"", ""application/vnd.solent.sdkm+xml""},
        { ""sdkm"", ""application/vnd.solent.sdkm+xml""},
        { ""sdp"", ""application/sdp""},
        { ""sdw"", ""application/vnd.stardivision.writer""},
        { ""see"", ""application/vnd.seemail""},
        { ""seed"", ""application/vnd.fdsn.seed""},
        { ""sema"", ""application/vnd.sema""},
        { ""semd"", ""application/vnd.semd""},
        { ""semf"", ""application/vnd.semf""},
        { ""ser"", ""application/java-serialized-object""},
        { ""setpay"", ""application/set-payment-initiation""},
        { ""setreg"", ""application/set-registration-initiation""},
        { ""sfd-hdstx"", ""application/vnd.hydrostatix.sof-data""},
        { ""sfs"", ""application/vnd.spotfire.sfs""},
        { ""sgl"", ""application/vnd.stardivision.writer-global""},
        { ""sgml"", ""text/sgml""},
        { ""sgm"", ""text/sgml""},
        { ""sh"", ""application/x-sh""},
        { ""shar"", ""application/x-shar""},
        { ""shf"", ""application/shf+xml""},
        { ""sic"", ""application/vnd.wap.sic""},
        { ""sig"", ""application/pgp-signature""},
        { ""silo"", ""model/mesh""},
        { ""sis"", ""application/vnd.symbian.install""},
        { ""sisx"", ""application/vnd.symbian.install""},
        { ""sit"", ""application/x-stuffit""},
        { ""si"", ""text/vnd.wap.si""},
        { ""sitx"", ""application/x-stuffitx""},
        { ""skd"", ""application/vnd.koan""},
        { ""skm"", ""application/vnd.koan""},
        { ""skp"", ""application/vnd.koan""},
        { ""skt"", ""application/vnd.koan""},
        { ""slc"", ""application/vnd.wap.slc""},
        { ""sldm"", ""application/vnd.ms-powerpoint.slide.macroenabled.12""},
        { ""sldx"", ""application/vnd.openxmlformats-officedocument.presentationml.slide""},
        { ""slt"", ""application/vnd.epson.salt""},
        { ""sl"", ""text/vnd.wap.sl""},
        { ""smf"", ""application/vnd.stardivision.math""},
        { ""smi"", ""application/smil+xml""},
        { ""smil"", ""application/smil+xml""},
        { ""snd"", ""audio/basic""},
        { ""snf"", ""application/x-font-snf""},
        { ""so"", ""application/octet-stream""},
        { ""spc"", ""application/x-pkcs7-certificates""},
        { ""spf"", ""application/vnd.yamaha.smaf-phrase""},
        { ""spl"", ""application/x-futuresplash""},
        { ""spot"", ""text/vnd.in3d.spot""},
        { ""spp"", ""application/scvp-vp-response""},
        { ""spq"", ""application/scvp-vp-request""},
        { ""spx"", ""audio/ogg""},
        { ""src"", ""application/x-wais-source""},
        { ""srx"", ""application/sparql-results+xml""},
        { ""sse"", ""application/vnd.kodak-descriptor""},
        { ""ssf"", ""application/vnd.epson.ssf""},
        { ""ssml"", ""application/ssml+xml""},
        { ""sst"", ""application/vnd.ms-pkicertstore""},
        { ""stc"", ""application/vnd.sun.xml.calc.template""},
        { ""std"", ""application/vnd.sun.xml.draw.template""},
        { ""s"", ""text/x-asm""},
        { ""stf"", ""application/vnd.wt.stf""},
        { ""sti"", ""application/vnd.sun.xml.impress.template""},
        { ""stk"", ""application/hyperstudio""},
        { ""stl"", ""application/vnd.ms-pki.stl""},
        { ""stm"", ""text/html""},
        { ""str"", ""application/vnd.pg.format""},
        { ""stw"", ""application/vnd.sun.xml.writer.template""},
        { ""sus"", ""application/vnd.sus-calendar""},
        { ""susp"", ""application/vnd.sus-calendar""},
        { ""sv4cpio"", ""application/x-sv4cpio""},
        { ""sv4crc"", ""application/x-sv4crc""},
        { ""svd"", ""application/vnd.svd""},
        { ""svg"", ""image/svg+xml""},
        { ""svgz"", ""image/svg+xml""},
        { ""swa"", ""application/x-director""},
        { ""swf"", ""application/x-shockwave-flash""},
        { ""swi"", ""application/vnd.arastra.swi""},
        { ""sxc"", ""application/vnd.sun.xml.calc""},
        { ""sxd"", ""application/vnd.sun.xml.draw""},
        { ""sxg"", ""application/vnd.sun.xml.writer.global""},
        { ""sxi"", ""application/vnd.sun.xml.impress""},
        { ""sxm"", ""application/vnd.sun.xml.math""},
        { ""sxw"", ""application/vnd.sun.xml.writer""},
        { ""tao"", ""application/vnd.tao.intent-module-archive""},
        { ""t"", ""application/x-troff""},
        { ""tar"", ""application/x-tar""},
        { ""tcap"", ""application/vnd.3gpp2.tcap""},
        { ""tcl"", ""application/x-tcl""},
        { ""teacher"", ""application/vnd.smart.teacher""},
        { ""tex"", ""application/x-tex""},
        { ""texi"", ""application/x-texinfo""},
        { ""texinfo"", ""application/x-texinfo""},
        { ""text"", ""text/plain""},
        { ""tfm"", ""application/x-tex-tfm""},
        { ""tgz"", ""application/x-gzip""},
        { ""tiff"", ""image/tiff""},
        { ""tif"", ""image/tiff""},
        { ""tmo"", ""application/vnd.tmobile-livetv""},
        { ""torrent"", ""application/x-bittorrent""},
        { ""tpl"", ""application/vnd.groove-tool-template""},
        { ""tpt"", ""application/vnd.trid.tpt""},
        { ""tra"", ""application/vnd.trueapp""},
        { ""trm"", ""application/x-msterminal""},
        { ""tr"", ""text/troff""},
        { ""tsv"", ""text/tab-separated-values""},
        { ""ttc"", ""application/x-font-ttf""},
        { ""ttf"", ""application/x-font-ttf""},
        { ""twd"", ""application/vnd.simtech-mindmapper""},
        { ""twds"", ""application/vnd.simtech-mindmapper""},
        { ""txd"", ""application/vnd.genomatix.tuxedo""},
        { ""txf"", ""application/vnd.mobius.txf""},
        { ""txt"", ""text/plain""},
        { ""u32"", ""application/x-authorware-bin""},
        { ""udeb"", ""application/x-debian-package""},
        { ""ufd"", ""application/vnd.ufdl""},
        { ""ufdl"", ""application/vnd.ufdl""},
        { ""uls"", ""text/iuls""},
        { ""umj"", ""application/vnd.umajin""},
        { ""unityweb"", ""application/vnd.unity""},
        { ""uoml"", ""application/vnd.uoml+xml""},
        { ""uris"", ""text/uri-list""},
        { ""uri"", ""text/uri-list""},
        { ""urls"", ""text/uri-list""},
        { ""ustar"", ""application/x-ustar""},
        { ""utz"", ""application/vnd.uiq.theme""},
        { ""uu"", ""text/x-uuencode""},
        { ""vcd"", ""application/x-cdlink""},
        { ""vcf"", ""text/x-vcard""},
        { ""vcg"", ""application/vnd.groove-vcard""},
        { ""vcs"", ""text/x-vcalendar""},
        { ""vcx"", ""application/vnd.vcx""},
        { ""vis"", ""application/vnd.visionary""},
        { ""viv"", ""video/vnd.vivo""},
        { ""vor"", ""application/vnd.stardivision.writer""},
        { ""vox"", ""application/x-authorware-bin""},
        { ""vrml"", ""x-world/x-vrml""},
        { ""vsd"", ""application/vnd.visio""},
        { ""vsf"", ""application/vnd.vsf""},
        { ""vss"", ""application/vnd.visio""},
        { ""vst"", ""application/vnd.visio""},
        { ""vsw"", ""application/vnd.visio""},
        { ""vtu"", ""model/vnd.vtu""},
        { ""vxml"", ""application/voicexml+xml""},
        { ""w3d"", ""application/x-director""},
        { ""wad"", ""application/x-doom""},
        { ""wav"", ""audio/x-wav""},
        { ""wax"", ""audio/x-ms-wax""},
        { ""wbmp"", ""image/vnd.wap.wbmp""},
        { ""wbs"", ""application/vnd.criticaltools.wbs+xml""},
        { ""wbxml"", ""application/vnd.wap.wbxml""},
        { ""wcm"", ""application/vnd.ms-works""},
        { ""wdb"", ""application/vnd.ms-works""},
        { ""wiz"", ""application/msword""},
        { ""wks"", ""application/vnd.ms-works""},
        { ""wma"", ""audio/x-ms-wma""},
        { ""wmd"", ""application/x-ms-wmd""},
        { ""wmf"", ""application/x-msmetafile""},
        { ""wmlc"", ""application/vnd.wap.wmlc""},
        { ""wmlsc"", ""application/vnd.wap.wmlscriptc""},
        { ""wmls"", ""text/vnd.wap.wmlscript""},
        { ""wml"", ""text/vnd.wap.wml""},
        { ""wm"", ""video/x-ms-wm""},
        { ""wmv"", ""video/x-ms-wmv""},
        { ""wmx"", ""video/x-ms-wmx""},
        { ""wmz"", ""application/x-ms-wmz""},
        { ""wpd"", ""application/vnd.wordperfect""},
        { ""wpl"", ""application/vnd.ms-wpl""},
        { ""wps"", ""application/vnd.ms-works""},
        { ""wqd"", ""application/vnd.wqd""},
        { ""wri"", ""application/x-mswrite""},
        { ""wrl"", ""x-world/x-vrml""},
        { ""wrz"", ""x-world/x-vrml""},
        { ""wsdl"", ""application/wsdl+xml""},
        { ""wspolicy"", ""application/wspolicy+xml""},
        { ""wtb"", ""application/vnd.webturbo""},
        { ""wvx"", ""video/x-ms-wvx""},
        { ""x32"", ""application/x-authorware-bin""},
        { ""x3d"", ""application/vnd.hzn-3d-crossword""},
        { ""xaf"", ""x-world/x-vrml""},
        { ""xap"", ""application/x-silverlight-app""},
        { ""xar"", ""application/vnd.xara""},
        { ""xbap"", ""application/x-ms-xbap""},
        { ""xbd"", ""application/vnd.fujixerox.docuworks.binder""},
        { ""xbm"", ""image/x-xbitmap""},
        { ""xdm"", ""application/vnd.syncml.dm+xml""},
        { ""xdp"", ""application/vnd.adobe.xdp+xml""},
        { ""xdw"", ""application/vnd.fujixerox.docuworks""},
        { ""xenc"", ""application/xenc+xml""},
        { ""xer"", ""application/patch-ops-error+xml""},
        { ""xfdf"", ""application/vnd.adobe.xfdf""},
        { ""xfdl"", ""application/vnd.xfdl""},
        { ""xht"", ""application/xhtml+xml""},
        { ""xhtml"", ""application/xhtml+xml""},
        { ""xhvml"", ""application/xv+xml""},
        { ""xif"", ""image/vnd.xiff""},
        { ""xla"", ""application/vnd.ms-excel""},
        { ""xlam"", ""application/vnd.ms-excel.addin.macroenabled.12""},
        { ""xlb"", ""application/vnd.ms-excel""},
        { ""xlc"", ""application/vnd.ms-excel""},
        { ""xlm"", ""application/vnd.ms-excel""},
        { ""xls"", ""application/vnd.ms-excel""},
        { ""xlsb"", ""application/vnd.ms-excel.sheet.binary.macroenabled.12""},
        { ""xlsm"", ""application/vnd.ms-excel.sheet.macroenabled.12""},
        { ""xlsx"", ""application/vnd.openxmlformats-officedocument.spreadsheetml.sheet""},
        { ""xlt"", ""application/vnd.ms-excel""},
        { ""xltm"", ""application/vnd.ms-excel.template.macroenabled.12""},
        { ""xltx"", ""application/vnd.openxmlformats-officedocument.spreadsheetml.template""},
        { ""xlw"", ""application/vnd.ms-excel""},
        { ""xml"", ""application/xml""},
        { ""xo"", ""application/vnd.olpc-sugar""},
        { ""xof"", ""x-world/x-vrml""},
        { ""xop"", ""application/xop+xml""},
        { ""xpdl"", ""application/xml""},
        { ""xpi"", ""application/x-xpinstall""},
        { ""xpm"", ""image/x-xpixmap""},
        { ""xpr"", ""application/vnd.is-xpr""},
        { ""xps"", ""application/vnd.ms-xpsdocument""},
        { ""xpw"", ""application/vnd.intercon.formnet""},
        { ""xpx"", ""application/vnd.intercon.formnet""},
        { ""xsl"", ""application/xml""},
        { ""xslt"", ""application/xslt+xml""},
        { ""xsm"", ""application/vnd.syncml+xml""},
        { ""xspf"", ""application/xspf+xml""},
        { ""xul"", ""application/vnd.mozilla.xul+xml""},
        { ""xvm"", ""application/xv+xml""},
        { ""xvml"", ""application/xv+xml""},
        { ""xwd"", ""image/x-xwindowdump""},
        { ""xyz"", ""chemical/x-xyz""},
        { ""z"", ""application/x-compress""},
        { ""zaz"", ""application/vnd.zzazz.deck+xml""},
        { ""zip"", ""application/zip""},
        { ""zir"", ""application/vnd.zul""},
        { ""zirz"", ""application/vnd.zul""},
        { ""zmm"", ""application/vnd.handheld-entertainment+xml""}
    };

    /**
     * Table for MIME type replacements.
     *
     * Table format: wrong type, correct type
     */
    private static final String[][] MIME_TYPE_REPLACEMENT_MAP = new String[][] {
        {""image/jpg"", ""image/jpeg""}
    };

    public static String unfold(String s) {
        if (s == null) {
            return null;
        }
        return s.replaceAll(""\r|\n"", """");
    }

    public static String decode(String s) {
        return decode(s, null);
    }

    public static String decode(String s, Message message) {
        if (s == null) {
            return null;
        }

        return DecoderUtil.decodeEncodedWords(s, message);
    }

    public static String unfoldAndDecode(String s) {
        return unfoldAndDecode(s, null);
    }

    public static String unfoldAndDecode(String s, Message message) {
        return decode(unfold(s), message);
    }

    // TODO implement proper foldAndEncode
    public static String foldAndEncode(String s) {
        return s;
    }

    /**
     * Returns the named parameter of a header field. If name is null the first
     * parameter is returned, or if there are no additional parameters in the
     * field the entire field is returned. Otherwise the named parameter is
     * searched for in a case insensitive fashion and returned. If the parameter
     * cannot be found the method returns null.
     *
     * @param header
     * @param name
     * @return
     */
    public static String getHeaderParameter(String header, String name) {
        if (header == null) {
            return null;
        }
        header = header.replaceAll(""\r|\n"", """");
        String[] parts = header.split("";"");
        if (name == null) {
            return parts[0];
        }
        for (String part : parts) {
            if (part.trim().toLowerCase().startsWith(name.toLowerCase())) {
                String parameter = part.split(""="", 2)[1].trim();
                if (parameter.startsWith(""\"""") && parameter.endsWith(""\"""")) {
                    return parameter.substring(1, parameter.length() - 1);
                } else {
                    return parameter;
                }
            }
        }
        return null;
    }

    public static Part findFirstPartByMimeType(Part part, String mimeType)
    throws MessagingException {
        if (part.getBody() instanceof Multipart) {
            Multipart multipart = (Multipart)part.getBody();
            for (int i = 0, count = multipart.getCount(); i < count; i++) {
                BodyPart bodyPart = multipart.getBodyPart(i);
                Part ret = findFirstPartByMimeType(bodyPart, mimeType);
                if (ret != null) {
                    return ret;
                }
            }
        } else if (part.getMimeType().equalsIgnoreCase(mimeType)) {
            return part;
        }
        return null;
    }

    public static Part findPartByContentId(Part part, String contentId) throws Exception {
        if (part.getBody() instanceof Multipart) {
            Multipart multipart = (Multipart)part.getBody();
            for (int i = 0, count = multipart.getCount(); i < count; i++) {
                BodyPart bodyPart = multipart.getBodyPart(i);
                Part ret = findPartByContentId(bodyPart, contentId);
                if (ret != null) {
                    return ret;
                }
            }
        }
        String[] header = part.getHeader(""Content-ID"");
        if (header != null) {
            for (String s : header) {
                if (s.equals(contentId)) {
                    return part;
                }
            }
        }
        return null;
    }

    /**
      * Reads the Part's body and returns a String based on any charset conversion that needed
      * to be done.  Note, this <b>does not</b> return a text representation of HTML.
      * @param part The part containing a body
      * @return a String containing the converted text in the body, or null if there was no text
      * or an error during conversion.
      */
    public static String getTextFromPart(Part part) {
        try {
            if ((part != null) && (part.getBody() != null)) {
                final Body body = part.getBody();
                if (body instanceof TextBody) {
                    return ((TextBody)body).getText();
                }

                final String mimeType = part.getMimeType();
                if ((mimeType != null) && MimeUtility.mimeTypeMatches(mimeType, ""text/*"")) {
                    /*
                     * We've got a text part, so let's see if it needs to be processed further.
                     */
                    String charset = getHeaderParameter(part.getContentType(), ""charset"");
                    charset = fixupCharset(charset, getMessageFromPart(part));

                    /*
                     * Now we read the part into a buffer for further processing. Because
                     * the stream is now wrapped we'll remove any transfer encoding at this point.
                     */
                    InputStream in = part.getBody().getInputStream();
                    return readToString(in, charset);
                }
            }

        } catch (OutOfMemoryError oom) {
            /*
             * If we are not able to process the body there's nothing we can do about it. Return
             * null and let the upper layers handle the missing content.
             */
            Log.e(K9.LOG_TAG, ""Unable to getTextFromPart "" + oom.toString());
        } catch (Exception e) {
            /*
             * If we are not able to process the body there's nothing we can do about it. Return
             * null and let the upper layers handle the missing content.
             */
            Log.e(K9.LOG_TAG, ""Unable to getTextFromPart"", e);
        }
        return null;
    }

    /**
     * Returns true if the given mimeType matches the matchAgainst specification.
     * @param mimeType A MIME type to check.
     * @param matchAgainst A MIME type to check against. May include wildcards such as image/* or
     * * /*.
     * @return
     */
    public static boolean mimeTypeMatches(String mimeType, String matchAgainst) {
        Pattern p = Pattern.compile(matchAgainst.replaceAll(""\\*"", ""\\.\\*""), Pattern.CASE_INSENSITIVE);
        return p.matcher(mimeType).matches();
    }

    /**
     * Returns true if the given mimeType matches any of the matchAgainst specifications.
     * @param mimeType A MIME type to check.
     * @param matchAgainst An array of MIME types to check against. May include wildcards such
     * as image/* or * /*.
     * @return
     */
    public static boolean mimeTypeMatches(String mimeType, String[] matchAgainst) {
        for (String matchType : matchAgainst) {
            if (mimeTypeMatches(mimeType, matchType)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Removes any content transfer encoding from the stream and returns a Body.
     */
    public static Body decodeBody(InputStream in, String contentTransferEncoding)
    throws IOException {
        /*
         * We'll remove any transfer encoding by wrapping the stream.
         */
        if (contentTransferEncoding != null) {
            contentTransferEncoding =
            MimeUtility.getHeaderParameter(contentTransferEncoding, null);
            if (""quoted-printable"".equalsIgnoreCase(contentTransferEncoding)) {
                in = new QuotedPrintableInputStream(in);
            } else if (""base64"".equalsIgnoreCase(contentTransferEncoding)) {
                in = new Base64InputStream(in);
            }
        }

        BinaryTempFileBody tempBody = new BinaryTempFileBody();
        OutputStream out = tempBody.getOutputStream();
        IOUtils.copy(in, out);
        out.close();
        return tempBody;
    }

    /**
     * An unfortunately named method that makes decisions about a Part (usually a Message)
     * as to which of it's children will be ""viewable"" and which will be attachments.
     * The method recursively sorts the viewables and attachments into seperate
     * lists for further processing.
     * @param part
     * @param viewables
     * @param attachments
     * @throws MessagingException
     */
    public static void collectParts(Part part, ArrayList<Part> viewables,
    ArrayList<Part> attachments) throws MessagingException {
        /*
         * If the part is Multipart but not alternative it's either mixed or
         * something we don't know about, which means we treat it as mixed
         * per the spec. We just process it's pieces recursively.
         */
        if (part.getBody() instanceof Multipart) {
            Multipart mp = (Multipart)part.getBody();
            for (int i = 0; i < mp.getCount(); i++) {
                collectParts(mp.getBodyPart(i), viewables, attachments);
            }
        }
        /*
         * If the part is an embedded message we just continue to process
         * it, pulling any viewables or attachments into the running list.
         */
        else if (part.getBody() instanceof Message) {
            Message message = (Message)part.getBody();
            collectParts(message, viewables, attachments);
        }
        /*
         * If the part is HTML and it got this far it's part of a mixed (et
         * al) and should be rendered inline.
         */
        else if (isPartTextualBody(part)) {
            viewables.add(part);
        } else {
            attachments.add(part);
        }

    }


    public static Boolean isPartTextualBody(Part part) throws MessagingException {
        String disposition = part.getDisposition();
        String dispositionType = null;
        String dispositionFilename = null;
        if (disposition != null) {
            dispositionType = MimeUtility.getHeaderParameter(disposition, null);
            dispositionFilename = MimeUtility.getHeaderParameter(disposition, ""filename"");
        }

        /*
         * A best guess that this part is intended to be an attachment and not inline.
         */
        boolean attachment = (""attachment"".equalsIgnoreCase(dispositionType) || (dispositionFilename != null));

        if ((!attachment) && (part.getMimeType().equalsIgnoreCase(""text/html""))) {
            return true;
        }
        /*
         * If the part is plain text and it got this far it's part of a
         * mixed (et al) and should be rendered inline.
         */
        else if ((!attachment) && (part.getMimeType().equalsIgnoreCase(""text/plain""))) {
            return true;
        }
        /*
         * Finally, if it's nothing else we will include it as an attachment.
         */
        else {
            return false;
        }
    }

    public static String getCharsetFromAddress(String address) {
        String variant = getJisVariantFromAddress(address);
        if (variant != null) {
            String charset = ""x-"" + variant + ""-shift_jis-2007"";
            if (Charset.isSupported(charset))
                return charset;
        }

        return ""UTF-8"";
    }

    public static String getMimeTypeByExtension(String filename) {
        String returnedType = null;
        String extension = null;

        if (filename != null && filename.lastIndexOf('.') != -1) {
            extension = filename.substring(filename.lastIndexOf('.') + 1).toLowerCase();
            returnedType = android.webkit.MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
        }
        // If the MIME type set by the user's mailer is application/octet-stream, try to figure
        // out whether there's a sane file type extension.
        if (returnedType != null && !DEFAULT_ATTACHMENT_MIME_TYPE.equalsIgnoreCase(returnedType)) {
            return returnedType;
        } else if (extension != null) {
            for (String[] contentTypeMapEntry : MIME_TYPE_BY_EXTENSION_MAP) {
                if (contentTypeMapEntry[0].equals(extension)) {
                    return contentTypeMapEntry[1];
                }
            }
        }

        return DEFAULT_ATTACHMENT_MIME_TYPE;
    }

    /**
     * Convert some wrong MIME types encountered in the wild to canonical MIME
     * types.
     *
     * @param mimeType The original MIME type
     * @return If {@code mimeType} is known to be wrong the correct MIME type
     *         is returned. Otherwise the value of {@code mimeType} is returned
     *         unmodified.
     *
     * @see #MIME_TYPE_REPLACEMENT_MAP
     */
    public static String canonicalizeMimeType(String mimeType) {
        for (String[] mimeTypeMapEntry : MIME_TYPE_REPLACEMENT_MAP) {
            if (mimeTypeMapEntry[0].equals(mimeType)) {
                return mimeTypeMapEntry[1];
            }
        }
        return mimeType;
    }

    /**
     * When viewing the attachment we want the MIME type to be as sensible as
     * possible. So we fix it up if necessary.
     *
     * @param mimeType The original MIME type of the attachment.
     * @param name The (file)name of the attachment.
     *
     * @return The best MIME type we can come up with.
     */
    public static String getMimeTypeForViewing(String mimeType, String name) {
        if (DEFAULT_ATTACHMENT_MIME_TYPE.equalsIgnoreCase(mimeType)) {
            // If the MIME type is the generic ""application/octet-stream""
            // we try to find a better one by looking at the file extension.
            return getMimeTypeByExtension(name);
        } else {
            // Some messages contain wrong MIME types. See if we know better.
            return canonicalizeMimeType(mimeType);
        }
    }

    private static Message getMessageFromPart(Part part) {
        while (part != null) {
            if (part instanceof Message)
                return (Message)part;

            if (!(part instanceof BodyPart))
                return null;

            Multipart multipart = ((BodyPart)part).getParent();
            if (multipart == null)
                return null;

            part = multipart.getParent();
        }
        return null;
    }

    public static String fixupCharset(String charset, Message message) throws MessagingException {
        if (charset == null || ""0"".equals(charset))
            charset = ""US-ASCII"";  // No encoding, so use us-ascii, which is the standard.

        charset = charset.toLowerCase();
        if (charset.equals(""cp932""))
            charset = ""shift_jis"";
        else if (charset.equals(""koi8-u""))
            charset = ""koi8-r"";

        if (charset.equals(""shift_jis"") || charset.equals(""iso-2022-jp"")) {
            String variant = getJisVariantFromMessage(message);
            if (variant != null)
                charset = ""x-"" + variant + ""-"" + charset + ""-2007"";
        }
        return charset;
    }

    private static String getJisVariantFromMessage(Message message) throws MessagingException {
        if (message == null)
            return null;

        // If a receiver is known to use a JIS variant, the sender transfers the message after converting the
        // charset as a convention.
        String variant = getJisVariantFromReceivedHeaders(message);
        if (variant != null)
            return variant;

        // If a receiver is not known to use any JIS variants, the sender transfers the message without converting
        // the charset.
        variant = getJisVariantFromFromHeaders(message);
        if (variant != null)
            return variant;

        return getJisVariantFromMailerHeaders(message);
    }

    private static String getJisVariantFromReceivedHeaders(Message message) throws MessagingException {
        String receivedHeaders[] = message.getHeader(""Received"");
        if (receivedHeaders == null)
            return null;

        for (String receivedHeader : receivedHeaders) {
            String address = getAddressFromReceivedHeader(receivedHeader);
            if (address == null)
                continue;
            String variant = getJisVariantFromAddress(address);
            if (variant != null)
                return variant;
        }
        return null;
    }

    private static String getAddressFromReceivedHeader(String receivedHeader) {
        // Not implemented yet!  Extract an address from the FOR clause of the given Received header.
        return null;
    }

    private static String getJisVariantFromFromHeaders(Message message) throws MessagingException {
        Address addresses[] = message.getFrom();
        if (addresses == null || addresses.length == 0)
            return null;

        return getJisVariantFromAddress(addresses[0].getAddress());
    }

    private static String getJisVariantFromAddress(String address) {
        if (isInDomain(address, ""docomo.ne.jp"") || isInDomain(address, ""dwmail.jp"") ||
        isInDomain(address, ""pdx.ne.jp"") || isInDomain(address, ""willcom.com""))
            return ""docomo"";
        else if (isInDomain(address, ""softbank.ne.jp"") || isInDomain(address, ""vodafone.ne.jp"") ||
        isInDomain(address, ""disney.ne.jp"") || isInDomain(address, ""vertuclub.ne.jp""))
            return ""softbank"";
        else if (isInDomain(address, ""ezweb.ne.jp"") || isInDomain(address, ""ido.ne.jp""))
            return ""kddi"";
        return null;
    }

    private static boolean isInDomain(String address, String domain) {
        int index = address.length() - domain.length() - 1;
        if (index < 0)
            return false;

        char c = address.charAt(index);
        if (c != '@' && c != '.')
            return false;

        return address.endsWith(domain);
    }

    private static String getJisVariantFromMailerHeaders(Message message) throws MessagingException {
        String mailerHeaders[] = message.getHeader(""X-Mailer"");
        if (mailerHeaders == null || mailerHeaders.length == 0)
            return null;

        if (mailerHeaders[0].startsWith(""iPhone Mail "") || mailerHeaders[0].startsWith(""iPad Mail ""))
            return ""iphone"";

        return null;
    }

    public static String readToString(InputStream in, String charset) throws IOException {
        boolean isIphoneString = false;

        // iso-2022-jp variants are supported by no versions as of Dec 2010.
        if (charset.length() > 19 && charset.startsWith(""x-"") &&
        charset.endsWith(""-iso-2022-jp-2007"") && !Charset.isSupported(charset)) {
            in = new Iso2022JpToShiftJisInputStream(in);
            charset = ""x-"" + charset.substring(2, charset.length() - 17) + ""-shift_jis-2007"";
        }

        // shift_jis variants are supported by Eclair and later.
        if (charset.length() > 17 && charset.startsWith(""x-"") &&
        charset.endsWith(""-shift_jis-2007"") && !Charset.isSupported(charset)) {
            // If the JIS variant is iPhone, map the Unicode private use area in iPhone to the one in Android after
            // converting the character set from the standard Shift JIS to Unicode.
            if (charset.substring(2, charset.length() - 15).equals(""iphone""))
                isIphoneString = true;

            charset = ""shift_jis"";
        }

        /*
         * See if there is conversion from the MIME charset to the Java one.
         * this function may also throw an exception if the charset name is not known
         */
        boolean supported;
        try {
            supported = Charset.isSupported(charset);
        } catch (IllegalCharsetNameException e) {
            supported = false;
        }
        if (!supported) {
            Log.e(K9.LOG_TAG, ""I don't know how to deal with the charset "" + charset +
            "". Falling back to US-ASCII"");
            charset = ""US-ASCII"";
        }
        /*
         * Convert and return as new String
         */
        String str = IOUtils.toString(in, charset);

        if (isIphoneString)
            str = importStringFromIphone(str);
        return str;
    }

    static private String importStringFromIphone(String str) {
        StringBuilder buff = new StringBuilder(str.length());
        for (int i = 0; i < str.length(); i = str.offsetByCodePoints(i, 1)) {
            int codePoint = str.codePointAt(i);
            buff.appendCodePoint(importCodePointFromIphone(codePoint));
        }
        return buff.toString();
    }

    static private int importCodePointFromIphone(int codePoint) {
        switch (codePoint) {
        case 0xE001:
            return 0xFE19B;
        case 0xE002:
            return 0xFE19C;
        case 0xE003:
            return 0xFE823;
        case 0xE004:
            return 0xFE19D;
        case 0xE005:
            return 0xFE19E;
        case 0xE006:
            return 0xFE4CF;
        case 0xE007:
            return 0xFE4CD;
        case 0xE008:
            return 0xFE4EF;
        case 0xE009:
            return 0xFE523;
        case 0xE00A:
            return 0xFE525;
        case 0xE00B:
            return 0xFE528;
        case 0xE00C:
            return 0xFE538;
        case 0xE00D:
            return 0xFEB96;
        case 0xE00E:
            return 0xFEB97;
        case 0xE00F:
            return 0xFEB98;
        case 0xE010:
            return 0xFEB93;
        case 0xE011:
            return 0xFEB94;
        case 0xE012:
            return 0xFEB95;
        case 0xE013:
            return 0xFE7D5;
        case 0xE014:
            return 0xFE7D2;
        case 0xE015:
            return 0xFE7D3;
        case 0xE016:
            return 0xFE7D1;
        case 0xE017:
            return 0xFE7DA;
        case 0xE018:
            return 0xFE7D4;
        case 0xE019:
            return 0xFE1BD;
        case 0xE01A:
            return 0xFE1BE;
        case 0xE01B:
            return 0xFE7E4;
        case 0xE01C:
            return 0xFE7EA;
        case 0xE01D:
            return 0xFE7E9;
        case 0xE01E:
            return 0xFE7DF;
        case 0xE01F:
            return 0xFE7E3;
        case 0xE020:
            return 0xFEB09;
        case 0xE021:
            return 0xFEB04;
        case 0xE022:
            return 0xFEB0C;
        case 0xE023:
            return 0xFEB0E;
        case 0xE024:
            return 0xFE01E;
        case 0xE025:
            return 0xFE01F;
        case 0xE026:
            return 0xFE020;
        case 0xE027:
            return 0xFE021;
        case 0xE028:
            return 0xFE022;
        case 0xE029:
            return 0xFE023;
        case 0xE02A:
            return 0xFE024;
        case 0xE02B:
            return 0xFE025;
        case 0xE02C:
            return 0xFE026;
        case 0xE02D:
            return 0xFE027;
        case 0xE02E:
            return 0xFE028;
        case 0xE02F:
            return 0xFE029;
        case 0xE030:
            return 0xFE040;
        case 0xE031:
            return 0xFE4D2;
        case 0xE032:
            return 0xFE041;
        case 0xE033:
            return 0xFE512;
        case 0xE034:
            return 0xFE825;
        case 0xE035:
            return 0xFE826;
        case 0xE036:
            return 0xFE4B0;
        case 0xE037:
            return 0xFE4BB;
        case 0xE038:
            return 0xFE4B2;
        case 0xE039:
            return 0xFE7EC;
        case 0xE03A:
            return 0xFE7F5;
        case 0xE03B:
            return 0xFE4C3;
        case 0xE03C:
            return 0xFE800;
        case 0xE03D:
            return 0xFE801;
        case 0xE03E:
            return 0xFE813;
        case 0xE03F:
            return 0xFEB82;
        case 0xE040:
            return 0xFE815;
        case 0xE041:
            return 0xFE816;
        case 0xE042:
            return 0xFE818;
        case 0xE043:
            return 0xFE980;
        case 0xE044:
            return 0xFE982;
        case 0xE045:
            return 0xFE981;
        case 0xE046:
            return 0xFE962;
        case 0xE047:
            return 0xFE983;
        case 0xE048:
            return 0xFE003;
        case 0xE049:
            return 0xFE001;
        case 0xE04A:
            return 0xFE000;
        case 0xE04B:
            return 0xFE002;
        case 0xE04C:
            return 0xFE014;
        case 0xE04D:
            return 0xFE009;
        case 0xE04E:
            return 0xFE1AF;
        case 0xE04F:
            return 0xFE1B8;
        case 0xE050:
            return 0xFE1C0;
        case 0xE051:
            return 0xFE1C1;
        case 0xE052:
            return 0xFE1B7;
        case 0xE053:
            return 0xFE1C2;
        case 0xE054:
            return 0xFE1C3;
        case 0xE055:
            return 0xFE1BC;
        case 0xE056:
            return 0xFE335;
        case 0xE057:
            return 0xFE330;
        case 0xE058:
            return 0xFE323;
        case 0xE059:
            return 0xFE320;
        case 0xE05A:
            return 0xFE4F4;
        case 0xE101:
            return 0xFE52D;
        case 0xE102:
            return 0xFE52E;
        case 0xE103:
            return 0xFE52B;
        case 0xE104:
            return 0xFE526;
        case 0xE105:
            return 0xFE329;
        case 0xE106:
            return 0xFE327;
        case 0xE107:
            return 0xFE341;
        case 0xE108:
            return 0xFE344;
        case 0xE109:
            return 0xFE1C4;
        case 0xE10A:
            return 0xFE1C5;
        case 0xE10B:
            return 0xFE1BF;
        case 0xE10C:
            return 0xFE1B0;
        case 0xE10D:
            return 0xFE7ED;
        case 0xE10E:
            return 0xFE4D1;
        case 0xE10F:
            return 0xFEB56;
        case 0xE110:
            return 0xFE03C;
        case 0xE111:
            return 0xFE827;
        case 0xE112:
            return 0xFE510;
        case 0xE113:
            return 0xFE4F5;
        case 0xE114:
            return 0xFEB85;
        case 0xE115:
            return 0xFE7D9;
        case 0xE116:
            return 0xFE4CA;
        case 0xE117:
            return 0xFE515;
        case 0xE118:
            return 0xFE03F;
        case 0xE119:
            return 0xFE042;
        case 0xE11A:
            return 0xFE1B2;
        case 0xE11B:
            return 0xFE1AE;
        case 0xE11C:
            return 0xFE1B3;
        case 0xE11D:
            return 0xFE4F6;
        case 0xE11E:
            return 0xFE53B;
        case 0xE11F:
            return 0xFE537;
        case 0xE120:
            return 0xFE960;
        case 0xE121:
            return 0xFE4BC;
        case 0xE122:
            return 0xFE7FB;
        case 0xE123:
            return 0xFE7FA;
        case 0xE124:
            return 0xFE7FD;
        case 0xE125:
            return 0xFE807;
        case 0xE126:
            return 0xFE81D;
        case 0xE127:
            return 0xFE81E;
        case 0xE128:
            return 0xFE81F;
        case 0xE129:
            return 0xFE820;
        case 0xE12A:
            return 0xFE81C;
        case 0xE12B:
            return 0xFE1B1;
        case 0xE12C:
            return 0xFE81B;
        case 0xE12D:
            return 0xFE80B;
        case 0xE12E:
            return 0xFEB32;
        case 0xE12F:
            return 0xFE4DD;
        case 0xE130:
            return 0xFE80C;
        case 0xE131:
            return 0xFE7DB;
        case 0xE132:
            return 0xFE7D7;
        case 0xE133:
            return 0xFE80D;
        case 0xE134:
            return 0xFE7DC;
        case 0xE135:
            return 0xFE7EE;
        case 0xE136:
            return 0xFE7EB;
        case 0xE137:
            return 0xFE7F8;
        case 0xE138:
            return 0xFEB33;
        case 0xE139:
            return 0xFEB34;
        case 0xE13A:
            return 0xFEB35;
        case 0xE13B:
            return 0xFE509;
        case 0xE13C:
            return 0xFEB59;
        case 0xE13D:
            return 0xFE004;
        case 0xE13E:
            return 0xFE4D6;
        case 0xE13F:
            return 0xFE505;
        case 0xE140:
            return 0xFE507;
        case 0xE141:
            return 0xFE821;
        case 0xE142:
            return 0xFE52F;
        case 0xE143:
            return 0xFE514;
        case 0xE144:
            return 0xFEB86;
        case 0xE145:
            return 0xFEB87;
        case 0xE146:
            return 0xFE00B;
        case 0xE147:
            return 0xFE965;
        case 0xE148:
            return 0xFE546;
        case 0xE149:
            return 0xFE4DE;
        case 0xE14A:
            return 0xFE4DF;
        case 0xE14B:
            return 0xFE531;
        case 0xE14C:
            return 0xFEB5E;
        case 0xE14D:
            return 0xFE4B5;
        case 0xE14E:
            return 0xFE7F7;
        case 0xE14F:
            return 0xFE7F6;
        case 0xE150:
            return 0xFE7E7;
        case 0xE151:
            return 0xFE506;
        case 0xE152:
            return 0xFE1A1;
        case 0xE153:
            return 0xFE4B3;
        case 0xE154:
            return 0xFE4B6;
        case 0xE155:
            return 0xFE4B4;
        case 0xE156:
            return 0xFE4B9;
        case 0xE157:
            return 0xFE4BA;
        case 0xE158:
            return 0xFE4B7;
        case 0xE159:
            return 0xFE7E6;
        case 0xE15A:
            return 0xFE7EF;
        case 0xE201:
            return 0xFE7F0;
        case 0xE202:
            return 0xFE7E8;
        case 0xE203:
            return 0xFEB24;
        case 0xE204:
            return 0xFEB19;
        case 0xE205:
            return 0xFEB61;
        case 0xE206:
            return 0xFEB62;
        case 0xE207:
            return 0xFEB25;
        case 0xE208:
            return 0xFEB1F;
        case 0xE209:
            return 0xFE044;
        case 0xE20A:
            return 0xFEB20;
        case 0xE20B:
            return 0xFE838;
        case 0xE20C:
            return 0xFEB1A;
        case 0xE20D:
            return 0xFEB1C;
        case 0xE20E:
            return 0xFEB1B;
        case 0xE20F:
            return 0xFEB1D;
        case 0xE210:
            return 0xFE82C;
        case 0xE211:
            return 0xFE82B;
        case 0xE212:
            return 0xFEB36;
        case 0xE213:
            return 0xFEB37;
        case 0xE214:
            return 0xFEB38;
        case 0xE215:
            return 0xFEB39;
        case 0xE216:
            return 0xFEB3A;
        case 0xE217:
            return 0xFEB3B;
        case 0xE218:
            return 0xFEB3C;
        case 0xE219:
            return 0xFEB63;
        case 0xE21A:
            return 0xFEB64;
        case 0xE21B:
            return 0xFEB67;
        case 0xE21C:
            return 0xFE82E;
        case 0xE21D:
            return 0xFE82F;
        case 0xE21E:
            return 0xFE830;
        case 0xE21F:
            return 0xFE831;
        case 0xE220:
            return 0xFE832;
        case 0xE221:
            return 0xFE833;
        case 0xE222:
            return 0xFE834;
        case 0xE223:
            return 0xFE835;
        case 0xE224:
            return 0xFE836;
        case 0xE225:
            return 0xFE837;
        case 0xE226:
            return 0xFEB3D;
        case 0xE227:
            return 0xFEB3E;
        case 0xE228:
            return 0xFEB3F;
        case 0xE229:
            return 0xFEB81;
        case 0xE22A:
            return 0xFEB31;
        case 0xE22B:
            return 0xFEB2F;
        case 0xE22C:
            return 0xFEB40;
        case 0xE22D:
            return 0xFEB41;
        case 0xE22E:
            return 0xFEB99;
        case 0xE22F:
            return 0xFEB9A;
        case 0xE230:
            return 0xFEB9B;
        case 0xE231:
            return 0xFEB9C;
        case 0xE232:
            return 0xFEAF8;
        case 0xE233:
            return 0xFEAF9;
        case 0xE234:
            return 0xFEAFA;
        case 0xE235:
            return 0xFEAFB;
        case 0xE236:
            return 0xFEAF0;
        case 0xE237:
            return 0xFEAF2;
        case 0xE238:
            return 0xFEAF1;
        case 0xE239:
            return 0xFEAF3;
        case 0xE23A:
            return 0xFEAFC;
        case 0xE23B:
            return 0xFEAFD;
        case 0xE23C:
            return 0xFEAFE;
        case 0xE23D:
            return 0xFEAFF;
        case 0xE23E:
            return 0xFE4F8;
        case 0xE23F:
            return 0xFE02B;
        case 0xE240:
            return 0xFE02C;
        case 0xE241:
            return 0xFE02D;
        case 0xE242:
            return 0xFE02E;
        case 0xE243:
            return 0xFE02F;
        case 0xE244:
            return 0xFE030;
        case 0xE245:
            return 0xFE031;
        case 0xE246:
            return 0xFE032;
        case 0xE247:
            return 0xFE033;
        case 0xE248:
            return 0xFE034;
        case 0xE249:
            return 0xFE035;
        case 0xE24A:
            return 0xFE036;
        case 0xE24B:
            return 0xFE037;
        case 0xE24C:
            return 0xFEB42;
        case 0xE24D:
            return 0xFEB27;
        case 0xE24E:
            return 0xFEB29;
        case 0xE24F:
            return 0xFEB2D;
        case 0xE250:
            return 0xFE839;
        case 0xE251:
            return 0xFE83A;
        case 0xE252:
            return 0xFEB23;
        case 0xE253:
            return 0xFE1B4;
        case 0xE254:
            return 0xFEE77;
        case 0xE255:
            return 0xFEE78;
        case 0xE256:
            return 0xFEE79;
        case 0xE257:
            return 0xFEE7A;
        case 0xE258:
            return 0xFEE7B;
        case 0xE259:
            return 0xFEE7C;
        case 0xE25A:
            return 0xFEE7D;
        case 0xE301:
            return 0xFE527;
        case 0xE302:
            return 0xFE4D3;
        case 0xE303:
            return 0xFE045;
        case 0xE304:
            return 0xFE03D;
        case 0xE305:
            return 0xFE046;
        case 0xE306:
            return 0xFE828;
        case 0xE307:
            return 0xFE047;
        case 0xE308:
            return 0xFE048;
        case 0xE309:
            return 0xFE508;
        case 0xE30A:
            return 0xFE803;
        case 0xE30B:
            return 0xFE985;
        case 0xE30C:
            return 0xFE987;
        case 0xE30D:
            return 0xFEB43;
        case 0xE30E:
            return 0xFEB1E;
        case 0xE30F:
            return 0xFE50A;
        case 0xE310:
            return 0xFE516;
        case 0xE311:
            return 0xFEB58;
        case 0xE312:
            return 0xFE517;
        case 0xE313:
            return 0xFE53E;
        case 0xE314:
            return 0xFE50F;
        case 0xE315:
            return 0xFEB2B;
        case 0xE316:
            return 0xFE53C;
        case 0xE317:
            return 0xFE530;
        case 0xE318:
            return 0xFE4D4;
        case 0xE319:
            return 0xFE4D5;
        case 0xE31A:
            return 0xFE4D7;
        case 0xE31B:
            return 0xFE4D8;
        case 0xE31C:
            return 0xFE195;
        case 0xE31D:
            return 0xFE196;
        case 0xE31E:
            return 0xFE197;
        case 0xE31F:
            return 0xFE198;
        case 0xE320:
            return 0xFE199;
        case 0xE321:
            return 0xFE4D9;
        case 0xE322:
            return 0xFE4DA;
        case 0xE323:
            return 0xFE4F0;
        case 0xE324:
            return 0xFE808;
        case 0xE325:
            return 0xFE4F2;
        case 0xE326:
            return 0xFE814;
        case 0xE327:
            return 0xFEB0D;
        case 0xE328:
            return 0xFEB11;
        case 0xE329:
            return 0xFEB12;
        case 0xE32A:
            return 0xFEB13;
        case 0xE32B:
            return 0xFEB14;
        case 0xE32C:
            return 0xFEB15;
        case 0xE32D:
            return 0xFEB16;
        case 0xE32E:
            return 0xFEB60;
        case 0xE32F:
            return 0xFEB68;
        case 0xE330:
            return 0xFEB5D;
        case 0xE331:
            return 0xFEB5B;
        case 0xE332:
            return 0xFEB44;
        case 0xE333:
            return 0xFEB45;
        case 0xE334:
            return 0xFEB57;
        case 0xE335:
            return 0xFEB69;
        case 0xE336:
            return 0xFEB0A;
        case 0xE337:
            return 0xFEB0B;
        case 0xE338:
            return 0xFE984;
        case 0xE339:
            return 0xFE964;
        case 0xE33A:
            return 0xFE966;
        case 0xE33B:
            return 0xFE967;
        case 0xE33C:
            return 0xFE968;
        case 0xE33D:
            return 0xFE969;
        case 0xE33E:
            return 0xFE96A;
        case 0xE33F:
            return 0xFE96B;
        case 0xE340:
            return 0xFE963;
        case 0xE341:
            return 0xFE96C;
        case 0xE342:
            return 0xFE961;
        case 0xE343:
            return 0xFE96D;
        case 0xE344:
            return 0xFE96E;
        case 0xE345:
            return 0xFE051;
        case 0xE346:
            return 0xFE052;
        case 0xE347:
            return 0xFE053;
        case 0xE348:
            return 0xFE054;
        case 0xE349:
            return 0xFE055;
        case 0xE34A:
            return 0xFE056;
        case 0xE34B:
            return 0xFE511;
        case 0xE34C:
            return 0xFE96F;
        case 0xE34D:
            return 0xFE970;
        case 0xE401:
            return 0xFE345;
        case 0xE402:
            return 0xFE343;
        case 0xE403:
            return 0xFE340;
        case 0xE404:
            return 0xFE333;
        case 0xE405:
            return 0xFE347;
        case 0xE406:
            return 0xFE33C;
        case 0xE407:
            return 0xFE33F;
        case 0xE408:
            return 0xFE342;
        case 0xE409:
            return 0xFE32A;
        case 0xE40A:
            return 0xFE33E;
        case 0xE40B:
            return 0xFE33B;
        case 0xE40C:
            return 0xFE32E;
        case 0xE40D:
            return 0xFE32F;
        case 0xE40E:
            return 0xFE326;
        case 0xE40F:
            return 0xFE325;
        case 0xE410:
            return 0xFE322;
        case 0xE411:
            return 0xFE33A;
        case 0xE412:
            return 0xFE334;
        case 0xE413:
            return 0xFE339;
        case 0xE414:
            return 0xFE336;
        case 0xE415:
            return 0xFE338;
        case 0xE416:
            return 0xFE33D;
        case 0xE417:
            return 0xFE32D;
        case 0xE418:
            return 0xFE32C;
        case 0xE419:
            return 0xFE190;
        case 0xE41A:
            return 0xFE192;
        case 0xE41B:
            return 0xFE191;
        case 0xE41C:
            return 0xFE193;
        case 0xE41D:
            return 0xFE35B;
        case 0xE41E:
            return 0xFEB9D;
        case 0xE41F:
            return 0xFEB9E;
        case 0xE420:
            return 0xFEB9F;
        case 0xE421:
            return 0xFEBA0;
        case 0xE422:
            return 0xFEBA1;
        case 0xE423:
            return 0xFE351;
        case 0xE424:
            return 0xFE352;
        case 0xE425:
            return 0xFE829;
        case 0xE426:
            return 0xFE353;
        case 0xE427:
            return 0xFE358;
        case 0xE428:
            return 0xFE1A0;
        case 0xE429:
            return 0xFE1A2;
        case 0xE42A:
            return 0xFE7D6;
        case 0xE42B:
            return 0xFE7DD;
        case 0xE42C:
            return 0xFE80E;
        case 0xE42D:
            return 0xFE7DE;
        case 0xE42E:
            return 0xFE7E5;
        case 0xE42F:
            return 0xFE7F1;
        case 0xE430:
            return 0xFE7F2;
        case 0xE431:
            return 0xFE7F3;
        case 0xE432:
            return 0xFE7F4;
        case 0xE433:
            return 0xFE7FE;
        case 0xE434:
            return 0xFE7E0;
        case 0xE435:
            return 0xFE7E2;
        case 0xE436:
            return 0xFE518;
        case 0xE437:
            return 0xFEB17;
        case 0xE438:
            return 0xFE519;
        case 0xE439:
            return 0xFE51A;
        case 0xE43A:
            return 0xFE51B;
        case 0xE43B:
            return 0xFE51C;
        case 0xE43C:
            return 0xFE007;
        case 0xE43D:
            return 0xFE82A;
        case 0xE43E:
            return 0xFE038;
        case 0xE43F:
            return 0xFE971;
        case 0xE440:
            return 0xFE51D;
        case 0xE441:
            return 0xFE1C6;
        case 0xE442:
            return 0xFE51E;
        case 0xE443:
            return 0xFE005;
        case 0xE444:
            return 0xFE049;
        case 0xE445:
            return 0xFE51F;
        case 0xE446:
            return 0xFE017;
        case 0xE447:
            return 0xFE043;
        case 0xE448:
            return 0xFE513;
        case 0xE449:
            return 0xFE00A;
        case 0xE44A:
            return 0xFE00C;
        case 0xE44B:
            return 0xFE008;
        case 0xE44C:
            return 0xFE00D;
        case 0xE501:
            return 0xFE4B8;
        case 0xE502:
            return 0xFE804;
        case 0xE503:
            return 0xFE805;
        case 0xE504:
            return 0xFE4BD;
        case 0xE505:
            return 0xFE4BE;
        case 0xE506:
            return 0xFE4BF;
        case 0xE507:
            return 0xFE802;
        case 0xE508:
            return 0xFE4C0;
        case 0xE509:
            return 0xFE4C4;
        case 0xE50A:
            return 0xFE4C5;
        case 0xE50B:
            return 0xFE4E5;
        case 0xE50C:
            return 0xFE4E6;
        case 0xE50D:
            return 0xFE4E7;
        case 0xE50E:
            return 0xFE4E8;
        case 0xE50F:
            return 0xFE4E9;
        case 0xE510:
            return 0xFE4EA;
        case 0xE511:
            return 0xFE4EB;
        case 0xE512:
            return 0xFE4EC;
        case 0xE513:
            return 0xFE4ED;
        case 0xE514:
            return 0xFE4EE;
        case 0xE515:
            return 0xFE1A4;
        case 0xE516:
            return 0xFE1A5;
        case 0xE517:
            return 0xFE1A6;
        case 0xE518:
            return 0xFE1A7;
        case 0xE519:
            return 0xFE1A8;
        case 0xE51A:
            return 0xFE1A9;
        case 0xE51B:
            return 0xFE1AA;
        case 0xE51C:
            return 0xFE1AB;
        case 0xE51D:
            return 0xFE4C6;
        case 0xE51E:
            return 0xFE1B5;
        case 0xE51F:
            return 0xFE1B6;
        case 0xE520:
            return 0xFE1C7;
        case 0xE521:
            return 0xFE1C8;
        case 0xE522:
            return 0xFE1C9;
        case 0xE523:
            return 0xFE1BA;
        case 0xE524:
            return 0xFE1CA;
        case 0xE525:
            return 0xFE1CB;
        case 0xE526:
            return 0xFE1CC;
        case 0xE527:
            return 0xFE1CD;
        case 0xE528:
            return 0xFE1CE;
        case 0xE529:
            return 0xFE1CF;
        case 0xE52A:
            return 0xFE1D0;
        case 0xE52B:
            return 0xFE1D1;
        case 0xE52C:
            return 0xFE1D2;
        case 0xE52D:
            return 0xFE1D3;
        case 0xE52E:
            return 0xFE1D4;
        case 0xE52F:
            return 0xFE1D5;
        case 0xE530:
            return 0xFE1D6;
        case 0xE531:
            return 0xFE1D7;
        case 0xE532:
            return 0xFE50B;
        case 0xE533:
            return 0xFE50C;
        case 0xE534:
            return 0xFE50D;
        case 0xE535:
            return 0xFE50E;
        case 0xE536:
            return 0xFE553;
        case 0xE537:
            return 0xFEB2A;
        case 0xE538:
            return 0xFEE70;
        case 0xE539:
            return 0xFEE71;
        case 0xE53A:
            return 0xFEE72;
        case 0xE53B:
            return 0xFEE73;
        case 0xE53C:
            return 0xFEE74;
        case 0xE53D:
            return 0xFEE75;
        case 0xE53E:
            return 0xFEE76;
        default:
            return codePoint;
        }
    }

    public static void setCharset(String charset, Part part) throws MessagingException {
        part.setHeader(MimeHeader.HEADER_CONTENT_TYPE,
        part.getMimeType() + "";\n charset="" + getExternalCharset(charset));
    }

    public static String getExternalCharset(String charset) {
        if (charset.length() > 17 && charset.startsWith(""x-"") &&
        charset.endsWith(""-shift_jis-2007""))
            return ""shift_jis"";

        return charset;
    }
}
",True,144,0,0,7,41,18,13,L1
140,com.fsck.k9.mail.internet.EncoderUtil.java,"
package com.fsck.k9.mail.internet;

import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.BitSet;

import org.apache.james.mime4j.util.CharsetUtil;

/**
 * Static methods for encoding header field values. This includes encoded-words
 * as defined in <a href='http://www.faqs.org/rfcs/rfc2047.html'>RFC 2047</a>
 * or display-names of an e-mail address, for example.
 *
 * This class is copied from the org.apache.james.mime4j.decoder.EncoderUtil class.  It's modified here in order to
 * encode emoji characters in the Subject headers.  The method to decode emoji depends on the MimeMessage class because
 * it has to be determined with the sender address.
 */
public class EncoderUtil {
    private static final BitSet Q_RESTRICTED_CHARS = initChars(""=_?\""#$%&'(),.:;<>@[\\]^`{|}~"");

    private static final String ENC_WORD_PREFIX = ""=?"";
    private static final String ENC_WORD_SUFFIX = ""?="";

    private static final int ENCODED_WORD_MAX_LENGTH = 75; // RFC 2047

    private static BitSet initChars(String specials) {
        BitSet bs = new BitSet(128);
        for (char ch = 33; ch < 127; ch++) {
            if (specials.indexOf(ch) == -1) {
                bs.set(ch);
            }
        }
        return bs;
    }

    /**
     * Selects one of the two encodings specified in RFC 2047.
     */
    public enum Encoding {
        /** The B encoding (identical to base64 defined in RFC 2045). */
        B,
        /** The Q encoding (similar to quoted-printable defined in RFC 2045). */
        Q
    }

    private EncoderUtil() {
    }

    /**
     * Encodes the specified text into an encoded word or a sequence of encoded
     * words separated by space. The text is separated into a sequence of
     * encoded words if it does not fit in a single one.
     *
     * @param text
     *            text to encode.
     * @param charset
     *            the Java charset that should be used to encode the specified
     *            string into a byte array. A suitable charset is detected
     *            automatically if this parameter is <code>null</code>.
     * @return the encoded word (or sequence of encoded words if the given text
     *         does not fit in a single encoded word).
     */
    public static String encodeEncodedWord(String text, Charset charset) {
        if (text == null)
            throw new IllegalArgumentException();

        if (charset == null)
            charset = determineCharset(text);

        String mimeCharset = MimeUtility.getExternalCharset(charset.name());

        byte[] bytes = encode(text, charset);

        Encoding encoding = determineEncoding(bytes);

        if (encoding == Encoding.B) {
            String prefix = ENC_WORD_PREFIX + mimeCharset + ""?B?"";
            return encodeB(prefix, text, charset, bytes);
        } else {
            String prefix = ENC_WORD_PREFIX + mimeCharset + ""?Q?"";
            return encodeQ(prefix, text, charset, bytes);
        }
    }

    private static String encodeB(String prefix, String text, Charset charset, byte[] bytes) {
        int encodedLength = bEncodedLength(bytes);

        int totalLength = prefix.length() + encodedLength
                          + ENC_WORD_SUFFIX.length();
        if (totalLength <= ENCODED_WORD_MAX_LENGTH) {
            return prefix + org.apache.james.mime4j.codec.EncoderUtil.encodeB(bytes) + ENC_WORD_SUFFIX;
        } else {
            String part1 = text.substring(0, text.length() / 2);
            byte[] bytes1 = encode(part1, charset);
            String word1 = encodeB(prefix, part1, charset, bytes1);

            String part2 = text.substring(text.length() / 2);
            byte[] bytes2 = encode(part2, charset);
            String word2 = encodeB(prefix, part2, charset, bytes2);

            return word1 + "" "" + word2;
        }
    }

    private static int bEncodedLength(byte[] bytes) {
        return (bytes.length + 2) / 3 * 4;
    }

    private static String encodeQ(String prefix, String text,  Charset charset, byte[] bytes) {
        int encodedLength = qEncodedLength(bytes);

        int totalLength = prefix.length() + encodedLength
                          + ENC_WORD_SUFFIX.length();
        if (totalLength <= ENCODED_WORD_MAX_LENGTH) {
            return prefix + org.apache.james.mime4j.codec.EncoderUtil.encodeQ(bytes, org.apache.james.mime4j.codec.EncoderUtil.Usage.WORD_ENTITY) + ENC_WORD_SUFFIX;
        } else {
            String part1 = text.substring(0, text.length() / 2);
            byte[] bytes1 = encode(part1, charset);
            String word1 = encodeQ(prefix, part1, charset, bytes1);

            String part2 = text.substring(text.length() / 2);
            byte[] bytes2 = encode(part2, charset);
            String word2 = encodeQ(prefix, part2, charset, bytes2);

            return word1 + "" "" + word2;
        }
    }

    private static int qEncodedLength(byte[] bytes) {
        int count = 0;

        for (int idx = 0; idx < bytes.length; idx++) {
            int v = bytes[idx] & 0xff;
            if (v == 32) {
                count++;
            } else if (!Q_RESTRICTED_CHARS.get(v)) {
                count += 3;
            } else {
                count++;
            }
        }

        return count;
    }

    private static byte[] encode(String text, Charset charset) {
        ByteBuffer buffer = charset.encode(text);
        byte[] bytes = new byte[buffer.limit()];
        buffer.get(bytes);
        return bytes;
    }

    private static Charset determineCharset(String text) {
        // it is an important property of iso-8859-1 that it directly maps
        // unicode code points 0000 to 00ff to byte values 00 to ff.
        boolean ascii = true;
        final int len = text.length();
        for (int index = 0; index < len; index++) {
            char ch = text.charAt(index);
            if (ch > 0xff) {
                return CharsetUtil.UTF_8;
            }
            if (ch > 0x7f) {
                ascii = false;
            }
        }
        return ascii ? CharsetUtil.US_ASCII : CharsetUtil.ISO_8859_1;
    }

    private static Encoding determineEncoding(byte[] bytes) {
        if (bytes.length == 0)
            return Encoding.Q;

        int qEncoded = 0;
        for (int i = 0; i < bytes.length; i++) {
            int v = bytes[i] & 0xff;
            if (v != 32 && !Q_RESTRICTED_CHARS.get(v)) {
                qEncoded++;
            }
        }

        int percentage = qEncoded * 100 / bytes.length;
        return percentage > 30 ? Encoding.B : Encoding.Q;
    }
}
",False,144,0,0,8,41,1,1,L1
141,com.fsck.k9.mail.internet.MimeMultipart.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.BodyPart;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Multipart;

import java.io.*;

public class MimeMultipart extends Multipart {
    protected String mPreamble;

    protected String mContentType;

    protected String mBoundary;

    protected String mSubType;

    public MimeMultipart() throws MessagingException {
        mBoundary = generateBoundary();
        setSubType(""mixed"");
    }

    public MimeMultipart(String contentType) throws MessagingException {
        this.mContentType = contentType;
        try {
            mSubType = MimeUtility.getHeaderParameter(contentType, null).split(""/"")[1];
            mBoundary = MimeUtility.getHeaderParameter(contentType, ""boundary"");
            if (mBoundary == null) {
                throw new MessagingException(""MultiPart does not contain boundary: "" + contentType);
            }
        } catch (Exception e) {
            throw new MessagingException(
                ""Invalid MultiPart Content-Type; must contain subtype and boundary. (""
                + contentType + "")"", e);
        }
    }

    public String generateBoundary() {
        StringBuffer sb = new StringBuffer();
        sb.append(""----"");
        for (int i = 0; i < 30; i++) {
            sb.append(Integer.toString((int)(Math.random() * 35), 36));
        }
        return sb.toString().toUpperCase();
    }

    public String getPreamble() {
        return mPreamble;
    }

    public void setPreamble(String preamble) {
        this.mPreamble = preamble;
    }

    @Override
    public String getContentType() {
        return mContentType;
    }

    public void setSubType(String subType) {
        this.mSubType = subType;
        mContentType = String.format(""multipart/%s; boundary=\""%s\"""", subType, mBoundary);
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException {
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out), 1024);

        if (mPreamble != null) {
            writer.write(mPreamble + ""\r\n"");
        }

        if (mParts.size() == 0) {
            writer.write(""--"" + mBoundary + ""\r\n"");
        }

        for (int i = 0, count = mParts.size(); i < count; i++) {
            BodyPart bodyPart = mParts.get(i);
            writer.write(""--"" + mBoundary + ""\r\n"");
            writer.flush();
            bodyPart.writeTo(out);
            writer.write(""\r\n"");
        }

        writer.write(""--"" + mBoundary + ""--\r\n"");
        writer.flush();
    }

    public InputStream getInputStream() throws MessagingException {
        return null;
    }
}
",True,144,0,0,8,40,4,5,L1
142,com.fsck.k9.mail.internet.DecoderUtil.java,"
package com.fsck.k9.mail.internet;

import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import org.apache.james.mime4j.codec.Base64InputStream;
import org.apache.james.mime4j.codec.QuotedPrintableInputStream;
import org.apache.james.mime4j.util.CharsetUtil;


/**
 * Static methods for decoding strings, byte arrays and encoded words.
 *
 * This class is copied from the org.apache.james.mime4j.decoder.DecoderUtil class.  It's modified here in order to
 * decode emoji characters in the Subject headers.  The method to decode emoji depends on the MimeMessage class because
 * it has to be determined with the sender address, the mailer and so on.
 */
public class DecoderUtil {
    /**
     * Decodes an encoded word encoded with the 'B' encoding (described in
     * RFC 2047) found in a header field body.
     *
     * @param encodedWord the encoded word to decode.
     * @param charset the Java charset to use.
     * @return the decoded string.
     */
    private static String decodeB(String encodedWord, String charset) {
        byte[] bytes;
        try {
            bytes = encodedWord.getBytes(""US-ASCII"");
        } catch (UnsupportedEncodingException e) {
            return null;
        }

        Base64InputStream is = new Base64InputStream(new ByteArrayInputStream(bytes));
        try {
            return MimeUtility.readToString(is, charset);
        } catch (IOException e) {
            return null;
        }
    }

    /**
     * Decodes an encoded word encoded with the 'Q' encoding (described in
     * RFC 2047) found in a header field body.
     *
     * @param encodedWord the encoded word to decode.
     * @param charset the Java charset to use.
     * @return the decoded string.
     */
    private static String decodeQ(String encodedWord, String charset) {

        /*
         * Replace _ with =20
         */
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < encodedWord.length(); i++) {
            char c = encodedWord.charAt(i);
            if (c == '_') {
                sb.append(""=20"");
            } else {
                sb.append(c);
            }
        }

        byte[] bytes;
        try {
            bytes = sb.toString().getBytes(""US-ASCII"");
        } catch (UnsupportedEncodingException e) {
            return null;
        }

        QuotedPrintableInputStream is = new QuotedPrintableInputStream(new ByteArrayInputStream(bytes));
        try {
            return MimeUtility.readToString(is, charset);
        } catch (IOException e) {
            return null;
        }
    }

    /**
     * Decodes a string containing encoded words as defined by RFC 2047.
     * Encoded words in have the form
     * =?charset?enc?Encoded word?= where enc is either 'Q' or 'q' for
     * quoted-printable and 'B' or 'b' for Base64.
     *
     * ANDROID:  COPIED FROM A NEWER VERSION OF MIME4J
     *
     * @param body the string to decode.
     * @param message the message which has the string.
     * @return the decoded string.
     */
    public static String decodeEncodedWords(String body, Message message) {

        // ANDROID:  Most strings will not include ""=?"" so a quick test can prevent unneeded
        // object creation.  This could also be handled via lazy creation of the StringBuilder.
        if (body.indexOf(""=?"") == -1) {
            return body;
        }

        int previousEnd = 0;
        boolean previousWasEncoded = false;

        StringBuilder sb = new StringBuilder();

        while (true) {
            int begin = body.indexOf(""=?"", previousEnd);

            // ANDROID:  The mime4j original version has an error here.  It gets confused if
            // the encoded string begins with an '=' (just after ""?Q?"").  This patch seeks forward
            // to find the two '?' in the ""header"", before looking for the final ""?="".
            int endScan = begin + 2;
            if (begin != -1) {
                int qm1 = body.indexOf('?', endScan + 2);
                int qm2 = body.indexOf('?', qm1 + 1);
                if (qm2 != -1) {
                    endScan = qm2 + 1;
                }
            }

            int end = begin == -1 ? -1 : body.indexOf(""?="", endScan);
            if (end == -1) {
                if (previousEnd == 0)
                    return body;

                sb.append(body.substring(previousEnd));
                return sb.toString();
            }
            end += 2;

            String sep = body.substring(previousEnd, begin);

            String decoded = decodeEncodedWord(body, begin, end, message);
            if (decoded == null) {
                sb.append(sep);
                sb.append(body.substring(begin, end));
            } else {
                if (!previousWasEncoded || !CharsetUtil.isWhitespace(sep)) {
                    sb.append(sep);
                }
                sb.append(decoded);
            }

            previousEnd = end;
            previousWasEncoded = decoded != null;
        }
    }

    // return null on error
    private static String decodeEncodedWord(String body, int begin, int end, Message message) {
        int qm1 = body.indexOf('?', begin + 2);
        if (qm1 == end - 2)
            return null;

        int qm2 = body.indexOf('?', qm1 + 1);
        if (qm2 == end - 2)
            return null;

        String mimeCharset = body.substring(begin + 2, qm1);
        String encoding = body.substring(qm1 + 1, qm2);
        String encodedText = body.substring(qm2 + 1, end - 2);

        String charset;
        try {
            charset = MimeUtility.fixupCharset(mimeCharset, message);
        } catch (MessagingException e) {
            return null;
        }

        if (encodedText.length() == 0) {
            Log.w(K9.LOG_TAG, ""Missing encoded text in encoded word: '"" + body.substring(begin, end) + ""'"");
            return null;
        }

        if (encoding.equalsIgnoreCase(""Q"")) {
            return decodeQ(encodedText, charset);
        } else if (encoding.equalsIgnoreCase(""B"")) {
            return DecoderUtil.decodeB(encodedText, charset);
        } else {
            Log.w(K9.LOG_TAG, ""Warning: Unknown encoding in encoded word '"" + body.substring(begin, end) + ""'"");
            return null;
        }
    }
}
",False,144,0,0,7,44,1,4,L1
143,com.fsck.k9.mail.internet.Iso2022JpToShiftJisInputStream.java,"package com.fsck.k9.mail.internet;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.MalformedInputException;

class Iso2022JpToShiftJisInputStream extends InputStream {
    private enum Charset {
        ASCII, JISX0201, JISX0208,
    }

    private InputStream mIn;
    private Charset charset = Charset.ASCII;
    private int out;
    private boolean hasOut = false;

    public Iso2022JpToShiftJisInputStream(InputStream in) {
        mIn = in;
    }

    @Override
    public int read() throws IOException {
        if (hasOut) {
            hasOut = false;
            return out;
        }

        int in1 = mIn.read();
        while (in1 == 0x1b) {
            in1 = mIn.read();
            if (in1 == '(') {
                in1 = mIn.read();
                if (in1 == 'B' || in1 == 'J')
                    charset = Charset.ASCII;
                else if (in1 == 'I')  // Not defined in RFC 1468 but in CP50221.
                    charset = Charset.JISX0201;
                else
                    throw new MalformedInputException(0);
            } else if (in1 == '$') {
                in1 = mIn.read();
                if (in1 == '@' || in1 == 'B')
                    charset = Charset.JISX0208;
                else
                    throw new MalformedInputException(0);
            } else
                throw new MalformedInputException(0);
            in1 = mIn.read();
        }

        if (in1 == '\n' || in1 == '\r')
            charset = Charset.ASCII;

        if (in1 < 0x21 || in1 >= 0x7f)
            return in1;

        switch (charset) {
        case ASCII:
            return in1;
        case JISX0201:
            return in1 + 0x80;
        case JISX0208:
            int in2 = mIn.read();
            if (in2 < 0x21 || in2 >= 0x7f)
                throw new MalformedInputException(0);

            int out1 = (in1 + 1) / 2 + (in1 < 0x5f ? 0x70 : 0xb0);
            int out2 = in2 + (in1 % 2 == 0 ? 0x7e : in2 < 0x60 ? 0x1f : 0x20);

            out = out2;
            hasOut = true;

            return out1;
        default:
            throw new RuntimeException();
        }
    }
}
",False,113,5,57,0,0,1,0,L1
144,com.fsck.k9.mail.store.UnavailableAccountException.java,"package com.fsck.k9.mail.store;

import com.fsck.k9.Account;

/**
 * An {@link Account} is not
 * {@link Account#isAvailable(android.content.Context)}.<br/>
 * The operation may be retried later.
 */
public class UnavailableAccountException extends RuntimeException {

    /**
     *
     */
    private static final long serialVersionUID = -1827283277120501465L;

    public UnavailableAccountException() {
        super(""please try again later"");
    }

    /**
     * @param detailMessage
     * @param throwable
     */
    public UnavailableAccountException(String detailMessage, Throwable throwable) {
        super(detailMessage, throwable);
    }

    /**
     * @param detailMessage
     */
    public UnavailableAccountException(String detailMessage) {
        super(detailMessage);
    }

    /**
     * @param throwable
     */
    public UnavailableAccountException(Throwable throwable) {
        super(throwable);
    }
}
",False,144,0,0,7,42,1,1,L1
145,com.fsck.k9.mail.store.WebDavStore.java,"package com.fsck.k9.mail.store;

import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.controller.MessageRetrievalListener;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Folder.OpenMode;
import com.fsck.k9.mail.filter.EOLConvertingOutputStream;
import com.fsck.k9.mail.internet.MimeMessage;
import com.fsck.k9.mail.transport.TrustedSocketFactory;
import org.apache.http.*;
import org.apache.http.client.CookieStore;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.client.protocol.ClientContext;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.BasicCookieStore;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.protocol.BasicHttpContext;
import org.apache.http.protocol.HttpContext;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;

import javax.net.ssl.SSLException;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.*;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Stack;
import java.util.zip.GZIPInputStream;

/**
 * <pre>
 * Uses WebDAV formatted HTTP calls to an MS Exchange server to fetch email
 * and email information.
 * </pre>
 */
public class WebDavStore extends Store {
    // Security options
    private static final short CONNECTION_SECURITY_NONE = 0;
    private static final short CONNECTION_SECURITY_TLS_OPTIONAL = 1;
    private static final short CONNECTION_SECURITY_TLS_REQUIRED = 2;
    private static final short CONNECTION_SECURITY_SSL_OPTIONAL = 3;
    private static final short CONNECTION_SECURITY_SSL_REQUIRED = 4;

    // Authentication types
    private static final short AUTH_TYPE_NONE = 0;
    private static final short AUTH_TYPE_BASIC = 1;
    private static final short AUTH_TYPE_FORM_BASED = 2;

    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED, Flag.SEEN, Flag.ANSWERED };

    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    private static final Message[] EMPTY_MESSAGE_ARRAY = new Message[0];

    // These are the ids used from Exchange server to identify the special folders
    // http://social.technet.microsoft.com/Forums/en/exchangesvrdevelopment/thread/1cd2e98c-8a12-44bd-a3e3-9c5ee9e4e14d
    private static final String DAV_MAIL_INBOX_FOLDER = ""inbox"";
    private static final String DAV_MAIL_DRAFTS_FOLDER = ""drafts"";
    private static final String DAV_MAIL_SPAM_FOLDER = ""junkemail"";
    private static final String DAV_MAIL_SEND_FOLDER = ""##DavMailSubmissionURI##"";
    private static final String DAV_MAIL_TRASH_FOLDER = ""deleteditems"";
    private static final String DAV_MAIL_OUTBOX_FOLDER = ""outbox"";
    private static final String DAV_MAIL_SENT_FOLDER = ""sentitems"";

    private short mConnectionSecurity;
    private String mUsername; /* Stores the username for authentications */
    private String mAlias; /* Stores the alias for the user's mailbox */
    private String mPassword; /* Stores the password for authentications */
    private String mUrl; /* Stores the base URL for the server */
    private String mHost; /* Stores the host name for the server */
    private String mPath; /* Stores the path for the server */
    private String mAuthPath; /* Stores the path off of the server to post data to for form based authentication */
    private String mMailboxPath; /* Stores the user specified path to the mailbox */
    private URI mUri; /* Stores the Uniform Resource Indicator with all connection info */

    private boolean mSecure;
    private WebDavHttpClient mHttpClient = null;
    private HttpContext mContext = null;
    private String mAuthString;
    private CookieStore mAuthCookies = null;
    private short mAuthentication = AUTH_TYPE_NONE;
    private String mCachedLoginUrl;

    private Folder mSendFolder = null;
    private HashMap<String, WebDavFolder> mFolderList = new HashMap<String, WebDavFolder>();

    /**
     * webdav://user:password@server:port CONNECTION_SECURITY_NONE
     * webdav+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * webdav+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * webdav+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * webdav+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     */
    public WebDavStore(Account account) throws MessagingException {
        super(account);

        try {
            mUri = new URI(mAccount.getStoreUri());
        } catch (URISyntaxException use) {
            throw new MessagingException(""Invalid WebDavStore URI"", use);
        }

        String scheme = mUri.getScheme();
        if (scheme.equals(""webdav"")) {
            mConnectionSecurity = CONNECTION_SECURITY_NONE;
        } else if (scheme.equals(""webdav+ssl"")) {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
        } else if (scheme.equals(""webdav+ssl+"")) {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
        } else if (scheme.equals(""webdav+tls"")) {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
        } else if (scheme.equals(""webdav+tls+"")) {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
        } else {
            throw new MessagingException(""Unsupported protocol"");
        }

        mHost = mUri.getHost();
        if (mHost.startsWith(""http"")) {
            String[] hostParts = mHost.split(""://"", 2);
            if (hostParts.length > 1) {
                mHost = hostParts[1];
            }
        }

        if (mUri.getUserInfo() != null) {
            try {
                String[] userInfoParts = mUri.getUserInfo().split("":"");
                mUsername = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                String userParts[] = mUsername.split(""\\\\"", 2);

                if (userParts.length > 1) {
                    mAlias = userParts[1];
                } else {
                    mAlias = mUsername;
                }
                if (userInfoParts.length > 1) {
                    mPassword = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
            } catch (UnsupportedEncodingException enc) {
                // This shouldn't happen since the encoding is hardcoded to UTF-8
                Log.e(K9.LOG_TAG, ""Couldn't urldecode username or password."", enc);
            }
        }

        String[] pathParts = mUri.getPath().split(""\\|"");

        for (int i = 0, count = pathParts.length; i < count; i++) {
            if (i == 0) {
                if (pathParts[0] != null &&
                        pathParts[0].length() > 1) {
                    mPath = pathParts[0];
                }
            } else if (i == 1) {
                if (pathParts[1] != null &&
                        pathParts[1].length() > 1) {
                    mAuthPath = pathParts[1];
                }
            } else if (i == 2) {
                if (pathParts[2] != null &&
                        pathParts[2].length() > 1) {
                    mMailboxPath = pathParts[2];
                }
            }
        }

        if (mPath == null || mPath.equals("""")) {
            mPath = ""/Exchange"";
        } else if (!mPath.startsWith(""/"")) {
            mPath = ""/"" + mPath;
        }

        if (mMailboxPath == null || mMailboxPath.equals("""")) {
            mMailboxPath = ""/"" + mAlias;
        } else if (!mMailboxPath.startsWith(""/"")) {
            mMailboxPath = ""/"" + mMailboxPath;
        }

        if (mAuthPath != null &&
                !mAuthPath.equals("""") &&
                !mAuthPath.startsWith(""/"")) {
            mAuthPath = ""/"" + mAuthPath;
        }

        // The URL typically looks like the following: ""https://mail.domain.com/Exchange/alias"".
        // The inbox path would look like: ""https://mail.domain.com/Exchange/alias/Inbox"".
        mUrl = getRoot() + mPath + mMailboxPath;

        mSecure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
        mAuthString = ""Basic "" + Utility.base64Encode(mUsername + "":"" + mPassword);
    }

    private String getRoot() {
        String root;
        if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED ||
                mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
                mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL ||
                mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL) {
            root = ""https"";
        } else {
            root = ""http"";
        }
        root += ""://"" + mHost + "":"" + mUri.getPort();
        return root;
    }

    @Override
    public void checkSettings() throws MessagingException {
        authenticate();
    }

    @Override
    public List <? extends Folder > getPersonalNamespaces(boolean forceListAll) throws MessagingException {
        LinkedList<Folder> folderList = new LinkedList<Folder>();
        /**
         * We have to check authentication here so we have the proper URL stored
         */
        getHttpClient();

        /**
         *  Firstly we get the ""special"" folders list (inbox, outbox, etc)
         *  and setup the account accordingly
         */
        HashMap<String, String> headers = new HashMap<String, String>();
        DataSet dataset = new DataSet();
        headers.put(""Depth"", ""0"");
        headers.put(""Brief"", ""t"");
        dataset = processRequest(this.mUrl, ""PROPFIND"", getSpecialFoldersList(), headers);

        HashMap<String, String> specialFoldersMap = dataset.getSpecialFolderToUrl();
        String folderName = getFolderName(specialFoldersMap.get(DAV_MAIL_INBOX_FOLDER));
        if (folderName != null) {
            mAccount.setAutoExpandFolderName(folderName);
            mAccount.setInboxFolderName(folderName);
        }

        folderName = getFolderName(specialFoldersMap.get(DAV_MAIL_DRAFTS_FOLDER));
        if (folderName != null)
            mAccount.setDraftsFolderName(folderName);

        folderName = getFolderName(specialFoldersMap.get(DAV_MAIL_TRASH_FOLDER));
        if (folderName != null)
            mAccount.setTrashFolderName(folderName);

        folderName = getFolderName(specialFoldersMap.get(DAV_MAIL_SPAM_FOLDER));
        if (folderName != null)
            mAccount.setSpamFolderName(folderName);

        // K-9 Mail's outbox is a special local folder and different from Exchange/WebDAV's outbox.
        /*
        folderName = getFolderName(specialFoldersMap.get(DAV_MAIL_OUTBOX_FOLDER));
        if (folderName != null)
            mAccount.setOutboxFolderName(folderName);
        */

        folderName = getFolderName(specialFoldersMap.get(DAV_MAIL_SENT_FOLDER));
        if (folderName != null)
            mAccount.setSentFolderName(folderName);

        /**
         * Next we get all the folders (including ""special"" ones)
         */
        headers = new HashMap<String, String>();
        dataset = new DataSet();
        headers.put(""Brief"", ""t"");
        dataset = processRequest(this.mUrl, ""SEARCH"", getFolderListXml(), headers);
        String[] folderUrls = dataset.getHrefs();

        for (int i = 0; i < folderUrls.length; i++) {
            String tempUrl = folderUrls[i];
            WebDavFolder folder = createFolder(tempUrl);
            if (folder != null)
                folderList.add(folder);
        }

        return folderList;
    }

    /**
     * Creates a folder using the URL passed as parameter (only if it has not been
     * already created) and adds this to our store folder map.
     *
     * @param folderUrl
     * @return
     */
    private WebDavFolder createFolder(String folderUrl) {
        if (folderUrl == null)
            return null;

        WebDavFolder wdFolder = null;
        String folderName = getFolderName(folderUrl);
        if (folderName != null) {
            if (!this.mFolderList.containsKey(folderName)) {
                wdFolder = new WebDavFolder(this, folderName);
                wdFolder.setUrl(folderUrl);
                mFolderList.put(folderName, wdFolder);
            }
        }
        // else: Unknown URL format => NO Folder created

        return wdFolder;
    }

    private String getFolderName(String folderUrl) {
        if (folderUrl == null)
            return null;

        // Here we extract the folder name starting from the complete url.
        // folderUrl is in the form http://mail.domain.com/exchange/username/foldername
        // so we need ""foldername"" which is the string after the fifth slash
        int folderSlash = -1;
        for (int j = 0; j < 5; j++) {
            folderSlash = folderUrl.indexOf('/', folderSlash + 1);
            if (folderSlash < 0)
                break;
        }

        if (folderSlash > 0) {
            String folderName;
            String fullPathName;

            // Removes the final slash if present
            if (folderUrl.charAt(folderUrl.length() - 1) == '/')
                fullPathName = folderUrl.substring(folderSlash + 1, folderUrl.length() - 1);
            else
                fullPathName = folderUrl.substring(folderSlash + 1);

            // Decodes the url-encoded folder name (i.e. ""My%20folder"" => ""My Folder""
            try {
                folderName = java.net.URLDecoder.decode(fullPathName, ""UTF-8"");
            } catch (UnsupportedEncodingException uee) {
                /**
                 * If we don't support UTF-8 there's a problem, don't decode
                 * it then
                 */
                folderName = fullPathName;
            }

            return folderName;
        }

        return null;
    }

    @Override
    public Folder getFolder(String name) {
        WebDavFolder folder;

        if ((folder = this.mFolderList.get(name)) == null) {
            folder = new WebDavFolder(this, name);
        }

        return folder;
    }

    public Folder getSendSpoolFolder() throws MessagingException {
        if (mSendFolder == null)
            mSendFolder = getFolder(DAV_MAIL_SEND_FOLDER);

        return mSendFolder;
    }

    @Override
    public boolean isMoveCapable() {
        return true;
    }

    @Override
    public boolean isCopyCapable() {
        return true;
    }

    private String getSpecialFoldersList() {
        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version=\""1.0\"" encoding=\""utf-8\"" standalone=\""no\""?>"");
        buffer.append(""<propfind xmlns=\""DAV:\"">"");
        buffer.append(""<prop>"");
        buffer.append(""<"").append(DAV_MAIL_INBOX_FOLDER).append("" xmlns=\""urn:schemas:httpmail:\""/>"");
        buffer.append(""<"").append(DAV_MAIL_DRAFTS_FOLDER).append("" xmlns=\""urn:schemas:httpmail:\""/>"");
        buffer.append(""<"").append(DAV_MAIL_OUTBOX_FOLDER).append("" xmlns=\""urn:schemas:httpmail:\""/>"");
        buffer.append(""<"").append(DAV_MAIL_SENT_FOLDER).append("" xmlns=\""urn:schemas:httpmail:\""/>"");
        buffer.append(""<"").append(DAV_MAIL_TRASH_FOLDER).append("" xmlns=\""urn:schemas:httpmail:\""/>"");
        // This should always be ##DavMailSubmissionURI## for which we already have a constant
        // buffer.append(""<sendmsg xmlns=\""urn:schemas:httpmail:\""/>"");

        buffer.append(""<"").append(DAV_MAIL_SPAM_FOLDER).append("" xmlns=\""urn:schemas:httpmail:\""/>"");

        buffer.append(""</prop>"");
        buffer.append(""</propfind>"");
        return buffer.toString();
    }

    /***************************************************************
     * WebDAV XML Request body retrieval functions
     */
    private String getFolderListXml() {
        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""DAV:uid\"", \""DAV:ishidden\""\r\n"");
        buffer.append("" FROM SCOPE('hierarchical traversal of \"""").append(this.mUrl).append(""\""')\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=True\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessageCountXml(String messageState) {
        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""DAV:visiblecount\""\r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False AND \""urn:schemas:httpmail:read\""="")
        .append(messageState).append(""\r\n"");
        buffer.append("" GROUP BY \""DAV:ishidden\""\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessageEnvelopeXml(String[] uids) {
        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""DAV:uid\"", \""DAV:getcontentlength\"","");
        buffer.append("" \""urn:schemas:mailheader:mime-version\"","");
        buffer.append("" \""urn:schemas:mailheader:content-type\"","");
        buffer.append("" \""urn:schemas:mailheader:subject\"","");
        buffer.append("" \""urn:schemas:mailheader:date\"","");
        buffer.append("" \""urn:schemas:mailheader:thread-topic\"","");
        buffer.append("" \""urn:schemas:mailheader:thread-index\"","");
        buffer.append("" \""urn:schemas:mailheader:from\"","");
        buffer.append("" \""urn:schemas:mailheader:to\"","");
        buffer.append("" \""urn:schemas:mailheader:in-reply-to\"","");
        buffer.append("" \""urn:schemas:mailheader:cc\"","");
        buffer.append("" \""urn:schemas:httpmail:read\"""");
        buffer.append("" \r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False AND "");
        for (int i = 0, count = uids.length; i < count; i++) {
            if (i != 0) {
                buffer.append(""  OR "");
            }
            buffer.append("" \""DAV:uid\""='"").append(uids[i]).append(""' "");
        }
        buffer.append(""\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessagesXml() {
        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""DAV:uid\""\r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessageUrlsXml(String[] uids) {
        StringBuffer buffer = new StringBuffer(600);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""urn:schemas:httpmail:read\"", \""DAV:uid\""\r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False AND "");
        for (int i = 0, count = uids.length; i < count; i++) {
            if (i != 0) {
                buffer.append(""  OR "");
            }

            buffer.append("" \""DAV:uid\""='"").append(uids[i]).append(""' "");

        }
        buffer.append(""\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessageFlagsXml(String[] uids) throws MessagingException {
        if (uids.length == 0) {
            throw new MessagingException(""Attempt to get flags on 0 length array for uids"");
        }

        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""urn:schemas:httpmail:read\"", \""DAV:uid\""\r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False AND "");

        for (int i = 0, count = uids.length; i < count; i++) {
            if (i != 0) {
                buffer.append("" OR "");
            }
            buffer.append("" \""DAV:uid\""='"").append(uids[i]).append(""' "");
        }
        buffer.append(""\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMarkMessagesReadXml(String[] urls, boolean read) {
        StringBuffer buffer = new StringBuffer(600);
        buffer.append(""<?xml version='1.0' ?>\r\n"");
        buffer.append(""<a:propertyupdate xmlns:a='DAV:' xmlns:b='urn:schemas:httpmail:'>\r\n"");
        buffer.append(""<a:target>\r\n"");
        for (String url : urls) {
            buffer.append("" <a:href>"").append(url).append(""</a:href>\r\n"");
        }
        buffer.append(""</a:target>\r\n"");
        buffer.append(""<a:set>\r\n"");
        buffer.append("" <a:prop>\r\n"");
        buffer.append(""  <b:read>"").append(read ? ""1"" : ""0"").append(""</b:read>\r\n"");
        buffer.append("" </a:prop>\r\n"");
        buffer.append(""</a:set>\r\n"");
        buffer.append(""</a:propertyupdate>\r\n"");
        return buffer.toString();
    }

    // For flag:
    // http://www.devnewsgroups.net/group/microsoft.public.exchange.development/topic27175.aspx
    // ""<m:0x10900003>1</m:0x10900003>"" & _

    private String getMoveOrCopyMessagesReadXml(String[] urls, boolean isMove) {

        String action = (isMove ? ""move"" : ""copy"");
        StringBuffer buffer = new StringBuffer(600);
        buffer.append(""<?xml version='1.0' ?>\r\n"");
        buffer.append(""<a:"").append(action).append("" xmlns:a='DAV:' xmlns:b='urn:schemas:httpmail:'>\r\n"");
        buffer.append(""<a:target>\r\n"");
        for (String url : urls) {
            buffer.append("" <a:href>"").append(url).append(""</a:href>\r\n"");
        }
        buffer.append(""</a:target>\r\n"");

        buffer.append(""</a:"").append(action).append("">\r\n"");
        return buffer.toString();
    }

    /***************************************************************
     * Authentication related methods
     */

    /**
     * Determines which type of authentication Exchange is using and authenticates appropriately.
     *
     * @throws MessagingException
     */
    public boolean authenticate()
    throws MessagingException {
        try {
            if (mAuthentication == AUTH_TYPE_NONE) {
                ConnectionInfo info = doInitialConnection();

                if (info.requiredAuthType == AUTH_TYPE_BASIC) {
                    HttpGeneric request = new HttpGeneric(mUrl);
                    request.setMethod(""GET"");
                    request.setHeader(""Authorization"", mAuthString);

                    WebDavHttpClient httpClient = new WebDavHttpClient();
                    HttpResponse response = httpClient.executeOverride(request, mContext);

                    int statusCode = response.getStatusLine().getStatusCode();
                    if (statusCode >= 200 && statusCode < 300) {
                        mAuthentication = AUTH_TYPE_BASIC;
                    } else if (statusCode == 401) {
                        throw new MessagingException(""Invalid username or password for authentication."");
                    } else {
                        throw new MessagingException(""Error with code "" + response.getStatusLine().getStatusCode() +
                                                     "" during request processing: "" + response.getStatusLine().toString());
                    }
                } else if (info.requiredAuthType == AUTH_TYPE_FORM_BASED) {
                    doFBA(info);
                }
            } else if (mAuthentication == AUTH_TYPE_BASIC) {
                // Nothing to do, we authenticate with every request when
                // using basic authentication.
            } else if (mAuthentication == AUTH_TYPE_FORM_BASED) {
                // Our cookie expired, re-authenticate.
                doFBA(null);
            }
        } catch (IOException ioe) {
            Log.e(K9.LOG_TAG, ""Error during authentication: "" + ioe + ""\nStack: "" + processException(ioe));
            throw new MessagingException(""Error during authentication"", ioe);
        }

        return mAuthentication != AUTH_TYPE_NONE;
    }

    /**
     * Makes the initial connection to Exchange for authentication. Determines the type of authentication necessary for
     * the server.
     *
     * @throws MessagingException
     */
    private ConnectionInfo doInitialConnection()
    throws MessagingException {
        // For our initial connection we are sending an empty GET request to
        // the configured URL, which should be in the following form:
        // https://mail.server.com/Exchange/alias
        //
        // Possible status codes include:
        // 401 - the server uses basic authentication
        // 30x - the server is trying to redirect us to an OWA login
        // 20x - success
        //
        // The latter two indicate form-based authentication.
        ConnectionInfo info = new ConnectionInfo();

        WebDavHttpClient httpClient = getHttpClient();

        HttpGeneric request = new HttpGeneric(mUrl);
        request.setMethod(""GET"");

        try {
            HttpResponse response = httpClient.executeOverride(request, mContext);
            info.statusCode = response.getStatusLine().getStatusCode();

            if (info.statusCode == 401) {
                // 401 is the ""Unauthorized"" status code, meaning the server wants
                // an authentication header for basic authentication.
                info.requiredAuthType = AUTH_TYPE_BASIC;
            } else if ((info.statusCode >= 200 && info.statusCode < 300) || // Success
                       (info.statusCode >= 300 && info.statusCode < 400) || // Redirect
                       (info.statusCode == 440)) { // Unauthorized
                // We will handle all 3 situations the same. First we take an educated
                // guess at where the authorization DLL is located. If this is this
                // doesn't work, then we'll use the redirection URL for OWA login given
                // to us by exchange. We can use this to scrape the location of the
                // authorization URL.
                info.requiredAuthType = AUTH_TYPE_FORM_BASED;

                if (mAuthPath != null && !mAuthPath.equals("""")) {
                    // The user specified their own authentication path, use that.
                    info.guessedAuthUrl = getRoot() + mAuthPath;
                } else {
                    // Use the default path to the authentication dll.
                    info.guessedAuthUrl = getRoot() + ""/exchweb/bin/auth/owaauth.dll"";
                }

                // Determine where the server is trying to redirect us.
                Header location = response.getFirstHeader(""Location"");
                if (location != null) {
                    info.redirectUrl = location.getValue();
                }
            } else {
                throw new IOException(""Error with code "" + info.statusCode + "" during request processing: "" +
                                      response.getStatusLine().toString());
            }
        } catch (SSLException e) {
            throw new CertificateValidationException(e.getMessage(), e);
        } catch (IOException ioe) {
            Log.e(K9.LOG_TAG, ""IOException: "" + ioe + ""\nTrace: "" + processException(ioe));
            throw new MessagingException(""IOException"", ioe);
        }

        return info;
    }

    /**
     * Performs form-based authentication.
     *
     * @throws MessagingException
     */
    public void doFBA(ConnectionInfo info)
    throws IOException, MessagingException {
        // Clear out cookies from any previous authentication.
        mAuthCookies.clear();

        WebDavHttpClient httpClient = getHttpClient();

        String loginUrl;
        if (info != null) {
            loginUrl = info.guessedAuthUrl;
        } else if (mCachedLoginUrl != null && !mCachedLoginUrl.equals("""")) {
            loginUrl = mCachedLoginUrl;
        } else {
            throw new MessagingException(""No valid login URL available for form-based authentication."");
        }

        HttpGeneric request = new HttpGeneric(loginUrl);
        request.setMethod(""POST"");

        // Build the POST data.
        ArrayList<BasicNameValuePair> pairs = new ArrayList<BasicNameValuePair>();
        pairs.add(new BasicNameValuePair(""destination"", mUrl));
        pairs.add(new BasicNameValuePair(""username"", mUsername));
        pairs.add(new BasicNameValuePair(""password"", mPassword));
        pairs.add(new BasicNameValuePair(""flags"", ""0""));
        pairs.add(new BasicNameValuePair(""SubmitCreds"", ""Log+On""));
        pairs.add(new BasicNameValuePair(""forcedownlevel"", ""0""));
        pairs.add(new BasicNameValuePair(""trusted"", ""0""));

        UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(pairs);
        request.setEntity(formEntity);

        HttpResponse response = httpClient.executeOverride(request, mContext);
        boolean authenticated = testAuthenticationResponse(response);
        if (!authenticated) {
            // Check the response from the authentication request above for a form action.
            String formAction = findFormAction(WebDavHttpClient.getUngzippedContent(response.getEntity()));
            if (formAction == null) {
                // If there is no form action, try using our redirect URL from the initial connection.
                if (info != null && info.redirectUrl != null && !info.redirectUrl.equals("""")) {
                    loginUrl = info.redirectUrl;

                    request = new HttpGeneric(loginUrl);
                    request.setMethod(""GET"");

                    response = httpClient.executeOverride(request, mContext);
                    formAction = findFormAction(WebDavHttpClient.getUngzippedContent(response.getEntity()));
                }
            }
            if (formAction != null) {
                try {
                    URI formActionUri = new URI(formAction);
                    URI loginUri = new URI(loginUrl);

                    if (formActionUri.isAbsolute()) {
                        // The form action is an absolute URL, just use it.
                        loginUrl = formAction;
                    } else {
                        // Append the form action to our current URL, minus the file name.
                        String urlPath;
                        if (formAction.startsWith(""/"")) {
                            urlPath = formAction;
                        } else {
                            urlPath = loginUri.getPath();
                            int lastPathPos = urlPath.lastIndexOf('/');
                            if (lastPathPos > -1) {
                                urlPath = urlPath.substring(0, lastPathPos + 1);
                                urlPath = urlPath.concat(formAction);
                            }
                        }

                        // Reconstruct the login URL based on the original login URL and the form action.
                        URI finalUri = new URI(loginUri.getScheme(),
                                               loginUri.getUserInfo(),
                                               loginUri.getHost(),
                                               loginUri.getPort(),
                                               urlPath,
                                               null,
                                               null);
                        loginUrl = finalUri.toString();
                    }

                    // Retry the login using our new URL.
                    request = new HttpGeneric(loginUrl);
                    request.setMethod(""POST"");
                    request.setEntity(formEntity);

                    response = httpClient.executeOverride(request, mContext);
                    authenticated = testAuthenticationResponse(response);
                } catch (URISyntaxException e) {
                    Log.e(K9.LOG_TAG, ""URISyntaxException caught "" + e + ""\nTrace: "" + processException(e));
                    throw new MessagingException(""URISyntaxException caught"", e);
                }
            } else {
                throw new MessagingException(""A valid URL for Exchange authentication could not be found."");
            }
        }

        if (authenticated) {
            mAuthentication = AUTH_TYPE_FORM_BASED;
            mCachedLoginUrl = loginUrl;
        } else {
            throw new MessagingException(""Invalid credentials provided for authentication."");
        }
    }

    /**
     * Searches the specified stream for an HTML form and returns the form's action target.
     *
     * @throws IOException
     */
    private String findFormAction(InputStream istream)
    throws IOException {
        String formAction = null;

        BufferedReader reader = new BufferedReader(new InputStreamReader(istream), 4096);
        String tempText;

        // Read line by line until we find something like: <form action=""owaauth.dll""...>.
        while ((tempText = reader.readLine()) != null &&
                formAction == null) {
            if (tempText.indexOf("" action="") > -1) {
                String[] actionParts = tempText.split("" action="");
                if (actionParts.length > 1 && actionParts[1].length() > 1) {
                    char openQuote = actionParts[1].charAt(0);
                    int closePos = actionParts[1].indexOf(openQuote, 1);
                    if (closePos > 1) {
                        formAction = actionParts[1].substring(1, closePos);
                        // Remove any GET parameters.
                        int quesPos = formAction.indexOf('?');
                        if (quesPos != -1) {
                            formAction = formAction.substring(0, quesPos);
                        }
                    }
                }
            }
        }

        return formAction;
    }

    private boolean testAuthenticationResponse(HttpResponse response)
    throws MessagingException {
        boolean authenticated = false;
        int statusCode = response.getStatusLine().getStatusCode();

        // Exchange 2007 will return a 302 status code no matter what.
        if (((statusCode >= 200 && statusCode < 300) || statusCode == 302) &&
                mAuthCookies != null && !mAuthCookies.getCookies().isEmpty()) {
            // We may be authenticated, we need to send a test request to know for sure.
            // Exchange 2007 adds the same cookies whether the username and password were valid or not.
            ConnectionInfo info = doInitialConnection();
            if (info.statusCode >= 200 && info.statusCode < 300) {
                authenticated = true;
            } else if (info.statusCode == 302) {
                // If we are successfully authenticated, Exchange will try to redirect us to our OWA inbox.
                // Otherwise, it will redirect us to a logon page.
                // Our URL is in the form: https://hostname:port/Exchange/alias.
                // The redirect is in the form: https://hostname:port/owa/alias.
                // Do a simple replace and compare the resulting strings.
                try {
                    String thisPath = new URI(mUrl).getPath();
                    String redirectPath = new URI(info.redirectUrl).getPath();

                    if (!thisPath.endsWith(""/"")) {
                        thisPath = thisPath.concat(""/"");
                    }
                    if (!redirectPath.endsWith(""/"")) {
                        redirectPath = redirectPath.concat(""/"");
                    }

                    if (redirectPath.equalsIgnoreCase(thisPath)) {
                        authenticated = true;
                    } else {
                        int found = thisPath.indexOf('/', 1);
                        if (found != -1) {
                            String replace = thisPath.substring(0, found + 1);
                            redirectPath = redirectPath.replace(""/owa/"", replace);
                            if (redirectPath.equalsIgnoreCase(thisPath)) {
                                authenticated = true;
                            }
                        }
                    }
                } catch (URISyntaxException e) {
                    Log.e(K9.LOG_TAG, ""URISyntaxException caught "" + e + ""\nTrace: "" + processException(e));
                    throw new MessagingException(""URISyntaxException caught"", e);
                }
            }
        }

        return authenticated;
    }

    public CookieStore getAuthCookies() {
        return mAuthCookies;
    }

    public String getAlias() {
        return mAlias;
    }

    public String getUrl() {
        return mUrl;
    }

    public WebDavHttpClient getHttpClient() throws MessagingException {
        if (mHttpClient == null) {
            mHttpClient = new WebDavHttpClient();
            // Disable automatic redirects on the http client.
            mHttpClient.getParams().setBooleanParameter(""http.protocol.handle-redirects"", false);

            // Setup a cookie store for forms-based authentication.
            mContext = new BasicHttpContext();
            mAuthCookies = new BasicCookieStore();
            mContext.setAttribute(ClientContext.COOKIE_STORE, mAuthCookies);

            SchemeRegistry reg = mHttpClient.getConnectionManager().getSchemeRegistry();
            try {
                Scheme s = new Scheme(""https"", new TrustedSocketFactory(mHost, mSecure), 443);
                reg.register(s);
            } catch (NoSuchAlgorithmException nsa) {
                Log.e(K9.LOG_TAG, ""NoSuchAlgorithmException in getHttpClient: "" + nsa);
                throw new MessagingException(""NoSuchAlgorithmException in getHttpClient: "" + nsa);
            } catch (KeyManagementException kme) {
                Log.e(K9.LOG_TAG, ""KeyManagementException in getHttpClient: "" + kme);
                throw new MessagingException(""KeyManagementException in getHttpClient: "" + kme);
            }
        }
        return mHttpClient;
    }

    private InputStream sendRequest(String url, String method, StringEntity messageBody,
                                    HashMap<String, String> headers, boolean tryAuth)
    throws MessagingException {
        InputStream istream = null;

        if (url == null || method == null) {
            return istream;
        }

        WebDavHttpClient httpclient = getHttpClient();

        try {
            int statusCode = -1;
            HttpGeneric httpmethod = new HttpGeneric(url);
            HttpResponse response;
            HttpEntity entity;

            if (messageBody != null) {
                httpmethod.setEntity(messageBody);
            }

            if (headers != null) {
                for (String headerName : headers.keySet()) {
                    httpmethod.setHeader(headerName, headers.get(headerName));
                }
            }

            if (mAuthentication == AUTH_TYPE_NONE) {
                if (!tryAuth || !authenticate()) {
                    throw new MessagingException(""Unable to authenticate in sendRequest()."");
                }
            } else if (mAuthentication == AUTH_TYPE_BASIC) {
                httpmethod.setHeader(""Authorization"", mAuthString);
            }

            httpmethod.setMethod(method);
            response = httpclient.executeOverride(httpmethod, mContext);
            statusCode = response.getStatusLine().getStatusCode();

            entity = response.getEntity();

            if (statusCode == 401) {
                throw new MessagingException(""Invalid username or password for Basic authentication."");
            } else if (statusCode == 440) {
                if (tryAuth && mAuthentication == AUTH_TYPE_FORM_BASED) {
                    // Our cookie expired, re-authenticate.
                    doFBA(null);
                    sendRequest(url, method, messageBody, headers, false);
                } else {
                    throw new MessagingException(""Authentication failure in sendRequest()."");
                }
            } else if (statusCode < 200 || statusCode >= 300) {
                throw new IOException(""Error with code "" + statusCode + "" during request processing: "" +
                                      response.getStatusLine().toString());
            }

            if (entity != null) {
                istream = WebDavHttpClient.getUngzippedContent(entity);
            }
        } catch (UnsupportedEncodingException uee) {
            Log.e(K9.LOG_TAG, ""UnsupportedEncodingException: "" + uee + ""\nTrace: "" + processException(uee));
            throw new MessagingException(""UnsupportedEncodingException"", uee);
        } catch (IOException ioe) {
            Log.e(K9.LOG_TAG, ""IOException: "" + ioe + ""\nTrace: "" + processException(ioe));
            throw new MessagingException(""IOException"", ioe);
        }

        return istream;
    }

    public String getAuthString() {
        return mAuthString;
    }

    /**
     * Performs an httprequest to the supplied url using the supplied method. messageBody and headers are optional as
     * not all requests will need them. There are two signatures to support calls that don't require parsing of the
     * response.
     */
    private DataSet processRequest(String url, String method, String messageBody, HashMap<String, String> headers)
    throws MessagingException {
        return processRequest(url, method, messageBody, headers, true);
    }

    private DataSet processRequest(String url, String method, String messageBody, HashMap<String, String> headers,
                                   boolean needsParsing)
    throws MessagingException {
        DataSet dataset = new DataSet();
        if (K9.DEBUG && K9.DEBUG_PROTOCOL_WEBDAV) {
            Log.v(K9.LOG_TAG, ""processRequest url = '"" + url + ""', method = '"" + method + ""', messageBody = '""
                  + messageBody + ""'"");
        }

        if (url == null ||
                method == null) {
            return dataset;
        }

        getHttpClient();

        try {
            StringEntity messageEntity = null;
            if (messageBody != null) {
                messageEntity = new StringEntity(messageBody);
                messageEntity.setContentType(""text/xml"");
            }
            InputStream istream = sendRequest(url, method, messageEntity, headers, true);
            if (istream != null &&
                    needsParsing) {
                try {
                    SAXParserFactory spf = SAXParserFactory.newInstance();
                    SAXParser sp = spf.newSAXParser();
                    XMLReader xr = sp.getXMLReader();
                    WebDavHandler myHandler = new WebDavHandler();

                    xr.setContentHandler(myHandler);

                    xr.parse(new InputSource(istream));

                    dataset = myHandler.getDataSet();
                } catch (SAXException se) {
                    Log.e(K9.LOG_TAG, ""SAXException in processRequest() "" + se + ""\nTrace: "" + processException(se));
                    throw new MessagingException(""SAXException in processRequest() "", se);
                } catch (ParserConfigurationException pce) {
                    Log.e(K9.LOG_TAG, ""ParserConfigurationException in processRequest() "" + pce + ""\nTrace: ""
                          + processException(pce));
                    throw new MessagingException(""ParserConfigurationException in processRequest() "", pce);
                }

                istream.close();
            }
        } catch (UnsupportedEncodingException uee) {
            Log.e(K9.LOG_TAG, ""UnsupportedEncodingException: "" + uee + ""\nTrace: "" + processException(uee));
            throw new MessagingException(""UnsupportedEncodingException in processRequest() "", uee);
        } catch (IOException ioe) {
            Log.e(K9.LOG_TAG, ""IOException: "" + ioe + ""\nTrace: "" + processException(ioe));
            throw new MessagingException(""IOException in processRequest() "", ioe);
        }

        return dataset;
    }

    /**
     * Returns a string of the stacktrace for a Throwable to allow for easy inline printing of errors.
     */
    private String processException(Throwable t) {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        PrintStream ps = new PrintStream(baos);

        t.printStackTrace(ps);
        ps.close();

        return baos.toString();
    }

    @Override
    public boolean isSendCapable() {
        return true;
    }

    @Override
    public void sendMessages(Message[] messages) throws MessagingException {
        WebDavFolder tmpFolder = (WebDavStore.WebDavFolder) getFolder(mAccount.getDraftsFolderName());
        try {
            tmpFolder.open(OpenMode.READ_WRITE);
            Message[] retMessages = tmpFolder.appendWebDavMessages(messages);

            tmpFolder.moveMessages(retMessages, getSendSpoolFolder());
        } finally {
            if (tmpFolder != null) {
                tmpFolder.close();
            }
        }
    }

    /*************************************************************************
     * Helper and Inner classes
     */

    /**
     * A WebDav Folder
     */
    class WebDavFolder extends Folder {
        private String mName;
        private String mFolderUrl;
        private boolean mIsOpen = false;
        private int mMessageCount = 0;
        private int mUnreadMessageCount = 0;
        private WebDavStore store;

        protected WebDavStore getStore() {
            return store;
        }

        public WebDavFolder(WebDavStore nStore, String name) {
            super(nStore.getAccount());
            store = nStore;
            this.mName = name;

            String encodedName = """";
            try {
                String[] urlParts = name.split(""/"");
                String url = """";
                for (int i = 0, count = urlParts.length; i < count; i++) {
                    if (i != 0) {
                        url = url + ""/"" + java.net.URLEncoder.encode(urlParts[i], ""UTF-8"");
                    } else {
                        url = java.net.URLEncoder.encode(urlParts[i], ""UTF-8"");
                    }
                }
                encodedName = url;
            } catch (UnsupportedEncodingException uee) {
                Log.e(K9.LOG_TAG, ""UnsupportedEncodingException URLEncoding folder name, skipping encoded"");
                encodedName = name;
            }

            encodedName = encodedName.replaceAll(""\\+"", ""%20"");

            this.mFolderUrl = WebDavStore.this.mUrl;
            if (!WebDavStore.this.mUrl.endsWith(""/"")) {
                this.mFolderUrl += ""/"";
            }
            this.mFolderUrl += encodedName;
        }

        public void setUrl(String url) {
            if (url != null) {
                this.mFolderUrl = url;
            }
        }

        @Override
        public void open(OpenMode mode) throws MessagingException {
            getHttpClient();

            this.mIsOpen = true;
        }

        @Override
        public void copyMessages(Message[] messages, Folder folder) throws MessagingException {
            moveOrCopyMessages(messages, folder.getName(), false);
        }

        @Override
        public void moveMessages(Message[] messages, Folder folder) throws MessagingException {
            moveOrCopyMessages(messages, folder.getName(), true);
        }

        @Override
        public void delete(Message[] msgs, String trashFolderName) throws MessagingException {
            moveOrCopyMessages(msgs, trashFolderName, true);
        }

        private void moveOrCopyMessages(Message[] messages, String folderName, boolean isMove)
        throws MessagingException {
            String[] uids = new String[messages.length];

            for (int i = 0, count = messages.length; i < count; i++) {
                uids[i] = messages[i].getUid();
            }
            String messageBody = """";
            HashMap<String, String> headers = new HashMap<String, String>();
            HashMap<String, String> uidToUrl = getMessageUrls(uids);
            String[] urls = new String[uids.length];

            for (int i = 0, count = uids.length; i < count; i++) {
                urls[i] = uidToUrl.get(uids[i]);
                if (urls[i] == null && messages[i] instanceof WebDavMessage) {
                    WebDavMessage wdMessage = (WebDavMessage) messages[i];
                    urls[i] = wdMessage.getUrl();
                }
            }

            messageBody = getMoveOrCopyMessagesReadXml(urls, isMove);
            WebDavFolder destFolder = (WebDavFolder) store.getFolder(folderName);
            headers.put(""Destination"", destFolder.mFolderUrl);
            headers.put(""Brief"", ""t"");
            headers.put(""If-Match"", ""*"");
            String action = (isMove ? ""BMOVE"" : ""BCOPY"");
            Log.i(K9.LOG_TAG, ""Moving "" + messages.length + "" messages to "" + destFolder.mFolderUrl);

            processRequest(mFolderUrl, action, messageBody, headers, false);
        }

        private int getMessageCount(boolean read) throws MessagingException {
            String isRead;
            int messageCount = 0;
            DataSet dataset = new DataSet();
            HashMap<String, String> headers = new HashMap<String, String>();
            String messageBody;

            if (read) {
                isRead = ""True"";
            } else {
                isRead = ""False"";
            }

            messageBody = getMessageCountXml(isRead);
            headers.put(""Brief"", ""t"");
            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);
            if (dataset != null) {
                messageCount = dataset.getMessageCount();
            }

            return messageCount;
        }

        @Override
        public int getMessageCount() throws MessagingException {
            open(OpenMode.READ_WRITE);
            this.mMessageCount = getMessageCount(true);
            return this.mMessageCount;
        }

        @Override
        public int getUnreadMessageCount() throws MessagingException {
            open(OpenMode.READ_WRITE);
            this.mUnreadMessageCount = getMessageCount(false);
            return this.mUnreadMessageCount;
        }

        @Override
        public int getFlaggedMessageCount() throws MessagingException {
            return -1;
        }

        @Override
        public boolean isOpen() {
            return this.mIsOpen;
        }

        @Override
        public OpenMode getMode() {
            return OpenMode.READ_WRITE;
        }

        @Override
        public String getName() {
            return this.mName;
        }

        @Override
        public boolean exists() {
            return true;
        }

        @Override
        public void close() {
            this.mMessageCount = 0;
            this.mUnreadMessageCount = 0;
            this.mIsOpen = false;
        }

        @Override
        public boolean create(FolderType type) throws MessagingException {
            return true;
        }

        @Override
        public void delete(boolean recursive) throws MessagingException {
            throw new Error(""WebDavFolder.delete() not implemeneted"");
        }

        @Override
        public Message getMessage(String uid) throws MessagingException {
            return new WebDavMessage(uid, this);
        }

        @Override
        public Message[] getMessages(int start, int end, Date earliestDate, MessageRetrievalListener listener)
        throws MessagingException {
            ArrayList<Message> messages = new ArrayList<Message>();
            String[] uids;
            DataSet dataset = new DataSet();
            HashMap<String, String> headers = new HashMap<String, String>();
            int uidsLength = -1;

            String messageBody;
            int prevStart = start;

            /** Reverse the message range since 0 index is newest */
            start = this.mMessageCount - end;
            end = start + (end - prevStart);

            if (start < 0 || end < 0 || end < start) {
                throw new MessagingException(String.format(""Invalid message set %d %d"", start, end));
            }

            if (start == 0 && end < 10) {
                end = 10;
            }

            /** Verify authentication */
            messageBody = getMessagesXml();

            headers.put(""Brief"", ""t"");
            headers.put(""Range"", ""rows="" + start + ""-"" + end);
            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);

            uids = dataset.getUids();
            HashMap<String, String> uidToUrl = dataset.getUidToUrl();
            uidsLength = uids.length;

            for (int i = 0; i < uidsLength; i++) {
                if (listener != null) {
                    listener.messageStarted(uids[i], i, uidsLength);
                }
                WebDavMessage message = new WebDavMessage(uids[i], this);
                message.setUrl(uidToUrl.get(uids[i]));
                messages.add(message);

                if (listener != null) {
                    listener.messageFinished(message, i, uidsLength);
                }
            }

            return messages.toArray(EMPTY_MESSAGE_ARRAY);
        }

        @Override
        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException {
            return getMessages(null, listener);
        }

        @Override
        public Message[] getMessages(String[] uids, MessageRetrievalListener listener) throws MessagingException {
            ArrayList<Message> messageList = new ArrayList<Message>();
            Message[] messages;

            if (uids == null ||
                    uids.length == 0) {
                return messageList.toArray(EMPTY_MESSAGE_ARRAY);
            }

            for (int i = 0, count = uids.length; i < count; i++) {
                if (listener != null) {
                    listener.messageStarted(uids[i], i, count);
                }

                WebDavMessage message = new WebDavMessage(uids[i], this);
                messageList.add(message);

                if (listener != null) {
                    listener.messageFinished(message, i, count);
                }
            }
            messages = messageList.toArray(EMPTY_MESSAGE_ARRAY);

            return messages;
        }

        private HashMap<String, String> getMessageUrls(String[] uids) throws MessagingException {
            HashMap<String, String> uidToUrl = new HashMap<String, String>();
            HashMap<String, String> headers = new HashMap<String, String>();
            DataSet dataset = new DataSet();
            String messageBody;

            /** Retrieve and parse the XML entity for our messages */
            messageBody = getMessageUrlsXml(uids);
            headers.put(""Brief"", ""t"");

            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);
            uidToUrl = dataset.getUidToUrl();

            return uidToUrl;
        }

        @Override
        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
        throws MessagingException {
            if (messages == null ||
                    messages.length == 0) {
                return;
            }

            /**
             * Fetch message envelope information for the array
             */
            if (fp.contains(FetchProfile.Item.ENVELOPE)) {
                fetchEnvelope(messages, listener);
            }
            /**
             * Fetch message flag info for the array
             */
            if (fp.contains(FetchProfile.Item.FLAGS)) {
                fetchFlags(messages, listener);
            }

            if (fp.contains(FetchProfile.Item.BODY_SANE)) {
                if (mAccount.getMaximumAutoDownloadMessageSize() > 0) {
                    fetchMessages(messages, listener, (mAccount.getMaximumAutoDownloadMessageSize() / 76));
                } else {
                    fetchMessages(messages, listener, -1);
                }
            }
            if (fp.contains(FetchProfile.Item.BODY)) {
                fetchMessages(messages, listener, -1);
            }
        }

        /**
         * Fetches the full messages or up to lines lines and passes them to the message parser.
         */
        private void fetchMessages(Message[] messages, MessageRetrievalListener listener, int lines)
        throws MessagingException {
            WebDavHttpClient httpclient;
            httpclient = getHttpClient();

            /**
             * We can't hand off to processRequest() since we need the stream to parse.
             */
            for (int i = 0, count = messages.length; i < count; i++) {
                WebDavMessage wdMessage;
                int statusCode = 0;

                if (!(messages[i] instanceof WebDavMessage)) {
                    throw new MessagingException(""WebDavStore fetch called with non-WebDavMessage"");
                }

                wdMessage = (WebDavMessage) messages[i];

                if (listener != null) {
                    listener.messageStarted(wdMessage.getUid(), i, count);
                }

                /**
                 * If fetch is called outside of the initial list (ie, a locally stored message), it may not have a URL
                 * associated. Verify and fix that
                 */
                if (wdMessage.getUrl().equals("""")) {
                    wdMessage.setUrl(getMessageUrls(new String[] { wdMessage.getUid() }).get(wdMessage.getUid()));
                    Log.i(K9.LOG_TAG, ""Fetching messages with UID = '"" + wdMessage.getUid() + ""', URL = '""
                          + wdMessage.getUrl() + ""'"");
                    if (wdMessage.getUrl().equals("""")) {
                        throw new MessagingException(""Unable to get URL for message"");
                    }
                }

                try {
                    Log.i(K9.LOG_TAG, ""Fetching message with UID = '"" + wdMessage.getUid() + ""', URL = '""
                          + wdMessage.getUrl() + ""'"");
                    HttpGet httpget = new HttpGet(new URI(wdMessage.getUrl()));
                    HttpResponse response;
                    HttpEntity entity;

                    httpget.setHeader(""translate"", ""f"");
                    if (mAuthentication == AUTH_TYPE_BASIC) {
                        httpget.setHeader(""Authorization"", mAuthString);
                    }
                    response = httpclient.executeOverride(httpget, mContext);

                    statusCode = response.getStatusLine().getStatusCode();

                    entity = response.getEntity();

                    if (statusCode < 200 ||
                            statusCode > 300) {
                        throw new IOException(""Error during with code "" + statusCode + "" during fetch: ""
                                              + response.getStatusLine().toString());
                    }

                    if (entity != null) {
                        InputStream istream = null;
                        StringBuffer buffer = new StringBuffer();
                        String tempText = """";
                        String resultText = """";
                        BufferedReader reader;
                        int currentLines = 0;

                        istream = WebDavHttpClient.getUngzippedContent(entity);

                        if (lines != -1) {
                            reader = new BufferedReader(new InputStreamReader(istream), 8192);

                            while ((tempText = reader.readLine()) != null &&
                                    (currentLines < lines)) {
                                buffer.append(tempText).append(""\r\n"");
                                currentLines++;
                            }

                            istream.close();
                            resultText = buffer.toString();
                            istream = new ByteArrayInputStream(resultText.getBytes(""UTF-8""));
                        }

                        wdMessage.parse(istream);
                    }

                } catch (IllegalArgumentException iae) {
                    Log.e(K9.LOG_TAG, ""IllegalArgumentException caught "" + iae + ""\nTrace: "" + processException(iae));
                    throw new MessagingException(""IllegalArgumentException caught"", iae);
                } catch (URISyntaxException use) {
                    Log.e(K9.LOG_TAG, ""URISyntaxException caught "" + use + ""\nTrace: "" + processException(use));
                    throw new MessagingException(""URISyntaxException caught"", use);
                } catch (IOException ioe) {
                    Log.e(K9.LOG_TAG, ""Non-success response code loading message, response code was "" + statusCode
                          + ""\nURL: "" + wdMessage.getUrl() + ""\nError: "" + ioe.getMessage() + ""\nTrace: ""
                          + processException(ioe));
                    throw new MessagingException(""Failure code "" + statusCode, ioe);
                }

                if (listener != null) {
                    listener.messageFinished(wdMessage, i, count);
                }
            }
        }

        /**
         * Fetches and sets the message flags for the supplied messages. The idea is to have this be recursive so that
         * we do a series of medium calls instead of one large massive call or a large number of smaller calls.
         */
        private void fetchFlags(Message[] startMessages, MessageRetrievalListener listener) throws MessagingException {
            HashMap<String, Boolean> uidToReadStatus = new HashMap<String, Boolean>();
            HashMap<String, String> headers = new HashMap<String, String>();
            DataSet dataset = new DataSet();
            String messageBody = """";
            Message[] messages = new Message[20];
            String[] uids;

            if (startMessages == null ||
                    startMessages.length == 0) {
                return;
            }

            if (startMessages.length > 20) {
                Message[] newMessages = new Message[startMessages.length - 20];
                for (int i = 0, count = startMessages.length; i < count; i++) {
                    if (i < 20) {
                        messages[i] = startMessages[i];
                    } else {
                        newMessages[i - 20] = startMessages[i];
                    }
                }

                fetchFlags(newMessages, listener);
            } else {
                messages = startMessages;
            }

            uids = new String[messages.length];

            for (int i = 0, count = messages.length; i < count; i++) {
                uids[i] = messages[i].getUid();
            }

            messageBody = getMessageFlagsXml(uids);
            headers.put(""Brief"", ""t"");
            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);

            if (dataset == null) {
                throw new MessagingException(""Data Set from request was null"");
            }

            uidToReadStatus = dataset.getUidToRead();

            for (int i = 0, count = messages.length; i < count; i++) {
                if (!(messages[i] instanceof WebDavMessage)) {
                    throw new MessagingException(""WebDavStore fetch called with non-WebDavMessage"");
                }
                WebDavMessage wdMessage = (WebDavMessage) messages[i];

                if (listener != null) {
                    listener.messageStarted(messages[i].getUid(), i, count);
                }

                wdMessage.setFlagInternal(Flag.SEEN, uidToReadStatus.get(wdMessage.getUid()));

                if (listener != null) {
                    listener.messageFinished(messages[i], i, count);
                }
            }
        }

        /**
         * Fetches and parses the message envelopes for the supplied messages. The idea is to have this be recursive so
         * that we do a series of medium calls instead of one large massive call or a large number of smaller calls.
         * Call it a happy balance
         */
        private void fetchEnvelope(Message[] startMessages, MessageRetrievalListener listener)
        throws MessagingException {
            HashMap<String, ParsedMessageEnvelope> envelopes = new HashMap<String, ParsedMessageEnvelope>();
            HashMap<String, String> headers = new HashMap<String, String>();
            DataSet dataset = new DataSet();
            String messageBody = """";
            String[] uids;
            Message[] messages = new Message[10];

            if (startMessages == null ||
                    startMessages.length == 0) {
                return;
            }

            if (startMessages.length > 10) {
                Message[] newMessages = new Message[startMessages.length - 10];
                for (int i = 0, count = startMessages.length; i < count; i++) {
                    if (i < 10) {
                        messages[i] = startMessages[i];
                    } else {
                        newMessages[i - 10] = startMessages[i];
                    }
                }

                fetchEnvelope(newMessages, listener);
            } else {
                messages = startMessages;
            }

            uids = new String[messages.length];

            for (int i = 0, count = messages.length; i < count; i++) {
                uids[i] = messages[i].getUid();
            }

            messageBody = getMessageEnvelopeXml(uids);
            headers.put(""Brief"", ""t"");
            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);

            envelopes = dataset.getMessageEnvelopes();

            int count = messages.length;
            for (int i = messages.length - 1; i >= 0; i--) {
                if (!(messages[i] instanceof WebDavMessage)) {
                    throw new MessagingException(""WebDavStore fetch called with non-WebDavMessage"");
                }
                WebDavMessage wdMessage = (WebDavMessage) messages[i];

                if (listener != null) {
                    listener.messageStarted(messages[i].getUid(), i, count);
                }

                wdMessage.setNewHeaders(envelopes.get(wdMessage.getUid()));
                wdMessage.setFlagInternal(Flag.SEEN, envelopes.get(wdMessage.getUid()).getReadStatus());

                if (listener != null) {
                    listener.messageFinished(messages[i], i, count);
                }
            }
        }

        @Override
        public Flag[] getPermanentFlags() {
            return PERMANENT_FLAGS;
        }

        @Override
        public void setFlags(Message[] messages, Flag[] flags, boolean value)
        throws MessagingException {
            String[] uids = new String[messages.length];

            for (int i = 0, count = messages.length; i < count; i++) {
                uids[i] = messages[i].getUid();
            }

            for (Flag flag : flags) {
                if (flag == Flag.SEEN) {
                    markServerMessagesRead(uids, value);
                } else if (flag == Flag.DELETED) {
                    deleteServerMessages(uids);
                }
            }
        }

        private void markServerMessagesRead(String[] uids, boolean read) throws MessagingException {
            String messageBody = """";
            HashMap<String, String> headers = new HashMap<String, String>();
            HashMap<String, String> uidToUrl = getMessageUrls(uids);
            String[] urls = new String[uids.length];

            for (int i = 0, count = uids.length; i < count; i++) {
                urls[i] = uidToUrl.get(uids[i]);
            }

            messageBody = getMarkMessagesReadXml(urls, read);
            headers.put(""Brief"", ""t"");
            headers.put(""If-Match"", ""*"");

            processRequest(this.mFolderUrl, ""BPROPPATCH"", messageBody, headers, false);
        }

        private void deleteServerMessages(String[] uids) throws MessagingException {
            HashMap<String, String> uidToUrl = getMessageUrls(uids);

            for (String uid : uids) {
                HashMap<String, String> headers = new HashMap<String, String>();
                String url = uidToUrl.get(uid);
                String destinationUrl = generateDeleteUrl(url);

                /**
                 * If the destination is the same as the origin, assume delete forever
                 */
                if (destinationUrl.equals(url)) {
                    headers.put(""Brief"", ""t"");
                    processRequest(url, ""DELETE"", null, headers, false);
                } else {
                    headers.put(""Destination"", generateDeleteUrl(url));
                    headers.put(""Brief"", ""t"");
                    processRequest(url, ""MOVE"", null, headers, false);
                }
            }
        }

        private String generateDeleteUrl(String startUrl) {
            String[] urlParts = startUrl.split(""/"");
            String filename = urlParts[urlParts.length - 1];
            String finalUrl = WebDavStore.this.mUrl + ""Deleted%20Items/"" + filename;

            return finalUrl;
        }

        @Override
        public void appendMessages(Message[] messages) throws MessagingException {
            appendWebDavMessages(messages);
        }

        public Message[] appendWebDavMessages(Message[] messages) throws MessagingException {
            Message[] retMessages = new Message[messages.length];
            int ind = 0;

            WebDavHttpClient httpclient = getHttpClient();

            for (Message message : messages) {
                HttpGeneric httpmethod;
                HttpResponse response;
                StringEntity bodyEntity;
                int statusCode;

                try {
                    ByteArrayOutputStream out;

                    out = new ByteArrayOutputStream(message.getSize());

                    open(OpenMode.READ_WRITE);
                    EOLConvertingOutputStream msgOut = new EOLConvertingOutputStream(
                        new BufferedOutputStream(out, 1024));
                    message.writeTo(msgOut);
                    msgOut.flush();

                    bodyEntity = new StringEntity(out.toString(), ""UTF-8"");
                    bodyEntity.setContentType(""message/rfc822"");

                    String messageURL = mFolderUrl;
                    if (!messageURL.endsWith(""/"")) {
                        messageURL += ""/"";
                    }
                    messageURL += URLEncoder.encode(message.getUid() + "":"" + System.currentTimeMillis() + "".eml"");

                    Log.i(K9.LOG_TAG, ""Uploading message as "" + messageURL);

                    httpmethod = new HttpGeneric(messageURL);
                    httpmethod.setMethod(""PUT"");
                    httpmethod.setEntity(bodyEntity);

                    String mAuthString = getAuthString();

                    if (mAuthString != null) {
                        httpmethod.setHeader(""Authorization"", mAuthString);
                    }

                    response = httpclient.executeOverride(httpmethod, mContext);
                    statusCode = response.getStatusLine().getStatusCode();

                    if (statusCode < 200 ||
                            statusCode > 300) {
                        throw new IOException(""Error with status code "" + statusCode
                                              + "" while sending/appending message.  Response = ""
                                              + response.getStatusLine().toString() + "" for message "" + messageURL);
                    }
                    WebDavMessage retMessage = new WebDavMessage(message.getUid(), this);

                    retMessage.setUrl(messageURL);
                    retMessages[ind++] = retMessage;
                } catch (Exception e) {
                    throw new MessagingException(""Unable to append"", e);
                }
            }
            return retMessages;
        }

        @Override
        public boolean equals(Object o) {
            return false;
        }

        @Override
        public int hashCode() {
            return super.hashCode();
        }

        @Override
        public String getUidFromMessageId(Message message) throws MessagingException {
            Log.e(K9.LOG_TAG,
                  ""Unimplemented method getUidFromMessageId in WebDavStore.WebDavFolder could lead to duplicate messages ""
                  + "" being uploaded to the Sent folder"");
            return null;
        }

        @Override
        public void setFlags(Flag[] flags, boolean value) throws MessagingException {
            Log.e(K9.LOG_TAG,
                  ""Unimplemented method setFlags(Flag[], boolean) breaks markAllMessagesAsRead and EmptyTrash"");
            // Try to make this efficient by not retrieving all of the messages
        }
    }

    /**
     * A WebDav Message
     */
    class WebDavMessage extends MimeMessage {
        private String mUrl = """";

        WebDavMessage(String uid, Folder folder) {
            this.mUid = uid;
            this.mFolder = folder;
        }

        public void setUrl(String url) {
            // TODO: This is a not as ugly hack (ie, it will actually work)
            // XXX: prevent URLs from getting to us that are broken
            if (!(url.toLowerCase().contains(""http""))) {
                if (!(url.startsWith(""/""))) {
                    url = ""/"" + url;
                }
                url = WebDavStore.this.mUrl + this.mFolder + url;
            }

            String[] urlParts = url.split(""/"");
            int length = urlParts.length;
            String end = urlParts[length - 1];

            this.mUrl = """";
            url = """";

            /**
             * We have to decode, then encode the URL because Exchange likes to not properly encode all characters
             */
            try {
                end = java.net.URLDecoder.decode(end, ""UTF-8"");
                end = java.net.URLEncoder.encode(end, ""UTF-8"");
                end = end.replaceAll(""\\+"", ""%20"");
            } catch (UnsupportedEncodingException uee) {
                Log.e(K9.LOG_TAG, ""UnsupportedEncodingException caught in setUrl: "" + uee + ""\nTrace: ""
                      + processException(uee));
            } catch (IllegalArgumentException iae) {
                Log.e(K9.LOG_TAG, ""IllegalArgumentException caught in setUrl: "" + iae + ""\nTrace: ""
                      + processException(iae));
            }

            for (int i = 0; i < length - 1; i++) {
                if (i != 0) {
                    url = url + ""/"" + urlParts[i];
                } else {
                    url = urlParts[i];
                }
            }

            url = url + ""/"" + end;

            this.mUrl = url;
        }

        public String getUrl() {
            return this.mUrl;
        }

        public void setSize(int size) {
            this.mSize = size;
        }

        @Override
        public void parse(InputStream in) throws IOException, MessagingException {
            super.parse(in);
        }

        public void setFlagInternal(Flag flag, boolean set) throws MessagingException {
            super.setFlag(flag, set);
        }

        public void setNewHeaders(ParsedMessageEnvelope envelope) throws MessagingException {
            String[] headers = envelope.getHeaderList();
            HashMap<String, String> messageHeaders = envelope.getMessageHeaders();

            for (String header : headers) {
                String headerValue = messageHeaders.get(header);
                if (header.equals(""Content-Length"")) {
                    int size = Integer.parseInt(messageHeaders.get(header));
                    this.setSize(size);
                }

                if (headerValue != null &&
                        !headerValue.equals("""")) {
                    this.addHeader(header, headerValue);
                }
            }
        }

        @Override
        public void delete(String trashFolderName) throws MessagingException {
            WebDavFolder wdFolder = (WebDavFolder) getFolder();
            Log.i(K9.LOG_TAG, ""Deleting message by moving to "" + trashFolderName);
            wdFolder.moveMessages(new Message[] { this }, wdFolder.getStore().getFolder(trashFolderName));
        }

        @Override
        public void setFlag(Flag flag, boolean set) throws MessagingException {
            super.setFlag(flag, set);
            mFolder.setFlags(new Message[] { this }, new Flag[] { flag }, set);
        }
    }

    /**
     * XML Parsing Handler Can handle all XML handling needs
     */
    public class WebDavHandler extends DefaultHandler {
        private DataSet mDataSet = new DataSet();
        private Stack<String> mOpenTags = new Stack<String>();

        public DataSet getDataSet() {
            return this.mDataSet;
        }

        @Override
        public void startDocument() throws SAXException {
            this.mDataSet = new DataSet();
        }

        @Override
        public void endDocument() throws SAXException {
            /* Do nothing */
        }

        @Override
        public void startElement(String namespaceURI, String localName,
                                 String qName, Attributes atts) throws SAXException {
            mOpenTags.push(localName);
        }

        @Override
        public void endElement(String namespaceURI, String localName, String qName) {
            mOpenTags.pop();

            /** Reset the hash temp variables */
            if (localName.equals(""response"")) {
                this.mDataSet.finish();
            }
        }

        @Override
        public void characters(char ch[], int start, int length) {
            String value = new String(ch, start, length);
            mDataSet.addValue(value, mOpenTags.peek());
        }
    }

    /**
     * Data set for a single E-Mail message's required headers (the envelope) Only provides accessor methods to the
     * stored data. All processing should be done elsewhere. This is done rather than having multiple hashmaps
     * associating UIDs to values
     */
    public static class ParsedMessageEnvelope {
        /**
         * Holds the mappings from the name returned from Exchange to the MIME format header name
         */
        private final HashMap<String, String> mHeaderMappings = new HashMap<String, String>() {
            {
                put(""mime-version"", ""MIME-Version"");
                put(""content-type"", ""Content-Type"");
                put(""subject"", ""Subject"");
                put(""date"", ""Date"");
                put(""thread-topic"", ""Thread-Topic"");
                put(""thread-index"", ""Thread-Index"");
                put(""from"", ""From"");
                put(""to"", ""To"");
                put(""in-reply-to"", ""In-Reply-To"");
                put(""cc"", ""Cc"");
                put(""getcontentlength"", ""Content-Length"");
            }
        };

        private boolean mReadStatus = false;
        private String mUid = """";
        private HashMap<String, String> mMessageHeaders = new HashMap<String, String>();
        private ArrayList<String> mHeaders = new ArrayList<String>();

        public void addHeader(String field, String value) {
            String headerName = mHeaderMappings.get(field);

            if (headerName != null) {
                this.mMessageHeaders.put(mHeaderMappings.get(field), value);
                this.mHeaders.add(mHeaderMappings.get(field));
            }
        }

        public HashMap<String, String> getMessageHeaders() {
            return this.mMessageHeaders;
        }

        public String[] getHeaderList() {
            return this.mHeaders.toArray(EMPTY_STRING_ARRAY);
        }

        public void setReadStatus(boolean status) {
            this.mReadStatus = status;
        }

        public boolean getReadStatus() {
            return this.mReadStatus;
        }

        public void setUid(String uid) {
            if (uid != null) {
                this.mUid = uid;
            }
        }

        public String getUid() {
            return this.mUid;
        }
    }

    /**
     * Dataset for all XML parses. Data is stored in a single format inside the class and is formatted appropriately
     * depending on the accessor calls made.
     */
    public class DataSet {
        private HashMap<String, HashMap<String, String>> mData = new HashMap<String, HashMap<String, String>>();
        // private HashMap<String, String> mLostData = new HashMap<String, String>();
        private String mUid = """";
        private HashMap<String, String> mTempData = new HashMap<String, String>();

        public void addValue(String value, String tagName) {
            if (tagName.equals(""uid"")) {
                mUid = value;
            }

            if (mTempData.containsKey(tagName)) {
                mTempData.put(tagName, mTempData.get(tagName) + value);
            } else {
                mTempData.put(tagName, value);
            }
        }

        public void finish() {
            if (mUid != null &&
                    mTempData != null) {
                mData.put(mUid, mTempData);
            } else if (mTempData != null) {
                /*
                 * Lost Data are for requests that don't include a message UID. These requests should only have a depth
                 * of one for the response so it will never get stomped over.
                 */
            }

            mUid = """";
            mTempData = new HashMap<String, String>();
        }

        /**
         * Returns a hashmap of special folder name => special folder url
         */
        public HashMap<String, String> getSpecialFolderToUrl() {
            // We return the first (and only) map
            for (HashMap<String, String> folderMap : mData.values()) {
                return folderMap;
            }
            return new HashMap<String, String>();
        }

        /**
         * Returns a hashmap of Message UID => Message Url
         */
        public HashMap<String, String> getUidToUrl() {
            HashMap<String, String> uidToUrl = new HashMap<String, String>();

            for (String uid : mData.keySet()) {
                HashMap<String, String> data = mData.get(uid);
                String value = data.get(""href"");
                if (value != null &&
                        !value.equals("""")) {
                    uidToUrl.put(uid, value);
                }
            }

            return uidToUrl;
        }

        /**
         * Returns a hashmap of Message UID => Read Status
         */
        public HashMap<String, Boolean> getUidToRead() {
            HashMap<String, Boolean> uidToRead = new HashMap<String, Boolean>();

            for (String uid : mData.keySet()) {
                HashMap<String, String> data = mData.get(uid);
                String readStatus = data.get(""read"");
                if (readStatus != null &&
                        !readStatus.equals("""")) {
                    Boolean value = !readStatus.equals(""0"");
                    uidToRead.put(uid, value);
                }
            }

            return uidToRead;
        }

        /**
         * Returns an array of all hrefs (urls) that were received
         */
        public String[] getHrefs() {
            ArrayList<String> hrefs = new ArrayList<String>();

            for (String uid : mData.keySet()) {
                HashMap<String, String> data = mData.get(uid);
                String href = data.get(""href"");
                hrefs.add(href);
            }

            return hrefs.toArray(EMPTY_STRING_ARRAY);
        }

        /**
         * Return an array of all Message UIDs that were received
         */
        public String[] getUids() {
            ArrayList<String> uids = new ArrayList<String>();

            for (String uid : mData.keySet()) {
                uids.add(uid);
            }

            return uids.toArray(EMPTY_STRING_ARRAY);
        }

        /**
         * Returns the message count as it was retrieved
         */
        public int getMessageCount() {
            int messageCount = -1;

            for (String uid : mData.keySet()) {
                HashMap<String, String> data = mData.get(uid);
                String count = data.get(""visiblecount"");

                if (count != null &&
                        !count.equals("""")) {
                    messageCount = Integer.parseInt(count);
                }

            }

            return messageCount;
        }

        /**
         * Returns a HashMap of message UID => ParsedMessageEnvelope
         */
        public HashMap<String, ParsedMessageEnvelope> getMessageEnvelopes() {
            HashMap<String, ParsedMessageEnvelope> envelopes = new HashMap<String, ParsedMessageEnvelope>();

            for (String uid : mData.keySet()) {
                ParsedMessageEnvelope envelope = new ParsedMessageEnvelope();
                HashMap<String, String> data = mData.get(uid);

                if (data != null) {
                    for (String header : data.keySet()) {
                        if (header.equals(""read"")) {
                            String read = data.get(header);
                            Boolean readStatus = !read.equals(""0"");

                            envelope.setReadStatus(readStatus);
                        } else if (header.equals(""date"")) {
                            /**
                             * Exchange doesn't give us rfc822 dates like it claims. The date is in the format:
                             * yyyy-MM-dd'T'HH:mm:ss.SSS<Single digit representation of timezone, so far, all instances
                             * are Z>
                             */
                            String date = data.get(header);
                            date = date.substring(0, date.length() - 1);

                            DateFormat dfInput = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS"", Locale.US);
                            DateFormat dfOutput = new SimpleDateFormat(""EEE, d MMM yy HH:mm:ss Z"", Locale.US);
                            String tempDate = """";

                            try {
                                Date parsedDate = dfInput.parse(date);
                                tempDate = dfOutput.format(parsedDate);
                            } catch (java.text.ParseException pe) {
                                Log.e(K9.LOG_TAG, ""Error parsing date: "" + pe + ""\nTrace: "" + processException(pe));
                            }
                            envelope.addHeader(header, tempDate);
                        } else {
                            envelope.addHeader(header, data.get(header));
                        }
                    }
                }

                envelopes.put(uid, envelope);
            }

            return envelopes;
        }
    }

    /**
     * New HTTP Method that allows changing of the method and generic handling Needed for WebDAV custom methods such as
     * SEARCH and PROPFIND
     */
    public class HttpGeneric extends HttpEntityEnclosingRequestBase {
        public String METHOD_NAME = ""POST"";

        public HttpGeneric() {
            super();
        }

        public HttpGeneric(final URI uri) {
            super();
            setURI(uri);
        }

        /**
         * @throws IllegalArgumentException
         *             if the uri is invalid.
         */
        public HttpGeneric(final String uri) {
            super();

            if (K9.DEBUG) {
                Log.v(K9.LOG_TAG, ""Starting uri = '"" + uri + ""'"");
            }

            String[] urlParts = uri.split(""/"");
            int length = urlParts.length;
            String end = urlParts[length - 1];
            String url = """";

            /**
             * We have to decode, then encode the URL because Exchange likes to not properly encode all characters
             */
            try {
                if (length > 3) {
                    end = java.net.URLDecoder.decode(end, ""UTF-8"");
                    end = java.net.URLEncoder.encode(end, ""UTF-8"");
                    end = end.replaceAll(""\\+"", ""%20"");
                }
            } catch (UnsupportedEncodingException uee) {
                Log.e(K9.LOG_TAG, ""UnsupportedEncodingException caught in HttpGeneric(String uri): "" + uee
                      + ""\nTrace: "" + processException(uee));
            } catch (IllegalArgumentException iae) {
                Log.e(K9.LOG_TAG, ""IllegalArgumentException caught in HttpGeneric(String uri): "" + iae + ""\nTrace: ""
                      + processException(iae));
            }

            for (int i = 0; i < length - 1; i++) {
                if (i != 0) {
                    url = url + ""/"" + urlParts[i];
                } else {
                    url = urlParts[i];
                }
            }
            if (K9.DEBUG && K9.DEBUG_PROTOCOL_WEBDAV) {
                Log.v(K9.LOG_TAG, ""url = '"" + url + ""' length = "" + url.length()
                      + "", end = '"" + end + ""' length = "" + end.length());
            }
            url = url + ""/"" + end;

            Log.i(K9.LOG_TAG, ""url = "" + url);
            setURI(URI.create(url));
        }

        @Override
        public String getMethod() {
            return METHOD_NAME;
        }

        public void setMethod(String method) {
            if (method != null) {
                METHOD_NAME = method;
            }
        }
    }

    public static class WebDavHttpClient extends DefaultHttpClient {
        /*
         * Copyright (C) 2007 The Android Open Source Project
         *
         * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in
         * compliance with the License. You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software distributed under the License is
         * distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
         * the License for the specific language governing permissions and limitations under the License.
         */
        public static void modifyRequestToAcceptGzipResponse(HttpRequest request) {
            Log.i(K9.LOG_TAG, ""Requesting gzipped data"");
            request.addHeader(""Accept-Encoding"", ""gzip"");
        }

        public static InputStream getUngzippedContent(HttpEntity entity)
        throws IOException {
            InputStream responseStream = entity.getContent();
            if (responseStream == null)
                return responseStream;
            Header header = entity.getContentEncoding();
            if (header == null)
                return responseStream;
            String contentEncoding = header.getValue();
            if (contentEncoding == null)
                return responseStream;
            if (contentEncoding.contains(""gzip"")) {
                Log.i(K9.LOG_TAG, ""Response is gzipped"");
                responseStream = new GZIPInputStream(responseStream);
            }
            return responseStream;
        }

        public HttpResponse executeOverride(HttpUriRequest request, HttpContext context)
        throws IOException {
            modifyRequestToAcceptGzipResponse(request);
            return super.execute(request, context);
        }
    }

    /**
     * Simple data container for passing connection information.
     */
    private static class ConnectionInfo {
        public int statusCode;
        public short requiredAuthType;
        public String guessedAuthUrl;
        public String redirectUrl;
    }
}
",True,144,0,0,6,41,3,15,L1
146,com.fsck.k9.mail.store.Pop3Store.java,"
package com.fsck.k9.mail.store;

import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.controller.MessageRetrievalListener;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Folder.OpenMode;
import com.fsck.k9.mail.internet.MimeMessage;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.TrustManager;
import java.io.*;
import java.net.*;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

public class Pop3Store extends Store {
    public static final int CONNECTION_SECURITY_NONE = 0;
    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED };

    private String mHost;
    private int mPort;
    private String mUsername;
    private String mPassword;
    private boolean useCramMd5;
    private int mConnectionSecurity;
    private HashMap<String, Folder> mFolders = new HashMap<String, Folder>();
    private Pop3Capabilities mCapabilities;

    /**
     * This value is {@code true} if the server supports the CAPA command but doesn't advertise
     * support for the TOP command OR if the server doesn't support the CAPA command and we
     * already unsuccessfully tried to use the TOP command.
     */
    private boolean mTopNotSupported;

    /**
     * pop3://user:password@server:port CONNECTION_SECURITY_NONE
     * pop3+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * pop3+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * pop3+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * pop3+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     */
    public Pop3Store(Account account) throws MessagingException {
        super(account);

        URI uri;
        try {
            uri = new URI(mAccount.getStoreUri());
        } catch (URISyntaxException use) {
            throw new MessagingException(""Invalid Pop3Store URI"", use);
        }

        String scheme = uri.getScheme();
        if (scheme.equals(""pop3"")) {
            mConnectionSecurity = CONNECTION_SECURITY_NONE;
            mPort = 110;
        } else if (scheme.equals(""pop3+tls"")) {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
            mPort = 110;
        } else if (scheme.equals(""pop3+tls+"")) {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
            mPort = 110;
        } else if (scheme.equals(""pop3+ssl+"")) {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
            mPort = 995;
        } else if (scheme.equals(""pop3+ssl"")) {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
            mPort = 995;
        } else {
            throw new MessagingException(""Unsupported protocol"");
        }

        mHost = uri.getHost();

        if (uri.getPort() != -1) {
            mPort = uri.getPort();
        }

        useCramMd5 = false;
        if (uri.getUserInfo() != null) {
            try {
                int userIndex = 0, passwordIndex = 1;
                String[] userInfoParts = uri.getUserInfo().split("":"");
                if (userInfoParts.length > 2) {
                    userIndex++;
                    passwordIndex++;
                    useCramMd5 = true;
                }
                mUsername = URLDecoder.decode(userInfoParts[userIndex], ""UTF-8"");
                if (userInfoParts.length > passwordIndex) {
                    mPassword = URLDecoder.decode(userInfoParts[passwordIndex], ""UTF-8"");
                }
            } catch (UnsupportedEncodingException enc) {
                // This shouldn't happen since the encoding is hardcoded to UTF-8
                Log.e(K9.LOG_TAG, ""Couldn't urldecode username or password."", enc);
            }
        }
    }

    @Override
    public Folder getFolder(String name) {
        Folder folder = mFolders.get(name);
        if (folder == null) {
            folder = new Pop3Folder(name);
            mFolders.put(folder.getName(), folder);
        }
        return folder;
    }

    @Override
    public List <? extends Folder > getPersonalNamespaces(boolean forceListAll) throws MessagingException {
        List<Folder> folders = new LinkedList<Folder>();
        folders.add(getFolder(mAccount.getInboxFolderName()));
        return folders;
    }

    @Override
    public void checkSettings() throws MessagingException {
        Pop3Folder folder = new Pop3Folder(mAccount.getInboxFolderName());
        folder.open(OpenMode.READ_WRITE);
        if (!mCapabilities.uidl) {
            /*
             * Run an additional test to see if UIDL is supported on the server. If it's not we
             * can't service this account.
             */

            /*
             * If the server doesn't support UIDL it will return a - response, which causes
             * executeSimpleCommand to throw a MessagingException, exiting this method.
             */
            folder.executeSimpleCommand(""UIDL"");

        }
        folder.close();
    }

    class Pop3Folder extends Folder {
        private Socket mSocket;
        private InputStream mIn;
        private OutputStream mOut;
        private HashMap<String, Pop3Message> mUidToMsgMap = new HashMap<String, Pop3Message>();
        private HashMap<Integer, Pop3Message> mMsgNumToMsgMap = new HashMap<Integer, Pop3Message>();
        private HashMap<String, Integer> mUidToMsgNumMap = new HashMap<String, Integer>();
        private String mName;
        private int mMessageCount;

        public Pop3Folder(String name) {
            super(Pop3Store.this.mAccount);
            this.mName = name;

            if (mName.equalsIgnoreCase(mAccount.getInboxFolderName())) {
                mName = mAccount.getInboxFolderName();
            }
        }

        @Override
        public synchronized void open(OpenMode mode) throws MessagingException {
            if (isOpen()) {
                return;
            }

            if (!mName.equalsIgnoreCase(mAccount.getInboxFolderName())) {
                throw new MessagingException(""Folder does not exist"");
            }

            try {
                SocketAddress socketAddress = new InetSocketAddress(mHost, mPort);
                if (mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
                        mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL) {
                    SSLContext sslContext = SSLContext.getInstance(""TLS"");
                    final boolean secure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
                    sslContext.init(null, new TrustManager[] {
                                        TrustManagerFactory.get(mHost, secure)
                                    }, new SecureRandom());
                    mSocket = sslContext.getSocketFactory().createSocket();
                } else {
                    mSocket = new Socket();
                }

                mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                mIn = new BufferedInputStream(mSocket.getInputStream(), 1024);
                mOut = new BufferedOutputStream(mSocket.getOutputStream(), 512);

                mSocket.setSoTimeout(Store.SOCKET_READ_TIMEOUT);
                if (!isOpen()) {
                    throw new MessagingException(""Unable to connect socket"");
                }

                // Eat the banner
                executeSimpleCommand(null);

                if (mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL
                        || mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED) {
                    mCapabilities = getCapabilities();

                    if (mCapabilities.stls) {
                        writeLine(""STLS"");

                        SSLContext sslContext = SSLContext.getInstance(""TLS"");
                        boolean secure = mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED;
                        sslContext.init(null, new TrustManager[] {
                                            TrustManagerFactory.get(mHost, secure)
                                        }, new SecureRandom());
                        mSocket = sslContext.getSocketFactory().createSocket(mSocket, mHost, mPort,
                                  true);
                        mSocket.setSoTimeout(Store.SOCKET_READ_TIMEOUT);
                        mIn = new BufferedInputStream(mSocket.getInputStream(), 1024);
                        mOut = new BufferedOutputStream(mSocket.getOutputStream(), 512);
                        if (!isOpen()) {
                            throw new MessagingException(""Unable to connect socket"");
                        }
                    } else if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED) {
                        throw new MessagingException(""TLS not supported but required"");
                    }
                }

                if (useCramMd5) {
                    try {
                        String b64Nonce = executeSimpleCommand(""AUTH CRAM-MD5"").replace(""+ "", """");

                        String b64CRAM = Authentication.computeCramMd5(mUsername, mPassword, b64Nonce);
                        executeSimpleCommand(b64CRAM);

                    } catch (MessagingException me) {
                        throw new AuthenticationFailedException(null, me);
                    }
                } else {
                    try {
                        executeSimpleCommand(""USER "" + mUsername);
                        executeSimpleCommand(""PASS "" + mPassword, true);
                    } catch (MessagingException me) {
                        throw new AuthenticationFailedException(null, me);
                    }
                }

                mCapabilities = getCapabilities();
            } catch (SSLException e) {
                throw new CertificateValidationException(e.getMessage(), e);
            } catch (GeneralSecurityException gse) {
                throw new MessagingException(
                    ""Unable to open connection to POP server due to security error."", gse);
            } catch (IOException ioe) {
                throw new MessagingException(""Unable to open connection to POP server."", ioe);
            }

            String response = executeSimpleCommand(""STAT"");
            String[] parts = response.split("" "");
            mMessageCount = Integer.parseInt(parts[1]);

            mUidToMsgMap.clear();
            mMsgNumToMsgMap.clear();
            mUidToMsgNumMap.clear();
        }

        @Override
        public boolean isOpen() {
            return (mIn != null && mOut != null && mSocket != null
                    && mSocket.isConnected() && !mSocket.isClosed());
        }

        @Override
        public OpenMode getMode() {
            return OpenMode.READ_WRITE;
        }

        @Override
        public void close() {
            try {
                if (isOpen()) {
                    executeSimpleCommand(""QUIT"");
                }
            } catch (Exception e) {
                /*
                 * QUIT may fail if the connection is already closed. We don't care. It's just
                 * being friendly.
                 */
            }

            closeIO();
        }

        private void closeIO() {
            try {
                mIn.close();
            } catch (Exception e) {
                /*
                 * May fail if the connection is already closed.
                 */
            }
            try {
                mOut.close();
            } catch (Exception e) {
                /*
                 * May fail if the connection is already closed.
                 */
            }
            try {
                mSocket.close();
            } catch (Exception e) {
                /*
                 * May fail if the connection is already closed.
                 */
            }
            mIn = null;
            mOut = null;
            mSocket = null;
        }

        @Override
        public String getName() {
            return mName;
        }

        @Override
        public boolean create(FolderType type) throws MessagingException {
            return false;
        }

        @Override
        public boolean exists() throws MessagingException {
            return mName.equalsIgnoreCase(mAccount.getInboxFolderName());
        }

        @Override
        public int getMessageCount() {
            return mMessageCount;
        }

        @Override
        public int getUnreadMessageCount() throws MessagingException {
            return -1;
        }
        @Override
        public int getFlaggedMessageCount() throws MessagingException {
            return -1;
        }

        @Override
        public Message getMessage(String uid) throws MessagingException {
            Pop3Message message = mUidToMsgMap.get(uid);
            if (message == null) {
                message = new Pop3Message(uid, this);
            }
            return message;
        }

        @Override
        public Message[] getMessages(int start, int end, Date earliestDate, MessageRetrievalListener listener)
        throws MessagingException {
            if (start < 1 || end < 1 || end < start) {
                throw new MessagingException(String.format(""Invalid message set %d %d"",
                                             start, end));
            }
            try {
                indexMsgNums(start, end);
            } catch (IOException ioe) {
                throw new MessagingException(""getMessages"", ioe);
            }
            ArrayList<Message> messages = new ArrayList<Message>();
            int i = 0;
            for (int msgNum = start; msgNum <= end; msgNum++) {
                Pop3Message message = mMsgNumToMsgMap.get(msgNum);
                if (message == null) {
                    /*
                     * There could be gaps in the message numbers or malformed
                     * responses which lead to ""gaps"" in mMsgNumToMsgMap.
                     *
                     * See issue 2252
                     */
                    continue;
                }

                if (listener != null) {
                    listener.messageStarted(message.getUid(), i++, (end - start) + 1);
                }
                messages.add(message);
                if (listener != null) {
                    listener.messageFinished(message, i++, (end - start) + 1);
                }
            }
            return messages.toArray(new Message[messages.size()]);
        }

        /**
         * Ensures that the given message set (from start to end inclusive)
         * has been queried so that uids are available in the local cache.
         * @param start
         * @param end
         * @throws MessagingException
         * @throws IOException
         */
        private void indexMsgNums(int start, int end)
        throws MessagingException, IOException {
            int unindexedMessageCount = 0;
            for (int msgNum = start; msgNum <= end; msgNum++) {
                if (mMsgNumToMsgMap.get(msgNum) == null) {
                    unindexedMessageCount++;
                }
            }
            if (unindexedMessageCount == 0) {
                return;
            }
            if (unindexedMessageCount < 50 && mMessageCount > 5000) {
                /*
                 * In extreme cases we'll do a UIDL command per message instead of a bulk
                 * download.
                 */
                for (int msgNum = start; msgNum <= end; msgNum++) {
                    Pop3Message message = mMsgNumToMsgMap.get(msgNum);
                    if (message == null) {
                        String response = executeSimpleCommand(""UIDL "" + msgNum);
                        int uidIndex = response.lastIndexOf(' ');
                        String msgUid = response.substring(uidIndex + 1);
                        message = new Pop3Message(msgUid, this);
                        indexMessage(msgNum, message);
                    }
                }
            } else {
                String response = executeSimpleCommand(""UIDL"");
                while ((response = readLine()) != null) {
                    if (response.equals(""."")) {
                        break;
                    }
                    String[] uidParts = response.split("" "");
                    if ((uidParts.length >= 3) && ""+OK"".equals(uidParts[0])) {
                        /*
                         * At least one server software places a ""+OK"" in
                         * front of every line in the unique-id listing.
                         *
                         * Fix up the array if we detected this behavior.
                         * See Issue 1237
                         */
                        uidParts[0] = uidParts[1];
                        uidParts[1] = uidParts[2];
                    }
                    if (uidParts.length >= 2) {
                        Integer msgNum = Integer.valueOf(uidParts[0]);
                        String msgUid = uidParts[1];
                        if (msgNum >= start && msgNum <= end) {
                            Pop3Message message = mMsgNumToMsgMap.get(msgNum);
                            if (message == null) {
                                message = new Pop3Message(msgUid, this);
                                indexMessage(msgNum, message);
                            }
                        }
                    }
                }
            }
        }

        private void indexUids(ArrayList<String> uids)
        throws MessagingException, IOException {
            HashSet<String> unindexedUids = new HashSet<String>();
            for (String uid : uids) {
                if (mUidToMsgMap.get(uid) == null) {
                    if (K9.DEBUG && K9.DEBUG_PROTOCOL_POP3) {
                        Log.d(K9.LOG_TAG, ""Need to index UID "" + uid);
                    }
                    unindexedUids.add(uid);
                }
            }
            if (unindexedUids.size() == 0) {
                return;
            }
            /*
             * If we are missing uids in the cache the only sure way to
             * get them is to do a full UIDL list. A possible optimization
             * would be trying UIDL for the latest X messages and praying.
             */
            String response = executeSimpleCommand(""UIDL"");
            while ((response = readLine()) != null) {
                if (response.equals(""."")) {
                    break;
                }
                String[] uidParts = response.split("" "");

                // Ignore messages without a unique-id
                if (uidParts.length >= 2) {
                    Integer msgNum = Integer.valueOf(uidParts[0]);
                    String msgUid = uidParts[1];
                    if (unindexedUids.contains(msgUid)) {
                        if (K9.DEBUG && K9.DEBUG_PROTOCOL_POP3) {
                            Log.d(K9.LOG_TAG, ""Got msgNum "" + msgNum + "" for UID "" + msgUid);
                        }

                        Pop3Message message = mUidToMsgMap.get(msgUid);
                        if (message == null) {
                            message = new Pop3Message(msgUid, this);
                        }
                        indexMessage(msgNum, message);
                    }
                }
            }
        }

        private void indexMessage(int msgNum, Pop3Message message) {
            if (K9.DEBUG && K9.DEBUG_PROTOCOL_POP3) {
                Log.d(K9.LOG_TAG, ""Adding index for UID "" + message.getUid() + "" to msgNum "" + msgNum);
            }
            mMsgNumToMsgMap.put(msgNum, message);
            mUidToMsgMap.put(message.getUid(), message);
            mUidToMsgNumMap.put(message.getUid(), msgNum);
        }

        @Override
        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException {
            throw new UnsupportedOperationException(""Pop3: No getMessages"");
        }

        @Override
        public Message[] getMessages(String[] uids, MessageRetrievalListener listener)
        throws MessagingException {
            throw new UnsupportedOperationException(""Pop3: No getMessages by uids"");
        }

        /**
         * Fetch the items contained in the FetchProfile into the given set of
         * Messages in as efficient a manner as possible.
         * @param messages
         * @param fp
         * @throws MessagingException
         */
        @Override
        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
        throws MessagingException {
            if (messages == null || messages.length == 0) {
                return;
            }
            ArrayList<String> uids = new ArrayList<String>();
            for (Message message : messages) {
                uids.add(message.getUid());
            }
            try {
                indexUids(uids);
            } catch (IOException ioe) {
                throw new MessagingException(""fetch"", ioe);
            }
            try {
                if (fp.contains(FetchProfile.Item.ENVELOPE)) {
                    /*
                     * We pass the listener only if there are other things to do in the
                     * FetchProfile. Since fetchEnvelop works in bulk and eveything else
                     * works one at a time if we let fetchEnvelope send events the
                     * event would get sent twice.
                     */
                    fetchEnvelope(messages, fp.size() == 1 ? listener : null);
                }
            } catch (IOException ioe) {
                throw new MessagingException(""fetch"", ioe);
            }
            for (int i = 0, count = messages.length; i < count; i++) {
                Message message = messages[i];
                if (!(message instanceof Pop3Message)) {
                    throw new MessagingException(""Pop3Store.fetch called with non-Pop3 Message"");
                }
                Pop3Message pop3Message = (Pop3Message)message;
                try {
                    if (listener != null && !fp.contains(FetchProfile.Item.ENVELOPE)) {
                        listener.messageStarted(pop3Message.getUid(), i, count);
                    }
                    if (fp.contains(FetchProfile.Item.BODY)) {
                        fetchBody(pop3Message, -1);
                    } else if (fp.contains(FetchProfile.Item.BODY_SANE)) {
                        /*
                         * To convert the suggested download size we take the size
                         * divided by the maximum line size (76).
                         */
                        if (mAccount.getMaximumAutoDownloadMessageSize() > 0) {
                            fetchBody(pop3Message,
                                      (mAccount.getMaximumAutoDownloadMessageSize() / 76));
                        } else {
                            fetchBody(pop3Message, -1);
                        }
                    } else if (fp.contains(FetchProfile.Item.STRUCTURE)) {
                        /*
                         * If the user is requesting STRUCTURE we are required to set the body
                         * to null since we do not support the function.
                         */
                        pop3Message.setBody(null);
                    }
                    if (listener != null && !(fp.contains(FetchProfile.Item.ENVELOPE) && fp.size() == 1)) {
                        listener.messageFinished(message, i, count);
                    }
                } catch (IOException ioe) {
                    throw new MessagingException(""Unable to fetch message"", ioe);
                }
            }
        }

        private void fetchEnvelope(Message[] messages,
                                   MessageRetrievalListener listener)  throws IOException, MessagingException {
            int unsizedMessages = 0;
            for (Message message : messages) {
                if (message.getSize() == -1) {
                    unsizedMessages++;
                }
            }
            if (unsizedMessages == 0) {
                return;
            }
            if (unsizedMessages < 50 && mMessageCount > 5000) {
                /*
                 * In extreme cases we'll do a command per message instead of a bulk request
                 * to hopefully save some time and bandwidth.
                 */
                for (int i = 0, count = messages.length; i < count; i++) {
                    Message message = messages[i];
                    if (!(message instanceof Pop3Message)) {
                        throw new MessagingException(""Pop3Store.fetch called with non-Pop3 Message"");
                    }
                    Pop3Message pop3Message = (Pop3Message)message;
                    if (listener != null) {
                        listener.messageStarted(pop3Message.getUid(), i, count);
                    }
                    String response = executeSimpleCommand(String.format(""LIST %d"",
                                                           mUidToMsgNumMap.get(pop3Message.getUid())));
                    String[] listParts = response.split("" "");
                    //int msgNum = Integer.parseInt(listParts[1]);
                    int msgSize = Integer.parseInt(listParts[2]);
                    pop3Message.setSize(msgSize);
                    if (listener != null) {
                        listener.messageFinished(pop3Message, i, count);
                    }
                }
            } else {
                HashSet<String> msgUidIndex = new HashSet<String>();
                for (Message message : messages) {
                    msgUidIndex.add(message.getUid());
                }
                int i = 0, count = messages.length;
                String response = executeSimpleCommand(""LIST"");
                while ((response = readLine()) != null) {
                    if (response.equals(""."")) {
                        break;
                    }
                    String[] listParts = response.split("" "");
                    int msgNum = Integer.parseInt(listParts[0]);
                    int msgSize = Integer.parseInt(listParts[1]);
                    Pop3Message pop3Message = mMsgNumToMsgMap.get(msgNum);
                    if (pop3Message != null && msgUidIndex.contains(pop3Message.getUid())) {
                        if (listener != null) {
                            listener.messageStarted(pop3Message.getUid(), i, count);
                        }
                        pop3Message.setSize(msgSize);
                        if (listener != null) {
                            listener.messageFinished(pop3Message, i, count);
                        }
                        i++;
                    }
                }
            }
        }

        /**
         * Fetches the body of the given message, limiting the downloaded data to the specified
         * number of lines if possible.
         *
         * If lines is -1 the entire message is fetched. This is implemented with RETR for
         * lines = -1 or TOP for any other value. If the server does not support TOP, RETR is used
         * instead.
         */
        private void fetchBody(Pop3Message message, int lines)
        throws IOException, MessagingException {
            String response = null;

            // Try hard to use the TOP command if we're not asked to download the whole message.
            if (lines != -1 && (!mTopNotSupported || mCapabilities.top)) {
                try {
                    if (K9.DEBUG && K9.DEBUG_PROTOCOL_POP3 && !mCapabilities.top) {
                        Log.d(K9.LOG_TAG, ""This server doesn't support the CAPA command. "" +
                              ""Checking to see if the TOP command is supported nevertheless."");
                    }

                    response = executeSimpleCommand(String.format(""TOP %d %d"",
                                                    mUidToMsgNumMap.get(message.getUid()), lines));

                    // TOP command is supported. Remember this for the next time.
                    mCapabilities.top = true;
                } catch (Pop3ErrorResponse e) {
                    if (mCapabilities.top) {
                        // The TOP command should be supported but something went wrong.
                        throw e;
                    } else {
                        if (K9.DEBUG && K9.DEBUG_PROTOCOL_POP3) {
                            Log.d(K9.LOG_TAG, ""The server really doesn't support the TOP "" +
                                  ""command. Using RETR instead."");
                        }

                        // Don't try to use the TOP command again.
                        mTopNotSupported = true;
                    }
                }
            }

            if (response == null) {
                response = executeSimpleCommand(String.format(""RETR %d"",
                                                mUidToMsgNumMap.get(message.getUid())));
            }

            try {
                message.parse(new Pop3ResponseInputStream(mIn));

                // TODO: if we've received fewer lines than requested we also have the complete message.
                if (lines == -1 || !mCapabilities.top) {
                    message.setFlag(Flag.X_DOWNLOADED_FULL, true);
                }
            } catch (MessagingException me) {
                /*
                 * If we're only downloading headers it's possible
                 * we'll get a broken MIME message which we're not
                 * real worried about. If we've downloaded the body
                 * and can't parse it we need to let the user know.
                 */
                if (lines == -1) {
                    throw me;
                }
            }
        }

        @Override
        public Flag[] getPermanentFlags() {
            return PERMANENT_FLAGS;
        }

        @Override
        public void appendMessages(Message[] messages) throws MessagingException {
        }

        @Override
        public void delete(boolean recurse) throws MessagingException {
        }

        @Override
        public void delete(Message[] msgs, String trashFolderName) throws MessagingException {
            setFlags(msgs, new Flag[] { Flag.DELETED }, true);
        }

        @Override
        public String getUidFromMessageId(Message message) throws MessagingException {
            return null;
        }

        @Override
        public void setFlags(Flag[] flags, boolean value) throws MessagingException {
            throw new UnsupportedOperationException(""POP3: No setFlags(Flag[],boolean)"");
        }

        @Override
        public void setFlags(Message[] messages, Flag[] flags, boolean value)
        throws MessagingException {
            if (!value || !Utility.arrayContains(flags, Flag.DELETED)) {
                /*
                 * The only flagging we support is setting the Deleted flag.
                 */
                return;
            }
            ArrayList<String> uids = new ArrayList<String>();
            try {
                for (Message message : messages) {
                    uids.add(message.getUid());
                }

                indexUids(uids);
            } catch (IOException ioe) {
                throw new MessagingException(""Could not get message number for uid "" + uids, ioe);
            }
            for (Message message : messages) {

                Integer msgNum = mUidToMsgNumMap.get(message.getUid());
                if (msgNum == null) {
                    MessagingException me = new MessagingException(""Could not delete message "" + message.getUid()
                            + "" because no msgNum found; permanent error"");
                    me.setPermanentFailure(true);
                    throw me;
                }
                executeSimpleCommand(String.format(""DELE %s"", msgNum));
            }
        }

        private String readLine() throws IOException {
            StringBuffer sb = new StringBuffer();
            int d = mIn.read();
            if (d == -1) {
                throw new IOException(""End of stream reached while trying to read line."");
            }
            do {
                if (((char)d) == '\r') {
                    continue;
                } else if (((char)d) == '\n') {
                    break;
                } else {
                    sb.append((char)d);
                }
            } while ((d = mIn.read()) != -1);
            String ret = sb.toString();
            if (K9.DEBUG && K9.DEBUG_PROTOCOL_POP3) {
                Log.d(K9.LOG_TAG, ""<<< "" + ret);
            }
            return ret;
        }

        private void writeLine(String s) throws IOException {
            mOut.write(s.getBytes());
            mOut.write('\r');
            mOut.write('\n');
            mOut.flush();
        }

        private Pop3Capabilities getCapabilities() throws IOException {
            Pop3Capabilities capabilities = new Pop3Capabilities();
            try {
                String response = executeSimpleCommand(""CAPA"");
                while ((response = readLine()) != null) {
                    if (response.equals(""."")) {
                        break;
                    }
                    if (response.equalsIgnoreCase(""STLS"")) {
                        capabilities.stls = true;
                    } else if (response.equalsIgnoreCase(""UIDL"")) {
                        capabilities.uidl = true;
                    } else if (response.equalsIgnoreCase(""PIPELINING"")) {
                        capabilities.pipelining = true;
                    } else if (response.equalsIgnoreCase(""USER"")) {
                        capabilities.user = true;
                    } else if (response.equalsIgnoreCase(""TOP"")) {
                        capabilities.top = true;
                    }
                }

                if (!capabilities.top) {
                    /*
                     * If the CAPA command is supported but it doesn't advertise support for the
                     * TOP command, we won't check for it manually.
                     */
                    mTopNotSupported = true;
                }
            } catch (MessagingException me) {
                /*
                 * The server may not support the CAPA command, so we just eat this Exception
                 * and allow the empty capabilities object to be returned.
                 */
            }
            return capabilities;
        }

        private String executeSimpleCommand(String command) throws MessagingException {
            return executeSimpleCommand(command, false);
        }

        private String executeSimpleCommand(String command, boolean sensitive) throws MessagingException {
            try {
                open(OpenMode.READ_WRITE);

                if (command != null) {
                    if (K9.DEBUG && K9.DEBUG_PROTOCOL_POP3) {
                        if (sensitive && !K9.DEBUG_SENSITIVE) {
                            Log.d(K9.LOG_TAG, "">>> ""
                                  + ""[Command Hidden, Enable Sensitive Debug Logging To Show]"");
                        } else {
                            Log.d(K9.LOG_TAG, "">>> "" + command);
                        }
                    }

                    writeLine(command);
                }

                String response = readLine();
                if (response.length() > 1 && response.charAt(0) == '-') {
                    throw new Pop3ErrorResponse(response);
                }

                return response;
            } catch (MessagingException me) {
                throw me;
            } catch (Exception e) {
                closeIO();
                throw new MessagingException(""Unable to execute POP3 command"", e);
            }
        }

        @Override
        public boolean isFlagSupported(Flag flag) {
            return (flag == Flag.DELETED);
        }

        @Override
        public boolean supportsFetchingFlags() {
            return false;
        }

        @Override
        public boolean equals(Object o) {
            if (o instanceof Pop3Folder) {
                return ((Pop3Folder) o).mName.equals(mName);
            }
            return super.equals(o);
        }

        @Override
        public int hashCode() {
            return mName.hashCode();
        }

    }//Pop3Folder

    static class Pop3Message extends MimeMessage {
        public Pop3Message(String uid, Pop3Folder folder) {
            mUid = uid;
            mFolder = folder;
            mSize = -1;
        }

        public void setSize(int size) {
            mSize = size;
        }

        @Override
        protected void parse(InputStream in) throws IOException, MessagingException {
            super.parse(in);
        }

        @Override
        public void setFlag(Flag flag, boolean set) throws MessagingException {
            super.setFlag(flag, set);
            mFolder.setFlags(new Message[] { this }, new Flag[] { flag }, set);
        }

        @Override
        public void delete(String trashFolderName) throws MessagingException {
            //  try
            //  {
            //  Poor POP3 users, we can't copy the message to the Trash folder, but they still want a delete
            setFlag(Flag.DELETED, true);
            //   }
//         catch (MessagingException me)
//         {
//          Log.w(K9.LOG_TAG, ""Could not delete non-existant message"", me);
//         }
        }
    }

    static class Pop3Capabilities {
        public boolean stls;
        public boolean top;
        public boolean user;
        public boolean uidl;
        public boolean pipelining;

        @Override
        public String toString() {
            return String.format(""STLS %b, TOP %b, USER %b, UIDL %b, PIPELINING %b"",
                                 stls,
                                 top,
                                 user,
                                 uidl,
                                 pipelining);
        }
    }

    static class Pop3ResponseInputStream extends InputStream {
        InputStream mIn;
        boolean mStartOfLine = true;
        boolean mFinished;

        public Pop3ResponseInputStream(InputStream in) {
            mIn = in;
        }

        @Override
        public int read() throws IOException {
            if (mFinished) {
                return -1;
            }
            int d = mIn.read();
            if (mStartOfLine && d == '.') {
                d = mIn.read();
                if (d == '\r') {
                    mFinished = true;
                    mIn.read();
                    return -1;
                }
            }

            mStartOfLine = (d == '\n');

            return d;
        }
    }

    /**
     * Exception that is thrown if the server returns an error response.
     */
    static class Pop3ErrorResponse extends MessagingException {
        public Pop3ErrorResponse(String message) {
            super(message, true);
        }
    }
}
",True,144,0,0,6,39,1,16,L1
147,com.fsck.k9.mail.store.ImapResponseParser.java,"package com.fsck.k9.mail.store;

import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.filter.FixedLengthInputStream;
import com.fsck.k9.mail.filter.PeekableInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Locale;

public class ImapResponseParser {
    private static final SimpleDateFormat mDateTimeFormat = new SimpleDateFormat(""dd-MMM-yyyy HH:mm:ss Z"", Locale.US);
    private static final SimpleDateFormat badDateTimeFormat = new SimpleDateFormat(""dd MMM yyyy HH:mm:ss Z"", Locale.US);
    private static final SimpleDateFormat badDateTimeFormat2 = new SimpleDateFormat(""E, dd MMM yyyy HH:mm:ss Z"", Locale.US);
    private static final SimpleDateFormat badDateTimeFormat3 = new SimpleDateFormat(""dd-MMM-yyyy HH:mm:ss"", Locale.US);

    private PeekableInputStream mIn;
    private ImapResponse mResponse;
    private Exception mException;

    public ImapResponseParser(PeekableInputStream in) {
        this.mIn = in;
    }

    public ImapResponse readResponse() throws IOException {
        return readResponse(null);
    }

    /**
     * Reads the next response available on the stream and returns an
     * ImapResponse object that represents it.
     */
    public ImapResponse readResponse(IImapResponseCallback callback) throws IOException {
        try {
            ImapResponse response = new ImapResponse();
            mResponse = response;
            mResponse.mCallback = callback;

            int ch = mIn.peek();
            if (ch == '*') {
                parseUntaggedResponse();
                readTokens(response);
            } else if (ch == '+') {
                response.mCommandContinuationRequested =
                    parseCommandContinuationRequest();
                //TODO: Add special ""resp-text"" parsing
                readTokens(response);
            } else {
                response.mTag = parseTaggedResponse();
                readTokens(response);
            }

            if (mException != null) {
                throw new RuntimeException(""readResponse(): Exception in callback method"", mException);
            }

            return response;
        } finally {
            mResponse.mCallback = null;
            mResponse = null;
            mException = null;
        }
    }

    private void readTokens(ImapResponse response) throws IOException {
        response.clear();
        Object token;
        while ((token = readToken(response)) != null) {
            if (!(token instanceof ImapList)) {
                response.add(token);
            }

            /*
             * TODO: Check for responses (""OK"", ""PREAUTH"", ""BYE"", ""NO"", ""BAD"")
             * that can contain resp-text tokens. If found, hand over to a special
             * method that parses a resp-text token. There's no need to use
             * readToken()/parseToken() on that data.
             *
             * See RFC 3501, Section 9 Formal Syntax (resp-text)
             */
        }
        response.mCompleted = true;
    }

    /**
     * Reads the next token of the response. The token can be one of: String -
     * for NIL, QUOTED, NUMBER, ATOM. Object - for LITERAL.
     * ImapList - for PARENTHESIZED LIST. Can contain any of the above
     * elements including List.
     *
     * @return The next token in the response or null if there are no more
     *         tokens.
     */
    private Object readToken(ImapResponse response) throws IOException {
        while (true) {
            Object token = parseToken(response);
            if (token == null || !(token.equals("")"") || token.equals(""]""))) {
                return token;
            }
        }
    }

    private Object parseToken(ImapList parent) throws IOException {
        while (true) {
            int ch = mIn.peek();
            if (ch == '(') {
                return parseList(parent);
            } else if (ch == '[') {
                return parseSequence(parent);
            } else if (ch == ')') {
                expect(')');
                return "")"";
            } else if (ch == ']') {
                expect(']');
                return ""]"";
            } else if (ch == '""') {
                return parseQuoted();
            } else if (ch == '{') {
                return parseLiteral();
            } else if (ch == ' ') {
                expect(' ');
            } else if (ch == '\r') {
                expect('\r');
                expect('\n');
                return null;
            } else if (ch == '\n') {
                expect('\n');
                return null;
            } else if (ch == '\t') {
                expect('\t');
            } else {
                return parseAtom();
            }
        }
    }

    private boolean parseCommandContinuationRequest() throws IOException {
        expect('+');
        return true;
    }

    // * OK [UIDNEXT 175] Predicted next UID
    private void parseUntaggedResponse() throws IOException {
        expect('*');
        expect(' ');
    }

    // 3 OK [READ-WRITE] Select completed.
    private String parseTaggedResponse() throws IOException {
        String tag = readStringUntil(' ');
        return tag;
    }

    private ImapList parseList(ImapList parent) throws IOException {
        expect('(');
        ImapList list = new ImapList();
        parent.add(list);
        Object token;
        while (true) {
            token = parseToken(list);
            if (token == null) {
                return null;
            } else if (token.equals("")"")) {
                break;
            } else if (token instanceof ImapList) {
                // Do nothing
            } else {
                list.add(token);
            }
        }
        return list;
    }

    private ImapList parseSequence(ImapList parent) throws IOException {
        expect('[');
        ImapList list = new ImapList();
        parent.add(list);
        Object token;
        while (true) {
            token = parseToken(list);
            if (token == null) {
                return null;
            } else if (token.equals(""]"")) {
                break;
            } else if (token instanceof ImapList) {
                // Do nothing
            } else {
                list.add(token);
            }
        }
        return list;
    }

    private String parseAtom() throws IOException {
        StringBuilder sb = new StringBuilder();
        int ch;
        while (true) {
            ch = mIn.peek();
            if (ch == -1) {
                throw new IOException(""parseAtom(): end of stream reached"");
            } else if (ch == '(' || ch == ')' || ch == '{' || ch == ' ' ||
                       ch == '[' || ch == ']' ||
                       // docs claim that flags are \ atom but atom isn't supposed to
                       // contain
                       // * and some falgs contain *
                       // ch == '%' || ch == '*' ||
//                    ch == '%' ||
                       // TODO probably should not allow \ and should recognize
                       // it as a flag instead
                       // ch == '""' || ch == '\' ||
                       ch == '""' || (ch >= 0x00 && ch <= 0x1f) || ch == 0x7f) {
                if (sb.length() == 0) {
                    throw new IOException(String.format(""parseAtom(): (%04x %c)"", ch, ch));
                }
                return sb.toString();
            } else {
                sb.append((char)mIn.read());
            }
        }
    }

    /**
     * A ""{"" has been read. Read the rest of the size string, the space and then
     * notify the callback with an InputStream.
     */
    private Object parseLiteral() throws IOException {
        expect('{');
        int size = Integer.parseInt(readStringUntil('}'));
        expect('\r');
        expect('\n');

        if (size == 0) {
            return """";
        }

        if (mResponse.mCallback != null) {
            FixedLengthInputStream fixed = new FixedLengthInputStream(mIn, size);

            Object result = null;
            try {
                result = mResponse.mCallback.foundLiteral(mResponse, fixed);
            } catch (IOException e) {
                // Pass IOExceptions through
                throw e;
            } catch (Exception e) {
                // Catch everything else and save it for later.
                mException = e;
                //Log.e(K9.LOG_TAG, ""parseLiteral(): Exception in callback method"", e);
            }

            // Check if only some of the literal data was read
            int available = fixed.available();
            if ((available > 0) && (available != size)) {
                // If so, skip the rest
                while (fixed.available() > 0) {
                    fixed.skip(fixed.available());
                }
            }

            if (result != null) {
                return result;
            }
        }

        byte[] data = new byte[size];
        int read = 0;
        while (read != size) {
            int count = mIn.read(data, read, size - read);
            if (count == -1) {
                throw new IOException(""parseLiteral(): end of stream reached"");
            }
            read += count;
        }

        return new String(data, ""US-ASCII"");
    }

    private String parseQuoted() throws IOException {
        expect('""');

        StringBuffer sb = new StringBuffer();
        int ch;
        boolean escape = false;
        while ((ch = mIn.read()) != -1) {
            if (!escape && (ch == '\\')) {
                // Found the escape character
                escape = true;
            } else if (!escape && (ch == '""')) {
                return sb.toString();
            } else {
                sb.append((char)ch);
                escape = false;
            }
        }
        throw new IOException(""parseQuoted(): end of stream reached"");
    }

    private String readStringUntil(char end) throws IOException {
        StringBuffer sb = new StringBuffer();
        int ch;
        while ((ch = mIn.read()) != -1) {
            if (ch == end) {
                return sb.toString();
            } else {
                sb.append((char)ch);
            }
        }
        throw new IOException(""readStringUntil(): end of stream reached"");
    }

    private int expect(char ch) throws IOException {
        int d;
        if ((d = mIn.read()) != ch) {
            throw new IOException(String.format(""Expected %04x (%c) but got %04x (%c)"", (int)ch,
                                                ch, d, (char)d));
        }
        return d;
    }

    /**
     * Represents an IMAP list response and is also the base class for the
     * ImapResponse.
     */
    public class ImapList extends ArrayList<Object> {
        private static final long serialVersionUID = -4067248341419617583L;

        public ImapList getList(int index) {
            return (ImapList)get(index);
        }

        public Object getObject(int index) {
            return get(index);
        }

        public String getString(int index) {
            return (String)get(index);
        }

        public InputStream getLiteral(int index) {
            return (InputStream)get(index);
        }

        public int getNumber(int index) {
            return Integer.parseInt(getString(index));
        }

        public Date getDate(int index) throws MessagingException {
            return getDate(getString(index));
        }

        public Date getKeyedDate(Object key) throws MessagingException {
            return getDate(getKeyedString(key));
        }

        private Date getDate(String value) throws MessagingException {
            try {
                if (value == null) {
                    return null;
                }
                return parseDate(value);
            } catch (ParseException pe) {
                throw new MessagingException(""Unable to parse IMAP datetime '"" + value + ""' "", pe);
            }
        }


        public Object getKeyedValue(Object key) {
            for (int i = 0, count = size(); i < count; i++) {
                if (equalsIgnoreCase(get(i), key)) {
                    return get(i + 1);
                }
            }
            return null;
        }

        public ImapList getKeyedList(Object key) {
            return (ImapList)getKeyedValue(key);
        }

        public String getKeyedString(Object key) {
            return (String)getKeyedValue(key);
        }

        public InputStream getKeyedLiteral(Object key) {
            return (InputStream)getKeyedValue(key);
        }

        public int getKeyedNumber(Object key) {
            return Integer.parseInt(getKeyedString(key));
        }

        public boolean containsKey(Object key) {
            if (key == null) {
                return false;
            }

            for (int i = 0, count = size(); i < count; i++) {
                if (equalsIgnoreCase(key, get(i))) {
                    return true;
                }
            }
            return false;
        }

        public int getKeyIndex(Object key) {
            for (int i = 0, count = size(); i < count; i++) {
                if (equalsIgnoreCase(key, get(i))) {
                    return i;
                }
            }

            throw new IllegalArgumentException(""getKeyIndex() only works for keys that are in the collection."");
        }

        private Date parseDate(String value) throws ParseException {
            //TODO: clean this up a bit
            try {
                synchronized (mDateTimeFormat) {
                    return mDateTimeFormat.parse(value);
                }
            } catch (Exception e) {
                try {
                    synchronized (badDateTimeFormat) {
                        return badDateTimeFormat.parse(value);
                    }
                } catch (Exception e2) {
                    try {
                        synchronized (badDateTimeFormat2) {
                            return badDateTimeFormat2.parse(value);
                        }
                    } catch (Exception e3) {
                        synchronized (badDateTimeFormat3) {
                            return badDateTimeFormat3.parse(value);
                        }
                    }
                }
            }
        }
    }

    /**
     * Represents a single response from the IMAP server. Tagged responses will
     * have a non-null tag. Untagged responses will have a null tag. The object
     * will contain all of the available tokens at the time the response is
     * received. In general, it will either contain all of the tokens of the
     * response or all of the tokens up until the first LITERAL. If the object
     * does not contain the entire response the caller must call more() to
     * continue reading the response until more returns false.
     */
    public class ImapResponse extends ImapList {
        /**
         *
         */
        private static final long serialVersionUID = 6886458551615975669L;
        private boolean mCompleted;
        private IImapResponseCallback mCallback;

        boolean mCommandContinuationRequested;
        String mTag;

        public boolean more() throws IOException {
            if (mCompleted) {
                return false;
            }
            readTokens(this);
            return true;
        }

        public String getAlertText() {
            if (size() > 1 && equalsIgnoreCase(""[ALERT]"", get(1))) {
                StringBuffer sb = new StringBuffer();
                for (int i = 2, count = size(); i < count; i++) {
                    sb.append(get(i).toString());
                    sb.append(' ');
                }
                return sb.toString();
            } else {
                return null;
            }
        }

        @Override
        public String toString() {
            return ""#"" + (mCommandContinuationRequested ? ""+"" : mTag) + ""# "" + super.toString();
        }
    }

    public static boolean equalsIgnoreCase(Object o1, Object o2) {
        if (o1 != null && o2 != null && o1 instanceof String && o2 instanceof String) {
            String s1 = (String)o1;
            String s2 = (String)o2;
            return s1.equalsIgnoreCase(s2);
        } else if (o1 != null) {
            return o1.equals(o2);
        } else if (o2 != null) {
            return o2.equals(o1);
        } else {
            // Both o1 and o2 are null
            return true;
        }
    }

    public interface IImapResponseCallback {
        /**
         * Callback method that is called by the parser when a literal string
         * is found in an IMAP response.
         *
         * @param response ImapResponse object with the fields that have been
         *                 parsed up until now (excluding the literal string).
         * @param literal  FixedLengthInputStream that can be used to access
         *                 the literal string.
         *
         * @return an Object that will be put in the ImapResponse object at the
         *         place of the literal string.
         *
         * @throws IOException passed-through if thrown by FixedLengthInputStream
         * @throws Exception if something goes wrong. Parsing will be resumed
         *                   and the exception will be thrown after the
         *                   complete IMAP response has been parsed.
         */
        public Object foundLiteral(ImapResponse response, FixedLengthInputStream literal)
        throws IOException, Exception;
    }
}
",True,116,7,48,1,3,1,3,L1
148,com.fsck.k9.mail.store.LocalStore.java,"
package com.fsck.k9.mail.store;

import java.io.*;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.regex.Pattern;

import com.fsck.k9.helper.HtmlConverter;
import org.apache.commons.io.IOUtils;

import android.app.Application;
import android.content.ContentValues;
import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.net.Uri;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.AccountStats;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.controller.MessageRemovalListener;
import com.fsck.k9.controller.MessageRetrievalListener;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.Body;
import com.fsck.k9.mail.BodyPart;
import com.fsck.k9.mail.FetchProfile;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Part;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.filter.Base64OutputStream;
import com.fsck.k9.mail.internet.MimeBodyPart;
import com.fsck.k9.mail.internet.MimeHeader;
import com.fsck.k9.mail.internet.MimeMessage;
import com.fsck.k9.mail.internet.MimeMultipart;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.internet.TextBody;
import com.fsck.k9.mail.store.LockableDatabase.DbCallback;
import com.fsck.k9.mail.store.LockableDatabase.WrappedException;
import com.fsck.k9.mail.store.StorageManager.StorageProvider;
import com.fsck.k9.provider.AttachmentProvider;

/**
 * <pre>
 * Implements a SQLite database backed local store for Messages.
 * </pre>
 */
public class LocalStore extends Store implements Serializable {

    private static final long serialVersionUID = -5142141896809423072L;

    private static final Message[] EMPTY_MESSAGE_ARRAY = new Message[0];

    /**
     * Immutable empty {@link String} array
     */
    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED, Flag.X_DESTROYED, Flag.SEEN, Flag.FLAGGED };

    private static Set<String> HEADERS_TO_SAVE = new HashSet<String>();
    static {
        HEADERS_TO_SAVE.add(K9.IDENTITY_HEADER);
        HEADERS_TO_SAVE.add(""To"");
        HEADERS_TO_SAVE.add(""Cc"");
        HEADERS_TO_SAVE.add(""From"");
        HEADERS_TO_SAVE.add(""In-Reply-To"");
        HEADERS_TO_SAVE.add(""References"");
        HEADERS_TO_SAVE.add(""Content-ID"");
        HEADERS_TO_SAVE.add(""Content-Disposition"");
        HEADERS_TO_SAVE.add(""User-Agent"");
    }
    /*
     * a String containing the columns getMessages expects to work with
     * in the correct order.
     */
    static private String GET_MESSAGES_COLS =
        ""subject, sender_list, date, uid, flags, id, to_list, cc_list, ""
        + ""bcc_list, reply_to_list, attachment_count, internal_date, message_id, folder_id, preview "";


    static private String GET_FOLDER_COLS = ""id, name, unread_count, visible_limit, last_updated, status, push_state, last_pushed, flagged_count, integrate, top_group, poll_class, push_class, display_class"";


    protected static final int DB_VERSION = 43;

    protected String uUid = null;

    private final Application mApplication;

    private LockableDatabase database;

    /**
     * local://localhost/path/to/database/uuid.db
     * This constructor is only used by {@link Store#getLocalInstance(Account, Application)}
     * @param account
     * @param application
     * @throws UnavailableStorageException if not {@link StorageProvider#isReady(Context)}
     */
    public LocalStore(final Account account, final Application application) throws MessagingException {
        super(account);
        database = new LockableDatabase(application, account.getUuid(), new StoreSchemaDefinition());

        mApplication = application;
        database.setStorageProviderId(account.getLocalStorageProviderId());
        uUid = account.getUuid();

        database.open();
    }

    public void switchLocalStorage(final String newStorageProviderId) throws MessagingException {
        database.switchProvider(newStorageProviderId);
    }

    protected SharedPreferences getPreferences() {
        return Preferences.getPreferences(mApplication).getPreferences();
    }

    private class StoreSchemaDefinition implements LockableDatabase.SchemaDefinition {
        @Override
        public int getVersion() {
            return DB_VERSION;
        }

        @Override
        public void doDbUpgrade(final SQLiteDatabase db) {
            Log.i(K9.LOG_TAG, String.format(""Upgrading database from version %d to version %d"",
                                            db.getVersion(), DB_VERSION));


            AttachmentProvider.clear(mApplication);

            try {
                // schema version 29 was when we moved to incremental updates
                // in the case of a new db or a < v29 db, we blow away and start from scratch
                if (db.getVersion() < 29) {

                    db.execSQL(""DROP TABLE IF EXISTS folders"");
                    db.execSQL(""CREATE TABLE folders (id INTEGER PRIMARY KEY, name TEXT, ""
                               + ""last_updated INTEGER, unread_count INTEGER, visible_limit INTEGER, status TEXT, ""
                               + ""push_state TEXT, last_pushed INTEGER, flagged_count INTEGER default 0, ""
                               + ""integrate INTEGER, top_group INTEGER, poll_class TEXT, push_class TEXT, display_class TEXT""
                               + "")"");

                    db.execSQL(""CREATE INDEX IF NOT EXISTS folder_name ON folders (name)"");
                    db.execSQL(""DROP TABLE IF EXISTS messages"");
                    db.execSQL(""CREATE TABLE messages (id INTEGER PRIMARY KEY, deleted INTEGER default 0, folder_id INTEGER, uid TEXT, subject TEXT, ""
                               + ""date INTEGER, flags TEXT, sender_list TEXT, to_list TEXT, cc_list TEXT, bcc_list TEXT, reply_to_list TEXT, ""
                               + ""html_content TEXT, text_content TEXT, attachment_count INTEGER, internal_date INTEGER, message_id TEXT, preview TEXT, ""
                               + ""mime_type TEXT)"");

                    db.execSQL(""DROP TABLE IF EXISTS headers"");
                    db.execSQL(""CREATE TABLE headers (id INTEGER PRIMARY KEY, message_id INTEGER, name TEXT, value TEXT)"");
                    db.execSQL(""CREATE INDEX IF NOT EXISTS header_folder ON headers (message_id)"");

                    db.execSQL(""CREATE INDEX IF NOT EXISTS msg_uid ON messages (uid, folder_id)"");
                    db.execSQL(""DROP INDEX IF EXISTS msg_folder_id"");
                    db.execSQL(""DROP INDEX IF EXISTS msg_folder_id_date"");
                    db.execSQL(""CREATE INDEX IF NOT EXISTS msg_folder_id_deleted_date ON messages (folder_id,deleted,internal_date)"");
                    db.execSQL(""DROP TABLE IF EXISTS attachments"");
                    db.execSQL(""CREATE TABLE attachments (id INTEGER PRIMARY KEY, message_id INTEGER,""
                               + ""store_data TEXT, content_uri TEXT, size INTEGER, name TEXT,""
                               + ""mime_type TEXT, content_id TEXT, content_disposition TEXT)"");

                    db.execSQL(""DROP TABLE IF EXISTS pending_commands"");
                    db.execSQL(""CREATE TABLE pending_commands "" +
                               ""(id INTEGER PRIMARY KEY, command TEXT, arguments TEXT)"");

                    db.execSQL(""DROP TRIGGER IF EXISTS delete_folder"");
                    db.execSQL(""CREATE TRIGGER delete_folder BEFORE DELETE ON folders BEGIN DELETE FROM messages WHERE old.id = folder_id; END;"");

                    db.execSQL(""DROP TRIGGER IF EXISTS delete_message"");
                    db.execSQL(""CREATE TRIGGER delete_message BEFORE DELETE ON messages BEGIN DELETE FROM attachments WHERE old.id = message_id; ""
                               + ""DELETE FROM headers where old.id = message_id; END;"");
                } else {
                    // in the case that we're starting out at 29 or newer, run all the needed updates

                    if (db.getVersion() < 30) {
                        try {
                            db.execSQL(""ALTER TABLE messages ADD deleted INTEGER default 0"");
                        } catch (SQLiteException e) {
                            if (! e.toString().startsWith(""duplicate column name: deleted"")) {
                                throw e;
                            }
                        }
                    }
                    if (db.getVersion() < 31) {
                        db.execSQL(""DROP INDEX IF EXISTS msg_folder_id_date"");
                        db.execSQL(""CREATE INDEX IF NOT EXISTS msg_folder_id_deleted_date ON messages (folder_id,deleted,internal_date)"");
                    }
                    if (db.getVersion() < 32) {
                        db.execSQL(""UPDATE messages SET deleted = 1 WHERE flags LIKE '%DELETED%'"");
                    }
                    if (db.getVersion() < 33) {

                        try {
                            db.execSQL(""ALTER TABLE messages ADD preview TEXT"");
                        } catch (SQLiteException e) {
                            if (! e.toString().startsWith(""duplicate column name: preview"")) {
                                throw e;
                            }
                        }

                    }
                    if (db.getVersion() < 34) {
                        try {
                            db.execSQL(""ALTER TABLE folders ADD flagged_count INTEGER default 0"");
                        } catch (SQLiteException e) {
                            if (! e.getMessage().startsWith(""duplicate column name: flagged_count"")) {
                                throw e;
                            }
                        }
                    }
                    if (db.getVersion() < 35) {
                        try {
                            db.execSQL(""update messages set flags = replace(flags, 'X_NO_SEEN_INFO', 'X_BAD_FLAG')"");
                        } catch (SQLiteException e) {
                            Log.e(K9.LOG_TAG, ""Unable to get rid of obsolete flag X_NO_SEEN_INFO"", e);
                        }
                    }
                    if (db.getVersion() < 36) {
                        try {
                            db.execSQL(""ALTER TABLE attachments ADD content_id TEXT"");
                        } catch (SQLiteException e) {
                            Log.e(K9.LOG_TAG, ""Unable to add content_id column to attachments"");
                        }
                    }
                    if (db.getVersion() < 37) {
                        try {
                            db.execSQL(""ALTER TABLE attachments ADD content_disposition TEXT"");
                        } catch (SQLiteException e) {
                            Log.e(K9.LOG_TAG, ""Unable to add content_disposition column to attachments"");
                        }
                    }

                    // Database version 38 is solely to prune cached attachments now that we clear them better
                    if (db.getVersion() < 39) {
                        try {
                            db.execSQL(""DELETE FROM headers WHERE id in (SELECT headers.id FROM headers LEFT JOIN messages ON headers.message_id = messages.id WHERE messages.id IS NULL)"");
                        } catch (SQLiteException e) {
                            Log.e(K9.LOG_TAG, ""Unable to remove extra header data from the database"");
                        }
                    }

                    // V40: Store the MIME type for a message.
                    if (db.getVersion() < 40) {
                        try {
                            db.execSQL(""ALTER TABLE messages ADD mime_type TEXT"");
                        } catch (SQLiteException e) {
                            Log.e(K9.LOG_TAG, ""Unable to add mime_type column to messages"");
                        }
                    }

                    if (db.getVersion() < 41) {
                        try {
                            db.execSQL(""ALTER TABLE folders ADD integrate INTEGER"");
                            db.execSQL(""ALTER TABLE folders ADD top_group INTEGER"");
                            db.execSQL(""ALTER TABLE folders ADD poll_class TEXT"");
                            db.execSQL(""ALTER TABLE folders ADD push_class TEXT"");
                            db.execSQL(""ALTER TABLE folders ADD display_class TEXT"");
                        } catch (SQLiteException e) {
                            if (! e.getMessage().startsWith(""duplicate column name:"")) {
                                throw e;
                            }
                        }
                        Cursor cursor = null;

                        try {

                            SharedPreferences prefs = getPreferences();
                            cursor = db.rawQuery(""SELECT id, name FROM folders"", null);
                            while (cursor.moveToNext()) {
                                try {
                                    int id = cursor.getInt(0);
                                    String name = cursor.getString(1);
                                    update41Metadata(db, prefs, id, name);
                                } catch (Exception e) {
                                    Log.e(K9.LOG_TAG, "" error trying to ugpgrade a folder class: "" + e);
                                }
                            }
                        }


                        catch (SQLiteException e) {
                            Log.e(K9.LOG_TAG, ""Exception while upgrading database to v41. folder classes may have vanished "" + e);

                        } finally {
                            if (cursor != null) {
                                cursor.close();
                            }
                        }
                    }
                    if (db.getVersion() == 41) {
                        try {
                            long startTime = System.currentTimeMillis();
                            SharedPreferences.Editor editor = getPreferences().edit();

                            List <? extends Folder >  folders = getPersonalNamespaces(true);
                            for (Folder folder : folders) {
                                if (folder instanceof LocalFolder) {
                                    LocalFolder lFolder = (LocalFolder)folder;
                                    lFolder.save(editor);
                                }
                            }

                            editor.commit();
                            long endTime = System.currentTimeMillis();
                            Log.i(K9.LOG_TAG, ""Putting folder preferences for "" + folders.size() + "" folders back into Preferences took "" + (endTime - startTime) + "" ms"");
                        } catch (Exception e) {
                            Log.e(K9.LOG_TAG, ""Could not replace Preferences in upgrade from DB_VERSION 41"", e);
                        }
                    }
                    if (db.getVersion() < 43) {
                        try {
                            // If folder ""OUTBOX"" (old, v3.800 - v3.802) exists, rename it to
                            // ""K9MAIL_INTERNAL_OUTBOX"" (new)
                            LocalFolder oldOutbox = new LocalFolder(""OUTBOX"");
                            if (oldOutbox.exists()) {
                                ContentValues cv = new ContentValues();
                                cv.put(""name"", Account.OUTBOX);
                                db.update(""folders"", cv, ""name = ?"", new String[] { ""OUTBOX"" });
                                Log.i(K9.LOG_TAG, ""Renamed folder OUTBOX to "" + Account.OUTBOX);
                            }

                            // Check if old (pre v3.800) localized outbox folder exists
                            String localizedOutbox = K9.app.getString(R.string.special_mailbox_name_outbox);
                            LocalFolder obsoleteOutbox = new LocalFolder(localizedOutbox);
                            if (obsoleteOutbox.exists()) {
                                // Get all messages from the localized outbox ...
                                Message[] messages = obsoleteOutbox.getMessages(null, false);

                                if (messages.length > 0) {
                                    // ... and move them to the drafts folder (we don't want to
                                    // surprise the user by sending potentially very old messages)
                                    LocalFolder drafts = new LocalFolder(mAccount.getDraftsFolderName());
                                    obsoleteOutbox.moveMessages(messages, drafts);
                                }

                                // Now get rid of the localized outbox
                                obsoleteOutbox.delete();
                                obsoleteOutbox.delete(true);
                            }
                        } catch (Exception e) {
                            Log.e(K9.LOG_TAG, ""Error trying to fix the outbox folders"", e);
                        }
                    }
                }
            }

            catch (SQLiteException e) {
                Log.e(K9.LOG_TAG, ""Exception while upgrading database. Resetting the DB to v0"");
                db.setVersion(0);
                throw new Error(""Database upgrade failed! Resetting your DB version to 0 to force a full schema recreation."");
            }



            db.setVersion(DB_VERSION);

            if (db.getVersion() != DB_VERSION) {
                throw new Error(""Database upgrade failed!"");
            }

            // Unless we're blowing away the whole data store, there's no reason to prune attachments
            // every time the user upgrades. it'll just cost them money and pain.
            // try
            //{
            //        pruneCachedAttachments(true);
            //}
            //catch (Exception me)
            //{
            //   Log.e(K9.LOG_TAG, ""Exception while force pruning attachments during DB update"", me);
            //}
        }

        private void update41Metadata(final SQLiteDatabase  db, SharedPreferences prefs, int id, String name) {


            Folder.FolderClass displayClass = Folder.FolderClass.NO_CLASS;
            Folder.FolderClass syncClass = Folder.FolderClass.INHERITED;
            Folder.FolderClass pushClass = Folder.FolderClass.SECOND_CLASS;
            boolean inTopGroup = false;
            boolean integrate = false;
            if (mAccount.getInboxFolderName().equals(name)) {
                displayClass = Folder.FolderClass.FIRST_CLASS;
                syncClass =  Folder.FolderClass.FIRST_CLASS;
                pushClass =  Folder.FolderClass.FIRST_CLASS;
                inTopGroup = true;
                integrate = true;
            }

            try {
                displayClass = Folder.FolderClass.valueOf(prefs.getString(uUid + ""."" + name + "".displayMode"", displayClass.name()));
                syncClass = Folder.FolderClass.valueOf(prefs.getString(uUid + ""."" + name + "".syncMode"", syncClass.name()));
                pushClass = Folder.FolderClass.valueOf(prefs.getString(uUid + ""."" + name + "".pushMode"", pushClass.name()));
                inTopGroup = prefs.getBoolean(uUid + ""."" + name + "".inTopGroup"", inTopGroup);
                integrate = prefs.getBoolean(uUid + ""."" + name + "".integrate"", integrate);
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, "" Throwing away an error while trying to upgrade folder metadata: "" + e);
            }

            if (displayClass == Folder.FolderClass.NONE) {
                displayClass = Folder.FolderClass.NO_CLASS;
            }
            if (syncClass == Folder.FolderClass.NONE) {
                syncClass = Folder.FolderClass.INHERITED;
            }
            if (pushClass == Folder.FolderClass.NONE) {
                pushClass = Folder.FolderClass.INHERITED;
            }

            db.execSQL(""UPDATE folders SET integrate = ?, top_group = ?, poll_class=?, push_class =?, display_class = ? WHERE id = ?"",
                       new Object[] { integrate, inTopGroup, syncClass, pushClass, displayClass, id });

        }
    }


    public long getSize() throws UnavailableStorageException {

        final StorageManager storageManager = StorageManager.getInstance(mApplication);

        final File attachmentDirectory = storageManager.getAttachmentDirectory(uUid,
                                         database.getStorageProviderId());

        return database.execute(false, new DbCallback<Long>() {
            @Override
            public Long doDbWork(final SQLiteDatabase db) {
                final File[] files = attachmentDirectory.listFiles();
                long attachmentLength = 0;
                for (File file : files) {
                    if (file.exists()) {
                        attachmentLength += file.length();
                    }
                }

                final File dbFile = storageManager.getDatabase(uUid, database.getStorageProviderId());
                return dbFile.length() + attachmentLength;
            }
        });
    }

    public void compact() throws MessagingException {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Before compaction size = "" + getSize());

        database.execute(false, new DbCallback<Void>() {
            @Override
            public Void doDbWork(final SQLiteDatabase db) throws WrappedException {
                db.execSQL(""VACUUM"");
                return null;
            }
        });
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""After compaction size = "" + getSize());
    }


    public void clear() throws MessagingException {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Before prune size = "" + getSize());

        pruneCachedAttachments(true);
        if (K9.DEBUG) {
            Log.i(K9.LOG_TAG, ""After prune / before compaction size = "" + getSize());

            Log.i(K9.LOG_TAG, ""Before clear folder count = "" + getFolderCount());
            Log.i(K9.LOG_TAG, ""Before clear message count = "" + getMessageCount());

            Log.i(K9.LOG_TAG, ""After prune / before clear size = "" + getSize());
        }
        // don't delete messages that are Local, since there is no copy on the server.
        // Don't delete deleted messages.  They are essentially placeholders for UIDs of messages that have
        // been deleted locally.  They take up insignificant space
        database.execute(false, new DbCallback<Void>() {
            @Override
            public Void doDbWork(final SQLiteDatabase db) {
                db.execSQL(""DELETE FROM messages WHERE deleted = 0 and uid not like 'Local%'"");
                db.execSQL(""update folders set flagged_count = 0, unread_count = 0"");
                return null;
            }
        });

        compact();

        if (K9.DEBUG) {
            Log.i(K9.LOG_TAG, ""After clear message count = "" + getMessageCount());

            Log.i(K9.LOG_TAG, ""After clear size = "" + getSize());
        }
    }

    public int getMessageCount() throws MessagingException {
        return database.execute(false, new DbCallback<Integer>() {
            @Override
            public Integer doDbWork(final SQLiteDatabase db) {
                Cursor cursor = null;
                try {
                    cursor = db.rawQuery(""SELECT COUNT(*) FROM messages"", null);
                    cursor.moveToFirst();
                    return cursor.getInt(0);   // message count
                } finally {
                    if (cursor != null) {
                        cursor.close();
                    }
                }
            }
        });
    }

    public void getMessageCounts(final AccountStats stats) throws MessagingException {
        final Account.FolderMode displayMode = mAccount.getFolderDisplayMode();

        database.execute(false, new DbCallback<Integer>() {
            @Override
            public Integer doDbWork(final SQLiteDatabase db) {
                Cursor cursor = null;
                try {
                    // Always count messages in the INBOX but exclude special folders and possibly
                    // more (depending on the folder display mode)
                    String baseQuery = ""SELECT SUM(unread_count), SUM(flagged_count) "" +
                                       ""FROM folders "" +
                                       ""WHERE (name = ?)"" +  /* INBOX */
                                       "" OR ("" +
                                       ""name NOT IN (?, ?, ?, ?, ?)"" +  /* special folders */
                                       ""%s)"";  /* placeholder for additional constraints */

                    List<String> queryParam = new ArrayList<String>();
                    queryParam.add(mAccount.getInboxFolderName());

                    queryParam.add((mAccount.getTrashFolderName() != null) ?
                                   mAccount.getTrashFolderName() : """");
                    queryParam.add((mAccount.getDraftsFolderName() != null) ?
                                   mAccount.getDraftsFolderName() : """");
                    queryParam.add((mAccount.getSpamFolderName() != null) ?
                                   mAccount.getSpamFolderName() : """");
                    queryParam.add((mAccount.getOutboxFolderName() != null) ?
                                   mAccount.getOutboxFolderName() : """");
                    queryParam.add((mAccount.getSentFolderName() != null) ?
                                   mAccount.getSentFolderName() : """");

                    final String extraWhere;
                    switch (displayMode) {
                    case FIRST_CLASS:
                        // Count messages in the INBOX and non-special first class folders
                        extraWhere = "" AND (display_class = ?)"";
                        queryParam.add(Folder.FolderClass.FIRST_CLASS.name());
                        break;
                    case FIRST_AND_SECOND_CLASS:
                        // Count messages in the INBOX and non-special first and second class folders
                        extraWhere = "" AND (display_class IN (?, ?))"";
                        queryParam.add(Folder.FolderClass.FIRST_CLASS.name());
                        queryParam.add(Folder.FolderClass.SECOND_CLASS.name());
                        break;
                    case NOT_SECOND_CLASS:
                        // Count messages in the INBOX and non-special non-second-class folders
                        extraWhere = "" AND (display_class != ?)"";
                        queryParam.add(Folder.FolderClass.SECOND_CLASS.name());
                        break;
                    case ALL:
                        // Count messages in the INBOX and non-special folders
                        extraWhere = """";
                        break;
                    default:
                        Log.e(K9.LOG_TAG, ""asked to compute account statistics for an impossible folder mode "" + displayMode);
                        stats.unreadMessageCount = 0;
                        stats.flaggedMessageCount = 0;
                        return null;
                    }

                    String query = String.format(Locale.US, baseQuery, extraWhere);
                    cursor = db.rawQuery(query, queryParam.toArray(EMPTY_STRING_ARRAY));

                    cursor.moveToFirst();
                    stats.unreadMessageCount = cursor.getInt(0);
                    stats.flaggedMessageCount = cursor.getInt(1);
                    return null;
                } finally {
                    if (cursor != null) {
                        cursor.close();
                    }
                }
            }
        });
    }


    public int getFolderCount() throws MessagingException {
        return database.execute(false, new DbCallback<Integer>() {
            @Override
            public Integer doDbWork(final SQLiteDatabase db) {
                Cursor cursor = null;
                try {
                    cursor = db.rawQuery(""SELECT COUNT(*) FROM folders"", null);
                    cursor.moveToFirst();
                    return cursor.getInt(0);        // folder count
                } finally {
                    if (cursor != null) {
                        cursor.close();
                    }
                }
            }
        });
    }

    @Override
    public LocalFolder getFolder(String name) {
        return new LocalFolder(name);
    }

    // TODO this takes about 260-300ms, seems slow.
    @Override
    public List <? extends Folder > getPersonalNamespaces(boolean forceListAll) throws MessagingException {
        final List<LocalFolder> folders = new LinkedList<LocalFolder>();
        try {
            database.execute(false, new DbCallback < List <? extends Folder >> () {
                @Override
                public List <? extends Folder > doDbWork(final SQLiteDatabase db) throws WrappedException {
                    Cursor cursor = null;

                    try {
                        cursor = db.rawQuery(""SELECT "" + GET_FOLDER_COLS + "" FROM folders ORDER BY name ASC"", null);
                        while (cursor.moveToNext()) {
                            LocalFolder folder = new LocalFolder(cursor.getString(1));
                            folder.open(cursor.getInt(0), cursor.getString(1), cursor.getInt(2), cursor.getInt(3), cursor.getLong(4), cursor.getString(5), cursor.getString(6), cursor.getLong(7), cursor.getInt(8), cursor.getInt(9), cursor.getInt(10), cursor.getString(11), cursor.getString(12), cursor.getString(13));

                            folders.add(folder);
                        }
                        return folders;
                    } catch (MessagingException e) {
                        throw new WrappedException(e);
                    } finally {
                        if (cursor != null) {
                            cursor.close();
                        }
                    }
                }
            });
        } catch (WrappedException e) {
            throw(MessagingException) e.getCause();
        }
        return folders;
    }

    @Override
    public void checkSettings() throws MessagingException {
    }

    public void delete() throws UnavailableStorageException {
        database.delete();
    }

    public void recreate() throws UnavailableStorageException {
        database.recreate();
    }

    public void pruneCachedAttachments() throws MessagingException {
        pruneCachedAttachments(false);
    }

    /**
     * Deletes all cached attachments for the entire store.
     * @param force
     * @throws com.fsck.k9.mail.MessagingException
     */
    private void pruneCachedAttachments(final boolean force) throws MessagingException {
        database.execute(false, new DbCallback<Void>() {
            @Override
            public Void doDbWork(final SQLiteDatabase db) throws WrappedException {
                if (force) {
                    ContentValues cv = new ContentValues();
                    cv.putNull(""content_uri"");
                    db.update(""attachments"", cv, null, null);
                }
                final StorageManager storageManager = StorageManager.getInstance(mApplication);
                File[] files = storageManager.getAttachmentDirectory(uUid, database.getStorageProviderId()).listFiles();
                for (File file : files) {
                    if (file.exists()) {
                        if (!force) {
                            Cursor cursor = null;
                            try {
                                cursor = db.query(
                                             ""attachments"",
                                             new String[] { ""store_data"" },
                                             ""id = ?"",
                                             new String[] { file.getName() },
                                             null,
                                             null,
                                             null);
                                if (cursor.moveToNext()) {
                                    if (cursor.getString(0) == null) {
                                        if (K9.DEBUG)
                                            Log.d(K9.LOG_TAG, ""Attachment "" + file.getAbsolutePath() + "" has no store data, not deleting"");
                                        /*
                                         * If the attachment has no store data it is not recoverable, so
                                         * we won't delete it.
                                         */
                                        continue;
                                    }
                                }
                            } finally {
                                if (cursor != null) {
                                    cursor.close();
                                }
                            }
                        }
                        if (!force) {
                            try {
                                ContentValues cv = new ContentValues();
                                cv.putNull(""content_uri"");
                                db.update(""attachments"", cv, ""id = ?"", new String[] { file.getName() });
                            } catch (Exception e) {
                                /*
                                 * If the row has gone away before we got to mark it not-downloaded that's
                                 * okay.
                                 */
                            }
                        }
                        if (!file.delete()) {
                            file.deleteOnExit();
                        }
                    }
                }
                return null;
            }
        });
    }

    public void resetVisibleLimits() throws UnavailableStorageException {
        resetVisibleLimits(mAccount.getDisplayCount());
    }

    public void resetVisibleLimits(int visibleLimit) throws UnavailableStorageException {
        final ContentValues cv = new ContentValues();
        cv.put(""visible_limit"", Integer.toString(visibleLimit));
        database.execute(false, new DbCallback<Void>() {
            @Override
            public Void doDbWork(final SQLiteDatabase db) throws WrappedException {
                db.update(""folders"", cv, null, null);
                return null;
            }
        });
    }

    public ArrayList<PendingCommand> getPendingCommands() throws UnavailableStorageException {
        return database.execute(false, new DbCallback<ArrayList<PendingCommand>>() {
            @Override
            public ArrayList<PendingCommand> doDbWork(final SQLiteDatabase db) throws WrappedException {
                Cursor cursor = null;
                try {
                    cursor = db.query(""pending_commands"",
                                      new String[] { ""id"", ""command"", ""arguments"" },
                                      null,
                                      null,
                                      null,
                                      null,
                                      ""id ASC"");
                    ArrayList<PendingCommand> commands = new ArrayList<PendingCommand>();
                    while (cursor.moveToNext()) {
                        PendingCommand command = new PendingCommand();
                        command.mId = cursor.getLong(0);
                        command.command = cursor.getString(1);
                        String arguments = cursor.getString(2);
                        command.arguments = arguments.split("","");
                        for (int i = 0; i < command.arguments.length; i++) {
                            command.arguments[i] = Utility.fastUrlDecode(command.arguments[i]);
                        }
                        commands.add(command);
                    }
                    return commands;
                } finally {
                    if (cursor != null) {
                        cursor.close();
                    }
                }
            }
        });
    }

    public void addPendingCommand(PendingCommand command) throws UnavailableStorageException {
        try {
            for (int i = 0; i < command.arguments.length; i++) {
                command.arguments[i] = URLEncoder.encode(command.arguments[i], ""UTF-8"");
            }
            final ContentValues cv = new ContentValues();
            cv.put(""command"", command.command);
            cv.put(""arguments"", Utility.combine(command.arguments, ','));
            database.execute(false, new DbCallback<Void>() {
                @Override
                public Void doDbWork(final SQLiteDatabase db) throws WrappedException {
                    db.insert(""pending_commands"", ""command"", cv);
                    return null;
                }
            });
        } catch (UnsupportedEncodingException usee) {
            throw new Error(""Aparently UTF-8 has been lost to the annals of history."");
        }
    }

    public void removePendingCommand(final PendingCommand command) throws UnavailableStorageException {
        database.execute(false, new DbCallback<Void>() {
            @Override
            public Void doDbWork(final SQLiteDatabase db) throws WrappedException {
                db.delete(""pending_commands"", ""id = ?"", new String[] { Long.toString(command.mId) });
                return null;
            }
        });
    }

    public void removePendingCommands() throws UnavailableStorageException {
        database.execute(false, new DbCallback<Void>() {
            @Override
            public Void doDbWork(final SQLiteDatabase db) throws WrappedException {
                db.delete(""pending_commands"", null, null);
                return null;
            }
        });
    }

    public static class PendingCommand {
        private long mId;
        public String command;
        public String[] arguments;

        @Override
        public String toString() {
            StringBuffer sb = new StringBuffer();
            sb.append(command);
            sb.append("": "");
            for (String argument : arguments) {
                sb.append("", "");
                sb.append(argument);
                //sb.append(""\n"");
            }
            return sb.toString();
        }
    }

    @Override
    public boolean isMoveCapable() {
        return true;
    }

    @Override
    public boolean isCopyCapable() {
        return true;
    }

    public Message[] searchForMessages(MessageRetrievalListener listener, String[] queryFields, String queryString,
                                       List<LocalFolder> folders, Message[] messages, final Flag[] requiredFlags, final Flag[] forbiddenFlags) throws MessagingException {
        List<String> args = new LinkedList<String>();

        StringBuilder whereClause = new StringBuilder();
        if (queryString != null && queryString.length() > 0) {
            boolean anyAdded = false;
            String likeString = ""%"" + queryString + ""%"";
            whereClause.append("" AND ("");
            for (String queryField : queryFields) {

                if (anyAdded) {
                    whereClause.append("" OR "");
                }
                whereClause.append(queryField).append("" LIKE ? "");
                args.add(likeString);
                anyAdded = true;
            }


            whereClause.append("" )"");
        }
        if (folders != null && folders.size() > 0) {
            whereClause.append("" AND folder_id in ("");
            boolean anyAdded = false;
            for (LocalFolder folder : folders) {
                if (anyAdded) {
                    whereClause.append("","");
                }
                anyAdded = true;
                whereClause.append(""?"");
                args.add(Long.toString(folder.getId()));
            }
            whereClause.append("" )"");
        }
        if (messages != null && messages.length > 0) {
            whereClause.append("" AND ( "");
            boolean anyAdded = false;
            for (Message message : messages) {
                if (anyAdded) {
                    whereClause.append("" OR "");
                }
                anyAdded = true;
                whereClause.append("" ( uid = ? AND folder_id = ? ) "");
                args.add(message.getUid());
                args.add(Long.toString(((LocalFolder)message.getFolder()).getId()));
            }
            whereClause.append("" )"");
        }
        if (forbiddenFlags != null && forbiddenFlags.length > 0) {
            whereClause.append("" AND ("");
            boolean anyAdded = false;
            for (Flag flag : forbiddenFlags) {
                if (anyAdded) {
                    whereClause.append("" AND "");
                }
                anyAdded = true;
                whereClause.append("" flags NOT LIKE ?"");

                args.add(""%"" + flag.toString() + ""%"");
            }
            whereClause.append("" )"");
        }
        if (requiredFlags != null && requiredFlags.length > 0) {
            whereClause.append("" AND ("");
            boolean anyAdded = false;
            for (Flag flag : requiredFlags) {
                if (anyAdded) {
                    whereClause.append("" OR "");
                }
                anyAdded = true;
                whereClause.append("" flags LIKE ?"");

                args.add(""%"" + flag.toString() + ""%"");
            }
            whereClause.append("" )"");
        }

        if (K9.DEBUG) {
            Log.v(K9.LOG_TAG, ""whereClause = "" + whereClause.toString());
            Log.v(K9.LOG_TAG, ""args = "" + args);
        }
        return getMessages(
                   listener,
                   null,
                   ""SELECT ""
                   + GET_MESSAGES_COLS
                   + ""FROM messages WHERE deleted = 0 "" + whereClause.toString() + "" ORDER BY date DESC""
                   , args.toArray(EMPTY_STRING_ARRAY)
               );
    }
    /*
     * Given a query string, actually do the query for the messages and
     * call the MessageRetrievalListener for each one
     */
    private Message[] getMessages(
        final MessageRetrievalListener listener,
        final LocalFolder folder,
        final String queryString, final String[] placeHolders
    ) throws MessagingException {
        final ArrayList<LocalMessage> messages = new ArrayList<LocalMessage>();
        final int j = database.execute(false, new DbCallback<Integer>() {
            @Override
            public Integer doDbWork(final SQLiteDatabase db) throws WrappedException {
                Cursor cursor = null;
                int i = 0;
                try {
                    cursor = db.rawQuery(queryString + "" LIMIT 10"", placeHolders);

                    while (cursor.moveToNext()) {
                        LocalMessage message = new LocalMessage(null, folder);
                        message.populateFromGetMessageCursor(cursor);

                        messages.add(message);
                        if (listener != null) {
                            listener.messageFinished(message, i, -1);
                        }
                        i++;
                    }
                    cursor.close();
                    cursor = db.rawQuery(queryString + "" LIMIT -1 OFFSET 10"", placeHolders);

                    while (cursor.moveToNext()) {
                        LocalMessage message = new LocalMessage(null, folder);
                        message.populateFromGetMessageCursor(cursor);

                        messages.add(message);
                        if (listener != null) {
                            listener.messageFinished(message, i, -1);
                        }
                        i++;
                    }
                } catch (Exception e) {
                    Log.d(K9.LOG_TAG, ""Got an exception "" + e);
                } finally {
                    if (cursor != null) {
                        cursor.close();
                    }
                }
                return i;
            }
        });
        if (listener != null) {
            listener.messagesFinished(j);
        }

        return messages.toArray(EMPTY_MESSAGE_ARRAY);

    }

    public AttachmentInfo getAttachmentInfo(final String attachmentId) throws UnavailableStorageException {
        return database.execute(false, new DbCallback<AttachmentInfo>() {
            @Override
            public AttachmentInfo doDbWork(final SQLiteDatabase db) throws WrappedException {
                String name;
                String type;
                int size;
                Cursor cursor = null;
                try {
                    cursor = db.query(
                                 ""attachments"",
                                 new String[] { ""name"", ""size"", ""mime_type"" },
                                 ""id = ?"",
                                 new String[] { attachmentId },
                                 null,
                                 null,
                                 null);
                    if (!cursor.moveToFirst()) {
                        return null;
                    }
                    name = cursor.getString(0);
                    size = cursor.getInt(1);
                    type = cursor.getString(2);
                    final AttachmentInfo attachmentInfo = new AttachmentInfo();
                    attachmentInfo.name = name;
                    attachmentInfo.size = size;
                    attachmentInfo.type = type;
                    return attachmentInfo;
                } finally {
                    if (cursor != null) {
                        cursor.close();
                    }
                }
            }
        });
    }

    public static class AttachmentInfo {
        public String name;
        public int size;
        public String type;
    }

    public void createFolders(final List<LocalFolder> foldersToCreate, final int visibleLimit) throws UnavailableStorageException {
        database.execute(true, new DbCallback<Void>() {
            @Override
            public Void doDbWork(final SQLiteDatabase db) throws WrappedException {
                for (LocalFolder folder : foldersToCreate) {
                    String name = folder.getName();
                    final  LocalFolder.PreferencesHolder prefHolder = folder.new PreferencesHolder();

                    // When created, special folders should always be displayed
                    // inbox should be integrated
                    // and the inbox and drafts folders should be syncced by default
                    if (mAccount.isSpecialFolder(name)) {
                        prefHolder.inTopGroup = true;
                        prefHolder.displayClass = LocalFolder.FolderClass.FIRST_CLASS;
                        if (name.equalsIgnoreCase(mAccount.getInboxFolderName())) {
                            prefHolder.integrate = true;
                            prefHolder.pushClass = LocalFolder.FolderClass.FIRST_CLASS;
                        } else {
                            prefHolder.pushClass = LocalFolder.FolderClass.INHERITED;

                        }
                        if (name.equalsIgnoreCase(mAccount.getInboxFolderName()) ||
                                name.equalsIgnoreCase(mAccount.getDraftsFolderName())) {
                            prefHolder.syncClass = LocalFolder.FolderClass.FIRST_CLASS;
                        } else {
                            prefHolder.syncClass = LocalFolder.FolderClass.NO_CLASS;
                        }
                    }
                    folder.refresh(name, prefHolder);   // Recover settings from Preferences

                    db.execSQL(""INSERT INTO folders (name, visible_limit, top_group, display_class, poll_class, push_class, integrate) VALUES (?, ?, ?, ?, ?, ?, ?)"", new Object[] {
                                   name,
                                   visibleLimit,
                                   prefHolder.inTopGroup ? 1 : 0,
                                   prefHolder.displayClass.name(),
                                   prefHolder.syncClass.name(),
                                   prefHolder.pushClass.name(),
                                   prefHolder.integrate ? 1 : 0,
                               });

                }
                return null;
            }
        });
    }

    public class LocalFolder extends Folder implements Serializable {
        /**
         *
         */
        private static final long serialVersionUID = -1973296520918624767L;
        private String mName = null;
        private long mFolderId = -1;
        private int mUnreadMessageCount = -1;
        private int mFlaggedMessageCount = -1;
        private int mVisibleLimit = -1;
        private String prefId = null;
        private FolderClass mDisplayClass = FolderClass.NO_CLASS;
        private FolderClass mSyncClass = FolderClass.INHERITED;
        private FolderClass mPushClass = FolderClass.SECOND_CLASS;
        private boolean mInTopGroup = false;
        private String mPushState = null;
        private boolean mIntegrate = false;
        // mLastUid is used during syncs. It holds the highest UID within the local folder so we
        // know whether or not an unread message added to the local folder is actually ""new"" or not.
        private Integer mLastUid = null;

        public LocalFolder(String name) {
            super(LocalStore.this.mAccount);
            this.mName = name;

            if (LocalStore.this.mAccount.getInboxFolderName().equals(getName())) {

                mSyncClass =  FolderClass.FIRST_CLASS;
                mPushClass =  FolderClass.FIRST_CLASS;
                mInTopGroup = true;
            }


        }

        public LocalFolder(long id) {
            super(LocalStore.this.mAccount);
            this.mFolderId = id;
        }

        public long getId() {
            return mFolderId;
        }

        @Override
        public void open(final OpenMode mode) throws MessagingException {
            if (isOpen()) {
                return;
            }
            try {
                database.execute(false, new DbCallback<Void>() {
                    @Override
                    public Void doDbWork(final SQLiteDatabase db) throws WrappedException {
                        Cursor cursor = null;
                        try {
                            String baseQuery = ""SELECT "" + GET_FOLDER_COLS + "" FROM folders "";

                            if (mName != null) {
                                cursor = db.rawQuery(baseQuery + ""where folders.name = ?"", new String[] { mName });
                            } else {
                                cursor = db.rawQuery(baseQuery + ""where folders.id = ?"", new String[] { Long.toString(mFolderId) });
                            }

                            if (cursor.moveToFirst()) {
                                int folderId = cursor.getInt(0);
                                if (folderId > 0) {
                                    open(folderId, cursor.getString(1), cursor.getInt(2), cursor.getInt(3), cursor.getLong(4), cursor.getString(5), cursor.getString(6), cursor.getLong(7), cursor.getInt(8), cursor.getInt(9), cursor.getInt(10), cursor.getString(11), cursor.getString(12), cursor.getString(13));
                                }
                            } else {
                                Log.w(K9.LOG_TAG, ""Creating folder "" + getName() + "" with existing id "" + getId());
                                create(FolderType.HOLDS_MESSAGES);
                                open(mode);
                            }
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        } finally {
                            if (cursor != null) {
                                cursor.close();
                            }
                        }
                        return null;
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }
        }

        private void open(int id, String name, int unreadCount, int visibleLimit, long lastChecked, String status, String pushState, long lastPushed, int flaggedCount, int integrate, int topGroup, String syncClass, String pushClass, String displayClass) throws MessagingException {
            mFolderId = id;
            mName = name;
            mUnreadMessageCount = unreadCount;
            mVisibleLimit = visibleLimit;
            mPushState = pushState;
            mFlaggedMessageCount = flaggedCount;
            super.setStatus(status);
            // Only want to set the local variable stored in the super class.  This class
            // does a DB update on setLastChecked
            super.setLastChecked(lastChecked);
            super.setLastPush(lastPushed);
            mInTopGroup = topGroup == 1  ? true : false;
            mIntegrate = integrate == 1 ? true : false;
            String noClass = FolderClass.NO_CLASS.toString();
            mDisplayClass = Folder.FolderClass.valueOf((displayClass == null) ? noClass : displayClass);
            mPushClass = Folder.FolderClass.valueOf((pushClass == null) ? noClass : pushClass);
            mSyncClass = Folder.FolderClass.valueOf((syncClass == null) ? noClass : syncClass);

        }

        @Override
        public boolean isOpen() {
            return (mFolderId != -1 && mName != null);
        }

        @Override
        public OpenMode getMode() {
            return OpenMode.READ_WRITE;
        }

        @Override
        public String getName() {
            return mName;
        }

        @Override
        public boolean exists() throws MessagingException {
            return database.execute(false, new DbCallback<Boolean>() {
                @Override
                public Boolean doDbWork(final SQLiteDatabase db) throws WrappedException {
                    Cursor cursor = null;
                    try {
                        cursor = db.rawQuery(""SELECT id FROM folders ""
                                             + ""where folders.name = ?"", new String[] { LocalFolder.this
                                                     .getName()
                                                                                      });
                        if (cursor.moveToFirst()) {
                            int folderId = cursor.getInt(0);
                            return (folderId > 0);
                        } else {
                            return false;
                        }
                    } finally {
                        if (cursor != null) {
                            cursor.close();
                        }
                    }
                }
            });
        }

        @Override
        public boolean create(FolderType type) throws MessagingException {
            return create(type, mAccount.getDisplayCount());
        }

        @Override
        public boolean create(FolderType type, final int visibleLimit) throws MessagingException {
            if (exists()) {
                throw new MessagingException(""Folder "" + mName + "" already exists."");
            }
            List<LocalFolder> foldersToCreate = new ArrayList<LocalFolder>(1);
            foldersToCreate.add(this);
            LocalStore.this.createFolders(foldersToCreate, visibleLimit);

            return true;
        }

        private class PreferencesHolder {
            FolderClass displayClass = mDisplayClass;
            FolderClass syncClass = mSyncClass;
            FolderClass pushClass = mPushClass;
            boolean inTopGroup = mInTopGroup;
            boolean integrate = mIntegrate;
        }

        @Override
        public void close() {
            mFolderId = -1;
        }

        @Override
        public int getMessageCount() throws MessagingException {
            try {
                return database.execute(false, new DbCallback<Integer>() {
                    @Override
                    public Integer doDbWork(final SQLiteDatabase db) throws WrappedException {
                        try {
                            open(OpenMode.READ_WRITE);
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        }
                        Cursor cursor = null;
                        try {
                            cursor = db.rawQuery(""SELECT COUNT(*) FROM messages WHERE deleted = 0 and folder_id = ?"",
                                                 new String[] {
                                                     Long.toString(mFolderId)
                                                 });
                            cursor.moveToFirst();
                            return cursor.getInt(0);   //messagecount
                        } finally {
                            if (cursor != null) {
                                cursor.close();
                            }
                        }
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }
        }

        @Override
        public int getUnreadMessageCount() throws MessagingException {
            open(OpenMode.READ_WRITE);
            return mUnreadMessageCount;
        }

        @Override
        public int getFlaggedMessageCount() throws MessagingException {
            open(OpenMode.READ_WRITE);
            return mFlaggedMessageCount;
        }

        public void setUnreadMessageCount(final int unreadMessageCount) throws MessagingException {
            mUnreadMessageCount = Math.max(0, unreadMessageCount);
            updateFolderColumn(""unread_count"", mUnreadMessageCount);
        }

        public void setFlaggedMessageCount(final int flaggedMessageCount) throws MessagingException {
            mFlaggedMessageCount = Math.max(0, flaggedMessageCount);
            updateFolderColumn(""flagged_count"", mFlaggedMessageCount);
        }

        @Override
        public void setLastChecked(final long lastChecked) throws MessagingException {
            try {
                open(OpenMode.READ_WRITE);
                LocalFolder.super.setLastChecked(lastChecked);
            } catch (MessagingException e) {
                throw new WrappedException(e);
            }
            updateFolderColumn(""last_updated"", lastChecked);
        }

        @Override
        public void setLastPush(final long lastChecked) throws MessagingException {
            try {
                open(OpenMode.READ_WRITE);
                LocalFolder.super.setLastPush(lastChecked);
            } catch (MessagingException e) {
                throw new WrappedException(e);
            }
            updateFolderColumn(""last_pushed"", lastChecked);
        }

        public int getVisibleLimit() throws MessagingException {
            open(OpenMode.READ_WRITE);
            return mVisibleLimit;
        }

        public void purgeToVisibleLimit(MessageRemovalListener listener) throws MessagingException {
            if (mVisibleLimit == 0) {
                return ;
            }
            open(OpenMode.READ_WRITE);
            Message[] messages = getMessages(null, false);
            for (int i = mVisibleLimit; i < messages.length; i++) {
                if (listener != null) {
                    listener.messageRemoved(messages[i]);
                }
                messages[i].destroy();

            }
        }


        public void setVisibleLimit(final int visibleLimit) throws MessagingException {
            mVisibleLimit = visibleLimit;
            updateFolderColumn(""visible_limit"", mVisibleLimit);
        }

        @Override
        public void setStatus(final String status) throws MessagingException {
            updateFolderColumn(""status"", status);
        }
        public void setPushState(final String pushState) throws MessagingException {
            mPushState = pushState;
            updateFolderColumn(""push_state"", pushState);
        }

        private void updateFolderColumn(final String column, final Object value) throws MessagingException {
            try {
                database.execute(false, new DbCallback<Void>() {
                    @Override
                    public Void doDbWork(final SQLiteDatabase db) throws WrappedException {
                        try {
                            open(OpenMode.READ_WRITE);
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        }
                        db.execSQL(""UPDATE folders SET "" + column + "" = ? WHERE id = ?"", new Object[] { value, mFolderId });
                        return null;
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }
        }

        public String getPushState() {
            return mPushState;
        }
        @Override
        public FolderClass getDisplayClass() {
            return mDisplayClass;
        }

        @Override
        public FolderClass getSyncClass() {
            if (FolderClass.INHERITED == mSyncClass) {
                return getDisplayClass();
            } else {
                return mSyncClass;
            }
        }

        public FolderClass getRawSyncClass() {
            return mSyncClass;

        }

        @Override
        public FolderClass getPushClass() {
            if (FolderClass.INHERITED == mPushClass) {
                return getSyncClass();
            } else {
                return mPushClass;
            }
        }

        public FolderClass getRawPushClass() {
            return mPushClass;

        }

        public void setDisplayClass(FolderClass displayClass) throws MessagingException {
            mDisplayClass = displayClass;
            updateFolderColumn(""display_class"", mDisplayClass.name());

        }

        public void setSyncClass(FolderClass syncClass) throws MessagingException {
            mSyncClass = syncClass;
            updateFolderColumn(""poll_class"", mSyncClass.name());
        }
        public void setPushClass(FolderClass pushClass) throws MessagingException {
            mPushClass = pushClass;
            updateFolderColumn(""push_class"", mPushClass.name());
        }

        public boolean isIntegrate() {
            return mIntegrate;
        }
        public void setIntegrate(boolean integrate) throws MessagingException {
            mIntegrate = integrate;
            updateFolderColumn(""integrate"", mIntegrate ? 1 : 0);
        }

        private String getPrefId(String name) {
            if (prefId == null) {
                prefId = uUid + ""."" + name;
            }

            return prefId;
        }

        private String getPrefId() throws MessagingException {
            open(OpenMode.READ_WRITE);
            return getPrefId(mName);

        }

        public void delete() throws MessagingException {
            String id = getPrefId();

            SharedPreferences.Editor editor = LocalStore.this.getPreferences().edit();

            editor.remove(id + "".displayMode"");
            editor.remove(id + "".syncMode"");
            editor.remove(id + "".pushMode"");
            editor.remove(id + "".inTopGroup"");
            editor.remove(id + "".integrate"");

            editor.commit();
        }

        public void save() throws MessagingException {
            SharedPreferences.Editor editor = LocalStore.this.getPreferences().edit();
            save(editor);
            editor.commit();
        }

        public void save(SharedPreferences.Editor editor) throws MessagingException {
            String id = getPrefId();

            // there can be a lot of folders.  For the defaults, let's not save prefs, saving space, except for INBOX
            if (mDisplayClass == FolderClass.NO_CLASS && !mAccount.getInboxFolderName().equals(getName())) {
                editor.remove(id + "".displayMode"");
            } else {
                editor.putString(id + "".displayMode"", mDisplayClass.name());
            }

            if (mSyncClass == FolderClass.INHERITED && !mAccount.getInboxFolderName().equals(getName())) {
                editor.remove(id + "".syncMode"");
            } else {
                editor.putString(id + "".syncMode"", mSyncClass.name());
            }

            if (mPushClass == FolderClass.SECOND_CLASS && !mAccount.getInboxFolderName().equals(getName())) {
                editor.remove(id + "".pushMode"");
            } else {
                editor.putString(id + "".pushMode"", mPushClass.name());
            }
            editor.putBoolean(id + "".inTopGroup"", mInTopGroup);

            editor.putBoolean(id + "".integrate"", mIntegrate);

        }

        public void refresh(String name, PreferencesHolder prefHolder) {
            String id = getPrefId(name);

            SharedPreferences preferences = LocalStore.this.getPreferences();

            try {
                prefHolder.displayClass = FolderClass.valueOf(preferences.getString(id + "".displayMode"",
                                          prefHolder.displayClass.name()));
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Unable to load displayMode for "" + getName(), e);
            }
            if (prefHolder.displayClass == FolderClass.NONE) {
                prefHolder.displayClass = FolderClass.NO_CLASS;
            }

            try {
                prefHolder.syncClass = FolderClass.valueOf(preferences.getString(id  + "".syncMode"",
                                       prefHolder.syncClass.name()));
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Unable to load syncMode for "" + getName(), e);

            }
            if (prefHolder.syncClass == FolderClass.NONE) {
                prefHolder.syncClass = FolderClass.INHERITED;
            }

            try {
                prefHolder.pushClass = FolderClass.valueOf(preferences.getString(id  + "".pushMode"",
                                       prefHolder.pushClass.name()));
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Unable to load pushMode for "" + getName(), e);
            }
            if (prefHolder.pushClass == FolderClass.NONE) {
                prefHolder.pushClass = FolderClass.INHERITED;
            }
            prefHolder.inTopGroup = preferences.getBoolean(id + "".inTopGroup"", prefHolder.inTopGroup);
            prefHolder.integrate = preferences.getBoolean(id + "".integrate"", prefHolder.integrate);

        }

        @Override
        public void fetch(final Message[] messages, final FetchProfile fp, final MessageRetrievalListener listener)
        throws MessagingException {
            try {
                database.execute(false, new DbCallback<Void>() {
                    @Override
                    public Void doDbWork(final SQLiteDatabase db) throws WrappedException {
                        try {
                            open(OpenMode.READ_WRITE);
                            if (fp.contains(FetchProfile.Item.BODY)) {
                                for (Message message : messages) {
                                    LocalMessage localMessage = (LocalMessage)message;
                                    Cursor cursor = null;
                                    MimeMultipart mp = new MimeMultipart();
                                    mp.setSubType(""mixed"");
                                    try {
                                        cursor = db.rawQuery(""SELECT html_content, text_content, mime_type FROM messages ""
                                                             + ""WHERE id = ?"",
                                                             new String[] { Long.toString(localMessage.mId) });
                                        cursor.moveToNext();
                                        String htmlContent = cursor.getString(0);
                                        String textContent = cursor.getString(1);
                                        String mimeType = cursor.getString(2);
                                        if (mimeType != null && mimeType.toLowerCase().startsWith(""multipart/"")) {
                                            // If this is a multipart message, preserve both text
                                            // and html parts, as well as the subtype.
                                            mp.setSubType(mimeType.toLowerCase().replaceFirst(""^multipart/"", """"));
                                            if (textContent != null) {
                                                LocalTextBody body = new LocalTextBody(textContent, htmlContent);
                                                MimeBodyPart bp = new MimeBodyPart(body, ""text/plain"");
                                                mp.addBodyPart(bp);
                                            }
                                            if (htmlContent != null) {
                                                TextBody body = new TextBody(htmlContent);
                                                MimeBodyPart bp = new MimeBodyPart(body, ""text/html"");
                                                mp.addBodyPart(bp);
                                            }

                                            // If we have both text and html content and our MIME type
                                            // isn't multipart/alternative, then corral them into a new
                                            // multipart/alternative part and put that into the parent.
                                            // If it turns out that this is the only part in the parent
                                            // MimeMultipart, it'll get fixed below before we attach to
                                            // the message.
                                            if (textContent != null && htmlContent != null && !mimeType.equalsIgnoreCase(""multipart/alternative"")) {
                                                MimeMultipart alternativeParts = mp;
                                                alternativeParts.setSubType(""alternative"");
                                                mp = new MimeMultipart();
                                                mp.addBodyPart(new MimeBodyPart(alternativeParts));
                                            }
                                        } else if (mimeType != null && mimeType.equalsIgnoreCase(""text/plain"")) {
                                            // If it's text, add only the plain part. The MIME
                                            // container will drop away below.
                                            if (textContent != null) {
                                                LocalTextBody body = new LocalTextBody(textContent, htmlContent);
                                                MimeBodyPart bp = new MimeBodyPart(body, ""text/plain"");
                                                mp.addBodyPart(bp);
                                            }
                                        } else if (mimeType != null && mimeType.equalsIgnoreCase(""text/html"")) {
                                            // If it's html, add only the html part. The MIME
                                            // container will drop away below.
                                            if (htmlContent != null) {
                                                TextBody body = new TextBody(htmlContent);
                                                MimeBodyPart bp = new MimeBodyPart(body, ""text/html"");
                                                mp.addBodyPart(bp);
                                            }
                                        } else {
                                            // MIME type not set. Grab whatever part we can get,
                                            // with Text taking precedence. This preserves pre-HTML
                                            // composition behaviour.
                                            if (textContent != null) {
                                                LocalTextBody body = new LocalTextBody(textContent, htmlContent);
                                                MimeBodyPart bp = new MimeBodyPart(body, ""text/plain"");
                                                mp.addBodyPart(bp);
                                            } else if (htmlContent != null) {
                                                TextBody body = new TextBody(htmlContent);
                                                MimeBodyPart bp = new MimeBodyPart(body, ""text/html"");
                                                mp.addBodyPart(bp);
                                            }
                                        }

                                    } catch (Exception e) {
                                        Log.e(K9.LOG_TAG, ""Exception fetching message:"", e);
                                    } finally {
                                        if (cursor != null) {
                                            cursor.close();
                                        }
                                    }

                                    try {
                                        cursor = db.query(
                                                     ""attachments"",
                                                     new String[] {
                                                         ""id"",
                                                         ""size"",
                                                         ""name"",
                                                         ""mime_type"",
                                                         ""store_data"",
                                                         ""content_uri"",
                                                         ""content_id"",
                                                         ""content_disposition""
                                                     },
                                                     ""message_id = ?"",
                                                     new String[] { Long.toString(localMessage.mId) },
                                                     null,
                                                     null,
                                                     null);

                                        while (cursor.moveToNext()) {
                                            long id = cursor.getLong(0);
                                            int size = cursor.getInt(1);
                                            String name = cursor.getString(2);
                                            String type = cursor.getString(3);
                                            String storeData = cursor.getString(4);
                                            String contentUri = cursor.getString(5);
                                            String contentId = cursor.getString(6);
                                            String contentDisposition = cursor.getString(7);
                                            Body body = null;

                                            if (contentDisposition == null) {
                                                contentDisposition = ""attachment"";
                                            }

                                            if (contentUri != null) {
                                                body = new LocalAttachmentBody(Uri.parse(contentUri), mApplication);
                                            }

                                            MimeBodyPart bp = new LocalAttachmentBodyPart(body, id);
                                            bp.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, ""base64"");
                                            if (name != null) {
                                                bp.setHeader(MimeHeader.HEADER_CONTENT_TYPE,
                                                             String.format(""%s;\n name=\""%s\"""",
                                                                           type,
                                                                           name));
                                                bp.setHeader(MimeHeader.HEADER_CONTENT_DISPOSITION,
                                                             String.format(""%s;\n filename=\""%s\"";\n size=%d"",
                                                                           contentDisposition,
                                                                           name, // TODO: Should use encoded word defined in RFC 2231.
                                                                           size));
                                            }

                                            bp.setHeader(MimeHeader.HEADER_CONTENT_ID, contentId);
                                            /*
                                             * HEADER_ANDROID_ATTACHMENT_STORE_DATA is a custom header we add to that
                                             * we can later pull the attachment from the remote store if necessary.
                                             */
                                            bp.setHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA, storeData);

                                            mp.addBodyPart(bp);
                                        }
                                    } finally {
                                        if (cursor != null) {
                                            cursor.close();
                                        }
                                    }

                                    if (mp.getCount() == 0) {
                                        // If we have no body, remove the container and create a
                                        // dummy plain text body. This check helps prevents us from
                                        // triggering T_MIME_NO_TEXT and T_TVD_MIME_NO_HEADERS
                                        // SpamAssassin rules.
                                        localMessage.setHeader(MimeHeader.HEADER_CONTENT_TYPE, ""text/plain"");
                                        localMessage.setBody(new TextBody(""""));
                                    } else if (mp.getCount() == 1 && (mp.getBodyPart(0) instanceof LocalAttachmentBodyPart) == false)

                                    {
                                        // If we have only one part, drop the MimeMultipart container.
                                        BodyPart part = mp.getBodyPart(0);
                                        localMessage.setHeader(MimeHeader.HEADER_CONTENT_TYPE, part.getContentType());
                                        localMessage.setBody(part.getBody());
                                    } else {
                                        // Otherwise, attach the MimeMultipart to the message.
                                        localMessage.setBody(mp);
                                    }
                                }
                            }
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        }
                        return null;
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }
        }

        @Override
        public Message[] getMessages(int start, int end, Date earliestDate, MessageRetrievalListener listener)
        throws MessagingException {
            open(OpenMode.READ_WRITE);
            throw new MessagingException(
                ""LocalStore.getMessages(int, int, MessageRetrievalListener) not yet implemented"");
        }

        /**
         * Populate the header fields of the given list of messages by reading
         * the saved header data from the database.
         *
         * @param messages
         *            The messages whose headers should be loaded.
         * @throws UnavailableStorageException
         */
        private void populateHeaders(final List<LocalMessage> messages) throws UnavailableStorageException {
            database.execute(false, new DbCallback<Void>() {
                @Override
                public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                    Cursor cursor = null;
                    if (messages.size() == 0) {
                        return null;
                    }
                    try {
                        Map<Long, LocalMessage> popMessages = new HashMap<Long, LocalMessage>();
                        List<String> ids = new ArrayList<String>();
                        StringBuffer questions = new StringBuffer();

                        for (int i = 0; i < messages.size(); i++) {
                            if (i != 0) {
                                questions.append("", "");
                            }
                            questions.append(""?"");
                            LocalMessage message = messages.get(i);
                            Long id = message.getId();
                            ids.add(Long.toString(id));
                            popMessages.put(id, message);

                        }

                        cursor = db.rawQuery(
                                     ""SELECT message_id, name, value FROM headers "" + ""WHERE message_id in ( "" + questions + "") "",
                                     ids.toArray(EMPTY_STRING_ARRAY));


                        while (cursor.moveToNext()) {
                            Long id = cursor.getLong(0);
                            String name = cursor.getString(1);
                            String value = cursor.getString(2);
                            //Log.i(K9.LOG_TAG, ""Retrieved header name= "" + name + "", value = "" + value + "" for message "" + id);
                            popMessages.get(id).addHeader(name, value);
                        }
                    } finally {
                        if (cursor != null) {
                            cursor.close();
                        }
                    }
                    return null;
                }
            });
        }

        @Override
        public Message getMessage(final String uid) throws MessagingException {
            try {
                return database.execute(false, new DbCallback<Message>() {
                    @Override
                    public Message doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                        try {
                            open(OpenMode.READ_WRITE);
                            LocalMessage message = new LocalMessage(uid, LocalFolder.this);
                            Cursor cursor = null;

                            try {
                                cursor = db.rawQuery(
                                             ""SELECT ""
                                             + GET_MESSAGES_COLS
                                             + ""FROM messages WHERE uid = ? AND folder_id = ?"",
                                             new String[] {
                                                 message.getUid(), Long.toString(mFolderId)
                                             });
                                if (!cursor.moveToNext()) {
                                    return null;
                                }
                                message.populateFromGetMessageCursor(cursor);
                            } finally {
                                if (cursor != null) {
                                    cursor.close();
                                }
                            }
                            return message;
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        }
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }
        }

        @Override
        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException {
            return getMessages(listener, true);
        }

        @Override
        public Message[] getMessages(final MessageRetrievalListener listener, final boolean includeDeleted) throws MessagingException {
            try {
                return database.execute(false, new DbCallback<Message[]>() {
                    @Override
                    public Message[] doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                        try {
                            open(OpenMode.READ_WRITE);
                            return LocalStore.this.getMessages(
                                       listener,
                                       LocalFolder.this,
                                       ""SELECT "" + GET_MESSAGES_COLS
                                       + ""FROM messages WHERE ""
                                       + (includeDeleted ? """" : ""deleted = 0 AND "")
                                       + "" folder_id = ? ORDER BY date DESC""
                                       , new String[] {
                                           Long.toString(mFolderId)
                                       }
                                   );
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        }
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }
        }


        @Override
        public Message[] getMessages(String[] uids, MessageRetrievalListener listener)
        throws MessagingException {
            open(OpenMode.READ_WRITE);
            if (uids == null) {
                return getMessages(listener);
            }
            ArrayList<Message> messages = new ArrayList<Message>();
            for (String uid : uids) {
                Message message = getMessage(uid);
                if (message != null) {
                    messages.add(message);
                }
            }
            return messages.toArray(EMPTY_MESSAGE_ARRAY);
        }

        @Override
        public void copyMessages(Message[] msgs, Folder folder) throws MessagingException {
            if (!(folder instanceof LocalFolder)) {
                throw new MessagingException(""copyMessages called with incorrect Folder"");
            }
            ((LocalFolder) folder).appendMessages(msgs, true);
        }

        @Override
        public void moveMessages(final Message[] msgs, final Folder destFolder) throws MessagingException {
            if (!(destFolder instanceof LocalFolder)) {
                throw new MessagingException(""moveMessages called with non-LocalFolder"");
            }

            final LocalFolder lDestFolder = (LocalFolder)destFolder;

            try {
                database.execute(false, new DbCallback<Void>() {
                    @Override
                    public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                        try {
                            lDestFolder.open(OpenMode.READ_WRITE);
                            for (Message message : msgs) {
                                LocalMessage lMessage = (LocalMessage)message;

                                if (!message.isSet(Flag.SEEN)) {
                                    setUnreadMessageCount(getUnreadMessageCount() - 1);
                                    lDestFolder.setUnreadMessageCount(lDestFolder.getUnreadMessageCount() + 1);
                                }

                                if (message.isSet(Flag.FLAGGED)) {
                                    setFlaggedMessageCount(getFlaggedMessageCount() - 1);
                                    lDestFolder.setFlaggedMessageCount(lDestFolder.getFlaggedMessageCount() + 1);
                                }

                                String oldUID = message.getUid();

                                if (K9.DEBUG)
                                    Log.d(K9.LOG_TAG, ""Updating folder_id to "" + lDestFolder.getId() + "" for message with UID ""
                                          + message.getUid() + "", id "" + lMessage.getId() + "" currently in folder "" + getName());

                                message.setUid(K9.LOCAL_UID_PREFIX + UUID.randomUUID().toString());

                                db.execSQL(""UPDATE messages "" + ""SET folder_id = ?, uid = ? "" + ""WHERE id = ?"", new Object[] {
                                               lDestFolder.getId(),
                                               message.getUid(),
                                               lMessage.getId()
                                           });

                                LocalMessage placeHolder = new LocalMessage(oldUID, LocalFolder.this);
                                placeHolder.setFlagInternal(Flag.DELETED, true);
                                placeHolder.setFlagInternal(Flag.SEEN, true);
                                appendMessages(new Message[] { placeHolder });
                            }
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        }
                        return null;
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }

        }

        /**
         * Convenience transaction wrapper for storing a message and set it as fully downloaded. Implemented mainly to speed up DB transaction commit.
         *
         * @param message Message to store. Never <code>null</code>.
         * @param runnable What to do before setting {@link Flag#X_DOWNLOADED_FULL}. Never <code>null</code>.
         * @return The local version of the message. Never <code>null</code>.
         * @throws MessagingException
         */
        public Message storeSmallMessage(final Message message, final Runnable runnable) throws MessagingException {
            return database.execute(true, new DbCallback<Message>() {
                @Override
                public Message doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                    try {
                        appendMessages(new Message[] { message });
                        final String uid = message.getUid();
                        final Message result = getMessage(uid);
                        runnable.run();
                        // Set a flag indicating this message has now be fully downloaded
                        result.setFlag(Flag.X_DOWNLOADED_FULL, true);
                        return result;
                    } catch (MessagingException e) {
                        throw new WrappedException(e);
                    }
                }
            });
        }

        /**
         * The method differs slightly from the contract; If an incoming message already has a uid
         * assigned and it matches the uid of an existing message then this message will replace the
         * old message. It is implemented as a delete/insert. This functionality is used in saving
         * of drafts and re-synchronization of updated server messages.
         *
         * NOTE that although this method is located in the LocalStore class, it is not guaranteed
         * that the messages supplied as parameters are actually {@link LocalMessage} instances (in
         * fact, in most cases, they are not). Therefore, if you want to make local changes only to a
         * message, retrieve the appropriate local message instance first (if it already exists).
         */
        @Override
        public void appendMessages(Message[] messages) throws MessagingException {
            appendMessages(messages, false);
        }

        public void destroyMessages(final Message[] messages) throws MessagingException {
            try {
                database.execute(true, new DbCallback<Void>() {
                    @Override
                    public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                        for (Message message : messages) {
                            try {
                                message.destroy();
                            } catch (MessagingException e) {
                                throw new WrappedException(e);
                            }
                        }
                        return null;
                    }
                });
            } catch (MessagingException e) {
                throw new WrappedException(e);
            }
        }


        /**
         * The method differs slightly from the contract; If an incoming message already has a uid
         * assigned and it matches the uid of an existing message then this message will replace the
         * old message. It is implemented as a delete/insert. This functionality is used in saving
         * of drafts and re-synchronization of updated server messages.
         *
         * NOTE that although this method is located in the LocalStore class, it is not guaranteed
         * that the messages supplied as parameters are actually {@link LocalMessage} instances (in
         * fact, in most cases, they are not). Therefore, if you want to make local changes only to a
         * message, retrieve the appropriate local message instance first (if it already exists).
         * @param messages
         * @param copy
         */
        private void appendMessages(final Message[] messages, final boolean copy) throws MessagingException {
            open(OpenMode.READ_WRITE);
            try {
                database.execute(true, new DbCallback<Void>() {
                    @Override
                    public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                        try {
                            for (Message message : messages) {
                                if (!(message instanceof MimeMessage)) {
                                    throw new Error(""LocalStore can only store Messages that extend MimeMessage"");
                                }

                                String uid = message.getUid();
                                if (uid == null || copy) {
                                    uid = K9.LOCAL_UID_PREFIX + UUID.randomUUID().toString();
                                    if (!copy) {
                                        message.setUid(uid);
                                    }
                                } else {
                                    Message oldMessage = getMessage(uid);
                                    if (oldMessage != null && !oldMessage.isSet(Flag.SEEN)) {
                                        setUnreadMessageCount(getUnreadMessageCount() - 1);
                                    }
                                    if (oldMessage != null && oldMessage.isSet(Flag.FLAGGED)) {
                                        setFlaggedMessageCount(getFlaggedMessageCount() - 1);
                                    }
                                    /*
                                     * The message may already exist in this Folder, so delete it first.
                                     */
                                    deleteAttachments(message.getUid());
                                    db.execSQL(""DELETE FROM messages WHERE folder_id = ? AND uid = ?"",
                                               new Object[]
                                               { mFolderId, message.getUid() });
                                }

                                ArrayList<Part> viewables = new ArrayList<Part>();
                                ArrayList<Part> attachments = new ArrayList<Part>();
                                MimeUtility.collectParts(message, viewables, attachments);

                                StringBuffer sbHtml = new StringBuffer();
                                StringBuffer sbText = new StringBuffer();
                                for (Part viewable : viewables) {
                                    try {
                                        String text = MimeUtility.getTextFromPart(viewable);

                                        /*
                                         * Small hack to make sure the string ""null"" doesn't end up
                                         * in one of the StringBuffers.
                                         */
                                        if (text == null) {
                                            text = """";
                                        }

                                        /*
                                         * Anything with MIME type text/html will be stored as such. Anything
                                         * else will be stored as text/plain.
                                         */
                                        if (viewable.getMimeType().equalsIgnoreCase(""text/html"")) {
                                            sbHtml.append(text);
                                        } else {
                                            sbText.append(text);
                                        }
                                    } catch (Exception e) {
                                        throw new MessagingException(""Unable to get text for message part"", e);
                                    }
                                }

                                String text = sbText.toString();
                                String html = markupContent(text, sbHtml.toString());
                                String preview = calculateContentPreview(text);
                                // If we couldn't generate a reasonable preview from the text part, try doing it with the HTML part.
                                if (preview == null || preview.length() == 0) {
                                    preview = calculateContentPreview(HtmlConverter.htmlToText(html));
                                }

                                try {
                                    ContentValues cv = new ContentValues();
                                    cv.put(""uid"", uid);
                                    cv.put(""subject"", message.getSubject());
                                    cv.put(""sender_list"", Address.pack(message.getFrom()));
                                    cv.put(""date"", message.getSentDate() == null
                                           ? System.currentTimeMillis() : message.getSentDate().getTime());
                                    cv.put(""flags"", Utility.combine(message.getFlags(), ',').toUpperCase());
                                    cv.put(""deleted"", message.isSet(Flag.DELETED) ? 1 : 0);
                                    cv.put(""folder_id"", mFolderId);
                                    cv.put(""to_list"", Address.pack(message.getRecipients(RecipientType.TO)));
                                    cv.put(""cc_list"", Address.pack(message.getRecipients(RecipientType.CC)));
                                    cv.put(""bcc_list"", Address.pack(message.getRecipients(RecipientType.BCC)));
                                    cv.put(""html_content"", html.length() > 0 ? html : null);
                                    cv.put(""text_content"", text.length() > 0 ? text : null);
                                    cv.put(""preview"", preview.length() > 0 ? preview : null);
                                    cv.put(""reply_to_list"", Address.pack(message.getReplyTo()));
                                    cv.put(""attachment_count"", attachments.size());
                                    cv.put(""internal_date"",  message.getInternalDate() == null
                                           ? System.currentTimeMillis() : message.getInternalDate().getTime());
                                    cv.put(""mime_type"", message.getMimeType());

                                    String messageId = message.getMessageId();
                                    if (messageId != null) {
                                        cv.put(""message_id"", messageId);
                                    }
                                    long messageUid;
                                    messageUid = db.insert(""messages"", ""uid"", cv);
                                    for (Part attachment : attachments) {
                                        saveAttachment(messageUid, attachment, copy);
                                    }
                                    saveHeaders(messageUid, (MimeMessage)message);
                                    if (!message.isSet(Flag.SEEN)) {
                                        setUnreadMessageCount(getUnreadMessageCount() + 1);
                                    }
                                    if (message.isSet(Flag.FLAGGED)) {
                                        setFlaggedMessageCount(getFlaggedMessageCount() + 1);
                                    }
                                } catch (Exception e) {
                                    throw new MessagingException(""Error appending message"", e);
                                }
                            }
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        }
                        return null;
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }
        }

        /**
         * Update the given message in the LocalStore without first deleting the existing
         * message (contrast with appendMessages). This method is used to store changes
         * to the given message while updating attachments and not removing existing
         * attachment data.
         * TODO In the future this method should be combined with appendMessages since the Message
         * contains enough data to decide what to do.
         * @param message
         * @throws MessagingException
         */
        public void updateMessage(final LocalMessage message) throws MessagingException {
            open(OpenMode.READ_WRITE);
            try {
                database.execute(false, new DbCallback<Void>() {
                    @Override
                    public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                        try {
                            ArrayList<Part> viewables = new ArrayList<Part>();
                            ArrayList<Part> attachments = new ArrayList<Part>();

                            message.buildMimeRepresentation();

                            MimeUtility.collectParts(message, viewables, attachments);

                            StringBuffer sbHtml = new StringBuffer();
                            StringBuffer sbText = new StringBuffer();
                            for (int i = 0, count = viewables.size(); i < count; i++) {
                                Part viewable = viewables.get(i);
                                try {
                                    String text = MimeUtility.getTextFromPart(viewable);

                                    /*
                                     * Small hack to make sure the string ""null"" doesn't end up
                                     * in one of the StringBuffers.
                                     */
                                    if (text == null) {
                                        text = """";
                                    }

                                    /*
                                     * Anything with MIME type text/html will be stored as such. Anything
                                     * else will be stored as text/plain.
                                     */
                                    if (viewable.getMimeType().equalsIgnoreCase(""text/html"")) {
                                        sbHtml.append(text);
                                    } else {
                                        sbText.append(text);
                                    }
                                } catch (Exception e) {
                                    throw new MessagingException(""Unable to get text for message part"", e);
                                }
                            }

                            String text = sbText.toString();
                            String html = markupContent(text, sbHtml.toString());
                            String preview = calculateContentPreview(text);
                            // If we couldn't generate a reasonable preview from the text part, try doing it with the HTML part.
                            if (preview == null || preview.length() == 0) {
                                preview = calculateContentPreview(HtmlConverter.htmlToText(html));
                            }
                            try {
                                db.execSQL(""UPDATE messages SET ""
                                           + ""uid = ?, subject = ?, sender_list = ?, date = ?, flags = ?, ""
                                           + ""folder_id = ?, to_list = ?, cc_list = ?, bcc_list = ?, ""
                                           + ""html_content = ?, text_content = ?, preview = ?, reply_to_list = ?, ""
                                           + ""attachment_count = ? WHERE id = ?"",
                                           new Object[] {
                                               message.getUid(),
                                               message.getSubject(),
                                               Address.pack(message.getFrom()),
                                               message.getSentDate() == null ? System
                                               .currentTimeMillis() : message.getSentDate()
                                               .getTime(),
                                               Utility.combine(message.getFlags(), ',').toUpperCase(),
                                               mFolderId,
                                               Address.pack(message
                                                            .getRecipients(RecipientType.TO)),
                                               Address.pack(message
                                                            .getRecipients(RecipientType.CC)),
                                               Address.pack(message
                                                            .getRecipients(RecipientType.BCC)),
                                               html.length() > 0 ? html : null,
                                               text.length() > 0 ? text : null,
                                               preview.length() > 0 ? preview : null,
                                               Address.pack(message.getReplyTo()),
                                               attachments.size(),
                                               message.mId
                                           });

                                for (int i = 0, count = attachments.size(); i < count; i++) {
                                    Part attachment = attachments.get(i);
                                    saveAttachment(message.mId, attachment, false);
                                }
                                saveHeaders(message.getId(), message);
                            } catch (Exception e) {
                                throw new MessagingException(""Error appending message"", e);
                            }
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        }
                        return null;
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }
        }

        /**
         * Save the headers of the given message. Note that the message is not
         * necessarily a {@link LocalMessage} instance.
         * @param id
         * @param message
         * @throws com.fsck.k9.mail.MessagingException
         */
        private void saveHeaders(final long id, final MimeMessage message) throws MessagingException {
            database.execute(true, new DbCallback<Void>() {
                @Override
                public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                    boolean saveAllHeaders = mAccount.saveAllHeaders();
                    boolean gotAdditionalHeaders = false;

                    deleteHeaders(id);
                    for (String name : message.getHeaderNames()) {
                        if (saveAllHeaders || HEADERS_TO_SAVE.contains(name)) {
                            String[] values = message.getHeader(name);
                            for (String value : values) {
                                ContentValues cv = new ContentValues();
                                cv.put(""message_id"", id);
                                cv.put(""name"", name);
                                cv.put(""value"", value);
                                db.insert(""headers"", ""name"", cv);
                            }
                        } else {
                            gotAdditionalHeaders = true;
                        }
                    }

                    if (!gotAdditionalHeaders) {
                        // Remember that all headers for this message have been saved, so it is
                        // not necessary to download them again in case the user wants to see all headers.
                        List<Flag> appendedFlags = new ArrayList<Flag>();
                        appendedFlags.addAll(Arrays.asList(message.getFlags()));
                        appendedFlags.add(Flag.X_GOT_ALL_HEADERS);

                        db.execSQL(""UPDATE messages "" + ""SET flags = ? "" + "" WHERE id = ?"",
                                   new Object[]
                                   { Utility.combine(appendedFlags.toArray(), ',').toUpperCase(), id });
                    }
                    return null;
                }
            });
        }

        private void deleteHeaders(final long id) throws UnavailableStorageException {
            database.execute(false, new DbCallback<Void>() {
                @Override
                public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                    db.execSQL(""DELETE FROM headers WHERE message_id = ?"", new Object[]
                               { id });
                    return null;
                }
            });
        }

        /**
         * @param messageId
         * @param attachment
         * @param saveAsNew
         * @throws IOException
         * @throws MessagingException
         */
        private void saveAttachment(final long messageId, final Part attachment, final boolean saveAsNew)
        throws IOException, MessagingException {
            try {
                database.execute(true, new DbCallback<Void>() {
                    @Override
                    public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                        try {
                            long attachmentId = -1;
                            Uri contentUri = null;
                            int size = -1;
                            File tempAttachmentFile = null;

                            if ((!saveAsNew) && (attachment instanceof LocalAttachmentBodyPart)) {
                                attachmentId = ((LocalAttachmentBodyPart) attachment).getAttachmentId();
                            }

                            final File attachmentDirectory = StorageManager.getInstance(mApplication).getAttachmentDirectory(uUid, database.getStorageProviderId());
                            if (attachment.getBody() != null) {
                                Body body = attachment.getBody();
                                if (body instanceof LocalAttachmentBody) {
                                    contentUri = ((LocalAttachmentBody) body).getContentUri();
                                } else {
                                    /*
                                     * If the attachment has a body we're expected to save it into the local store
                                     * so we copy the data into a cached attachment file.
                                     */
                                    InputStream in = attachment.getBody().getInputStream();
                                    tempAttachmentFile = File.createTempFile(""att"", null, attachmentDirectory);
                                    FileOutputStream out = new FileOutputStream(tempAttachmentFile);
                                    size = IOUtils.copy(in, out);
                                    in.close();
                                    out.close();
                                }
                            }

                            if (size == -1) {
                                /*
                                 * If the attachment is not yet downloaded see if we can pull a size
                                 * off the Content-Disposition.
                                 */
                                String disposition = attachment.getDisposition();
                                if (disposition != null) {
                                    String s = MimeUtility.getHeaderParameter(disposition, ""size"");
                                    if (s != null) {
                                        size = Integer.parseInt(s);
                                    }
                                }
                            }
                            if (size == -1) {
                                size = 0;
                            }

                            String storeData =
                                Utility.combine(attachment.getHeader(
                                                    MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA), ',');

                            String name = MimeUtility.getHeaderParameter(attachment.getContentType(), ""name"");
                            String contentId = MimeUtility.getHeaderParameter(attachment.getContentId(), null);

                            String contentDisposition = MimeUtility.unfoldAndDecode(attachment.getDisposition());
                            String dispositionType = contentDisposition;

                            if (dispositionType != null) {
                                int pos = dispositionType.indexOf(';');
                                if (pos != -1) {
                                    // extract the disposition-type, ""attachment"", ""inline"" or extension-token (see the RFC 2183)
                                    dispositionType = dispositionType.substring(0, pos);
                                }
                            }

                            if (name == null && contentDisposition != null) {
                                name = MimeUtility.getHeaderParameter(contentDisposition, ""filename"");
                            }
                            if (attachmentId == -1) {
                                ContentValues cv = new ContentValues();
                                cv.put(""message_id"", messageId);
                                cv.put(""content_uri"", contentUri != null ? contentUri.toString() : null);
                                cv.put(""store_data"", storeData);
                                cv.put(""size"", size);
                                cv.put(""name"", name);
                                cv.put(""mime_type"", attachment.getMimeType());
                                cv.put(""content_id"", contentId);
                                cv.put(""content_disposition"", dispositionType);

                                attachmentId = db.insert(""attachments"", ""message_id"", cv);
                            } else {
                                ContentValues cv = new ContentValues();
                                cv.put(""content_uri"", contentUri != null ? contentUri.toString() : null);
                                cv.put(""size"", size);
                                db.update(""attachments"", cv, ""id = ?"", new String[]
                                          { Long.toString(attachmentId) });
                            }

                            if (attachmentId != -1 && tempAttachmentFile != null) {
                                File attachmentFile = new File(attachmentDirectory, Long.toString(attachmentId));
                                tempAttachmentFile.renameTo(attachmentFile);
                                contentUri = AttachmentProvider.getAttachmentUri(
                                                 mAccount,
                                                 attachmentId);
                                attachment.setBody(new LocalAttachmentBody(contentUri, mApplication));
                                ContentValues cv = new ContentValues();
                                cv.put(""content_uri"", contentUri != null ? contentUri.toString() : null);
                                db.update(""attachments"", cv, ""id = ?"", new String[]
                                          { Long.toString(attachmentId) });
                            }

                            /* The message has attachment with Content-ID */
                            if (contentId != null && contentUri != null) {
                                Cursor cursor = db.query(""messages"", new String[]
                                                         { ""html_content"" }, ""id = ?"", new String[]
                                                         { Long.toString(messageId) }, null, null, null);
                                try {
                                    if (cursor.moveToNext()) {
                                        String htmlContent = cursor.getString(0);

                                        if (htmlContent != null) {
                                            String newHtmlContent = htmlContent.replaceAll(
                                                                        Pattern.quote(""cid:"" + contentId),
                                                                        contentUri.toString());

                                            ContentValues cv = new ContentValues();
                                            cv.put(""html_content"", newHtmlContent);
                                            db.update(""messages"", cv, ""id = ?"", new String[]
                                                      { Long.toString(messageId) });
                                        }
                                    }
                                } finally {
                                    if (cursor != null) {
                                        cursor.close();
                                    }
                                }
                            }

                            if (attachmentId != -1 && attachment instanceof LocalAttachmentBodyPart) {
                                ((LocalAttachmentBodyPart) attachment).setAttachmentId(attachmentId);
                            }
                            return null;
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        } catch (IOException e) {
                            throw new WrappedException(e);
                        }
                    }
                });
            } catch (WrappedException e) {
                final Throwable cause = e.getCause();
                if (cause instanceof IOException) {
                    throw(IOException) cause;
                } else {
                    throw(MessagingException) cause;
                }
            }
        }

        /**
         * Changes the stored uid of the given message (using it's internal id as a key) to
         * the uid in the message.
         * @param message
         * @throws com.fsck.k9.mail.MessagingException
         */
        public void changeUid(final LocalMessage message) throws MessagingException {
            open(OpenMode.READ_WRITE);
            final ContentValues cv = new ContentValues();
            cv.put(""uid"", message.getUid());
            database.execute(false, new DbCallback<Void>() {
                @Override
                public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                    db.update(""messages"", cv, ""id = ?"", new String[]
                              { Long.toString(message.mId) });
                    return null;
                }
            });
        }

        @Override
        public void setFlags(Message[] messages, Flag[] flags, boolean value)
        throws MessagingException {
            open(OpenMode.READ_WRITE);
            for (Message message : messages) {
                message.setFlags(flags, value);
            }
        }

        @Override
        public void setFlags(Flag[] flags, boolean value)
        throws MessagingException {
            open(OpenMode.READ_WRITE);
            for (Message message : getMessages(null)) {
                message.setFlags(flags, value);
            }
        }

        @Override
        public String getUidFromMessageId(Message message) throws MessagingException {
            throw new MessagingException(""Cannot call getUidFromMessageId on LocalFolder"");
        }

        private void clearMessagesWhere(final String whereClause, final String[] params)  throws MessagingException {
            open(OpenMode.READ_ONLY);
            Message[] messages  = LocalStore.this.getMessages(
                                      null,
                                      this,
                                      ""SELECT "" + GET_MESSAGES_COLS + ""FROM messages WHERE "" + whereClause,
                                      params);

            for (Message message : messages) {
                deleteAttachments(message.getUid());
            }
            database.execute(false, new DbCallback<Void>() {
                @Override
                public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                    db.execSQL(""DELETE FROM messages WHERE "" + whereClause, params);
                    return null;
                }
            });
            resetUnreadAndFlaggedCounts();
        }

        public void clearMessagesOlderThan(long cutoff) throws MessagingException {
            final String where = ""folder_id = ? and date < ?"";
            final String[] params = new String[] {
                Long.toString(mFolderId), Long.toString(cutoff)
            };

            clearMessagesWhere(where, params);
        }



        public void clearAllMessages() throws MessagingException {
            final String where = ""folder_id = ?"";
            final String[] params = new String[] {
                Long.toString(mFolderId)
            };


            clearMessagesWhere(where, params);
            setPushState(null);
            setLastPush(0);
            setLastChecked(0);
            setVisibleLimit(mAccount.getDisplayCount());
        }

        private void resetUnreadAndFlaggedCounts() {
            try {
                int newUnread = 0;
                int newFlagged = 0;
                Message[] messages = getMessages(null);
                for (Message message : messages) {
                    if (!message.isSet(Flag.SEEN)) {
                        newUnread++;
                    }
                    if (message.isSet(Flag.FLAGGED)) {
                        newFlagged++;
                    }
                }
                setUnreadMessageCount(newUnread);
                setFlaggedMessageCount(newFlagged);
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Unable to fetch all messages from LocalStore"", e);
            }
        }


        @Override
        public void delete(final boolean recurse) throws MessagingException {
            try {
                database.execute(false, new DbCallback<Void>() {
                    @Override
                    public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                        try {
                            // We need to open the folder first to make sure we've got it's id
                            open(OpenMode.READ_ONLY);
                            Message[] messages = getMessages(null);
                            for (Message message : messages) {
                                deleteAttachments(message.getUid());
                            }
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        }
                        db.execSQL(""DELETE FROM folders WHERE id = ?"", new Object[]
                                   { Long.toString(mFolderId), });
                        return null;
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }
        }

        @Override
        public boolean equals(Object o) {
            if (o instanceof LocalFolder) {
                return ((LocalFolder)o).mName.equals(mName);
            }
            return super.equals(o);
        }

        @Override
        public int hashCode() {
            return mName.hashCode();
        }

        @Override
        public Flag[] getPermanentFlags() {
            return PERMANENT_FLAGS;
        }


        private void deleteAttachments(final long messageId) throws MessagingException {
            open(OpenMode.READ_WRITE);
            database.execute(false, new DbCallback<Void>() {
                @Override
                public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                    Cursor attachmentsCursor = null;
                    try {
                        attachmentsCursor = db.query(""attachments"", new String[]
                                                     { ""id"" }, ""message_id = ?"", new String[]
                                                     { Long.toString(messageId) }, null, null, null);
                        final File attachmentDirectory = StorageManager.getInstance(mApplication)
                                                         .getAttachmentDirectory(uUid, database.getStorageProviderId());
                        while (attachmentsCursor.moveToNext()) {
                            long attachmentId = attachmentsCursor.getLong(0);
                            try {
                                File file = new File(attachmentDirectory, Long.toString(attachmentId));
                                if (file.exists()) {
                                    file.delete();
                                }
                            } catch (Exception e) {

                            }
                        }
                    } finally {
                        if (attachmentsCursor != null) {
                            attachmentsCursor.close();
                        }
                    }
                    return null;
                }
            });
        }

        private void deleteAttachments(final String uid) throws MessagingException {
            open(OpenMode.READ_WRITE);
            try {
                database.execute(false, new DbCallback<Void>() {
                    @Override
                    public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                        Cursor messagesCursor = null;
                        try {
                            messagesCursor = db.query(""messages"", new String[]
                                                      { ""id"" }, ""folder_id = ? AND uid = ?"", new String[]
                                                      { Long.toString(mFolderId), uid }, null, null, null);
                            while (messagesCursor.moveToNext()) {
                                long messageId = messagesCursor.getLong(0);
                                deleteAttachments(messageId);

                            }
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        } finally {
                            if (messagesCursor != null) {
                                messagesCursor.close();
                            }
                        }
                        return null;
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }
        }

        /*
         * calculateContentPreview
         * Takes a plain text message body as a string.
         * Returns a message summary as a string suitable for showing in a message list
         *
         * A message summary should be about the first 160 characters
         * of unique text written by the message sender
         * Quoted text, ""On $date"" and so on will be stripped out.
         * All newlines and whitespace will be compressed.
         *
         */
        public String calculateContentPreview(String text) {
            if (text == null) {
                return null;
            }

            // Only look at the first 8k of a message when calculating
            // the preview.  This should avoid unnecessary
            // memory usage on large messages
            if (text.length() > 8192) {
                text = text.substring(0, 8192);
            }

            // try to remove lines of dashes in the preview
            text = text.replaceAll(""(?m)^----.*?$"", """");
            // remove quoted text from the preview
            text = text.replaceAll(""(?m)^[#>].*$"", """");
            // Remove a common quote header from the preview
            text = text.replaceAll(""(?m)^On .*wrote.?$"", """");
            // Remove a more generic quote header from the preview
            text = text.replaceAll(""(?m)^.*\\w+:$"", """");

            // URLs in the preview should just be shown as ""..."" - They're not
            // clickable and they usually overwhelm the preview
            text = text.replaceAll(""https?://\\S+"", ""..."");
            // Don't show newlines in the preview
            text = text.replaceAll(""(\\r|\\n)+"", "" "");
            // Collapse whitespace in the preview
            text = text.replaceAll(""\\s+"", "" "");
            if (text.length() <= 512) {
                return text;
            } else {
                return text.substring(0, 512);
            }

        }

        public String markupContent(String text, String html) {
            if (text.length() > 0 && html.length() == 0) {
                html = HtmlConverter.textToHtml(text);
            }

            html = HtmlConverter.convertEmoji2Img(html);

            return html;
        }


        @Override
        public boolean isInTopGroup() {
            return mInTopGroup;
        }

        public void setInTopGroup(boolean inTopGroup) throws MessagingException {
            mInTopGroup = inTopGroup;
            updateFolderColumn(""top_group"", mInTopGroup ? 1 : 0);
        }

        public Integer getLastUid() {
            return mLastUid;
        }

        /**
         * <p>Fetches the most recent <b>numeric</b> UID value in this folder.  This is used by
         * {@link com.fsck.k9.controller.MessagingController#shouldNotifyForMessage} to see if messages being
         * fetched are new and unread.  Messages are ""new"" if they have a UID higher than the most recent UID prior
         * to synchronization.</p>
         *
         * <p>This only works for protocols with numeric UIDs (like IMAP). For protocols with
         * alphanumeric UIDs (like POP), this method quietly fails and shouldNotifyForMessage() will
         * always notify for unread messages.</p>
         *
         * <p>Once Issue 1072 has been fixed, this method and shouldNotifyForMessage() should be
         * updated to use internal dates rather than UIDs to determine new-ness. While this doesn't
         * solve things for POP (which doesn't have internal dates), we can likely use this as a
         * framework to examine send date in lieu of internal date.</p>
         * @throws MessagingException
         */
        public void updateLastUid() throws MessagingException {
            Integer lastUid = database.execute(false, new DbCallback<Integer>() {
                @Override
                public Integer doDbWork(final SQLiteDatabase db) {
                    Cursor cursor = null;
                    try {
                        open(OpenMode.READ_ONLY);
                        cursor = db.rawQuery(""SELECT MAX(uid) FROM messages WHERE folder_id=?"", new String[] { Long.toString(mFolderId) });
                        if (cursor.getCount() > 0) {
                            cursor.moveToFirst();
                            return cursor.getInt(0);
                        }
                    } catch (Exception e) {
                        Log.e(K9.LOG_TAG, ""Unable to updateLastUid: "", e);
                    } finally {
                        if (cursor != null) {
                            cursor.close();
                        }
                    }
                    return null;
                }
            });
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Updated last UID for folder "" + mName + "" to "" + lastUid);
            mLastUid = lastUid;
        }

        public long getOldestMessageDate() throws MessagingException {
            return database.execute(false, new DbCallback<Long>() {
                @Override
                public Long doDbWork(final SQLiteDatabase db) {
                    Cursor cursor = null;
                    try {
                        open(OpenMode.READ_ONLY);
                        cursor = db.rawQuery(""SELECT MIN(date) FROM messages WHERE folder_id=?"", new String[] { Long.toString(mFolderId) });
                        if (cursor.getCount() > 0) {
                            cursor.moveToFirst();
                            return cursor.getLong(0);
                        }
                    } catch (Exception e) {
                        Log.e(K9.LOG_TAG, ""Unable to fetch oldest message date: "", e);
                    } finally {
                        if (cursor != null) {
                            cursor.close();
                        }
                    }
                    return null;
                }
            });
        }

    }

    public static class LocalTextBody extends TextBody {
        /**
         * This is an HTML-ified version of the message for display purposes.
         */
        private String mBodyForDisplay;

        public LocalTextBody(String body) {
            super(body);
        }

        public LocalTextBody(String body, String bodyForDisplay) {
            super(body);
            this.mBodyForDisplay = bodyForDisplay;
        }

        public String getBodyForDisplay() {
            return mBodyForDisplay;
        }

        public void setBodyForDisplay(String mBodyForDisplay) {
            this.mBodyForDisplay = mBodyForDisplay;
        }

    }//LocalTextBody

    public class LocalMessage extends MimeMessage {
        private long mId;
        private int mAttachmentCount;
        private String mSubject;

        private String mPreview = """";

        private boolean mToMeCalculated = false;
        private boolean mCcMeCalculated = false;
        private boolean mToMe = false;
        private boolean mCcMe = false;

        private boolean mHeadersLoaded = false;
        private boolean mMessageDirty = false;

        public LocalMessage() {
        }

        LocalMessage(String uid, Folder folder) {
            this.mUid = uid;
            this.mFolder = folder;
        }

        private void populateFromGetMessageCursor(Cursor cursor)
        throws MessagingException {
            final String subject = cursor.getString(0);
            this.setSubject(subject == null ? """" : subject);

            Address[] from = Address.unpack(cursor.getString(1));
            if (from.length > 0) {
                this.setFrom(from[0]);
            }
            this.setInternalSentDate(new Date(cursor.getLong(2)));
            this.setUid(cursor.getString(3));
            String flagList = cursor.getString(4);
            if (flagList != null && flagList.length() > 0) {
                String[] flags = flagList.split("","");

                for (String flag : flags) {
                    try {
                        this.setFlagInternal(Flag.valueOf(flag), true);
                    }

                    catch (Exception e) {
                        if (!""X_BAD_FLAG"".equals(flag)) {
                            Log.w(K9.LOG_TAG, ""Unable to parse flag "" + flag);
                        }
                    }
                }
            }
            this.mId = cursor.getLong(5);
            this.setRecipients(RecipientType.TO, Address.unpack(cursor.getString(6)));
            this.setRecipients(RecipientType.CC, Address.unpack(cursor.getString(7)));
            this.setRecipients(RecipientType.BCC, Address.unpack(cursor.getString(8)));
            this.setReplyTo(Address.unpack(cursor.getString(9)));

            this.mAttachmentCount = cursor.getInt(10);
            this.setInternalDate(new Date(cursor.getLong(11)));
            this.setMessageId(cursor.getString(12));

            final String preview = cursor.getString(14);
            mPreview = (preview == null ? """" : preview);

            if (this.mFolder == null) {
                LocalFolder f = new LocalFolder(cursor.getInt(13));
                f.open(LocalFolder.OpenMode.READ_WRITE);
                this.mFolder = f;
            }
        }

        /**
         * Fetch the message text for display. This always returns an HTML-ified version of the
         * message, even if it was originally a text-only message.
         * @return HTML version of message for display purposes or null.
         * @throws MessagingException
         */
        public String getTextForDisplay() throws MessagingException {
            String text = null;    // First try and fetch an HTML part.
            Part part = MimeUtility.findFirstPartByMimeType(this, ""text/html"");
            if (part == null) {
                // If that fails, try and get a text part.
                part = MimeUtility.findFirstPartByMimeType(this, ""text/plain"");
                if (part != null && part.getBody() instanceof LocalStore.LocalTextBody) {
                    text = ((LocalStore.LocalTextBody) part.getBody()).getBodyForDisplay();
                }
            } else {
                // We successfully found an HTML part; do the necessary character set decoding.
                text = MimeUtility.getTextFromPart(part);
            }
            return text;
        }


        /* Custom version of writeTo that updates the MIME message based on localMessage
         * changes.
         */

        @Override
        public void writeTo(OutputStream out) throws IOException, MessagingException {
            if (mMessageDirty) buildMimeRepresentation();
            super.writeTo(out);
        }

        private void buildMimeRepresentation() throws MessagingException {
            if (!mMessageDirty) {
                return;
            }

            super.setSubject(mSubject);
            if (this.mFrom != null && this.mFrom.length > 0) {
                super.setFrom(this.mFrom[0]);
            }

            super.setReplyTo(mReplyTo);
            super.setSentDate(this.getSentDate());
            super.setRecipients(RecipientType.TO, mTo);
            super.setRecipients(RecipientType.CC, mCc);
            super.setRecipients(RecipientType.BCC, mBcc);
            if (mMessageId != null) super.setMessageId(mMessageId);

            mMessageDirty = false;
        }

        public String getPreview() {
            return mPreview;
        }

        @Override
        public String getSubject() {
            return mSubject;
        }


        @Override
        public void setSubject(String subject) throws MessagingException {
            mSubject = subject;
            mMessageDirty = true;
        }


        @Override
        public void setMessageId(String messageId) {
            mMessageId = messageId;
            mMessageDirty = true;
        }

        public boolean hasAttachments() {
            if (mAttachmentCount > 0) {
                return true;
            } else {
                return false;
            }

        }

        public int getAttachmentCount() {
            return mAttachmentCount;
        }

        @Override
        public void setFrom(Address from) throws MessagingException {
            this.mFrom = new Address[] { from };
            mMessageDirty = true;
        }


        @Override
        public void setReplyTo(Address[] replyTo) throws MessagingException {
            if (replyTo == null || replyTo.length == 0) {
                mReplyTo = null;
            } else {
                mReplyTo = replyTo;
            }
            mMessageDirty = true;
        }


        /*
         * For performance reasons, we add headers instead of setting them (see super implementation)
         * which removes (expensive) them before adding them
         */
        @Override
        public void setRecipients(RecipientType type, Address[] addresses) throws MessagingException {
            if (type == RecipientType.TO) {
                if (addresses == null || addresses.length == 0) {
                    this.mTo = null;
                } else {
                    this.mTo = addresses;
                }
            } else if (type == RecipientType.CC) {
                if (addresses == null || addresses.length == 0) {
                    this.mCc = null;
                } else {
                    this.mCc = addresses;
                }
            } else if (type == RecipientType.BCC) {
                if (addresses == null || addresses.length == 0) {
                    this.mBcc = null;
                } else {
                    this.mBcc = addresses;
                }
            } else {
                throw new MessagingException(""Unrecognized recipient type."");
            }
            mMessageDirty = true;
        }



        public boolean toMe() {
            try {
                if (!mToMeCalculated) {
                    for (Address address : getRecipients(RecipientType.TO)) {
                        if (mAccount.isAnIdentity(address)) {
                            mToMe = true;
                            mToMeCalculated = true;
                        }
                    }
                }
            } catch (MessagingException e) {
                // do something better than ignore this
                // getRecipients can throw a messagingexception
            }
            return mToMe;
        }





        public boolean ccMe() {
            try {

                if (!mCcMeCalculated) {
                    for (Address address : getRecipients(RecipientType.CC)) {
                        if (mAccount.isAnIdentity(address)) {
                            mCcMe = true;
                            mCcMeCalculated = true;
                        }
                    }

                }
            } catch (MessagingException e) {
                // do something better than ignore this
                // getRecipients can throw a messagingexception
            }

            return mCcMe;
        }






        public void setFlagInternal(Flag flag, boolean set) throws MessagingException {
            super.setFlag(flag, set);
        }

        public long getId() {
            return mId;
        }

        @Override
        public void setFlag(final Flag flag, final boolean set) throws MessagingException {

            try {
                database.execute(true, new DbCallback<Void>() {
                    @Override
                    public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                        try {
                            if (flag == Flag.DELETED && set) {
                                delete();
                            }

                            updateFolderCountsOnFlag(flag, set);


                            LocalMessage.super.setFlag(flag, set);
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        }
                        /*
                         * Set the flags on the message.
                         */
                        db.execSQL(""UPDATE messages "" + ""SET flags = ? "" + "" WHERE id = ?"", new Object[]
                                   { Utility.combine(getFlags(), ',').toUpperCase(), mId });
                        return null;
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }


        }

        /*
         * If a message is being marked as deleted we want to clear out it's content
         * and attachments as well. Delete will not actually remove the row since we need
         * to retain the uid for synchronization purposes.
         */
        private void delete() throws MessagingException

        {
            /*
             * Delete all of the message's content to save space.
             */
            try {
                database.execute(true, new DbCallback<Void>() {
                    @Override
                    public Void doDbWork(final SQLiteDatabase db) throws WrappedException, UnavailableStorageException {
                        db.execSQL(""UPDATE messages SET "" + ""deleted = 1,"" + ""subject = NULL, ""
                                   + ""sender_list = NULL, "" + ""date = NULL, "" + ""to_list = NULL, ""
                                   + ""cc_list = NULL, "" + ""bcc_list = NULL, "" + ""preview = NULL, ""
                                   + ""html_content = NULL, "" + ""text_content = NULL, ""
                                   + ""reply_to_list = NULL "" + ""WHERE id = ?"", new Object[]
                                   { mId });
                        /*
                         * Delete all of the message's attachments to save space.
                         * We do this explicit deletion here because we're not deleting the record
                         * in messages, which means our ON DELETE trigger for messages won't cascade
                         */
                        try {
                            ((LocalFolder) mFolder).deleteAttachments(mId);
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        }
                        db.execSQL(""DELETE FROM attachments WHERE message_id = ?"", new Object[]
                                   { mId });
                        return null;
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }
            ((LocalFolder)mFolder).deleteHeaders(mId);


        }

        /*
         * Completely remove a message from the local database
         */
        @Override
        public void destroy() throws MessagingException {
            try {
                database.execute(true, new DbCallback<Void>() {
                    @Override
                    public Void doDbWork(final SQLiteDatabase db) throws WrappedException,
                        UnavailableStorageException {
                        try {
                            updateFolderCountsOnFlag(Flag.X_DESTROYED, true);
                            ((LocalFolder) mFolder).deleteAttachments(mId);
                            db.execSQL(""DELETE FROM messages WHERE id = ?"", new Object[] { mId });
                        } catch (MessagingException e) {
                            throw new WrappedException(e);
                        }
                        return null;
                    }
                });
            } catch (WrappedException e) {
                throw(MessagingException) e.getCause();
            }
        }

        private void updateFolderCountsOnFlag(Flag flag, boolean set) {
            /*
             * Update the unread count on the folder.
             */
            try {
                LocalFolder folder = (LocalFolder)mFolder;
                if (flag == Flag.DELETED || flag == Flag.X_DESTROYED) {
                    if (!isSet(Flag.SEEN)) {
                        folder.setUnreadMessageCount(folder.getUnreadMessageCount() + (set ? -1 : 1));
                    }
                    if (isSet(Flag.FLAGGED)) {
                        folder.setFlaggedMessageCount(folder.getFlaggedMessageCount() + (set ? -1 : 1));
                    }
                }


                if (!isSet(Flag.DELETED)) {

                    if (flag == Flag.SEEN) {
                        if (set != isSet(Flag.SEEN)) {
                            folder.setUnreadMessageCount(folder.getUnreadMessageCount() + (set ? -1 : 1));
                        }
                    }

                    if (flag == Flag.FLAGGED) {
                        folder.setFlaggedMessageCount(folder.getFlaggedMessageCount() + (set ?  1 : -1));
                    }
                }
            } catch (MessagingException me) {
                Log.e(K9.LOG_TAG, ""Unable to update LocalStore unread message count"",
                      me);
                throw new RuntimeException(me);
            }
        }

        private void loadHeaders() throws UnavailableStorageException {
            ArrayList<LocalMessage> messages = new ArrayList<LocalMessage>();
            messages.add(this);
            mHeadersLoaded = true; // set true before calling populate headers to stop recursion
            ((LocalFolder) mFolder).populateHeaders(messages);

        }

        @Override
        public void addHeader(String name, String value) throws UnavailableStorageException {
            if (!mHeadersLoaded)
                loadHeaders();
            super.addHeader(name, value);
        }

        @Override
        public void setHeader(String name, String value) throws UnavailableStorageException {
            if (!mHeadersLoaded)
                loadHeaders();
            super.setHeader(name, value);
        }

        @Override
        public String[] getHeader(String name) throws UnavailableStorageException {
            if (!mHeadersLoaded)
                loadHeaders();
            return super.getHeader(name);
        }

        @Override
        public void removeHeader(String name) throws UnavailableStorageException {
            if (!mHeadersLoaded)
                loadHeaders();
            super.removeHeader(name);
        }

        @Override
        public Set<String> getHeaderNames() throws UnavailableStorageException {
            if (!mHeadersLoaded)
                loadHeaders();
            return super.getHeaderNames();
        }
    }

    public static class LocalAttachmentBodyPart extends MimeBodyPart {
        private long mAttachmentId = -1;

        public LocalAttachmentBodyPart(Body body, long attachmentId) throws MessagingException {
            super(body);
            mAttachmentId = attachmentId;
        }

        /**
         * Returns the local attachment id of this body, or -1 if it is not stored.
         * @return
         */
        public long getAttachmentId() {
            return mAttachmentId;
        }

        public void setAttachmentId(long attachmentId) {
            mAttachmentId = attachmentId;
        }

        @Override
        public String toString() {
            return """" + mAttachmentId;
        }
    }

    public static class LocalAttachmentBody implements Body {
        private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
        private Application mApplication;
        private Uri mUri;

        public LocalAttachmentBody(Uri uri, Application application) {
            mApplication = application;
            mUri = uri;
        }

        public InputStream getInputStream() throws MessagingException {
            try {
                return mApplication.getContentResolver().openInputStream(mUri);
            } catch (FileNotFoundException fnfe) {
                /*
                 * Since it's completely normal for us to try to serve up attachments that
                 * have been blown away, we just return an empty stream.
                 */
                return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);
            }
        }

        public void writeTo(OutputStream out) throws IOException, MessagingException {
            InputStream in = getInputStream();
            Base64OutputStream base64Out = new Base64OutputStream(out);
            IOUtils.copy(in, base64Out);
            base64Out.close();
        }

        public Uri getContentUri() {
            return mUri;
        }
    }
}
",True,145,1,1,6,31,18,30,L1
149,com.fsck.k9.mail.store.LockableDatabase.java,"package com.fsck.k9.mail.store;

import java.io.File;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import android.app.Application;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.util.Log;

import com.fsck.k9.K9;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.MessagingException;

public class LockableDatabase {

    /**
     * Callback interface for DB operations. Concept is similar to Spring
     * HibernateCallback.
     *
     * @param <T>
     *            Return value type for {@link #doDbWork(SQLiteDatabase)}
     */
    public static interface DbCallback<T> {
        /**
         * @param db
         *            The locked database on which the work should occur. Never
         *            <code>null</code>.
         * @return Any relevant data. Can be <code>null</code>.
         * @throws WrappedException
         * @throws UnavailableStorageException
         */
        T doDbWork(SQLiteDatabase db) throws WrappedException, UnavailableStorageException;
    }

    public static interface SchemaDefinition {
        int getVersion();

        /**
         * @param db Never <code>null</code>.
         */
        void doDbUpgrade(SQLiteDatabase db);
    }

    /**
     * Workaround exception wrapper used to keep the inner exception generated
     * in a {@link DbCallback}.
     */
    protected static class WrappedException extends RuntimeException {
        /**
         *
         */
        private static final long serialVersionUID = 8184421232587399369L;

        public WrappedException(final Exception cause) {
            super(cause);
        }
    }

    /**
     * Open the DB on mount and close the DB on unmount
     */
    private class StorageListener implements StorageManager.StorageListener {
        @Override
        public void onUnmount(final String providerId) {
            if (!providerId.equals(mStorageProviderId)) {
                return;
            }

            if (K9.DEBUG) {
                Log.d(K9.LOG_TAG, ""LockableDatabase: Closing DB "" + uUid + "" due to unmount event on StorageProvider: "" + providerId);
            }

            try {
                lockWrite();
                try {
                    mDb.close();
                } finally {
                    unlockWrite();
                }
            } catch (UnavailableStorageException e) {
                Log.w(K9.LOG_TAG, ""Unable to writelock on unmount"", e);
            }
        }

        @Override
        public void onMount(final String providerId) {
            if (!providerId.equals(mStorageProviderId)) {
                return;
            }

            if (K9.DEBUG) {
                Log.d(K9.LOG_TAG, ""LockableDatabase: Opening DB "" + uUid + "" due to mount event on StorageProvider: "" + providerId);
            }

            try {
                openOrCreateDataspace(mApplication);
            } catch (UnavailableStorageException e) {
                Log.e(K9.LOG_TAG, ""Unable to open DB on mount"", e);
            }
        }
    }

    private String mStorageProviderId;

    private SQLiteDatabase mDb;
    /**
     * Reentrant read lock
     */
    private final Lock mReadLock;
    /**
     * Reentrant write lock (if you lock it 2x from the same thread, you have to
     * unlock it 2x to release it)
     */
    private final Lock mWriteLock;

    {
        final ReadWriteLock lock = new ReentrantReadWriteLock(true);
        mReadLock = lock.readLock();
        mWriteLock = lock.writeLock();
    }

    private final StorageListener mStorageListener = new StorageListener();

    private Application mApplication;

    /**
     * {@link ThreadLocal} to check whether a DB transaction is occuring in the
     * current {@link Thread}.
     *
     * @see #execute(boolean, DbCallback)
     */
    private ThreadLocal<Boolean> inTransaction = new ThreadLocal<Boolean>();

    private SchemaDefinition mSchemaDefinition;

    private String uUid;

    /**
     * @param application
     *            Never <code>null</code>.
     * @param uUid
     *            Never <code>null</code>.
     * @param schemaDefinition
     *            Never <code>null</code
     */
    public LockableDatabase(final Application application, final String uUid, final SchemaDefinition schemaDefinition) {
        this.mApplication = application;
        this.uUid = uUid;
        this.mSchemaDefinition = schemaDefinition;
    }

    public void setStorageProviderId(String mStorageProviderId) {
        this.mStorageProviderId = mStorageProviderId;
    }

    public String getStorageProviderId() {
        return mStorageProviderId;
    }

    private StorageManager getStorageManager() {
        return StorageManager.getInstance(mApplication);
    }

    /**
     * Lock the storage for shared operations (concurrent threads are allowed to
     * run simultaneously).
     *
     * <p>
     * You <strong>have to</strong> invoke {@link #unlockRead()} when you're
     * done with the storage.
     * </p>
     *
     * @throws UnavailableStorageException
     *             If storage can't be locked because it is not available
     */
    protected void lockRead() throws UnavailableStorageException {
        mReadLock.lock();
        try {
            getStorageManager().lockProvider(mStorageProviderId);
        } catch (UnavailableStorageException e) {
            mReadLock.unlock();
            throw e;
        } catch (RuntimeException e) {
            mReadLock.unlock();
            throw e;
        }
    }

    protected void unlockRead() {
        getStorageManager().unlockProvider(mStorageProviderId);
        mReadLock.unlock();
    }

    /**
     * Lock the storage for exclusive access (other threads aren't allowed to
     * run simultaneously)
     *
     * <p>
     * You <strong>have to</strong> invoke {@link #unlockWrite()} when you're
     * done with the storage.
     * </p>
     *
     * @throws UnavailableStorageException
     *             If storage can't be locked because it is not available.
     */
    protected void lockWrite() throws UnavailableStorageException {
        lockWrite(mStorageProviderId);
    }

    /**
     * Lock the storage for exclusive access (other threads aren't allowed to
     * run simultaneously)
     *
     * <p>
     * You <strong>have to</strong> invoke {@link #unlockWrite()} when you're
     * done with the storage.
     * </p>
     *
     * @param providerId
     *            Never <code>null</code>.
     *
     * @throws UnavailableStorageException
     *             If storage can't be locked because it is not available.
     */
    protected void lockWrite(final String providerId) throws UnavailableStorageException {
        mWriteLock.lock();
        try {
            getStorageManager().lockProvider(providerId);
        } catch (UnavailableStorageException e) {
            mWriteLock.unlock();
            throw e;
        } catch (RuntimeException e) {
            mWriteLock.unlock();
            throw e;
        }
    }

    protected void unlockWrite() {
        unlockWrite(mStorageProviderId);
    }

    protected void unlockWrite(final String providerId) {
        getStorageManager().unlockProvider(providerId);
        mWriteLock.unlock();
    }

    /**
     * Execute a DB callback in a shared context (doesn't prevent concurrent
     * shared executions), taking care of locking the DB storage.
     *
     * <p>
     * Can be instructed to start a transaction if none is currently active in
     * the current thread. Callback will participe in any active transaction (no
     * inner transaction created).
     * </p>
     *
     * @param transactional
     *            <code>true</code> the callback must be executed in a
     *            transactional context.
     * @param callback
     *            Never <code>null</code>.
     *
     * @param <T>
     * @return Whatever {@link DbCallback#doDbWork(SQLiteDatabase)} returns.
     * @throws UnavailableStorageException
     */
    public <T> T execute(final boolean transactional, final DbCallback<T> callback) throws UnavailableStorageException {
        lockRead();
        final boolean doTransaction = transactional && inTransaction.get() == null;
        try {
            final boolean debug = K9.DEBUG;
            if (doTransaction) {
                inTransaction.set(Boolean.TRUE);
                mDb.beginTransaction();
            }
            try {
                final T result = callback.doDbWork(mDb);
                if (doTransaction) {
                    mDb.setTransactionSuccessful();
                }
                return result;
            } finally {
                if (doTransaction) {
                    final long begin;
                    if (debug) {
                        begin = System.currentTimeMillis();
                    } else {
                        begin = 0l;
                    }
                    // not doing endTransaction in the same 'finally' block of unlockRead() because endTransaction() may throw an exception
                    mDb.endTransaction();
                    if (debug) {
                        Log.v(K9.LOG_TAG, ""LockableDatabase: Transaction ended, took "" + Long.toString(System.currentTimeMillis() - begin) + ""ms / "" + new Exception().getStackTrace()[1].toString());
                    }
                }
            }
        } finally {
            if (doTransaction) {
                inTransaction.set(null);
            }
            unlockRead();
        }
    }

    /**
     * @param newProviderId
     *            Never <code>null</code>.
     * @throws MessagingException
     */
    public void switchProvider(final String newProviderId) throws MessagingException {
        if (newProviderId.equals(mStorageProviderId)) {
            Log.v(K9.LOG_TAG, ""LockableDatabase: Ignoring provider switch request as they are equal: "" + newProviderId);
            return;
        }

        final String oldProviderId = mStorageProviderId;
        lockWrite(oldProviderId);
        try {
            lockWrite(newProviderId);
            try {
                try {
                    mDb.close();
                } catch (Exception e) {
                    Log.i(K9.LOG_TAG, ""Unable to close DB on local store migration"", e);
                }

                final StorageManager storageManager = getStorageManager();

                // create new path
                prepareStorage(newProviderId);

                // move all database files
                Utility.moveRecursive(storageManager.getDatabase(uUid, oldProviderId), storageManager.getDatabase(uUid, newProviderId));
                // move all attachment files
                Utility.moveRecursive(storageManager.getAttachmentDirectory(uUid, oldProviderId), storageManager.getAttachmentDirectory(uUid, newProviderId));

                mStorageProviderId = newProviderId;

                // re-initialize this class with the new Uri
                openOrCreateDataspace(mApplication);
            } finally {
                unlockWrite(newProviderId);
            }
        } finally {
            unlockWrite(oldProviderId);
        }
    }

    public void open() throws UnavailableStorageException {
        lockWrite();
        try {
            openOrCreateDataspace(mApplication);
        } finally {
            unlockWrite();
        }
        StorageManager.getInstance(mApplication).addListener(mStorageListener);
    }

    /**
     *
     * @param application
     * @throws UnavailableStorageException
     */
    protected void openOrCreateDataspace(final Application application) throws UnavailableStorageException {

        lockWrite();
        try {
            final File databaseFile = prepareStorage(mStorageProviderId);
            try {
                mDb = SQLiteDatabase.openOrCreateDatabase(databaseFile, null);
            } catch (SQLiteException e) {
                // try to gracefully handle DB corruption - see issue 2537
                Log.w(K9.LOG_TAG, ""Unable to open DB "" + databaseFile + "" - removing file and retrying"", e);
                databaseFile.delete();
                mDb = SQLiteDatabase.openOrCreateDatabase(databaseFile, null);
            }
            if (mDb.getVersion() != mSchemaDefinition.getVersion()) {
                mSchemaDefinition.doDbUpgrade(mDb);
            }
        } finally {
            unlockWrite();
        }
    }

    /**
     * @param providerId
     *            Never <code>null</code>.
     * @return DB file.
     * @throws UnavailableStorageException
     */
    protected File prepareStorage(final String providerId) throws UnavailableStorageException {
        final StorageManager storageManager = getStorageManager();

        final File databaseFile;
        final File databaseParentDir;
        databaseFile = storageManager.getDatabase(uUid, providerId);
        databaseParentDir = databaseFile.getParentFile();
        if (databaseParentDir.isFile()) {
            // should be safe to inconditionally delete clashing file: user is not supposed to mess with our directory
            databaseParentDir.delete();
        }
        if (!databaseParentDir.exists()) {
            if (!databaseParentDir.mkdirs()) {
                // Android seems to be unmounting the storage...
                throw new UnavailableStorageException(""Unable to access: "" + databaseParentDir);
            }
            Utility.touchFile(databaseParentDir, "".nomedia"");
        }

        final File attachmentDir;
        final File attachmentParentDir;
        attachmentDir = storageManager
                        .getAttachmentDirectory(uUid, providerId);
        attachmentParentDir = attachmentDir.getParentFile();
        if (!attachmentParentDir.exists()) {
            attachmentParentDir.mkdirs();
            Utility.touchFile(attachmentParentDir, "".nomedia"");
        }
        if (!attachmentDir.exists()) {
            attachmentDir.mkdirs();
        }
        return databaseFile;
    }

    /**
     * Delete the backing database.
     *
     * @throws UnavailableStorageException
     */
    public void delete() throws UnavailableStorageException {
        delete(false);
    }

    public void recreate() throws UnavailableStorageException {
        delete(true);
    }

    /**
     * @param recreate
     *            <code>true</code> if the DB should be recreated after delete
     * @throws UnavailableStorageException
     */
    private void delete(final boolean recreate) throws UnavailableStorageException {
        lockWrite();
        try {
            try {
                mDb.close();
            } catch (Exception e) {

            }
            final StorageManager storageManager = getStorageManager();
            try {
                final File attachmentDirectory = storageManager.getAttachmentDirectory(uUid, mStorageProviderId);
                final File[] attachments = attachmentDirectory.listFiles();
                for (File attachment : attachments) {
                    if (attachment.exists()) {
                        attachment.delete();
                    }
                }
                if (attachmentDirectory.exists()) {
                    attachmentDirectory.delete();
                }
            } catch (Exception e) {
            }
            try {
                storageManager.getDatabase(uUid, mStorageProviderId).delete();
            } catch (Exception e) {
                Log.i(K9.LOG_TAG, ""LockableDatabase: delete(): Unable to delete backing DB file"", e);
            }

            if (recreate) {
                openOrCreateDataspace(mApplication);
            } else {
                // stop waiting for mount/unmount events
                getStorageManager().removeListener(mStorageListener);
            }
        } finally {
            unlockWrite();
        }
    }

}
",True,144,0,0,7,52,1,5,L1
150,com.fsck.k9.mail.store.UnavailableStorageException.java,"package com.fsck.k9.mail.store;

import com.fsck.k9.mail.MessagingException;

public class UnavailableStorageException extends MessagingException {

    private static final long serialVersionUID = 1348267375054620792L;

    public UnavailableStorageException(String message) {
        // consider this exception as a permanent failure by default
        this(message, true);
    }

    public UnavailableStorageException(String message, boolean perm) {
        super(message, perm);
    }

    public UnavailableStorageException(String message, Throwable throwable) {
        // consider this exception as permanent failure by default
        this(message, true, throwable);
    }

    public UnavailableStorageException(String message, boolean perm, Throwable throwable) {
        super(message, perm, throwable);
    }

}
",False,114,4,55,1,1,6,1,L1
151,com.fsck.k9.mail.store.StorageManager.java,"package com.fsck.k9.mail.store;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.IdentityHashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import android.app.Application;
import android.content.Context;
import android.os.Build;
import android.os.Environment;
import android.util.Log;

import com.fsck.k9.K9;
import com.fsck.k9.R;

/**
 * Manager for different {@link StorageProvider} -classes that abstract access
 * to sd-cards, additional internal memory and other storage-locations.
 */
public class StorageManager {

    /**
     * Provides entry points (File objects) to an underlying storage,
     * alleviating the caller from having to know where that storage is located.
     *
     * <p>
     * Allow checking for the denoted storage availability since its lifecycle
     * can evolving (a storage might become unavailable at some time and be back
     * online later).
     * </p>
     */
    public static interface StorageProvider {

        /**
         * Retrieve the uniquely identifier for the current implementation.
         *
         * <p>
         * It is expected that the identifier doesn't change over reboots since
         * it'll be used to save settings and retrieve the provider at a later
         * time.
         * </p>
         *
         * <p>
         * The returned identifier doesn't have to be user friendly.
         * </p>
         *
         * @return Never <code>null</code>.
         */
        String getId();

        /**
         * Hook point for provider initialization.
         *
         * @param context
         *            Never <code>null</code>.
         */
        void init(Context context);

        /**
         * @param context
         *            Never <code>null</code>.
         * @return A user displayable, localized name for this provider. Never
         *         <code>null</code>.
         */
        String getName(Context context);

        /**
         * Some implementations may not be able to return valid File handles
         * because the device doesn't provide the denoted storage. You can check
         * the provider compatibility with this method to prevent from having to
         * invoke this provider ever again.
         *
         * @param context
         *            TODO
         * @return Whether this provider supports the current device.
         * @see StorageManager#getAvailableProviders()
         */
        boolean isSupported(Context context);

        /**
         * Return the {@link File} to the choosen email database file. The
         * resulting {@link File} doesn't necessarily match an existing file on
         * the filesystem.
         *
         * @param context
         *            Never <code>null</code>.
         * @param id
         *            Never <code>null</code>.
         * @return Never <code>null</code>.
         */
        File getDatabase(Context context, String id);

        /**
         * Return the {@link File} to the choosen attachment directory. The
         * resulting {@link File} doesn't necessarily match an existing
         * directory on the filesystem.
         *
         * @param context
         *            Never <code>null</code>.
         * @param id
         *            Never <code>null</code>.
         * @return Never <code>null</code>.
         */
        File getAttachmentDirectory(Context context, String id);

        /**
         * Check for the underlying storage availability.
         *
         * @param context
         *            Never <code>null</code>.
         * @return Whether the underlying storage returned by this provider is
         *         ready for read/write operations at the time of invokation.
         */
        boolean isReady(Context context);

        /**
         * Retrieve the root of the underlying storage.
         *
         * @param context
         *            Never <code>null</code>.
         * @return The root directory of the denoted storage. Never
         *         <code>null</code>.
         */
        File getRoot(Context context);
    }

    /**
     * Interface for components wanting to be notified of storage availability
     * events.
     */
    public static interface StorageListener {
        /**
         * Invoked on storage mount (with read/write access).
         *
         * @param providerId
         *            Identifier (as returned by {@link StorageProvider#getId()}
         *            of the newly mounted storage. Never <code>null</code>.
         */
        void onMount(String providerId);

        /**
         * Invoked when a storage is about to be unmounted.
         *
         * @param providerId
         *            Identifier (as returned by {@link StorageProvider#getId()}
         *            of the to-be-unmounted storage. Never <code>null</code>.
         */
        void onUnmount(String providerId);
    }

    /**
     * Base provider class for providers that rely on well-known path to check
     * for storage availability.
     *
     * <p>
     * Since solely checking for paths can be unsafe, this class allows to check
     * for device compatibility using {@link #supportsVendor()}. If the vendor
     * specific check fails, the provider won't be able to provide any valid
     * File handle, regardless of the path existence.
     * </p>
     *
     * <p>
     * Moreover, this class validates the denoted storage path against mount
     * points using {@link StorageManager#isMountPoint(File)}.
     * </p>
     */
    public abstract static class FixedStorageProviderBase implements StorageProvider {
        /**
         * The root of the denoted storage. Used for mount points checking.
         */
        protected File mRoot;

        /**
         * Choosen base directory
         */
        protected File mApplicationDir;

        @Override
        public void init(final Context context) {
            mRoot = computeRoot(context);
            // use <STORAGE_ROOT>/k9
            mApplicationDir = new File(mRoot, ""k9"");
        }

        /**
         * Vendor specific checks
         *
         * @return Whether this provider supports the underlying vendor specific
         *         storage
         */
        protected abstract boolean supportsVendor();

        @Override
        public boolean isReady(Context context) {
            try {
                final File root = mRoot.getCanonicalFile();
                return isMountPoint(root)
                       && Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());
            } catch (IOException e) {
                Log.w(K9.LOG_TAG, ""Specified root isn't ready: "" + mRoot, e);
                return false;
            }
        }

        @Override
        public final boolean isSupported(Context context) {
            return mRoot.isDirectory() && supportsVendor();
        }

        @Override
        public File getDatabase(Context context, String id) {
            return new File(mApplicationDir, id + "".db"");
        }

        @Override
        public File getAttachmentDirectory(Context context, String id) {
            return new File(mApplicationDir, id + "".db_att"");
        }

        @Override
        public final File getRoot(Context context) {
            return mRoot;
        }

        /**
         * Retrieve the well-known storage root directory from the actual
         * implementation.
         *
         * @param context
         *            Never <code>null</code>.
         * @return Never <code>null</code>.
         */
        protected abstract File computeRoot(Context context);
    }

    /**
     * Strategy to access the always available internal storage.
     *
     * <p>
     * This implementation is expected to work on every device since it's based
     * on the regular Android API {@link Context#getDatabasePath(String)} and
     * uses the resul to retrieve the DB path and the attachment directory path.
     * </p>
     *
     * <p>
     * The underlying storage has always been used by K-9.
     * </p>
     */
    public static class InternalStorageProvider implements StorageProvider {

        public static final String ID = ""InternalStorage"";

        protected File mRoot;

        @Override
        public String getId() {
            return ID;
        }

        @Override
        public void init(Context context) {
            // XXX
            mRoot = new File(""/"");
        }

        @Override
        public String getName(Context context) {
            return context.getString(R.string.local_storage_provider_internal_label);
        }

        @Override
        public boolean isSupported(Context context) {
            return true;
        }

        @Override
        public File getDatabase(Context context, String id) {
            return context.getDatabasePath(id + "".db"");
        }

        @Override
        public File getAttachmentDirectory(Context context, String id) {
            // we store attachments in the database directory
            return context.getDatabasePath(id + "".db_att"");
        }

        @Override
        public boolean isReady(Context context) {
            return true;
        }

        @Override
        public File getRoot(Context context) {
            return mRoot;
        }
    }

    /**
     * Strategy for accessing the storage as returned by
     * {@link Environment#getExternalStorageDirectory()}. In order to be
     * compliant with Android recommendation regarding application uninstalling
     * and to prevent from cluttering the storage root, the choosen directory
     * will be
     * <code>&lt;STORAGE_ROOT&gt;/Android/data/&lt;APPLICATION_PACKAGE_NAME&gt;/files/</code>
     *
     * <p>
     * The denoted storage is usually a SD card.
     * </p>
     *
     * <p>
     * This provider is expected to work on all devices but the returned
     * underlying storage might not be always available, due to
     * mount/unmount/USB share events.
     * </p>
     */
    public static class ExternalStorageProvider implements StorageProvider {

        public static final String ID = ""ExternalStorage"";

        /**
         * Root of the denoted storage.
         */
        protected File mRoot;

        /**
         * Choosen base directory.
         */
        protected File mApplicationDirectory;

        public String getId() {
            return ID;
        }

        @Override
        public void init(Context context) {
            mRoot = Environment.getExternalStorageDirectory();
            mApplicationDirectory = new File(new File(new File(new File(mRoot, ""Android""), ""data""),
                                             context.getPackageName()), ""files"");
        }

        @Override
        public String getName(Context context) {
            return context.getString(R.string.local_storage_provider_external_label);
        }

        @Override
        public boolean isSupported(Context context) {
            return true;
        }

        @Override
        public File getDatabase(Context context, String id) {
            return new File(mApplicationDirectory, id + "".db"");
        }

        @Override
        public File getAttachmentDirectory(Context context, String id) {
            return new File(mApplicationDirectory, id + "".db_att"");
        }

        @Override
        public boolean isReady(Context context) {
            return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());
        }

        @Override
        public File getRoot(Context context) {
            return mRoot;
        }
    }

    /**
     * Storage provider to allow access the /emmc directory on a HTC Incredible.
     *
     * <p>
     * This implementation is experimental and _untested_.
     * </p>
     *
     * See http://groups.google.com/group/android-developers/browse_frm/thread/96f15e57150ed173
     *
     * @see FixedStorageProviderBase
     */
    public static class HtcIncredibleStorageProvider extends FixedStorageProviderBase {

        public static final String ID = ""HtcIncredibleStorage"";

        public String getId() {
            return ID;
        }

        @Override
        public String getName(Context context) {
            return context.getString(R.string.local_storage_provider_samsunggalaxy_label,
                                     Build.MODEL);
        }

        @Override
        protected boolean supportsVendor() {
            return ""inc"".equals(Build.DEVICE);
        }

        @Override
        protected File computeRoot(Context context) {
            return new File(""/emmc"");
        }
    }

    /**
     * Storage provider to allow access the Samsung Galaxy S 'internal SD card'.
     *
     * <p>
     * This implementation is experimental and _untested_.
     * </p>
     *
     * See http://groups.google.com/group/android-developers/browse_frm/thread/a1adf7122a75a657
     *
     * @see FixedStorageProviderBase
     */
    public static class SamsungGalaxySStorageProvider extends FixedStorageProviderBase {

        public static final String ID = ""SamsungGalaxySStorage"";

        public String getId() {
            return ID;
        }

        @Override
        public String getName(Context context) {
            return context.getString(R.string.local_storage_provider_samsunggalaxy_label,
                                     Build.MODEL);
        }

        @Override
        protected boolean supportsVendor() {
            // FIXME
            return ""GT-I5800"".equals(Build.DEVICE) || ""GT-I9000"".equals(Build.DEVICE)
                   || ""SGH-T959"".equals(Build.DEVICE) || ""SGH-I897"".equals(Build.DEVICE);
        }

        @Override
        protected File computeRoot(Context context) {
            return Environment.getExternalStorageDirectory(); // was: new
            // File(""/sdcard"")
        }
    }

    /**
     * Stores storage provider locking informations
     */
    public static class SynchronizationAid {
        /**
         * {@link Lock} has a thread semantic so it can't be released from
         * another thread - this flags act as a holder for the unmount state
         */
        public boolean unmounting = false;

        public final Lock readLock;

        public final Lock writeLock;

        {
            final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(true);
            readLock = readWriteLock.readLock();
            writeLock = readWriteLock.writeLock();
        }
    }

    /**
     * The active storage providers.
     */
    private final Map<String, StorageProvider> mProviders = new LinkedHashMap<String, StorageProvider>();

    /**
     * Locking data for the active storage providers.
     */
    private final Map<StorageProvider, SynchronizationAid> mProviderLocks = new IdentityHashMap<StorageProvider, SynchronizationAid>();

    protected final Application mApplication;

    /**
     * Listener to be notified for storage related events.
     */
    private List<StorageListener> mListeners = new ArrayList<StorageListener>();

    private static transient StorageManager instance;

    public static synchronized StorageManager getInstance(final Application application) {
        if (instance == null) {
            instance = new StorageManager(application);
        }
        return instance;
    }

    /**
     * @param file
     *            Canonical file to match. Never <code>null</code>.
     * @return Whether the specified file matches a filesystem root.
     * @throws IOException
     */
    public static boolean isMountPoint(final File file) {
        for (final File root : File.listRoots()) {
            if (root.equals(file)) {
                return true;
            }
        }
        return false;
    }

    /**
     * @param application
     *            Never <code>null</code>.
     * @throws NullPointerException
     *             If <tt>application</tt> is <code>null</code>.
     */
    protected StorageManager(final Application application) throws NullPointerException {
        if (application == null) {
            throw new NullPointerException(""No application instance given"");
        }

        mApplication = application;

        /*
         * 20101113/fiouzy:
         *
         * Here is where we define which providers are used, currently we only
         * allow the internal storage and the regular external storage.
         *
         * HTC Incredible storage and Samsung Galaxy S are omitted on purpose
         * (they're experimental and I don't have those devices to test).
         *
         *
         * !!! Make sure InternalStorageProvider is the first provider as it'll
         * be considered as the default provider !!!
         */
        final List<StorageProvider> allProviders = Arrays.asList(new InternalStorageProvider(),
                new ExternalStorageProvider());
        for (final StorageProvider provider : allProviders) {
            // check for provider compatibility
            if (provider.isSupported(mApplication)) {
                // provider is compatible! proceeding

                provider.init(application);
                mProviders.put(provider.getId(), provider);
                mProviderLocks.put(provider, new SynchronizationAid());
            }
        }

    }

    /**
     * @return Never <code>null</code>.
     */
    public String getDefaultProviderId() {
        // assume there is at least 1 provider defined
        return mProviders.entrySet().iterator().next().getKey();
    }

    /**
     * @param providerId
     *            Never <code>null</code>.
     * @return <code>null</code> if not found.
     */
    protected StorageProvider getProvider(final String providerId) {
        return mProviders.get(providerId);
    }

    /**
     * @param dbName
     *            Never <code>null</code>.
     * @param providerId
     *            Never <code>null</code>.
     * @return The resolved database file for the given provider ID.
     */
    public File getDatabase(final String dbName, final String providerId) {
        StorageProvider provider = getProvider(providerId);
        // TODO fallback to internal storage if no provider
        return provider.getDatabase(mApplication, dbName);
    }

    /**
     * @param dbName
     *            Never <code>null</code>.
     * @param providerId
     *            Never <code>null</code>.
     * @return The resolved attachement directory for the given provider ID.
     */
    public File getAttachmentDirectory(final String dbName, final String providerId) {
        StorageProvider provider = getProvider(providerId);
        // TODO fallback to internal storage if no provider
        return provider.getAttachmentDirectory(mApplication, dbName);
    }

    /**
     * @param providerId
     *            Never <code>null</code>.
     * @return Whether the specified provider is ready for read/write operations
     */
    public boolean isReady(final String providerId) {
        StorageProvider provider = getProvider(providerId);
        if (provider == null) {
            Log.w(K9.LOG_TAG, ""Storage-Provider \"""" + providerId + ""\"" does not exist"");
            return false;
        }
        return provider.isReady(mApplication);
    }

    /**
     * @return A map of available providers names, indexed by their ID. Never
     *         <code>null</code>.
     * @see StorageManager
     * @see StorageProvider#isSupported(Context)
     */
    public Map<String, String> getAvailableProviders() {
        final Map<String, String> result = new LinkedHashMap<String, String>();
        for (final Map.Entry<String, StorageProvider> entry : mProviders.entrySet()) {
            result.put(entry.getKey(), entry.getValue().getName(mApplication));
        }
        return result;
    }

    /**
     * @param path
     */
    public void onBeforeUnmount(final String path) {
        Log.i(K9.LOG_TAG, ""storage path \"""" + path + ""\"" unmounting"");
        final StorageProvider provider = resolveProvider(path);
        if (provider == null) {
            return;
        }
        for (final StorageListener listener : mListeners) {
            try {
                listener.onUnmount(provider.getId());
            } catch (Exception e) {
                Log.w(K9.LOG_TAG, ""Error while notifying StorageListener"", e);
            }
        }
        final SynchronizationAid sync = mProviderLocks.get(resolveProvider(path));
        sync.writeLock.lock();
        sync.unmounting = true;
        sync.writeLock.unlock();
    }

    public void onAfterUnmount(final String path) {
        Log.i(K9.LOG_TAG, ""storage path \"""" + path + ""\"" unmounted"");
        final StorageProvider provider = resolveProvider(path);
        if (provider == null) {
            return;
        }
        final SynchronizationAid sync = mProviderLocks.get(resolveProvider(path));
        sync.writeLock.lock();
        sync.unmounting = false;
        sync.writeLock.unlock();

        K9.setServicesEnabled(K9.app);
    }

    /**
     * @param path
     * @param readOnly
     */
    public void onMount(final String path, final boolean readOnly) {
        Log.i(K9.LOG_TAG, ""storage path \"""" + path + ""\"" mounted readOnly="" + readOnly);
        if (readOnly) {
            return;
        }

        final StorageProvider provider = resolveProvider(path);
        if (provider == null) {
            return;
        }
        for (final StorageListener listener : mListeners) {
            try {
                listener.onMount(provider.getId());
            } catch (Exception e) {
                Log.w(K9.LOG_TAG, ""Error while notifying StorageListener"", e);
            }
        }

        // XXX we should reset mail service ONLY if there are accounts using the storage (this is not done in a regular listener because it has to be invoked afterward)
        K9.setServicesEnabled(K9.app);
    }

    /**
     * @param path
     *            Never <code>null</code>.
     * @return The corresponding provider. <code>null</code> if no match.
     */
    protected StorageProvider resolveProvider(final String path) {
        for (final StorageProvider provider : mProviders.values()) {
            if (path.equals(provider.getRoot(mApplication).getAbsolutePath())) {
                return provider;
            }
        }
        return null;
    }

    public void addListener(final StorageListener listener) {
        mListeners.add(listener);
    }

    public void removeListener(final StorageListener listener) {
        mListeners.remove(listener);
    }

    /**
     * Try to lock the underlying storage to prevent concurrent unmount.
     *
     * <p>
     * You must invoke {@link #unlockProvider(String)} when you're done with the
     * storage.
     * </p>
     *
     * @param providerId
     * @throws UnavailableStorageException
     *             If the storage can't be locked.
     */
    public void lockProvider(final String providerId) throws UnavailableStorageException {
        final StorageProvider provider = getProvider(providerId);
        if (provider == null) {
            throw new UnavailableStorageException(""StorageProvider not found: "" + providerId);
        }
        // lock provider
        final SynchronizationAid sync = mProviderLocks.get(provider);
        final boolean locked = sync.readLock.tryLock();
        if (!locked || (locked && sync.unmounting)) {
            if (locked) {
                sync.readLock.unlock();
            }
            throw new UnavailableStorageException(""StorageProvider is unmounting"");
        } else if (locked && !provider.isReady(mApplication)) {
            sync.readLock.unlock();
            throw new UnavailableStorageException(""StorageProvider not ready"");
        }
    }

    public void unlockProvider(final String providerId) {
        final StorageProvider provider = getProvider(providerId);
        final SynchronizationAid sync = mProviderLocks.get(provider);
        sync.readLock.unlock();
    }
}
",True,145,1,1,7,53,11,2,L1
152,com.fsck.k9.mail.store.TrustManagerFactory.java,"
package com.fsck.k9.mail.store;

import android.app.Application;
import android.content.Context;
import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.helper.DomainNameChecker;

import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.HashMap;
import java.util.Map;

public final class TrustManagerFactory {
    private static final String LOG_TAG = ""TrustManagerFactory"";

    private static X509TrustManager defaultTrustManager;
    private static X509TrustManager unsecureTrustManager;
    private static X509TrustManager localTrustManager;

    private static X509Certificate[] lastCertChain = null;

    private static File keyStoreFile;
    private static KeyStore keyStore;


    private static class SimpleX509TrustManager implements X509TrustManager {
        public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
        }

        public X509Certificate[] getAcceptedIssuers() {
            return null;
        }
    }

    private static class SecureX509TrustManager implements X509TrustManager {
        private static final Map<String, SecureX509TrustManager> mTrustManager =
            new HashMap<String, SecureX509TrustManager>();

        private final String mHost;

        private SecureX509TrustManager(String host) {
            mHost = host;
        }

        public synchronized static X509TrustManager getInstance(String host) {
            SecureX509TrustManager trustManager;
            if (mTrustManager.containsKey(host)) {
                trustManager = mTrustManager.get(host);
            } else {
                trustManager = new SecureX509TrustManager(host);
                mTrustManager.put(host, trustManager);
            }

            return trustManager;
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
            defaultTrustManager.checkClientTrusted(chain, authType);
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
            TrustManagerFactory.setLastCertChain(chain);
            try {
                defaultTrustManager.checkServerTrusted(chain, authType);
            } catch (CertificateException e) {
                localTrustManager.checkServerTrusted(new X509Certificate[] {chain[0]}, authType);
            }
            if (!DomainNameChecker.match(chain[0], mHost)) {
                try {
                    String dn = chain[0].getSubjectDN().toString();
                    if ((dn != null) && (dn.equalsIgnoreCase(keyStore.getCertificateAlias(chain[0])))) {
                        return;
                    }
                } catch (KeyStoreException e) {
                    throw new CertificateException(""Certificate cannot be verified; KeyStore Exception: "" + e);
                }
                throw new CertificateException(""Certificate domain name does not match ""
                                               + mHost);
            }
        }

        public X509Certificate[] getAcceptedIssuers() {
            return defaultTrustManager.getAcceptedIssuers();
        }

    }

    static {
        try {
            javax.net.ssl.TrustManagerFactory tmf = javax.net.ssl.TrustManagerFactory.getInstance(""X509"");
            Application app = K9.app;
            keyStoreFile = new File(app.getDir(""KeyStore"", Context.MODE_PRIVATE) + File.separator + ""KeyStore.bks"");
            keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            java.io.FileInputStream fis;
            try {
                fis = new java.io.FileInputStream(keyStoreFile);
            } catch (FileNotFoundException e1) {
                fis = null;
            }
            try {
                keyStore.load(fis, """".toCharArray());
                //if (fis != null) {
                // fis.close();
                //}
            } catch (IOException e) {
                Log.e(LOG_TAG, ""KeyStore IOException while initializing TrustManagerFactory "", e);
                keyStore = null;
            } catch (CertificateException e) {
                Log.e(LOG_TAG, ""KeyStore CertificateException while initializing TrustManagerFactory "", e);
                keyStore = null;
            }
            tmf.init(keyStore);
            TrustManager[] tms = tmf.getTrustManagers();
            if (tms != null) {
                for (TrustManager tm : tms) {
                    if (tm instanceof X509TrustManager) {
                        localTrustManager = (X509TrustManager)tm;
                        break;
                    }
                }
            }
            tmf = javax.net.ssl.TrustManagerFactory.getInstance(""X509"");
            tmf.init((KeyStore)null);
            tms = tmf.getTrustManagers();
            if (tms != null) {
                for (TrustManager tm : tms) {
                    if (tm instanceof X509TrustManager) {
                        defaultTrustManager = (X509TrustManager) tm;
                        break;
                    }
                }
            }

        } catch (NoSuchAlgorithmException e) {
            Log.e(LOG_TAG, ""Unable to get X509 Trust Manager "", e);
        } catch (KeyStoreException e) {
            Log.e(LOG_TAG, ""Key Store exception while initializing TrustManagerFactory "", e);
        }
        unsecureTrustManager = new SimpleX509TrustManager();
    }

    private TrustManagerFactory() {
    }

    public static X509TrustManager get(String host, boolean secure) {
        return secure ? SecureX509TrustManager.getInstance(host) :
               unsecureTrustManager;
    }

    public static KeyStore getKeyStore() {
        return keyStore;
    }

    public static void setLastCertChain(X509Certificate[] chain) {
        lastCertChain = chain;
    }
    public static X509Certificate[] getLastCertChain() {
        return lastCertChain;
    }

    public static void addCertificateChain(String alias, X509Certificate[] chain) throws CertificateException {
        try {
            javax.net.ssl.TrustManagerFactory tmf = javax.net.ssl.TrustManagerFactory.getInstance(""X509"");
            for (X509Certificate element : chain) {
                keyStore.setCertificateEntry
                (element.getSubjectDN().toString(), element);
            }

            tmf.init(keyStore);
            TrustManager[] tms = tmf.getTrustManagers();
            if (tms != null) {
                for (TrustManager tm : tms) {
                    if (tm instanceof X509TrustManager) {
                        localTrustManager = (X509TrustManager) tm;
                        break;
                    }
                }
            }
            java.io.FileOutputStream keyStoreStream;
            try {
                keyStoreStream = new java.io.FileOutputStream(keyStoreFile);
                keyStore.store(keyStoreStream, """".toCharArray());
                keyStoreStream.close();
            } catch (FileNotFoundException e) {
                throw new CertificateException(""Unable to write KeyStore: "" + e.getMessage());
            } catch (CertificateException e) {
                throw new CertificateException(""Unable to write KeyStore: "" + e.getMessage());
            } catch (IOException e) {
                throw new CertificateException(""Unable to write KeyStore: "" + e.getMessage());
            }

        } catch (NoSuchAlgorithmException e) {
            Log.e(LOG_TAG, ""Unable to get X509 Trust Manager "", e);
        } catch (KeyStoreException e) {
            Log.e(LOG_TAG, ""Key Store exception while initializing TrustManagerFactory "", e);
        }
    }
}
",True,144,0,0,7,55,5,2,L1
153,com.fsck.k9.mail.store.ImapStore.java,"
package com.fsck.k9.mail.store;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.ConnectException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CodingErrorAction;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;
import java.security.Security;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.TrustManager;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.PowerManager;
import android.util.Log;

import com.beetstra.jutf7.CharsetProvider;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.R;
import com.fsck.k9.controller.MessageRetrievalListener;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.helper.power.TracingPowerManager;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;
import com.fsck.k9.mail.Authentication;
import com.fsck.k9.mail.AuthenticationFailedException;
import com.fsck.k9.mail.Body;
import com.fsck.k9.mail.CertificateValidationException;
import com.fsck.k9.mail.FetchProfile;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Part;
import com.fsck.k9.mail.PushReceiver;
import com.fsck.k9.mail.Pusher;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.filter.EOLConvertingOutputStream;
import com.fsck.k9.mail.filter.FixedLengthInputStream;
import com.fsck.k9.mail.filter.PeekableInputStream;
import com.fsck.k9.mail.internet.MimeBodyPart;
import com.fsck.k9.mail.internet.MimeHeader;
import com.fsck.k9.mail.internet.MimeMessage;
import com.fsck.k9.mail.internet.MimeMultipart;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.store.ImapResponseParser.ImapList;
import com.fsck.k9.mail.store.ImapResponseParser.ImapResponse;
import com.fsck.k9.mail.transport.imap.ImapSettings;
import com.jcraft.jzlib.JZlib;
import com.jcraft.jzlib.ZOutputStream;
import java.util.zip.Inflater;
import java.util.zip.InflaterInputStream;

/**
 * <pre>
 * TODO Need to start keeping track of UIDVALIDITY
 * TODO Need a default response handler for things like folder updates
 * </pre>
 */
public class ImapStore extends Store {
    public static final int CONNECTION_SECURITY_NONE = 0;
    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

    public enum AuthType { PLAIN, CRAM_MD5 }

    private static final int IDLE_READ_TIMEOUT_INCREMENT = 5 * 60 * 1000;
    private static final int IDLE_FAILURE_COUNT_LIMIT = 10;
    private static int MAX_DELAY_TIME = 5 * 60 * 1000; // 5 minutes
    private static int NORMAL_DELAY_TIME = 5000;

    private static int FETCH_WINDOW_SIZE = 100;

    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED, Flag.SEEN };

    private static final String CAPABILITY_IDLE = ""IDLE"";
    private static final String COMMAND_IDLE = ""IDLE"";
    private static final String CAPABILITY_NAMESPACE = ""NAMESPACE"";
    private static final String COMMAND_NAMESPACE = ""NAMESPACE"";

    private static final String CAPABILITY_CAPABILITY = ""CAPABILITY"";
    private static final String COMMAND_CAPABILITY = ""CAPABILITY"";

    private static final String CAPABILITY_COMPRESS_DEFLATE = ""COMPRESS=DEFLATE"";
    private static final String COMMAND_COMPRESS_DEFLATE = ""COMPRESS DEFLATE"";

    private static final Message[] EMPTY_MESSAGE_ARRAY = new Message[0];

    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    private String mHost;
    private int mPort;
    private String mUsername;
    private String mPassword;
    private int mConnectionSecurity;
    private AuthType mAuthType;
    private volatile String mPathPrefix;
    private volatile String mCombinedPrefix = null;
    private volatile String mPathDelimeter = null;

    public class StoreImapSettings implements ImapSettings {

        @Override
        public String getHost() {
            return mHost;
        }

        @Override
        public int getPort() {
            return mPort;
        }

        @Override
        public int getConnectionSecurity() {
            return mConnectionSecurity;
        }

        @Override
        public AuthType getAuthType() {
            return mAuthType;
        }

        @Override
        public String getUsername() {
            return mUsername;
        }

        @Override
        public String getPassword() {
            return mPassword;
        }

        @Override
        public boolean useCompression(final int type) {
            return mAccount.useCompression(type);
        }

        @Override
        public String getPathPrefix() {
            return mPathPrefix;
        }

        @Override
        public void setPathPrefix(String prefix) {
            mPathPrefix = prefix;
        }

        @Override
        public String getPathDelimeter() {
            return mPathDelimeter;
        }

        @Override
        public void setPathDelimeter(String delimeter) {
            mPathDelimeter = delimeter;
        }

        @Override
        public String getCombinedPrefix() {
            return mCombinedPrefix;
        }

        @Override
        public void setCombinedPrefix(String prefix) {
            mCombinedPrefix = prefix;
        }

    }

    private static final SimpleDateFormat RFC3501_DATE = new SimpleDateFormat(""dd-MMM-yyyy"", Locale.US);

    private LinkedList<ImapConnection> mConnections =
        new LinkedList<ImapConnection>();

    /**
     * Charset used for converting folder names to and from UTF-7 as defined by RFC 3501.
     */
    private Charset mModifiedUtf7Charset;

    /**
     * Cache of ImapFolder objects. ImapFolders are attached to a given folder on the server
     * and as long as their associated connection remains open they are reusable between
     * requests. This cache lets us make sure we always reuse, if possible, for a given
     * folder name.
     */
    private HashMap<String, ImapFolder> mFolderCache = new HashMap<String, ImapFolder>();

    /**
     * imap://auth:user:password@server:port CONNECTION_SECURITY_NONE
     * imap+tls://auth:user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * imap+tls+://auth:user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * imap+ssl+://auth:user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * imap+ssl://auth:user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     *
     * @param _uri
     */
    public ImapStore(Account account) throws MessagingException {
        super(account);
        URI uri;
        try {
            uri = new URI(mAccount.getStoreUri());
        } catch (URISyntaxException use) {
            throw new MessagingException(""Invalid ImapStore URI"", use);
        }

        String scheme = uri.getScheme();
        if (scheme.equals(""imap"")) {
            mConnectionSecurity = CONNECTION_SECURITY_NONE;
            mPort = 143;
        } else if (scheme.equals(""imap+tls"")) {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
            mPort = 143;
        } else if (scheme.equals(""imap+tls+"")) {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
            mPort = 143;
        } else if (scheme.equals(""imap+ssl+"")) {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
            mPort = 993;
        } else if (scheme.equals(""imap+ssl"")) {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
            mPort = 993;
        } else {
            throw new MessagingException(""Unsupported protocol"");
        }

        mHost = uri.getHost();

        if (uri.getPort() != -1) {
            mPort = uri.getPort();
        }

        if (uri.getUserInfo() != null) {
            try {
                String[] userInfoParts = uri.getUserInfo().split("":"");
                if (userInfoParts.length == 2) {
                    mAuthType = AuthType.PLAIN;
                    mUsername = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                    mPassword = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                } else {
                    mAuthType = AuthType.valueOf(userInfoParts[0]);
                    mUsername = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                    mPassword = URLDecoder.decode(userInfoParts[2], ""UTF-8"");
                }
            } catch (UnsupportedEncodingException enc) {
                // This shouldn't happen since the encoding is hardcoded to UTF-8
                Log.e(K9.LOG_TAG, ""Couldn't urldecode username or password."", enc);
            }
        }

        if ((uri.getPath() != null) && (uri.getPath().length() > 0)) {
            mPathPrefix = uri.getPath().substring(1);
            if (mPathPrefix != null && mPathPrefix.trim().length() == 0) {
                mPathPrefix = null;
            }
        }

        mModifiedUtf7Charset = new CharsetProvider().charsetForName(""X-RFC-3501"");
    }

    @Override
    public Folder getFolder(String name) {
        ImapFolder folder;
        synchronized (mFolderCache) {
            folder = mFolderCache.get(name);
            if (folder == null) {
                folder = new ImapFolder(this, name);
                mFolderCache.put(name, folder);
            }
        }
        return folder;
    }

    private String getCombinedPrefix() {
        if (mCombinedPrefix == null) {
            if (mPathPrefix != null) {
                String tmpPrefix = mPathPrefix.trim();
                String tmpDelim = (mPathDelimeter != null ? mPathDelimeter.trim() : """");
                if (tmpPrefix.endsWith(tmpDelim)) {
                    mCombinedPrefix = tmpPrefix;
                } else if (tmpPrefix.length() > 0) {
                    mCombinedPrefix = tmpPrefix + tmpDelim;
                } else {
                    mCombinedPrefix = """";
                }
            } else {
                mCombinedPrefix = """";
            }
        }
        return mCombinedPrefix;
    }

    @Override
    public List <? extends Folder > getPersonalNamespaces(boolean forceListAll) throws MessagingException {
        ImapConnection connection = getConnection();
        try {
            List <? extends Folder > allFolders = listFolders(connection, false);
            if (forceListAll || !mAccount.subscribedFoldersOnly()) {
                return allFolders;
            } else {
                List<Folder> resultFolders = new LinkedList<Folder>();
                HashSet<String> subscribedFolderNames = new HashSet<String>();
                List <? extends Folder > subscribedFolders = listFolders(connection, true);
                for (Folder subscribedFolder : subscribedFolders) {
                    subscribedFolderNames.add(subscribedFolder.getName());
                }
                for (Folder folder : allFolders) {
                    if (subscribedFolderNames.contains(folder.getName())) {
                        resultFolders.add(folder);
                    }
                }
                return resultFolders;
            }
        } catch (IOException ioe) {
            connection.close();
            throw new MessagingException(""Unable to get folder list."", ioe);
        } catch (MessagingException me) {
            connection.close();
            throw new MessagingException(""Unable to get folder list."", me);
        } finally {
            releaseConnection(connection);
        }
    }


    private List <? extends Folder > listFolders(ImapConnection connection, boolean LSUB) throws IOException, MessagingException {
        String commandResponse = LSUB ? ""LSUB"" : ""LIST"";

        LinkedList<Folder> folders = new LinkedList<Folder>();

        List<ImapResponse> responses =
            connection.executeSimpleCommand(String.format(commandResponse + "" \""\"" %s"",
                                            encodeString(getCombinedPrefix() + ""*"")));

        for (ImapResponse response : responses) {
            if (ImapResponseParser.equalsIgnoreCase(response.get(0), commandResponse)) {
                boolean includeFolder = true;

                String decodedFolderName;
                try {
                    decodedFolderName = decodeFolderName(response.getString(3));
                } catch (CharacterCodingException e) {
                    Log.w(K9.LOG_TAG, ""Folder name not correctly encoded with the UTF-7 variant "" +
                          ""as defined by RFC 3501: "" + response.getString(3), e);

                    //TODO: Use the raw name returned by the server for all commands that require
                    //      a folder name. Use the decoded name only for showing it to the user.

                    // We currently just skip folders with malformed names.
                    continue;
                }

                String folder = decodedFolderName;

                if (mPathDelimeter == null) {
                    mPathDelimeter = response.getString(2);
                    mCombinedPrefix = null;
                }

                if (folder.equalsIgnoreCase(mAccount.getInboxFolderName())) {
                    continue;
                } else if (folder.equals(mAccount.getOutboxFolderName())) {
                    /*
                     * There is a folder on the server with the same name as our local
                     * outbox. Until we have a good plan to deal with this situation
                     * we simply ignore the folder on the server.
                     */
                    continue;
                } else {
                    int prefixLength = getCombinedPrefix().length();
                    if (prefixLength > 0) {
                        // Strip prefix from the folder name
                        if (folder.length() >= prefixLength) {
                            folder = folder.substring(prefixLength);
                        }
                        if (!decodedFolderName.equalsIgnoreCase(getCombinedPrefix() + folder)) {
                            includeFolder = false;
                        }
                    }
                }

                ImapList attributes = response.getList(1);
                for (int i = 0, count = attributes.size(); i < count; i++) {
                    String attribute = attributes.getString(i);
                    if (attribute.equalsIgnoreCase(""\\NoSelect"")) {
                        includeFolder = false;
                    }
                }
                if (includeFolder) {
                    folders.add(getFolder(folder));
                }
            }
        }
        folders.add(getFolder(mAccount.getInboxFolderName()));
        return folders;

    }

    @Override
    public void checkSettings() throws MessagingException {
        try {
            ImapConnection connection = new ImapConnection(new StoreImapSettings());
            connection.open();
            connection.close();
        } catch (IOException ioe) {
            throw new MessagingException(K9.app.getString(R.string.error_unable_to_connect), ioe);
        }
    }

    /**
     * Gets a connection if one is available for reuse, or creates a new one if not.
     * @return
     */
    private ImapConnection getConnection() throws MessagingException {
        synchronized (mConnections) {
            ImapConnection connection = null;
            while ((connection = mConnections.poll()) != null) {
                try {
                    connection.executeSimpleCommand(""NOOP"");
                    break;
                } catch (IOException ioe) {
                    connection.close();
                }
            }
            if (connection == null) {
                connection = new ImapConnection(new StoreImapSettings());
            }
            return connection;
        }
    }

    private void releaseConnection(ImapConnection connection) {
        if (connection != null && connection.isOpen()) {
            synchronized (mConnections) {
                mConnections.offer(connection);
            }
        }
    }

    /**
     * Encode a string to be able to use it in an IMAP command.
     *
     * ""A quoted string is a sequence of zero or more 7-bit characters,
     *  excluding CR and LF, with double quote (<"">) characters at each
     *  end."" - Section 4.3, RFC 3501
     *
     * Double quotes and backslash are escaped by prepending a backslash.
     *
     * @param str
     *     The input string (only 7-bit characters allowed).
     * @return
     *     The string encoded as quoted (IMAP) string.
     */
    private static String encodeString(String str) {
        return ""\"""" + str.replace(""\\"", ""\\\\"").replace(""\"""", ""\\\"""") + ""\"""";
    }

    private String encodeFolderName(String name) {
        try {
            ByteBuffer bb = mModifiedUtf7Charset.encode(name);
            byte[] b = new byte[bb.limit()];
            bb.get(b);
            return new String(b, ""US-ASCII"");
        } catch (UnsupportedEncodingException uee) {
            /*
             * The only thing that can throw this is getBytes(""US-ASCII"") and if US-ASCII doesn't
             * exist we're totally screwed.
             */
            throw new RuntimeException(""Unable to encode folder name: "" + name, uee);
        }
    }

    private String decodeFolderName(String name) throws CharacterCodingException {
        /*
         * Convert the encoded name to US-ASCII, then pass it through the modified UTF-7
         * decoder and return the Unicode String.
         */
        try {
            // Make sure the decoder throws an exception if it encounters an invalid encoding.
            CharsetDecoder decoder = mModifiedUtf7Charset.newDecoder().onMalformedInput(CodingErrorAction.REPORT);
            CharBuffer cb = decoder.decode(ByteBuffer.wrap(name.getBytes(""US-ASCII"")));
            return cb.toString();
        } catch (UnsupportedEncodingException uee) {
            /*
             * The only thing that can throw this is getBytes(""US-ASCII"") and if US-ASCII doesn't
             * exist we're totally screwed.
             */
            throw new RuntimeException(""Unable to decode folder name: "" + name, uee);
        }
    }

    @Override
    public boolean isMoveCapable() {
        return true;
    }

    @Override
    public boolean isCopyCapable() {
        return true;
    }
    @Override
    public boolean isPushCapable() {
        return true;
    }
    @Override
    public boolean isExpungeCapable() {
        return true;
    }


    class ImapFolder extends Folder {
        private String mName;
        protected volatile int mMessageCount = -1;
        protected volatile int uidNext = -1;
        protected volatile ImapConnection mConnection;
        private OpenMode mMode;
        private volatile boolean mExists;
        private ImapStore store = null;
        Map<Integer, String> msgSeqUidMap = new ConcurrentHashMap<Integer, String>();


        public ImapFolder(ImapStore nStore, String name) {
            super(nStore.getAccount());
            store = nStore;
            this.mName = name;
        }

        public String getPrefixedName() throws MessagingException {
            String prefixedName = """";
            if (!mAccount.getInboxFolderName().equalsIgnoreCase(mName)) {
                ImapConnection connection = null;
                synchronized (this) {
                    if (mConnection == null) {
                        connection = getConnection();
                    } else {
                        connection = mConnection;
                    }
                }
                try {

                    connection.open();
                } catch (IOException ioe) {
                    throw new MessagingException(""Unable to get IMAP prefix"", ioe);
                } finally {
                    if (mConnection == null) {
                        releaseConnection(connection);
                    }
                }
                prefixedName = getCombinedPrefix();
            }

            prefixedName += mName;
            return prefixedName;
        }

        protected List<ImapResponse> executeSimpleCommand(String command) throws MessagingException, IOException {
            return handleUntaggedResponses(mConnection.executeSimpleCommand(command));
        }

        protected List<ImapResponse> executeSimpleCommand(String command, boolean sensitve, UntaggedHandler untaggedHandler) throws MessagingException, IOException {
            return handleUntaggedResponses(mConnection.executeSimpleCommand(command, sensitve, untaggedHandler));
        }

        @Override
        public void open(OpenMode mode) throws MessagingException {
            internalOpen(mode);

            if (mMessageCount == -1) {
                throw new MessagingException(
                    ""Did not find message count during open"");
            }
        }

        public List<ImapResponse> internalOpen(OpenMode mode) throws MessagingException {
            if (isOpen() && mMode == mode) {
                // Make sure the connection is valid. If it's not we'll close it down and continue
                // on to get a new one.
                try {
                    List<ImapResponse> responses = executeSimpleCommand(""NOOP"");
                    return responses;
                } catch (IOException ioe) {
                    ioExceptionHandler(mConnection, ioe);
                }
            }
            releaseConnection(mConnection);
            synchronized (this) {
                mConnection = getConnection();
            }
            // * FLAGS (\Answered \Flagged \Deleted \Seen \Draft NonJunk
            // $MDNSent)
            // * OK [PERMANENTFLAGS (\Answered \Flagged \Deleted \Seen \Draft
            // NonJunk $MDNSent \*)] Flags permitted.
            // * 23 EXISTS
            // * 0 RECENT
            // * OK [UIDVALIDITY 1125022061] UIDs valid
            // * OK [UIDNEXT 57576] Predicted next UID
            // 2 OK [READ-WRITE] Select completed.
            try {
                msgSeqUidMap.clear();
                String command = String.format((mode == OpenMode.READ_WRITE ? ""SELECT"" : ""EXAMINE"") + "" %s"",
                                               encodeString(encodeFolderName(getPrefixedName())));

                List<ImapResponse> responses = executeSimpleCommand(command);

                /*
                 * If the command succeeds we expect the folder has been opened read-write
                 * unless we are notified otherwise in the responses.
                 */
                mMode = mode;

                for (ImapResponse response : responses) {
                    if (response.mTag != null && response.size() >= 2) {
                        Object bracketedObj = response.get(1);
                        if (bracketedObj instanceof ImapList) {
                            ImapList bracketed = (ImapList)bracketedObj;

                            if (bracketed.size() > 0) {
                                Object keyObj = bracketed.get(0);
                                if (keyObj instanceof String) {
                                    String key = (String)keyObj;

                                    if (""READ-ONLY"".equalsIgnoreCase(key)) {
                                        mMode = OpenMode.READ_ONLY;
                                    } else if (""READ-WRITE"".equalsIgnoreCase(key)) {
                                        mMode = OpenMode.READ_WRITE;
                                    }
                                }
                            }
                        }

                    }
                }

                mExists = true;
                return responses;
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            } catch (MessagingException me) {
                Log.e(K9.LOG_TAG, ""Unable to open connection for "" + getLogId(), me);
                throw me;
            }

        }

        @Override
        public boolean isOpen() {
            return mConnection != null;
        }

        @Override
        public OpenMode getMode() {
            return mMode;
        }

        @Override
        public void close() {
            if (mMessageCount != -1) {
                mMessageCount = -1;
            }
            if (!isOpen()) {
                return;
            }

            synchronized (this) {
                releaseConnection(mConnection);
                mConnection = null;
            }
        }

        @Override
        public String getName() {
            return mName;
        }

        /**
         * Check if a given folder exists on the server.
         *
         * @param folderName
         *     The name of the folder encoded as quoted string.
         *     See {@link ImapStore#encodeString}
         *
         * @return
         *     {@code True}, if the folder exists. {@code False}, otherwise.
         */
        private boolean exists(String folderName) throws MessagingException {
            try {
                // Since we don't care about RECENT, we'll use that for the check, because we're checking
                // a folder other than ourself, and don't want any untagged responses to cause a change
                // in our own fields
                mConnection.executeSimpleCommand(String.format(""STATUS %s (RECENT)"", folderName));
                return true;
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            } catch (MessagingException me) {
                return false;
            }
        }

        @Override
        public boolean exists() throws MessagingException {
            if (mExists) {
                return true;
            }
            /*
             * This method needs to operate in the unselected mode as well as the selected mode
             * so we must get the connection ourselves if it's not there. We are specifically
             * not calling checkOpen() since we don't care if the folder is open.
             */
            ImapConnection connection = null;
            synchronized (this) {
                if (mConnection == null) {
                    connection = getConnection();
                } else {
                    connection = mConnection;
                }
            }
            try {
                connection.executeSimpleCommand(String.format(""STATUS %s (UIDVALIDITY)"",
                                                encodeString(encodeFolderName(getPrefixedName()))));
                mExists = true;
                return true;
            } catch (MessagingException me) {
                return false;
            } catch (IOException ioe) {
                throw ioExceptionHandler(connection, ioe);
            } finally {
                if (mConnection == null) {
                    releaseConnection(connection);
                }
            }
        }

        @Override
        public boolean create(FolderType type) throws MessagingException {
            /*
             * This method needs to operate in the unselected mode as well as the selected mode
             * so we must get the connection ourselves if it's not there. We are specifically
             * not calling checkOpen() since we don't care if the folder is open.
             */
            ImapConnection connection = null;
            synchronized (this) {
                if (mConnection == null) {
                    connection = getConnection();
                } else {
                    connection = mConnection;
                }
            }
            try {
                connection.executeSimpleCommand(String.format(""CREATE %s"",
                                                encodeString(encodeFolderName(getPrefixedName()))));
                return true;
            } catch (MessagingException me) {
                return false;
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            } finally {
                if (mConnection == null) {
                    releaseConnection(connection);
                }
            }
        }

        @Override
        public void copyMessages(Message[] messages, Folder folder) throws MessagingException {
            if (!(folder instanceof ImapFolder)) {
                throw new MessagingException(""ImapFolder.copyMessages passed non-ImapFolder"");
            }

            if (messages.length == 0)
                return;

            ImapFolder iFolder = (ImapFolder)folder;
            checkOpen();
            String[] uids = new String[messages.length];
            for (int i = 0, count = messages.length; i < count; i++) {
                uids[i] = messages[i].getUid();
            }
            try {
                String remoteDestName = encodeString(encodeFolderName(iFolder.getPrefixedName()));

                if (!exists(remoteDestName)) {
                    /*
                     * If the remote trash folder doesn't exist we try to create it.
                     */
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""IMAPMessage.copyMessages: attempting to create remote '"" + remoteDestName + ""' folder for "" + getLogId());
                    iFolder.create(FolderType.HOLDS_MESSAGES);
                }

                if (exists(remoteDestName)) {
                    executeSimpleCommand(String.format(""UID COPY %s %s"",
                                                       Utility.combine(uids, ','),
                                                       remoteDestName));
                } else {
                    throw new MessagingException(""IMAPMessage.copyMessages: remote destination folder "" + folder.getName()
                                                 + "" does not exist and could not be created for "" + getLogId()
                                                 , true);
                }
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        @Override
        public void moveMessages(Message[] messages, Folder folder) throws MessagingException {
            if (messages.length == 0)
                return;
            copyMessages(messages, folder);
            setFlags(messages, new Flag[] { Flag.DELETED }, true);
        }

        @Override
        public void delete(Message[] messages, String trashFolderName) throws MessagingException {
            if (messages.length == 0)
                return;

            if (trashFolderName == null || getName().equalsIgnoreCase(trashFolderName)) {
                setFlags(messages, new Flag[] { Flag.DELETED }, true);
            } else {
                ImapFolder remoteTrashFolder = (ImapFolder)getStore().getFolder(trashFolderName);
                String remoteTrashName = encodeString(encodeFolderName(remoteTrashFolder.getPrefixedName()));

                if (!exists(remoteTrashName)) {
                    /*
                     * If the remote trash folder doesn't exist we try to create it.
                     */
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""IMAPMessage.delete: attempting to create remote '"" + trashFolderName + ""' folder for "" + getLogId());
                    remoteTrashFolder.create(FolderType.HOLDS_MESSAGES);
                }

                if (exists(remoteTrashName)) {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""IMAPMessage.delete: copying remote "" + messages.length + "" messages to '"" + trashFolderName + ""' for "" + getLogId());

                    moveMessages(messages, remoteTrashFolder);
                } else {
                    throw new MessagingException(""IMAPMessage.delete: remote Trash folder "" + trashFolderName + "" does not exist and could not be created for "" + getLogId()
                                                 , true);
                }
            }
        }


        @Override
        public int getMessageCount() {
            return mMessageCount;
        }


        private int getRemoteMessageCount(String criteria) throws MessagingException {
            checkOpen();
            try {
                int count = 0;
                int start = 1;

                List<ImapResponse> responses = executeSimpleCommand(String.format(""SEARCH %d:* "" + criteria, start));
                for (ImapResponse response : responses) {
                    if (ImapResponseParser.equalsIgnoreCase(response.get(0), ""SEARCH"")) {
                        count += response.size() - 1;
                    }
                }
                return count;
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            }


        }

        @Override
        public int getUnreadMessageCount() throws MessagingException {
            return getRemoteMessageCount(""UNSEEN NOT DELETED"");
        }

        @Override
        public int getFlaggedMessageCount() throws MessagingException {
            return getRemoteMessageCount(""FLAGGED NOT DELETED"");
        }

        protected int getHighestUid() {
            try {
                ImapSearcher searcher = new ImapSearcher() {
                    public List<ImapResponse> search() throws IOException, MessagingException {
                        return executeSimpleCommand(""UID SEARCH *:*"");
                    }
                };
                Message[] messages = search(searcher, null);
                if (messages.length > 0) {
                    return Integer.parseInt(messages[0].getUid());
                }
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Unable to find highest UID in folder "" + getName(), e);
            }
            return -1;

        }

        @Override
        public void delete(boolean recurse) throws MessagingException {
            throw new Error(""ImapStore.delete() not yet implemented"");
        }

        @Override
        public Message getMessage(String uid) throws MessagingException {
            return new ImapMessage(uid, this);
        }


        @Override
        public Message[] getMessages(int start, int end, Date earliestDate, MessageRetrievalListener listener)
        throws MessagingException {
            return getMessages(start, end, earliestDate, false, listener);
        }

        protected Message[] getMessages(final int start, final int end, Date earliestDate, final boolean includeDeleted, final MessageRetrievalListener listener)
        throws MessagingException {
            if (start < 1 || end < 1 || end < start) {
                throw new MessagingException(
                    String.format(""Invalid message set %d %d"",
                                  start, end));
            }
            final StringBuilder dateSearchString = new StringBuilder();
            if (earliestDate != null) {
                dateSearchString.append("" SINCE "");
                synchronized (RFC3501_DATE) {
                    dateSearchString.append(RFC3501_DATE.format(earliestDate));
                }
            }


            ImapSearcher searcher = new ImapSearcher() {
                public List<ImapResponse> search() throws IOException, MessagingException {
                    return executeSimpleCommand(String.format(""UID SEARCH %d:%d%s"" + (includeDeleted ? """" : "" NOT DELETED""), start, end, dateSearchString));
                }
            };
            return search(searcher, listener);

        }
        protected Message[] getMessages(final List<Integer> mesgSeqs, final boolean includeDeleted, final MessageRetrievalListener listener)
        throws MessagingException {
            ImapSearcher searcher = new ImapSearcher() {
                public List<ImapResponse> search() throws IOException, MessagingException {
                    return executeSimpleCommand(String.format(""UID SEARCH %s"" + (includeDeleted ? """" : "" NOT DELETED""), Utility.combine(mesgSeqs.toArray(), ',')));
                }
            };
            return search(searcher, listener);
        }

        protected Message[] getMessagesFromUids(final List<String> mesgUids, final boolean includeDeleted, final MessageRetrievalListener listener)
        throws MessagingException {
            ImapSearcher searcher = new ImapSearcher() {
                public List<ImapResponse> search() throws IOException, MessagingException {
                    return executeSimpleCommand(String.format(""UID SEARCH UID %s"" + (includeDeleted ? """" : "" NOT DELETED""), Utility.combine(mesgUids.toArray(), ',')));
                }
            };
            return search(searcher, listener);
        }

        private Message[] search(ImapSearcher searcher, MessageRetrievalListener listener) throws MessagingException {

            checkOpen();
            ArrayList<Message> messages = new ArrayList<Message>();
            try {
                ArrayList<Integer> uids = new ArrayList<Integer>();
                List<ImapResponse> responses = searcher.search(); //
                for (ImapResponse response : responses) {
                    if (response.mTag == null) {
                        if (ImapResponseParser.equalsIgnoreCase(response.get(0), ""SEARCH"")) {
                            for (int i = 1, count = response.size(); i < count; i++) {
                                uids.add(Integer.parseInt(response.getString(i)));
                            }
                        }
                    }
                }

                // Sort the uids in numerically ascending order
                Collections.sort(uids);
                for (int i = 0, count = uids.size(); i < count; i++) {
                    if (listener != null) {
                        listener.messageStarted("""" + uids.get(i), i, count);
                    }
                    ImapMessage message = new ImapMessage("""" + uids.get(i), this);
                    messages.add(message);
                    if (listener != null) {
                        listener.messageFinished(message, i, count);
                    }
                }
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            }
            return messages.toArray(EMPTY_MESSAGE_ARRAY);
        }


        @Override
        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException {
            return getMessages(null, listener);
        }

        @Override
        public Message[] getMessages(String[] uids, MessageRetrievalListener listener)
        throws MessagingException {
            checkOpen();
            ArrayList<Message> messages = new ArrayList<Message>();
            try {
                if (uids == null) {
                    List<ImapResponse> responses = executeSimpleCommand(""UID SEARCH 1:* NOT DELETED"");
                    ArrayList<String> tempUids = new ArrayList<String>();
                    for (ImapResponse response : responses) {
                        if (ImapResponseParser.equalsIgnoreCase(response.get(0), ""SEARCH"")) {
                            for (int i = 1, count = response.size(); i < count; i++) {
                                tempUids.add(response.getString(i));
                            }
                        }
                    }
                    uids = tempUids.toArray(EMPTY_STRING_ARRAY);
                }
                for (int i = 0, count = uids.length; i < count; i++) {
                    if (listener != null) {
                        listener.messageStarted(uids[i], i, count);
                    }
                    ImapMessage message = new ImapMessage(uids[i], this);
                    messages.add(message);
                    if (listener != null) {
                        listener.messageFinished(message, i, count);
                    }
                }
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            }
            return messages.toArray(EMPTY_MESSAGE_ARRAY);
        }

        @Override
        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
        throws MessagingException {
            if (messages == null || messages.length == 0) {
                return;
            }
            checkOpen();
            List<String> uids = new ArrayList<String>(messages.length);
            HashMap<String, Message> messageMap = new HashMap<String, Message>();
            for (int i = 0, count = messages.length; i < count; i++) {

                String uid = messages[i].getUid();
                uids.add(uid);
                messageMap.put(uid, messages[i]);
            }

            /*
             * Figure out what command we are going to run:
             * Flags - UID FETCH (FLAGS)
             * Envelope - UID FETCH ([FLAGS] INTERNALDATE UID RFC822.SIZE FLAGS BODY.PEEK[HEADER.FIELDS (date subject from content-type to cc)])
             *
             */
            LinkedHashSet<String> fetchFields = new LinkedHashSet<String>();
            fetchFields.add(""UID"");
            if (fp.contains(FetchProfile.Item.FLAGS)) {
                fetchFields.add(""FLAGS"");
            }
            if (fp.contains(FetchProfile.Item.ENVELOPE)) {
                fetchFields.add(""INTERNALDATE"");
                fetchFields.add(""RFC822.SIZE"");
                fetchFields.add(""BODY.PEEK[HEADER.FIELDS (date subject from content-type to cc reply-to ""
                                + K9.IDENTITY_HEADER + "")]"");
            }
            if (fp.contains(FetchProfile.Item.STRUCTURE)) {
                fetchFields.add(""BODYSTRUCTURE"");
            }
            if (fp.contains(FetchProfile.Item.BODY_SANE)) {
                // If the user wants to download unlimited-size messages, don't go only for the truncated body
                if (mAccount.getMaximumAutoDownloadMessageSize() > 0) {
                    fetchFields.add(String.format(""BODY.PEEK[]<0.%d>"", mAccount.getMaximumAutoDownloadMessageSize()));
                } else {
                    fetchFields.add(""BODY.PEEK[]"");
                }
            }
            if (fp.contains(FetchProfile.Item.BODY)) {
                fetchFields.add(""BODY.PEEK[]"");
            }



            for (int windowStart = 0; windowStart < messages.length; windowStart += (FETCH_WINDOW_SIZE)) {
                List<String> uidWindow = uids.subList(windowStart, Math.min((windowStart + FETCH_WINDOW_SIZE), messages.length));

                try {
                    mConnection.sendCommand(String.format(""UID FETCH %s (%s)"",
                                                          Utility.combine(uidWindow.toArray(new String[uidWindow.size()]), ','),
                                                          Utility.combine(fetchFields.toArray(new String[fetchFields.size()]), ' ')
                                                         ), false);
                    ImapResponse response;
                    int messageNumber = 0;

                    ImapResponseParser.IImapResponseCallback callback = null;
                    if (fp.contains(FetchProfile.Item.BODY) || fp.contains(FetchProfile.Item.BODY_SANE)) {
                        callback = new FetchBodyCallback(messageMap);
                    }

                    do {
                        response = mConnection.readResponse(callback);

                        if (response.mTag == null && ImapResponseParser.equalsIgnoreCase(response.get(1), ""FETCH"")) {
                            ImapList fetchList = (ImapList)response.getKeyedValue(""FETCH"");
                            String uid = fetchList.getKeyedString(""UID"");
                            int msgSeq = response.getNumber(0);
                            if (uid != null) {
                                try {
                                    msgSeqUidMap.put(msgSeq, uid);
                                    if (K9.DEBUG) {
                                        Log.v(K9.LOG_TAG, ""Stored uid '"" + uid + ""' for msgSeq "" + msgSeq + "" into map "" /*+ msgSeqUidMap.toString() */);
                                    }
                                } catch (Exception e) {
                                    Log.e(K9.LOG_TAG, ""Unable to store uid '"" + uid + ""' for msgSeq "" + msgSeq);
                                }
                            }

                            Message message = messageMap.get(uid);
                            if (message == null) {
                                if (K9.DEBUG)
                                    Log.d(K9.LOG_TAG, ""Do not have message in messageMap for UID "" + uid + "" for "" + getLogId());

                                handleUntaggedResponse(response);
                                continue;
                            }
                            if (listener != null) {
                                listener.messageStarted(uid, messageNumber++, messageMap.size());
                            }

                            ImapMessage imapMessage = (ImapMessage) message;

                            Object literal = handleFetchResponse(imapMessage, fetchList);

                            if (literal != null) {
                                if (literal instanceof String) {
                                    String bodyString = (String)literal;
                                    InputStream bodyStream = new ByteArrayInputStream(bodyString.getBytes());
                                    imapMessage.parse(bodyStream);
                                } else if (literal instanceof Integer) {
                                    // All the work was done in FetchBodyCallback.foundLiteral()
                                } else {
                                    // This shouldn't happen
                                    throw new MessagingException(""Got FETCH response with bogus parameters"");
                                }
                            }

                            if (listener != null) {
                                listener.messageFinished(message, messageNumber, messageMap.size());
                            }
                        } else {
                            handleUntaggedResponse(response);
                        }

                        while (response.more());

                    } while (response.mTag == null);
                } catch (IOException ioe) {
                    throw ioExceptionHandler(mConnection, ioe);
                }
            }
        }


        @Override
        public void fetchPart(Message message, Part part, MessageRetrievalListener listener)
        throws MessagingException {
            checkOpen();

            String[] parts = part.getHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA);
            if (parts == null) {
                return;
            }

            String fetch;
            String partId = parts[0];
            if (""TEXT"".equalsIgnoreCase(partId)) {
                fetch = String.format(""BODY.PEEK[TEXT]<0.%d>"", mAccount.getMaximumAutoDownloadMessageSize());
            } else {
                fetch = String.format(""BODY.PEEK[%s]"", partId);
            }

            try {
                mConnection.sendCommand(
                    String.format(""UID FETCH %s (UID %s)"", message.getUid(), fetch),
                    false);

                ImapResponse response;
                int messageNumber = 0;

                ImapResponseParser.IImapResponseCallback callback = new FetchPartCallback(part);

                do {
                    response = mConnection.readResponse(callback);

                    if ((response.mTag == null) &&
                            (ImapResponseParser.equalsIgnoreCase(response.get(1), ""FETCH""))) {
                        ImapList fetchList = (ImapList)response.getKeyedValue(""FETCH"");
                        String uid = fetchList.getKeyedString(""UID"");

                        if (!message.getUid().equals(uid)) {
                            if (K9.DEBUG)
                                Log.d(K9.LOG_TAG, ""Did not ask for UID "" + uid + "" for "" + getLogId());

                            handleUntaggedResponse(response);
                            continue;
                        }
                        if (listener != null) {
                            listener.messageStarted(uid, messageNumber++, 1);
                        }

                        ImapMessage imapMessage = (ImapMessage) message;

                        Object literal = handleFetchResponse(imapMessage, fetchList);

                        if (literal != null) {
                            if (literal instanceof Body) {
                                // Most of the work was done in FetchAttchmentCallback.foundLiteral()
                                part.setBody((Body)literal);
                            } else if (literal instanceof String) {
                                String bodyString = (String)literal;
                                InputStream bodyStream = new ByteArrayInputStream(bodyString.getBytes());

                                String contentTransferEncoding = part.getHeader(
                                                                     MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING)[0];
                                part.setBody(MimeUtility.decodeBody(bodyStream, contentTransferEncoding));
                            } else {
                                // This shouldn't happen
                                throw new MessagingException(""Got FETCH response with bogus parameters"");
                            }
                        }

                        if (listener != null) {
                            listener.messageFinished(message, messageNumber, 1);
                        }
                    } else {
                        handleUntaggedResponse(response);
                    }

                    while (response.more());

                } while (response.mTag == null);
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        // Returns value of body field
        private Object handleFetchResponse(ImapMessage message, ImapList fetchList) throws MessagingException {
            Object result = null;
            if (fetchList.containsKey(""FLAGS"")) {
                ImapList flags = fetchList.getKeyedList(""FLAGS"");
                if (flags != null) {
                    for (int i = 0, count = flags.size(); i < count; i++) {
                        String flag = flags.getString(i);
                        if (flag.equalsIgnoreCase(""\\Deleted"")) {
                            message.setFlagInternal(Flag.DELETED, true);
                        } else if (flag.equalsIgnoreCase(""\\Answered"")) {
                            message.setFlagInternal(Flag.ANSWERED, true);
                        } else if (flag.equalsIgnoreCase(""\\Seen"")) {
                            message.setFlagInternal(Flag.SEEN, true);
                        } else if (flag.equalsIgnoreCase(""\\Flagged"")) {
                            message.setFlagInternal(Flag.FLAGGED, true);
                        }
                    }
                }
            }

            if (fetchList.containsKey(""INTERNALDATE"")) {
                Date internalDate = fetchList.getKeyedDate(""INTERNALDATE"");
                message.setInternalDate(internalDate);
            }

            if (fetchList.containsKey(""RFC822.SIZE"")) {
                int size = fetchList.getKeyedNumber(""RFC822.SIZE"");
                message.setSize(size);
            }

            if (fetchList.containsKey(""BODYSTRUCTURE"")) {
                ImapList bs = fetchList.getKeyedList(""BODYSTRUCTURE"");
                if (bs != null) {
                    try {
                        parseBodyStructure(bs, message, ""TEXT"");
                    } catch (MessagingException e) {
                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""Error handling message for "" + getLogId(), e);
                        message.setBody(null);
                    }
                }
            }

            if (fetchList.containsKey(""BODY"")) {
                int index = fetchList.getKeyIndex(""BODY"") + 2;
                result = fetchList.getObject(index);

                // Check if there's an origin octet
                if (result instanceof String) {
                    String originOctet = (String)result;
                    if (originOctet.startsWith(""<"")) {
                        result = fetchList.getObject(index + 1);
                    }
                }
            }

            return result;
        }

        @Override
        public Flag[] getPermanentFlags() {
            return PERMANENT_FLAGS;
        }

        /**
         * Handle any untagged responses that the caller doesn't care to handle themselves.
         * @param responses
         */
        protected List<ImapResponse> handleUntaggedResponses(List<ImapResponse> responses) {
            for (ImapResponse response : responses) {
                handleUntaggedResponse(response);
            }
            return responses;
        }

        protected void handlePossibleUidNext(ImapResponse response) {
            if (ImapResponseParser.equalsIgnoreCase(response.get(0), ""OK"") && response.size() > 1) {
                Object bracketedObj = response.get(1);
                if (bracketedObj instanceof ImapList) {
                    ImapList bracketed = (ImapList)bracketedObj;

                    if (bracketed.size() > 1) {
                        Object keyObj = bracketed.get(0);
                        if (keyObj instanceof String) {
                            String key = (String)keyObj;
                            if (""UIDNEXT"".equalsIgnoreCase(key)) {
                                uidNext = bracketed.getNumber(1);
                                if (K9.DEBUG)
                                    Log.d(K9.LOG_TAG, ""Got UidNext = "" + uidNext + "" for "" + getLogId());
                            }
                        }
                    }


                }
            }
        }

        /**
         * Handle an untagged response that the caller doesn't care to handle themselves.
         * @param response
         */
        protected void handleUntaggedResponse(ImapResponse response) {
            if (response.mTag == null && response.size() > 1) {
                if (ImapResponseParser.equalsIgnoreCase(response.get(1), ""EXISTS"")) {
                    mMessageCount = response.getNumber(0);
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Got untagged EXISTS with value "" + mMessageCount + "" for "" + getLogId());
                }
                handlePossibleUidNext(response);

                if (ImapResponseParser.equalsIgnoreCase(response.get(1), ""EXPUNGE"") && mMessageCount > 0) {
                    mMessageCount--;
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Got untagged EXPUNGE with mMessageCount "" + mMessageCount + "" for "" + getLogId());
                }
//            if (response.size() > 1) {
//                Object bracketedObj = response.get(1);
//                if (bracketedObj instanceof ImapList)
//                {
//                    ImapList bracketed = (ImapList)bracketedObj;
//
//                    if (bracketed.size() > 0)
//                    {
//                        Object keyObj = bracketed.get(0);
//                        if (keyObj instanceof String)
//                        {
//                            String key = (String)keyObj;
//                            if (""ALERT"".equalsIgnoreCase(key))
//                            {
//                                StringBuffer sb = new StringBuffer();
//                                for (int i = 2, count = response.size(); i < count; i++) {
//                                    sb.append(response.get(i).toString());
//                                    sb.append(' ');
//                                }
//
//                                Log.w(K9.LOG_TAG, ""ALERT: "" + sb.toString() + "" for "" + getLogId());
//                            }
//                        }
//                    }
//
//
//                }
//            }
            }
            //Log.i(K9.LOG_TAG, ""mMessageCount = "" + mMessageCount + "" for "" + getLogId());
        }

        private void parseBodyStructure(ImapList bs, Part part, String id)
        throws MessagingException {
            if (bs.get(0) instanceof ImapList) {
                /*
                 * This is a multipart/*
                 */
                MimeMultipart mp = new MimeMultipart();
                for (int i = 0, count = bs.size(); i < count; i++) {
                    if (bs.get(i) instanceof ImapList) {
                        /*
                         * For each part in the message we're going to add a new BodyPart and parse
                         * into it.
                         */
                        ImapBodyPart bp = new ImapBodyPart();
                        if (id.equalsIgnoreCase(""TEXT"")) {
                            parseBodyStructure(bs.getList(i), bp, Integer.toString(i + 1));
                        } else {
                            parseBodyStructure(bs.getList(i), bp, id + ""."" + (i + 1));
                        }
                        mp.addBodyPart(bp);
                    } else {
                        /*
                         * We've got to the end of the children of the part, so now we can find out
                         * what type it is and bail out.
                         */
                        String subType = bs.getString(i);
                        mp.setSubType(subType.toLowerCase());
                        break;
                    }
                }
                part.setBody(mp);
            } else {
                /*
                 * This is a body. We need to add as much information as we can find out about
                 * it to the Part.
                 */

                /*
                 *  0| 0  body type
                 *  1| 1  body subtype
                 *  2| 2  body parameter parenthesized list
                 *  3| 3  body id (unused)
                 *  4| 4  body description (unused)
                 *  5| 5  body encoding
                 *  6| 6  body size
                 *  -| 7  text lines (only for type TEXT, unused)
                 * Extensions (optional):
                 *  7| 8  body MD5 (unused)
                 *  8| 9  body disposition
                 *  9|10  body language (unused)
                 * 10|11  body location (unused)
                 */

                String type = bs.getString(0);
                String subType = bs.getString(1);
                String mimeType = (type + ""/"" + subType).toLowerCase();

                ImapList bodyParams = null;
                if (bs.get(2) instanceof ImapList) {
                    bodyParams = bs.getList(2);
                }
                String encoding = bs.getString(5);
                int size = bs.getNumber(6);

                if (MimeUtility.mimeTypeMatches(mimeType, ""message/rfc822"")) {
//                  A body type of type MESSAGE and subtype RFC822
//                  contains, immediately after the basic fields, the
//                  envelope structure, body structure, and size in
//                  text lines of the encapsulated message.
//                    [MESSAGE, RFC822, [NAME, Fwd: [#HTR-517941]:  update plans at 1am Friday - Memory allocation - displayware.eml], NIL, NIL, 7BIT, 5974, NIL, [INLINE, [FILENAME*0, Fwd: [#HTR-517941]:  update plans at 1am Friday - Memory all, FILENAME*1, ocation - displayware.eml]], NIL]
                    /*
                     * This will be caught by fetch and handled appropriately.
                     */
                    throw new MessagingException(""BODYSTRUCTURE message/rfc822 not yet supported."");
                }

                /*
                 * Set the content type with as much information as we know right now.
                 */
                String contentType = String.format(""%s"", mimeType);

                if (bodyParams != null) {
                    /*
                     * If there are body params we might be able to get some more information out
                     * of them.
                     */
                    for (int i = 0, count = bodyParams.size(); i < count; i += 2) {
                        contentType += String.format("";\n %s=\""%s\"""",
                                                     bodyParams.getString(i),
                                                     bodyParams.getString(i + 1));
                    }
                }

                part.setHeader(MimeHeader.HEADER_CONTENT_TYPE, contentType);

                // Extension items
                ImapList bodyDisposition = null;
                if ((""text"".equalsIgnoreCase(type))
                        && (bs.size() > 9)
                        && (bs.get(9) instanceof ImapList)) {
                    bodyDisposition = bs.getList(9);
                } else if (!(""text"".equalsIgnoreCase(type))
                           && (bs.size() > 8)
                           && (bs.get(8) instanceof ImapList)) {
                    bodyDisposition = bs.getList(8);
                }

                String contentDisposition = """";

                if (bodyDisposition != null && bodyDisposition.size() > 0) {
                    if (!""NIL"".equalsIgnoreCase(bodyDisposition.getString(0))) {
                        contentDisposition = bodyDisposition.getString(0).toLowerCase();
                    }

                    if ((bodyDisposition.size() > 1)
                            && (bodyDisposition.get(1) instanceof ImapList)) {
                        ImapList bodyDispositionParams = bodyDisposition.getList(1);
                        /*
                         * If there is body disposition information we can pull some more information
                         * about the attachment out.
                         */
                        for (int i = 0, count = bodyDispositionParams.size(); i < count; i += 2) {
                            contentDisposition += String.format("";\n %s=\""%s\"""",
                                                                bodyDispositionParams.getString(i).toLowerCase(),
                                                                bodyDispositionParams.getString(i + 1));
                        }
                    }
                }

                if (MimeUtility.getHeaderParameter(contentDisposition, ""size"") == null) {
                    contentDisposition += String.format("";\n size=%d"", size);
                }

                /*
                 * Set the content disposition containing at least the size. Attachment
                 * handling code will use this down the road.
                 */
                part.setHeader(MimeHeader.HEADER_CONTENT_DISPOSITION, contentDisposition);


                /*
                 * Set the Content-Transfer-Encoding header. Attachment code will use this
                 * to parse the body.
                 */
                part.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, encoding);

                if (part instanceof ImapMessage) {
                    ((ImapMessage) part).setSize(size);
                } else if (part instanceof ImapBodyPart) {
                    ((ImapBodyPart) part).setSize(size);
                } else {
                    throw new MessagingException(""Unknown part type "" + part.toString());
                }
                part.setHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA, id);
            }

        }

        /**
         * Appends the given messages to the selected folder. This implementation also determines
         * the new UID of the given message on the IMAP server and sets the Message's UID to the
         * new server UID.
         */
        @Override
        public void appendMessages(Message[] messages) throws MessagingException {
            checkOpen();
            try {
                for (Message message : messages) {
                    mConnection.sendCommand(
                        String.format(""APPEND %s (%s) {%d}"",
                                      encodeString(encodeFolderName(getPrefixedName())),
                                      combineFlags(message.getFlags()),
                                      message.calculateSize()), false);
                    ImapResponse response;
                    do {
                        response = mConnection.readResponse();
                        handleUntaggedResponse(response);
                        if (response.mCommandContinuationRequested) {
                            EOLConvertingOutputStream eolOut = new EOLConvertingOutputStream(mConnection.mOut);
                            message.writeTo(eolOut);
                            eolOut.write('\r');
                            eolOut.write('\n');
                            eolOut.flush();
                        }
                        while (response.more());
                    } while (response.mTag == null);

                    String newUid = getUidFromMessageId(message);
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Got UID "" + newUid + "" for message for "" + getLogId());

                    if (newUid != null) {
                        message.setUid(newUid);
                    }


                }
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        @Override
        public String getUidFromMessageId(Message message) throws MessagingException {
            try {
                /*
                * Try to find the UID of the message we just appended using the
                * Message-ID header.
                */
                String[] messageIdHeader = message.getHeader(""Message-ID"");

                if (messageIdHeader == null || messageIdHeader.length == 0) {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Did not get a message-id in order to search for UID  for "" + getLogId());
                    return null;
                }
                String messageId = messageIdHeader[0];
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Looking for UID for message with message-id "" + messageId + "" for "" + getLogId());

                List<ImapResponse> responses =
                    executeSimpleCommand(
                        String.format(""UID SEARCH HEADER MESSAGE-ID %s"", messageId));
                for (ImapResponse response1 : responses) {
                    if (response1.mTag == null && ImapResponseParser.equalsIgnoreCase(response1.get(0), ""SEARCH"")
                            && response1.size() > 1) {
                        return response1.getString(1);
                    }
                }
                return null;
            } catch (IOException ioe) {
                throw new MessagingException(""Could not find UID for message based on Message-ID"", ioe);
            }
        }


        @Override
        public void expunge() throws MessagingException {
            checkOpen();
            try {
                executeSimpleCommand(""EXPUNGE"");
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        private String combineFlags(Flag[] flags) {
            ArrayList<String> flagNames = new ArrayList<String>();
            for (Flag flag : flags) {
                if (flag == Flag.SEEN) {
                    flagNames.add(""\\Seen"");
                } else if (flag == Flag.DELETED) {
                    flagNames.add(""\\Deleted"");
                } else if (flag == Flag.ANSWERED) {
                    flagNames.add(""\\Answered"");
                } else if (flag == Flag.FLAGGED) {
                    flagNames.add(""\\Flagged"");
                }

            }
            return Utility.combine(flagNames.toArray(new String[flagNames.size()]), ' ');
        }


        @Override
        public void setFlags(Flag[] flags, boolean value)
        throws MessagingException {
            checkOpen();


            try {
                executeSimpleCommand(String.format(""UID STORE 1:* %sFLAGS.SILENT (%s)"",
                                                   value ? ""+"" : ""-"", combineFlags(flags)));
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        @Override
        public String getNewPushState(String oldPushStateS, Message message) {
            try {
                String messageUidS = message.getUid();
                int messageUid = Integer.parseInt(messageUidS);
                ImapPushState oldPushState = ImapPushState.parse(oldPushStateS);
                if (messageUid >= oldPushState.uidNext) {
                    int uidNext = messageUid + 1;
                    ImapPushState newPushState = new ImapPushState(uidNext);
                    return newPushState.toString();
                } else {
                    return null;
                }
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Exception while updated push state for "" + getLogId(), e);
                return null;
            }
        }


        @Override
        public void setFlags(Message[] messages, Flag[] flags, boolean value)
        throws MessagingException {
            checkOpen();
            String[] uids = new String[messages.length];
            for (int i = 0, count = messages.length; i < count; i++) {
                uids[i] = messages[i].getUid();
            }
            ArrayList<String> flagNames = new ArrayList<String>();
            for (Flag flag : flags) {
                if (flag == Flag.SEEN) {
                    flagNames.add(""\\Seen"");
                } else if (flag == Flag.DELETED) {
                    flagNames.add(""\\Deleted"");
                } else if (flag == Flag.ANSWERED) {
                    flagNames.add(""\\Answered"");
                } else if (flag == Flag.FLAGGED) {
                    flagNames.add(""\\Flagged"");
                }
            }
            try {
                executeSimpleCommand(String.format(""UID STORE %s %sFLAGS.SILENT (%s)"",
                                                   Utility.combine(uids, ','),
                                                   value ? ""+"" : ""-"",
                                                   Utility.combine(flagNames.toArray(new String[flagNames.size()]), ' ')));
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        private void checkOpen() throws MessagingException {
            if (!isOpen()) {
                throw new MessagingException(""Folder "" + getPrefixedName() + "" is not open."");
            }
        }

        private MessagingException ioExceptionHandler(ImapConnection connection, IOException ioe) {
            Log.e(K9.LOG_TAG, ""IOException for "" + getLogId(), ioe);
            if (connection != null) {
                connection.close();
            }
            close();
            return new MessagingException(""IO Error"", ioe);
        }

        @Override
        public boolean equals(Object o) {
            if (o instanceof ImapFolder) {
                return ((ImapFolder)o).getName().equalsIgnoreCase(getName());
            }
            return super.equals(o);
        }

        @Override
        public int hashCode() {
            return getName().hashCode();
        }

        protected ImapStore getStore() {
            return store;
        }

        protected String getLogId() {
            String id = getAccount().getDescription() + "":"" + getName() + ""/"" + Thread.currentThread().getName();
            if (mConnection != null) {
                id += ""/"" + mConnection.getLogId();
            }
            return id;
        }
    }

    /**
     * A cacheable class that stores the details for a single IMAP connection.
     */
    public static class ImapConnection {
        protected Socket mSocket;
        protected PeekableInputStream mIn;
        protected OutputStream mOut;
        protected ImapResponseParser mParser;
        protected int mNextCommandTag;
        protected Set<String> capabilities = new HashSet<String>();

        private ImapSettings mSettings;

        public ImapConnection(final ImapSettings settings) {
            this.mSettings = settings;
        }

        protected String getLogId() {
            return ""conn"" + hashCode();
        }

        private List<ImapResponse> receiveCapabilities(List<ImapResponse> responses) {
            for (ImapResponse response : responses) {
                ImapList capabilityList = null;
                if (response.size() > 0 && ImapResponseParser.equalsIgnoreCase(response.get(0), ""OK"")) {
                    for (Object thisPart : response) {
                        if (thisPart instanceof ImapList) {
                            ImapList thisList = (ImapList)thisPart;
                            if (ImapResponseParser.equalsIgnoreCase(thisList.get(0), CAPABILITY_CAPABILITY)) {
                                capabilityList = thisList;
                                break;
                            }
                        }
                    }
                } else if (response.mTag == null) {
                    capabilityList = response;
                }

                if (capabilityList != null) {
                    if (capabilityList.size() > 0 && ImapResponseParser.equalsIgnoreCase(capabilityList.get(0), CAPABILITY_CAPABILITY)) {
                        if (K9.DEBUG) {
                            Log.d(K9.LOG_TAG, ""Saving "" + capabilityList.size() + "" capabilities for "" + getLogId());
                        }
                        for (Object capability : capabilityList) {
                            if (capability instanceof String) {
//                                if (K9.DEBUG)
//                                {
//                                    Log.v(K9.LOG_TAG, ""Saving capability '"" + capability + ""' for "" + getLogId());
//                                }
                                capabilities.add(((String)capability).toUpperCase());
                            }
                        }

                    }
                }
            }
            return responses;
        }

        public void open() throws IOException, MessagingException {
            if (isOpen()) {
                return;
            }

            boolean authSuccess = false;

            mNextCommandTag = 1;
            try {
                Security.setProperty(""networkaddress.cache.ttl"", ""0"");
            } catch (Exception e) {
                Log.w(K9.LOG_TAG, ""Could not set DNS ttl to 0 for "" + getLogId(), e);
            }


            try {
                Security.setProperty(""networkaddress.cache.negative.ttl"", ""0"");
            } catch (Exception e) {
                Log.w(K9.LOG_TAG, ""Could not set DNS negative ttl to 0 for "" + getLogId(), e);
            }



            try {

                SocketAddress socketAddress = new InetSocketAddress(mSettings.getHost(), mSettings.getPort());

                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Connection "" + getLogId() + "" connecting to "" + mSettings.getHost() + "" @ IP addr "" + socketAddress);

                if (mSettings.getConnectionSecurity() == CONNECTION_SECURITY_SSL_REQUIRED ||
                        mSettings.getConnectionSecurity() == CONNECTION_SECURITY_SSL_OPTIONAL) {
                    SSLContext sslContext = SSLContext.getInstance(""TLS"");
                    final boolean secure = mSettings.getConnectionSecurity() == CONNECTION_SECURITY_SSL_REQUIRED;
                    sslContext.init(null, new TrustManager[] {
                                        TrustManagerFactory.get(mSettings.getHost(), secure)
                                    }, new SecureRandom());
                    mSocket = sslContext.getSocketFactory().createSocket();
                    mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                } else {
                    mSocket = new Socket();
                    mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                }

                setReadTimeout(Store.SOCKET_READ_TIMEOUT);

                mIn = new PeekableInputStream(new BufferedInputStream(mSocket.getInputStream(),
                                              1024));
                mParser = new ImapResponseParser(mIn);
                mOut = mSocket.getOutputStream();

                capabilities.clear();
                ImapResponse nullResponse = mParser.readResponse();
                if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
                    Log.v(K9.LOG_TAG, getLogId() + ""<<<"" + nullResponse);

                List<ImapResponse> nullResponses = new LinkedList<ImapResponse>();
                nullResponses.add(nullResponse);
                receiveCapabilities(nullResponses);

                if (!hasCapability(CAPABILITY_CAPABILITY)) {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Did not get capabilities in banner, requesting CAPABILITY for "" + getLogId());
                    List<ImapResponse> responses = receiveCapabilities(executeSimpleCommand(COMMAND_CAPABILITY));
                    if (responses.size() != 2) {
                        throw new MessagingException(""Invalid CAPABILITY response received"");
                    }
                }

                if (mSettings.getConnectionSecurity() == CONNECTION_SECURITY_TLS_OPTIONAL
                        || mSettings.getConnectionSecurity() == CONNECTION_SECURITY_TLS_REQUIRED) {

                    if (hasCapability(""STARTTLS"")) {
                        // STARTTLS
                        executeSimpleCommand(""STARTTLS"");

                        SSLContext sslContext = SSLContext.getInstance(""TLS"");
                        boolean secure = mSettings.getConnectionSecurity() == CONNECTION_SECURITY_TLS_REQUIRED;
                        sslContext.init(null, new TrustManager[] {
                                            TrustManagerFactory.get(mSettings.getHost(), secure)
                                        }, new SecureRandom());
                        mSocket = sslContext.getSocketFactory().createSocket(mSocket, mSettings.getHost(), mSettings.getPort(),
                                  true);
                        mSocket.setSoTimeout(Store.SOCKET_READ_TIMEOUT);
                        mIn = new PeekableInputStream(new BufferedInputStream(mSocket
                                                      .getInputStream(), 1024));
                        mParser = new ImapResponseParser(mIn);
                        mOut = mSocket.getOutputStream();
                    } else if (mSettings.getConnectionSecurity() == CONNECTION_SECURITY_TLS_REQUIRED) {
                        throw new MessagingException(""TLS not supported but required"");
                    }
                }

                mOut = new BufferedOutputStream(mOut, 1024);

                try {
                    // Yahoo! requires a custom IMAP command to work right over a non-3G network
                    if (mSettings.getHost().endsWith(""yahoo.com"")) {
                        if (K9.DEBUG)
                            Log.v(K9.LOG_TAG, ""Found Yahoo! account.  Sending proprietary commands."");
                        executeSimpleCommand(""ID (\""GUID\"" \""1\"")"");
                    }
                    if (mSettings.getAuthType() == AuthType.CRAM_MD5) {
                        authCramMD5();
                        // The authCramMD5 method called on the previous line does not allow for handling updated capabilities
                        // sent by the server.  So, to make sure we update to the post-authentication capability list
                        // we fetch the capabilities here.
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Updating capabilities after CRAM-MD5 authentication for "" + getLogId());
                        List<ImapResponse> responses = receiveCapabilities(executeSimpleCommand(COMMAND_CAPABILITY));
                        if (responses.size() != 2) {
                            throw new MessagingException(""Invalid CAPABILITY response received"");
                        }

                    } else if (mSettings.getAuthType() == AuthType.PLAIN) {
                        receiveCapabilities(executeSimpleCommand(String.format(""LOGIN %s %s"", ImapStore.encodeString(mSettings.getUsername()), ImapStore.encodeString(mSettings.getPassword())), true));
                    }
                    authSuccess = true;
                } catch (ImapException ie) {
                    throw new AuthenticationFailedException(ie.getAlertText(), ie);

                } catch (MessagingException me) {
                    throw new AuthenticationFailedException(null, me);
                }
                if (K9.DEBUG) {
                    Log.d(K9.LOG_TAG, CAPABILITY_COMPRESS_DEFLATE + "" = "" + hasCapability(CAPABILITY_COMPRESS_DEFLATE));
                }
                if (hasCapability(CAPABILITY_COMPRESS_DEFLATE)) {
                    ConnectivityManager connectivityManager = (ConnectivityManager)K9.app.getSystemService(Context.CONNECTIVITY_SERVICE);
                    boolean useCompression = true;

                    NetworkInfo netInfo = connectivityManager.getActiveNetworkInfo();
                    if (netInfo != null) {
                        int type = netInfo.getType();
                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""On network type "" + type);
                        useCompression = mSettings.useCompression(type);

                    }
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""useCompression "" + useCompression);
                    if (useCompression) {
                        try {
                            executeSimpleCommand(COMMAND_COMPRESS_DEFLATE);
                            Inflater inf = new Inflater(true);
                            InflaterInputStream zInputStream = new InflaterInputStream(mSocket.getInputStream(), inf);
                            mIn = new PeekableInputStream(new BufferedInputStream(zInputStream, 1024));
                            mParser = new ImapResponseParser(mIn);
                            ZOutputStream zOutputStream = new ZOutputStream(mSocket.getOutputStream(), JZlib.Z_BEST_SPEED, true);
                            mOut = new BufferedOutputStream(zOutputStream, 1024);
                            zOutputStream.setFlushMode(JZlib.Z_PARTIAL_FLUSH);
                            if (K9.DEBUG) {
                                Log.i(K9.LOG_TAG, ""Compression enabled for "" + getLogId());
                            }
                        } catch (Exception e) {
                            Log.e(K9.LOG_TAG, ""Unable to negotiate compression"", e);
                        }
                    }
                }


                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""NAMESPACE = "" + hasCapability(CAPABILITY_NAMESPACE)
                          + "", mPathPrefix = "" + mSettings.getPathPrefix());

                if (mSettings.getPathPrefix() == null) {
                    if (hasCapability(CAPABILITY_NAMESPACE)) {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""mPathPrefix is unset and server has NAMESPACE capability"");
                        List<ImapResponse> namespaceResponses =
                            executeSimpleCommand(COMMAND_NAMESPACE);
                        for (ImapResponse response : namespaceResponses) {
                            if (ImapResponseParser.equalsIgnoreCase(response.get(0), COMMAND_NAMESPACE)) {
                                if (K9.DEBUG)
                                    Log.d(K9.LOG_TAG, ""Got NAMESPACE response "" + response + "" on "" + getLogId());

                                Object personalNamespaces = response.get(1);
                                if (personalNamespaces != null && personalNamespaces instanceof ImapList) {
                                    if (K9.DEBUG)
                                        Log.d(K9.LOG_TAG, ""Got personal namespaces: "" + personalNamespaces);
                                    ImapList bracketed = (ImapList)personalNamespaces;
                                    Object firstNamespace = bracketed.get(0);
                                    if (firstNamespace != null && firstNamespace instanceof ImapList) {
                                        if (K9.DEBUG)
                                            Log.d(K9.LOG_TAG, ""Got first personal namespaces: "" + firstNamespace);
                                        bracketed = (ImapList)firstNamespace;
                                        mSettings.setPathPrefix(bracketed.getString(0));
                                        mSettings.setPathDelimeter(bracketed.getString(1));
                                        mSettings.setCombinedPrefix(null);
                                        if (K9.DEBUG)
                                            Log.d(K9.LOG_TAG, ""Got path '"" + mSettings.getPathPrefix() + ""' and separator '"" + mSettings.getPathDelimeter() + ""'"");
                                    }
                                }
                            }
                        }
                    } else {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""mPathPrefix is unset but server does not have NAMESPACE capability"");
                        mSettings.setPathPrefix("""");
                    }
                }
                if (mSettings.getPathDelimeter() == null) {
                    try {
                        List<ImapResponse> nameResponses =
                            executeSimpleCommand(String.format(""LIST \""\"" \""\""""));
                        for (ImapResponse response : nameResponses) {
                            if (ImapResponseParser.equalsIgnoreCase(response.get(0), ""LIST"")) {
                                mSettings.setPathDelimeter(response.getString(2));
                                mSettings.setCombinedPrefix(null);
                                if (K9.DEBUG)
                                    Log.d(K9.LOG_TAG, ""Got path delimeter '"" + mSettings.getPathDelimeter() + ""' for "" + getLogId());
                            }
                        }
                    } catch (Exception e) {
                        Log.e(K9.LOG_TAG, ""Unable to get path delimeter using LIST"", e);
                    }
                }


            } catch (SSLException e) {
                throw new CertificateValidationException(e.getMessage(), e);
            } catch (GeneralSecurityException gse) {
                throw new MessagingException(
                    ""Unable to open connection to IMAP server due to security error."", gse);
            } catch (ConnectException ce) {
                String ceMess = ce.getMessage();
                String[] tokens = ceMess.split(""-"");
                if (tokens != null && tokens.length > 1 && tokens[1] != null) {
                    Log.e(K9.LOG_TAG, ""Stripping host/port from ConnectionException for "" + getLogId(), ce);
                    throw new ConnectException(tokens[1].trim());
                } else {
                    throw ce;
                }
            } finally {
                if (!authSuccess) {
                    Log.e(K9.LOG_TAG, ""Failed to login, closing connection for "" + getLogId());
                    close();
                }
            }
        }

        protected void authCramMD5() throws AuthenticationFailedException, MessagingException {
            try {
                String tag = sendCommand(""AUTHENTICATE CRAM-MD5"", false);
                byte[] buf = new byte[1024];
                int b64NonceLen = 0;
                for (int i = 0; i < buf.length; i++) {
                    buf[i] = (byte)mIn.read();
                    if (buf[i] == 0x0a) {
                        b64NonceLen = i;
                        break;
                    }
                }
                if (b64NonceLen == 0) {
                    throw new AuthenticationFailedException(""Error negotiating CRAM-MD5: nonce too long."");
                }
                byte[] b64NonceTrim = new byte[b64NonceLen - 2];
                System.arraycopy(buf, 1, b64NonceTrim, 0, b64NonceLen - 2);

                byte[] b64CRAM = Authentication.computeCramMd5Bytes(mSettings.getUsername(),
                                 mSettings.getPassword(), b64NonceTrim);

                mOut.write(b64CRAM);
                mOut.write(new byte[] { 0x0d, 0x0a });
                mOut.flush();

                int respLen = 0;
                for (int i = 0; i < buf.length; i++) {
                    buf[i] = (byte)mIn.read();
                    if (buf[i] == 0x0a) {
                        respLen = i;
                        break;
                    }
                }

                String toMatch = tag + "" OK"";
                String respStr = new String(buf, 0, respLen);
                if (!respStr.startsWith(toMatch)) {
                    throw new AuthenticationFailedException(""CRAM-MD5 error: "" + respStr);
                }
            } catch (IOException ioe) {
                throw new AuthenticationFailedException(""CRAM-MD5 Auth Failed."", ioe);
            }
        }

        protected void setReadTimeout(int millis) throws SocketException {
            Socket sock = mSocket;
            if (sock != null) {
                sock.setSoTimeout(millis);
            }
        }

        protected boolean isIdleCapable() {
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""Connection "" + getLogId() + "" has "" + capabilities.size() + "" capabilities"");

            return capabilities.contains(CAPABILITY_IDLE);
        }

        protected boolean hasCapability(String capability) {
            return capabilities.contains(capability.toUpperCase());
        }

        public boolean isOpen() {
            return (mIn != null && mOut != null && mSocket != null && mSocket.isConnected() && !mSocket.isClosed());
        }

        public void close() {
//            if (isOpen()) {
//                try {
//                    executeSimpleCommand(""LOGOUT"");
//                } catch (Exception e) {
//
//                }
//            }
            try {
                mIn.close();
            } catch (Exception e) {

            }
            try {
                mOut.close();
            } catch (Exception e) {

            }
            try {
                mSocket.close();
            } catch (Exception e) {

            }
            mIn = null;
            mOut = null;
            mSocket = null;
        }

        public ImapResponse readResponse() throws IOException, MessagingException {
            return readResponse(null);
        }

        public ImapResponse readResponse(ImapResponseParser.IImapResponseCallback callback) throws IOException {
            try {
                ImapResponse response = mParser.readResponse(callback);
                if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
                    Log.v(K9.LOG_TAG, getLogId() + ""<<<"" + response);

                return response;
            } catch (IOException ioe) {
                close();
                throw ioe;
            }
        }

        public void sendContinuation(String continuation) throws IOException {
            mOut.write(continuation.getBytes());
            mOut.write('\r');
            mOut.write('\n');
            mOut.flush();

            if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
                Log.v(K9.LOG_TAG, getLogId() + "">>> "" + continuation);

        }

        public String sendCommand(String command, boolean sensitive)
        throws MessagingException, IOException {
            try {
                open();
                String tag = Integer.toString(mNextCommandTag++);
                String commandToSend = tag + "" "" + command;
                mOut.write(commandToSend.getBytes());
                mOut.write('\r');
                mOut.write('\n');
                mOut.flush();

                if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP) {
                    if (sensitive && !K9.DEBUG_SENSITIVE) {
                        Log.v(K9.LOG_TAG, getLogId() + "">>> ""
                              + ""[Command Hidden, Enable Sensitive Debug Logging To Show]"");
                    } else {
                        Log.v(K9.LOG_TAG, getLogId() + "">>> "" + commandToSend);
                    }
                }

                return tag;
            } catch (IOException ioe) {
                close();
                throw ioe;
            } catch (ImapException ie) {
                close();
                throw ie;
            } catch (MessagingException me) {
                close();
                throw me;
            }
        }

        public List<ImapResponse> executeSimpleCommand(String command) throws IOException,
            ImapException, MessagingException {
            return executeSimpleCommand(command, false);
        }

        public List<ImapResponse> executeSimpleCommand(String command, boolean sensitive) throws IOException,
            ImapException, MessagingException {
            return executeSimpleCommand(command, sensitive, null);
        }

        public List<ImapResponse> executeSimpleCommand(String command, boolean sensitive, UntaggedHandler untaggedHandler)
        throws IOException, ImapException, MessagingException {
            String commandToLog = command;
            if (sensitive && !K9.DEBUG_SENSITIVE) {
                commandToLog = ""*sensitive*"";
            }


            //if (K9.DEBUG)
            //    Log.v(K9.LOG_TAG, ""Sending IMAP command "" + commandToLog + "" on connection "" + getLogId());

            String tag = sendCommand(command, sensitive);
            //if (K9.DEBUG)
            //    Log.v(K9.LOG_TAG, ""Sent IMAP command "" + commandToLog + "" with tag "" + tag + "" for "" + getLogId());

            ArrayList<ImapResponse> responses = new ArrayList<ImapResponse>();
            ImapResponse response;
            do {
                response = mParser.readResponse();
                if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
                    Log.v(K9.LOG_TAG, getLogId() + ""<<<"" + response);

                if (response.mTag != null && !response.mTag.equalsIgnoreCase(tag)) {
                    Log.w(K9.LOG_TAG, ""After sending tag "" + tag + "", got tag response from previous command "" + response + "" for "" + getLogId());
                    Iterator<ImapResponse> iter = responses.iterator();
                    while (iter.hasNext()) {
                        ImapResponse delResponse = iter.next();
                        if (delResponse.mTag != null || delResponse.size() < 2
                                || (!ImapResponseParser.equalsIgnoreCase(delResponse.get(1), ""EXISTS"") && !ImapResponseParser.equalsIgnoreCase(delResponse.get(1), ""EXPUNGE""))) {
                            iter.remove();
                        }
                    }
                    response.mTag = null;
                    continue;
                }
                if (untaggedHandler != null) {
                    untaggedHandler.handleAsyncUntaggedResponse(response);
                }
                responses.add(response);
            } while (response.mTag == null);
            if (response.size() < 1 || !ImapResponseParser.equalsIgnoreCase(response.get(0), ""OK"")) {
                throw new ImapException(""Command: "" + commandToLog + ""; response: "" + response.toString(), response.getAlertText());
            }
            return responses;
        }
    }

    static class ImapMessage extends MimeMessage {
        ImapMessage(String uid, Folder folder) {
            this.mUid = uid;
            this.mFolder = folder;
        }

        public void setSize(int size) {
            this.mSize = size;
        }

        @Override
        public void parse(InputStream in) throws IOException, MessagingException {
            super.parse(in);
        }

        public void setFlagInternal(Flag flag, boolean set) throws MessagingException {
            super.setFlag(flag, set);
        }


        @Override
        public void setFlag(Flag flag, boolean set) throws MessagingException {
            super.setFlag(flag, set);
            mFolder.setFlags(new Message[] { this }, new Flag[] { flag }, set);
        }

        @Override
        public void delete(String trashFolderName) throws MessagingException {
            getFolder().delete(new Message[] { this }, trashFolderName);
        }
    }

    static class ImapBodyPart extends MimeBodyPart {
        public ImapBodyPart() throws MessagingException {
            super();
        }

        public void setSize(int size) {
            this.mSize = size;
        }
    }

    static class ImapException extends MessagingException {
        private static final long serialVersionUID = 3725007182205882394L;
        String mAlertText;

        public ImapException(String message, String alertText, Throwable throwable) {
            super(message, throwable);
            this.mAlertText = alertText;
        }

        public ImapException(String message, String alertText) {
            super(message);
            this.mAlertText = alertText;
        }

        public String getAlertText() {
            return mAlertText;
        }

        public void setAlertText(String alertText) {
            mAlertText = alertText;
        }
    }

    public class ImapFolderPusher extends ImapFolder implements UntaggedHandler {
        final PushReceiver receiver;
        Thread listeningThread = null;
        final AtomicBoolean stop = new AtomicBoolean(false);
        final AtomicBoolean idling = new AtomicBoolean(false);
        final AtomicBoolean doneSent = new AtomicBoolean(false);
        final AtomicInteger delayTime = new AtomicInteger(NORMAL_DELAY_TIME);
        final AtomicInteger idleFailureCount = new AtomicInteger(0);
        final AtomicBoolean needsPoll = new AtomicBoolean(false);
        List<ImapResponse> storedUntaggedResponses = new ArrayList<ImapResponse>();
        TracingWakeLock wakeLock = null;

        public ImapFolderPusher(ImapStore store, String name, PushReceiver nReceiver) {
            super(store, name);
            receiver = nReceiver;
            TracingPowerManager pm = TracingPowerManager.getPowerManager(receiver.getContext());
            wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""ImapFolderPusher "" + store.getAccount().getDescription() + "":"" + getName());
            wakeLock.setReferenceCounted(false);

        }
        public void refresh() throws IOException, MessagingException {
            if (idling.get()) {
                wakeLock.acquire(K9.PUSH_WAKE_LOCK_TIMEOUT);
                sendDone();
            }
        }

        private void sendDone() throws IOException, MessagingException {
            if (doneSent.compareAndSet(false, true)) {
                ImapConnection conn = mConnection;
                if (conn != null) {
                    conn.setReadTimeout(Store.SOCKET_READ_TIMEOUT);
                    sendContinuation(""DONE"");
                }

            }
        }

        private void sendContinuation(String continuation)
        throws IOException {
            ImapConnection conn = mConnection;
            if (conn != null) {
                conn.sendContinuation(continuation);
            }
        }

        public void start() {
            Runnable runner = new Runnable() {
                public void run() {
                    wakeLock.acquire(K9.PUSH_WAKE_LOCK_TIMEOUT);
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Pusher starting for "" + getLogId());

                    while (!stop.get()) {
                        try {
                            int oldUidNext = -1;
                            try {
                                String pushStateS = receiver.getPushState(getName());
                                ImapPushState pushState = ImapPushState.parse(pushStateS);
                                oldUidNext = pushState.uidNext;
                                if (K9.DEBUG)
                                    Log.i(K9.LOG_TAG, ""Got oldUidNext "" + oldUidNext + "" for "" + getLogId());
                            } catch (Exception e) {
                                Log.e(K9.LOG_TAG, ""Unable to get oldUidNext for "" + getLogId(), e);
                            }
                            ImapConnection oldConnection = mConnection;
                            internalOpen(OpenMode.READ_ONLY);
                            ImapConnection conn = mConnection;
                            if (conn == null) {
                                receiver.pushError(""Could not establish connection for IDLE"", null);
                                throw new MessagingException(""Could not establish connection for IDLE"");

                            }
                            if (!conn.isIdleCapable()) {
                                stop.set(true);
                                receiver.pushError(""IMAP server is not IDLE capable: "" + conn.toString(), null);
                                throw new MessagingException(""IMAP server is not IDLE capable:"" + conn.toString());
                            }

                            if (!stop.get() && mAccount.isPushPollOnConnect() && (conn != oldConnection || needsPoll.getAndSet(false))) {
                                List<ImapResponse> untaggedResponses = new ArrayList<ImapResponse>(storedUntaggedResponses);
                                storedUntaggedResponses.clear();
                                processUntaggedResponses(untaggedResponses);
                                if (mMessageCount == -1) {
                                    throw new MessagingException(""Message count = -1 for idling"");
                                }
                                receiver.syncFolder(ImapFolderPusher.this);
                            }
                            if (stop.get()) {
                                continue;
                            }
                            int startUid = oldUidNext;

                            int newUidNext = uidNext;

                            if (newUidNext == -1) {
                                if (K9.DEBUG) {
                                    Log.d(K9.LOG_TAG, ""uidNext is -1, using search to find highest UID"");
                                }
                                int highestUid = getHighestUid();
                                if (highestUid != -1) {
                                    if (K9.DEBUG)
                                        Log.d(K9.LOG_TAG, ""highest UID = "" + highestUid);
                                    newUidNext = highestUid + 1;
                                    if (K9.DEBUG)
                                        Log.d(K9.LOG_TAG, ""highest UID = "" + highestUid
                                              + "", set newUidNext to "" + newUidNext);
                                }
                            }

                            if (startUid < newUidNext - mAccount.getDisplayCount()) {
                                startUid = newUidNext - mAccount.getDisplayCount();
                            }
                            if (startUid < 1) {
                                startUid = 1;
                            }
                            if (newUidNext > startUid) {

                                if (K9.DEBUG)
                                    Log.i(K9.LOG_TAG, ""Needs sync from uid "" + startUid  + "" to "" + newUidNext + "" for "" + getLogId());
                                List<Message> messages = new ArrayList<Message>();
                                for (int uid = startUid; uid < newUidNext; uid++) {
                                    ImapMessage message = new ImapMessage("""" + uid, ImapFolderPusher.this);
                                    messages.add(message);
                                }
                                if (messages.size() > 0) {
                                    pushMessages(messages, true);
                                }

                            } else {
                                List<ImapResponse> untaggedResponses = null;
                                while (storedUntaggedResponses.size() > 0) {
                                    if (K9.DEBUG)
                                        Log.i(K9.LOG_TAG, ""Processing "" + storedUntaggedResponses.size() + "" untagged responses from previous commands for "" + getLogId());
                                    untaggedResponses = new ArrayList<ImapResponse>(storedUntaggedResponses);
                                    storedUntaggedResponses.clear();
                                    processUntaggedResponses(untaggedResponses);
                                }

                                if (K9.DEBUG)
                                    Log.i(K9.LOG_TAG, ""About to IDLE for "" + getLogId());

                                receiver.setPushActive(getName(), true);
                                idling.set(true);
                                doneSent.set(false);

                                conn.setReadTimeout((getAccount().getIdleRefreshMinutes() * 60 * 1000) + IDLE_READ_TIMEOUT_INCREMENT);
                                untaggedResponses = executeSimpleCommand(COMMAND_IDLE, false, ImapFolderPusher.this);
                                idling.set(false);
                                delayTime.set(NORMAL_DELAY_TIME);
                                idleFailureCount.set(0);
                            }
                        } catch (Exception e) {
                            wakeLock.acquire(K9.PUSH_WAKE_LOCK_TIMEOUT);
                            storedUntaggedResponses.clear();
                            idling.set(false);
                            receiver.setPushActive(getName(), false);
                            try {
                                close();
                            } catch (Exception me) {
                                Log.e(K9.LOG_TAG, ""Got exception while closing for exception for "" + getLogId(), me);
                            }
                            if (stop.get()) {
                                Log.i(K9.LOG_TAG, ""Got exception while idling, but stop is set for "" + getLogId());
                            } else {
                                receiver.pushError(""Push error for "" + getName(), e);
                                Log.e(K9.LOG_TAG, ""Got exception while idling for "" + getLogId(), e);
                                int delayTimeInt = delayTime.get();
                                receiver.sleep(wakeLock, delayTimeInt);
                                delayTimeInt *= 2;
                                if (delayTimeInt > MAX_DELAY_TIME) {
                                    delayTimeInt = MAX_DELAY_TIME;
                                }
                                delayTime.set(delayTimeInt);
                                if (idleFailureCount.incrementAndGet() > IDLE_FAILURE_COUNT_LIMIT) {
                                    Log.e(K9.LOG_TAG, ""Disabling pusher for "" + getLogId() + "" after "" + idleFailureCount.get() + "" consecutive errors"");
                                    receiver.pushError(""Push disabled for "" + getName() + "" after "" + idleFailureCount.get() + "" consecutive errors"", e);
                                    stop.set(true);
                                }

                            }
                        }
                    }
                    receiver.setPushActive(getName(), false);
                    try {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Pusher for "" + getLogId() + "" is exiting"");
                        close();
                    } catch (Exception me) {
                        Log.e(K9.LOG_TAG, ""Got exception while closing for "" + getLogId(), me);
                    } finally {
                        wakeLock.release();
                    }
                }
            };
            listeningThread = new Thread(runner);
            listeningThread.start();
        }

        @Override
        protected void handleUntaggedResponse(ImapResponse response) {
            if (response.mTag == null && response.size() > 1) {
                Object responseType = response.get(1);
                if (ImapResponseParser.equalsIgnoreCase(responseType, ""FETCH"")
                        || ImapResponseParser.equalsIgnoreCase(responseType, ""EXPUNGE"")
                        || ImapResponseParser.equalsIgnoreCase(responseType, ""EXISTS"")) {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Storing response "" + response + "" for later processing"");

                    storedUntaggedResponses.add(response);
                }
                handlePossibleUidNext(response);
            }
        }

        protected void processUntaggedResponses(List<ImapResponse> responses) throws MessagingException {
            boolean skipSync = false;
            int oldMessageCount = mMessageCount;
            if (oldMessageCount == -1) {
                skipSync = true;
            }
            List<Integer> flagSyncMsgSeqs = new ArrayList<Integer>();
            List<String> removeMsgUids = new LinkedList<String>();

            for (ImapResponse response : responses) {
                oldMessageCount += processUntaggedResponse(oldMessageCount, response, flagSyncMsgSeqs, removeMsgUids);
            }
            if (!skipSync) {
                if (oldMessageCount < 0) {
                    oldMessageCount = 0;
                }
                if (mMessageCount > oldMessageCount) {
                    syncMessages(mMessageCount, true);
                }
            }
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""UIDs for messages needing flag sync are "" + flagSyncMsgSeqs + ""  for "" + getLogId());

            if (flagSyncMsgSeqs.size() > 0) {
                syncMessages(flagSyncMsgSeqs);
            }
            if (removeMsgUids.size() > 0) {
                removeMessages(removeMsgUids);
            }
        }

        private void syncMessages(int end, boolean newArrivals) throws MessagingException {
            int oldUidNext = -1;
            try {
                String pushStateS = receiver.getPushState(getName());
                ImapPushState pushState = ImapPushState.parse(pushStateS);
                oldUidNext = pushState.uidNext;
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Got oldUidNext "" + oldUidNext + "" for "" + getLogId());
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Unable to get oldUidNext for "" + getLogId(), e);
            }

            Message[] messageArray = getMessages(end, end, null, true, null);
            if (messageArray != null && messageArray.length > 0) {
                int newUid = Integer.parseInt(messageArray[0].getUid());
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Got newUid "" + newUid + "" for message "" + end + "" on "" + getLogId());
                int startUid = oldUidNext;
                if (startUid < newUid - 10) {
                    startUid = newUid - 10;
                }
                if (startUid < 1) {
                    startUid = 1;
                }
                if (newUid >= startUid) {

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Needs sync from uid "" + startUid  + "" to "" + newUid + "" for "" + getLogId());
                    List<Message> messages = new ArrayList<Message>();
                    for (int uid = startUid; uid <= newUid; uid++) {
                        ImapMessage message = new ImapMessage("""" + uid, ImapFolderPusher.this);
                        messages.add(message);
                    }
                    if (messages.size() > 0) {
                        pushMessages(messages, true);
                    }
                }
            }
        }

        private void syncMessages(List<Integer> flagSyncMsgSeqs) {
            try {
                Message[] messageArray = null;

                messageArray = getMessages(flagSyncMsgSeqs, true, null);

                List<Message> messages = new ArrayList<Message>();
                messages.addAll(Arrays.asList(messageArray));
                pushMessages(messages, false);

            } catch (Exception e) {
                receiver.pushError(""Exception while processing Push untagged responses"", e);
            }
        }

        private void removeMessages(List<String> removeUids) {
            List<Message> messages = new ArrayList<Message>(removeUids.size());

            try {
                Message[] existingMessages = getMessagesFromUids(removeUids, true, null);
                for (Message existingMessage : existingMessages) {
                    needsPoll.set(true);
                    msgSeqUidMap.clear();
                    String existingUid = existingMessage.getUid();
                    Log.w(K9.LOG_TAG, ""Message with UID "" + existingUid + "" still exists on server, not expunging"");
                    removeUids.remove(existingUid);
                }
                for (String uid : removeUids) {
                    ImapMessage message = new ImapMessage(uid, this);
                    try {
                        message.setFlagInternal(Flag.DELETED, true);
                    } catch (MessagingException me) {
                        Log.e(K9.LOG_TAG, ""Unable to set DELETED flag on message "" + message.getUid());
                    }
                    messages.add(message);
                }
                receiver.messagesRemoved(this, messages);
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Cannot remove EXPUNGEd messages"", e);
            }

        }

        protected int processUntaggedResponse(int oldMessageCount, ImapResponse response, List<Integer> flagSyncMsgSeqs, List<String> removeMsgUids) {
            super.handleUntaggedResponse(response);
            int messageCountDelta = 0;
            if (response.mTag == null && response.size() > 1) {
                try {
                    Object responseType = response.get(1);
                    if (ImapResponseParser.equalsIgnoreCase(responseType, ""FETCH"")) {
                        Log.i(K9.LOG_TAG, ""Got FETCH "" + response);
                        int msgSeq = response.getNumber(0);

                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""Got untagged FETCH for msgseq "" + msgSeq + "" for "" + getLogId());

                        if (!flagSyncMsgSeqs.contains(msgSeq)) {
                            flagSyncMsgSeqs.add(msgSeq);
                        }
                    }
                    if (ImapResponseParser.equalsIgnoreCase(responseType, ""EXPUNGE"")) {
                        int msgSeq = response.getNumber(0);
                        if (msgSeq <= oldMessageCount) {
                            messageCountDelta = -1;
                        }
                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""Got untagged EXPUNGE for msgseq "" + msgSeq + "" for "" + getLogId());

                        List<Integer> newSeqs = new ArrayList<Integer>();
                        Iterator<Integer> flagIter = flagSyncMsgSeqs.iterator();
                        while (flagIter.hasNext()) {
                            Integer flagMsg = flagIter.next();
                            if (flagMsg >= msgSeq) {
                                flagIter.remove();
                                if (flagMsg > msgSeq) {
                                    newSeqs.add(flagMsg--);
                                }
                            }
                        }
                        flagSyncMsgSeqs.addAll(newSeqs);


                        List<Integer> msgSeqs = new ArrayList<Integer>(msgSeqUidMap.keySet());
                        Collections.sort(msgSeqs);  // Have to do comparisons in order because of msgSeq reductions

                        for (Integer msgSeqNumI : msgSeqs) {
                            if (K9.DEBUG) {
                                Log.v(K9.LOG_TAG, ""Comparing EXPUNGEd msgSeq "" + msgSeq + "" to "" + msgSeqNumI);
                            }
                            int msgSeqNum = msgSeqNumI;
                            if (msgSeqNum == msgSeq) {
                                String uid = msgSeqUidMap.get(msgSeqNum);
                                if (K9.DEBUG) {
                                    Log.d(K9.LOG_TAG, ""Scheduling removal of UID "" + uid + "" because msgSeq "" + msgSeqNum + "" was expunged"");
                                }
                                removeMsgUids.add(uid);
                                msgSeqUidMap.remove(msgSeqNum);
                            } else if (msgSeqNum > msgSeq) {
                                String uid = msgSeqUidMap.get(msgSeqNum);
                                if (K9.DEBUG) {
                                    Log.d(K9.LOG_TAG, ""Reducing msgSeq for UID "" + uid + "" from "" + msgSeqNum + "" to "" + (msgSeqNum - 1));
                                }
                                msgSeqUidMap.remove(msgSeqNum);
                                msgSeqUidMap.put(msgSeqNum - 1, uid);
                            }
                        }
                    }
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Could not handle untagged FETCH for "" + getLogId(), e);
                }
            }
            return messageCountDelta;
        }


        private void pushMessages(List<Message> messages, boolean newArrivals) {
            RuntimeException holdException = null;
            try {
                if (newArrivals) {
                    receiver.messagesArrived(this, messages);
                } else {
                    receiver.messagesFlagsChanged(this, messages);
                }
            } catch (RuntimeException e) {
                holdException = e;
            }

            if (holdException != null) {
                throw holdException;
            }
        }

        public void stop() {
            stop.set(true);
            if (listeningThread != null) {
                listeningThread.interrupt();
            }
            ImapConnection conn = mConnection;
            if (conn != null) {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""Closing mConnection to stop pushing for "" + getLogId());
                conn.close();
            } else {
                Log.w(K9.LOG_TAG, ""Attempt to interrupt null mConnection to stop pushing on folderPusher for "" + getLogId());
            }
        }

        public void handleAsyncUntaggedResponse(ImapResponse response) {
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""Got async response: "" + response);

            if (stop.get()) {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Got async untagged response: "" + response + "", but stop is set for "" + getLogId());

                try {
                    sendDone();
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Exception while sending DONE for "" + getLogId(), e);
                }
            } else {
                if (response.mTag == null) {
                    if (response.size() > 1) {
                        boolean started = false;
                        Object responseType = response.get(1);
                        if (ImapResponseParser.equalsIgnoreCase(responseType, ""EXISTS"") || ImapResponseParser.equalsIgnoreCase(responseType, ""EXPUNGE"") ||
                                ImapResponseParser.equalsIgnoreCase(responseType, ""FETCH"")) {
                            if (!started) {
                                wakeLock.acquire(K9.PUSH_WAKE_LOCK_TIMEOUT);
                                started = true;
                            }

                            if (K9.DEBUG)
                                Log.d(K9.LOG_TAG, ""Got useful async untagged response: "" + response + "" for "" + getLogId());

                            try {
                                sendDone();
                            } catch (Exception e) {
                                Log.e(K9.LOG_TAG, ""Exception while sending DONE for "" + getLogId(), e);
                            }
                        }
                    } else if (response.mCommandContinuationRequested) {
                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""Idling "" + getLogId());

                        wakeLock.release();
                    }
                }
            }
        }
    }
    @Override
    public Pusher getPusher(PushReceiver receiver) {
        return new ImapPusher(this, receiver);
    }

    public class ImapPusher implements Pusher {
        final ImapStore mStore;
        final PushReceiver mReceiver;
        private long lastRefresh = -1;

        HashMap<String, ImapFolderPusher> folderPushers = new HashMap<String, ImapFolderPusher>();

        public ImapPusher(ImapStore store, PushReceiver receiver) {
            mStore = store;
            mReceiver = receiver;
        }

        public void start(List<String> folderNames) {
            stop();
            synchronized (folderPushers) {
                setLastRefresh(System.currentTimeMillis());
                for (String folderName : folderNames) {
                    ImapFolderPusher pusher = folderPushers.get(folderName);
                    if (pusher == null) {
                        pusher = new ImapFolderPusher(mStore, folderName, mReceiver);
                        folderPushers.put(folderName, pusher);
                        pusher.start();
                    }
                }
            }
        }

        public void refresh() {
            synchronized (folderPushers) {
                for (ImapFolderPusher folderPusher : folderPushers.values()) {
                    try {
                        folderPusher.refresh();
                    } catch (Exception e) {
                        Log.e(K9.LOG_TAG, ""Got exception while refreshing for "" + folderPusher.getName(), e);
                    }
                }
            }
        }

        public void stop() {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""Requested stop of IMAP pusher"");

            synchronized (folderPushers) {
                for (ImapFolderPusher folderPusher : folderPushers.values()) {
                    try {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Requesting stop of IMAP folderPusher "" + folderPusher.getName());
                        folderPusher.stop();
                    } catch (Exception e) {
                        Log.e(K9.LOG_TAG, ""Got exception while stopping "" + folderPusher.getName(), e);
                    }
                }
                folderPushers.clear();
            }
        }

        public int getRefreshInterval() {
            return (getAccount().getIdleRefreshMinutes() * 60 * 1000);
        }

        public long getLastRefresh() {
            return lastRefresh;
        }

        public void setLastRefresh(long lastRefresh) {
            this.lastRefresh = lastRefresh;
        }

    }
    private interface UntaggedHandler {
        void handleAsyncUntaggedResponse(ImapResponse respose);
    }

    protected static class ImapPushState {
        protected int uidNext;
        protected ImapPushState(int nUidNext) {
            uidNext = nUidNext;
        }
        protected static ImapPushState parse(String pushState) {
            int newUidNext = -1;
            if (pushState != null) {
                StringTokenizer tokenizer = new StringTokenizer(pushState, "";"");
                while (tokenizer.hasMoreTokens()) {
                    StringTokenizer thisState = new StringTokenizer(tokenizer.nextToken(), ""="");
                    if (thisState.hasMoreTokens()) {
                        String key = thisState.nextToken();

                        if (""uidNext"".equalsIgnoreCase(key) && thisState.hasMoreTokens()) {
                            String value = thisState.nextToken();
                            try {
                                newUidNext = Integer.parseInt(value);
                            } catch (Exception e) {
                                Log.e(K9.LOG_TAG, ""Unable to part uidNext value "" + value, e);
                            }

                        }
                    }
                }
            }
            return new ImapPushState(newUidNext);
        }
        @Override
        public String toString() {
            return ""uidNext="" + uidNext;
        }

    }
    private interface ImapSearcher {
        List<ImapResponse> search() throws IOException, MessagingException;
    }

    private static class FetchBodyCallback implements ImapResponseParser.IImapResponseCallback {
        private HashMap<String, Message> mMessageMap;

        FetchBodyCallback(HashMap<String, Message> mesageMap) {
            mMessageMap = mesageMap;
        }

        @Override
        public Object foundLiteral(ImapResponse response,
                                   FixedLengthInputStream literal) throws IOException, Exception {
            if (response.mTag == null &&
                    ImapResponseParser.equalsIgnoreCase(response.get(1), ""FETCH"")) {
                ImapList fetchList = (ImapList)response.getKeyedValue(""FETCH"");
                String uid = fetchList.getKeyedString(""UID"");

                ImapMessage message = (ImapMessage) mMessageMap.get(uid);
                message.parse(literal);

                // Return placeholder object
                return new Integer(1);
            }
            return null;
        }
    }

    private static class FetchPartCallback implements ImapResponseParser.IImapResponseCallback {
        private Part mPart;

        FetchPartCallback(Part part) {
            mPart = part;
        }

        @Override
        public Object foundLiteral(ImapResponse response,
                                   FixedLengthInputStream literal) throws IOException, Exception {
            if (response.mTag == null &&
                    ImapResponseParser.equalsIgnoreCase(response.get(1), ""FETCH"")) {
                //TODO: check for correct UID

                String contentTransferEncoding = mPart.getHeader(
                                                     MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING)[0];

                return MimeUtility.decodeBody(literal, contentTransferEncoding);
            }
            return null;
        }
    }

}
",True,144,0,0,6,33,2,30,L1
154,com.fsck.k9.preferences.Editor.java,"package com.fsck.k9.preferences;

import android.util.Log;
import com.fsck.k9.K9;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

public class Editor implements android.content.SharedPreferences.Editor {
    private Storage storage;
    private HashMap<String, String> changes = new HashMap<String, String>();
    private ArrayList<String> removals = new ArrayList<String>();
    private boolean removeAll = false;

    Map<String, String> snapshot = new HashMap<String, String>();


    protected Editor(Storage storage) {
        this.storage = storage;
        snapshot.putAll(storage.getAll());
    }

    public void copy(android.content.SharedPreferences input) {
        Map < String, ? > oldVals = input.getAll();
        for (Entry < String, ? > entry : oldVals.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            if (key != null && value != null) {
                if (K9.DEBUG) {
                    Log.d(K9.LOG_TAG, ""Copying key '"" + key + ""', value '"" + value + ""'"");
                }
                changes.put(key, """" + value);
            } else {
                if (K9.DEBUG) {
                    Log.d(K9.LOG_TAG, ""Skipping copying key '"" + key + ""', value '"" + value + ""'"");
                }
            }
        }
    }

    //@Override
    public android.content.SharedPreferences.Editor clear() {
        removeAll = true;
        return this;
    }


    // TODO Android 2.3 provides a sexy new ""apply"" method we need to implement
    public void apply() {
        commit();
    }



    /* This method is poorly defined.  It should throw an Exception on failure */
    //@Override
    public boolean commit() {
        try {
            commitChanges();
            return true;
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Failed to save preferences"", e);
            return false;
        }
    }

    public void commitChanges() {
        long startTime = System.currentTimeMillis();
        Log.i(K9.LOG_TAG, ""Committing preference changes"");
        Runnable committer = new Runnable() {
            public void run() {
                if (removeAll) {
                    storage.removeAll();
                }
                for (String removeKey : removals) {
                    storage.remove(removeKey);
                }
                Map<String, String> insertables = new HashMap<String, String>();
                for (Entry<String, String> entry : changes.entrySet()) {
                    String key = entry.getKey();
                    String newValue = entry.getValue();
                    String oldValue = snapshot.get(key);
                    if (removeAll || removals.contains(key) || !newValue.equals(oldValue)) {
                        insertables.put(key, newValue);
                    }
                }
                storage.put(insertables);
            }
        };
        storage.doInTransaction(committer);
        long endTime = System.currentTimeMillis();
        Log.i(K9.LOG_TAG, ""Preferences commit took "" + (endTime - startTime) + ""ms"");

    }

    //@Override
    public android.content.SharedPreferences.Editor putBoolean(String key,
            boolean value) {
        changes.put(key, """" + value);
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor putFloat(String key,
            float value) {
        changes.put(key, """" + value);
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor putInt(String key, int value) {
        changes.put(key, """" + value);
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor putLong(String key, long value) {
        changes.put(key, """" + value);
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor putString(String key,
            String value) {
        if (value == null) {
            remove(key);
        } else {
            changes.put(key, value);
        }
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor remove(String key) {
        removals.add(key);
        return this;
    }

}
",True,144,0,0,7,53,2,2,L1
155,com.fsck.k9.preferences.Storage.java,"package com.fsck.k9.preferences;

import android.content.ContentValues;
import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;
import android.util.Log;

import com.fsck.k9.K9;
import com.fsck.k9.helper.Utility;

import java.net.URI;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

public class Storage implements SharedPreferences {
    private static ConcurrentHashMap<Context, Storage> storages =
        new ConcurrentHashMap<Context, Storage>();

    private volatile ConcurrentHashMap<String, String> storage = new ConcurrentHashMap<String, String>();

    private CopyOnWriteArrayList<OnSharedPreferenceChangeListener> listeners =
        new CopyOnWriteArrayList<OnSharedPreferenceChangeListener>();

    private int DB_VERSION = 2;
    private String DB_NAME = ""preferences_storage"";

    private ThreadLocal<ConcurrentHashMap<String, String>> workingStorage
    = new ThreadLocal<ConcurrentHashMap<String, String>>();
    private ThreadLocal<SQLiteDatabase> workingDB =
        new ThreadLocal<SQLiteDatabase>();
    private ThreadLocal<ArrayList<String>> workingChangedKeys = new ThreadLocal<ArrayList<String>>();


    private Context context = null;

    private SQLiteDatabase openDB() {
        SQLiteDatabase mDb = context.openOrCreateDatabase(DB_NAME, Context.MODE_PRIVATE, null);

        if (mDb.getVersion() == 1) {
            Log.i(K9.LOG_TAG, ""Updating preferences to urlencoded username/password"");

            String accountUuids = readValue(mDb, ""accountUuids"");
            if (accountUuids != null && accountUuids.length() != 0) {
                String[] uuids = accountUuids.split("","");
                for (String uuid : uuids) {
                    try {
                        String storeUriStr = Utility.base64Decode(readValue(mDb, uuid + "".storeUri""));
                        String transportUriStr = Utility.base64Decode(readValue(mDb, uuid + "".transportUri""));

                        URI uri = new URI(transportUriStr);
                        String newUserInfo = null;
                        if (transportUriStr != null) {
                            String[] userInfoParts = uri.getUserInfo().split("":"");

                            String usernameEnc = URLEncoder.encode(userInfoParts[0], ""UTF-8"");
                            String passwordEnc = """";
                            String authType = """";
                            if (userInfoParts.length > 1) {
                                passwordEnc = "":"" + URLEncoder.encode(userInfoParts[1], ""UTF-8"");
                            }
                            if (userInfoParts.length > 2) {
                                authType = "":"" + userInfoParts[2];
                            }

                            newUserInfo = usernameEnc + passwordEnc + authType;
                        }

                        if (newUserInfo != null) {
                            URI newUri = new URI(uri.getScheme(), newUserInfo, uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());
                            String newTransportUriStr = Utility.base64Encode(newUri.toString());
                            writeValue(mDb, uuid + "".transportUri"", newTransportUriStr);
                        }

                        uri = new URI(storeUriStr);
                        newUserInfo = null;
                        if (storeUriStr.startsWith(""imap"")) {
                            String[] userInfoParts = uri.getUserInfo().split("":"");
                            if (userInfoParts.length == 2) {
                                String usernameEnc = URLEncoder.encode(userInfoParts[0], ""UTF-8"");
                                String passwordEnc = URLEncoder.encode(userInfoParts[1], ""UTF-8"");

                                newUserInfo = usernameEnc + "":"" + passwordEnc;
                            } else {
                                String authType = userInfoParts[0];
                                String usernameEnc = URLEncoder.encode(userInfoParts[1], ""UTF-8"");
                                String passwordEnc = URLEncoder.encode(userInfoParts[2], ""UTF-8"");

                                newUserInfo = authType + "":"" + usernameEnc + "":"" + passwordEnc;
                            }
                        } else if (storeUriStr.startsWith(""pop3"")) {
                            String[] userInfoParts = uri.getUserInfo().split("":"", 2);
                            String usernameEnc = URLEncoder.encode(userInfoParts[0], ""UTF-8"");

                            String passwordEnc = """";
                            if (userInfoParts.length > 1) {
                                passwordEnc = "":"" + URLEncoder.encode(userInfoParts[1], ""UTF-8"");
                            }

                            newUserInfo = usernameEnc + passwordEnc;
                        } else if (storeUriStr.startsWith(""webdav"")) {
                            String[] userInfoParts = uri.getUserInfo().split("":"", 2);
                            String usernameEnc = URLEncoder.encode(userInfoParts[0], ""UTF-8"");

                            String passwordEnc = """";
                            if (userInfoParts.length > 1) {
                                passwordEnc = "":"" + URLEncoder.encode(userInfoParts[1], ""UTF-8"");
                            }

                            newUserInfo = usernameEnc + passwordEnc;
                        }

                        if (newUserInfo != null) {
                            URI newUri = new URI(uri.getScheme(), newUserInfo, uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());
                            String newStoreUriStr = Utility.base64Encode(newUri.toString());
                            writeValue(mDb, uuid + "".storeUri"", newStoreUriStr);
                        }
                    } catch (Exception e) {
                        Log.e(K9.LOG_TAG, ""ooops"", e);
                    }
                }
            }

            mDb.setVersion(DB_VERSION);
        }

        if (mDb.getVersion() != DB_VERSION) {
            Log.i(K9.LOG_TAG, ""Creating Storage database"");
            mDb.execSQL(""DROP TABLE IF EXISTS preferences_storage"");
            mDb.execSQL(""CREATE TABLE preferences_storage "" +
                        ""(primkey TEXT PRIMARY KEY ON CONFLICT REPLACE, value TEXT)"");
            mDb.setVersion(DB_VERSION);
        }
        return mDb;
    }


    public static Storage getStorage(Context context) {
        Storage tmpStorage = storages.get(context);
        if (tmpStorage != null) {
            if (K9.DEBUG) {
                Log.d(K9.LOG_TAG, ""Returning already existing Storage"");
            }
            return tmpStorage;
        } else {
            if (K9.DEBUG) {
                Log.d(K9.LOG_TAG, ""Creating provisional storage"");
            }
            tmpStorage = new Storage(context);
            Storage oldStorage = storages.putIfAbsent(context, tmpStorage);
            if (oldStorage != null) {
                if (K9.DEBUG) {
                    Log.d(K9.LOG_TAG, ""Another thread beat us to creating the Storage, returning that one"");
                }
                return oldStorage;
            } else {
                if (K9.DEBUG) {
                    Log.d(K9.LOG_TAG, ""Returning the Storage we created"");
                }
                return tmpStorage;
            }
        }
    }

    private void loadValues() {
        long startTime = System.currentTimeMillis();
        Log.i(K9.LOG_TAG, ""Loading preferences from DB into Storage"");
        Cursor cursor = null;
        SQLiteDatabase mDb = null;
        try {
            mDb = openDB();

            cursor = mDb.rawQuery(""SELECT primkey, value FROM preferences_storage"", null);
            while (cursor.moveToNext()) {
                String key = cursor.getString(0);
                String value = cursor.getString(1);
                if (K9.DEBUG) {
                    Log.d(K9.LOG_TAG, ""Loading key '"" + key + ""', value = '"" + value + ""'"");
                }
                storage.put(key, value);
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
            if (mDb != null) {
                mDb.close();
            }
            long endTime = System.currentTimeMillis();
            Log.i(K9.LOG_TAG, ""Preferences load took "" + (endTime - startTime) + ""ms"");
        }
    }

    private Storage(Context context) {
        this.context = context;
        loadValues();
    }

    private void keyChange(String key) {
        ArrayList<String> changedKeys = workingChangedKeys.get();
        if (!changedKeys.contains(key)) {
            changedKeys.add(key);
        }
    }

    protected void put(String key, String value) {
        ContentValues cv = generateCV(key, value);
        workingDB.get().insert(""preferences_storage"", ""primkey"", cv);
        liveUpdate(key, value);
    }

    protected void put(Map<String, String> insertables) {
        String sql = ""insert into preferences_storage (primkey, value) VALUES (?, ?)"";
        SQLiteStatement stmt = workingDB.get().compileStatement(sql);

        for (Map.Entry<String, String> entry : insertables.entrySet()) {
            String key = entry.getKey();
            String value = entry.getValue();
            stmt.bindString(1, key);
            stmt.bindString(2, value);
            stmt.execute();
            stmt.clearBindings();
            liveUpdate(key, value);
        }
        stmt.close();
    }

    private ContentValues generateCV(String key, String value) {
        ContentValues cv = new ContentValues();
        cv.put(""primkey"", key);
        cv.put(""value"", value);
        return cv;
    }

    private void liveUpdate(String key, String value) {
        workingStorage.get().put(key, value);

        keyChange(key);
    }

    protected void remove(String key) {
        workingDB.get().delete(""preferences_storage"", ""primkey = ?"", new String[] { key });
        workingStorage.get().remove(key);

        keyChange(key);
    }

    protected void removeAll() {
        for (String key : workingStorage.get().keySet()) {
            keyChange(key);
        }
        workingDB.get().execSQL(""DELETE FROM preferences_storage"");
        workingStorage.get().clear();
    }

    protected void doInTransaction(Runnable dbWork) {
        ConcurrentHashMap<String, String> newStorage = new ConcurrentHashMap<String, String>();
        newStorage.putAll(storage);
        workingStorage.set(newStorage);

        SQLiteDatabase mDb = openDB();
        workingDB.set(mDb);

        ArrayList<String> changedKeys = new ArrayList<String>();
        workingChangedKeys.set(changedKeys);

        mDb.beginTransaction();
        try {
            dbWork.run();
            mDb.setTransactionSuccessful();
            storage = newStorage;
            for (String changedKey : changedKeys) {
                for (OnSharedPreferenceChangeListener listener : listeners) {
                    listener.onSharedPreferenceChanged(this, changedKey);
                }
            }
        } finally {
            workingDB.remove();
            workingStorage.remove();
            workingChangedKeys.remove();
            mDb.endTransaction();
            mDb.close();
        }
    }

    public long size() {
        return storage.size();
    }

    //@Override
    public boolean contains(String key) {
        return storage.contains(key);
    }

    //@Override
    public com.fsck.k9.preferences.Editor edit() {
        return new com.fsck.k9.preferences.Editor(this);
    }

    //@Override
    public Map<String, String> getAll() {
        return storage;
    }

    //@Override
    public boolean getBoolean(String key, boolean defValue) {
        String val = storage.get(key);
        if (val == null) {
            return defValue;
        }
        return Boolean.parseBoolean(val);
    }

    //@Override
    public float getFloat(String key, float defValue) {
        String val = storage.get(key);
        if (val == null) {
            return defValue;
        }
        return Float.parseFloat(val);
    }

    //@Override
    public int getInt(String key, int defValue) {
        String val = storage.get(key);
        if (val == null) {
            return defValue;
        }
        return Integer.parseInt(val);
    }

    //@Override
    public long getLong(String key, long defValue) {
        String val = storage.get(key);
        if (val == null) {
            return defValue;
        }
        return Long.parseLong(val);
    }

    //@Override
    public String getString(String key, String defValue) {
        String val = storage.get(key);
        if (val == null) {
            return defValue;
        }
        return val;
    }

    //@Override
    public void registerOnSharedPreferenceChangeListener(
        OnSharedPreferenceChangeListener listener) {
        listeners.addIfAbsent(listener);
    }

    //@Override
    public void unregisterOnSharedPreferenceChangeListener(
        OnSharedPreferenceChangeListener listener) {
        listeners.remove(listener);
    }

    private String readValue(SQLiteDatabase mDb, String key) {
        Cursor cursor = null;
        String value = null;
        try {
            cursor = mDb.query(
                         ""preferences_storage"",
                         new String[] {""value""},
                         ""primkey = ?"",
                         new String[] {key},
                         null,
                         null,
                         null);

            if (cursor.moveToNext()) {
                value = cursor.getString(0);
                if (K9.DEBUG) {
                    Log.d(K9.LOG_TAG, ""Loading key '"" + key + ""', value = '"" + value + ""'"");
                }
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }

        return value;
    }

    private void writeValue(SQLiteDatabase mDb, String key, String value) {
        ContentValues cv = new ContentValues();
        cv.put(""primkey"", key);
        cv.put(""value"", value);

        long result = mDb.insert(""preferences_storage"", ""primkey"", cv);

        if (result == -1) {
            Log.e(K9.LOG_TAG, ""Error writing key '"" + key + ""', value = '"" + value + ""'"");
        }
    }
}
",True,144,0,0,7,52,2,3,L1
156,com.fsck.k9.preferences.TimePickerPreference.java,"/* Sourced from http://www.ebessette.com/d/TimePickerPreference
 * on 2010-11-27 by jessev
 */

package com.fsck.k9.preferences;

import android.content.Context;
import android.preference.DialogPreference;
import android.text.format.DateFormat;
import android.util.AttributeSet;
import android.view.View;
import android.widget.TimePicker;

/**
 * A preference type that allows a user to choose a time
 */
public class TimePickerPreference extends DialogPreference implements
    TimePicker.OnTimeChangedListener {

    /**
     * The validation expression for this preference
     */
    private static final String VALIDATION_EXPRESSION = ""[0-2]*[0-9]:[0-5]*[0-9]"";

    /**
     * The default value for this preference
     */
    private String defaultValue;
    /**
     * Store the original value, in case the user
     * chooses to abort the {@link DialogPreference}
     * after making a change.
     */
    private int originalHour = 0;
    /**
     * Store the original value, in case the user
     * chooses to abort the {@link DialogPreference}
     * after making a change.
     */
    private int originalMinute = 0;
    /**
     * @param context
     * @param attrs
     */
    public TimePickerPreference(final Context context, final AttributeSet attrs) {
        super(context, attrs);
        initialize();
    }

    /**
     * @param context
     * @param attrs
     * @param defStyle
     */
    public TimePickerPreference(final Context context, final AttributeSet attrs,
                                final int defStyle) {
        super(context, attrs, defStyle);
        initialize();
    }

    /**
     * Initialize this preference
     */
    private void initialize() {
        setPersistent(true);
    }

    /*
     * (non-Javadoc)
     *
     * @see android.preference.DialogPreference#onCreateDialogView()
     */
    @Override
    protected View onCreateDialogView() {

        TimePicker tp = new TimePicker(getContext());
        tp.setIs24HourView(DateFormat.is24HourFormat(getContext()));
        tp.setOnTimeChangedListener(this);
        originalHour = getHour();
        originalMinute = getMinute();
        if (originalHour >= 0 && originalMinute >= 0) {
            tp.setCurrentHour(originalHour);
            tp.setCurrentMinute(originalMinute);
        }

        return tp;
    }

    /**
     * @see
     * android.widget.TimePicker.OnTimeChangedListener#onTimeChanged(android
     * .widget.TimePicker, int, int)
     */
    @Override
    public void onTimeChanged(final TimePicker view, final int hour, final int minute) {

        persistString(String.format(""%02d:%02d"", hour, minute));
        callChangeListener(String.format(""%02d:%02d"", hour, minute));
    }

    /**
     * If not a positive result, restore the original value
     * before going to super.onDialogClosed(positiveResult).
     */
    @Override
    protected void onDialogClosed(boolean positiveResult) {

        if (!positiveResult) {
            persistString(String.format(""%02d:%02d"", originalHour, originalMinute));
            callChangeListener(String.format(""%02d:%02d"", originalHour, originalMinute));
        }
        super.onDialogClosed(positiveResult);
    }

    /**
     * @see android.preference.Preference#setDefaultValue(java.lang.Object)
     */
    @Override
    public void setDefaultValue(final Object defaultValue) {
        // BUG this method is never called if you use the 'android:defaultValue' attribute in your XML preference file, not sure why it isn't

        super.setDefaultValue(defaultValue);

        if (!(defaultValue instanceof String)) {
            return;
        }

        if (!((String) defaultValue).matches(VALIDATION_EXPRESSION)) {
            return;
        }

        this.defaultValue = (String) defaultValue;
    }

    /**
     * Get the hour value (in 24 hour time)
     *
     * @return The hour value, will be 0 to 23 (inclusive) or -1 if illegal
     */
    private int getHour() {
        String time = getTime();
        if (time == null || !time.matches(VALIDATION_EXPRESSION)) {
            return -1;
        }

        return Integer.valueOf(time.split("":"")[0]);
    }

    /**
     * Get the minute value
     *
     * @return the minute value, will be 0 to 59 (inclusive) or -1 if illegal
     */
    private int getMinute() {
        String time = getTime();
        if (time == null || !time.matches(VALIDATION_EXPRESSION)) {
            return -1;
        }

        return Integer.valueOf(time.split("":"")[1]);
    }

    /**
     * Get the time. It is only legal, if it matches
     * {@link #VALIDATION_EXPRESSION}.
     *
     * @return the time as hh:mm
     */
    public String getTime() {
        return getPersistedString(this.defaultValue);
    }

}

",False,113,7,61,0,0,1,0,L1
157,com.fsck.k9.preferences.CheckBoxListPreference.java,"package com.fsck.k9.preferences;

import android.app.AlertDialog.Builder;
import android.content.Context;
import android.content.DialogInterface;
import android.preference.DialogPreference;
import android.util.AttributeSet;

public class CheckBoxListPreference extends DialogPreference {

    private CharSequence[] mItems;

    private boolean[] mCheckedItems;

    /**
     * checkboxes state when the dialog is displayed
     */
    private boolean[] mPendingItems;

    /**
     * @param context
     * @param attrs
     * @param defStyle
     */
    public CheckBoxListPreference(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    /**
     * @param context
     * @param attrs
     */
    public CheckBoxListPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected void onPrepareDialogBuilder(final Builder builder) {
        mPendingItems = new boolean[mItems.length];

        System.arraycopy(mCheckedItems, 0, mPendingItems, 0, mCheckedItems.length);

        builder.setMultiChoiceItems(mItems, mPendingItems,
        new DialogInterface.OnMultiChoiceClickListener() {
            @Override
            public void onClick(final DialogInterface dialog, final int which,
            final boolean isChecked) {
                mPendingItems[which] = isChecked;
            }
        });
    }

    @Override
    protected void onDialogClosed(boolean positiveResult) {
        if (positiveResult) {
            System.arraycopy(mPendingItems, 0, mCheckedItems, 0, mPendingItems.length);
        }
        mPendingItems = null;
    }

    public void setItems(final CharSequence[] items) {
        mItems = items;
    }

    public void setCheckedItems(final boolean[] items) {
        mCheckedItems = items;
    }

    public boolean[] getCheckedItems() {
        return mCheckedItems;
    }

}
",False,113,7,61,0,0,1,0,L1
158,com.fsck.k9.controller.MessageRetrievalListener.java,"
package com.fsck.k9.controller;

import com.fsck.k9.mail.Message;

public interface MessageRetrievalListener {
    public void messageStarted(String uid, int number, int ofTotal);

    public void messageFinished(Message message, int number, int ofTotal);

    /**
     * FIXME <strong>this method is almost never invoked by various Stores! Don't rely on it unless fixed!!</strong>
     *
     * @param total
     */
    public void messagesFinished(int total);
}
",False,144,0,0,7,43,6,1,L1
159,com.fsck.k9.controller.MessageRemovalListener.java,"package com.fsck.k9.controller;

import com.fsck.k9.mail.Message;

public interface MessageRemovalListener {
    public void messageRemoved(Message message);
}
",False,144,0,0,7,42,2,1,L1
160,com.fsck.k9.controller.MessageDateComparator.java,"
package com.fsck.k9.controller;

import java.util.Comparator;
import com.fsck.k9.mail.Message;

public class MessageDateComparator implements Comparator<Message> {
    public int compare(Message o1, Message o2) {
        try {
            if (o1.getSentDate() == null) {
                return 1;
            } else if (o2.getSentDate() == null) {
                return -1;
            } else
                return o2.getSentDate().compareTo(o1.getSentDate());
        } catch (Exception e) {
            return 0;
        }
    }
}
",True,145,0,0,7,43,0,1,L2
161,com.fsck.k9.controller.MessagingControllerPushReceiver.java,"package com.fsck.k9.controller;

import android.app.Application;
import android.content.Context;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Folder.OpenMode;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.PushReceiver;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import com.fsck.k9.service.SleepService;

import java.util.List;
import java.util.concurrent.CountDownLatch;

public class MessagingControllerPushReceiver implements PushReceiver {
    final Account account;
    final MessagingController controller;
    final Application mApplication;

    public MessagingControllerPushReceiver(Application nApplication, Account nAccount, MessagingController nController) {
        account = nAccount;
        controller = nController;
        mApplication = nApplication;
    }

    public void messagesFlagsChanged(Folder folder,
                                     List<Message> messages) {
        controller.messagesArrived(account, folder, messages, true);
    }
    public void messagesArrived(Folder folder, List<Message> messages) {
        controller.messagesArrived(account, folder, messages, false);
    }
    public void messagesRemoved(Folder folder, List<Message> messages) {
        controller.messagesArrived(account, folder, messages, true);
    }

    public void syncFolder(Folder folder) {
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""syncFolder("" + folder.getName() + "")"");
        final CountDownLatch latch = new CountDownLatch(1);
        controller.synchronizeMailbox(account, folder.getName(), new MessagingListener() {
            @Override
            public void synchronizeMailboxFinished(Account account, String folder,
            int totalMessagesInMailbox, int numNewMessages) {
                latch.countDown();
            }

            @Override
            public void synchronizeMailboxFailed(Account account, String folder,
            String message) {
                latch.countDown();
            }
        }, folder);

        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""syncFolder("" + folder.getName() + "") about to await latch release"");
        try {
            latch.await();
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""syncFolder("" + folder.getName() + "") got latch release"");
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Interrupted while awaiting latch release"", e);
        }
    }

    @Override
    public void sleep(TracingWakeLock wakeLock, long millis) {
        SleepService.sleep(mApplication, millis, wakeLock, K9.PUSH_WAKE_LOCK_TIMEOUT);
    }

    public void pushError(String errorMessage, Exception e) {
        String errMess = errorMessage;

        if (errMess == null && e != null) {
            errMess = e.getMessage();
        }
        controller.addErrorMessage(account, errMess, e);
    }

    public String getPushState(String folderName) {
        LocalFolder localFolder = null;
        try {
            LocalStore localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folderName);
            localFolder.open(OpenMode.READ_WRITE);
            return localFolder.getPushState();
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Unable to get push state from account "" + account.getDescription()
                  + "", folder "" + folderName, e);
            return null;
        } finally {
            if (localFolder != null) {
                localFolder.close();
            }
        }
    }

    public void setPushActive(String folderName, boolean enabled) {
        for (MessagingListener l : controller.getListeners()) {
            l.setPushActive(account, folderName, enabled);
        }
    }

    @Override
    public Context getContext() {
        return mApplication;
    }

}
",True,144,0,0,6,49,1,10,L1
162,com.fsck.k9.controller.MessagingController.java,"
package com.fsck.k9.controller;

import java.io.CharArrayWriter;
import java.io.PrintWriter;
import java.util.*;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import android.app.Application;
import android.app.KeyguardManager;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.media.AudioManager;
import android.net.Uri;
import android.os.PowerManager;
import android.os.Process;
import android.text.TextUtils;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.AccountStats;
import com.fsck.k9.K9;
import com.fsck.k9.NotificationSetting;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.SearchSpecification;
import com.fsck.k9.K9.Intents;
import com.fsck.k9.activity.FolderList;
import com.fsck.k9.activity.MessageList;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.helper.power.TracingPowerManager;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.FetchProfile;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Folder.FolderType;
import com.fsck.k9.mail.Folder.OpenMode;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Part;
import com.fsck.k9.mail.PushReceiver;
import com.fsck.k9.mail.Pusher;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.Transport;
import com.fsck.k9.mail.internet.MimeMessage;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.internet.TextBody;
import com.fsck.k9.mail.store.UnavailableAccountException;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.UnavailableStorageException;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import com.fsck.k9.mail.store.LocalStore.LocalMessage;
import com.fsck.k9.mail.store.LocalStore.PendingCommand;


/**
 * Starts a long running (application) Thread that will run through commands
 * that require remote mailbox access. This class is used to serialize and
 * prioritize these commands. Each method that will submit a command requires a
 * MessagingListener instance to be provided. It is expected that that listener
 * has also been added as a registered listener using addListener(). When a
 * command is to be executed, if the listener that was provided with the command
 * is no longer registered the command is skipped. The design idea for the above
 * is that when an Activity starts it registers as a listener. When it is paused
 * it removes itself. Thus, any commands that that activity submitted are
 * removed from the queue once the activity is no longer active.
 */
public class MessagingController implements Runnable {

    /**
     * Immutable empty {@link String} array
     */
    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    /**
     * Immutable empty {@link Message} array
     */
    private static final Message[] EMPTY_MESSAGE_ARRAY = new Message[0];

    /**
     * Immutable empty {@link Folder} array
     */
    private static final Folder[] EMPTY_FOLDER_ARRAY = new Folder[0];

    /**
     * The maximum message size that we'll consider to be ""small"". A small message is downloaded
     * in full immediately instead of in pieces. Anything over this size will be downloaded in
     * pieces with attachments being left off completely and downloaded on demand.
     *
     *
     * 25k for a ""small"" message was picked by educated trial and error.
     * http://answers.google.com/answers/threadview?id=312463 claims that the
     * average size of an email is 59k, which I feel is too large for our
     * blind download. The following tests were performed on a download of
     * 25 random messages.
     * <pre>
     * 5k - 61 seconds,
     * 25k - 51 seconds,
     * 55k - 53 seconds,
     * </pre>
     * So 25k gives good performance and a reasonable data footprint. Sounds good to me.
     */

    private static final String PENDING_COMMAND_MOVE_OR_COPY = ""com.fsck.k9.MessagingController.moveOrCopy"";
    private static final String PENDING_COMMAND_MOVE_OR_COPY_BULK = ""com.fsck.k9.MessagingController.moveOrCopyBulk"";
    private static final String PENDING_COMMAND_EMPTY_TRASH = ""com.fsck.k9.MessagingController.emptyTrash"";
    private static final String PENDING_COMMAND_SET_FLAG_BULK = ""com.fsck.k9.MessagingController.setFlagBulk"";
    private static final String PENDING_COMMAND_SET_FLAG = ""com.fsck.k9.MessagingController.setFlag"";
    private static final String PENDING_COMMAND_APPEND = ""com.fsck.k9.MessagingController.append"";
    private static final String PENDING_COMMAND_MARK_ALL_AS_READ = ""com.fsck.k9.MessagingController.markAllAsRead"";
    private static final String PENDING_COMMAND_EXPUNGE = ""com.fsck.k9.MessagingController.expunge"";

    /**
     * Maximum number of unsynced messages to store at once
     */
    private static final int UNSYNC_CHUNK_SIZE = 5;

    private static MessagingController inst = null;
    private BlockingQueue<Command> mCommands = new PriorityBlockingQueue<Command>();

    private Thread mThread;
    private Set<MessagingListener> mListeners = new CopyOnWriteArraySet<MessagingListener>();

    private HashMap<SORT_TYPE, Boolean> sortAscending = new HashMap<SORT_TYPE, Boolean>();

    private final ConcurrentHashMap<String, AtomicInteger> sendCount = new ConcurrentHashMap<String, AtomicInteger>();

    ConcurrentHashMap<Account, Pusher> pushers = new ConcurrentHashMap<Account, Pusher>();

    private final ExecutorService threadPool = Executors.newCachedThreadPool();

    public enum SORT_TYPE {
        SORT_DATE(R.string.sort_earliest_first, R.string.sort_latest_first, false),
        SORT_SUBJECT(R.string.sort_subject_alpha, R.string.sort_subject_re_alpha, true),
        SORT_SENDER(R.string.sort_sender_alpha, R.string.sort_sender_re_alpha, true),
        SORT_UNREAD(R.string.sort_unread_first, R.string.sort_unread_last, true),
        SORT_FLAGGED(R.string.sort_flagged_first, R.string.sort_flagged_last, true),
        SORT_ATTACHMENT(R.string.sort_attach_first, R.string.sort_unattached_first, true);

        private int ascendingToast;
        private int descendingToast;
        private boolean defaultAscending;

        SORT_TYPE(int ascending, int descending, boolean ndefaultAscending) {
            ascendingToast = ascending;
            descendingToast = descending;
            defaultAscending = ndefaultAscending;
        }

        public int getToast(boolean ascending) {
            if (ascending) {
                return ascendingToast;
            } else {
                return descendingToast;
            }
        }
        public boolean isDefaultAscending() {
            return defaultAscending;
        }
    }

    private SORT_TYPE sortType = SORT_TYPE.SORT_DATE;

    private MessagingListener checkMailListener = null;

    private MemorizingListener memorizingListener = new MemorizingListener();

    private boolean mBusy;

    /**
     *  {@link K9}
     */
    private Application mApplication;

    // Key is accountUuid:folderName:messageUid   ,   value is unimportant
    private ConcurrentHashMap<String, String> deletedUids = new ConcurrentHashMap<String, String>();

    private String createMessageKey(Account account, String folder, Message message) {
        return createMessageKey(account, folder, message.getUid());
    }

    private String createMessageKey(Account account, String folder, String uid) {
        return account.getUuid() + "":"" + folder + "":"" + uid;
    }

    private void suppressMessage(Account account, String folder, Message message) {

        if (account == null || folder == null || message == null) {
            return;
        }
        String messKey = createMessageKey(account, folder, message);
        deletedUids.put(messKey, ""true"");
    }

    private void unsuppressMessage(Account account, String folder, String uid) {
        if (account == null || folder == null || uid == null) {
            return;
        }
        String messKey = createMessageKey(account, folder, uid);
        deletedUids.remove(messKey);
    }


    private boolean isMessageSuppressed(Account account, String folder, Message message) {
        if (account == null || folder == null || message == null) {
            return false;
        }
        String messKey = createMessageKey(account, folder, message);

        if (deletedUids.containsKey(messKey)) {
            return true;
        }

        return false;
    }

    /**
     * @param application  {@link K9}
     */
    private MessagingController(Application application) {
        mApplication = application;
        mThread = new Thread(this);
        mThread.setName(""MessagingController"");
        mThread.start();
        if (memorizingListener != null) {
            addListener(memorizingListener);
        }
    }

    /**
     * Gets or creates the singleton instance of MessagingController. Application is used to
     * provide a Context to classes that need it.
     * @param application {@link K9}
     * @return
     */
    public synchronized static MessagingController getInstance(Application application) {
        if (inst == null) {
            inst = new MessagingController(application);
        }
        return inst;
    }

    public boolean isBusy() {
        return mBusy;
    }

    @Override
    public void run() {
        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
        while (true) {
            String commandDescription = null;
            try {
                final Command command = mCommands.take();

                if (command != null) {
                    commandDescription = command.description;

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Running "" + (command.isForeground ? ""Foreground"" : ""Background"") + "" command '"" + command.description + ""', seq = "" + command.sequence);

                    mBusy = true;
                    try {
                        command.runnable.run();
                    } catch (UnavailableAccountException e) {
                        // retry later
                        new Thread() {
                            @Override
                            public void run() {
                                try {
                                    sleep(30 * 1000);
                                    mCommands.put(command);
                                } catch (InterruptedException e) {
                                    Log.e(K9.LOG_TAG, ""interrupted while putting a pending command for""
                                          + "" an unavailable account back into the queue.""
                                          + "" THIS SHOULD NEVER HAPPEN."");
                                }
                            }
                        } .start();
                    }

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, (command.isForeground ? ""Foreground"" : ""Background"") +
                              "" Command '"" + command.description + ""' completed"");

                    for (MessagingListener l : getListeners(command.listener)) {
                        l.controllerCommandCompleted(mCommands.size() > 0);
                    }
                }
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, ""Error running command '"" + commandDescription + ""'"", e);
            }
            mBusy = false;
        }
    }

    private void put(String description, MessagingListener listener, Runnable runnable) {
        putCommand(mCommands, description, listener, runnable, true);
    }

    private void putBackground(String description, MessagingListener listener, Runnable runnable) {
        putCommand(mCommands, description, listener, runnable, false);
    }

    private void putCommand(BlockingQueue<Command> queue, String description, MessagingListener listener, Runnable runnable, boolean isForeground) {
        int retries = 10;
        Exception e = null;
        while (retries-- > 0) {
            try {
                Command command = new Command();
                command.listener = listener;
                command.runnable = runnable;
                command.description = description;
                command.isForeground = isForeground;
                queue.put(command);
                return;
            } catch (InterruptedException ie) {
                try {
                    Thread.sleep(200);
                } catch (InterruptedException ne) {
                }
                e = ie;
            }
        }
        throw new Error(e);
    }


    public void addListener(MessagingListener listener) {
        mListeners.add(listener);
        refreshListener(listener);
    }

    public void refreshListener(MessagingListener listener) {
        if (memorizingListener != null && listener != null) {
            memorizingListener.refreshOther(listener);
        }
    }

    public void removeListener(MessagingListener listener) {
        mListeners.remove(listener);
    }

    public Set<MessagingListener> getListeners() {
        return mListeners;
    }


    public Set<MessagingListener> getListeners(MessagingListener listener) {
        if (listener == null) {
            return mListeners;
        }

        Set<MessagingListener> listeners = new HashSet<MessagingListener>(mListeners);
        listeners.add(listener);
        return listeners;

    }


    /**
     * Lists folders that are available locally and remotely. This method calls
     * listFoldersCallback for local folders before it returns, and then for
     * remote folders at some later point. If there are no local folders
     * includeRemote is forced by this method. This method should be called from
     * a Thread as it may take several seconds to list the local folders.
     * TODO this needs to cache the remote folder list
     *
     * @param account
     * @param listener
     * @throws MessagingException
     */
    public void listFolders(final Account account, final boolean refreshRemote, final MessagingListener listener) {
        threadPool.execute(new Runnable() {
            @Override
            public void run() {
                listFoldersSynchronous(account, refreshRemote, listener);
            }
        });
    }

    /**
     * Lists folders that are available locally and remotely. This method calls
     * listFoldersCallback for local folders before it returns, and then for
     * remote folders at some later point. If there are no local folders
     * includeRemote is forced by this method. This method is called in the
     * foreground.
     * TODO this needs to cache the remote folder list
     *
     * @param account
     * @param listener
     * @throws MessagingException
     */
    public void listFoldersSynchronous(final Account account, final boolean refreshRemote, final MessagingListener listener) {
        for (MessagingListener l : getListeners(listener)) {
            l.listFoldersStarted(account);
        }
        List <? extends Folder > localFolders = null;
        if (!account.isAvailable(mApplication)) {
            Log.i(K9.LOG_TAG, ""not listing folders of unavailable account"");
        } else {
            try {
                Store localStore = account.getLocalStore();
                localFolders = localStore.getPersonalNamespaces(false);

                Folder[] folderArray = localFolders.toArray(EMPTY_FOLDER_ARRAY);

                if (refreshRemote || localFolders.size() == 0) {
                    doRefreshRemote(account, listener);
                    return;
                }

                for (MessagingListener l : getListeners(listener)) {
                    l.listFolders(account, folderArray);
                }
            } catch (Exception e) {
                for (MessagingListener l : getListeners(listener)) {
                    l.listFoldersFailed(account, e.getMessage());
                }

                addErrorMessage(account, null, e);
                return;
            } finally {
                if (localFolders != null) {
                    for (Folder localFolder : localFolders) {
                        closeFolder(localFolder);
                    }
                }
            }
        }

        for (MessagingListener l : getListeners(listener)) {
            l.listFoldersFinished(account);
        }
    }

    private void doRefreshRemote(final Account account, MessagingListener listener) {
        put(""doRefreshRemote"", listener, new Runnable() {
            @Override
            public void run() {
                List <? extends Folder > localFolders = null;
                try {
                    Store store = account.getRemoteStore();

                    List <? extends Folder > remoteFolders = store.getPersonalNamespaces(false);

                    LocalStore localStore = account.getLocalStore();
                    HashSet<String> remoteFolderNames = new HashSet<String>();
                    List<LocalFolder> foldersToCreate = new LinkedList<LocalFolder>();

                    localFolders = localStore.getPersonalNamespaces(false);
                    HashSet<String> localFolderNames = new HashSet<String>();
                    for (Folder localFolder : localFolders) {
                        localFolderNames.add(localFolder.getName());
                    }
                    for (Folder remoteFolder : remoteFolders) {
                        if (localFolderNames.contains(remoteFolder.getName()) == false) {
                            LocalFolder localFolder = localStore.getFolder(remoteFolder.getName());
                            foldersToCreate.add(localFolder);
                        }
                        remoteFolderNames.add(remoteFolder.getName());
                    }
                    localStore.createFolders(foldersToCreate, account.getDisplayCount());

                    localFolders = localStore.getPersonalNamespaces(false);

                    /*
                     * Clear out any folders that are no longer on the remote store.
                     */
                    for (Folder localFolder : localFolders) {
                        String localFolderName = localFolder.getName();
                        if (!account.isSpecialFolder(localFolderName) && !remoteFolderNames.contains(localFolderName)) {
                            localFolder.delete(false);
                        }
                    }

                    localFolders = localStore.getPersonalNamespaces(false);
                    Folder[] folderArray = localFolders.toArray(EMPTY_FOLDER_ARRAY);

                    for (MessagingListener l : getListeners()) {
                        l.listFolders(account, folderArray);
                    }
                    for (MessagingListener l : getListeners()) {
                        l.listFoldersFinished(account);
                    }
                } catch (Exception e) {
                    for (MessagingListener l : getListeners()) {
                        l.listFoldersFailed(account, """");
                    }
                    addErrorMessage(account, null, e);
                } finally {
                    if (localFolders != null) {
                        for (Folder localFolder : localFolders) {
                            closeFolder(localFolder);
                        }
                    }
                }
            }
        });
    }



    /**
     * List the messages in the local message store for the given folder asynchronously.
     *
     * @param account
     * @param folder
     * @param listener
     * @throws MessagingException
     */
    public void listLocalMessages(final Account account, final String folder, final MessagingListener listener) {
        threadPool.execute(new Runnable() {
            @Override
            public void run() {
                listLocalMessagesSynchronous(account, folder, listener);
            }
        });
    }


    /**
     * List the messages in the local message store for the given folder synchronously.
     *
     * @param account
     * @param folder
     * @param listener
     * @throws MessagingException
     */
    public void listLocalMessagesSynchronous(final Account account, final String folder, final MessagingListener listener) {

        for (MessagingListener l : getListeners(listener)) {
            l.listLocalMessagesStarted(account, folder);
        }

        Folder localFolder = null;
        MessageRetrievalListener retrievalListener =
        new MessageRetrievalListener() {
            List<Message> pendingMessages = new ArrayList<Message>();


            int totalDone = 0;


            @Override
            public void messageStarted(String message, int number, int ofTotal) {}
            @Override
            public void messageFinished(Message message, int number, int ofTotal) {

                if (!isMessageSuppressed(account, folder, message)) {
                    pendingMessages.add(message);
                    totalDone++;
                    if (pendingMessages.size() > 10) {
                        addPendingMessages();
                    }

                } else {
                    for (MessagingListener l : getListeners(listener)) {
                        l.listLocalMessagesRemoveMessage(account, folder, message);
                    }
                }
            }
            @Override
            public void messagesFinished(int number) {
                addPendingMessages();
            }
            private void addPendingMessages() {
                for (MessagingListener l : getListeners(listener)) {
                    l.listLocalMessagesAddMessages(account, folder, pendingMessages);
                }
                pendingMessages.clear();
            }
        };



        try {
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folder);
            localFolder.open(OpenMode.READ_WRITE);

            localFolder.getMessages(
                retrievalListener,
                false // Skip deleted messages
            );
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""Got ack that callbackRunner finished"");

            for (MessagingListener l : getListeners(listener)) {
                l.listLocalMessagesFinished(account, folder);
            }
        } catch (Exception e) {
            for (MessagingListener l : getListeners(listener)) {
                l.listLocalMessagesFailed(account, folder, e.getMessage());
            }
            addErrorMessage(account, null, e);
        } finally {
            closeFolder(localFolder);
        }
    }

    public void searchLocalMessages(SearchSpecification searchSpecification, final Message[] messages, final MessagingListener listener) {
        searchLocalMessages(searchSpecification.getAccountUuids(), searchSpecification.getFolderNames(), messages,
                            searchSpecification.getQuery(), searchSpecification.isIntegrate(), searchSpecification.getRequiredFlags(), searchSpecification.getForbiddenFlags(), listener);
    }


    /**
     * Find all messages in any local account which match the query 'query'
     * @throws MessagingException
     */
    public void searchLocalMessages(final String[] accountUuids, final String[] folderNames, final Message[] messages, final String query, final boolean integrate,
                                    final Flag[] requiredFlags, final Flag[] forbiddenFlags, final MessagingListener listener) {
        if (K9.DEBUG) {
            Log.i(K9.LOG_TAG, ""searchLocalMessages (""
                  + ""accountUuids="" + Utility.combine(accountUuids, ',')
                  + "", folderNames = "" + Utility.combine(folderNames, ',')
                  + "", messages.size() = "" + (messages != null ? messages.length : null)
                  + "", query = "" + query
                  + "", integrate = "" + integrate
                  + "", requiredFlags = "" + Utility.combine(requiredFlags, ',')
                  + "", forbiddenFlags = "" + Utility.combine(forbiddenFlags, ',')
                  + "")"");
        }

        threadPool.execute(new Runnable() {
            @Override
            public void run() {
                searchLocalMessagesSynchronous(accountUuids, folderNames, messages,  query, integrate, requiredFlags, forbiddenFlags, listener);
            }
        });
    }
    public void searchLocalMessagesSynchronous(final String[] accountUuids, final String[] folderNames, final Message[] messages, final String query, final boolean integrate, final Flag[] requiredFlags, final Flag[] forbiddenFlags, final MessagingListener listener) {

        final AccountStats stats = new AccountStats();
        final Set<String> accountUuidsSet = new HashSet<String>();
        if (accountUuids != null) {
            accountUuidsSet.addAll(Arrays.asList(accountUuids));
        }
        final Preferences prefs = Preferences.getPreferences(mApplication.getApplicationContext());
        Account[] accounts = prefs.getAccounts();
        List<LocalFolder> foldersToSearch = null;
        boolean displayableOnly = false;
        boolean noSpecialFolders = true;
        for (final Account account : accounts) {
            if (!account.isAvailable(mApplication)) {
                Log.d(K9.LOG_TAG, ""searchLocalMessagesSynchronous() ignores account that is not available"");
                continue;
            }
            if (accountUuids != null && !accountUuidsSet.contains(account.getUuid())) {
                continue;
            }

            if (accountUuids != null && accountUuidsSet.contains(account.getUuid())) {
                displayableOnly = true;
                noSpecialFolders = true;
            } else if (!integrate && folderNames == null) {
                Account.Searchable searchableFolders = account.getSearchableFolders();
                switch (searchableFolders) {
                case NONE:
                    continue;
                case DISPLAYABLE:
                    displayableOnly = true;
                    break;

                }
            }
            List<Message> messagesToSearch = null;
            if (messages != null) {
                messagesToSearch = new LinkedList<Message>();
                for (Message message : messages) {
                    if (message.getFolder().getAccount().getUuid().equals(account.getUuid())) {
                        messagesToSearch.add(message);
                    }
                }
                if (messagesToSearch.isEmpty()) {
                    continue;
                }
            }
            if (listener != null) {
                listener.listLocalMessagesStarted(account, null);
            }

            if (integrate || displayableOnly || folderNames != null || noSpecialFolders) {
                List<LocalFolder> tmpFoldersToSearch = new LinkedList<LocalFolder>();
                try {
                    LocalStore store = account.getLocalStore();
                    List <? extends Folder > folders = store.getPersonalNamespaces(false);
                    Set<String> folderNameSet = null;
                    if (folderNames != null) {
                        folderNameSet = new HashSet<String>();
                        folderNameSet.addAll(Arrays.asList(folderNames));
                    }
                    for (Folder folder : folders) {
                        LocalFolder localFolder = (LocalFolder)folder;
                        boolean include = true;
                        folder.refresh(prefs);
                        String localFolderName = localFolder.getName();
                        if (integrate) {
                            include = localFolder.isIntegrate();
                        } else {
                            if (folderNameSet != null) {
                                if (!folderNameSet.contains(localFolderName))

                                {
                                    include = false;
                                }
                            }
                            // Never exclude the INBOX (see issue 1817)
                            else if (noSpecialFolders && !localFolderName.equalsIgnoreCase(account.getInboxFolderName()) &&
                                     !localFolderName.equals(account.getArchiveFolderName()) && account.isSpecialFolder(localFolderName)) {
                                include = false;
                            } else if (displayableOnly && modeMismatch(account.getFolderDisplayMode(), folder.getDisplayClass())) {
                                include = false;
                            }
                        }

                        if (include) {
                            tmpFoldersToSearch.add(localFolder);
                        }
                    }
                    if (tmpFoldersToSearch.size() < 1) {
                        continue;
                    }
                    foldersToSearch = tmpFoldersToSearch;
                } catch (MessagingException me) {
                    Log.e(K9.LOG_TAG, ""Unable to restrict search folders in Account "" + account.getDescription() + "", searching all"", me);
                    addErrorMessage(account, null, me);
                }

            }

            MessageRetrievalListener retrievalListener = new MessageRetrievalListener() {
                @Override
                public void messageStarted(String message, int number, int ofTotal) {}
                @Override
                public void messageFinished(Message message, int number, int ofTotal) {
                    if (!isMessageSuppressed(message.getFolder().getAccount(), message.getFolder().getName(), message)) {
                        List<Message> messages = new ArrayList<Message>();

                        messages.add(message);
                        stats.unreadMessageCount += (!message.isSet(Flag.SEEN)) ? 1 : 0;
                        stats.flaggedMessageCount += (message.isSet(Flag.FLAGGED)) ? 1 : 0;
                        if (listener != null) {
                            listener.listLocalMessagesAddMessages(account, null, messages);
                        }
                    }

                }
                @Override
                public void messagesFinished(int number) {

                }
            };

            try {
                String[] queryFields = {""html_content"", ""subject"", ""sender_list""};
                LocalStore localStore = account.getLocalStore();
                localStore.searchForMessages(retrievalListener, queryFields
                                             , query, foldersToSearch,
                                             messagesToSearch == null ? null : messagesToSearch.toArray(EMPTY_MESSAGE_ARRAY),
                                             requiredFlags, forbiddenFlags);

            } catch (Exception e) {
                if (listener != null) {
                    listener.listLocalMessagesFailed(account, null, e.getMessage());
                }
                addErrorMessage(account, null, e);
            } finally {
                if (listener != null) {
                    listener.listLocalMessagesFinished(account, null);
                }
            }
        }
        if (listener != null) {
            listener.searchStats(stats);
        }
    }
    public void loadMoreMessages(Account account, String folder, MessagingListener listener) {
        try {
            LocalStore localStore = account.getLocalStore();
            LocalFolder localFolder = localStore.getFolder(folder);
            if (localFolder.getVisibleLimit() > 0) {
                localFolder.setVisibleLimit(localFolder.getVisibleLimit() + localFolder.getMessageCount());
            }
            synchronizeMailbox(account, folder, listener, null);
        } catch (MessagingException me) {
            addErrorMessage(account, null, me);

            throw new RuntimeException(""Unable to set visible limit on folder"", me);
        }
    }

    public void resetVisibleLimits(Collection<Account> accounts) {
        for (Account account : accounts) {
            account.resetVisibleLimits();
        }
    }

    /**
     * Start background synchronization of the specified folder.
     * @param account
     * @param folder
     * @param listener
     * @param providedRemoteFolder TODO
     */
    public void synchronizeMailbox(final Account account, final String folder, final MessagingListener listener, final Folder providedRemoteFolder) {
        putBackground(""synchronizeMailbox"", listener, new Runnable() {
            @Override
            public void run() {
                synchronizeMailboxSynchronous(account, folder, listener, providedRemoteFolder);
            }
        });
    }

    /**
     * Start foreground synchronization of the specified folder. This is generally only called
     * by synchronizeMailbox.
     * @param account
     * @param folder
     *
     * TODO Break this method up into smaller chunks.
     * @param providedRemoteFolder TODO
     */
    private void synchronizeMailboxSynchronous(final Account account, final String folder, final MessagingListener listener, Folder providedRemoteFolder) {
        Folder remoteFolder = null;
        LocalFolder tLocalFolder = null;

        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Synchronizing folder "" + account.getDescription() + "":"" + folder);

        for (MessagingListener l : getListeners(listener)) {
            l.synchronizeMailboxStarted(account, folder);
        }
        /*
         * We don't ever sync the Outbox or errors folder
         */
        if (folder.equals(account.getOutboxFolderName()) || folder.equals(account.getErrorFolderName())) {
            for (MessagingListener l : getListeners(listener)) {
                l.synchronizeMailboxFinished(account, folder, 0, 0);
            }

            return;
        }

        Exception commandException = null;
        try {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""SYNC: About to process pending commands for account "" + account.getDescription());

            try {
                processPendingCommandsSynchronous(account);
            } catch (Exception e) {
                addErrorMessage(account, null, e);

                Log.e(K9.LOG_TAG, ""Failure processing command, but allow message sync attempt"", e);
                commandException = e;
            }

            /*
             * Get the message list from the local store and create an index of
             * the uids within the list.
             */
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""SYNC: About to get local folder "" + folder);

            final LocalStore localStore = account.getLocalStore();
            tLocalFolder = localStore.getFolder(folder);
            final LocalFolder localFolder = tLocalFolder;
            localFolder.open(OpenMode.READ_WRITE);
            localFolder.updateLastUid();
            Message[] localMessages = localFolder.getMessages(null);
            HashMap<String, Message> localUidMap = new HashMap<String, Message>();
            for (Message message : localMessages) {
                localUidMap.put(message.getUid(), message);
            }

            if (providedRemoteFolder != null) {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""SYNC: using providedRemoteFolder "" + folder);
                remoteFolder = providedRemoteFolder;
            } else {
                Store remoteStore = account.getRemoteStore();

                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""SYNC: About to get remote folder "" + folder);
                remoteFolder = remoteStore.getFolder(folder);

                if (! verifyOrCreateRemoteSpecialFolder(account, folder, remoteFolder, listener)) {
                    return;
                }


                /*
                 * Synchronization process:
                 *
                Open the folder
                Upload any local messages that are marked as PENDING_UPLOAD (Drafts, Sent, Trash)
                Get the message count
                Get the list of the newest K9.DEFAULT_VISIBLE_LIMIT messages
                getMessages(messageCount - K9.DEFAULT_VISIBLE_LIMIT, messageCount)
                See if we have each message locally, if not fetch it's flags and envelope
                Get and update the unread count for the folder
                Update the remote flags of any messages we have locally with an internal date newer than the remote message.
                Get the current flags for any messages we have locally but did not just download
                Update local flags
                For any message we have locally but not remotely, delete the local message to keep cache clean.
                Download larger parts of any new messages.
                (Optional) Download small attachments in the background.
                 */

                /*
                 * Open the remote folder. This pre-loads certain metadata like message count.
                 */
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""SYNC: About to open remote folder "" + folder);

                remoteFolder.open(OpenMode.READ_WRITE);
                if (Account.EXPUNGE_ON_POLL.equals(account.getExpungePolicy())) {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""SYNC: Expunging folder "" + account.getDescription() + "":"" + folder);
                    remoteFolder.expunge();
                }

            }

            /*
             * Get the remote message count.
             */
            int remoteMessageCount = remoteFolder.getMessageCount();

            int visibleLimit = localFolder.getVisibleLimit();

            if (visibleLimit < 0) {
                visibleLimit = K9.DEFAULT_VISIBLE_LIMIT;
            }

            Message[] remoteMessageArray = EMPTY_MESSAGE_ARRAY;
            final ArrayList<Message> remoteMessages = new ArrayList<Message>();
            HashMap<String, Message> remoteUidMap = new HashMap<String, Message>();

            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""SYNC: Remote message count for folder "" + folder + "" is "" + remoteMessageCount);
            final Date earliestDate = account.getEarliestPollDate();


            if (remoteMessageCount > 0) {
                /* Message numbers start at 1.  */
                int remoteStart;
                if (visibleLimit > 0) {
                    remoteStart = Math.max(0, remoteMessageCount - visibleLimit) + 1;
                } else {
                    remoteStart = 1;
                }
                int remoteEnd = remoteMessageCount;

                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""SYNC: About to get messages "" + remoteStart + "" through "" + remoteEnd + "" for folder "" + folder);

                final AtomicInteger headerProgress = new AtomicInteger(0);
                for (MessagingListener l : getListeners(listener)) {
                    l.synchronizeMailboxHeadersStarted(account, folder);
                }


                remoteMessageArray = remoteFolder.getMessages(remoteStart, remoteEnd, earliestDate, null);

                int messageCount = remoteMessageArray.length;

                for (Message thisMess : remoteMessageArray) {
                    headerProgress.incrementAndGet();
                    for (MessagingListener l : getListeners(listener)) {
                        l.synchronizeMailboxHeadersProgress(account, folder, headerProgress.get(), messageCount);
                    }
                    Message localMessage = localUidMap.get(thisMess.getUid());
                    if (localMessage == null || !localMessage.olderThan(earliestDate)) {
                        remoteMessages.add(thisMess);
                        remoteUidMap.put(thisMess.getUid(), thisMess);
                    }
                }
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""SYNC: Got "" + remoteUidMap.size() + "" messages for folder "" + folder);

                remoteMessageArray = null;
                for (MessagingListener l : getListeners(listener)) {
                    l.synchronizeMailboxHeadersFinished(account, folder, headerProgress.get(), remoteUidMap.size());
                }

            } else if (remoteMessageCount < 0) {
                throw new Exception(""Message count "" + remoteMessageCount + "" for folder "" + folder);
            }

            /*
             * Remove any messages that are in the local store but no longer on the remote store or are too old
             */
            if (account.syncRemoteDeletions()) {
                ArrayList<Message> destroyMessages = new ArrayList<Message>();
                for (Message localMessage : localMessages) {
                    if (remoteUidMap.get(localMessage.getUid()) == null) {
                        destroyMessages.add(localMessage);
                    }
                }


                localFolder.destroyMessages(destroyMessages.toArray(EMPTY_MESSAGE_ARRAY));

                for (Message destroyMessage : destroyMessages) {
                    for (MessagingListener l : getListeners(listener)) {
                        l.synchronizeMailboxRemovedMessage(account, folder, destroyMessage);
                    }
                }
            }
            localMessages = null;

            /*
             * Now we download the actual content of messages.
             */
            int newMessages = downloadMessages(account, remoteFolder, localFolder, remoteMessages, false);

            int unreadMessageCount = setLocalUnreadCountToRemote(localFolder, remoteFolder,  newMessages);
            setLocalFlaggedCountToRemote(localFolder, remoteFolder);


            for (MessagingListener l : getListeners()) {
                l.folderStatusChanged(account, folder, unreadMessageCount);
            }

            /* Notify listeners that we're finally done. */

            localFolder.setLastChecked(System.currentTimeMillis());
            localFolder.setStatus(null);

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Done synchronizing folder "" + account.getDescription() + "":"" + folder +
                      "" @ "" + new Date() + "" with "" + newMessages + "" new messages"");

            for (MessagingListener l : getListeners(listener)) {
                l.synchronizeMailboxFinished(account, folder, remoteMessageCount, newMessages);
            }


            if (commandException != null) {
                String rootMessage = getRootCauseMessage(commandException);
                Log.e(K9.LOG_TAG, ""Root cause failure in "" + account.getDescription() + "":"" +
                      tLocalFolder.getName() + "" was '"" + rootMessage + ""'"");
                localFolder.setStatus(rootMessage);
                for (MessagingListener l : getListeners(listener)) {
                    l.synchronizeMailboxFailed(account, folder, rootMessage);
                }
            }

            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""Done synchronizing folder "" + account.getDescription() + "":"" + folder);

        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""synchronizeMailbox"", e);
            // If we don't set the last checked, it can try too often during
            // failure conditions
            String rootMessage = getRootCauseMessage(e);
            if (tLocalFolder != null) {
                try {
                    tLocalFolder.setStatus(rootMessage);
                    tLocalFolder.setLastChecked(System.currentTimeMillis());
                } catch (MessagingException me) {
                    Log.e(K9.LOG_TAG, ""Could not set last checked on folder "" + account.getDescription() + "":"" +
                          tLocalFolder.getName(), e);
                }
            }

            for (MessagingListener l : getListeners(listener)) {
                l.synchronizeMailboxFailed(account, folder, rootMessage);
            }
            addErrorMessage(account, null, e);
            Log.e(K9.LOG_TAG, ""Failed synchronizing folder "" + account.getDescription() + "":"" + folder + "" @ "" + new Date());

        } finally {
            if (providedRemoteFolder == null) {
                closeFolder(remoteFolder);
            }

            closeFolder(tLocalFolder);
        }

    }


    private void closeFolder(Folder f) {
        if (f != null) {
            f.close();
        }
    }


    /*
     * If the folder is a ""special"" folder we need to see if it exists
     * on the remote server. It if does not exist we'll try to create it. If we
     * can't create we'll abort. This will happen on every single Pop3 folder as
     * designed and on Imap folders during error conditions. This allows us
     * to treat Pop3 and Imap the same in this code.
     */
    private boolean verifyOrCreateRemoteSpecialFolder(final Account account, final String folder, final Folder remoteFolder, final MessagingListener listener) throws MessagingException {
        if (folder.equals(account.getTrashFolderName()) ||
                folder.equals(account.getSentFolderName()) ||
                folder.equals(account.getDraftsFolderName())) {
            if (!remoteFolder.exists()) {
                if (!remoteFolder.create(FolderType.HOLDS_MESSAGES)) {
                    for (MessagingListener l : getListeners(listener)) {
                        l.synchronizeMailboxFinished(account, folder, 0, 0);
                    }
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Done synchronizing folder "" + folder);

                    return false;
                }
            }
        }
        return true;
    }
    private int setLocalUnreadCountToRemote(LocalFolder localFolder, Folder remoteFolder, int newMessageCount) throws MessagingException {
        int remoteUnreadMessageCount = remoteFolder.getUnreadMessageCount();
        if (remoteUnreadMessageCount != -1) {
            localFolder.setUnreadMessageCount(remoteUnreadMessageCount);
        } else {
            int unreadCount = 0;
            Message[] messages = localFolder.getMessages(null, false);
            for (Message message : messages) {
                if (!message.isSet(Flag.SEEN) && !message.isSet(Flag.DELETED)) {
                    unreadCount++;
                }
            }
            localFolder.setUnreadMessageCount(unreadCount);
        }
        return localFolder.getUnreadMessageCount();
    }

    private void setLocalFlaggedCountToRemote(LocalFolder localFolder, Folder remoteFolder) throws MessagingException {
        int remoteFlaggedMessageCount = remoteFolder.getFlaggedMessageCount();
        if (remoteFlaggedMessageCount != -1) {
            localFolder.setFlaggedMessageCount(remoteFlaggedMessageCount);
        } else {
            int flaggedCount = 0;
            Message[] messages = localFolder.getMessages(null, false);
            for (Message message : messages) {
                if (message.isSet(Flag.FLAGGED) && !message.isSet(Flag.DELETED)) {
                    flaggedCount++;
                }
            }
            localFolder.setFlaggedMessageCount(flaggedCount);
        }
    }

    /**
     * Fetches the messages described by inputMessages from the remote store and writes them to
     * local storage.
     *
     * @param account
     *            The account the remote store belongs to.
     * @param remoteFolder
     *            The remote folder to download messages from.
     * @param localFolder
     *            The {@link LocalFolder} instance corresponding to the remote folder.
     * @param inputMessages
     *            A list of messages objects that store the UIDs of which messages to download.
     * @param flagSyncOnly
     *            Only flags will be fetched from the remote store if this is {@code true}.
     *
     * @return The number of downloaded messages that are not flagged as {@link Flag#SEEN}.
     *
     * @throws MessagingException
     */
    private int downloadMessages(final Account account, final Folder remoteFolder,
                                 final LocalFolder localFolder, List<Message> inputMessages,
                                 boolean flagSyncOnly) throws MessagingException {

        final Date earliestDate = account.getEarliestPollDate();
        Date downloadStarted = new Date(); // now

        if (earliestDate != null) {
            if (K9.DEBUG) {
                Log.d(K9.LOG_TAG, ""Only syncing messages after "" + earliestDate);
            }
        }
        final String folder = remoteFolder.getName();

        int unreadBeforeStart = 0;
        try {
            AccountStats stats = account.getStats(mApplication);
            unreadBeforeStart = stats.unreadMessageCount;

        } catch (MessagingException e) {
            Log.e(K9.LOG_TAG, ""Unable to getUnreadMessageCount for account: "" + account, e);
        }

        ArrayList<Message> syncFlagMessages = new ArrayList<Message>();
        List<Message> unsyncedMessages = new ArrayList<Message>();
        final AtomicInteger newMessages = new AtomicInteger(0);

        List<Message> messages = new ArrayList<Message>(inputMessages);

        for (Message message : messages) {
            evaluateMessageForDownload(message, folder, localFolder, remoteFolder, account, unsyncedMessages, syncFlagMessages , flagSyncOnly);
        }

        final AtomicInteger progress = new AtomicInteger(0);
        final int todo = unsyncedMessages.size() + syncFlagMessages.size();
        for (MessagingListener l : getListeners()) {
            l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
        }

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Have "" + unsyncedMessages.size() + "" unsynced messages"");

        messages.clear();
        final ArrayList<Message> largeMessages = new ArrayList<Message>();
        final ArrayList<Message> smallMessages = new ArrayList<Message>();
        if (unsyncedMessages.size() > 0) {

            /*
             * Reverse the order of the messages. Depending on the server this may get us
             * fetch results for newest to oldest. If not, no harm done.
             */
            Collections.reverse(unsyncedMessages);
            int visibleLimit = localFolder.getVisibleLimit();
            int listSize = unsyncedMessages.size();

            if ((visibleLimit > 0) && (listSize > visibleLimit)) {
                unsyncedMessages = unsyncedMessages.subList(listSize - visibleLimit, listSize);
            }

            FetchProfile fp = new FetchProfile();
            if (remoteFolder.supportsFetchingFlags()) {
                fp.add(FetchProfile.Item.FLAGS);
            }
            fp.add(FetchProfile.Item.ENVELOPE);

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""SYNC: About to fetch "" + unsyncedMessages.size() + "" unsynced messages for folder "" + folder);


            fetchUnsyncedMessages(account, remoteFolder, localFolder, unsyncedMessages, smallMessages, largeMessages, progress, todo, fp);

            // If a message didn't exist, messageFinished won't be called, but we shouldn't try again
            // If we got here, nothing failed
            for (Message message : unsyncedMessages) {
                String newPushState = remoteFolder.getNewPushState(localFolder.getPushState(), message);
                if (newPushState != null) {
                    localFolder.setPushState(newPushState);
                }
            }
            if (K9.DEBUG) {
                Log.d(K9.LOG_TAG, ""SYNC: Synced unsynced messages for folder "" + folder);
            }


        }

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Have ""
                  + largeMessages.size() + "" large messages and ""
                  + smallMessages.size() + "" small messages out of ""
                  + unsyncedMessages.size() + "" unsynced messages"");

        unsyncedMessages.clear();

        /*
         * Grab the content of the small messages first. This is going to
         * be very fast and at very worst will be a single up of a few bytes and a single
         * download of 625k.
         */
        FetchProfile fp = new FetchProfile();
        fp.add(FetchProfile.Item.BODY);
        //        fp.add(FetchProfile.Item.FLAGS);
        //        fp.add(FetchProfile.Item.ENVELOPE);

        downloadSmallMessages(account, remoteFolder, localFolder, smallMessages, progress, unreadBeforeStart, newMessages, todo, fp);
        smallMessages.clear();

        /*
         * Now do the large messages that require more round trips.
         */
        fp.clear();
        fp.add(FetchProfile.Item.STRUCTURE);
        downloadLargeMessages(account, remoteFolder, localFolder, largeMessages, progress, unreadBeforeStart,  newMessages, todo, fp);
        largeMessages.clear();

        /*
         * Refresh the flags for any messages in the local store that we didn't just
         * download.
         */

        refreshLocalMessageFlags(account, remoteFolder, localFolder, syncFlagMessages, progress, todo);

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Synced remote messages for folder "" + folder + "", "" + newMessages.get() + "" new messages"");

        localFolder.purgeToVisibleLimit(new MessageRemovalListener() {
            @Override
            public void messageRemoved(Message message) {
                for (MessagingListener l : getListeners()) {
                    l.synchronizeMailboxRemovedMessage(account, folder, message);
                }
            }

        });

        // If the oldest message seen on this sync is newer than
        // the oldest message seen on the previous sync, then
        // we want to move our high-water mark forward
        // this is all here just for pop which only syncs inbox
        // this would be a little wrong for IMAP (we'd want a folder-level pref, not an account level pref.)
        // fortunately, we just don't care.
        Long oldestMessageTime = localFolder.getOldestMessageDate();

        if (oldestMessageTime != null) {
            Date oldestExtantMessage = new Date(oldestMessageTime);
            if (oldestExtantMessage.before(downloadStarted) &&
                    oldestExtantMessage.after(new Date(account.getLatestOldMessageSeenTime()))) {
                account.setLatestOldMessageSeenTime(oldestExtantMessage.getTime());
                account.save(Preferences.getPreferences(mApplication.getApplicationContext()));
            }

        }
        return newMessages.get();
    }
    private void evaluateMessageForDownload(final Message message, final String folder,
                                            final LocalFolder localFolder,
                                            final Folder remoteFolder,
                                            final Account account,
                                            final List<Message> unsyncedMessages,
                                            final ArrayList<Message> syncFlagMessages,
                                            boolean flagSyncOnly) throws MessagingException {
        if (message.isSet(Flag.DELETED)) {
            syncFlagMessages.add(message);
            return;
        } else if (isMessageSuppressed(account, folder, message)) {
            return;
        }

        Message localMessage = localFolder.getMessage(message.getUid());

        if (localMessage == null) {
            if (!flagSyncOnly) {
                if (!message.isSet(Flag.X_DOWNLOADED_FULL) && !message.isSet(Flag.X_DOWNLOADED_PARTIAL)) {
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""Message with uid "" + message.getUid() + "" has not yet been downloaded"");

                    unsyncedMessages.add(message);
                } else {
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""Message with uid "" + message.getUid() + "" is partially or fully downloaded"");

                    // Store the updated message locally
                    localFolder.appendMessages(new Message[] { message });

                    localMessage = localFolder.getMessage(message.getUid());

                    localMessage.setFlag(Flag.X_DOWNLOADED_FULL, message.isSet(Flag.X_DOWNLOADED_FULL));
                    localMessage.setFlag(Flag.X_DOWNLOADED_PARTIAL, message.isSet(Flag.X_DOWNLOADED_PARTIAL));

                    for (MessagingListener l : getListeners()) {
                        l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                        if (!localMessage.isSet(Flag.SEEN)) {
                            l.synchronizeMailboxNewMessage(account, folder, localMessage);
                        }
                    }
                }
            }
        } else if (!localMessage.isSet(Flag.DELETED)) {
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""Message with uid "" + message.getUid() + "" is present in the local store"");

            if (!localMessage.isSet(Flag.X_DOWNLOADED_FULL) && !localMessage.isSet(Flag.X_DOWNLOADED_PARTIAL)) {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""Message with uid "" + message.getUid()
                          + "" is not downloaded, even partially; trying again"");

                unsyncedMessages.add(message);
            } else {
                String newPushState = remoteFolder.getNewPushState(localFolder.getPushState(), message);
                if (newPushState != null) {
                    localFolder.setPushState(newPushState);
                }
                syncFlagMessages.add(message);
            }
        }
    }

    private void fetchUnsyncedMessages(final Account account, final Folder remoteFolder,
                                       final LocalFolder localFolder,
                                       List<Message> unsyncedMessages,
                                       final ArrayList<Message> smallMessages,
                                       final ArrayList<Message> largeMessages,
                                       final AtomicInteger progress,
                                       final int todo,
                                       FetchProfile fp) throws MessagingException {
        final String folder = remoteFolder.getName();

        final Date earliestDate = account.getEarliestPollDate();

        /*
         * Messages to be batch written
         */
        final List<Message> chunk = new ArrayList<Message>(UNSYNC_CHUNK_SIZE);

        remoteFolder.fetch(unsyncedMessages.toArray(EMPTY_MESSAGE_ARRAY), fp,
        new MessageRetrievalListener() {
            @Override
            public void messageFinished(Message message, int number, int ofTotal) {
                try {
                    String newPushState = remoteFolder.getNewPushState(localFolder.getPushState(), message);
                    if (newPushState != null) {
                        localFolder.setPushState(newPushState);
                    }
                    if (message.isSet(Flag.DELETED) || message.olderThan(earliestDate)) {

                        if (K9.DEBUG) {
                            if (message.isSet(Flag.DELETED)) {
                                Log.v(K9.LOG_TAG, ""Newly downloaded message "" + account + "":"" + folder + "":"" + message.getUid()
                                      + "" was marked deleted on server, skipping"");
                            } else {
                                Log.d(K9.LOG_TAG, ""Newly downloaded message "" + message.getUid() + "" is older than ""
                                      + earliestDate + "", skipping"");
                            }
                        }
                        progress.incrementAndGet();
                        for (MessagingListener l : getListeners()) {
                            l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
                        }
                        return;
                    }

                    if (account.getMaximumAutoDownloadMessageSize() > 0 &&
                    message.getSize() > account.getMaximumAutoDownloadMessageSize()) {
                        largeMessages.add(message);
                    } else {
                        smallMessages.add(message);
                    }

                    // And include it in the view
                    if (message.getSubject() != null && message.getFrom() != null) {
                        /*
                         * We check to make sure that we got something worth
                         * showing (subject and from) because some protocols
                         * (POP) may not be able to give us headers for
                         * ENVELOPE, only size.
                         */
                        if (!isMessageSuppressed(account, folder, message)) {
                            // keep message for delayed storing
                            chunk.add(message);

                            if (chunk.size() >= UNSYNC_CHUNK_SIZE) {
                                writeUnsyncedMessages(chunk, localFolder, account, folder);
                                chunk.clear();
                            }
                        }
                    }
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Error while storing downloaded message."", e);
                    addErrorMessage(account, null, e);
                }
            }

            @Override
            public void messageStarted(String uid, int number, int ofTotal) {}

            @Override
            public void messagesFinished(int total) {
                // FIXME this method is almost never invoked by various Stores! Don't rely on it unless fixed!!
            }

        });
        if (chunk.size() > 0) {
            writeUnsyncedMessages(chunk, localFolder, account, folder);
            chunk.clear();
        }
    }

    /**
     * Actual storing of messages
     *
     * <br>
     * FIXME: <strong>This method should really be moved in the above MessageRetrievalListener once {@link MessageRetrievalListener#messagesFinished(int)} is properly invoked by various stores</strong>
     *
     * @param messages Never <code>null</code>.
     * @param localFolder
     * @param account
     * @param folder
     */
    private void writeUnsyncedMessages(final List<Message> messages, final LocalFolder localFolder, final Account account, final String folder) {
        if (K9.DEBUG) {
            Log.v(K9.LOG_TAG, ""Batch writing "" + Integer.toString(messages.size()) + "" messages"");
        }
        try {
            // Store the new message locally
            localFolder.appendMessages(messages.toArray(new Message[messages.size()]));

            for (final Message message : messages) {
                final Message localMessage = localFolder.getMessage(message.getUid());
                syncFlags(localMessage, message);
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""About to notify listeners that we got a new unsynced message ""
                          + account + "":"" + folder + "":"" + message.getUid());
                for (final MessagingListener l : getListeners()) {
                    l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                }
            }
        } catch (final Exception e) {
            Log.e(K9.LOG_TAG, ""Error while storing downloaded message."", e);
            addErrorMessage(account, null, e);
        }
    }


    private boolean shouldImportMessage(final Account account, final String folder, final Message message, final AtomicInteger progress, final Date earliestDate) {

        if (isMessageSuppressed(account, folder, message)) {
            if (K9.DEBUG) {
                Log.d(K9.LOG_TAG, ""Message "" + message.getUid() + "" was suppressed "" +
                      ""but just downloaded. "" +
                      ""The race condition means we wasted some bandwidth. Oh well."");
            }
            return false;

        }
        if (message.olderThan(earliestDate)) {
            if (K9.DEBUG) {
                Log.d(K9.LOG_TAG, ""Message "" + message.getUid() + "" is older than ""
                      + earliestDate + "", hence not saving"");
            }
            return false;
        }
        return true;
    }

    private void downloadSmallMessages(final Account account, final Folder remoteFolder,
                                       final LocalFolder localFolder,
                                       ArrayList<Message> smallMessages,
                                       final AtomicInteger progress,
                                       final int unreadBeforeStart,
                                       final AtomicInteger newMessages,
                                       final int todo,
                                       FetchProfile fp) throws MessagingException {
        final String folder = remoteFolder.getName();

        final Date earliestDate = account.getEarliestPollDate();

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Fetching small messages for folder "" + folder);

        remoteFolder.fetch(smallMessages.toArray(new Message[smallMessages.size()]),
        fp, new MessageRetrievalListener() {
            @Override
            public void messageFinished(final Message message, int number, int ofTotal) {
                try {

                    if (!shouldImportMessage(account, folder, message, progress, earliestDate)) {
                        progress.incrementAndGet();

                        return;
                    }

                    // Store the updated message locally
                    final Message localMessage = localFolder.storeSmallMessage(message, new Runnable() {
                        @Override
                        public void run() {
                            progress.incrementAndGet();
                        }
                    });

                    // Increment the number of ""new messages"" if the newly downloaded message is
                    // not marked as read.
                    if (!localMessage.isSet(Flag.SEEN)) {
                        newMessages.incrementAndGet();
                    }

                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""About to notify listeners that we got a new small message ""
                              + account + "":"" + folder + "":"" + message.getUid());

                    // Update the listener with what we've found
                    for (MessagingListener l : getListeners()) {
                        l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                        l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
                        if (!localMessage.isSet(Flag.SEEN)) {
                            l.synchronizeMailboxNewMessage(account, folder, localMessage);
                        }
                    }
                    // Send a notification of this message

                    if (shouldNotifyForMessage(account, localFolder, message)) {
                        notifyAccount(mApplication, account, message, unreadBeforeStart, newMessages);
                    }

                } catch (MessagingException me) {
                    addErrorMessage(account, null, me);
                    Log.e(K9.LOG_TAG, ""SYNC: fetch small messages"", me);
                }
            }

            @Override
            public void messageStarted(String uid, int number, int ofTotal) {}

            @Override
            public void messagesFinished(int total) {}
        });

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Done fetching small messages for folder "" + folder);
    }



    private void downloadLargeMessages(final Account account, final Folder remoteFolder,
                                       final LocalFolder localFolder,
                                       ArrayList<Message> largeMessages,
                                       final AtomicInteger progress,
                                       final int unreadBeforeStart,
                                       final AtomicInteger newMessages,
                                       final int todo,
                                       FetchProfile fp) throws MessagingException {
        final String folder = remoteFolder.getName();

        final Date earliestDate = account.getEarliestPollDate();

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Fetching large messages for folder "" + folder);

        remoteFolder.fetch(largeMessages.toArray(new Message[largeMessages.size()]), fp, null);
        for (Message message : largeMessages) {

            if (!shouldImportMessage(account, folder, message, progress, earliestDate)) {
                progress.incrementAndGet();
                continue;
            }

            if (message.getBody() == null) {
                /*
                 * The provider was unable to get the structure of the message, so
                 * we'll download a reasonable portion of the messge and mark it as
                 * incomplete so the entire thing can be downloaded later if the user
                 * wishes to download it.
                 */
                fp.clear();
                fp.add(FetchProfile.Item.BODY_SANE);
                /*
                 *  TODO a good optimization here would be to make sure that all Stores set
                 *  the proper size after this fetch and compare the before and after size. If
                 *  they equal we can mark this SYNCHRONIZED instead of PARTIALLY_SYNCHRONIZED
                 */

                remoteFolder.fetch(new Message[] { message }, fp, null);

                // Store the updated message locally
                localFolder.appendMessages(new Message[] { message });

                Message localMessage = localFolder.getMessage(message.getUid());


                // Certain (POP3) servers give you the whole message even when you ask for only the first x Kb
                if (!message.isSet(Flag.X_DOWNLOADED_FULL)) {
                    /*
                     * Mark the message as fully downloaded if the message size is smaller than
                     * the account's autodownload size limit, otherwise mark as only a partial
                     * download.  This will prevent the system from downloading the same message
                     * twice.
                     *
                     * If there is no limit on autodownload size, that's the same as the message
                     * being smaller than the max size
                     */
                    if (account.getMaximumAutoDownloadMessageSize() == 0 || message.getSize() < account.getMaximumAutoDownloadMessageSize()) {
                        localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);
                    } else {
                        // Set a flag indicating that the message has been partially downloaded and
                        // is ready for view.
                        localMessage.setFlag(Flag.X_DOWNLOADED_PARTIAL, true);
                    }
                }
            } else {
                /*
                 * We have a structure to deal with, from which
                 * we can pull down the parts we want to actually store.
                 * Build a list of parts we are interested in. Text parts will be downloaded
                 * right now, attachments will be left for later.
                 */

                ArrayList<Part> viewables = new ArrayList<Part>();
                ArrayList<Part> attachments = new ArrayList<Part>();
                MimeUtility.collectParts(message, viewables, attachments);

                /*
                 * Now download the parts we're interested in storing.
                 */
                for (Part part : viewables) {
                    remoteFolder.fetchPart(message, part, null);
                }
                // Store the updated message locally
                localFolder.appendMessages(new Message[] { message });

                Message localMessage = localFolder.getMessage(message.getUid());

                // Set a flag indicating this message has been fully downloaded and can be
                // viewed.
                localMessage.setFlag(Flag.X_DOWNLOADED_PARTIAL, true);
            }
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""About to notify listeners that we got a new large message ""
                      + account + "":"" + folder + "":"" + message.getUid());

            // Update the listener with what we've found
            progress.incrementAndGet();
            Message localMessage = localFolder.getMessage(message.getUid());

            // Increment the number of ""new messages"" if the newly downloaded message is
            // not marked as read.
            if (!localMessage.isSet(Flag.SEEN)) {
                newMessages.incrementAndGet();
            }

            for (MessagingListener l : getListeners()) {
                l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
                if (!localMessage.isSet(Flag.SEEN)) {
                    l.synchronizeMailboxNewMessage(account, folder, localMessage);
                }
            }

            // Send a notification of this message
            if (shouldNotifyForMessage(account, localFolder, message)) {
                notifyAccount(mApplication, account, message, unreadBeforeStart, newMessages);
            }

        }//for large messsages
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Done fetching large messages for folder "" + folder);

    }

    private void refreshLocalMessageFlags(final Account account, final Folder remoteFolder,
                                          final LocalFolder localFolder,
                                          ArrayList<Message> syncFlagMessages,
                                          final AtomicInteger progress,
                                          final int todo
                                         ) throws MessagingException {

        final String folder = remoteFolder.getName();
        if (remoteFolder.supportsFetchingFlags()) {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""SYNC: About to sync flags for ""
                      + syncFlagMessages.size() + "" remote messages for folder "" + folder);

            FetchProfile fp = new FetchProfile();
            fp.add(FetchProfile.Item.FLAGS);

            List<Message> undeletedMessages = new LinkedList<Message>();
            for (Message message : syncFlagMessages) {
                if (!message.isSet(Flag.DELETED)) {
                    undeletedMessages.add(message);
                }
            }

            remoteFolder.fetch(undeletedMessages.toArray(EMPTY_MESSAGE_ARRAY), fp, null);
            for (Message remoteMessage : syncFlagMessages) {
                Message localMessage = localFolder.getMessage(remoteMessage.getUid());
                boolean messageChanged = syncFlags(localMessage, remoteMessage);
                if (messageChanged) {
                    if (localMessage.isSet(Flag.DELETED) || isMessageSuppressed(account, folder, localMessage)) {
                        for (MessagingListener l : getListeners()) {
                            l.synchronizeMailboxRemovedMessage(account, folder, localMessage);
                        }
                    } else {
                        for (MessagingListener l : getListeners()) {
                            l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                        }
                    }

                }
                progress.incrementAndGet();
                for (MessagingListener l : getListeners()) {
                    l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
                }
            }
        }
    }

    private boolean syncFlags(Message localMessage, Message remoteMessage) throws MessagingException {
        boolean messageChanged = false;
        if (localMessage == null || localMessage.isSet(Flag.DELETED)) {
            return false;
        }
        if (remoteMessage.isSet(Flag.DELETED)) {
            if (localMessage.getFolder().getAccount().syncRemoteDeletions()) {
                localMessage.setFlag(Flag.DELETED, true);
                messageChanged = true;
            }
        } else {
            for (Flag flag : new Flag[] { Flag.SEEN, Flag.FLAGGED, Flag.ANSWERED }) {
                if (remoteMessage.isSet(flag) != localMessage.isSet(flag)) {
                    localMessage.setFlag(flag, remoteMessage.isSet(flag));
                    messageChanged = true;
                }
            }
        }
        return messageChanged;
    }
    private String getRootCauseMessage(Throwable t) {
        Throwable rootCause = t;
        Throwable nextCause = rootCause;
        do {
            nextCause = rootCause.getCause();
            if (nextCause != null) {
                rootCause = nextCause;
            }
        } while (nextCause != null);
        if (rootCause instanceof MessagingException) {
            return rootCause.getMessage();
        } else {
            return rootCause.toString();
        }
    }

    private void queuePendingCommand(Account account, PendingCommand command) {
        try {
            LocalStore localStore = account.getLocalStore();
            localStore.addPendingCommand(command);
        } catch (Exception e) {
            addErrorMessage(account, null, e);

            throw new RuntimeException(""Unable to enqueue pending command"", e);
        }
    }

    private void processPendingCommands(final Account account) {
        putBackground(""processPendingCommands"", null, new Runnable() {
            @Override
            public void run() {
                try {
                    processPendingCommandsSynchronous(account);
                } catch (UnavailableStorageException e) {
                    Log.i(K9.LOG_TAG, ""Failed to process pending command because storage is not available - trying again later."");
                    throw new UnavailableAccountException(e);
                } catch (MessagingException me) {
                    Log.e(K9.LOG_TAG, ""processPendingCommands"", me);

                    addErrorMessage(account, null, me);

                    /*
                     * Ignore any exceptions from the commands. Commands will be processed
                     * on the next round.
                     */
                }
            }
        });
    }

    private void processPendingCommandsSynchronous(Account account) throws MessagingException {
        LocalStore localStore = account.getLocalStore();
        ArrayList<PendingCommand> commands = localStore.getPendingCommands();

        int progress = 0;
        int todo = commands.size();
        if (todo == 0) {
            return;
        }

        for (MessagingListener l : getListeners()) {
            l.pendingCommandsProcessing(account);
            l.synchronizeMailboxProgress(account, null, progress, todo);
        }

        PendingCommand processingCommand = null;
        try {
            for (PendingCommand command : commands) {
                processingCommand = command;
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Processing pending command '"" + command + ""'"");

                String[] components = command.command.split(""\\."");
                String commandTitle = components[components.length - 1];
                for (MessagingListener l : getListeners()) {
                    l.pendingCommandStarted(account, commandTitle);
                }
                /*
                 * We specifically do not catch any exceptions here. If a command fails it is
                 * most likely due to a server or IO error and it must be retried before any
                 * other command processes. This maintains the order of the commands.
                 */
                try {
                    if (PENDING_COMMAND_APPEND.equals(command.command)) {
                        processPendingAppend(command, account);
                    } else if (PENDING_COMMAND_SET_FLAG_BULK.equals(command.command)) {
                        processPendingSetFlag(command, account);
                    } else if (PENDING_COMMAND_SET_FLAG.equals(command.command)) {
                        processPendingSetFlagOld(command, account);
                    } else if (PENDING_COMMAND_MARK_ALL_AS_READ.equals(command.command)) {
                        processPendingMarkAllAsRead(command, account);
                    } else if (PENDING_COMMAND_MOVE_OR_COPY_BULK.equals(command.command)) {
                        processPendingMoveOrCopy(command, account);
                    } else if (PENDING_COMMAND_MOVE_OR_COPY.equals(command.command)) {
                        processPendingMoveOrCopyOld(command, account);
                    } else if (PENDING_COMMAND_EMPTY_TRASH.equals(command.command)) {
                        processPendingEmptyTrash(command, account);
                    } else if (PENDING_COMMAND_EXPUNGE.equals(command.command)) {
                        processPendingExpunge(command, account);
                    }
                    localStore.removePendingCommand(command);
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Done processing pending command '"" + command + ""'"");
                } catch (MessagingException me) {
                    if (me.isPermanentFailure()) {
                        addErrorMessage(account, null, me);
                        Log.e(K9.LOG_TAG, ""Failure of command '"" + command + ""' was permanent, removing command from queue"");
                        localStore.removePendingCommand(processingCommand);
                    } else {
                        throw me;
                    }
                } finally {
                    progress++;
                    for (MessagingListener l : getListeners()) {
                        l.synchronizeMailboxProgress(account, null, progress, todo);
                        l.pendingCommandCompleted(account, commandTitle);
                    }
                }
            }
        } catch (MessagingException me) {
            addErrorMessage(account, null, me);
            Log.e(K9.LOG_TAG, ""Could not process command '"" + processingCommand + ""'"", me);
            throw me;
        } finally {
            for (MessagingListener l : getListeners()) {
                l.pendingCommandsFinished(account);
            }
        }
    }

    /**
     * Process a pending append message command. This command uploads a local message to the
     * server, first checking to be sure that the server message is not newer than
     * the local message. Once the local message is successfully processed it is deleted so
     * that the server message will be synchronized down without an additional copy being
     * created.
     * TODO update the local message UID instead of deleteing it
     *
     * @param command arguments = (String folder, String uid)
     * @param account
     * @throws MessagingException
     */
    private void processPendingAppend(PendingCommand command, Account account)
    throws MessagingException {
        Folder remoteFolder = null;
        LocalFolder localFolder = null;
        try {

            String folder = command.arguments[0];
            String uid = command.arguments[1];

            if (account.getErrorFolderName().equals(folder)) {
                return;
            }

            LocalStore localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folder);
            LocalMessage localMessage = (LocalMessage) localFolder.getMessage(uid);

            if (localMessage == null) {
                return;
            }

            Store remoteStore = account.getRemoteStore();
            remoteFolder = remoteStore.getFolder(folder);
            if (!remoteFolder.exists()) {
                if (!remoteFolder.create(FolderType.HOLDS_MESSAGES)) {
                    return;
                }
            }
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE) {
                return;
            }

            Message remoteMessage = null;
            if (!localMessage.getUid().startsWith(K9.LOCAL_UID_PREFIX)) {
                remoteMessage = remoteFolder.getMessage(localMessage.getUid());
            }

            if (remoteMessage == null) {
                if (localMessage.isSet(Flag.X_REMOTE_COPY_STARTED)) {
                    Log.w(K9.LOG_TAG, ""Local message with uid "" + localMessage.getUid() +
                          "" has flag "" + Flag.X_REMOTE_COPY_STARTED + "" already set, checking for remote message with "" +
                          "" same message id"");
                    String rUid = remoteFolder.getUidFromMessageId(localMessage);
                    if (rUid != null) {
                        Log.w(K9.LOG_TAG, ""Local message has flag "" + Flag.X_REMOTE_COPY_STARTED + "" already set, and there is a remote message with "" +
                              "" uid "" + rUid + "", assuming message was already copied and aborting this copy"");

                        String oldUid = localMessage.getUid();
                        localMessage.setUid(rUid);
                        localFolder.changeUid(localMessage);
                        for (MessagingListener l : getListeners()) {
                            l.messageUidChanged(account, folder, oldUid, localMessage.getUid());
                        }
                        return;
                    } else {
                        Log.w(K9.LOG_TAG, ""No remote message with message-id found, proceeding with append"");
                    }
                }

                /*
                 * If the message does not exist remotely we just upload it and then
                 * update our local copy with the new uid.
                 */
                FetchProfile fp = new FetchProfile();
                fp.add(FetchProfile.Item.BODY);
                localFolder.fetch(new Message[] { localMessage } , fp, null);
                String oldUid = localMessage.getUid();
                localMessage.setFlag(Flag.X_REMOTE_COPY_STARTED, true);
                remoteFolder.appendMessages(new Message[] { localMessage });

                localFolder.changeUid(localMessage);
                for (MessagingListener l : getListeners()) {
                    l.messageUidChanged(account, folder, oldUid, localMessage.getUid());
                }
            } else {
                /*
                 * If the remote message exists we need to determine which copy to keep.
                 */
                /*
                 * See if the remote message is newer than ours.
                 */
                FetchProfile fp = new FetchProfile();
                fp.add(FetchProfile.Item.ENVELOPE);
                remoteFolder.fetch(new Message[] { remoteMessage }, fp, null);
                Date localDate = localMessage.getInternalDate();
                Date remoteDate = remoteMessage.getInternalDate();
                if (remoteDate != null && remoteDate.compareTo(localDate) > 0) {
                    /*
                     * If the remote message is newer than ours we'll just
                     * delete ours and move on. A sync will get the server message
                     * if we need to be able to see it.
                     */
                    localMessage.destroy();
                } else {
                    /*
                     * Otherwise we'll upload our message and then delete the remote message.
                     */
                    fp.clear();
                    fp = new FetchProfile();
                    fp.add(FetchProfile.Item.BODY);
                    localFolder.fetch(new Message[] { localMessage }, fp, null);
                    String oldUid = localMessage.getUid();

                    localMessage.setFlag(Flag.X_REMOTE_COPY_STARTED, true);

                    remoteFolder.appendMessages(new Message[] { localMessage });
                    localFolder.changeUid(localMessage);
                    for (MessagingListener l : getListeners()) {
                        l.messageUidChanged(account, folder, oldUid, localMessage.getUid());
                    }
                    if (remoteDate != null) {
                        remoteMessage.setFlag(Flag.DELETED, true);
                        if (Account.EXPUNGE_IMMEDIATELY.equals(account.getExpungePolicy())) {
                            remoteFolder.expunge();
                        }
                    }
                }
            }
        } finally {
            closeFolder(remoteFolder);
            closeFolder(localFolder);
        }
    }
    private void queueMoveOrCopy(Account account, String srcFolder, String destFolder, boolean isCopy, String uids[]) {
        if (account.getErrorFolderName().equals(srcFolder)) {
            return;
        }
        PendingCommand command = new PendingCommand();
        command.command = PENDING_COMMAND_MOVE_OR_COPY_BULK;

        int length = 3 + uids.length;
        command.arguments = new String[length];
        command.arguments[0] = srcFolder;
        command.arguments[1] = destFolder;
        command.arguments[2] = Boolean.toString(isCopy);
        System.arraycopy(uids, 0, command.arguments, 3, uids.length);
        queuePendingCommand(account, command);
    }
    /**
     * Process a pending trash message command.
     *
     * @param command arguments = (String folder, String uid)
     * @param account
     * @throws MessagingException
     */
    private void processPendingMoveOrCopy(PendingCommand command, Account account)
    throws MessagingException {
        Folder remoteSrcFolder = null;
        Folder remoteDestFolder = null;
        try {
            String srcFolder = command.arguments[0];
            if (account.getErrorFolderName().equals(srcFolder)) {
                return;
            }
            String destFolder = command.arguments[1];
            String isCopyS = command.arguments[2];
            Store remoteStore = account.getRemoteStore();
            remoteSrcFolder = remoteStore.getFolder(srcFolder);

            List<Message> messages = new ArrayList<Message>();
            for (int i = 3; i < command.arguments.length; i++) {
                String uid = command.arguments[i];
                if (!uid.startsWith(K9.LOCAL_UID_PREFIX)) {
                    messages.add(remoteSrcFolder.getMessage(uid));
                }
            }

            boolean isCopy = false;
            if (isCopyS != null) {
                isCopy = Boolean.parseBoolean(isCopyS);
            }

            if (!remoteSrcFolder.exists()) {
                throw new MessagingException(""processingPendingMoveOrCopy: remoteFolder "" + srcFolder + "" does not exist"", true);
            }
            remoteSrcFolder.open(OpenMode.READ_WRITE);
            if (remoteSrcFolder.getMode() != OpenMode.READ_WRITE) {
                throw new MessagingException(""processingPendingMoveOrCopy: could not open remoteSrcFolder "" + srcFolder + "" read/write"", true);
            }

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""processingPendingMoveOrCopy: source folder = "" + srcFolder
                      + "", "" + messages.size() + "" messages, destination folder = "" + destFolder + "", isCopy = "" + isCopy);

            if (!isCopy && destFolder.equals(account.getTrashFolderName())) {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""processingPendingMoveOrCopy doing special case for deleting message"");

                String destFolderName = destFolder;
                if (K9.FOLDER_NONE.equals(destFolderName)) {
                    destFolderName = null;
                }
                remoteSrcFolder.delete(messages.toArray(EMPTY_MESSAGE_ARRAY), destFolderName);
            } else {
                remoteDestFolder = remoteStore.getFolder(destFolder);

                if (isCopy) {
                    remoteSrcFolder.copyMessages(messages.toArray(EMPTY_MESSAGE_ARRAY), remoteDestFolder);
                } else {
                    remoteSrcFolder.moveMessages(messages.toArray(EMPTY_MESSAGE_ARRAY), remoteDestFolder);
                }
            }
            if (!isCopy && Account.EXPUNGE_IMMEDIATELY.equals(account.getExpungePolicy())) {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""processingPendingMoveOrCopy expunging folder "" + account.getDescription() + "":"" + srcFolder);

                remoteSrcFolder.expunge();
            }
        } finally {
            closeFolder(remoteSrcFolder);
            closeFolder(remoteDestFolder);
        }


    }

    private void queueSetFlag(final Account account, final String folderName, final String newState, final String flag, final String[] uids) {
        putBackground(""queueSetFlag "" + account.getDescription() + "":"" + folderName, null, new Runnable() {
            @Override
            public void run() {
                PendingCommand command = new PendingCommand();
                command.command = PENDING_COMMAND_SET_FLAG_BULK;
                int length = 3 + uids.length;
                command.arguments = new String[length];
                command.arguments[0] = folderName;
                command.arguments[1] = newState;
                command.arguments[2] = flag;
                System.arraycopy(uids, 0, command.arguments, 3, uids.length);
                queuePendingCommand(account, command);
                processPendingCommands(account);
            }
        });
    }
    /**
     * Processes a pending mark read or unread command.
     *
     * @param command arguments = (String folder, String uid, boolean read)
     * @param account
     */
    private void processPendingSetFlag(PendingCommand command, Account account)
    throws MessagingException {
        String folder = command.arguments[0];

        if (account.getErrorFolderName().equals(folder)) {
            return;
        }

        boolean newState = Boolean.parseBoolean(command.arguments[1]);

        Flag flag = Flag.valueOf(command.arguments[2]);

        Store remoteStore = account.getRemoteStore();
        Folder remoteFolder = remoteStore.getFolder(folder);
        if (!remoteFolder.exists() || !remoteFolder.isFlagSupported(flag)) {
            return;
        }

        try {
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE) {
                return;
            }
            List<Message> messages = new ArrayList<Message>();
            for (int i = 3; i < command.arguments.length; i++) {
                String uid = command.arguments[i];
                if (!uid.startsWith(K9.LOCAL_UID_PREFIX)) {
                    messages.add(remoteFolder.getMessage(uid));
                }
            }

            if (messages.size() == 0) {
                return;
            }
            remoteFolder.setFlags(messages.toArray(EMPTY_MESSAGE_ARRAY), new Flag[] { flag }, newState);
        } finally {
            closeFolder(remoteFolder);
        }
    }

    // TODO: This method is obsolete and is only for transition from K-9 2.0 to K-9 2.1
    // Eventually, it should be removed
    private void processPendingSetFlagOld(PendingCommand command, Account account)
    throws MessagingException {
        String folder = command.arguments[0];
        String uid = command.arguments[1];

        if (account.getErrorFolderName().equals(folder)) {
            return;
        }
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""processPendingSetFlagOld: folder = "" + folder + "", uid = "" + uid);

        boolean newState = Boolean.parseBoolean(command.arguments[2]);

        Flag flag = Flag.valueOf(command.arguments[3]);
        Folder remoteFolder = null;
        try {
            Store remoteStore = account.getRemoteStore();
            remoteFolder = remoteStore.getFolder(folder);
            if (!remoteFolder.exists()) {
                return;
            }
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE) {
                return;
            }
            Message remoteMessage = null;
            if (!uid.startsWith(K9.LOCAL_UID_PREFIX)) {
                remoteMessage = remoteFolder.getMessage(uid);
            }
            if (remoteMessage == null) {
                return;
            }
            remoteMessage.setFlag(flag, newState);
        } finally {
            closeFolder(remoteFolder);
        }
    }
    private void queueExpunge(final Account account, final String folderName) {
        putBackground(""queueExpunge "" + account.getDescription() + "":"" + folderName, null, new Runnable() {
            @Override
            public void run() {
                PendingCommand command = new PendingCommand();
                command.command = PENDING_COMMAND_EXPUNGE;

                command.arguments = new String[1];

                command.arguments[0] = folderName;
                queuePendingCommand(account, command);
                processPendingCommands(account);
            }
        });
    }
    private void processPendingExpunge(PendingCommand command, Account account)
    throws MessagingException {
        String folder = command.arguments[0];

        if (account.getErrorFolderName().equals(folder)) {
            return;
        }
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""processPendingExpunge: folder = "" + folder);

        Store remoteStore = account.getRemoteStore();
        Folder remoteFolder = remoteStore.getFolder(folder);
        try {
            if (!remoteFolder.exists()) {
                return;
            }
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE) {
                return;
            }
            remoteFolder.expunge();
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""processPendingExpunge: complete for folder = "" + folder);
        } finally {
            closeFolder(remoteFolder);
        }
    }


    // TODO: This method is obsolete and is only for transition from K-9 2.0 to K-9 2.1
    // Eventually, it should be removed
    private void processPendingMoveOrCopyOld(PendingCommand command, Account account)
    throws MessagingException {
        String srcFolder = command.arguments[0];
        String uid = command.arguments[1];
        String destFolder = command.arguments[2];
        String isCopyS = command.arguments[3];

        boolean isCopy = false;
        if (isCopyS != null) {
            isCopy = Boolean.parseBoolean(isCopyS);
        }

        if (account.getErrorFolderName().equals(srcFolder)) {
            return;
        }

        Store remoteStore = account.getRemoteStore();
        Folder remoteSrcFolder = remoteStore.getFolder(srcFolder);
        Folder remoteDestFolder = remoteStore.getFolder(destFolder);

        if (!remoteSrcFolder.exists()) {
            throw new MessagingException(""processPendingMoveOrCopyOld: remoteFolder "" + srcFolder + "" does not exist"", true);
        }
        remoteSrcFolder.open(OpenMode.READ_WRITE);
        if (remoteSrcFolder.getMode() != OpenMode.READ_WRITE) {
            throw new MessagingException(""processPendingMoveOrCopyOld: could not open remoteSrcFolder "" + srcFolder + "" read/write"", true);
        }

        Message remoteMessage = null;
        if (!uid.startsWith(K9.LOCAL_UID_PREFIX)) {
            remoteMessage = remoteSrcFolder.getMessage(uid);
        }
        if (remoteMessage == null) {
            throw new MessagingException(""processPendingMoveOrCopyOld: remoteMessage "" + uid + "" does not exist"", true);
        }

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""processPendingMoveOrCopyOld: source folder = "" + srcFolder
                  + "", uid = "" + uid + "", destination folder = "" + destFolder + "", isCopy = "" + isCopy);

        if (!isCopy && destFolder.equals(account.getTrashFolderName())) {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""processPendingMoveOrCopyOld doing special case for deleting message"");

            remoteMessage.delete(account.getTrashFolderName());
            remoteSrcFolder.close();
            return;
        }

        remoteDestFolder.open(OpenMode.READ_WRITE);
        if (remoteDestFolder.getMode() != OpenMode.READ_WRITE) {
            throw new MessagingException(""processPendingMoveOrCopyOld: could not open remoteDestFolder "" + srcFolder + "" read/write"", true);
        }

        if (isCopy) {
            remoteSrcFolder.copyMessages(new Message[] { remoteMessage }, remoteDestFolder);
        } else {
            remoteSrcFolder.moveMessages(new Message[] { remoteMessage }, remoteDestFolder);
        }
        remoteSrcFolder.close();
        remoteDestFolder.close();
    }

    private void processPendingMarkAllAsRead(PendingCommand command, Account account) throws MessagingException {
        String folder = command.arguments[0];
        Folder remoteFolder = null;
        LocalFolder localFolder = null;
        try {
            Store localStore = account.getLocalStore();
            localFolder = (LocalFolder) localStore.getFolder(folder);
            localFolder.open(OpenMode.READ_WRITE);
            Message[] messages = localFolder.getMessages(null, false);
            for (Message message : messages) {
                if (!message.isSet(Flag.SEEN)) {
                    message.setFlag(Flag.SEEN, true);
                    for (MessagingListener l : getListeners()) {
                        l.listLocalMessagesUpdateMessage(account, folder, message);
                    }
                }
            }
            localFolder.setUnreadMessageCount(0);
            for (MessagingListener l : getListeners()) {
                l.folderStatusChanged(account, folder, 0);
            }


            if (account.getErrorFolderName().equals(folder)) {
                return;
            }

            Store remoteStore = account.getRemoteStore();
            remoteFolder = remoteStore.getFolder(folder);

            if (!remoteFolder.exists() || !remoteFolder.isFlagSupported(Flag.SEEN)) {
                return;
            }
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE) {
                return;
            }

            remoteFolder.setFlags(new Flag[] {Flag.SEEN}, true);
            remoteFolder.close();
        } catch (UnsupportedOperationException uoe) {
            Log.w(K9.LOG_TAG, ""Could not mark all server-side as read because store doesn't support operation"", uoe);
        } finally {
            closeFolder(localFolder);
            closeFolder(remoteFolder);
        }
    }

    static long uidfill = 0;
    static AtomicBoolean loopCatch = new AtomicBoolean();
    public void addErrorMessage(Account account, String subject, Throwable t) {
        if (!loopCatch.compareAndSet(false, true)) {
            return;
        }
        try {
            if (t == null) {
                return;
            }

            CharArrayWriter baos = new CharArrayWriter(t.getStackTrace().length * 10);
            PrintWriter ps = new PrintWriter(baos);
            t.printStackTrace(ps);
            ps.close();

            if (subject == null) {
                subject = getRootCauseMessage(t);
            }

            addErrorMessage(account, subject, baos.toString());
        } catch (Throwable it) {
            Log.e(K9.LOG_TAG, ""Could not save error message to "" + account.getErrorFolderName(), it);
        } finally {
            loopCatch.set(false);
        }
    }

    public void addErrorMessage(Account account, String subject, String body) {
        if (!K9.ENABLE_ERROR_FOLDER) {
            return;
        }
        if (!loopCatch.compareAndSet(false, true)) {
            return;
        }
        try {
            if (body == null || body.length() < 1) {
                return;
            }

            Store localStore = account.getLocalStore();
            LocalFolder localFolder = (LocalFolder)localStore.getFolder(account.getErrorFolderName());
            Message[] messages = new Message[1];
            MimeMessage message = new MimeMessage();


            message.setBody(new TextBody(body));
            message.setFlag(Flag.X_DOWNLOADED_FULL, true);
            message.setSubject(subject);

            long nowTime = System.currentTimeMillis();
            Date nowDate = new Date(nowTime);
            message.setInternalDate(nowDate);
            message.addSentDate(nowDate);
            message.setFrom(new Address(account.getEmail(), ""K9mail internal""));
            messages[0] = message;

            localFolder.appendMessages(messages);

            localFolder.clearMessagesOlderThan(nowTime - (15 * 60 * 1000));

        } catch (Throwable it) {
            Log.e(K9.LOG_TAG, ""Could not save error message to "" + account.getErrorFolderName(), it);
        } finally {
            loopCatch.set(false);
        }
    }



    public void markAllMessagesRead(final Account account, final String folder) {

        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Marking all messages in "" + account.getDescription() + "":"" + folder + "" as read"");
        List<String> args = new ArrayList<String>();
        args.add(folder);
        PendingCommand command = new PendingCommand();
        command.command = PENDING_COMMAND_MARK_ALL_AS_READ;
        command.arguments = args.toArray(EMPTY_STRING_ARRAY);
        queuePendingCommand(account, command);
        processPendingCommands(account);
    }

    public void setFlag(
        final Message[] messages,
        final Flag flag,
        final boolean newState) {
        actOnMessages(messages, new MessageActor() {
            @Override
            public void act(final Account account, final Folder folder,
            final List<Message> messages) {
                String[] uids = new String[messages.size()];
                for (int i = 0; i < messages.size(); i++) {
                    uids[i] = messages.get(i).getUid();
                }
                setFlag(account, folder.getName(), uids, flag, newState);
            }

        });

    }

    public void setFlag(
        final Account account,
        final String folderName,
        final String[] uids,
        final Flag flag,
        final boolean newState) {
        // TODO: put this into the background, but right now that causes odd behavior
        // because the FolderMessageList doesn't have its own cache of the flag states
        Folder localFolder = null;
        try {
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folderName);
            localFolder.open(OpenMode.READ_WRITE);
            ArrayList<Message> messages = new ArrayList<Message>();
            for (String uid : uids) {
                // Allows for re-allowing sending of messages that could not be sent
                if (flag == Flag.FLAGGED && !newState
                        && uid != null
                        && account.getOutboxFolderName().equals(folderName)) {
                    sendCount.remove(uid);
                }
                Message msg = localFolder.getMessage(uid);
                if (msg != null) {
                    messages.add(msg);
                }
            }

            localFolder.setFlags(messages.toArray(EMPTY_MESSAGE_ARRAY), new Flag[] {flag}, newState);


            for (MessagingListener l : getListeners()) {
                l.folderStatusChanged(account, folderName, localFolder.getUnreadMessageCount());
            }

            if (account.getErrorFolderName().equals(folderName)) {
                return;
            }

            queueSetFlag(account, folderName, Boolean.toString(newState), flag.toString(), uids);
            processPendingCommands(account);
        } catch (MessagingException me) {
            addErrorMessage(account, null, me);

            throw new RuntimeException(me);
        } finally {
            closeFolder(localFolder);
        }
    }//setMesssageFlag

    public void clearAllPending(final Account account) {
        try {
            Log.w(K9.LOG_TAG, ""Clearing pending commands!"");
            LocalStore localStore = account.getLocalStore();
            localStore.removePendingCommands();
        } catch (MessagingException me) {
            Log.e(K9.LOG_TAG, ""Unable to clear pending command"", me);
            addErrorMessage(account, null, me);
        }
    }

    public void loadMessageForViewRemote(final Account account, final String folder,
                                         final String uid, final MessagingListener listener) {
        put(""loadMessageForViewRemote"", listener, new Runnable() {
            @Override
            public void run() {
                Folder remoteFolder = null;
                LocalFolder localFolder = null;
                try {
                    LocalStore localStore = account.getLocalStore();
                    localFolder = localStore.getFolder(folder);
                    localFolder.open(OpenMode.READ_WRITE);

                    Message message = localFolder.getMessage(uid);

                    if (message.isSet(Flag.X_DOWNLOADED_FULL)) {
                        /*
                         * If the message has been synchronized since we were called we'll
                         * just hand it back cause it's ready to go.
                         */
                        FetchProfile fp = new FetchProfile();
                        fp.add(FetchProfile.Item.ENVELOPE);
                        fp.add(FetchProfile.Item.BODY);
                        localFolder.fetch(new Message[] { message }, fp, null);
                    } else {
                        /*
                         * At this point the message is not available, so we need to download it
                         * fully if possible.
                         */

                        Store remoteStore = account.getRemoteStore();
                        remoteFolder = remoteStore.getFolder(folder);
                        remoteFolder.open(OpenMode.READ_WRITE);

                        // Get the remote message and fully download it
                        Message remoteMessage = remoteFolder.getMessage(uid);
                        FetchProfile fp = new FetchProfile();
                        fp.add(FetchProfile.Item.BODY);
                        remoteFolder.fetch(new Message[] { remoteMessage }, fp, null);

                        // Store the message locally and load the stored message into memory
                        localFolder.appendMessages(new Message[] { remoteMessage });
                        fp.add(FetchProfile.Item.ENVELOPE);
                        message = localFolder.getMessage(uid);
                        localFolder.fetch(new Message[] { message }, fp, null);

                        // Mark that this message is now fully synched
                        message.setFlag(Flag.X_DOWNLOADED_FULL, true);
                    }

                    // now that we have the full message, refresh the headers
                    for (MessagingListener l : getListeners(listener)) {
                        l.loadMessageForViewHeadersAvailable(account, folder, uid, message);
                    }

                    for (MessagingListener l : getListeners(listener)) {
                        l.loadMessageForViewBodyAvailable(account, folder, uid, message);
                    }
                    for (MessagingListener l : getListeners(listener)) {
                        l.loadMessageForViewFinished(account, folder, uid, message);
                    }
                } catch (Exception e) {
                    for (MessagingListener l : getListeners(listener)) {
                        l.loadMessageForViewFailed(account, folder, uid, e);
                    }
                    addErrorMessage(account, null, e);

                } finally {
                    closeFolder(remoteFolder);
                    closeFolder(localFolder);
                }
            }//run
        });
    }

    public void loadMessageForView(final Account account, final String folder, final String uid,
                                   final MessagingListener listener) {
        for (MessagingListener l : getListeners(listener)) {
            l.loadMessageForViewStarted(account, folder, uid);
        }
        threadPool.execute(new Runnable() {
            @Override
            public void run() {

                try {
                    LocalStore localStore = account.getLocalStore();
                    LocalFolder localFolder = localStore.getFolder(folder);
                    localFolder.open(OpenMode.READ_WRITE);

                    LocalMessage message = (LocalMessage)localFolder.getMessage(uid);
                    if (message == null
                    || message.getId() == 0) {
                        throw new IllegalArgumentException(""Message not found: folder="" + folder + "", uid="" + uid);
                    }
                    if (!message.isSet(Flag.SEEN)) {
                        message.setFlag(Flag.SEEN, true);
                        setFlag(new Message[] { message }, Flag.SEEN, true);
                    }

                    for (MessagingListener l : getListeners(listener)) {
                        l.loadMessageForViewHeadersAvailable(account, folder, uid, message);
                    }

                    FetchProfile fp = new FetchProfile();
                    fp.add(FetchProfile.Item.ENVELOPE);
                    fp.add(FetchProfile.Item.BODY);
                    localFolder.fetch(new Message[] {
                                          message
                                      }, fp, null);
                    localFolder.close();

                    for (MessagingListener l : getListeners(listener)) {
                        l.loadMessageForViewBodyAvailable(account, folder, uid, message);
                    }

                    for (MessagingListener l : getListeners(listener)) {
                        l.loadMessageForViewFinished(account, folder, uid, message);
                    }

                } catch (Exception e) {
                    for (MessagingListener l : getListeners(listener)) {
                        l.loadMessageForViewFailed(account, folder, uid, e);
                    }
                    addErrorMessage(account, null, e);

                }
            }
        });
    }

    /**
     * Attempts to load the attachment specified by part from the given account and message.
     * @param account
     * @param message
     * @param part
     * @param listener
     */
    public void loadAttachment(
        final Account account,
        final Message message,
        final Part part,
        final Object tag,
        final MessagingListener listener) {
        /*
         * Check if the attachment has already been downloaded. If it has there's no reason to
         * download it, so we just tell the listener that it's ready to go.
         */

        if (part.getBody() != null) {
            for (MessagingListener l : getListeners()) {
                l.loadAttachmentStarted(account, message, part, tag, false);
            }
            if (listener != null) {
                listener.loadAttachmentStarted(account, message, part, tag, false);
            }

            for (MessagingListener l : getListeners()) {
                l.loadAttachmentFinished(account, message, part, tag);
            }

            if (listener != null) {
                listener.loadAttachmentFinished(account, message, part, tag);
            }
            return;
        }



        for (MessagingListener l : getListeners()) {
            l.loadAttachmentStarted(account, message, part, tag, true);
        }
        if (listener != null) {
            listener.loadAttachmentStarted(account, message, part, tag, false);
        }

        put(""loadAttachment"", listener, new Runnable() {
            @Override
            public void run() {
                Folder remoteFolder = null;
                LocalFolder localFolder = null;
                try {
                    LocalStore localStore = account.getLocalStore();

                    ArrayList<Part> viewables = new ArrayList<Part>();
                    ArrayList<Part> attachments = new ArrayList<Part>();
                    MimeUtility.collectParts(message, viewables, attachments);
                    for (Part attachment : attachments) {
                        attachment.setBody(null);
                    }
                    Store remoteStore = account.getRemoteStore();
                    localFolder = localStore.getFolder(message.getFolder().getName());
                    remoteFolder = remoteStore.getFolder(message.getFolder().getName());
                    remoteFolder.open(OpenMode.READ_WRITE);

                    //FIXME: This is an ugly hack that won't be needed once the Message objects have been united.
                    Message remoteMessage = remoteFolder.getMessage(message.getUid());
                    remoteMessage.setBody(message.getBody());
                    remoteFolder.fetchPart(remoteMessage, part, null);

                    localFolder.updateMessage((LocalMessage)message);
                    for (MessagingListener l : getListeners()) {
                        l.loadAttachmentFinished(account, message, part, tag);
                    }
                    if (listener != null) {
                        listener.loadAttachmentFinished(account, message, part, tag);
                    }
                } catch (MessagingException me) {
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""Exception loading attachment"", me);

                    for (MessagingListener l : getListeners()) {
                        l.loadAttachmentFailed(account, message, part, tag, me.getMessage());
                    }
                    if (listener != null) {
                        listener.loadAttachmentFailed(account, message, part, tag, me.getMessage());
                    }
                    addErrorMessage(account, null, me);

                } finally {
                    closeFolder(localFolder);
                    closeFolder(remoteFolder);
                }
            }
        });
    }

    /**
     * Stores the given message in the Outbox and starts a sendPendingMessages command to
     * attempt to send the message.
     * @param account
     * @param message
     * @param listener
     */
    public void sendMessage(final Account account,
                            final Message message,
                            MessagingListener listener) {
        try {
            LocalStore localStore = account.getLocalStore();
            LocalFolder localFolder = localStore.getFolder(account.getOutboxFolderName());
            localFolder.open(OpenMode.READ_WRITE);
            localFolder.appendMessages(new Message[] { message });
            Message localMessage = localFolder.getMessage(message.getUid());
            localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);
            localFolder.close();
            sendPendingMessages(account, listener);
        } catch (Exception e) {
            /*
            for (MessagingListener l : getListeners())
            {
                // TODO general failed
            }
            */
            addErrorMessage(account, null, e);

        }
    }


    public void sendPendingMessages(MessagingListener listener) {
        final Preferences prefs = Preferences.getPreferences(mApplication.getApplicationContext());
        Account[] accounts = prefs.getAccounts();
        for (Account account : accounts) {
            sendPendingMessages(account, listener);
        }
    }


    /**
     * Attempt to send any messages that are sitting in the Outbox.
     * @param account
     * @param listener
     */
    public void sendPendingMessages(final Account account,
                                    MessagingListener listener) {
        putBackground(""sendPendingMessages"", listener, new Runnable() {
            @Override
            public void run() {
                if (!account.isAvailable(mApplication)) {
                    throw new UnavailableAccountException();
                }
                if (messagesPendingSend(account)) {


                    notifyWhileSending(account);

                    try {
                        sendPendingMessagesSynchronous(account);
                    } finally {
                        notifyWhileSendingDone(account);
                    }
                }
            }
        });
    }

    private void cancelNotification(int id) {
        NotificationManager notifMgr =
            (NotificationManager)mApplication.getSystemService(Context.NOTIFICATION_SERVICE);
        notifMgr.cancel(id);
    }

    private void notifyWhileSendingDone(Account account) {
        if (account.isShowOngoing()) {
            cancelNotification(K9.FETCHING_EMAIL_NOTIFICATION - account.getAccountNumber());


        }
    }
    private void notifyWhileSending(Account account) {
        if (!account.isShowOngoing()) {
            return;
        }
        NotificationManager notifMgr =
            (NotificationManager)mApplication.getSystemService(Context.NOTIFICATION_SERVICE);
        Notification notif = new Notification(R.drawable.ic_menu_refresh,
                                              mApplication.getString(R.string.notification_bg_send_ticker, account.getDescription()), System.currentTimeMillis());
        Intent intent = MessageList.actionHandleFolderIntent(mApplication, account, account.getInboxFolderName());
        PendingIntent pi = PendingIntent.getActivity(mApplication, 0, intent, 0);
        notif.setLatestEventInfo(mApplication, mApplication.getString(R.string.notification_bg_send_title),
                                 account.getDescription() , pi);
        notif.flags = Notification.FLAG_ONGOING_EVENT;

        if (K9.NOTIFICATION_LED_WHILE_SYNCING) {
            configureNotification(notif,  null, null, account.getNotificationSetting().getLedColor(), K9.NOTIFICATION_LED_BLINK_FAST, true);
        }

        notifMgr.notify(K9.FETCHING_EMAIL_NOTIFICATION - account.getAccountNumber(), notif);
    }

    private void notifySendTempFailed(Account account, Exception lastFailure) {
        notifySendFailed(account, lastFailure, account.getOutboxFolderName());
    }
    private void notifySendPermFailed(Account account, Exception lastFailure) {
        notifySendFailed(account, lastFailure, account.getDraftsFolderName());
    }
    private void notifySendFailed(Account account, Exception lastFailure, String openFolder) {
        NotificationManager notifMgr = (NotificationManager)mApplication.getSystemService(Context.NOTIFICATION_SERVICE);
        Notification notif = new Notification(R.drawable.stat_notify_email_generic, mApplication.getString(R.string.send_failure_subject), System.currentTimeMillis());

        Intent i = FolderList.actionHandleNotification(mApplication, account, openFolder);

        PendingIntent pi = PendingIntent.getActivity(mApplication, 0, i, 0);

        notif.setLatestEventInfo(mApplication, mApplication.getString(R.string.send_failure_subject), getRootCauseMessage(lastFailure), pi);

        configureNotification(notif,  null, null, K9.NOTIFICATION_LED_SENDING_FAILURE_COLOR, K9.NOTIFICATION_LED_BLINK_FAST, true);
        notif.flags |= Notification.FLAG_AUTO_CANCEL;
        notifMgr.notify(K9.SEND_FAILED_NOTIFICATION - account.getAccountNumber(), notif);
    }


    private void notifyFetchingMail(final Account account, final Folder folder) {
        if (account.isShowOngoing()) {
            final NotificationManager notifMgr = (NotificationManager)mApplication
                                                 .getSystemService(Context.NOTIFICATION_SERVICE);
            Notification notif = new Notification(R.drawable.ic_menu_refresh,
                                                  mApplication.getString(R.string.notification_bg_sync_ticker, account.getDescription(), folder.getName()),
                                                  System.currentTimeMillis());
            Intent intent = MessageList.actionHandleFolderIntent(mApplication, account, account.getInboxFolderName());
            PendingIntent pi = PendingIntent.getActivity(mApplication, 0, intent, 0);
            notif.setLatestEventInfo(mApplication, mApplication.getString(R.string.notification_bg_sync_title), account.getDescription()
                                     + mApplication.getString(R.string.notification_bg_title_separator) + folder.getName(), pi);
            notif.flags = Notification.FLAG_ONGOING_EVENT;

            if (K9.NOTIFICATION_LED_WHILE_SYNCING) {
                configureNotification(notif,  null, null, account.getNotificationSetting().getLedColor(), K9.NOTIFICATION_LED_BLINK_FAST, true);
            }

            notifMgr.notify(K9.FETCHING_EMAIL_NOTIFICATION - account.getAccountNumber(), notif);
        }
    }
    private void notifyFetchingMailCancel(final Account account) {
        if (account.isShowOngoing()) {
            cancelNotification(K9.FETCHING_EMAIL_NOTIFICATION - account.getAccountNumber());
        }
    }

    public boolean messagesPendingSend(final Account account) {
        Folder localFolder = null;
        try {
            localFolder = account.getLocalStore().getFolder(
                              account.getOutboxFolderName());
            if (!localFolder.exists()) {
                return false;
            }

            localFolder.open(OpenMode.READ_WRITE);

            if (localFolder.getMessageCount() > 0) {
                return true;
            }
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Exception while checking for unsent messages"", e);
        } finally {
            closeFolder(localFolder);
        }
        return false;
    }

    /**
     * Attempt to send any messages that are sitting in the Outbox.
     * @param account
     */
    public void sendPendingMessagesSynchronous(final Account account) {
        Folder localFolder = null;
        Exception lastFailure = null;
        try {
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(
                              account.getOutboxFolderName());
            if (!localFolder.exists()) {
                return;
            }
            for (MessagingListener l : getListeners()) {
                l.sendPendingMessagesStarted(account);
            }
            localFolder.open(OpenMode.READ_WRITE);

            Message[] localMessages = localFolder.getMessages(null);
            int progress = 0;
            int todo = localMessages.length;
            for (MessagingListener l : getListeners()) {
                l.synchronizeMailboxProgress(account, account.getSentFolderName(), progress, todo);
            }
            /*
             * The profile we will use to pull all of the content
             * for a given local message into memory for sending.
             */
            FetchProfile fp = new FetchProfile();
            fp.add(FetchProfile.Item.ENVELOPE);
            fp.add(FetchProfile.Item.BODY);

            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""Scanning folder '"" + account.getOutboxFolderName() + ""' ("" + ((LocalFolder)localFolder).getId() + "") for messages to send"");

            Transport transport = Transport.getInstance(account);
            for (Message message : localMessages) {
                if (message.isSet(Flag.DELETED)) {
                    message.destroy();
                    continue;
                }
                try {
                    AtomicInteger count = new AtomicInteger(0);
                    AtomicInteger oldCount = sendCount.putIfAbsent(message.getUid(), count);
                    if (oldCount != null) {
                        count = oldCount;
                    }

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Send count for message "" + message.getUid() + "" is "" + count.get());

                    if (count.incrementAndGet() > K9.MAX_SEND_ATTEMPTS) {
                        Log.e(K9.LOG_TAG, ""Send count for message "" + message.getUid() + "" can't be delivered after "" + K9.MAX_SEND_ATTEMPTS + "" attempts.  Giving up until the user restarts the device"");
                        notifySendTempFailed(account, new MessagingException(message.getSubject()));
                        continue;
                    }



                    localFolder.fetch(new Message[] { message }, fp, null);
                    try {


                        if (message.getHeader(K9.IDENTITY_HEADER) != null) {
                            Log.v(K9.LOG_TAG, ""The user has set the Outbox and Drafts folder to the same thing. "" +
                                  ""This message appears to be a draft, so K-9 will not send it"");
                            continue;

                        }


                        message.setFlag(Flag.X_SEND_IN_PROGRESS, true);
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Sending message with UID "" + message.getUid());
                        transport.sendMessage(message);
                        message.setFlag(Flag.X_SEND_IN_PROGRESS, false);
                        message.setFlag(Flag.SEEN, true);
                        progress++;
                        for (MessagingListener l : getListeners()) {
                            l.synchronizeMailboxProgress(account, account.getSentFolderName(), progress, todo);
                        }
                        if (K9.FOLDER_NONE.equals(account.getSentFolderName())) {
                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Sent folder set to "" + K9.FOLDER_NONE + "", deleting sent message"");
                            message.setFlag(Flag.DELETED, true);
                        } else {
                            LocalFolder localSentFolder = (LocalFolder) localStore.getFolder(account.getSentFolderName());
                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Moving sent message to folder '"" + account.getSentFolderName() + ""' ("" + localSentFolder.getId() + "") "");

                            localFolder.moveMessages(new Message[] { message }, localSentFolder);

                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Moved sent message to folder '"" + account.getSentFolderName() + ""' ("" + localSentFolder.getId() + "") "");

                            PendingCommand command = new PendingCommand();
                            command.command = PENDING_COMMAND_APPEND;
                            command.arguments = new String[] { localSentFolder.getName(), message.getUid() };
                            queuePendingCommand(account, command);
                            processPendingCommands(account);
                        }

                    } catch (Exception e) {
                        // 5.x.x errors from the SMTP server are ""PERMFAIL""
                        // move the message over to drafts rather than leaving it in the outbox
                        // This is a complete hack, but is worlds better than the previous
                        // ""don't even bother"" functionality
                        if (getRootCauseMessage(e).startsWith(""5"")) {
                            localFolder.moveMessages(new Message[] { message }, (LocalFolder) localStore.getFolder(account.getDraftsFolderName()));
                        } else {
                        }

                        message.setFlag(Flag.X_SEND_FAILED, true);
                        Log.e(K9.LOG_TAG, ""Failed to send message"", e);
                        for (MessagingListener l : getListeners()) {
                            l.synchronizeMailboxFailed(account, localFolder.getName(), getRootCauseMessage(e));
                        }
                        lastFailure = e;
                    }
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Failed to fetch message for sending"", e);
                    for (MessagingListener l : getListeners()) {
                        l.synchronizeMailboxFailed(account, localFolder.getName(), getRootCauseMessage(e));
                    }
                    lastFailure = e;
                }
            }
            for (MessagingListener l : getListeners()) {
                l.sendPendingMessagesCompleted(account);
            }
            if (lastFailure != null) {
                if (getRootCauseMessage(lastFailure).startsWith(""5"")) {
                    notifySendPermFailed(account, lastFailure);
                } else {
                    notifySendTempFailed(account, lastFailure);
                }
            }
        } catch (UnavailableStorageException e) {
            Log.i(K9.LOG_TAG, ""Failed to send pending messages because storage is not available - trying again later."");
            throw new UnavailableAccountException(e);
        } catch (Exception e) {
            for (MessagingListener l : getListeners()) {
                l.sendPendingMessagesFailed(account);
            }
            addErrorMessage(account, null, e);

        } finally {
            if (lastFailure == null) {
                cancelNotification(K9.SEND_FAILED_NOTIFICATION - account.getAccountNumber());
            }
            closeFolder(localFolder);
        }
    }

    public void getAccountStats(final Context context, final Account account,
                                final MessagingListener l) {
        Runnable unreadRunnable = new Runnable() {
            @Override
            public void run() {
                try {
                    AccountStats stats = account.getStats(context);
                    l.accountStatusChanged(account, stats);
                } catch (MessagingException me) {
                    Log.e(K9.LOG_TAG, ""Count not get unread count for account "" + account.getDescription(),
                          me);
                }

            }
        };

        put(""getAccountStats:"" + account.getDescription(), l, unreadRunnable);
    }

    public void getFolderUnreadMessageCount(final Account account, final String folderName,
                                            final MessagingListener l) {
        Runnable unreadRunnable = new Runnable() {
            @Override
            public void run() {

                int unreadMessageCount = 0;
                try {
                    Folder localFolder = account.getLocalStore().getFolder(folderName);
                    unreadMessageCount = localFolder.getUnreadMessageCount();
                } catch (MessagingException me) {
                    Log.e(K9.LOG_TAG, ""Count not get unread count for account "" + account.getDescription(), me);
                }
                l.folderStatusChanged(account, folderName, unreadMessageCount);
            }
        };


        put(""getFolderUnread:"" + account.getDescription() + "":"" + folderName, l, unreadRunnable);
    }



    public boolean isMoveCapable(Message message) {
        return !message.getUid().startsWith(K9.LOCAL_UID_PREFIX);
    }
    public boolean isCopyCapable(Message message) {
        return isMoveCapable(message);
    }

    public boolean isMoveCapable(final Account account) {
        try {
            Store localStore = account.getLocalStore();
            Store remoteStore = account.getRemoteStore();
            return localStore.isMoveCapable() && remoteStore.isMoveCapable();
        } catch (MessagingException me) {

            Log.e(K9.LOG_TAG, ""Exception while ascertaining move capability"", me);
            return false;
        }
    }
    public boolean isCopyCapable(final Account account) {
        try {
            Store localStore = account.getLocalStore();
            Store remoteStore = account.getRemoteStore();
            return localStore.isCopyCapable() && remoteStore.isCopyCapable();
        } catch (MessagingException me) {
            Log.e(K9.LOG_TAG, ""Exception while ascertaining copy capability"", me);
            return false;
        }
    }
    public void moveMessages(final Account account, final String srcFolder, final Message[] messages, final String destFolder,
                             final MessagingListener listener) {
        for (Message message : messages) {
            suppressMessage(account, srcFolder, message);
        }
        putBackground(""moveMessages"", null, new Runnable() {
            @Override
            public void run() {
                moveOrCopyMessageSynchronous(account, srcFolder, messages, destFolder, false, listener);
            }
        });
    }

    public void moveMessage(final Account account, final String srcFolder, final Message message, final String destFolder,
                            final MessagingListener listener) {
        moveMessages(account, srcFolder, new Message[] { message }, destFolder, listener);
    }

    public void copyMessages(final Account account, final String srcFolder, final Message[] messages, final String destFolder,
                             final MessagingListener listener) {
        putBackground(""copyMessages"", null, new Runnable() {
            @Override
            public void run() {
                moveOrCopyMessageSynchronous(account, srcFolder, messages, destFolder, true, listener);
            }
        });
    }
    public void copyMessage(final Account account, final String srcFolder, final Message message, final String destFolder,
                            final MessagingListener listener) {
        copyMessages(account, srcFolder, new Message[] { message }, destFolder, listener);
    }

    private void moveOrCopyMessageSynchronous(final Account account, final String srcFolder, final Message[] inMessages,
            final String destFolder, final boolean isCopy, MessagingListener listener) {
        try {
            Store localStore = account.getLocalStore();
            Store remoteStore = account.getRemoteStore();
            if (!isCopy && (!remoteStore.isMoveCapable() || !localStore.isMoveCapable())) {
                return;
            }
            if (isCopy && (!remoteStore.isCopyCapable() || !localStore.isCopyCapable())) {
                return;
            }

            Folder localSrcFolder = localStore.getFolder(srcFolder);
            Folder localDestFolder = localStore.getFolder(destFolder);

            List<String> uids = new LinkedList<String>();
            for (Message message : inMessages) {
                String uid = message.getUid();
                if (!uid.startsWith(K9.LOCAL_UID_PREFIX)) {
                    uids.add(uid);
                }
            }

            Message[] messages = localSrcFolder.getMessages(uids.toArray(EMPTY_STRING_ARRAY), null);
            if (messages.length > 0) {
                Map<String, Message> origUidMap = new HashMap<String, Message>();

                for (Message message : messages) {
                    origUidMap.put(message.getUid(), message);
                }

                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""moveOrCopyMessageSynchronous: source folder = "" + srcFolder
                          + "", "" + messages.length + "" messages, "" + "", destination folder = "" + destFolder + "", isCopy = "" + isCopy);

                if (isCopy) {
                    FetchProfile fp = new FetchProfile();
                    fp.add(FetchProfile.Item.ENVELOPE);
                    fp.add(FetchProfile.Item.BODY);
                    localSrcFolder.fetch(messages, fp, null);
                    localSrcFolder.copyMessages(messages, localDestFolder);
                } else {
                    localSrcFolder.moveMessages(messages, localDestFolder);
                    for (String origUid : origUidMap.keySet()) {
                        for (MessagingListener l : getListeners()) {
                            l.messageUidChanged(account, srcFolder, origUid, origUidMap.get(origUid).getUid());
                        }
                        unsuppressMessage(account, srcFolder, origUid);
                    }
                }

                queueMoveOrCopy(account, srcFolder, destFolder, isCopy, origUidMap.keySet().toArray(EMPTY_STRING_ARRAY));
            }

            processPendingCommands(account);
        } catch (UnavailableStorageException e) {
            Log.i(K9.LOG_TAG, ""Failed to move/copy message because storage is not available - trying again later."");
            throw new UnavailableAccountException(e);
        } catch (MessagingException me) {
            addErrorMessage(account, null, me);

            throw new RuntimeException(""Error moving message"", me);
        }
    }

    public void expunge(final Account account, final String folder, final MessagingListener listener) {
        putBackground(""expunge"", null, new Runnable() {
            @Override
            public void run() {
                queueExpunge(account, folder);
            }
        });
    }

    public void deleteDraft(final Account account, String uid) {
        LocalFolder localFolder = null;
        try {
            LocalStore localStore = account.getLocalStore();
            localFolder = localStore.getFolder(account.getDraftsFolderName());
            localFolder.open(OpenMode.READ_WRITE);
            Message message = localFolder.getMessage(uid);
            if (message != null) {
                deleteMessages(new Message[] { message }, null);
            }
        } catch (MessagingException me) {
            addErrorMessage(account, null, me);
        } finally {
            closeFolder(localFolder);
        }
    }

    public void deleteMessages(final Message[] messages, final MessagingListener listener) {
        actOnMessages(messages, new MessageActor() {

            @Override
            public void act(final Account account, final Folder folder,
            final List<Message> messages) {
                for (Message message : messages) {
                    suppressMessage(account, folder.getName(), message);
                }

                putBackground(""deleteMessages"", null, new Runnable() {
                    @Override
                    public void run() {
                        deleteMessagesSynchronous(account, folder.getName(), messages.toArray(EMPTY_MESSAGE_ARRAY), listener);
                    }
                });
            }

        });

    }

    private void deleteMessagesSynchronous(final Account account, final String folder, final Message[] messages,
                                           MessagingListener listener) {
        Folder localFolder = null;
        Folder localTrashFolder = null;
        String[] uids = getUidsFromMessages(messages);
        try {
            //We need to make these callbacks before moving the messages to the trash
            //as messages get a new UID after being moved
            for (Message message : messages) {
                if (listener != null) {
                    listener.messageDeleted(account, folder, message);
                }
                for (MessagingListener l : getListeners()) {
                    l.messageDeleted(account, folder, message);
                }
            }
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folder);
            if (folder.equals(account.getTrashFolderName()) || K9.FOLDER_NONE.equals(account.getTrashFolderName())) {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Deleting messages in trash folder or trash set to -None-, not copying"");

                localFolder.setFlags(messages, new Flag[] { Flag.DELETED }, true);
            } else {
                localTrashFolder = localStore.getFolder(account.getTrashFolderName());
                if (!localTrashFolder.exists()) {
                    localTrashFolder.create(Folder.FolderType.HOLDS_MESSAGES);
                }
                if (localTrashFolder.exists()) {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Deleting messages in normal folder, moving"");

                    localFolder.moveMessages(messages, localTrashFolder);

                }
            }

            for (MessagingListener l : getListeners()) {
                l.folderStatusChanged(account, folder, localFolder.getUnreadMessageCount());
                if (localTrashFolder != null) {
                    l.folderStatusChanged(account, account.getTrashFolderName(), localTrashFolder.getUnreadMessageCount());
                }
            }

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Delete policy for account "" + account.getDescription() + "" is "" + account.getDeletePolicy());

            if (folder.equals(account.getOutboxFolderName())) {
                for (Message message : messages) {
                    // If the message was in the Outbox, then it has been copied to local Trash, and has
                    // to be copied to remote trash
                    PendingCommand command = new PendingCommand();
                    command.command = PENDING_COMMAND_APPEND;
                    command.arguments =
                        new String[] {
                        account.getTrashFolderName(),
                        message.getUid()
                    };
                    queuePendingCommand(account, command);
                }
                processPendingCommands(account);
            } else if (account.getDeletePolicy() == Account.DELETE_POLICY_ON_DELETE) {
                if (folder.equals(account.getTrashFolderName())) {
                    queueSetFlag(account, folder, Boolean.toString(true), Flag.DELETED.toString(), uids);
                } else {
                    queueMoveOrCopy(account, folder, account.getTrashFolderName(), false, uids);
                }
                processPendingCommands(account);
            } else if (account.getDeletePolicy() == Account.DELETE_POLICY_MARK_AS_READ) {
                queueSetFlag(account, folder, Boolean.toString(true), Flag.SEEN.toString(), uids);
                processPendingCommands(account);
            } else {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Delete policy "" + account.getDeletePolicy() + "" prevents delete from server"");
            }
            for (String uid : uids) {
                unsuppressMessage(account, folder, uid);
            }
        } catch (UnavailableStorageException e) {
            Log.i(K9.LOG_TAG, ""Failed to delete message because storage is not available - trying again later."");
            throw new UnavailableAccountException(e);
        } catch (MessagingException me) {
            addErrorMessage(account, null, me);

            throw new RuntimeException(""Error deleting message from local store."", me);
        } finally {
            closeFolder(localFolder);
            closeFolder(localTrashFolder);
        }
    }

    private String[] getUidsFromMessages(Message[] messages) {
        String[] uids = new String[messages.length];
        for (int i = 0; i < messages.length; i++) {
            uids[i] = messages[i].getUid();
        }
        return uids;
    }

    private void processPendingEmptyTrash(PendingCommand command, Account account) throws MessagingException {
        Store remoteStore = account.getRemoteStore();

        Folder remoteFolder = remoteStore.getFolder(account.getTrashFolderName());
        try {
            if (remoteFolder.exists()) {
                remoteFolder.open(OpenMode.READ_WRITE);
                remoteFolder.setFlags(new Flag [] { Flag.DELETED }, true);
                if (Account.EXPUNGE_IMMEDIATELY.equals(account.getExpungePolicy())) {
                    remoteFolder.expunge();
                }

                // When we empty trash, we need to actually synchronize the folder
                // or local deletes will never get cleaned up
                synchronizeFolder(account, remoteFolder, true, 0, null);
                compact(account, null);


            }
        } finally {
            closeFolder(remoteFolder);
        }
    }

    public void emptyTrash(final Account account, MessagingListener listener) {
        putBackground(""emptyTrash"", listener, new Runnable() {
            @Override
            public void run() {
                Folder localFolder = null;
                try {
                    Store localStore = account.getLocalStore();
                    localFolder = localStore.getFolder(account.getTrashFolderName());
                    localFolder.open(OpenMode.READ_WRITE);
                    localFolder.setFlags(new Flag[] { Flag.DELETED }, true);

                    for (MessagingListener l : getListeners()) {
                        l.emptyTrashCompleted(account);
                    }
                    List<String> args = new ArrayList<String>();
                    PendingCommand command = new PendingCommand();
                    command.command = PENDING_COMMAND_EMPTY_TRASH;
                    command.arguments = args.toArray(EMPTY_STRING_ARRAY);
                    queuePendingCommand(account, command);
                    processPendingCommands(account);
                } catch (UnavailableStorageException e) {
                    Log.i(K9.LOG_TAG, ""Failed to empty trash because storage is not available - trying again later."");
                    throw new UnavailableAccountException(e);
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""emptyTrash failed"", e);

                    addErrorMessage(account, null, e);
                } finally {
                    closeFolder(localFolder);
                }
            }
        });
    }

    public void sendAlternate(final Context context, Account account, Message message) {
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""About to load message "" + account.getDescription() + "":"" + message.getFolder().getName()
                  + "":"" + message.getUid() + "" for sendAlternate"");

        loadMessageForView(account, message.getFolder().getName(),
        message.getUid(), new MessagingListener() {
            @Override
            public void loadMessageForViewBodyAvailable(Account account, String folder, String uid,
            Message message) {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Got message "" + account.getDescription() + "":"" + folder
                          + "":"" + message.getUid() + "" for sendAlternate"");

                try {
                    Intent msg = new Intent(Intent.ACTION_SEND);
                    String quotedText = null;
                    Part part = MimeUtility.findFirstPartByMimeType(message,
                                ""text/plain"");
                    if (part == null) {
                        part = MimeUtility.findFirstPartByMimeType(message, ""text/html"");
                    }
                    if (part != null) {
                        quotedText = MimeUtility.getTextFromPart(part);
                    }
                    if (quotedText != null) {
                        msg.putExtra(Intent.EXTRA_TEXT, quotedText);
                    }
                    msg.putExtra(Intent.EXTRA_SUBJECT, message.getSubject());

                    Address[] from = message.getFrom();
                    String[] senders = new String[from.length];
                    for (int i = 0; i < from.length; i++) {
                        senders[i] = from[i].toString();
                    }
                    msg.putExtra(Intents.Share.EXTRA_FROM, senders);

                    Address[] to = message.getRecipients(RecipientType.TO);
                    String[] recipientsTo = new String[to.length];
                    for (int i = 0; i < to.length; i++) {
                        recipientsTo[i] = to[i].toString();
                    }
                    msg.putExtra(Intent.EXTRA_EMAIL, recipientsTo);

                    Address[] cc = message.getRecipients(RecipientType.CC);
                    String[] recipientsCc = new String[cc.length];
                    for (int i = 0; i < cc.length; i++) {
                        recipientsCc[i] = cc[i].toString();
                    }
                    msg.putExtra(Intent.EXTRA_CC, recipientsCc);

                    msg.setType(""text/plain"");
                    context.startActivity(Intent.createChooser(msg, context.getString(R.string.send_alternate_chooser_title)));
                } catch (MessagingException me) {
                    Log.e(K9.LOG_TAG, ""Unable to send email through alternate program"", me);
                }
            }
        });

    }

    /**
     * Checks mail for one or multiple accounts. If account is null all accounts
     * are checked.
     *
     * @param context
     * @param account
     * @param listener
     */
    public void checkMail(final Context context, final Account account,
                          final boolean ignoreLastCheckedTime,
                          final boolean useManualWakeLock,
                          final MessagingListener listener) {

        TracingWakeLock twakeLock = null;
        if (useManualWakeLock) {
            TracingPowerManager pm = TracingPowerManager.getPowerManager(context);

            twakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""K9 MessagingController.checkMail"");
            twakeLock.setReferenceCounted(false);
            twakeLock.acquire(K9.MANUAL_WAKE_LOCK_TIMEOUT);
        }
        final TracingWakeLock wakeLock = twakeLock;

        for (MessagingListener l : getListeners()) {
            l.checkMailStarted(context, account);
        }
        putBackground(""checkMail"", listener, new Runnable() {
            @Override
            public void run() {

                try {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Starting mail check"");
                    Preferences prefs = Preferences.getPreferences(context);

                    Account[] accounts;
                    if (account != null) {
                        accounts = new Account[] {
                            account
                        };
                    } else {
                        accounts = prefs.getAccounts();
                    }

                    for (final Account account : accounts) {
                        checkMailForAccount(context, account, ignoreLastCheckedTime, prefs, listener);
                    }

                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Unable to synchronize mail"", e);
                    addErrorMessage(account, null, e);
                }
                putBackground(""finalize sync"", null, new Runnable() {
                    @Override
                    public void run() {

                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Finished mail sync"");

                        if (wakeLock != null) {
                            wakeLock.release();
                        }
                        for (MessagingListener l : getListeners()) {
                            l.checkMailFinished(context, account);
                        }

                    }
                }
                             );
            }
        });
    }



    private void checkMailForAccount(final Context context, final Account account,
                                     final boolean ignoreLastCheckedTime,
                                     final Preferences prefs,
                                     final MessagingListener listener) {
        if (!account.isAvailable(context)) {
            if (K9.DEBUG) {
                Log.i(K9.LOG_TAG, ""Skipping synchronizing unavailable account "" + account.getDescription());
            }
            return;
        }
        final long accountInterval = account.getAutomaticCheckIntervalMinutes() * 60 * 1000;
        if (!ignoreLastCheckedTime && accountInterval <= 0) {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""Skipping synchronizing account "" + account.getDescription());
            return;
        }

        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Synchronizing account "" + account.getDescription());

        account.setRingNotified(false);

        sendPendingMessages(account, listener);

        try {
            Account.FolderMode aDisplayMode = account.getFolderDisplayMode();
            Account.FolderMode aSyncMode = account.getFolderSyncMode();

            Store localStore = account.getLocalStore();
            for (final Folder folder : localStore.getPersonalNamespaces(false)) {
                folder.open(Folder.OpenMode.READ_WRITE);
                folder.refresh(prefs);

                Folder.FolderClass fDisplayClass = folder.getDisplayClass();
                Folder.FolderClass fSyncClass = folder.getSyncClass();

                if (modeMismatch(aDisplayMode, fDisplayClass)) {
                    // Never sync a folder that isn't displayed
                    /*
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""Not syncing folder "" + folder.getName() +
                              "" which is in display mode "" + fDisplayClass + "" while account is in display mode "" + aDisplayMode);
                    */

                    continue;
                }

                if (modeMismatch(aSyncMode, fSyncClass)) {
                    // Do not sync folders in the wrong class
                    /*
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""Not syncing folder "" + folder.getName() +
                              "" which is in sync mode "" + fSyncClass + "" while account is in sync mode "" + aSyncMode);
                    */

                    continue;
                }
                synchronizeFolder(account, folder, ignoreLastCheckedTime, accountInterval, listener);
            }
        } catch (MessagingException e) {
            Log.e(K9.LOG_TAG, ""Unable to synchronize account "" + account.getName(), e);
            addErrorMessage(account, null, e);
        } finally {
            putBackground(""clear notification flag for "" + account.getDescription(), null, new Runnable() {
                @Override
                public void run() {
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""Clearing notification flag for "" + account.getDescription());
                    account.setRingNotified(false);
                    try {
                        AccountStats stats = account.getStats(context);
                        if (stats == null || stats.unreadMessageCount == 0) {
                            notifyAccountCancel(context, account);
                        }
                    } catch (MessagingException e) {
                        Log.e(K9.LOG_TAG, ""Unable to getUnreadMessageCount for account: "" + account, e);
                    }
                }
            }
                         );
        }


    }


    private void synchronizeFolder(
        final Account account,
        final Folder folder,
        final boolean ignoreLastCheckedTime,
        final long accountInterval,
        final MessagingListener listener) {


        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""Folder "" + folder.getName() + "" was last synced @ "" +
                  new Date(folder.getLastChecked()));

        if (!ignoreLastCheckedTime && folder.getLastChecked() >
                (System.currentTimeMillis() - accountInterval)) {
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""Not syncing folder "" + folder.getName()
                      + "", previously synced @ "" + new Date(folder.getLastChecked())
                      + "" which would be too recent for the account period"");

            return;
        }
        putBackground(""sync"" + folder.getName(), null, new Runnable() {
            @Override
            public void run() {
                LocalFolder tLocalFolder = null;
                try {
                    // In case multiple Commands get enqueued, don't run more than
                    // once
                    final LocalStore localStore = account.getLocalStore();
                    tLocalFolder = localStore.getFolder(folder.getName());
                    tLocalFolder.open(Folder.OpenMode.READ_WRITE);

                    if (!ignoreLastCheckedTime && tLocalFolder.getLastChecked() >
                    (System.currentTimeMillis() - accountInterval)) {
                        if (K9.DEBUG)
                            Log.v(K9.LOG_TAG, ""Not running Command for folder "" + folder.getName()
                                  + "", previously synced @ "" + new Date(folder.getLastChecked())
                                  + "" which would be too recent for the account period"");
                        return;
                    }
                    notifyFetchingMail(account, folder);
                    try {
                        synchronizeMailboxSynchronous(account, folder.getName(), listener, null);
                    } finally {
                        notifyFetchingMailCancel(account);
                    }
                } catch (Exception e) {

                    Log.e(K9.LOG_TAG, ""Exception while processing folder "" +
                          account.getDescription() + "":"" + folder.getName(), e);
                    addErrorMessage(account, null, e);
                } finally {
                    closeFolder(tLocalFolder);
                }
            }
        }
                     );


    }



    public void compact(final Account account, final MessagingListener ml) {
        putBackground(""compact:"" + account.getDescription(), ml, new Runnable() {
            @Override
            public void run() {
                try {
                    LocalStore localStore = account.getLocalStore();
                    long oldSize = localStore.getSize();
                    localStore.compact();
                    long newSize = localStore.getSize();
                    if (ml != null) {
                        ml.accountSizeChanged(account, oldSize, newSize);
                    }
                    for (MessagingListener l : getListeners()) {
                        l.accountSizeChanged(account, oldSize, newSize);
                    }
                } catch (UnavailableStorageException e) {
                    Log.i(K9.LOG_TAG, ""Failed to compact account because storage is not available - trying again later."");
                    throw new UnavailableAccountException(e);
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Failed to compact account "" + account.getDescription(), e);
                }
            }
        });
    }

    public void clear(final Account account, final MessagingListener ml) {
        putBackground(""clear:"" + account.getDescription(), ml, new Runnable() {
            @Override
            public void run() {
                try {
                    LocalStore localStore = account.getLocalStore();
                    long oldSize = localStore.getSize();
                    localStore.clear();
                    localStore.resetVisibleLimits(account.getDisplayCount());
                    long newSize = localStore.getSize();
                    AccountStats stats = new AccountStats();
                    stats.size = newSize;
                    stats.unreadMessageCount = 0;
                    stats.flaggedMessageCount = 0;
                    if (ml != null) {
                        ml.accountSizeChanged(account, oldSize, newSize);
                        ml.accountStatusChanged(account, stats);
                    }
                    for (MessagingListener l : getListeners()) {
                        l.accountSizeChanged(account, oldSize, newSize);
                        l.accountStatusChanged(account, stats);
                    }
                } catch (UnavailableStorageException e) {
                    Log.i(K9.LOG_TAG, ""Failed to clear account because storage is not available - trying again later."");
                    throw new UnavailableAccountException(e);
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Failed to clear account "" + account.getDescription(), e);
                }
            }
        });
    }

    public void recreate(final Account account, final MessagingListener ml) {
        putBackground(""recreate:"" + account.getDescription(), ml, new Runnable() {
            @Override
            public void run() {
                try {
                    LocalStore localStore = account.getLocalStore();
                    long oldSize = localStore.getSize();
                    localStore.recreate();
                    localStore.resetVisibleLimits(account.getDisplayCount());
                    long newSize = localStore.getSize();
                    AccountStats stats = new AccountStats();
                    stats.size = newSize;
                    stats.unreadMessageCount = 0;
                    stats.flaggedMessageCount = 0;
                    if (ml != null) {
                        ml.accountSizeChanged(account, oldSize, newSize);
                        ml.accountStatusChanged(account, stats);
                    }
                    for (MessagingListener l : getListeners()) {
                        l.accountSizeChanged(account, oldSize, newSize);
                        l.accountStatusChanged(account, stats);
                    }
                } catch (UnavailableStorageException e) {
                    Log.i(K9.LOG_TAG, ""Failed to recreate an account because storage is not available - trying again later."");
                    throw new UnavailableAccountException(e);
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Failed to recreate account "" + account.getDescription(), e);
                }
            }
        });
    }


    private boolean shouldNotifyForMessage(Account account, LocalFolder localFolder, Message message) {
        // If we don't even have an account name, don't show the notification.
        // (This happens during initial account setup)
        if (account.getName() == null) {
            return false;
        }

        // Do not notify if the user does not have notifications enabled or if the message has
        // been read.
        if (!account.isNotifyNewMail() || message.isSet(Flag.SEEN)) {
            return false;
        }

        // If the account is a POP3 account and the message is older than the oldest message we've
        // previously seen, then don't notify about it.
        if (account.getStoreUri().startsWith(""pop3"") &&
                message.olderThan(new Date(account.getLatestOldMessageSeenTime()))) {
            return false;
        }

        // No notification for new messages in Trash, Drafts, Spam or Sent folder.
        // But do notify if it's the INBOX (see issue 1817).
        Folder folder = message.getFolder();
        if (folder != null) {
            String folderName = folder.getName();
            if (!account.getInboxFolderName().equals(folderName) &&
                    (account.getTrashFolderName().equals(folderName)
                     || account.getDraftsFolderName().equals(folderName)
                     || account.getSpamFolderName().equals(folderName)
                     || account.getSentFolderName().equals(folderName))) {
                return false;
            }
        }

        if (message.getUid() != null && localFolder.getLastUid() != null) {
            try {
                Integer messageUid = Integer.parseInt(message.getUid());
                if (messageUid <= localFolder.getLastUid()) {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Message uid is "" + messageUid + "", max message uid is "" +
                              localFolder.getLastUid() + "".  Skipping notification."");
                    return false;
                }
            } catch (NumberFormatException e) {
                // Nothing to be done here.
            }
        }

        // Don't notify if the sender address matches one of our identities and the user chose not
        // to be notified for such messages.
        if (account.isAnIdentity(message.getFrom()) && !account.isNotifySelfNewMail()) {
            return false;
        }

        return true;
    }



    /**
     * Creates a notification of a newly received message.
     */
    private void notifyAccount(Context context, Account account, Message message,
                               int previousUnreadMessageCount, AtomicInteger newMessageCount) {

        // If we have a message, set the notification to ""<From>: <Subject>""
        StringBuilder messageNotice = new StringBuilder();
        final KeyguardManager keyguardService = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
        try {
            if (message.getFrom() != null) {
                Address[] fromAddrs = message.getFrom();
                String from = fromAddrs.length > 0 ? fromAddrs[0].toFriendly().toString() : null;
                String subject = message.getSubject();
                if (subject == null) {
                    subject = context.getString(R.string.general_no_subject);
                }

                if (from != null) {
                    // Show From: address by default
                    if (!account.isAnIdentity(fromAddrs)) {
                        messageNotice.append(from).append("": "").append(subject);
                    }
                    // show To: if the message was sent from me
                    else {
                        Address[] rcpts = message.getRecipients(Message.RecipientType.TO);
                        String to = rcpts.length > 0 ? rcpts[0].toFriendly().toString() : null;
                        if (to != null) {
                            messageNotice.append(String.format(context.getString(R.string.message_to_fmt), to)).append("": "").append(subject);
                        } else {
                            messageNotice.append(context.getString(R.string.general_no_sender)).append("": "").append(subject);
                        }
                    }
                }
            }
        } catch (MessagingException e) {
            Log.e(K9.LOG_TAG, ""Unable to get message information for notification."", e);
        }

        // If privacy mode active and keyguard active
        // OR
        // If we could not set a per-message notification, revert to a default message
        if ((K9.keyguardPrivacy() && keyguardService.inKeyguardRestrictedInputMode()) || messageNotice.length() == 0) {
            messageNotice = new StringBuilder(context.getString(R.string.notification_new_title));
        }

        NotificationManager notifMgr =
            (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
        Notification notif = new Notification(R.drawable.stat_notify_email_generic, messageNotice, System.currentTimeMillis());
        final int unreadCount = previousUnreadMessageCount + newMessageCount.get();
        if (account.isNotificationShowsUnreadCount()) {
            notif.number = unreadCount;
        }

        Intent i = FolderList.actionHandleNotification(context, account, message.getFolder().getName());
        PendingIntent pi = PendingIntent.getActivity(context, 0, i, 0);

        String accountDescr = (account.getDescription() != null) ? account.getDescription() : account.getEmail();
        String accountNotice = context.getString(R.string.notification_new_one_account_fmt, unreadCount, accountDescr);
        notif.setLatestEventInfo(context, accountNotice, messageNotice, pi);

        // Only ring or vibrate if we have not done so already on this
        // account and fetch
        boolean ringAndVibrate = false;
        if (!account.isRingNotified()) {
            account.setRingNotified(true);
            ringAndVibrate = true;
        }

        NotificationSetting n = account.getNotificationSetting();

        configureNotification(notif, (n.shouldRing() ?  n.getRingtone() : null), (n.shouldVibrate() ? n.getVibration() : null), (n.isLed() ?  n.getLedColor()  : null), K9.NOTIFICATION_LED_BLINK_SLOW, ringAndVibrate);

        notifMgr.notify(account.getAccountNumber(), notif);
    }

    /**
     * @param notification
     *            Object to configure. Never <code>null</code>.
     * @param ringtone
     *          String name of ringtone. <code>null</code> if no ringtone should be played
     * @param vibrationPattern
     *         <code>long[]</code> vibration pattern. <code>null</code> if no vibration should be played
     * @param ledColor
     *         <code>Integer</code> Color to flash LED. <code>null</code> if no LED flash should happen
     * @param ledSpeed
     *         <code>int</code> should LEDs flash K9.NOTIFICATION_LED_BLINK_SLOW or K9.NOTIFICATION_LED_BLINK_FAST
     * @param ringAndVibrate
     *            <code>true</code> if ringtone/vibration are allowed,
     *            <code>false</code> otherwise.
     */
    private void configureNotification(final Notification notification,
                                       final String ringtone,
                                       final long[] vibrationPattern,
                                       final Integer ledColor,
                                       final int ledSpeed,

                                       final boolean ringAndVibrate) {

        // if it's quiet time, then we shouldn't be ringing, buzzing or flashing
        if (K9.isQuietTime()) {
            return;
        }

        if (ringAndVibrate) {
            if (ringtone != null) {
                notification.sound = TextUtils.isEmpty(ringtone) ? null : Uri.parse(ringtone);
                notification.audioStreamType = AudioManager.STREAM_NOTIFICATION;
            }
            if (vibrationPattern != null) {
                notification.vibrate = vibrationPattern;
            }
        }

        if (ledColor != null) {
            notification.flags |= Notification.FLAG_SHOW_LIGHTS;
            notification.ledARGB = ledColor;
            if (ledSpeed == K9.NOTIFICATION_LED_BLINK_SLOW) {
                notification.ledOnMS = K9.NOTIFICATION_LED_ON_TIME;
                notification.ledOffMS = K9.NOTIFICATION_LED_OFF_TIME;
            } else if (ledSpeed == K9.NOTIFICATION_LED_BLINK_FAST) {
                notification.ledOnMS = K9.NOTIFICATION_LED_FAST_ON_TIME;
                notification.ledOffMS = K9.NOTIFICATION_LED_FAST_OFF_TIME;
            }
        }
    }

    /** Cancel a notification of new email messages */
    public void notifyAccountCancel(Context context, Account account) {
        NotificationManager notifMgr =
            (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
        notifMgr.cancel(account.getAccountNumber());
        notifMgr.cancel(-1000 - account.getAccountNumber());
    }

    /**
     * Save a draft message.
     * @param account Account we are saving for.
     * @param message Message to save.
     * @return Message representing the entry in the local store.
     */
    public Message saveDraft(final Account account, final Message message) {
        Message localMessage = null;
        try {
            LocalStore localStore = account.getLocalStore();
            LocalFolder localFolder = localStore.getFolder(account.getDraftsFolderName());
            localFolder.open(OpenMode.READ_WRITE);
            // Save the message to the store.
            localFolder.appendMessages(new Message[] {
                                           message
                                       });
            // Fetch the message back from the store.  This is the Message that's returned to the caller.
            localMessage = localFolder.getMessage(message.getUid());
            localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);

            PendingCommand command = new PendingCommand();
            command.command = PENDING_COMMAND_APPEND;
            command.arguments = new String[] {
                localFolder.getName(),
                localMessage.getUid()
            };
            queuePendingCommand(account, command);
            processPendingCommands(account);

        } catch (MessagingException e) {
            Log.e(K9.LOG_TAG, ""Unable to save message as draft."", e);
            addErrorMessage(account, null, e);
        }
        return localMessage;
    }

    public boolean modeMismatch(Account.FolderMode aMode, Folder.FolderClass fMode) {
        if (aMode == Account.FolderMode.NONE
                || (aMode == Account.FolderMode.FIRST_CLASS &&
                    fMode != Folder.FolderClass.FIRST_CLASS)
                || (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
                    fMode != Folder.FolderClass.FIRST_CLASS &&
                    fMode != Folder.FolderClass.SECOND_CLASS)
                || (aMode == Account.FolderMode.NOT_SECOND_CLASS &&
                    fMode == Folder.FolderClass.SECOND_CLASS)) {
            return true;
        } else {
            return false;
        }
    }

    static AtomicInteger sequencing = new AtomicInteger(0);
    static class Command implements Comparable<Command> {
        public Runnable runnable;

        public MessagingListener listener;

        public String description;

        boolean isForeground;

        int sequence = sequencing.getAndIncrement();

        @Override
        public int compareTo(Command other) {
            if (other.isForeground && !isForeground) {
                return 1;
            } else if (!other.isForeground && isForeground) {
                return -1;
            } else {
                return (sequence - other.sequence);
            }
        }
    }

    public MessagingListener getCheckMailListener() {
        return checkMailListener;
    }

    public void setCheckMailListener(MessagingListener checkMailListener) {
        if (this.checkMailListener != null) {
            removeListener(this.checkMailListener);
        }
        this.checkMailListener = checkMailListener;
        if (this.checkMailListener != null) {
            addListener(this.checkMailListener);
        }
    }

    public SORT_TYPE getSortType() {
        return sortType;
    }

    public void setSortType(SORT_TYPE sortType) {
        this.sortType = sortType;
    }

    public boolean isSortAscending(SORT_TYPE sortType) {
        Boolean sortAsc = sortAscending.get(sortType);
        if (sortAsc == null) {
            return sortType.isDefaultAscending();
        } else return sortAsc;
    }

    public void setSortAscending(SORT_TYPE sortType, boolean nsortAscending) {
        sortAscending.put(sortType, nsortAscending);
    }

    public Collection<Pusher> getPushers() {
        return pushers.values();
    }

    public boolean setupPushing(final Account account) {
        try {
            Pusher previousPusher = pushers.remove(account);
            if (previousPusher != null) {
                previousPusher.stop();
            }
            Preferences prefs = Preferences.getPreferences(mApplication);

            Account.FolderMode aDisplayMode = account.getFolderDisplayMode();
            Account.FolderMode aPushMode = account.getFolderPushMode();

            List<String> names = new ArrayList<String>();

            Store localStore = account.getLocalStore();
            for (final Folder folder : localStore.getPersonalNamespaces(false)) {
                if (folder.getName().equals(account.getErrorFolderName())
                        || folder.getName().equals(account.getOutboxFolderName())) {
                    /*
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""Not pushing folder "" + folder.getName() +
                              "" which should never be pushed"");
                    */

                    continue;
                }
                folder.open(Folder.OpenMode.READ_WRITE);
                folder.refresh(prefs);

                Folder.FolderClass fDisplayClass = folder.getDisplayClass();
                Folder.FolderClass fPushClass = folder.getPushClass();

                if (modeMismatch(aDisplayMode, fDisplayClass)) {
                    // Never push a folder that isn't displayed
                    /*
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""Not pushing folder "" + folder.getName() +
                              "" which is in display class "" + fDisplayClass + "" while account is in display mode "" + aDisplayMode);
                    */

                    continue;
                }

                if (modeMismatch(aPushMode, fPushClass)) {
                    // Do not push folders in the wrong class
                    /*
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""Not pushing folder "" + folder.getName() +
                              "" which is in push mode "" + fPushClass + "" while account is in push mode "" + aPushMode);
                    */

                    continue;
                }
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Starting pusher for "" + account.getDescription() + "":"" + folder.getName());

                names.add(folder.getName());
            }

            if (names.size() > 0) {
                PushReceiver receiver = new MessagingControllerPushReceiver(mApplication, account, this);
                int maxPushFolders = account.getMaxPushFolders();

                if (names.size() > maxPushFolders) {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Count of folders to push for account "" + account.getDescription() + "" is "" + names.size()
                              + "", greater than limit of "" + maxPushFolders + "", truncating"");

                    names = names.subList(0, maxPushFolders);
                }

                try {
                    Store store = account.getRemoteStore();
                    if (!store.isPushCapable()) {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Account "" + account.getDescription() + "" is not push capable, skipping"");

                        return false;
                    }
                    Pusher pusher = store.getPusher(receiver);
                    if (pusher != null) {
                        Pusher oldPusher  = pushers.putIfAbsent(account, pusher);
                        if (oldPusher == null) {
                            pusher.start(names);
                        }
                    }
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Could not get remote store"", e);
                    return false;
                }

                return true;
            } else {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""No folders are configured for pushing in account "" + account.getDescription());
                return false;
            }

        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Got exception while setting up pushing"", e);
        }
        return false;
    }

    public void stopAllPushing() {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Stopping all pushers"");

        Iterator<Pusher> iter = pushers.values().iterator();
        while (iter.hasNext()) {
            Pusher pusher = iter.next();
            iter.remove();
            pusher.stop();
        }
    }

    public void messagesArrived(final Account account, final Folder remoteFolder, final List<Message> messages, final boolean flagSyncOnly) {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Got new pushed email messages for account "" + account.getDescription()
                  + "", folder "" + remoteFolder.getName());

        final CountDownLatch latch = new CountDownLatch(1);
        putBackground(""Push messageArrived of account "" + account.getDescription()
        + "", folder "" + remoteFolder.getName(), null, new Runnable() {
            @Override
            public void run() {
                LocalFolder localFolder = null;
                try {
                    LocalStore localStore = account.getLocalStore();
                    localFolder = localStore.getFolder(remoteFolder.getName());
                    localFolder.open(OpenMode.READ_WRITE);

                    account.setRingNotified(false);
                    int newCount = downloadMessages(account, remoteFolder, localFolder, messages, flagSyncOnly);
                    int unreadMessageCount = setLocalUnreadCountToRemote(localFolder, remoteFolder,  messages.size());

                    setLocalFlaggedCountToRemote(localFolder, remoteFolder);

                    localFolder.setLastPush(System.currentTimeMillis());
                    localFolder.setStatus(null);

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""messagesArrived newCount = "" + newCount + "", unread count = "" + unreadMessageCount);

                    if (unreadMessageCount == 0) {
                        notifyAccountCancel(mApplication, account);
                    }

                    for (MessagingListener l : getListeners()) {
                        l.folderStatusChanged(account, remoteFolder.getName(), unreadMessageCount);
                    }

                } catch (Exception e) {
                    String rootMessage = getRootCauseMessage(e);
                    String errorMessage = ""Push failed: "" + rootMessage;
                    try {
                        // Oddly enough, using a local variable gets rid of a
                        // potential null pointer access warning with Eclipse.
                        LocalFolder folder = localFolder;
                        folder.setStatus(errorMessage);
                    } catch (Exception se) {
                        Log.e(K9.LOG_TAG, ""Unable to set failed status on localFolder"", se);
                    }
                    for (MessagingListener l : getListeners()) {
                        l.synchronizeMailboxFailed(account, remoteFolder.getName(), errorMessage);
                    }
                    addErrorMessage(account, null, e);
                } finally {
                    closeFolder(localFolder);
                    latch.countDown();
                }

            }
        });
        try {
            latch.await();
        } catch (Exception e) {
            Log.e(K9.LOG_TAG, ""Interrupted while awaiting latch release"", e);
        }
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""MessagingController.messagesArrivedLatch released"");
    }

    public void systemStatusChanged() {
        for (MessagingListener l : getListeners()) {
            l.systemStatusChanged();
        }
    }

    enum MemorizingState { STARTED, FINISHED, FAILED }

    static class Memory {
        Account account;
        String folderName;
        MemorizingState syncingState = null;
        MemorizingState sendingState = null;
        MemorizingState pushingState = null;
        MemorizingState processingState = null;
        String failureMessage = null;

        int syncingTotalMessagesInMailbox;
        int syncingNumNewMessages;

        int folderCompleted = 0;
        int folderTotal = 0;
        String processingCommandTitle = null;

        Memory(Account nAccount, String nFolderName) {
            account = nAccount;
            folderName = nFolderName;
        }

        String getKey() {
            return getMemoryKey(account, folderName);
        }


    }
    static String getMemoryKey(Account taccount, String tfolderName) {
        return taccount.getDescription() + "":"" + tfolderName;
    }
    static class MemorizingListener extends MessagingListener {
        HashMap<String, Memory> memories = new HashMap<String, Memory>(31);

        Memory getMemory(Account account, String folderName) {
            Memory memory = memories.get(getMemoryKey(account, folderName));
            if (memory == null) {
                memory = new Memory(account, folderName);
                memories.put(memory.getKey(), memory);
            }
            return memory;
        }

        @Override
        public synchronized void synchronizeMailboxStarted(Account account, String folder) {
            Memory memory = getMemory(account, folder);
            memory.syncingState = MemorizingState.STARTED;
            memory.folderCompleted = 0;
            memory.folderTotal = 0;
        }

        @Override
        public synchronized void synchronizeMailboxFinished(Account account, String folder,
                int totalMessagesInMailbox, int numNewMessages) {
            Memory memory = getMemory(account, folder);
            memory.syncingState = MemorizingState.FINISHED;
            memory.syncingTotalMessagesInMailbox = totalMessagesInMailbox;
            memory.syncingNumNewMessages = numNewMessages;
        }

        @Override
        public synchronized void synchronizeMailboxFailed(Account account, String folder,
                String message) {

            Memory memory = getMemory(account, folder);
            memory.syncingState = MemorizingState.FAILED;
            memory.failureMessage = message;
        }
        synchronized void refreshOther(MessagingListener other) {
            if (other != null) {

                Memory syncStarted = null;
                Memory sendStarted = null;
                Memory processingStarted = null;

                for (Memory memory : memories.values()) {

                    if (memory.syncingState != null) {
                        switch (memory.syncingState) {
                        case STARTED:
                            syncStarted = memory;
                            break;
                        case FINISHED:
                            other.synchronizeMailboxFinished(memory.account, memory.folderName,
                                                             memory.syncingTotalMessagesInMailbox, memory.syncingNumNewMessages);
                            break;
                        case FAILED:
                            other.synchronizeMailboxFailed(memory.account, memory.folderName,
                                                           memory.failureMessage);
                            break;
                        }
                    }

                    if (memory.sendingState != null) {
                        switch (memory.sendingState) {
                        case STARTED:
                            sendStarted = memory;
                            break;
                        case FINISHED:
                            other.sendPendingMessagesCompleted(memory.account);
                            break;
                        case FAILED:
                            other.sendPendingMessagesFailed(memory.account);
                            break;
                        }
                    }
                    if (memory.pushingState != null) {
                        switch (memory.pushingState) {
                        case STARTED:
                            other.setPushActive(memory.account, memory.folderName, true);
                            break;
                        case FINISHED:
                            other.setPushActive(memory.account, memory.folderName, false);
                            break;
                        }
                    }
                    if (memory.processingState != null) {
                        switch (memory.processingState) {
                        case STARTED:
                            processingStarted = memory;
                            break;
                        case FINISHED:
                        case FAILED:
                            other.pendingCommandsFinished(memory.account);
                            break;
                        }
                    }
                }
                Memory somethingStarted = null;
                if (syncStarted != null) {
                    other.synchronizeMailboxStarted(syncStarted.account, syncStarted.folderName);
                    somethingStarted = syncStarted;
                }
                if (sendStarted != null) {
                    other.sendPendingMessagesStarted(sendStarted.account);
                    somethingStarted = sendStarted;
                }
                if (processingStarted != null) {
                    other.pendingCommandsProcessing(processingStarted.account);
                    if (processingStarted.processingCommandTitle != null) {
                        other.pendingCommandStarted(processingStarted.account, processingStarted.processingCommandTitle);

                    } else {
                        other.pendingCommandCompleted(processingStarted.account, processingStarted.processingCommandTitle);
                    }
                    somethingStarted = processingStarted;
                }
                if (somethingStarted != null && somethingStarted.folderTotal > 0) {
                    other.synchronizeMailboxProgress(somethingStarted.account, somethingStarted.folderName, somethingStarted.folderCompleted, somethingStarted.folderTotal);
                }

            }
        }
        @Override
        public synchronized void setPushActive(Account account, String folderName, boolean active) {
            Memory memory = getMemory(account, folderName);
            memory.pushingState = (active ? MemorizingState.STARTED : MemorizingState.FINISHED);
        }

        @Override
        public synchronized void sendPendingMessagesStarted(Account account) {
            Memory memory = getMemory(account, null);
            memory.sendingState = MemorizingState.STARTED;
            memory.folderCompleted = 0;
            memory.folderTotal = 0;
        }

        @Override
        public synchronized void sendPendingMessagesCompleted(Account account) {
            Memory memory = getMemory(account, null);
            memory.sendingState = MemorizingState.FINISHED;
        }

        @Override
        public synchronized void sendPendingMessagesFailed(Account account) {
            Memory memory = getMemory(account, null);
            memory.sendingState = MemorizingState.FAILED;
        }


        @Override
        public synchronized void synchronizeMailboxProgress(Account account, String folderName, int completed, int total) {
            Memory memory = getMemory(account, folderName);
            memory.folderCompleted = completed;
            memory.folderTotal = total;
        }


        @Override
        public synchronized void pendingCommandsProcessing(Account account) {
            Memory memory = getMemory(account, null);
            memory.processingState = MemorizingState.STARTED;
            memory.folderCompleted = 0;
            memory.folderTotal = 0;
        }
        @Override
        public synchronized void pendingCommandsFinished(Account account) {
            Memory memory = getMemory(account, null);
            memory.processingState = MemorizingState.FINISHED;
        }
        @Override
        public synchronized void pendingCommandStarted(Account account, String commandTitle) {
            Memory memory = getMemory(account, null);
            memory.processingCommandTitle = commandTitle;
        }

        @Override
        public synchronized void pendingCommandCompleted(Account account, String commandTitle) {
            Memory memory = getMemory(account, null);
            memory.processingCommandTitle = null;
        }

    }

    private void actOnMessages(Message[] messages, MessageActor actor) {
        Map<Account, Map<Folder, List<Message>>> accountMap = new HashMap<Account, Map<Folder, List<Message>>>();

        for (Message message : messages) {
            Folder folder = message.getFolder();
            Account account = folder.getAccount();

            Map<Folder, List<Message>> folderMap = accountMap.get(account);
            if (folderMap == null) {
                folderMap = new HashMap<Folder, List<Message>>();
                accountMap.put(account, folderMap);
            }
            List<Message> messageList = folderMap.get(folder);
            if (messageList == null) {
                messageList = new LinkedList<Message>();
                folderMap.put(folder, messageList);
            }

            messageList.add(message);
        }
        for (Map.Entry<Account, Map<Folder, List<Message>>> entry : accountMap.entrySet()) {
            Account account = entry.getKey();

            //account.refresh(Preferences.getPreferences(K9.app));
            Map<Folder, List<Message>> folderMap = entry.getValue();
            for (Map.Entry<Folder, List<Message>> folderEntry : folderMap.entrySet()) {
                Folder folder = folderEntry.getKey();
                List<Message> messageList = folderEntry.getValue();
                actor.act(account, folder, messageList);
            }
        }
    }

    interface MessageActor {
        public void act(final Account account, final Folder folder, final List<Message> messages);
    }
}
",True,145,1,1,5,53,15,31,L1
163,com.fsck.k9.controller.MessagingListener.java,"
package com.fsck.k9.controller;

import android.content.Context;
import com.fsck.k9.Account;
import com.fsck.k9.AccountStats;
import com.fsck.k9.BaseAccount;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.Part;

import java.util.List;

/**
 * Defines the interface that MessagingController will use to callback to requesters. This class
 * is defined as non-abstract so that someone who wants to receive only a few messages can
 * do so without implementing the entire interface. It is highly recommended that users of
 * this interface use the @Override annotation in their implementations to avoid being caught by
 * changes in this class.
 */
public class MessagingListener {
    public void searchStats(AccountStats stats) {}

    public void accountStatusChanged(BaseAccount account, AccountStats stats) {
    }

    public void accountSizeChanged(Account account, long oldSize, long newSize) {
    }

    public void listFoldersStarted(Account account) {
    }

    public void listFolders(Account account, Folder[] folders) {
    }

    public void listFoldersFailed(Account account, String message) {
    }

    public void listFoldersFinished(Account account) {
    }

    public void listLocalMessagesStarted(Account account, String folder) {
    }

    public void listLocalMessages(Account account, String folder, Message[] messages) {
    }

    public void listLocalMessagesAddMessages(Account account, String folder, List<Message> messages) {
    }

    public void listLocalMessagesUpdateMessage(Account account, String folder, Message message) {
    }

    public void listLocalMessagesRemoveMessage(Account account, String folder, Message message) {
    }

    public void listLocalMessagesFailed(Account account, String folder, String message) {
    }

    public void listLocalMessagesFinished(Account account, String folder) {
    }

    public void synchronizeMailboxStarted(Account account, String folder) {
    }

    public void synchronizeMailboxHeadersStarted(Account account, String folder) {
    }

    public void synchronizeMailboxHeadersProgress(Account account, String folder, int completed, int total) {
    }

    public void synchronizeMailboxHeadersFinished(Account account, String folder,
            int totalMessagesInMailbox, int numNewMessages) {
    }


    public void synchronizeMailboxProgress(Account account, String folder, int completed, int total)
    {}

    public void synchronizeMailboxNewMessage(Account account, String folder, Message message) {
    }

    public void synchronizeMailboxAddOrUpdateMessage(Account account, String folder, Message message) {
    }

    public void synchronizeMailboxRemovedMessage(Account account, String folder, Message message) {
    }

    public void synchronizeMailboxFinished(Account account, String folder,
                                           int totalMessagesInMailbox, int numNewMessages) {
    }

    public void synchronizeMailboxFailed(Account account, String folder,
                                         String message) {
    }

    public void loadMessageForViewStarted(Account account, String folder, String uid) {
    }

    public void loadMessageForViewHeadersAvailable(Account account, String folder, String uid,
            Message message) {
    }

    public void loadMessageForViewBodyAvailable(Account account, String folder, String uid,
            Message message) {
    }

    public void loadMessageForViewFinished(Account account, String folder, String uid,
                                           Message message) {
    }

    public void loadMessageForViewFailed(Account account, String folder, String uid, Throwable t) {
    }

    public void checkMailStarted(Context context, Account account) {
    }

    public void checkMailFinished(Context context, Account account) {
    }

    public void checkMailFailed(Context context, Account account, String reason) {
    }

    public void sendPendingMessagesStarted(Account account) {
    }

    public void sendPendingMessagesCompleted(Account account) {
    }

    public void sendPendingMessagesFailed(Account account) {
    }

    public void messageDeleted(Account account, String folder, Message message) {

    }
    public void emptyTrashCompleted(Account account) {
    }

    public void folderStatusChanged(Account account, String folderName, int unreadMessageCount) {
    }

    public void folderStatusChanged(Account account, String folderName) {
    }

    public void systemStatusChanged() {
    }

    public void messageUidChanged(Account account, String folder, String oldUid, String newUid) {

    }

    public void setPushActive(Account account, String folderName, boolean enabled) {

    }

    public void loadAttachmentStarted(
        Account account,
        Message message,
        Part part,
        Object tag,
        boolean requiresDownload) {
    }

    public void loadAttachmentFinished(
        Account account,
        Message message,
        Part part,
        Object tag) {
    }

    public void loadAttachmentFailed(
        Account account,
        Message message,
        Part part,
        Object tag,
        String reason) {
    }

    public void pendingCommandsProcessing(Account account) {}
    public void pendingCommandsFinished(Account account) {}
    public void pendingCommandStarted(Account account, String commandTitle)
    {}

    public void pendingCommandCompleted(Account account, String commandTitle)
    {}

    /**
     * General notification messages subclasses can override to be notified that the controller
     * has completed a command. This is useful for turning off progress indicators that may have
     * been left over from previous commands.
     * @param moreCommandsToRun True if the controller will continue on to another command
     * immediately.
     */
    public void controllerCommandCompleted(boolean moreCommandsToRun) {

    }
}
",False,145,1,1,7,38,14,6,L1
