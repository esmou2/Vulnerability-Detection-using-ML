,file_path,source_code,is_vulnerable, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,com.fsck.k9.K9Activity.java,"package com.fsck.k9;


import android.app.Activity;
import android.os.Bundle;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.widget.ScrollView;

import com.fsck.k9.activity.DateFormatter;


public class K9Activity extends Activity
{
    private GestureDetector gestureDetector;

    protected ScrollView mTopView;
    
    @Override
    public void onCreate(Bundle icicle)
    {
        setTheme(K9.getK9Theme());
        super.onCreate(icicle);
        setupFormats();

        // Gesture detection
        gestureDetector = new GestureDetector(new MyGestureDetector());

    }
    @Override
    public boolean dispatchTouchEvent(MotionEvent ev)
    {
        super.dispatchTouchEvent(ev);
        return gestureDetector.onTouchEvent(ev);
    }

    @Override
    public void onResume()
    {
        super.onResume();
        setupFormats();
    }

    private java.text.DateFormat mDateFormat;
    private java.text.DateFormat mTimeFormat;

    private void setupFormats()
    {

        mDateFormat = DateFormatter.getDateFormat(this);
        mTimeFormat = android.text.format.DateFormat.getTimeFormat(this);   // 12/24 date format
    }

    public java.text.DateFormat getTimeFormat()
    {
        return mTimeFormat;
    }

    public java.text.DateFormat getDateFormat()
    {
        return mDateFormat;
    }
    protected void onNext(boolean animate)
    {
        
    }
    protected void onPrevious(boolean animate)
    {
    }

    class MyGestureDetector extends SimpleOnGestureListener
    {

        private static final float SWIPE_MIN_DISTANCE_DIP = 130.0f;
        private static final float SWIPE_MAX_OFF_PATH_DIP = 250f;
        private static final float SWIPE_THRESHOLD_VELOCITY_DIP = 325f;
        
        @Override
        public boolean onDoubleTap(MotionEvent ev)
        {
            super.onDoubleTap(ev);
            if (mTopView != null)
            {
                int height = getResources().getDisplayMetrics().heightPixels;
                if (ev.getRawY() < (height/4))
                {
                    mTopView.fullScroll(mTopView.FOCUS_UP);
    
                }
                else if (ev.getRawY() > (height - height/4))
                {
                    mTopView.fullScroll(mTopView.FOCUS_DOWN);
    
                }
            }
            return false;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)
        {
            if (K9.gesturesEnabled())
            {
                // Convert the dips to pixels
                final float mGestureScale = getResources().getDisplayMetrics().density;
                int min_distance = (int)(SWIPE_MIN_DISTANCE_DIP * mGestureScale + 0.5f);
                int min_velocity = (int)(SWIPE_THRESHOLD_VELOCITY_DIP * mGestureScale + 0.5f);
                int max_off_path = (int)(SWIPE_MAX_OFF_PATH_DIP * mGestureScale + 0.5f);
    
    
                try
                {
                    if (Math.abs(e1.getY() - e2.getY()) > max_off_path)
                        return false;
                    // right to left swipe
                    if (e1.getX() - e2.getX() > min_distance && Math.abs(velocityX) > min_velocity)
                    {
                        onNext(true);
                    }
                    else if (e2.getX() - e1.getX() > min_distance && Math.abs(velocityX) > min_velocity)
                    {
                        onPrevious(true);
                    }
                }
                catch (Exception e)
                {
                    // nothing
                }
            }
            return false;
        }


    }

}
",True,189,0,0,9,52,12,2,L1
1,com.fsck.k9.Utility.java,"
package com.fsck.k9;

import android.text.Editable;
import android.widget.EditText;
import android.widget.TextView;
import com.fsck.k9.codec.binary.Base64;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.util.Date;

public class Utility
{
    public final static String readInputStream(InputStream in, String encoding) throws IOException
    {
        InputStreamReader reader = new InputStreamReader(in, encoding);
        StringBuffer sb = new StringBuffer();
        int count;
        char[] buf = new char[512];
        while ((count = reader.read(buf)) != -1)
        {
            sb.append(buf, 0, count);
        }
        return sb.toString();
    }

    public final static boolean arrayContains(Object[] a, Object o)
    {
        for (int i = 0, count = a.length; i < count; i++)
        {
            if (a[i].equals(o))
            {
                return true;
            }
        }
        return false;
    }

    /**
     * Combines the given array of Objects into a single string using the
     * seperator character and each Object's toString() method. between each
     * part.
     *
     * @param parts
     * @param seperator
     * @return
     */
    public static String combine(Object[] parts, char seperator)
    {
        if (parts == null)
        {
            return null;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < parts.length; i++)
        {
            sb.append(parts[i].toString());
            if (i < parts.length - 1)
            {
                sb.append(seperator);
            }
        }
        return sb.toString();
    }

    public static String base64Decode(String encoded)
    {
        if (encoded == null)
        {
            return null;
        }
        byte[] decoded = new Base64().decode(encoded.getBytes());
        return new String(decoded);
    }

    public static String base64Encode(String s)
    {
        if (s == null)
        {
            return s;
        }
        byte[] encoded = new Base64().encode(s.getBytes());
        return new String(encoded);
    }

    public static boolean requiredFieldValid(TextView view)
    {
        return view.getText() != null && view.getText().length() > 0;
    }


    public static boolean requiredFieldValid(Editable s)
    {
        return s != null && s.length() > 0;
    }

    public static boolean domainFieldValid(EditText view)
    {
        if (view.getText() != null)
        {
            String s = view.getText().toString();
            if (s.matches(""^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}$""))
            {
                return true;
            }
            if (s.matches(""^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$""))
            {
                return true;
            }
            if ((s.equalsIgnoreCase(""localhost""))||(s.equalsIgnoreCase(""localhost.localdomain"")))
            {
                return true;
            }
        }
        return false;
    }

    /**
     * Ensures that the given string starts and ends with the double quote character. The string is not modified in any way except to add the
     * double quote character to start and end if it's not already there.
     * sample -> ""sample""
     * ""sample"" -> ""sample""
     * """"sample"""" -> ""sample""
     * ""sample"""" -> ""sample""
     * sa""mp""le -> ""sa""mp""le""
     * ""sa""mp""le"" -> ""sa""mp""le""
     * (empty string) -> """"
     * "" -> """"
     * @param s
     * @return
     */
    public static String quoteString(String s)
    {
        if (s == null)
        {
            return null;
        }
        if (!s.matches(""^\"".*\""$""))
        {
            return ""\"""" + s + ""\"""";
        }
        else
        {
            return s;
        }
    }

    /**
     * A fast version of  URLDecoder.decode() that works only with UTF-8 and does only two
     * allocations. This version is around 3x as fast as the standard one and I'm using it
     * hundreds of times in places that slow down the UI, so it helps.
     */
    public static String fastUrlDecode(String s)
    {
        try
        {
            byte[] bytes = s.getBytes(""UTF-8"");
            byte ch;
            int length = 0;
            for (int i = 0, count = bytes.length; i < count; i++)
            {
                ch = bytes[i];
                if (ch == '%')
                {
                    int h = (bytes[i + 1] - '0');
                    int l = (bytes[i + 2] - '0');
                    if (h > 9)
                    {
                        h -= 7;
                    }
                    if (l > 9)
                    {
                        l -= 7;
                    }
                    bytes[length] = (byte)((h << 4) | l);
                    i += 2;
                }
                else if (ch == '+')
                {
                    bytes[length] = ' ';
                }
                else
                {
                    bytes[length] = bytes[i];
                }
                length++;
            }
            return new String(bytes, 0, length, ""UTF-8"");
        }
        catch (UnsupportedEncodingException uee)
        {
            return null;
        }
    }

    /**
     * Returns true if the specified date is within 18 hours of ""now"". Returns false otherwise.
     * @param date
     * @return
     */
    public static boolean isDateToday(Date date)
    {
        Date now = new Date();
        if (now.getTime() - 64800000 > date.getTime() || now.getTime() + 64800000 < date.getTime())
        {
            return false;
        }
        else
        {
            return true;
        }
    }

    /*
     * TODO disabled this method globally. It is used in all the settings screens but I just
     * noticed that an unrelated icon was dimmed. Android must share drawables internally.
     */
    public static void setCompoundDrawablesAlpha(TextView view, int alpha)
    {
//        Drawable[] drawables = view.getCompoundDrawables();
//        for (Drawable drawable : drawables) {
//            if (drawable != null) {
//                drawable.setAlpha(alpha);
//            }
//        }
    }

}
",True,74,4,36,1,1,15,1,L1
2,com.fsck.k9.Preferences.java,"
package com.fsck.k9;

import java.util.ArrayList;
import java.util.List;
import android.content.Context;
import android.content.SharedPreferences;
import android.util.Config;
import android.util.Log;
import com.fsck.k9.preferences.Editor;
import com.fsck.k9.preferences.Storage;

public class Preferences
{
    private static Preferences preferences;

    /**
     * TODO need to think about what happens if this gets GCed along with the
     * Activity that initialized it. Do we lose ability to read Preferences in
     * further Activities? Maybe this should be stored in the Application
     * context.
     */
    public static synchronized Preferences getPreferences(Context context)
    {
        if (preferences == null)
        {
            preferences = new Preferences(context);
        }
        return preferences;
    }


    private Storage mStorage;
    private List<Account> accounts;
    private Account newAccount;

    private Preferences(Context context)
    {
        mStorage = Storage.getStorage(context);
        if (mStorage.size() == 0)
        {
            Log.i(K9.LOG_TAG, ""Preferences storage is zero-size, importing from Android-style preferences"");
            Editor editor = mStorage.edit();
            editor.copy(context.getSharedPreferences(""AndroidMail.Main"", Context.MODE_PRIVATE));
            editor.commit();
        }
    }

    private synchronized void loadAccounts()
    {
        String accountUuids = getPreferences().getString(""accountUuids"", null);
        if ((accountUuids != null) && (accountUuids.length() != 0))
        {
            String[] uuids = accountUuids.split("","");
            accounts = new ArrayList<Account>(uuids.length);
            for (int i = 0, length = uuids.length; i < length; i++)
            {
                accounts.add(new Account(this, uuids[i]));
            }
        }
        else
        {
            accounts = new ArrayList<Account>();
        }
    }

    /**
     * Returns an array of the accounts on the system. If no accounts are
     * registered the method returns an empty array.
     */
    public synchronized Account[] getAccounts()
    {
        if (accounts == null)
        {
            loadAccounts();
        }

        if ((newAccount != null) && newAccount.getAccountNumber() != -1)
        {
            accounts.add(newAccount);
            newAccount = null;
        }

        return accounts.toArray(new Account[0]);
    }

    public synchronized Account getAccount(String uuid)
    {
        if (accounts == null)
        {
            loadAccounts();
        }

        for (Account account : accounts)
        {
            if (account.getUuid().equals(uuid))
            {
                return account;
            }
        }

        if ((newAccount != null) && newAccount.getUuid().equals(uuid))
        {
            return newAccount;
        }

        return null;
    }

    public synchronized Account newAccount()
    {
        newAccount = new Account(K9.app);

        return newAccount;
    }

    public synchronized void deleteAccount(Account account)
    {
        accounts.remove(account);
        account.delete(this);

        if (newAccount == account)
        {
            newAccount = null;
        }
    }

    /**
     * Returns the Account marked as default. If no account is marked as default
     * the first account in the list is marked as default and then returned. If
     * there are no accounts on the system the method returns null.
     */
    public Account getDefaultAccount()
    {
        String defaultAccountUuid = getPreferences().getString(""defaultAccountUuid"", null);
        Account defaultAccount = getAccount(defaultAccountUuid);

        if (defaultAccount == null)
        {
            Account[] accounts = getAccounts();
            if (accounts.length > 0)
            {
                defaultAccount = accounts[0];
                setDefaultAccount(defaultAccount);
            }
        }

        return defaultAccount;
    }

    public void setDefaultAccount(Account account)
    {
        getPreferences().edit().putString(""defaultAccountUuid"", account.getUuid()).commit();
    }

    public void dump()
    {
        if (Config.LOGV)
        {
            for (String key : getPreferences().getAll().keySet())
            {
                Log.v(K9.LOG_TAG, key + "" = "" + getPreferences().getAll().get(key));
            }
        }
    }

    public SharedPreferences getPreferences()
    {
        return mStorage;
    }
}
",True,191,1,2,8,46,29,4,L1
3,com.fsck.k9.Account.java,"
package com.fsck.k9;

import android.content.Context;
import android.content.SharedPreferences;
import android.net.ConnectivityManager;
import android.net.Uri;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Account stores all of the settings for a single account defined by the user. It is able to save
 * and delete itself given a Preferences to work with. Each account is defined by a UUID.
 */
public class Account
{
    public static final String EXPUNGE_IMMEDIATELY = ""EXPUNGE_IMMEDIATELY"";
    public static final String EXPUNGE_MANUALLY = ""EXPUNGE_MANUALLY"";
    public static final String EXPUNGE_ON_POLL = ""EXPUNGE_ON_POLL"";

    public static final int DELETE_POLICY_NEVER = 0;
    public static final int DELETE_POLICY_7DAYS = 1;
    public static final int DELETE_POLICY_ON_DELETE = 2;
    public static final int DELETE_POLICY_MARK_AS_READ = 3;
    
    public static final String TYPE_WIFI = ""WIFI"";
    public static final String TYPE_MOBILE = ""MOBILE"";
    public static final String TYPE_OTHER = ""OTHER"";
    private static String[] networkTypes = { TYPE_WIFI, TYPE_MOBILE, TYPE_OTHER };

    /**
     * <pre>
     * 0 - Never (DELETE_POLICY_NEVER)
     * 1 - After 7 days (DELETE_POLICY_7DAYS)
     * 2 - When I delete from inbox (DELETE_POLICY_ON_DELETE)
     * 3 - Mark as read (DELETE_POLICY_MARK_AS_READ)
     * </pre>
     */
    private int mDeletePolicy;

    private String mUuid;
    private String mStoreUri;
    private String mLocalStoreUri;
    private String mTransportUri;
    private String mDescription;
    private String mAlwaysBcc;
    private int mAutomaticCheckIntervalMinutes;
    private int mDisplayCount;
    private long mLastAutomaticCheckTime;
    private boolean mNotifyNewMail;
    private boolean mNotifySelfNewMail;
    private String mDraftsFolderName;
    private String mSentFolderName;
    private String mTrashFolderName;
    private String mOutboxFolderName;
    private String mAutoExpandFolderName;
    private FolderMode mFolderDisplayMode;
    private FolderMode mFolderSyncMode;
    private FolderMode mFolderPushMode;
    private FolderMode mFolderTargetMode;
    private int mAccountNumber;
    private boolean mVibrate;
    private boolean mRing;
    private String mRingtoneUri;
    private boolean mNotifySync;
    private HideButtons mHideMessageViewButtons;
    private boolean mIsSignatureBeforeQuotedText;
    private String mExpungePolicy = EXPUNGE_IMMEDIATELY;
    private int mMaxPushFolders;
    private Map<String, Boolean> compressionMap = new ConcurrentHashMap<String, Boolean>(); 
    // Tracks if we have sent a notification for this account for
    // current set of fetched messages
    private boolean mRingNotified;

    private List<Identity> identities;

    public enum FolderMode
    {
        NONE, ALL, FIRST_CLASS, FIRST_AND_SECOND_CLASS, NOT_SECOND_CLASS;
    }

    public enum HideButtons
    {
        NEVER, ALWAYS, KEYBOARD_AVAILABLE;
    }


    protected Account(Context context)
    {
        // TODO Change local store path to something readable / recognizable
        mUuid = UUID.randomUUID().toString();
        mLocalStoreUri = ""local://localhost/"" + context.getDatabasePath(mUuid + "".db"");
        mAutomaticCheckIntervalMinutes = -1;
        mDisplayCount = -1;
        mAccountNumber = -1;
        mNotifyNewMail = true;
        mNotifySync = true;
        mVibrate = false;
        mRing = true;
        mNotifySelfNewMail = true;
        mFolderDisplayMode = FolderMode.NOT_SECOND_CLASS;
        mFolderSyncMode = FolderMode.FIRST_CLASS;
        mFolderPushMode = FolderMode.FIRST_CLASS;
        mFolderTargetMode = FolderMode.NOT_SECOND_CLASS;
        mHideMessageViewButtons = HideButtons.NEVER;
        mRingtoneUri = ""content://settings/system/notification_sound"";
        mIsSignatureBeforeQuotedText = false;
        mExpungePolicy = EXPUNGE_IMMEDIATELY;
        mAutoExpandFolderName = ""INBOX"";
        mMaxPushFolders = 10;
        
        identities = new ArrayList<Identity>();

        Identity identity = new Identity();
        identity.setSignatureUse(true);
        identity.setSignature(context.getString(R.string.default_signature));
        identity.setDescription(context.getString(R.string.default_identity_description));
        identities.add(identity);
    }

    protected Account(Preferences preferences, String uuid)
    {
        this.mUuid = uuid;
        loadAccount(preferences);
    }

    /**
     * Load stored settings for this account.
     */
    private synchronized void loadAccount(Preferences preferences)
    {
        mStoreUri = Utility.base64Decode(preferences.getPreferences().getString(mUuid
                                         + "".storeUri"", null));
        mLocalStoreUri = preferences.getPreferences().getString(mUuid + "".localStoreUri"", null);
        mTransportUri = Utility.base64Decode(preferences.getPreferences().getString(mUuid
                                             + "".transportUri"", null));
        mDescription = preferences.getPreferences().getString(mUuid + "".description"", null);
        mAlwaysBcc = preferences.getPreferences().getString(mUuid + "".alwaysBcc"", mAlwaysBcc);
        mAutomaticCheckIntervalMinutes = preferences.getPreferences().getInt(mUuid
                                         + "".automaticCheckIntervalMinutes"", -1);
        mDisplayCount = preferences.getPreferences().getInt(mUuid + "".displayCount"", -1);
        mLastAutomaticCheckTime = preferences.getPreferences().getLong(mUuid
                                  + "".lastAutomaticCheckTime"", 0);
        mNotifyNewMail = preferences.getPreferences().getBoolean(mUuid + "".notifyNewMail"",
                         false);
        mNotifySelfNewMail = preferences.getPreferences().getBoolean(mUuid + "".notifySelfNewMail"",
                             true);
        mNotifySync = preferences.getPreferences().getBoolean(mUuid + "".notifyMailCheck"",
                      false);
        mDeletePolicy = preferences.getPreferences().getInt(mUuid + "".deletePolicy"", 0);
        mDraftsFolderName = preferences.getPreferences().getString(mUuid  + "".draftsFolderName"",
                            ""Drafts"");
        mSentFolderName = preferences.getPreferences().getString(mUuid  + "".sentFolderName"",
                          ""Sent"");
        mTrashFolderName = preferences.getPreferences().getString(mUuid  + "".trashFolderName"",
                           ""Trash"");
        mOutboxFolderName = preferences.getPreferences().getString(mUuid  + "".outboxFolderName"",
                            ""Outbox"");
        mExpungePolicy = preferences.getPreferences().getString(mUuid  + "".expungePolicy"", EXPUNGE_IMMEDIATELY);

        mMaxPushFolders = preferences.getPreferences().getInt(mUuid + "".maxPushFolders"", 10);
        
        for (String type : networkTypes)
        {
            Boolean useCompression = preferences.getPreferences().getBoolean(mUuid + "".useCompression."" + type,
                    true);
            compressionMap.put(type, useCompression);
        }

        // Between r418 and r431 (version 0.103), folder names were set empty if the Incoming settings were
        // opened for non-IMAP accounts.  0.103 was never a market release, so perhaps this code
        // should be deleted sometime soon
        if (mDraftsFolderName == null || mDraftsFolderName.equals(""""))
        {
            mDraftsFolderName = ""Drafts"";
        }
        if (mSentFolderName == null || mSentFolderName.equals(""""))
        {
            mSentFolderName = ""Sent"";
        }
        if (mTrashFolderName == null || mTrashFolderName.equals(""""))
        {
            mTrashFolderName = ""Trash"";
        }
        if (mOutboxFolderName == null || mOutboxFolderName.equals(""""))
        {
            mOutboxFolderName = ""Outbox"";
        }
        // End of 0.103 repair

        mAutoExpandFolderName = preferences.getPreferences().getString(mUuid  + "".autoExpandFolderName"",
                                ""INBOX"");

        mAccountNumber = preferences.getPreferences().getInt(mUuid + "".accountNumber"", 0);
        mVibrate = preferences.getPreferences().getBoolean(mUuid + "".vibrate"", false);
        mRing = preferences.getPreferences().getBoolean(mUuid + "".ring"", true);

        try
        {
            mHideMessageViewButtons = HideButtons.valueOf(preferences.getPreferences().getString(mUuid + "".hideButtonsEnum"",
                                      HideButtons.NEVER.name()));
        }
        catch (Exception e)
        {
            mHideMessageViewButtons = HideButtons.NEVER;
        }

        mRingtoneUri = preferences.getPreferences().getString(mUuid  + "".ringtone"",
                       ""content://settings/system/notification_sound"");
        try
        {
            mFolderDisplayMode = FolderMode.valueOf(preferences.getPreferences().getString(mUuid  + "".folderDisplayMode"",
                                                    FolderMode.NOT_SECOND_CLASS.name()));
        }
        catch (Exception e)
        {
            mFolderDisplayMode = FolderMode.NOT_SECOND_CLASS;
        }

        try
        {
            mFolderSyncMode = FolderMode.valueOf(preferences.getPreferences().getString(mUuid  + "".folderSyncMode"",
                                                 FolderMode.FIRST_CLASS.name()));
        }
        catch (Exception e)
        {
            mFolderSyncMode = FolderMode.FIRST_CLASS;
        }

        try
        {
            mFolderPushMode = FolderMode.valueOf(preferences.getPreferences().getString(mUuid  + "".folderPushMode"",
                                                 FolderMode.FIRST_CLASS.name()));
        }
        catch (Exception e)
        {
            mFolderPushMode = FolderMode.FIRST_CLASS;
        }

        try
        {
            mFolderTargetMode = FolderMode.valueOf(preferences.getPreferences().getString(mUuid  + "".folderTargetMode"",
                                                   FolderMode.NOT_SECOND_CLASS.name()));
        }
        catch (Exception e)
        {
            mFolderTargetMode = FolderMode.NOT_SECOND_CLASS;
        }

        mIsSignatureBeforeQuotedText = preferences.getPreferences().getBoolean(mUuid  + "".signatureBeforeQuotedText"", false);
        identities = loadIdentities(preferences.getPreferences());
    }


    protected synchronized void delete(Preferences preferences)
    {
        String[] uuids = preferences.getPreferences().getString(""accountUuids"", """").split("","");
        StringBuffer sb = new StringBuffer();
        for (int i = 0, length = uuids.length; i < length; i++)
        {
            if (!uuids[i].equals(mUuid))
            {
                if (sb.length() > 0)
                {
                    sb.append(',');
                }
                sb.append(uuids[i]);
            }
        }
        String accountUuids = sb.toString();
        SharedPreferences.Editor editor = preferences.getPreferences().edit();
        editor.putString(""accountUuids"", accountUuids);

        editor.remove(mUuid + "".storeUri"");
        editor.remove(mUuid + "".localStoreUri"");
        editor.remove(mUuid + "".transportUri"");
        editor.remove(mUuid + "".description"");
        editor.remove(mUuid + "".name"");
        editor.remove(mUuid + "".email"");
        editor.remove(mUuid + "".alwaysBcc"");
        editor.remove(mUuid + "".automaticCheckIntervalMinutes"");
        editor.remove(mUuid + "".lastAutomaticCheckTime"");
        editor.remove(mUuid + "".notifyNewMail"");
        editor.remove(mUuid + "".notifySelfNewMail"");
        editor.remove(mUuid + "".deletePolicy"");
        editor.remove(mUuid + "".draftsFolderName"");
        editor.remove(mUuid + "".sentFolderName"");
        editor.remove(mUuid + "".trashFolderName"");
        editor.remove(mUuid + "".outboxFolderName"");
        editor.remove(mUuid + "".autoExpandFolderName"");
        editor.remove(mUuid + "".accountNumber"");
        editor.remove(mUuid + "".vibrate"");
        editor.remove(mUuid + "".ring"");
        editor.remove(mUuid + "".ringtone"");
        editor.remove(mUuid + "".lastFullSync"");
        editor.remove(mUuid + "".folderDisplayMode"");
        editor.remove(mUuid + "".folderSyncMode"");
        editor.remove(mUuid + "".folderPushMode"");
        editor.remove(mUuid + "".folderTargetMode"");
        editor.remove(mUuid + "".hideButtonsEnum"");
        editor.remove(mUuid + "".signatureBeforeQuotedText"");
        editor.remove(mUuid + "".expungePolicy"");
        editor.remove(mUuid + "".maxPushFolders"");
        for (String type : networkTypes)
        {
            editor.remove(mUuid + "".useCompression."" + type);
        }
        deleteIdentities(preferences.getPreferences(), editor);
        editor.commit();
    }

    public synchronized void save(Preferences preferences)
    {
        SharedPreferences.Editor editor = preferences.getPreferences().edit();

        if (!preferences.getPreferences().getString(""accountUuids"", """").contains(mUuid))
        {
            /*
             * When the account is first created we assign it a unique account number. The
             * account number will be unique to that account for the lifetime of the account.
             * So, we get all the existing account numbers, sort them ascending, loop through
             * the list and check if the number is greater than 1 + the previous number. If so
             * we use the previous number + 1 as the account number. This refills gaps.
             * mAccountNumber starts as -1 on a newly created account. It must be -1 for this
             * algorithm to work.
             *
             * I bet there is a much smarter way to do this. Anyone like to suggest it?
             */
            Account[] accounts = preferences.getAccounts();
            int[] accountNumbers = new int[accounts.length];
            for (int i = 0; i < accounts.length; i++)
            {
                accountNumbers[i] = accounts[i].getAccountNumber();
            }
            Arrays.sort(accountNumbers);
            for (int accountNumber : accountNumbers)
            {
                if (accountNumber > mAccountNumber + 1)
                {
                    break;
                }
                mAccountNumber = accountNumber;
            }
            mAccountNumber++;

            String accountUuids = preferences.getPreferences().getString(""accountUuids"", """");
            accountUuids += (accountUuids.length() != 0 ? "","" : """") + mUuid;
            editor.putString(""accountUuids"", accountUuids);
        }

        editor.putString(mUuid + "".storeUri"", Utility.base64Encode(mStoreUri));
        editor.putString(mUuid + "".localStoreUri"", mLocalStoreUri);
        editor.putString(mUuid + "".transportUri"", Utility.base64Encode(mTransportUri));
        editor.putString(mUuid + "".description"", mDescription);
        editor.putString(mUuid + "".alwaysBcc"", mAlwaysBcc);
        editor.putInt(mUuid + "".automaticCheckIntervalMinutes"", mAutomaticCheckIntervalMinutes);
        editor.putInt(mUuid + "".displayCount"", mDisplayCount);
        editor.putLong(mUuid + "".lastAutomaticCheckTime"", mLastAutomaticCheckTime);
        editor.putBoolean(mUuid + "".notifyNewMail"", mNotifyNewMail);
        editor.putBoolean(mUuid + "".notifySelfNewMail"", mNotifySelfNewMail);
        editor.putBoolean(mUuid + "".notifyMailCheck"", mNotifySync);
        editor.putInt(mUuid + "".deletePolicy"", mDeletePolicy);
        editor.putString(mUuid + "".draftsFolderName"", mDraftsFolderName);
        editor.putString(mUuid + "".sentFolderName"", mSentFolderName);
        editor.putString(mUuid + "".trashFolderName"", mTrashFolderName);
        editor.putString(mUuid + "".outboxFolderName"", mOutboxFolderName);
        editor.putString(mUuid + "".autoExpandFolderName"", mAutoExpandFolderName);
        editor.putInt(mUuid + "".accountNumber"", mAccountNumber);
        editor.putBoolean(mUuid + "".vibrate"", mVibrate);
        editor.putBoolean(mUuid + "".ring"", mRing);
        editor.putString(mUuid + "".hideButtonsEnum"", mHideMessageViewButtons.name());
        editor.putString(mUuid + "".ringtone"", mRingtoneUri);
        editor.putString(mUuid + "".folderDisplayMode"", mFolderDisplayMode.name());
        editor.putString(mUuid + "".folderSyncMode"", mFolderSyncMode.name());
        editor.putString(mUuid + "".folderPushMode"", mFolderPushMode.name());
        editor.putString(mUuid + "".folderTargetMode"", mFolderTargetMode.name());
        editor.putBoolean(mUuid + "".signatureBeforeQuotedText"", this.mIsSignatureBeforeQuotedText);
        editor.putString(mUuid + "".expungePolicy"", mExpungePolicy);
        editor.putInt(mUuid + "".maxPushFolders"", mMaxPushFolders);
        for (String type : networkTypes)
        {
            Boolean useCompression = compressionMap.get(type);
            if (useCompression != null)
            {
                editor.putBoolean(mUuid + "".useCompression."" + type, useCompression);
            }
        }
        saveIdentities(preferences.getPreferences(), editor);

        editor.commit();

    }

    //TODO: Shouldn't this live in MessagingController?
    public int getUnreadMessageCount(Context context) throws MessagingException
    {
        int unreadMessageCount = 0;
        LocalStore localStore = getLocalStore();
        Account.FolderMode aMode = getFolderDisplayMode();
        Preferences prefs = Preferences.getPreferences(context);
        for (LocalFolder folder : localStore.getPersonalNamespaces())
        {
            folder.refresh(prefs);
            Folder.FolderClass fMode = folder.getDisplayClass();

            if (folder.getName().equals(getTrashFolderName()) == false &&
                    folder.getName().equals(getDraftsFolderName()) == false &&
                    folder.getName().equals(getOutboxFolderName()) == false &&
                    folder.getName().equals(getSentFolderName()) == false &&
                    folder.getName().equals(getErrorFolderName()) == false)
            {
                if (aMode == Account.FolderMode.NONE)
                {
                    continue;
                }
                if (aMode == Account.FolderMode.FIRST_CLASS &&
                        fMode != Folder.FolderClass.FIRST_CLASS)
                {
                    continue;
                }
                if (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
                        fMode != Folder.FolderClass.FIRST_CLASS &&
                        fMode != Folder.FolderClass.SECOND_CLASS)
                {
                    continue;
                }
                if (aMode == Account.FolderMode.NOT_SECOND_CLASS &&
                        fMode == Folder.FolderClass.SECOND_CLASS)
                {
                    continue;
                }
                unreadMessageCount += folder.getUnreadMessageCount();
            }
        }

        return unreadMessageCount;
    }

    public String getUuid()
    {
        return mUuid;
    }

    public Uri getContentUri()
    {
        return Uri.parse(""content://accounts/"" + getUuid());
    }

    public synchronized String getStoreUri()
    {
        return mStoreUri;
    }

    public synchronized void setStoreUri(String storeUri)
    {
        this.mStoreUri = storeUri;
    }

    public synchronized String getTransportUri()
    {
        return mTransportUri;
    }

    public synchronized void setTransportUri(String transportUri)
    {
        this.mTransportUri = transportUri;
    }

    public synchronized String getDescription()
    {
        return mDescription;
    }

    public synchronized void setDescription(String description)
    {
        this.mDescription = description;
    }

    public synchronized String getName()
    {
        return identities.get(0).getName();
    }

    public synchronized void setName(String name)
    {
        identities.get(0).setName(name);
    }

    public synchronized boolean getSignatureUse()
    {
        return identities.get(0).getSignatureUse();
    }

    public synchronized void setSignatureUse(boolean signatureUse)
    {
        identities.get(0).setSignatureUse(signatureUse);
    }

    public synchronized String getSignature()
    {
        return identities.get(0).getSignature();
    }

    public synchronized void setSignature(String signature)
    {
        identities.get(0).setSignature(signature);
    }

    public synchronized String getEmail()
    {
        return identities.get(0).getEmail();
    }

    public synchronized void setEmail(String email)
    {
        identities.get(0).setEmail(email);
    }

    public synchronized String getAlwaysBcc()
    {
        return mAlwaysBcc;
    }

    public synchronized void setAlwaysBcc(String alwaysBcc)
    {
        this.mAlwaysBcc = alwaysBcc;
    }

    public synchronized boolean isVibrate()
    {
        return mVibrate;
    }

    public synchronized void setVibrate(boolean vibrate)
    {
        mVibrate = vibrate;
    }



   /* Have we sent a new mail notification on this account */
   public boolean isRingNotified()
   {
       return mRingNotified;
   }

   public void setRingNotified(boolean ringNotified)
   {
       mRingNotified = ringNotified;
   }

   public synchronized String getRingtone()
    {
        return mRingtoneUri;
    }

    public synchronized void setRingtone(String ringtoneUri)
    {
        mRingtoneUri = ringtoneUri;
    }

    public synchronized String getLocalStoreUri()
    {
        return mLocalStoreUri;
    }

    public synchronized void setLocalStoreUri(String localStoreUri)
    {
        this.mLocalStoreUri = localStoreUri;
    }

    /**
     * Returns -1 for never.
     */
    public synchronized int getAutomaticCheckIntervalMinutes()
    {
        return mAutomaticCheckIntervalMinutes;
    }

    /**
     * @param automaticCheckIntervalMinutes or -1 for never.
     */
    public synchronized boolean setAutomaticCheckIntervalMinutes(int automaticCheckIntervalMinutes)
    {
        int oldInterval = this.mAutomaticCheckIntervalMinutes;
        int newInterval = automaticCheckIntervalMinutes;
        this.mAutomaticCheckIntervalMinutes = automaticCheckIntervalMinutes;
        
        return (oldInterval != newInterval);
    }

    public synchronized int getDisplayCount()
    {
        if (mDisplayCount == -1)
        {
            this.mDisplayCount = K9.DEFAULT_VISIBLE_LIMIT;
        }
        return mDisplayCount;
    }

    public synchronized void setDisplayCount(int displayCount)
    {
        if (displayCount != -1)
        {
            this.mDisplayCount = displayCount;
        }
        else
        {
            this.mDisplayCount = K9.DEFAULT_VISIBLE_LIMIT;
        }
    }

    public synchronized long getLastAutomaticCheckTime()
    {
        return mLastAutomaticCheckTime;
    }

    public synchronized void setLastAutomaticCheckTime(long lastAutomaticCheckTime)
    {
        this.mLastAutomaticCheckTime = lastAutomaticCheckTime;
    }

    public synchronized boolean isNotifyNewMail()
    {
        return mNotifyNewMail;
    }

    public synchronized void setNotifyNewMail(boolean notifyNewMail)
    {
        this.mNotifyNewMail = notifyNewMail;
    }

    public synchronized int getDeletePolicy()
    {
        return mDeletePolicy;
    }

    public synchronized void setDeletePolicy(int deletePolicy)
    {
        this.mDeletePolicy = deletePolicy;
    }

    public synchronized String getDraftsFolderName()
    {
        return mDraftsFolderName;
    }

    public synchronized void setDraftsFolderName(String draftsFolderName)
    {
        mDraftsFolderName = draftsFolderName;
    }

    public synchronized String getSentFolderName()
    {
        return mSentFolderName;
    }

    public synchronized String getErrorFolderName()
    {
        return K9.ERROR_FOLDER_NAME;
    }

    public synchronized void setSentFolderName(String sentFolderName)
    {
        mSentFolderName = sentFolderName;
    }

    public synchronized String getTrashFolderName()
    {
        return mTrashFolderName;
    }

    public synchronized void setTrashFolderName(String trashFolderName)
    {
        mTrashFolderName = trashFolderName;
    }

    public synchronized String getOutboxFolderName()
    {
        return mOutboxFolderName;
    }

    public synchronized void setOutboxFolderName(String outboxFolderName)
    {
        mOutboxFolderName = outboxFolderName;
    }

    public synchronized String getAutoExpandFolderName()
    {
        return mAutoExpandFolderName;
    }

    public synchronized void setAutoExpandFolderName(String autoExpandFolderName)
    {
        mAutoExpandFolderName = autoExpandFolderName;
    }

    public synchronized int getAccountNumber()
    {
        return mAccountNumber;
    }

    public synchronized FolderMode getFolderDisplayMode()
    {
        return mFolderDisplayMode;
    }

    public synchronized boolean setFolderDisplayMode(FolderMode displayMode)
    {
        FolderMode oldDisplayMode = mFolderDisplayMode;
        mFolderDisplayMode = displayMode;
        return oldDisplayMode != displayMode;
    }

    public synchronized FolderMode getFolderSyncMode()
    {
        return mFolderSyncMode;
    }

    public synchronized boolean setFolderSyncMode(FolderMode syncMode)
    {
        FolderMode oldSyncMode = mFolderSyncMode;
        mFolderSyncMode = syncMode;
        
        if (syncMode == FolderMode.NONE && oldSyncMode != FolderMode.NONE)
        {
            return true;
        }
        if (syncMode != FolderMode.NONE && oldSyncMode == FolderMode.NONE)
        {
            return true;
        }
        return false;
    }

    public synchronized FolderMode getFolderPushMode()
    {
        return mFolderPushMode;
    }

    public synchronized boolean setFolderPushMode(FolderMode pushMode)
    {
        FolderMode oldPushMode = mFolderPushMode;
        
        mFolderPushMode = pushMode;
        return pushMode != oldPushMode;
    }

    public synchronized boolean isShowOngoing()
    {
        return mNotifySync;
    }

    public synchronized void setShowOngoing(boolean showOngoing)
    {
        this.mNotifySync = showOngoing;
    }

    public synchronized HideButtons getHideMessageViewButtons()
    {
        return mHideMessageViewButtons;
    }

    public synchronized void setHideMessageViewButtons(HideButtons hideMessageViewButtons)
    {
        mHideMessageViewButtons = hideMessageViewButtons;
    }

    public synchronized FolderMode getFolderTargetMode()
    {
        return mFolderTargetMode;
    }

    public synchronized void setFolderTargetMode(FolderMode folderTargetMode)
    {
        mFolderTargetMode = folderTargetMode;
    }

    public synchronized boolean isSignatureBeforeQuotedText()
    {
        return mIsSignatureBeforeQuotedText;
    }

    public synchronized void setSignatureBeforeQuotedText(boolean mIsSignatureBeforeQuotedText)
    {
        this.mIsSignatureBeforeQuotedText = mIsSignatureBeforeQuotedText;
    }

    public synchronized boolean isNotifySelfNewMail()
    {
        return mNotifySelfNewMail;
    }

    public synchronized void setNotifySelfNewMail(boolean notifySelfNewMail)
    {
        mNotifySelfNewMail = notifySelfNewMail;
    }

    public synchronized String getExpungePolicy()
    {
        return mExpungePolicy;
    }

    public synchronized void setExpungePolicy(String expungePolicy)
    {
        mExpungePolicy = expungePolicy;
    }

    public synchronized int getMaxPushFolders()
    {
        return mMaxPushFolders;
    }

    public synchronized boolean setMaxPushFolders(int maxPushFolders)
    {
        int oldMaxPushFolders = mMaxPushFolders;
        mMaxPushFolders = maxPushFolders;
        return oldMaxPushFolders != maxPushFolders;
    }

    public synchronized boolean isRing()
    {
        return mRing;
    }

    public synchronized void setRing(boolean ring)
    {
        mRing = ring;
    }

    public LocalStore getLocalStore() throws MessagingException
    {
        return Store.getLocalInstance(this, K9.app);        
    }
    
    public Store getRemoteStore() throws MessagingException
    {
        return Store.getRemoteInstance(this);        
    }

    @Override
    public synchronized String toString()
    {
        return mDescription;
    }
    
    public void setCompression(String networkType, boolean useCompression)
    {
        compressionMap.put(networkType, useCompression);
    }
    
    public boolean useCompression(String networkType)
    {
        Boolean useCompression = compressionMap.get(networkType);
        if (useCompression == null)
        {
            return true;
        }
        else
        {
            return useCompression;
        }
    }
    
    public boolean useCompression(int type)
    {
        String networkType = TYPE_OTHER;
        switch (type)
        {
            case ConnectivityManager.TYPE_MOBILE:
                networkType = TYPE_MOBILE;
                break;
            case ConnectivityManager.TYPE_WIFI:
                networkType = TYPE_WIFI;
                break;
        }
        return useCompression(networkType);
    }
    
    @Override
    public boolean equals(Object o)
    {
        if (o instanceof Account)
        {
            return ((Account)o).mUuid.equals(mUuid);
        }
        return super.equals(o);
    }

    @Override
    public int hashCode()
    {
        return mUuid.hashCode();
    }


    private synchronized List<Identity> loadIdentities(SharedPreferences prefs)
    {
        List<Identity> newIdentities = new ArrayList<Identity>();
        int ident = 0;
        boolean gotOne = false;
        do
        {
            gotOne = false;
            String name = prefs.getString(mUuid + "".name."" + ident, null);
            String email = prefs.getString(mUuid + "".email."" + ident, null);
            boolean signatureUse = prefs.getBoolean(mUuid  + "".signatureUse."" + ident, true);
            String signature = prefs.getString(mUuid + "".signature."" + ident, null);
            String description = prefs.getString(mUuid + "".description."" + ident, null);
            if (email != null)
            {
                Identity identity = new Identity();
                identity.setName(name);
                identity.setEmail(email);
                identity.setSignatureUse(signatureUse);
                identity.setSignature(signature);
                identity.setDescription(description);
                newIdentities.add(identity);
                gotOne = true;
            }
            ident++;
        }
        while (gotOne);

        if (newIdentities.size() == 0)
        {
            String name = prefs.getString(mUuid + "".name"", null);
            String email = prefs.getString(mUuid + "".email"", null);
            boolean signatureUse = prefs.getBoolean(mUuid  + "".signatureUse"", true);
            String signature = prefs.getString(mUuid + "".signature"", null);
            Identity identity = new Identity();
            identity.setName(name);
            identity.setEmail(email);
            identity.setSignatureUse(signatureUse);
            identity.setSignature(signature);
            identity.setDescription(email);
            newIdentities.add(identity);
        }

        return newIdentities;
    }

    private synchronized void deleteIdentities(SharedPreferences prefs, SharedPreferences.Editor editor)
    {
        int ident = 0;
        boolean gotOne = false;
        do
        {
            gotOne = false;
            String email = prefs.getString(mUuid + "".email."" + ident, null);
            if (email != null)
            {
                editor.remove(mUuid + "".name."" + ident);
                editor.remove(mUuid + "".email."" + ident);
                editor.remove(mUuid + "".signatureUse."" + ident);
                editor.remove(mUuid + "".signature."" + ident);
                editor.remove(mUuid + "".description."" + ident);
                gotOne = true;
            }
            ident++;
        }
        while (gotOne);
    }

    private synchronized void saveIdentities(SharedPreferences prefs, SharedPreferences.Editor editor)
    {
        deleteIdentities(prefs, editor);
        int ident = 0;

        for (Identity identity : identities)
        {
            editor.putString(mUuid + "".name."" + ident, identity.getName());
            editor.putString(mUuid + "".email."" + ident, identity.getEmail());
            editor.putBoolean(mUuid + "".signatureUse."" + ident, identity.getSignatureUse());
            editor.putString(mUuid + "".signature."" + ident, identity.getSignature());
            editor.putString(mUuid + "".description."" + ident, identity.getDescription());
            ident++;
        }
    }

    public synchronized List<Identity> getIdentities()
    {
        return identities;
    }

    public synchronized void setIdentities(List<Identity> newIdentities)
    {
        identities = new ArrayList<Identity>(newIdentities);
    }

    public synchronized Identity getIdentity(int i)
    {
        if (i < identities.size())
        {
            return identities.get(i);
        }
        return null;
    }

    public boolean isAnIdentity(Address[] addrs)
    {
        if (addrs == null)
        {
            return false;
        }
        for (Address addr : addrs)
        {
            if (findIdentity(addr) != null)
            {
                return true;
            }
        }

        return false;
    }

    public boolean isAnIdentity(Address addr)
    {
        return findIdentity(addr) != null;
    }

    public synchronized Identity findIdentity(Address addr)
    {
        for (Identity identity : identities)
        {
            String email = identity.getEmail();
            if (email != null && email.equalsIgnoreCase(addr.getAddress()))
            {
                return identity;
            }
        }
        return null;
    }
}
",True,191,1,2,7,49,38,9,L1
4,com.fsck.k9.K9ListActivity.java,"package com.fsck.k9;

import android.app.ListActivity;
import android.os.Bundle;
import com.fsck.k9.activity.DateFormatter;


public class K9ListActivity extends ListActivity
{
    @Override
    public void onCreate(Bundle icicle)
    {
        setTheme(K9.getK9Theme());
        super.onCreate(icicle);
        setupFormats();
    }

    @Override
    public void onResume()
    {
        super.onResume();
        setupFormats();
    }

    private java.text.DateFormat mDateFormat;
    private java.text.DateFormat mTimeFormat;

    private void setupFormats()
    {
        mDateFormat = DateFormatter.getDateFormat(this);
        mTimeFormat = android.text.format.DateFormat.getTimeFormat(this);   // 12/24 date format
    }

    public java.text.DateFormat getTimeFormat()
    {
        return mTimeFormat;
    }

    public java.text.DateFormat getDateFormat()
    {
        return mDateFormat;
    }
}
",False,189,0,0,9,52,4,2,L1
5,com.fsck.k9.EmailAddressAdapter.java,"/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9;

import android.content.ContentResolver;
import android.content.Context;
import android.os.Build;
import android.widget.ResourceCursorAdapter;

public abstract class EmailAddressAdapter extends ResourceCursorAdapter
{
    private static EmailAddressAdapter sInstance;
    private static Context sContext;

    public static EmailAddressAdapter getInstance(Context context)
    {
        if (sInstance == null)
        {
            String className;

            sContext = context;

            /*
             * Check the version of the SDK we are running on. Choose an
             * implementation class designed for that version of the SDK.
             */
            @SuppressWarnings(""deprecation"")
            int sdkVersion = Integer.parseInt(Build.VERSION.SDK);       // Cupcake style
            if (sdkVersion < Build.VERSION_CODES.ECLAIR)
            {
                className = ""com.fsck.k9.EmailAddressAdapterSdk3_4"";
            }
            else
            {
                className = ""com.fsck.k9.EmailAddressAdapterSdk5"";
            }

            /*
             * Find the required class by name and instantiate it.
             */
            try
            {
                Class<? extends EmailAddressAdapter> clazz =
                        Class.forName(className).asSubclass(EmailAddressAdapter.class);
                sInstance = clazz.newInstance();
            }
            catch (Exception e)
            {
                throw new IllegalStateException(e);
            }
        }

        return sInstance;
    }

    public static Context getContext()
    {
        return sContext;
    }

    protected ContentResolver mContentResolver;

    public EmailAddressAdapter()
    {
        super(getContext(), R.layout.recipient_dropdown_item, null);
        mContentResolver = getContext().getContentResolver();
    }
}
",False,73,6,42,0,0,3,0,L1
6,com.fsck.k9.K9.java,"
package com.fsck.k9;

import android.app.Application;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.util.Log;
import android.webkit.WebSettings;

import com.fsck.k9.activity.MessageCompose;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.internet.BinaryTempFileBody;
import com.fsck.k9.service.BootReceiver;
import com.fsck.k9.service.MailService;

import java.io.File;
import java.lang.reflect.Method;

public class K9 extends Application
{
    public static Application app = null;
    public static File tempDirectory;
    public static final String LOG_TAG = ""k9"";

    public enum BACKGROUND_OPS
    {
        WHEN_CHECKED, ALWAYS, NEVER
    }

    private static int theme = android.R.style.Theme_Light;

    private static BACKGROUND_OPS backgroundOps = BACKGROUND_OPS.WHEN_CHECKED;
    /**
     * Some log messages can be sent to a file, so that the logs
     * can be read using unprivileged access (eg. Terminal Emulator)
     * on the phone, without adb.  Set to null to disable
     */
    public static final String logFile = null;
    //public static final String logFile = ""/sdcard/k9mail/debug.log"";

    /**
     * If this is enabled there will be additional logging information sent to
     * Log.d, including protocol dumps.
     * Controlled by Preferences at run-time
     */
    public static boolean DEBUG = false;

    /**
     * If this is enabled than logging that normally hides sensitive information
     * like passwords will show that information.
     */
    public static boolean DEBUG_SENSITIVE = false;

    /**
     * Can create messages containing stack traces that can be forwarded
     * to the development team.
     */
    public static boolean ENABLE_ERROR_FOLDER = true;
    public static String ERROR_FOLDER_NAME = ""K9mail-errors"";


    private static boolean mAnimations = true;


    private static boolean mMessageListStars = true;
    private static boolean mMessageListCheckboxes = false;
    private static boolean mMessageListTouchable = false;
    private static boolean mGesturesEnabled = true;

    /**
     * We use WebSettings.getBlockNetworkLoads() to prevent the WebView that displays email
     * bodies from loading external resources over the network. Unfortunately this method
     * isn't exposed via the official Android API. That's why we use reflection to be able
     * to call the method. 
     */
    private static final Method mGetBlockNetworkLoads = getMethod(WebSettings.class, ""setBlockNetworkLoads"");


    /**
     * The MIME type(s) of attachments we're willing to send. At the moment it is not possible
     * to open a chooser with a list of filter types, so the chooser is only opened with the first
     * item in the list. The entire list will be used to filter down attachments that are added
     * with Intent.ACTION_SEND.
     */
    public static final String[] ACCEPTABLE_ATTACHMENT_SEND_TYPES = new String[]
    {
        ""*/*""
    };

    /**
     * The MIME type(s) of attachments we're willing to view.
     */
    public static final String[] ACCEPTABLE_ATTACHMENT_VIEW_TYPES = new String[]
    {
        ""*/*"",
    };

    /**
     * The MIME type(s) of attachments we're not willing to view.
     */
    public static final String[] UNACCEPTABLE_ATTACHMENT_VIEW_TYPES = new String[]
    {
    };

    /**
     * The MIME type(s) of attachments we're willing to download to SD.
     */
    public static final String[] ACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES = new String[]
    {
        ""*/*"",
    };

    /**
     * The MIME type(s) of attachments we're not willing to download to SD.
     */
    public static final String[] UNACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES = new String[]
    {
    };

    /**
     * The special name ""INBOX"" is used throughout the application to mean ""Whatever folder
     * the server refers to as the user's Inbox. Placed here to ease use.
     */
    public static final String INBOX = ""INBOX"";

    /**
     * For use when displaying that no folder is selected
     */
    public static final String FOLDER_NONE = ""-NONE-"";

    public static final String LOCAL_UID_PREFIX = ""K9LOCAL:"";

    public static final String REMOTE_UID_PREFIX = ""K9REMOTE:"";

    public static final String K9MAIL_IDENTITY = ""X-K9mail-Identity"";

    /**
     * Specifies how many messages will be shown in a folder by default. This number is set
     * on each new folder and can be incremented with ""Load more messages..."" by the
     * VISIBLE_LIMIT_INCREMENT
     */
    public static int DEFAULT_VISIBLE_LIMIT = 25;

    /**
     * Number of additioanl messages to load when a user selectes ""Load more messages...""
     */
    public static int VISIBLE_LIMIT_INCREMENT = 25;

    public static int MAX_SEND_ATTEMPTS = 5;

    /**
     * The maximum size of an attachment we're willing to download (either View or Save)
     * Attachments that are base64 encoded (most) will be about 1.375x their actual size
     * so we should probably factor that in. A 5MB attachment will generally be around
     * 6.8MB downloaded but only 5MB saved.
     */
    public static final int MAX_ATTACHMENT_DOWNLOAD_SIZE = (5 * 1024 * 1024);

    /**
     * Max time (in millis) the wake lock will be held for when background sync is happening
     */
    public static final int WAKE_LOCK_TIMEOUT = 600000;

    public static final int MANUAL_WAKE_LOCK_TIMEOUT = 120000;

    public static final int PUSH_WAKE_LOCK_TIMEOUT = 60000;

    public static final int MAIL_SERVICE_WAKE_LOCK_TIMEOUT = 30000;

    public static final int BOOT_RECEIVER_WAKE_LOCK_TIMEOUT = 60000;


    /**
     * LED color used for the new email notitication
     */
    public static final int NOTIFICATION_LED_COLOR = 0xffff00ff;

    /**
     * Time the LED is on when blicking on new email notification
     */
    public static final int NOTIFICATION_LED_ON_TIME = 500;

    /**
     * Time the LED is off when blicking on new email notification
     */
    public static final int NOTIFICATION_LED_OFF_TIME = 2000;

    public static final boolean NOTIFICATION_LED_WHILE_SYNCING = false;
    public static final int NOTIFICATION_LED_DIM_COLOR = 0x77770077;
    public static final int NOTIFICATION_LED_FAST_ON_TIME = 100;
    public static final int NOTIFICATION_LED_FAST_OFF_TIME = 100;

    public static final int NOTIFICATION_LED_SENDING_FAILURE_COLOR = 0xffff0000;

    // Must not conflict with an account number
    public static final int FETCHING_EMAIL_NOTIFICATION_ID      = -4;
    public static final int FETCHING_EMAIL_NOTIFICATION_MULTI_ACCOUNT_ID      = -1;
    public static final int FETCHING_EMAIL_NOTIFICATION_NO_ACCOUNT = -2;
    public static final int CONNECTIVITY_ID = -3;

    public static final int[] COLOR_CHIP_RES_IDS = new int[]
    {
        R.drawable.appointment_indicator_leftside_1,
        R.drawable.appointment_indicator_leftside_2,
        R.drawable.appointment_indicator_leftside_3,
        R.drawable.appointment_indicator_leftside_4,
        R.drawable.appointment_indicator_leftside_5,
        R.drawable.appointment_indicator_leftside_6,
        R.drawable.appointment_indicator_leftside_7,
        R.drawable.appointment_indicator_leftside_8,
        R.drawable.appointment_indicator_leftside_9,
        R.drawable.appointment_indicator_leftside_10,
        R.drawable.appointment_indicator_leftside_11,
        R.drawable.appointment_indicator_leftside_12,
        R.drawable.appointment_indicator_leftside_13,
        R.drawable.appointment_indicator_leftside_14,
        R.drawable.appointment_indicator_leftside_15,
        R.drawable.appointment_indicator_leftside_16,
        R.drawable.appointment_indicator_leftside_17,
        R.drawable.appointment_indicator_leftside_18,
        R.drawable.appointment_indicator_leftside_19,
        R.drawable.appointment_indicator_leftside_20,
        R.drawable.appointment_indicator_leftside_21,
    };


    public class Intents
    {

        public class EmailReceived
        {
            public static final String ACTION_EMAIL_RECEIVED    = ""com.fsck.k9.intent.action.EMAIL_RECEIVED"";
            public static final String ACTION_EMAIL_DELETED     = ""com.fsck.k9.intent.action.EMAIL_DELETED"";
            public static final String EXTRA_ACCOUNT            = ""com.fsck.k9.intent.extra.ACCOUNT"";
            public static final String EXTRA_FOLDER             = ""com.fsck.k9.intent.extra.FOLDER"";
            public static final String EXTRA_SENT_DATE          = ""com.fsck.k9.intent.extra.SENT_DATE"";
            public static final String EXTRA_FROM               = ""com.fsck.k9.intent.extra.FROM"";
            public static final String EXTRA_TO                 = ""com.fsck.k9.intent.extra.TO"";
            public static final String EXTRA_CC                 = ""com.fsck.k9.intent.extra.CC"";
            public static final String EXTRA_BCC                = ""com.fsck.k9.intent.extra.BCC"";
            public static final String EXTRA_SUBJECT            = ""com.fsck.k9.intent.extra.SUBJECT"";
            public static final String EXTRA_FROM_SELF          = ""com.fsck.k9.intent.extra.FROM_SELF"";
        }

    }

    /**
     * Called throughout the application when the number of accounts has changed. This method
     * enables or disables the Compose activity, the boot receiver and the service based on
     * whether any accounts are configured.
     */
    public static void setServicesEnabled(Context context)
    {
        int acctLength = Preferences.getPreferences(context).getAccounts().length;

        setServicesEnabled(context, acctLength > 0, null);

    }

    public static void setServicesEnabled(Context context, Integer wakeLockId)
    {
        setServicesEnabled(context, Preferences.getPreferences(context).getAccounts().length > 0, wakeLockId);
    }

    public static void setServicesEnabled(Context context, boolean enabled, Integer wakeLockId)
    {

        PackageManager pm = context.getPackageManager();

        if (!enabled && pm.getComponentEnabledSetting(new ComponentName(context, MailService.class)) ==
                PackageManager.COMPONENT_ENABLED_STATE_ENABLED)
        {
            /*
             * If no accounts now exist but the service is still enabled we're about to disable it
             * so we'll reschedule to kill off any existing alarms.
             */
            MailService.actionReset(context, wakeLockId);
        }
        Class[] classes = { MessageCompose.class, BootReceiver.class, MailService.class };

        for (Class clazz : classes)
        {

            boolean alreadyEnabled = pm.getComponentEnabledSetting(new ComponentName(context, clazz)) ==
                                     PackageManager.COMPONENT_ENABLED_STATE_ENABLED;

            if (enabled != alreadyEnabled)
            {
                pm.setComponentEnabledSetting(
                    new ComponentName(context, clazz),
                    enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED :
                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                    PackageManager.DONT_KILL_APP);
            }
        }

        if (enabled && pm.getComponentEnabledSetting(new ComponentName(context, MailService.class)) ==
                PackageManager.COMPONENT_ENABLED_STATE_ENABLED)
        {
            /*
             * And now if accounts do exist then we've just enabled the service and we want to
             * schedule alarms for the new accounts.
             */
            MailService.actionReset(context, wakeLockId);
        }

    }

    public static void save(SharedPreferences.Editor editor)
    {
        editor.putBoolean(""enableDebugLogging"", K9.DEBUG);
        editor.putBoolean(""enableSensitiveLogging"", K9.DEBUG_SENSITIVE);
        editor.putString(""backgroundOperations"", K9.backgroundOps.toString());
        editor.putBoolean(""animations"", mAnimations);
        editor.putBoolean(""gesturesEnabled"", mGesturesEnabled);
        editor.putBoolean(""messageListStars"",mMessageListStars);
        editor.putBoolean(""messageListCheckboxes"",mMessageListCheckboxes);
        editor.putBoolean(""messageListTouchable"",mMessageListTouchable);
        editor.putInt(""theme"", theme);
    }

    @Override
    public void onCreate()
    {
        super.onCreate();
        app = this;
        Preferences prefs = Preferences.getPreferences(this);
        SharedPreferences sprefs = prefs.getPreferences();
        DEBUG = sprefs.getBoolean(""enableDebugLogging"", false);
        DEBUG_SENSITIVE = sprefs.getBoolean(""enableSensitiveLogging"", false);
        mAnimations = sprefs.getBoolean(""animations"", true);
        mGesturesEnabled = sprefs.getBoolean(""gesturesEnabled"", true);
        mMessageListStars = sprefs.getBoolean(""messageListStars"",true);
        mMessageListCheckboxes = sprefs.getBoolean(""messageListCheckboxes"",false);
        mMessageListTouchable = sprefs.getBoolean(""messageListTouchable"",false);


        try
        {
            setBackgroundOps(BACKGROUND_OPS.valueOf(sprefs.getString(""backgroundOperations"", ""WHEN_CHECKED"")));
        }
        catch (Exception e)
        {
            setBackgroundOps(BACKGROUND_OPS.WHEN_CHECKED);
        }

        K9.setK9Theme(sprefs.getInt(""theme"", android.R.style.Theme_Light));
        MessagingController.getInstance(this).resetVisibleLimits(prefs.getAccounts());

        /*
         * We have to give MimeMessage a temp directory because File.createTempFile(String, String)
         * doesn't work in Android and MimeMessage does not have access to a Context.
         */
        BinaryTempFileBody.setTempDirectory(getCacheDir());

        /*
         * Enable background sync of messages
         */

        setServicesEnabled(this);

        MessagingController.getInstance(this).addListener(new MessagingListener()
        {
            private void broadcastIntent(String action, Account account, String folder, Message message)
            {
                try
                {
                    Uri uri = Uri.parse(""email://messages/"" + account.getAccountNumber() + ""/"" + Uri.encode(folder) + ""/"" + Uri.encode(message.getUid()));
                    Intent intent = new Intent(action, uri);
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_ACCOUNT, account.getDescription());
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_FOLDER, folder);
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_SENT_DATE, message.getSentDate());
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_FROM, Address.toString(message.getFrom()));
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_TO, Address.toString(message.getRecipients(Message.RecipientType.TO)));
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_CC, Address.toString(message.getRecipients(Message.RecipientType.CC)));
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_BCC, Address.toString(message.getRecipients(Message.RecipientType.BCC)));
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_SUBJECT, message.getSubject());
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_FROM_SELF, account.isAnIdentity(message.getFrom()));
                    K9.this.sendBroadcast(intent);
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Broadcasted: action="" + action
                              + "" account="" + account.getDescription()
                              + "" folder="" + folder
                              + "" message uid="" + message.getUid()
                             );

                }
                catch (MessagingException e)
                {
                    Log.w(K9.LOG_TAG, ""Error: action="" + action
                          + "" account="" + account.getDescription()
                          + "" folder="" + folder
                          + "" message uid="" + message.getUid()
                         );
                }
            }

            @Override
            public void synchronizeMailboxRemovedMessage(Account account, String folder, Message message)
            {
                broadcastIntent(K9.Intents.EmailReceived.ACTION_EMAIL_DELETED, account, folder, message);
            }

            @Override
            public void messageDeleted(Account account, String folder, Message message)
            {
                broadcastIntent(K9.Intents.EmailReceived.ACTION_EMAIL_DELETED, account, folder, message);
            }

            @Override
            public void synchronizeMailboxNewMessage(Account account, String folder, Message message)
            {
                broadcastIntent(K9.Intents.EmailReceived.ACTION_EMAIL_RECEIVED, account, folder, message);
            }


        });

    }

    public static int getK9Theme()
    {
        return theme;
    }

    public static void setK9Theme(int ntheme)
    {
        theme = ntheme;
    }

    public static BACKGROUND_OPS getBackgroundOps()
    {
        return backgroundOps;
    }

    public static boolean setBackgroundOps(BACKGROUND_OPS backgroundOps)
    {
        BACKGROUND_OPS oldBackgroundOps = K9.backgroundOps;
        K9.backgroundOps = backgroundOps;
        return backgroundOps != oldBackgroundOps;
    }

    public static boolean setBackgroundOps(String nbackgroundOps)
    {
        return setBackgroundOps(BACKGROUND_OPS.valueOf(nbackgroundOps));
    }

    public static boolean gesturesEnabled()
    {
        return mGesturesEnabled;
    }
    
    public static void setGesturesEnabled(boolean gestures)
    {
        mGesturesEnabled = gestures;
    }
    
    public static boolean isAnimations()
    {
        return mAnimations;
    }

    public static void setAnimations(boolean animations)
    {
        mAnimations = animations;
    }

    public static boolean messageListTouchable()
    {
        return mMessageListTouchable;
    }

    public static void setMessageListTouchable(boolean touchy)
    {
        mMessageListTouchable = touchy;
    }

    public static boolean messageListStars()
    {
        return mMessageListStars;
    }

    public static void setMessageListStars(boolean stars)
    {
        mMessageListStars = stars;
    }
    public static boolean messageListCheckboxes()
    {
        return mMessageListCheckboxes;
    }

    public static void setMessageListCheckboxes(boolean checkboxes)
    {
        mMessageListCheckboxes = checkboxes;
    }


    private static Method getMethod(Class classObject, String methodName)
    {
        try
        {
            Method method = classObject.getMethod(methodName, boolean.class);
            return method;
        }
        catch (NoSuchMethodException e)
        {
            Log.i(K9.LOG_TAG, ""Can't get method "" +
                    classObject.toString() + ""."" + methodName);
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Error while using reflection to get method "" +
                    classObject.toString() + ""."" + methodName, e);
        }
        return null;
    }

    public static void setBlockNetworkLoads(WebSettings webSettings, boolean state)
    {
        if (mGetBlockNetworkLoads != null)
        {
            try
            {
                mGetBlockNetworkLoads.invoke(webSettings, state);
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Error on invoking WebSettings.setBlockNetworkLoads()"", e);
            }
        }
    }
}
",True,192,1,3,8,52,46,11,L1
7,com.fsck.k9.Identity.java,"package com.fsck.k9;

import java.io.Serializable;

public class Identity implements Serializable
{
    private String mDescription;
    private String mName;
    private String mEmail;
    private String mSignature;
    private boolean mSignatureUse;

    public synchronized String getName()
    {
        return mName;
    }

    public synchronized void setName(String name)
    {
        mName = name;
    }

    public synchronized String getEmail()
    {
        return mEmail;
    }

    public synchronized void setEmail(String email)
    {
        mEmail = email;
    }

    public synchronized boolean getSignatureUse()
    {
        return mSignatureUse;
    }

    public synchronized void setSignatureUse(boolean signatureUse)
    {
        mSignatureUse = signatureUse;
    }

    public synchronized String getSignature()
    {
        return mSignature;
    }

    public synchronized void setSignature(String signature)
    {
        mSignature = signature;
    }

    public synchronized String getDescription()
    {
        return mDescription;
    }

    public synchronized void setDescription(String description)
    {
        mDescription = description;
    }

    @Override
    public synchronized String toString()
    {
        return ""Account.Identity(description="" + mDescription + "", name="" + mName + "", email="" + mEmail + "", signature="" + mSignature;
    }
}
",False,73,6,34,0,0,5,0,L1
8,com.fsck.k9.PeekableInputStream.java,"
package com.fsck.k9;

import java.io.IOException;
import java.io.InputStream;

/**
 * A filtering InputStream that allows single byte ""peeks"" without consuming the byte. The
 * client of this stream can call peek() to see the next available byte in the stream
 * and a subsequent read will still return the peeked byte.
 */
public class PeekableInputStream extends InputStream
{
    private InputStream mIn;
    private boolean mPeeked;
    private int mPeekedByte;

    public PeekableInputStream(InputStream in)
    {
        this.mIn = in;
    }

    @Override
    public int read() throws IOException
    {
        if (!mPeeked)
        {
            return mIn.read();
        }
        else
        {
            mPeeked = false;
            return mPeekedByte;
        }
    }

    public int peek() throws IOException
    {
        if (!mPeeked)
        {
            mPeekedByte = read();
            mPeeked = true;
        }
        return mPeekedByte;
    }

    @Override
    public int read(byte[] b, int offset, int length) throws IOException
    {
        if (!mPeeked)
        {
            return mIn.read(b, offset, length);
        }
        else
        {
            b[0] = (byte)mPeekedByte;
            mPeeked = false;
            int r = mIn.read(b, offset + 1, length - 1);
            if (r == -1)
            {
                return 1;
            }
            else
            {
                return r + 1;
            }
        }
    }

    @Override
    public int read(byte[] b) throws IOException
    {
        return read(b, 0, b.length);
    }

    public String toString()
    {
        return String.format(""PeekableInputStream(in=%s, peeked=%b, peekedByte=%d)"",
                             mIn.toString(), mPeeked, mPeekedByte);
    }
}
",True,73,8,25,0,0,4,0,L1
9,com.fsck.k9.EmailAddressAdapterSdk3_4.java,"/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9;

import android.content.Context;
import android.database.Cursor;
import android.database.DatabaseUtils;
import android.provider.Contacts.ContactMethods;
import android.provider.Contacts.People;
import android.view.View;
import android.widget.TextView;
import com.fsck.k9.mail.Address;

import static android.provider.Contacts.ContactMethods.CONTENT_EMAIL_URI;

public class EmailAddressAdapterSdk3_4 extends EmailAddressAdapter
{
    public static final int NAME_INDEX = 1;

    public static final int DATA_INDEX = 2;

    private static final String SORT_ORDER = People.TIMES_CONTACTED + "" DESC, "" + People.NAME;

    private static final String[] PROJECTION =
    {
        ContactMethods._ID, // 0
        ContactMethods.NAME, // 1
        ContactMethods.DATA // 2
    };

    @Override
    public final String convertToString(Cursor cursor)
    {
        String name = cursor.getString(NAME_INDEX);
        String address = cursor.getString(DATA_INDEX);

        return new Address(address, name).toString();
    }

    @Override
    public final void bindView(View view, Context context, Cursor cursor)
    {
        TextView text1 = (TextView)view.findViewById(R.id.text1);
        TextView text2 = (TextView)view.findViewById(R.id.text2);
        text1.setText(cursor.getString(NAME_INDEX));
        text2.setText(cursor.getString(DATA_INDEX));
    }

    @Override
    public Cursor runQueryOnBackgroundThread(CharSequence constraint)
    {
        String where = null;

        if (constraint != null)
        {
            String filter = DatabaseUtils.sqlEscapeString(constraint.toString() + '%');

            StringBuilder s = new StringBuilder();
            s.append(""(""+People.NAME+"" LIKE "");
            s.append(filter);
            s.append("") OR (""+ContactMethods.DATA+"" LIKE "");
            s.append(filter);
            s.append("")"");

            where = s.toString();
        }

        return mContentResolver.query(CONTENT_EMAIL_URI, PROJECTION, where, null, SORT_ORDER);
    }
}
",True,190,0,0,10,56,0,2,L4
10,com.fsck.k9.MessagingControllerPushReceiver.java,"package com.fsck.k9;

import android.app.Application;
import android.content.Context;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Log;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Folder.OpenMode;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.PushReceiver;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import com.fsck.k9.service.SleepService;

import java.util.List;

public class MessagingControllerPushReceiver implements PushReceiver
{
    final Account account;
    final MessagingController controller;
    final Application mApplication;

    public MessagingControllerPushReceiver(Application nApplication, Account nAccount, MessagingController nController)
    {
        account = nAccount;
        controller = nController;
        mApplication = nApplication;
    }
    ThreadLocal<WakeLock> threadWakeLock = new ThreadLocal<WakeLock>();
    public void acquireWakeLock()
    {
        WakeLock wakeLock = threadWakeLock.get();
        if (wakeLock == null)
        {
            PowerManager pm = (PowerManager) mApplication.getSystemService(Context.POWER_SERVICE);
            wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""K9"");
            wakeLock.setReferenceCounted(false);
            threadWakeLock.set(wakeLock);
        }
        wakeLock.acquire(K9.PUSH_WAKE_LOCK_TIMEOUT);

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""Acquired WakeLock for Pushing for thread "" + Thread.currentThread().getName());
    }

    public void releaseWakeLock()
    {
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""Considering releasing WakeLock for Pushing"");

        WakeLock wakeLock = threadWakeLock.get();
        if (wakeLock != null)
        {

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Releasing WakeLock for Pushing for thread "" + Thread.currentThread().getName());

            wakeLock.release();
        }
        else
        {
            Log.e(K9.LOG_TAG, ""No WakeLock waiting to be released for thread "" + Thread.currentThread().getName());
        }
    }

    public void messagesFlagsChanged(Folder folder,
                                     List<Message> messages)
    {
        controller.messagesArrived(account, folder, messages, true);

    }
    public void messagesArrived(Folder folder, List<Message> messages)
    {
        controller.messagesArrived(account, folder, messages, false);
    }

    public void sleep(long millis)
    {
        SleepService.sleep(mApplication, millis, threadWakeLock.get(), K9.PUSH_WAKE_LOCK_TIMEOUT);
    }

    public void pushError(String errorMessage, Exception e)
    {
        String errMess = errorMessage;
        String body = null;

        if (errMess == null && e != null)
        {
            errMess = e.getMessage();
        }
        body = errMess;
        if (e != null)
        {
            body = e.toString();
        }
        controller.addErrorMessage(account, errMess, body);
    }

    public String getPushState(String folderName)
    {
        LocalFolder localFolder = null;
        try
        {
            LocalStore localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folderName);
            localFolder.open(OpenMode.READ_WRITE);
            return localFolder.getPushState();
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Unable to get push state from account "" + account.getDescription()
                  + "", folder "" + folderName, e);
            return null;
        }
        finally
        {
            if (localFolder != null)
            {
                localFolder.close();
            }
        }
    }

    public void setPushActive(String folderName, boolean enabled)
    {
        for (MessagingListener l : controller.getListeners())
        {
            l.setPushActive(account, folderName, enabled);
        }
    }

}
",True,189,0,0,7,51,1,10,L1
11,com.fsck.k9.EmailReceivedIntent.java,"package com.fsck.k9;

public class EmailReceivedIntent
{

    public static final String ACTION_EMAIL_RECEIVED = ""com.fsck.k9.intent.action.EMAIL_RECEIVED"";
    public static final String EXTRA_ACCOUNT    = ""com.fsck.k9.intent.extra.ACCOUNT"";
    public static final String EXTRA_FOLDER     = ""com.fsck.k9.intent.extra.FOLDER"";
    public static final String EXTRA_SENT_DATE  = ""com.fsck.k9.intent.extra.SENT_DATE"";
    public static final String EXTRA_FROM       = ""com.fsck.k9.intent.extra.FROM"";
    public static final String EXTRA_TO         = ""com.fsck.k9.intent.extra.TO"";
    public static final String EXTRA_CC         = ""com.fsck.k9.intent.extra.CC"";
    public static final String EXTRA_BCC        = ""com.fsck.k9.intent.extra.BCC"";
    public static final String EXTRA_SUBJECT    = ""com.fsck.k9.intent.extra.SUBJECT"";
}
",False,1,0,0,0,0,0,0,I0
12,com.fsck.k9.FixedLengthInputStream.java,"
package com.fsck.k9;

import java.io.IOException;
import java.io.InputStream;

/**
 * A filtering InputStream that stops allowing reads after the given length has been read. This
 * is used to allow a client to read directly from an underlying protocol stream without reading
 * past where the protocol handler intended the client to read.
 */
public class FixedLengthInputStream extends InputStream
{
    private InputStream mIn;
    private int mLength;
    private int mCount;

    public FixedLengthInputStream(InputStream in, int length)
    {
        this.mIn = in;
        this.mLength = length;
    }

    @Override
    public int available() throws IOException
    {
        return mLength - mCount;
    }

    @Override
    public int read() throws IOException
    {
        if (mCount < mLength)
        {
            mCount++;
            return mIn.read();
        }
        else
        {
            return -1;
        }
    }

    @Override
    public int read(byte[] b, int offset, int length) throws IOException
    {
        if (mCount < mLength)
        {
            int d = mIn.read(b, offset, Math.min(mLength - mCount, length));
            if (d == -1)
            {
                return -1;
            }
            else
            {
                mCount += d;
                return d;
            }
        }
        else
        {
            return -1;
        }
    }

    @Override
    public int read(byte[] b) throws IOException
    {
        return read(b, 0, b.length);
    }

    public String toString()
    {
        return String.format(""FixedLengthInputStream(in=%s, length=%d)"", mIn.toString(), mLength);
    }
}
",True,73,9,27,0,0,1,0,L1
13,com.fsck.k9.K9PreferenceActivity.java,"package com.fsck.k9;

import android.os.Bundle;
import android.preference.PreferenceActivity;



public class K9PreferenceActivity extends PreferenceActivity
{
    @Override
    public void onCreate(Bundle icicle)
    {
        setTheme(K9.getK9Theme());
        super.onCreate(icicle);
    }


}
",False,189,0,0,9,51,3,1,L1
14,com.fsck.k9.MessagingController.java,"
package com.fsck.k9;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import android.app.Application;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.PowerManager;
import android.os.Process;
import android.os.PowerManager.WakeLock;
import android.text.TextUtils;
import android.util.Log;

import com.fsck.k9.activity.FolderList;
import com.fsck.k9.activity.MessageList;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.FetchProfile;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessageRemovalListener;
import com.fsck.k9.mail.MessageRetrievalListener;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Part;
import com.fsck.k9.mail.PushReceiver;
import com.fsck.k9.mail.Pusher;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.Transport;
import com.fsck.k9.mail.Folder.FolderType;
import com.fsck.k9.mail.Folder.OpenMode;
import com.fsck.k9.mail.internet.MimeMessage;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.internet.TextBody;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import com.fsck.k9.mail.store.LocalStore.LocalMessage;
import com.fsck.k9.mail.store.LocalStore.PendingCommand;


/**
 * Starts a long running (application) Thread that will run through commands
 * that require remote mailbox access. This class is used to serialize and
 * prioritize these commands. Each method that will submit a command requires a
 * MessagingListener instance to be provided. It is expected that that listener
 * has also been added as a registered listener using addListener(). When a
 * command is to be executed, if the listener that was provided with the command
 * is no longer registered the command is skipped. The design idea for the above
 * is that when an Activity starts it registers as a listener. When it is paused
 * it removes itself. Thus, any commands that that activity submitted are
 * removed from the queue once the activity is no longer active.
 */
public class MessagingController implements Runnable
{
    /**
     * The maximum message size that we'll consider to be ""small"". A small message is downloaded
     * in full immediately instead of in pieces. Anything over this size will be downloaded in
     * pieces with attachments being left off completely and downloaded on demand.
     *
     *
     * 25k for a ""small"" message was picked by educated trial and error.
     * http://answers.google.com/answers/threadview?id=312463 claims that the
     * average size of an email is 59k, which I feel is too large for our
     * blind download. The following tests were performed on a download of
     * 25 random messages.
     * <pre>
     * 5k - 61 seconds,
     * 25k - 51 seconds,
     * 55k - 53 seconds,
     * </pre>
     * So 25k gives good performance and a reasonable data footprint. Sounds good to me.
     */
    private static final int MAX_SMALL_MESSAGE_SIZE = Store.FETCH_BODY_SANE_SUGGESTED_SIZE;

    private static final String PENDING_COMMAND_MOVE_OR_COPY = ""com.fsck.k9.MessagingController.moveOrCopy"";
    private static final String PENDING_COMMAND_MOVE_OR_COPY_BULK = ""com.fsck.k9.MessagingController.moveOrCopyBulk"";
    private static final String PENDING_COMMAND_EMPTY_TRASH = ""com.fsck.k9.MessagingController.emptyTrash"";
    private static final String PENDING_COMMAND_SET_FLAG_BULK = ""com.fsck.k9.MessagingController.setFlagBulk"";
    private static final String PENDING_COMMAND_SET_FLAG = ""com.fsck.k9.MessagingController.setFlag"";
    private static final String PENDING_COMMAND_APPEND = ""com.fsck.k9.MessagingController.append"";
    private static final String PENDING_COMMAND_MARK_ALL_AS_READ = ""com.fsck.k9.MessagingController.markAllAsRead"";
    private static final String PENDING_COMMAND_EXPUNGE = ""com.fsck.k9.MessagingController.expunge"";

    private static MessagingController inst = null;
    private BlockingQueue<Command> mCommands = new PriorityBlockingQueue<Command>();

    private Thread mThread;
    private Set<MessagingListener> mListeners = new CopyOnWriteArraySet<MessagingListener>();

    private HashMap<SORT_TYPE, Boolean> sortAscending = new HashMap<SORT_TYPE, Boolean>();

    private ConcurrentHashMap<String, AtomicInteger> sendCount = new ConcurrentHashMap<String, AtomicInteger>();

    ConcurrentHashMap<Account, Pusher> pushers = new ConcurrentHashMap<Account, Pusher>();

    private final ExecutorService threadPool = Executors.newFixedThreadPool(5);

    public enum SORT_TYPE
    {
        SORT_DATE(R.string.sort_earliest_first, R.string.sort_latest_first, false),
        SORT_SUBJECT(R.string.sort_subject_alpha, R.string.sort_subject_re_alpha, true),
        SORT_SENDER(R.string.sort_sender_alpha, R.string.sort_sender_re_alpha, true),
        SORT_UNREAD(R.string.sort_unread_first, R.string.sort_unread_last, true),
        SORT_FLAGGED(R.string.sort_flagged_first, R.string.sort_flagged_last, true),
        SORT_ATTACHMENT(R.string.sort_attach_first, R.string.sort_unattached_first, true);

        private int ascendingToast;
        private int descendingToast;
        private boolean defaultAscending;

        SORT_TYPE(int ascending, int descending, boolean ndefaultAscending)
        {
            ascendingToast = ascending;
            descendingToast = descending;
            defaultAscending = ndefaultAscending;
        }

        public int getToast(boolean ascending)
        {
            if (ascending)
            {
                return ascendingToast;
            }
            else
            {
                return descendingToast;
            }
        }
        public boolean isDefaultAscending()
        {
            return defaultAscending;
        }
    };
    private SORT_TYPE sortType = SORT_TYPE.SORT_DATE;

    private MessagingListener checkMailListener = null;

    private MemorizingListener memorizingListener = new MemorizingListener();

    private boolean mBusy;
    private Application mApplication;

    // Key is accountUuid:folderName:messageUid   ,   value is unimportant
    private ConcurrentHashMap<String, String> deletedUids = new ConcurrentHashMap<String, String>();

    // Key is accountUuid:folderName   ,  value is a long of the highest message UID ever emptied from Trash
    private ConcurrentHashMap<String, Long> expungedUid = new ConcurrentHashMap<String, Long>();


    private String createMessageKey(Account account, String folder, Message message)
    {
        return createMessageKey(account, folder, message.getUid());
    }

    private String createMessageKey(Account account, String folder, String uid)
    {
        return account.getUuid() + "":"" + folder + "":"" + uid;
    }

    private String createFolderKey(Account account, String folder)
    {
        return account.getUuid() + "":"" + folder;
    }

    private void suppressMessage(Account account, String folder, Message message)
    {

        if (account == null || folder == null || message == null)
        {
            return;
        }
        String messKey = createMessageKey(account, folder, message);
        deletedUids.put(messKey, ""true"");
    }

    private void unsuppressMessage(Account account, String folder, Message message)
    {
        if (account == null || folder == null || message == null)
        {
            return;
        }
        unsuppressMessage(account, folder, message.getUid());
    }

    private void unsuppressMessage(Account account, String folder, String uid)
    {
        if (account == null || folder == null || uid == null)
        {
            return;
        }
        String messKey = createMessageKey(account, folder, uid);
        deletedUids.remove(messKey);
    }


    private boolean isMessageSuppressed(Account account, String folder, Message message)
    {
        if (account == null || folder == null || message == null)
        {
            return false;
        }
        String messKey = createMessageKey(account, folder, message);

        if (deletedUids.containsKey(messKey))
        {
            return true;
        }
        Long expungedUidL = expungedUid.get(createFolderKey(account, folder));
        if (expungedUidL != null)
        {
            long expungedUid = expungedUidL;
            String messageUidS = message.getUid();
            try
            {
                long messageUid = Long.parseLong(messageUidS);
                if (messageUid <= expungedUid)
                {
                    return false;
                }
            }
            catch (NumberFormatException nfe)
            {
                // Nothing to do
            }
        }
        return false;
    }




    private MessagingController(Application application)
    {
        mApplication = application;
        mThread = new Thread(this);
        mThread.start();
        if (memorizingListener != null)
        {
            addListener(memorizingListener);
        }
    }

    /**
     * Gets or creates the singleton instance of MessagingController. Application is used to
     * provide a Context to classes that need it.
     * @param application
     * @return
     */
    public synchronized static MessagingController getInstance(Application application)
    {
        if (inst == null)
        {
            inst = new MessagingController(application);
        }
        return inst;
    }

    public boolean isBusy()
    {
        return mBusy;
    }

    public void run()
    {
        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
        while (true)
        {
            String commandDescription = null;
            try
            {
                Command command = mCommands.take();

                if (command != null)
                {
                    commandDescription = command.description;

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Running "" + (command.isForeground ? ""Foreground"" : ""Background"") + "" command '"" + command.description + ""', seq = "" + command.sequence);

                    mBusy = true;
                    command.runnable.run();

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, (command.isForeground ? ""Foreground"" : ""Background"") +
                              "" Command '"" + command.description + ""' completed"");

                    for (MessagingListener l : getListeners())
                    {
                        l.controllerCommandCompleted(mCommands.size() > 0);
                    }
                    if (command.listener != null && !getListeners().contains(command.listener))
                    {
                        command.listener.controllerCommandCompleted(mCommands.size() > 0);
                    }
                }
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Error running command '"" + commandDescription + ""'"", e);
            }
            mBusy = false;
        }
    }

    private void put(String description, MessagingListener listener, Runnable runnable)
    {
        putCommand(mCommands, description, listener, runnable, true);
    }

    private void putBackground(String description, MessagingListener listener, Runnable runnable)
    {
        putCommand(mCommands, description, listener, runnable, false);
    }

    private void putCommand(BlockingQueue<Command> queue, String description, MessagingListener listener, Runnable runnable, boolean isForeground)
    {
        int retries = 10;
        Exception e = null;
        while (retries-- > 0)
        {
            try
            {
                Command command = new Command();
                command.listener = listener;
                command.runnable = runnable;
                command.description = description;
                command.isForeground = isForeground;
                queue.put(command);
                return;
            }
            catch (InterruptedException ie)
            {
                try
                {
                    Thread.sleep(200);
                }
                catch (InterruptedException ne)
                {
                }
                e = ie;
            }
        }
        throw new Error(e);
    }


    public void addListener(MessagingListener listener)
    {
        mListeners.add(listener);
        refreshListener(listener);
    }

    public void refreshListener(MessagingListener listener)
    {
        if (memorizingListener != null && listener != null)
        {
            memorizingListener.refreshOther(listener);
        }
    }

    public void removeListener(MessagingListener listener)
    {
        mListeners.remove(listener);
    }

    public Set<MessagingListener> getListeners()
    {
        return mListeners;
    }

    /**
     * Lists folders that are available locally and remotely. This method calls
     * listFoldersCallback for local folders before it returns, and then for
     * remote folders at some later point. If there are no local folders
     * includeRemote is forced by this method. This method should be called from
     * a Thread as it may take several seconds to list the local folders.
     * TODO this needs to cache the remote folder list
     *
     * @param account
     * @param includeRemote
     * @param listener
     * @throws MessagingException
     */
    public void listFolders(final Account account, final boolean refreshRemote, final MessagingListener listener)
    {
        threadPool.execute(new Runnable()
        {
            public void run()
            {
                for (MessagingListener l : getListeners())
                {
                    l.listFoldersStarted(account);
                }
                if (listener != null)
                {
                    listener.listFoldersStarted(account);
                }
                Folder[] localFolders = null;
                try
                {
                    Store localStore = account.getLocalStore();
                    localFolders = localStore.getPersonalNamespaces();

                    if (refreshRemote || localFolders == null || localFolders.length == 0)
                    {
                        doRefreshRemote(account, listener);
                        return;
                    }
                    for (MessagingListener l : getListeners())
                    {
                        l.listFolders(account, localFolders);
                    }
                    if (listener != null)
                    {
                        listener.listFolders(account, localFolders);
                    }
                }
                catch (Exception e)
                {
                    for (MessagingListener l : getListeners())
                    {
                        l.listFoldersFailed(account, e.getMessage());
                    }
                    if (listener != null)
                    {
                        listener.listFoldersFailed(account, e.getMessage());
                    }
                    addErrorMessage(account, e);
                    return;
                }
                finally
                {
                    if (localFolders != null)
                    {
                        for (Folder localFolder : localFolders)
                        {
                            if (localFolder != null)
                            {
                                localFolder.close();
                            }
                        }
                    }
                }

                for (MessagingListener l : getListeners())
                {
                    l.listFoldersFinished(account);
                }
                if (listener != null)
                {
                    listener.listFoldersFinished(account);
                }
            }
        });
    }

    private void doRefreshRemote(final Account account, MessagingListener listener)
    {
        put(""doRefreshRemote"", listener, new Runnable()
        {
            public void run()
            {
                Folder[] localFolders = null;
                try
                {
                    Store store = account.getRemoteStore();

                    Folder[] remoteFolders = store.getPersonalNamespaces();

                    LocalStore localStore = account.getLocalStore();
                    HashSet<String> remoteFolderNames = new HashSet<String>();
                    for (int i = 0, count = remoteFolders.length; i < count; i++)
                    {
                        LocalFolder localFolder = localStore.getFolder(remoteFolders[i].getName());
                        if (!localFolder.exists())
                        {
                            localFolder.create(FolderType.HOLDS_MESSAGES, account.getDisplayCount());
                        }
                        remoteFolderNames.add(remoteFolders[i].getName());
                    }

                    localFolders = localStore.getPersonalNamespaces();

                    /*
                     * Clear out any folders that are no longer on the remote store.
                     */
                    for (Folder localFolder : localFolders)
                    {
                        String localFolderName = localFolder.getName();
                        if (localFolderName.equalsIgnoreCase(K9.INBOX) ||
                                localFolderName.equals(account.getTrashFolderName()) ||
                                localFolderName.equals(account.getOutboxFolderName()) ||
                                localFolderName.equals(account.getDraftsFolderName()) ||
                                localFolderName.equals(account.getSentFolderName()) ||
                                localFolderName.equals(account.getErrorFolderName()))
                        {
                            continue;
                        }
                        if (!remoteFolderNames.contains(localFolder.getName()))
                        {
                            localFolder.delete(false);
                        }
                    }

                    localFolders = localStore.getPersonalNamespaces();

                    for (MessagingListener l : getListeners())
                    {
                        l.listFolders(account, localFolders);
                    }
                    for (MessagingListener l : getListeners())
                    {
                        l.listFoldersFinished(account);
                    }
                }
                catch (Exception e)
                {
                    for (MessagingListener l : getListeners())
                    {
                        l.listFoldersFailed(account, """");
                    }
                    addErrorMessage(account, e);
                }
                finally
                {
                    if (localFolders != null)
                    {
                        for (Folder localFolder : localFolders)
                        {
                            if (localFolder != null)
                            {
                                localFolder.close();
                            }
                        }
                    }
                }
            }
        });
    }



    /**
     * List the messages in the local message store for the given folder asynchronously.
     *
     * @param account
     * @param folder
     * @param listener
     * @throws MessagingException
     */
    public void listLocalMessages(final Account account, final String folder, final MessagingListener listener)
    {
        threadPool.execute(new Runnable()
        {
            public void run()
            {
                listLocalMessagesSynchronous(account, folder, listener);
            }
        });
    }


    /**
     * List the messages in the local message store for the given folder synchronously.
     *
     * @param account
     * @param folder
     * @param listener
     * @throws MessagingException
     */
    public void listLocalMessagesSynchronous(final Account account, final String folder, final MessagingListener listener)
    {

        for (MessagingListener l : getListeners())
        {
            l.listLocalMessagesStarted(account, folder);
        }

        if (listener != null && getListeners().contains(listener) == false)
        {
            listener.listLocalMessagesStarted(account, folder);
        }

        Folder localFolder = null;
        MessageRetrievalListener retrievalListener =
            new MessageRetrievalListener()
        {
            List<Message> pendingMessages = new ArrayList<Message>();


            int totalDone = 0;


            public void messageStarted(String message, int number, int ofTotal) {}
            public void messageFinished(Message message, int number, int ofTotal)
            {

                if (isMessageSuppressed(account, folder, message) == false)
                {
                    pendingMessages.add(message);
                    totalDone++;
                    if (pendingMessages.size() > 10)
                    {
                        addPendingMessages();
                    }

                }
                else
                {
                    for (MessagingListener l : getListeners())
                    {
                        l.listLocalMessagesRemoveMessage(account, folder, message);
                    }
                    if (listener != null && getListeners().contains(listener) == false)
                    {
                        listener.listLocalMessagesRemoveMessage(account, folder, message);
                    }

                }
            }
            public void messagesFinished(int number)
            {
                addPendingMessages();
            }
            private void addPendingMessages()
            {
                for (MessagingListener l : getListeners())
                {
                    l.listLocalMessagesAddMessages(account, folder, pendingMessages);
                }
                if (listener != null && getListeners().contains(listener) == false)
                {
                    listener.listLocalMessagesAddMessages(account, folder, pendingMessages);
                }
                pendingMessages.clear();
            }
        };



        try
        {
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folder);
            localFolder.open(OpenMode.READ_WRITE);

            localFolder.getMessages(
                retrievalListener,
                false // Skip deleted messages
            );
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""Got ack that callbackRunner finished"");

            for (MessagingListener l : getListeners())
            {
                l.listLocalMessagesFinished(account, folder);
            }
            if (listener != null && getListeners().contains(listener) == false)
            {
                listener.listLocalMessagesFinished(account, folder);
            }
        }
        catch (Exception e)
        {
            for (MessagingListener l : getListeners())
            {
                l.listLocalMessagesFailed(account, folder, e.getMessage());
            }
            if (listener != null && getListeners().contains(listener) == false)
            {
                listener.listLocalMessagesFailed(account, folder, e.getMessage());
            }
            addErrorMessage(account, e);
        }
        finally
        {
            if (localFolder != null)
            {
                localFolder.close();
            }
        }
    }


    /**
     * Find all messages in any local account which match the query 'query'
     *
     * @param account
     * @param query
     * @param listener
     * @throws MessagingException
     */
    public void searchLocalMessages(final Account account, final String query, final MessagingListener listener)
    {

        if (listener == null)
        {
            return;
        }
        threadPool.execute(new Runnable()
        {
            public void run()
            {


                Preferences prefs = Preferences.getPreferences(mApplication.getApplicationContext());
                Account[] accounts = prefs.getAccounts();

                listener.listLocalMessagesStarted(account, null);
                for (final Account account : accounts)
                {


                    MessageRetrievalListener retrievalListener = new MessageRetrievalListener()
                    {


                        int totalDone = 0;

                        public void messageStarted(String message, int number, int ofTotal) {}
                        public void messageFinished(Message message, int number, int ofTotal)
                        {
                            List<Message> messages = new ArrayList<Message>();
                            messages.add(message);
                            listener.listLocalMessagesAddMessages(account, null, messages);
                        }
                        public void messagesFinished(int number) {}
                        private void addPendingMessages() {}
                    };



                    try
                    {
                        LocalStore localStore = account.getLocalStore();
                        localStore.searchForMessages(retrievalListener, query);
                    }
                    catch (Exception e)
                    {
                        listener.listLocalMessagesFailed(account, null, e.getMessage());
                        addErrorMessage(account, e);
                    }
                    finally
                    {
                        listener.listLocalMessagesFinished(account, null);
                    }
                }
            }
        });
    }

    public void loadMoreMessages(Account account, String folder, MessagingListener listener)
    {
        try
        {
            LocalStore localStore = account.getLocalStore();
            LocalFolder localFolder = localStore.getFolder(folder);
            localFolder.setVisibleLimit(localFolder.getVisibleLimit() + account.getDisplayCount());
            synchronizeMailbox(account, folder, listener);
        }
        catch (MessagingException me)
        {
            addErrorMessage(account, me);

            throw new RuntimeException(""Unable to set visible limit on folder"", me);
        }
    }

    public void resetVisibleLimits(Account[] accounts)
    {
        for (Account account : accounts)
        {
            try
            {
                LocalStore localStore = account.getLocalStore();
                localStore.resetVisibleLimits(account.getDisplayCount());
            }
            catch (MessagingException e)
            {
                addErrorMessage(account, e);

                Log.e(K9.LOG_TAG, ""Unable to reset visible limits"", e);
            }
        }
    }

    /**
     * Start background synchronization of the specified folder.
     * @param account
     * @param folder
     * @param listener
     */
    public void synchronizeMailbox(final Account account, final String folder, final MessagingListener listener)
    {
        putBackground(""synchronizeMailbox"", listener, new Runnable()
        {
            public void run()
            {
                synchronizeMailboxSynchronous(account, folder, listener);
            }
        });
    }

    /**
     * Start foreground synchronization of the specified folder. This is generally only called
     * by synchronizeMailbox.
     * @param account
     * @param folder
     *
     * TODO Break this method up into smaller chunks.
     */
    public void synchronizeMailboxSynchronous(final Account account, final String folder, final MessagingListener listener)
    {
        Folder remoteFolder = null;
        LocalFolder tLocalFolder = null;
        /*
         * We don't ever sync the Outbox or errors folder
         */
        if (folder.equals(account.getOutboxFolderName()) || folder.equals(account.getErrorFolderName()))
        {
            return;
        }

        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Synchronizing folder "" + account.getDescription() + "":"" + folder);

        for (MessagingListener l : getListeners())
        {
            l.synchronizeMailboxStarted(account, folder);
        }
        if (listener != null && getListeners().contains(listener) == false)
        {
            listener.synchronizeMailboxStarted(account, folder);
        }

        Exception commandException = null;
        try
        {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""SYNC: About to process pending commands for account "" +
                      account.getDescription());

            try
            {
                processPendingCommandsSynchronous(account);
            }
            catch (Exception e)
            {
                addErrorMessage(account, e);

                Log.e(K9.LOG_TAG, ""Failure processing command, but allow message sync attempt"", e);
                commandException = e;
            }

            /*
             * Get the message list from the local store and create an index of
             * the uids within the list.
             */
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""SYNC: About to get local folder "" + folder);

            final LocalStore localStore = account.getLocalStore();
            tLocalFolder = localStore.getFolder(folder);
            final LocalFolder localFolder = tLocalFolder;
            localFolder.open(OpenMode.READ_WRITE);
            Message[] localMessages = localFolder.getMessages(null);
            HashMap<String, Message> localUidMap = new HashMap<String, Message>();
            for (Message message : localMessages)
            {
                localUidMap.put(message.getUid(), message);
            }

            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""SYNC: About to get remote store for "" + folder);

            Store remoteStore = account.getRemoteStore();

            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""SYNC: About to get remote folder "" + folder);

            remoteFolder = remoteStore.getFolder(folder);

            /*
             * If the folder is a ""special"" folder we need to see if it exists
             * on the remote server. It if does not exist we'll try to create it. If we
             * can't create we'll abort. This will happen on every single Pop3 folder as
             * designed and on Imap folders during error conditions. This allows us
             * to treat Pop3 and Imap the same in this code.
             */
            if (folder.equals(account.getTrashFolderName()) ||
                    folder.equals(account.getSentFolderName()) ||
                    folder.equals(account.getDraftsFolderName()))
            {
                if (!remoteFolder.exists())
                {
                    if (!remoteFolder.create(FolderType.HOLDS_MESSAGES))
                    {
                        for (MessagingListener l : getListeners())
                        {
                            l.synchronizeMailboxFinished(account, folder, 0, 0);
                        }
                        if (listener != null && getListeners().contains(listener) == false)
                        {
                            listener.synchronizeMailboxFinished(account, folder, 0, 0);
                        }
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Done synchronizing folder "" + folder);

                        return;
                    }
                }
            }

            /*
             * Synchronization process:
            Open the folder
            Upload any local messages that are marked as PENDING_UPLOAD (Drafts, Sent, Trash)
            Get the message count
            Get the list of the newest K9.DEFAULT_VISIBLE_LIMIT messages
            getMessages(messageCount - K9.DEFAULT_VISIBLE_LIMIT, messageCount)
            See if we have each message locally, if not fetch it's flags and envelope
            Get and update the unread count for the folder
            Update the remote flags of any messages we have locally with an internal date
            newer than the remote message.
            Get the current flags for any messages we have locally but did not just download
            Update local flags
            For any message we have locally but not remotely, delete the local message to keep
            cache clean.
            Download larger parts of any new messages.
            (Optional) Download small attachments in the background.
             */

            /*
             * Open the remote folder. This pre-loads certain metadata like message count.
             */
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""SYNC: About to open remote folder "" + folder);

            remoteFolder.open(OpenMode.READ_WRITE);

            if (Account.EXPUNGE_ON_POLL.equals(account.getExpungePolicy()))
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SYNC: Expunging folder "" + account.getDescription() + "":"" + folder);

                remoteFolder.expunge();
            }


            /*
             * Get the remote message count.
             */
            int remoteMessageCount = remoteFolder.getMessageCount();

            int visibleLimit = localFolder.getVisibleLimit();

            Message[] remoteMessageArray = new Message[0];
            final ArrayList<Message> remoteMessages = new ArrayList<Message>();
            //  final ArrayList<Message> unsyncedMessages = new ArrayList<Message>();
            HashMap<String, Message> remoteUidMap = new HashMap<String, Message>();

            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""SYNC: Remote message count for folder "" + folder + "" is "" + remoteMessageCount);

            if (remoteMessageCount > 0)
            {
                /*
                 * Message numbers start at 1.
                 */
                int remoteStart = Math.max(0, remoteMessageCount - visibleLimit) + 1;
                int remoteEnd = remoteMessageCount;

                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""SYNC: About to get messages "" + remoteStart + "" through "" + remoteEnd + "" for folder "" + folder);

                remoteMessageArray = remoteFolder.getMessages(remoteStart, remoteEnd, null);
                for (Message thisMess : remoteMessageArray)
                {
                    remoteMessages.add(thisMess);
                    remoteUidMap.put(thisMess.getUid(), thisMess);
                }
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""SYNC: Got "" + remoteUidMap.size() + "" messages for folder "" + folder);

                remoteMessageArray = null;

            }
            else if (remoteMessageCount < 0)
            {
                throw new Exception(""Message count "" + remoteMessageCount + "" for folder "" + folder);
            }

            /*
             * Remove any messages that are in the local store but no longer on the remote store.
             */
            for (Message localMessage : localMessages)
            {
                if (remoteUidMap.get(localMessage.getUid()) == null && !localMessage.isSet(Flag.DELETED))
                {
                    localMessage.setFlag(Flag.X_DESTROYED, true);

                    for (MessagingListener l : getListeners())
                    {
                        l.synchronizeMailboxRemovedMessage(account, folder, localMessage);
                    }
                    if (listener != null && getListeners().contains(listener) == false)
                    {
                        listener.synchronizeMailboxRemovedMessage(account, folder, localMessage);
                    }
                }
            }
            localMessages = null;

            /*
             * Now we download the actual content of messages.
             */
            int newMessages = downloadMessages(account, remoteFolder, localFolder, remoteMessages, false);

            int unreadMessageCount = setLocalUnreadCountToRemote(localFolder, remoteFolder,  newMessages);

            for (MessagingListener l : getListeners())
            {
                l.folderStatusChanged(account, folder, unreadMessageCount);
            }

            /*
             * Notify listeners that we're finally done.
             */

            localFolder.setLastChecked(System.currentTimeMillis());
            localFolder.setStatus(null);

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Done synchronizing folder "" +
                      account.getDescription() + "":"" + folder + "" @ "" + new Date() +
                      "" with "" + newMessages + "" new messages"");

            for (MessagingListener l : getListeners())
            {
                l.synchronizeMailboxFinished(account, folder, remoteMessageCount, newMessages);
            }
            if (listener != null && getListeners().contains(listener) == false)
            {
                listener.synchronizeMailboxFinished(account, folder, remoteMessageCount, newMessages);
            }


            if (commandException != null)
            {
                String rootMessage = getRootCauseMessage(commandException);
                Log.e(K9.LOG_TAG, ""Root cause failure in "" + account.getDescription() + "":"" +
                      tLocalFolder.getName() + "" was '"" + rootMessage + ""'"");
                localFolder.setStatus(rootMessage);
                for (MessagingListener l : getListeners())
                {
                    l.synchronizeMailboxFailed(account, folder, rootMessage);
                }
                if (listener != null && getListeners().contains(listener) == false)
                {
                    listener.synchronizeMailboxFailed(account, folder, rootMessage);
                }
            }

            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""Done synchronizing folder "" + account.getDescription() + "":"" + folder);

        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""synchronizeMailbox"", e);
            // If we don't set the last checked, it can try too often during
            // failure conditions
            String rootMessage = getRootCauseMessage(e);
            if (tLocalFolder != null)
            {
                try
                {
                    tLocalFolder.setStatus(rootMessage);
                    tLocalFolder.setLastChecked(System.currentTimeMillis());
                }
                catch (MessagingException me)
                {
                    Log.e(K9.LOG_TAG, ""Could not set last checked on folder "" + account.getDescription() + "":"" +
                          tLocalFolder.getName(), e);
                }
            }

            for (MessagingListener l : getListeners())
            {
                l.synchronizeMailboxFailed(
                    account,
                    folder,
                    rootMessage);
            }
            if (listener != null && getListeners().contains(listener) == false)
            {
                listener.synchronizeMailboxFailed(
                    account,
                    folder,
                    rootMessage);
            }
            addErrorMessage(account, e);
            Log.e(K9.LOG_TAG, ""Failed synchronizing folder "" +
                  account.getDescription() + "":"" + folder + "" @ "" + new Date());

        }
        finally
        {
            if (remoteFolder != null)
            {
                remoteFolder.close();
            }
            if (tLocalFolder != null)
            {
                tLocalFolder.close();
            }
        }

    }

    private int setLocalUnreadCountToRemote(LocalFolder localFolder, Folder remoteFolder, int newMessageCount) throws MessagingException
    {
        int remoteUnreadMessageCount = remoteFolder.getUnreadMessageCount();
        if (remoteUnreadMessageCount != -1)
        {
            localFolder.setUnreadMessageCount(remoteUnreadMessageCount);
            return remoteUnreadMessageCount;
        }
        else
        {
            return localFolder.getMessageCount();
        }
    }

    private int downloadMessages(final Account account, final Folder remoteFolder,
                                 final LocalFolder localFolder, List<Message> inputMessages, boolean flagSyncOnly) throws MessagingException
    {
        final String folder = remoteFolder.getName();

        ArrayList<Message> syncFlagMessages = new ArrayList<Message>();
        List<Message> unsyncedMessages = new ArrayList<Message>();
        final AtomicInteger newMessages = new AtomicInteger(0);

        List<Message> messages = new ArrayList<Message>(inputMessages);

        for (Message message : messages)
        {
            if (isMessageSuppressed(account, folder, message) == false)
            {
                Message localMessage = localFolder.getMessage(message.getUid());

                if (localMessage == null)
                {
                    if (!flagSyncOnly)
                    {
                        if (!message.isSet(Flag.X_DOWNLOADED_FULL) && !message.isSet(Flag.X_DOWNLOADED_PARTIAL))
                        {
                            if (K9.DEBUG)
                                Log.v(K9.LOG_TAG, ""Message with uid "" + message.getUid() + "" is not downloaded at all"");

                            unsyncedMessages.add(message);
                        }
                        else
                        {
                            if (K9.DEBUG)
                                Log.v(K9.LOG_TAG, ""Message with uid "" + message.getUid() + "" is partially or fully downloaded"");

                            // Store the updated message locally
                            localFolder.appendMessages(new Message[] { message });

                            localMessage = localFolder.getMessage(message.getUid());

                            localMessage.setFlag(Flag.X_DOWNLOADED_FULL, message.isSet(Flag.X_DOWNLOADED_FULL));
                            localMessage.setFlag(Flag.X_DOWNLOADED_PARTIAL, message.isSet(Flag.X_DOWNLOADED_PARTIAL));

                            for (MessagingListener l : getListeners())
                            {
                                l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                                if (!localMessage.isSet(Flag.SEEN))
                                {
                                    l.synchronizeMailboxNewMessage(account, folder, localMessage);
                                }
                            }
                        }
                    }
                }
                else if (localMessage.isSet(Flag.DELETED) == false)
                {
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""Message with uid "" + message.getUid() + "" is already locally present"");

                    String newPushState = remoteFolder.getNewPushState(localFolder.getPushState(), message);
                    if (newPushState != null)
                    {
                        localFolder.setPushState(newPushState);
                    }
                    if (!localMessage.isSet(Flag.X_DOWNLOADED_FULL) && !localMessage.isSet(Flag.X_DOWNLOADED_PARTIAL))
                    {
                        if (K9.DEBUG)
                            Log.v(K9.LOG_TAG, ""Message with uid "" + message.getUid()
                                  + "" is not downloaded, even partially; trying again"");

                        unsyncedMessages.add(message);
                    }
                    else
                    {
                        syncFlagMessages.add(message);
                    }
                }
            }
        }

        final AtomicInteger progress = new AtomicInteger(0);
        final int todo = unsyncedMessages.size() + syncFlagMessages.size();
        for (MessagingListener l : getListeners())
        {
            l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
        }

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Have "" + unsyncedMessages.size() + "" unsynced messages"");

        messages.clear();
        final ArrayList<Message> largeMessages = new ArrayList<Message>();
        final ArrayList<Message> smallMessages = new ArrayList<Message>();
        if (unsyncedMessages.size() > 0)
        {

            /*
             * Reverse the order of the messages. Depending on the server this may get us
             * fetch results for newest to oldest. If not, no harm done.
             */
            Collections.reverse(unsyncedMessages);
            int visibleLimit = localFolder.getVisibleLimit();
            int listSize = unsyncedMessages.size();

            if (listSize > visibleLimit)
            {
                unsyncedMessages = unsyncedMessages.subList(listSize - visibleLimit, listSize);
            }

            FetchProfile fp = new FetchProfile();
            if (remoteFolder.supportsFetchingFlags())
            {
                fp.add(FetchProfile.Item.FLAGS);
            }
            fp.add(FetchProfile.Item.ENVELOPE);

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""SYNC: About to sync "" + unsyncedMessages.size() + "" unsynced messages for folder "" + folder);

            remoteFolder.fetch(unsyncedMessages.toArray(new Message[0]), fp,
                               new MessageRetrievalListener()
            {
                public void messageFinished(Message message, int number, int ofTotal)
                {
                    try
                    {
                        String newPushState = remoteFolder.getNewPushState(localFolder.getPushState(), message);
                        if (newPushState != null)
                        {
                            localFolder.setPushState(newPushState);
                        }
                        if (message.isSet(Flag.DELETED))
                        {
                            if (K9.DEBUG)
                                Log.v(K9.LOG_TAG, ""Newly downloaded message "" + account + "":"" + folder + "":"" + message.getUid()
                                      + "" was already deleted on server, skipping"");
                            return;
                        }

                        // Store the new message locally
                        localFolder.appendMessages(new Message[]
                                                   {
                                                       message
                                                   });

                        if (message.getSize() > (MAX_SMALL_MESSAGE_SIZE))
                        {
                            largeMessages.add(message);
                        }
                        else
                        {
                            smallMessages.add(message);
                        }
                       
                        // And include it in the view
                        if (message.getSubject() != null &&
                                message.getFrom() != null)
                        {
                            /*
                             * We check to make sure that we got something worth
                             * showing (subject and from) because some protocols
                             * (POP) may not be able to give us headers for
                             * ENVELOPE, only size.
                             */
                            if (isMessageSuppressed(account, folder, message) == false)
                            {
                                Message localMessage = localFolder.getMessage(message.getUid());
                                syncFlags(localMessage, message);
                                if (K9.DEBUG)
                                    Log.v(K9.LOG_TAG, ""About to notify listeners that we got a new unsynced message ""
                                          + account + "":"" + folder + "":"" + message.getUid());
                                for (MessagingListener l : getListeners())
                                {
                                    l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                                }

                                // Send a notification of this message
                                if (notifyAccount(mApplication, account, message) == true)
                                {
                                    newMessages.incrementAndGet();
                                }
                                
                            }

                        }

                    }
                    catch (Exception e)
                    {
                        Log.e(K9.LOG_TAG, ""Error while storing downloaded message."", e);
                        addErrorMessage(account, e);

                    }
                }

                public void messageStarted(String uid, int number, int ofTotal)
                {
                }

                public void messagesFinished(int total) {}
            });
            // If a message didn't exist, messageFinished won't be called, but we shouldn't try again
            // If we got here, nothing failed
            for (Message message : unsyncedMessages)
            {
                String newPushState = remoteFolder.getNewPushState(localFolder.getPushState(), message);
                if (newPushState != null)
                {
                    localFolder.setPushState(newPushState);
                }
            }
            if (K9.DEBUG)
            {
                Log.d(K9.LOG_TAG, ""SYNC: Synced unsynced messages for folder "" + folder);
            }


        }

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Have ""
                  + largeMessages.size() + "" large messages and ""
                  + smallMessages.size() + "" small messages out of ""
                  + unsyncedMessages.size() + "" unsynced messages"");

        unsyncedMessages.clear();

        /*
         * Grab the content of the small messages first. This is going to
         * be very fast and at very worst will be a single up of a few bytes and a single
         * download of 625k.
         */
        FetchProfile fp = new FetchProfile();
        fp.add(FetchProfile.Item.BODY);
        //        fp.add(FetchProfile.Item.FLAGS);
        //        fp.add(FetchProfile.Item.ENVELOPE);

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Fetching small messages for folder "" + folder);

        remoteFolder.fetch(smallMessages.toArray(new Message[smallMessages.size()]),
                           fp, new MessageRetrievalListener()
        {
            public void messageFinished(Message message, int number, int ofTotal)
            {
                try
                {
                    // Store the updated message locally
                    localFolder.appendMessages(new Message[] { message });

                    Message localMessage = localFolder.getMessage(message.getUid());

                    // Set a flag indicating this message has now be fully downloaded
                    localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""About to notify listeners that we got a new small message ""
                              + account + "":"" + folder + "":"" + message.getUid());

                    progress.incrementAndGet();

                    // Update the listener with what we've found
                    for (MessagingListener l : getListeners())
                    {
                        l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                        l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
                        if (!localMessage.isSet(Flag.SEEN))
                        {
                            l.synchronizeMailboxNewMessage(account, folder, localMessage);
                        }
                    }
                    notifyAccount(mApplication, account, message);

                }
                catch (MessagingException me)
                {
                    addErrorMessage(account, me);

                    Log.e(K9.LOG_TAG, ""SYNC: fetch small messages"", me);
                }
            }

            public void messageStarted(String uid, int number, int ofTotal)
            {
            }

            public void messagesFinished(int total) {}
        });

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Done fetching small messages for folder "" + folder);

        smallMessages.clear();

        /*
         * Now do the large messages that require more round trips.
         */
        fp.clear();
        fp.add(FetchProfile.Item.STRUCTURE);

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Fetching large messages for folder "" + folder);

        remoteFolder.fetch(largeMessages.toArray(new Message[largeMessages.size()]), fp, null);
        for (Message message : largeMessages)
        {
            if (message.getBody() == null)
            {
                /*
                 * The provider was unable to get the structure of the message, so
                 * we'll download a reasonable portion of the messge and mark it as
                 * incomplete so the entire thing can be downloaded later if the user
                 * wishes to download it.
                 */
                fp.clear();
                fp.add(FetchProfile.Item.BODY_SANE);
                /*
                 *  TODO a good optimization here would be to make sure that all Stores set
                 *  the proper size after this fetch and compare the before and after size. If
                 *  they equal we can mark this SYNCHRONIZED instead of PARTIALLY_SYNCHRONIZED
                 */

                remoteFolder.fetch(new Message[] { message }, fp, null);
                // Store the updated message locally
                localFolder.appendMessages(new Message[] { message });

                Message localMessage = localFolder.getMessage(message.getUid());


                // Certain (POP3) servers give you the whole message even when you ask for only the first x Kb
                if (!message.isSet(Flag.X_DOWNLOADED_FULL))
                {
                    /*
                     * Mark the message as fully downloaded if the message size is smaller than
                     * the FETCH_BODY_SANE_SUGGESTED_SIZE, otherwise mark as only a partial
                     * download.  This will prevent the system from downloading the same message
                     * twice.
                     */
                    if (message.getSize() < Store.FETCH_BODY_SANE_SUGGESTED_SIZE)
                    {
                        localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);
                    }
                    else
                    {
                        // Set a flag indicating that the message has been partially downloaded and
                        // is ready for view.
                        localMessage.setFlag(Flag.X_DOWNLOADED_PARTIAL, true);
                    }
                }
            }
            else
            {
                /*
                 * We have a structure to deal with, from which
                 * we can pull down the parts we want to actually store.
                 * Build a list of parts we are interested in. Text parts will be downloaded
                 * right now, attachments will be left for later.
                 */

                ArrayList<Part> viewables = new ArrayList<Part>();
                ArrayList<Part> attachments = new ArrayList<Part>();
                MimeUtility.collectParts(message, viewables, attachments);

                /*
                 * Now download the parts we're interested in storing.
                 */
                for (Part part : viewables)
                {
                    fp.clear();
                    fp.add(part);
                    // TODO what happens if the network connection dies? We've got partial
                    // messages with incorrect status stored.
                    remoteFolder.fetch(new Message[] { message }, fp, null);
                }
                // Store the updated message locally
                localFolder.appendMessages(new Message[] { message });

                Message localMessage = localFolder.getMessage(message.getUid());

                // Set a flag indicating this message has been fully downloaded and can be
                // viewed.
                localMessage.setFlag(Flag.X_DOWNLOADED_PARTIAL, true);
            }
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""About to notify listeners that we got a new large message ""
                      + account + "":"" + folder + "":"" + message.getUid());

            // Update the listener with what we've found
            progress.incrementAndGet();
            for (MessagingListener l : getListeners())
            {
                Message localMessage = localFolder.getMessage(message.getUid());
                l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
                if (!localMessage.isSet(Flag.SEEN))
                {
                    l.synchronizeMailboxNewMessage(account, folder, localMessage);
                }
            }
            notifyAccount(mApplication, account, message);
        }//for large messsages
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Done fetching large messages for folder "" + folder);

        largeMessages.clear();

        /*
         * Refresh the flags for any messages in the local store that we didn't just
         * download.
         */
        if (remoteFolder.supportsFetchingFlags())
        {


            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""SYNC: About to sync flags for ""
                      + syncFlagMessages.size() + "" remote messages for folder "" + folder);


            fp.clear();
            fp.add(FetchProfile.Item.FLAGS);
            remoteFolder.fetch(syncFlagMessages.toArray(new Message[0]), fp, null);
            for (Message remoteMessage : syncFlagMessages)
            {
                Message localMessage = localFolder.getMessage(remoteMessage.getUid());
                boolean messageChanged = syncFlags(localMessage, remoteMessage);
                if (messageChanged)
                {
                    if (localMessage.isSet(Flag.DELETED) || isMessageSuppressed(account, folder, localMessage))
                    {
                        for (MessagingListener l : getListeners())
                        {
                            l.synchronizeMailboxRemovedMessage(account, folder, localMessage);
                        }
                    }
                    else
                    {
                        for (MessagingListener l : getListeners())
                        {
                            l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                        }
                    }

                }
                progress.incrementAndGet();
                for (MessagingListener l : getListeners())
                {
                    l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
                }
            }
        }
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Synced remote messages for folder "" + folder + "", "" + newMessages.get() + "" new messages"");

        localFolder.purgeToVisibleLimit(new MessageRemovalListener()
        {
            public void messageRemoved(Message message)
            {
                for (MessagingListener l : getListeners())
                {
                    l.synchronizeMailboxRemovedMessage(account, folder, message);
                }
            }

        });

        return newMessages.get();
    }


    private boolean syncFlags(Message localMessage, Message remoteMessage) throws MessagingException
    {
        boolean messageChanged = false;
        if (localMessage == null || localMessage.isSet(Flag.DELETED))
        {
            return false;
        }
        if (remoteMessage.isSet(Flag.DELETED))
        {
            localMessage.setFlag(Flag.DELETED, true);
            messageChanged = true;
        }
        for (Flag flag : new Flag[] { Flag.SEEN, Flag.FLAGGED, Flag.ANSWERED })
        {
            if (remoteMessage.isSet(flag) != localMessage.isSet(flag))
            {
                localMessage.setFlag(flag, remoteMessage.isSet(flag));
                messageChanged = true;
            }
        }
        return messageChanged;
    }
    private String getRootCauseMessage(Throwable t)
    {
        Throwable rootCause = t;
        Throwable nextCause = rootCause;
        do
        {
            nextCause = rootCause.getCause();
            if (nextCause != null)
            {
                rootCause = nextCause;
            }
        }
        while (nextCause != null);
        return rootCause.getMessage();
    }

    private void queuePendingCommand(Account account, PendingCommand command)
    {
        try
        {
            LocalStore localStore = account.getLocalStore();
            localStore.addPendingCommand(command);
        }
        catch (Exception e)
        {
            addErrorMessage(account, e);

            throw new RuntimeException(""Unable to enqueue pending command"", e);
        }
    }

    private void processPendingCommands(final Account account)
    {
        putBackground(""processPendingCommands"", null, new Runnable()
        {
            public void run()
            {
                try
                {
                    processPendingCommandsSynchronous(account);
                }
                catch (MessagingException me)
                {
                    Log.e(K9.LOG_TAG, ""processPendingCommands"", me);

                    addErrorMessage(account, me);

                    /*
                     * Ignore any exceptions from the commands. Commands will be processed
                     * on the next round.
                     */
                }
            }
        });
    }

    private void processPendingCommandsSynchronous(Account account) throws MessagingException
    {
        LocalStore localStore = account.getLocalStore();
        ArrayList<PendingCommand> commands = localStore.getPendingCommands();

        int progress = 0;
        int todo = commands.size();
        if (todo == 0)
        {
            return;
        }

        for (MessagingListener l : getListeners())
        {
            l.pendingCommandsProcessing(account);
            l.synchronizeMailboxProgress(account, null, progress, todo);
        }

        PendingCommand processingCommand = null;
        try
        {
            for (PendingCommand command : commands)
            {
                processingCommand = command;
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Processing pending command '"" + command + ""'"");

                String[] components = command.command.split(""\\."");
                String commandTitle = components[components.length - 1];
                for (MessagingListener l : getListeners())
                {
                    l.pendingCommandStarted(account, commandTitle);
                }
                /*
                 * We specifically do not catch any exceptions here. If a command fails it is
                 * most likely due to a server or IO error and it must be retried before any
                 * other command processes. This maintains the order of the commands.
                 */
                try
                {
                    if (PENDING_COMMAND_APPEND.equals(command.command))
                    {
                        processPendingAppend(command, account);
                    }
                    else if (PENDING_COMMAND_SET_FLAG_BULK.equals(command.command))
                    {
                        processPendingSetFlag(command, account);
                    }
                    else if (PENDING_COMMAND_SET_FLAG.equals(command.command))
                    {
                        processPendingSetFlagOld(command, account);
                    }
                    else if (PENDING_COMMAND_MARK_ALL_AS_READ.equals(command.command))
                    {
                        processPendingMarkAllAsRead(command, account);
                    }
                    else if (PENDING_COMMAND_MOVE_OR_COPY_BULK.equals(command.command))
                    {
                        processPendingMoveOrCopy(command, account);
                    }
                    else if (PENDING_COMMAND_MOVE_OR_COPY.equals(command.command))
                    {
                        processPendingMoveOrCopyOld(command, account);
                    }
                    else if (PENDING_COMMAND_EMPTY_TRASH.equals(command.command))
                    {
                        processPendingEmptyTrash(command, account);
                    }
                    else if (PENDING_COMMAND_EXPUNGE.equals(command.command))
                    {
                        processPendingExpunge(command, account);
                    }
                    localStore.removePendingCommand(command);
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Done processing pending command '"" + command + ""'"");
                }
                catch (MessagingException me)
                {
                    if (me.isPermanentFailure())
                    {
                        addErrorMessage(account, me);
                        Log.e(K9.LOG_TAG, ""Failure of command '"" + command + ""' was permanent, removing command from queue"");
                        localStore.removePendingCommand(processingCommand);
                    }
                    else
                    {
                        throw me;
                    }
                }
                finally
                {
                    progress++;
                    for (MessagingListener l : getListeners())
                    {
                        l.synchronizeMailboxProgress(account, null, progress, todo);
                        l.pendingCommandCompleted(account, commandTitle);
                    }
                }
            }
        }
        catch (MessagingException me)
        {
            addErrorMessage(account, me);
            Log.e(K9.LOG_TAG, ""Could not process command '"" + processingCommand + ""'"", me);
            throw me;
        }
        finally
        {
            for (MessagingListener l : getListeners())
            {
                l.pendingCommandsFinished(account);
            }
        }
    }

    /**
     * Process a pending append message command. This command uploads a local message to the
     * server, first checking to be sure that the server message is not newer than
     * the local message. Once the local message is successfully processed it is deleted so
     * that the server message will be synchronized down without an additional copy being
     * created.
     * TODO update the local message UID instead of deleteing it
     *
     * @param command arguments = (String folder, String uid)
     * @param account
     * @throws MessagingException
     */
    private void processPendingAppend(PendingCommand command, Account account)
    throws MessagingException
    {
        Folder remoteFolder = null;
        LocalFolder localFolder = null;
        try
        {

            String folder = command.arguments[0];
            String uid = command.arguments[1];

            if (account.getErrorFolderName().equals(folder))
            {
                return;
            }

            LocalStore localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folder);
            LocalMessage localMessage = (LocalMessage) localFolder.getMessage(uid);

            if (localMessage == null)
            {
                return;
            }

            Store remoteStore = account.getRemoteStore();
            remoteFolder = remoteStore.getFolder(folder);
            if (!remoteFolder.exists())
            {
                if (!remoteFolder.create(FolderType.HOLDS_MESSAGES))
                {
                    return;
                }
            }
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE)
            {
                return;
            }

            Message remoteMessage = null;
            if (!localMessage.getUid().startsWith(K9.LOCAL_UID_PREFIX))
            {
                remoteMessage = remoteFolder.getMessage(localMessage.getUid());
            }

            if (remoteMessage == null)
            {
                if (localMessage.isSet(Flag.X_REMOTE_COPY_STARTED))
                {
                    Log.w(K9.LOG_TAG, ""Local message with uid "" + localMessage.getUid() +
                          "" has flag "" + Flag.X_REMOTE_COPY_STARTED + "" already set, checking for remote message with "" +
                          "" same message id"");
                    String rUid = remoteFolder.getUidFromMessageId(localMessage);
                    if (rUid != null)
                    {
                        Log.w(K9.LOG_TAG, ""Local message has flag "" + Flag.X_REMOTE_COPY_STARTED + "" already set, and there is a remote message with "" +
                              "" uid "" + rUid + "", assuming message was already copied and aborting this copy"");

                        String oldUid = localMessage.getUid();
                        localMessage.setUid(rUid);
                        localFolder.changeUid(localMessage);
                        for (MessagingListener l : getListeners())
                        {
                            l.messageUidChanged(account, folder, oldUid, localMessage.getUid());
                        }
                        return;
                    }
                    else
                    {
                        Log.w(K9.LOG_TAG, ""No remote message with message-id found, proceeding with append"");
                    }
                }

                /*
                 * If the message does not exist remotely we just upload it and then
                 * update our local copy with the new uid.
                 */
                FetchProfile fp = new FetchProfile();
                fp.add(FetchProfile.Item.BODY);
                localFolder.fetch(new Message[]
                                  {
                                      localMessage
                                  }
                                  , fp, null);
                String oldUid = localMessage.getUid();
                localMessage.setFlag(Flag.X_REMOTE_COPY_STARTED, true);
                remoteFolder.appendMessages(new Message[] { localMessage });

                localFolder.changeUid(localMessage);
                for (MessagingListener l : getListeners())
                {
                    l.messageUidChanged(account, folder, oldUid, localMessage.getUid());
                }
            }
            else
            {
                /*
                 * If the remote message exists we need to determine which copy to keep.
                 */
                /*
                 * See if the remote message is newer than ours.
                 */
                FetchProfile fp = new FetchProfile();
                fp.add(FetchProfile.Item.ENVELOPE);
                remoteFolder.fetch(new Message[] { remoteMessage }, fp, null);
                Date localDate = localMessage.getInternalDate();
                Date remoteDate = remoteMessage.getInternalDate();
                if (remoteDate.compareTo(localDate) > 0)
                {
                    /*
                     * If the remote message is newer than ours we'll just
                     * delete ours and move on. A sync will get the server message
                     * if we need to be able to see it.
                     */
                    localMessage.setFlag(Flag.DELETED, true);
                }
                else
                {
                    /*
                     * Otherwise we'll upload our message and then delete the remote message.
                     */
                    fp.clear();
                    fp = new FetchProfile();
                    fp.add(FetchProfile.Item.BODY);
                    localFolder.fetch(new Message[] { localMessage }, fp, null);
                    String oldUid = localMessage.getUid();

                    localMessage.setFlag(Flag.X_REMOTE_COPY_STARTED, true);

                    remoteFolder.appendMessages(new Message[] { localMessage });
                    localFolder.changeUid(localMessage);
                    for (MessagingListener l : getListeners())
                    {
                        l.messageUidChanged(account, folder, oldUid, localMessage.getUid());
                    }
                    remoteMessage.setFlag(Flag.DELETED, true);
                    if (Account.EXPUNGE_IMMEDIATELY.equals(account.getExpungePolicy()))
                    {
                        remoteFolder.expunge();
                    }
                }
            }
        }
        finally
        {
            if (remoteFolder != null)
            {
                remoteFolder.close();
            }
            if (localFolder != null)
            {
                localFolder.close();
            }
        }
    }
    private void queueMoveOrCopy(Account account, String srcFolder, String destFolder, boolean isCopy, String uids[])
    {
        if (account.getErrorFolderName().equals(srcFolder))
        {
            return;
        }
        PendingCommand command = new PendingCommand();
        command.command = PENDING_COMMAND_MOVE_OR_COPY_BULK;

        int length = 3 + uids.length;
        command.arguments = new String[length];
        command.arguments[0] = srcFolder;
        command.arguments[1] = destFolder;
        command.arguments[2] = Boolean.toString(isCopy);
        for (int i = 0; i < uids.length; i++)
        {
            command.arguments[3 + i] = uids[i];
        }
        queuePendingCommand(account, command);
    }
    /**
     * Process a pending trash message command.
     *
     * @param command arguments = (String folder, String uid)
     * @param account
     * @throws MessagingException
     */
    private void processPendingMoveOrCopy(PendingCommand command, Account account)
    throws MessagingException
    {
        Folder remoteSrcFolder = null;
        Folder remoteDestFolder = null;
        try
        {
            String srcFolder = command.arguments[0];
            if (account.getErrorFolderName().equals(srcFolder))
            {
                return;
            }
            String destFolder = command.arguments[1];
            String isCopyS = command.arguments[2];
            Store remoteStore = account.getRemoteStore();
            remoteSrcFolder = remoteStore.getFolder(srcFolder);

            List<Message> messages = new ArrayList<Message>();
            for (int i = 3; i < command.arguments.length; i++)
            {
                String uid = command.arguments[i];
                if (!uid.startsWith(K9.LOCAL_UID_PREFIX))
                {
                    messages.add(remoteSrcFolder.getMessage(uid));
                }
            }

            boolean isCopy = false;
            if (isCopyS != null)
            {
                isCopy = Boolean.parseBoolean(isCopyS);
            }

            if (!remoteSrcFolder.exists())
            {
                throw new MessagingException(""processingPendingMoveOrCopy: remoteFolder "" + srcFolder + "" does not exist"", true);
            }
            remoteSrcFolder.open(OpenMode.READ_WRITE);
            if (remoteSrcFolder.getMode() != OpenMode.READ_WRITE)
            {
                throw new MessagingException(""processingPendingMoveOrCopy: could not open remoteSrcFolder "" + srcFolder + "" read/write"", true);
            }

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""processingPendingMoveOrCopy: source folder = "" + srcFolder
                      + "", "" + messages.size() + "" messages, destination folder = "" + destFolder + "", isCopy = "" + isCopy);

            if (isCopy == false && destFolder.equals(account.getTrashFolderName()))
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""processingPendingMoveOrCopy doing special case for deleting message"");

                String destFolderName = destFolder;
                if (K9.FOLDER_NONE.equals(destFolderName))
                {
                    destFolderName = null;
                }
                remoteSrcFolder.delete(messages.toArray(new Message[0]), destFolderName);
            }
            else
            {
                remoteDestFolder = remoteStore.getFolder(destFolder);

                if (isCopy)
                {
                    remoteSrcFolder.copyMessages(messages.toArray(new Message[0]), remoteDestFolder);
                }
                else
                {
                    remoteSrcFolder.moveMessages(messages.toArray(new Message[0]), remoteDestFolder);
                }
            }
            if (isCopy == false && Account.EXPUNGE_IMMEDIATELY.equals(account.getExpungePolicy()))
            {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""processingPendingMoveOrCopy expunging folder "" + account.getDescription() + "":"" + srcFolder);

                remoteSrcFolder.expunge();
            }
        }
        finally
        {
            if (remoteSrcFolder != null)
            {
                remoteSrcFolder.close();
            }
            if (remoteDestFolder != null)
            {
                remoteDestFolder.close();
            }
        }


    }

    private void queueSetFlag(final Account account, final String folderName, final String newState, final String flag, final String[] uids)
    {
        putBackground(""queueSetFlag "" + account.getDescription() + "":"" + folderName, null, new Runnable()
        {
            public void run()
            {
                PendingCommand command = new PendingCommand();
                command.command = PENDING_COMMAND_SET_FLAG_BULK;
                int length = 3 + uids.length;
                command.arguments = new String[length];
                command.arguments[0] = folderName;
                command.arguments[1] = newState;
                command.arguments[2] = flag;
                for (int i = 0; i < uids.length; i++)
                {
                    command.arguments[3 + i] = uids[i];
                }
                queuePendingCommand(account, command);
                processPendingCommands(account);
            }
        });
    }
    /**
     * Processes a pending mark read or unread command.
     *
     * @param command arguments = (String folder, String uid, boolean read)
     * @param account
     */
    private void processPendingSetFlag(PendingCommand command, Account account)
    throws MessagingException
    {
        String folder = command.arguments[0];

        if (account.getErrorFolderName().equals(folder))
        {
            return;
        }

        boolean newState = Boolean.parseBoolean(command.arguments[1]);

        Flag flag = Flag.valueOf(command.arguments[2]);

        Store remoteStore = account.getRemoteStore();
        Folder remoteFolder = remoteStore.getFolder(folder);
        try
        {
            if (!remoteFolder.exists())
            {
                return;
            }
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE)
            {
                return;
            }
            List<Message> messages = new ArrayList<Message>();
            for (int i = 3; i < command.arguments.length; i++)
            {
                String uid = command.arguments[i];
                if (!uid.startsWith(K9.LOCAL_UID_PREFIX))
                {
                    messages.add(remoteFolder.getMessage(uid));
                }
            }

            if (messages.size() == 0)
            {
                return;
            }
            remoteFolder.setFlags(messages.toArray(new Message[0]), new Flag[] { flag }, newState);
        }
        finally
        {
            if (remoteFolder != null)
            {
                remoteFolder.close();
            }
        }
    }

    // TODO: This method is obsolete and is only for transition from K-9 2.0 to K-9 2.1
    // Eventually, it should be removed
    private void processPendingSetFlagOld(PendingCommand command, Account account)
    throws MessagingException
    {
        String folder = command.arguments[0];
        String uid = command.arguments[1];

        if (account.getErrorFolderName().equals(folder))
        {
            return;
        }
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""processPendingSetFlagOld: folder = "" + folder + "", uid = "" + uid);

        boolean newState = Boolean.parseBoolean(command.arguments[2]);

        Flag flag = Flag.valueOf(command.arguments[3]);
        Folder remoteFolder = null;
        try
        {
            Store remoteStore = account.getRemoteStore();
            remoteFolder = remoteStore.getFolder(folder);
            if (!remoteFolder.exists())
            {
                return;
            }
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE)
            {
                return;
            }
            Message remoteMessage = null;
            if (!uid.startsWith(K9.LOCAL_UID_PREFIX))
            {
                remoteMessage = remoteFolder.getMessage(uid);
            }
            if (remoteMessage == null)
            {
                return;
            }
            remoteMessage.setFlag(flag, newState);
        }
        finally
        {
            if (remoteFolder != null)
            {
                remoteFolder.close();
            }
        }
    }
    private void queueExpunge(final Account account, final String folderName)
    {
        putBackground(""queueExpunge "" + account.getDescription() + "":"" + folderName, null, new Runnable()
        {
            public void run()
            {
                PendingCommand command = new PendingCommand();
                command.command = PENDING_COMMAND_EXPUNGE;

                command.arguments = new String[1];

                command.arguments[0] = folderName;
                queuePendingCommand(account, command);
                processPendingCommands(account);
            }
        });
    }
    private void processPendingExpunge(PendingCommand command, Account account)
    throws MessagingException
    {
        String folder = command.arguments[0];

        if (account.getErrorFolderName().equals(folder))
        {
            return;
        }
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""processPendingExpunge: folder = "" + folder);

        Store remoteStore = account.getRemoteStore();
        Folder remoteFolder = remoteStore.getFolder(folder);
        try
        {
            if (!remoteFolder.exists())
            {
                return;
            }
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE)
            {
                return;
            }
            remoteFolder.expunge();
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""processPendingExpunge: complete for folder = "" + folder);
        }
        finally
        {
            if (remoteFolder != null)
            {
                remoteFolder.close();
            }
        }
    }


    // TODO: This method is obsolete and is only for transition from K-9 2.0 to K-9 2.1
    // Eventually, it should be removed
    private void processPendingMoveOrCopyOld(PendingCommand command, Account account)
    throws MessagingException
    {
        String srcFolder = command.arguments[0];
        String uid = command.arguments[1];
        String destFolder = command.arguments[2];
        String isCopyS = command.arguments[3];

        boolean isCopy = false;
        if (isCopyS != null)
        {
            isCopy = Boolean.parseBoolean(isCopyS);
        }

        if (account.getErrorFolderName().equals(srcFolder))
        {
            return;
        }

        Store remoteStore = account.getRemoteStore();
        Folder remoteSrcFolder = remoteStore.getFolder(srcFolder);
        Folder remoteDestFolder = remoteStore.getFolder(destFolder);

        if (!remoteSrcFolder.exists())
        {
            throw new MessagingException(""processPendingMoveOrCopyOld: remoteFolder "" + srcFolder + "" does not exist"", true);
        }
        remoteSrcFolder.open(OpenMode.READ_WRITE);
        if (remoteSrcFolder.getMode() != OpenMode.READ_WRITE)
        {
            throw new MessagingException(""processPendingMoveOrCopyOld: could not open remoteSrcFolder "" + srcFolder + "" read/write"", true);
        }

        Message remoteMessage = null;
        if (!uid.startsWith(K9.LOCAL_UID_PREFIX))
        {
            remoteMessage = remoteSrcFolder.getMessage(uid);
        }
        if (remoteMessage == null)
        {
            throw new MessagingException(""processPendingMoveOrCopyOld: remoteMessage "" + uid + "" does not exist"", true);
        }

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""processPendingMoveOrCopyOld: source folder = "" + srcFolder
                  + "", uid = "" + uid + "", destination folder = "" + destFolder + "", isCopy = "" + isCopy);

        if (isCopy == false && destFolder.equals(account.getTrashFolderName()))
        {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""processPendingMoveOrCopyOld doing special case for deleting message"");

            remoteMessage.delete(account.getTrashFolderName());
            remoteSrcFolder.close();
            return;
        }

        remoteDestFolder.open(OpenMode.READ_WRITE);
        if (remoteDestFolder.getMode() != OpenMode.READ_WRITE)
        {
            throw new MessagingException(""processPendingMoveOrCopyOld: could not open remoteDestFolder "" + srcFolder + "" read/write"", true);
        }

        if (isCopy)
        {
            remoteSrcFolder.copyMessages(new Message[] { remoteMessage }, remoteDestFolder);
        }
        else
        {
            remoteSrcFolder.moveMessages(new Message[] { remoteMessage }, remoteDestFolder);
        }
        remoteSrcFolder.close();
        remoteDestFolder.close();
    }

    private void processPendingMarkAllAsRead(PendingCommand command, Account account) throws MessagingException
    {
        String folder = command.arguments[0];
        Folder remoteFolder = null;
        LocalFolder localFolder = null;
        try
        {
            Store localStore = account.getLocalStore();
            localFolder = (LocalFolder) localStore.getFolder(folder);
            localFolder.open(OpenMode.READ_WRITE);
            Message[] messages = localFolder.getMessages(null, false);
            for (Message message : messages)
            {
                if (message.isSet(Flag.SEEN) == false)
                {
                    message.setFlag(Flag.SEEN, true);
                    for (MessagingListener l : getListeners())
                    {
                        l.listLocalMessagesUpdateMessage(account, folder, message);
                    }
                }
            }
            localFolder.setUnreadMessageCount(0);
            for (MessagingListener l : getListeners())
            {
                l.folderStatusChanged(account, folder, 0);
            }


            if (account.getErrorFolderName().equals(folder))
            {
                return;
            }

            Store remoteStore = account.getRemoteStore();
            remoteFolder = remoteStore.getFolder(folder);

            if (!remoteFolder.exists())
            {
                return;
            }
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE)
            {
                return;
            }

            remoteFolder.setFlags(new Flag[] {Flag.SEEN}, true);
            remoteFolder.close();
        }
        catch (UnsupportedOperationException uoe)
        {
            Log.w(K9.LOG_TAG, ""Could not mark all server-side as read because store doesn't support operation"", uoe);
        }
        finally
        {
            if (localFolder != null)
            {
                localFolder.close();
            }
            if (remoteFolder != null)
            {
                remoteFolder.close();
            }
        }
    }

    static long uidfill = 0;
    static AtomicBoolean loopCatch = new AtomicBoolean();
    public void addErrorMessage(Account account, Throwable t)
    {
        if (K9.ENABLE_ERROR_FOLDER == false)
        {
            return;
        }
        if (loopCatch.compareAndSet(false, true) == false)
        {
            return;
        }
        try
        {
            if (t == null)
            {
                return;
            }

            String rootCauseMessage = getRootCauseMessage(t);
            Log.e(K9.LOG_TAG, ""Error "" + ""'"" + rootCauseMessage + ""'"", t);

            Store localStore = account.getLocalStore();
            LocalFolder localFolder = (LocalFolder)localStore.getFolder(account.getErrorFolderName());
            Message[] messages = new Message[1];
            MimeMessage message = new MimeMessage();
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            PrintStream ps = new PrintStream(baos);
            t.printStackTrace(ps);
            ps.close();
            message.setBody(new TextBody(baos.toString()));
            message.setFlag(Flag.X_DOWNLOADED_FULL, true);
            message.setSubject(rootCauseMessage);

            long nowTime = System.currentTimeMillis();
            Date nowDate = new Date(nowTime);
            message.setInternalDate(nowDate);
            message.addSentDate(nowDate);
            message.setFrom(new Address(account.getEmail(), ""K9mail internal""));
            messages[0] = message;

            localFolder.appendMessages(messages);

            localFolder.deleteMessagesOlderThan(nowTime - (15 * 60 * 1000));

            for (MessagingListener l : getListeners())
            {
                l.folderStatusChanged(account, localFolder.getName(), localFolder.getUnreadMessageCount());
            }

        }
        catch (Throwable it)
        {
            Log.e(K9.LOG_TAG, ""Could not save error message to "" + account.getErrorFolderName(), it);
        }
        finally
        {
            loopCatch.set(false);
        }
    }

    public void addErrorMessage(Account account, String subject, String body)
    {
        if (K9.ENABLE_ERROR_FOLDER == false)
        {
            return;
        }
        if (loopCatch.compareAndSet(false, true) == false)
        {
            return;
        }
        try
        {
            if (body == null || body.length() < 1)
            {
                return;
            }

            Store localStore = account.getLocalStore();
            LocalFolder localFolder = (LocalFolder)localStore.getFolder(account.getErrorFolderName());
            Message[] messages = new Message[1];
            MimeMessage message = new MimeMessage();


            message.setBody(new TextBody(body));
            message.setFlag(Flag.X_DOWNLOADED_FULL, true);
            message.setSubject(subject);

            long nowTime = System.currentTimeMillis();
            Date nowDate = new Date(nowTime);
            message.setInternalDate(nowDate);
            message.addSentDate(nowDate);
            message.setFrom(new Address(account.getEmail(), ""K9mail internal""));
            messages[0] = message;

            localFolder.appendMessages(messages);

            localFolder.deleteMessagesOlderThan(nowTime - (15 * 60 * 1000));

        }
        catch (Throwable it)
        {
            Log.e(K9.LOG_TAG, ""Could not save error message to "" + account.getErrorFolderName(), it);
        }
        finally
        {
            loopCatch.set(false);
        }
    }



    public void markAllMessagesRead(final Account account, final String folder)
    {

        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Marking all messages in "" + account.getDescription() + "":"" + folder + "" as read"");
        List<String> args = new ArrayList<String>();
        args.add(folder);
        PendingCommand command = new PendingCommand();
        command.command = PENDING_COMMAND_MARK_ALL_AS_READ;
        command.arguments = args.toArray(new String[0]);
        queuePendingCommand(account, command);
        processPendingCommands(account);
    }

    public void setFlag(
        final Message[] messages,
        final Flag flag,
        final boolean newState)
    {
        actOnMessages(messages, new MessageActor()
        {
            @Override
            public void act(final Account account, final Folder folder,
                    final List<Message> messages)
            {
                String[] uids = new String[messages.size()];
                for (int i = 0; i < messages.size(); i++)
                {
                    uids[i] = messages.get(i).getUid();
                }
                setFlag(account, folder.getName(), uids, flag, newState);
            }
            
        });
        
    }

    public void setFlag(
        final Account account,
        final String folderName,
        final String[] uids,
        final Flag flag,
        final boolean newState)
    {
        // TODO: put this into the background, but right now that causes odd behavior
        // because the FolderMessageList doesn't have its own cache of the flag states
        Folder localFolder = null;
        try
        {
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folderName);
            localFolder.open(OpenMode.READ_WRITE);
            ArrayList<Message> messages = new ArrayList<Message>();
            for (int i = 0; i < uids.length; i++)
            {
                String uid = uids[i];
                // Allows for re-allowing sending of messages that could not be sent
                if (flag == Flag.FLAGGED && newState == false
                        && uid != null
                        && account.getOutboxFolderName().equals(folderName))
                {
                    sendCount.remove(uid);
                }
                Message msg = localFolder.getMessage(uid);
                if (msg != null)
                {
                	messages.add(msg);
                }
            }

            localFolder.setFlags(messages.toArray(new Message[0]), new Flag[] {flag}, newState);


            for (MessagingListener l : getListeners())
            {
                l.folderStatusChanged(account, folderName, localFolder.getUnreadMessageCount());
            }

            if (account.getErrorFolderName().equals(folderName))
            {
                return;
            }

            queueSetFlag(account, folderName, Boolean.toString(newState), flag.toString(), uids);
            processPendingCommands(account);
        }
        catch (MessagingException me)
        {
            addErrorMessage(account, me);

            throw new RuntimeException(me);
        }
        finally
        {
            if (localFolder != null)
            {
                localFolder.close();
            }
        }
    }//setMesssageFlag

    public void clearAllPending(final Account account)
    {
        try
        {
            Log.w(K9.LOG_TAG, ""Clearing pending commands!"");
            LocalStore localStore = account.getLocalStore();
            localStore.removePendingCommands();
        }
        catch (MessagingException me)
        {
            Log.e(K9.LOG_TAG, ""Unable to clear pending command"", me);
            addErrorMessage(account, me);
        }
    }

    private void loadMessageForViewRemote(final Account account, final String folder,
                                          final String uid, final MessagingListener listener)
    {
        put(""loadMessageForViewRemote"", listener, new Runnable()
        {
            public void run()
            {
                Folder remoteFolder = null;
                LocalFolder localFolder = null;
                try
                {
                    LocalStore localStore = account.getLocalStore();
                    localFolder = localStore.getFolder(folder);
                    localFolder.open(OpenMode.READ_WRITE);

                    Message message = localFolder.getMessage(uid);

                    if (message.isSet(Flag.X_DOWNLOADED_FULL))
                    {
                        /*
                         * If the message has been synchronized since we were called we'll
                         * just hand it back cause it's ready to go.
                         */
                        FetchProfile fp = new FetchProfile();
                        fp.add(FetchProfile.Item.ENVELOPE);
                        fp.add(FetchProfile.Item.BODY);
                        localFolder.fetch(new Message[] { message }, fp, null);
                    }
                    else
                    {
                        /*
                         * At this point the message is not available, so we need to download it
                         * fully if possible.
                         */

                        Store remoteStore = account.getRemoteStore();
                        remoteFolder = remoteStore.getFolder(folder);
                        remoteFolder.open(OpenMode.READ_WRITE);

                        // Get the remote message and fully download it
                        Message remoteMessage = remoteFolder.getMessage(uid);
                        FetchProfile fp = new FetchProfile();
                        fp.add(FetchProfile.Item.BODY);
                        remoteFolder.fetch(new Message[] { remoteMessage }, fp, null);

                        // Store the message locally and load the stored message into memory
                        localFolder.appendMessages(new Message[] { remoteMessage });
                        message = localFolder.getMessage(uid);
                        localFolder.fetch(new Message[] { message }, fp, null);

                        // Mark that this message is now fully synched
                        message.setFlag(Flag.X_DOWNLOADED_FULL, true);
                    }

                    // This is a view message request, so mark it read
                    if (!message.isSet(Flag.SEEN))
                    {
                        setFlag(new Message[] { message }, Flag.SEEN, true);
                    }

                    if (listener != null && !getListeners().contains(listener))
                    {
                        listener.loadMessageForViewBodyAvailable(account, folder, uid, message);
                    }
                    for (MessagingListener l : getListeners())
                    {
                        l.loadMessageForViewBodyAvailable(account, folder, uid, message);
                    }
                    if (listener != null && !getListeners().contains(listener))
                    {
                        listener.loadMessageForViewFinished(account, folder, uid, message);
                    }
                    for (MessagingListener l : getListeners())
                    {
                        l.loadMessageForViewFinished(account, folder, uid, message);
                    }
                }
                catch (Exception e)
                {
                    for (MessagingListener l : getListeners())
                    {
                        l.loadMessageForViewFailed(account, folder, uid, e);
                    }
                    if (listener != null && !getListeners().contains(listener))
                    {
                        listener.loadMessageForViewFailed(account, folder, uid, e);
                    }
                    addErrorMessage(account, e);

                }
                finally
                {
                    if (remoteFolder!=null)
                    {
                        remoteFolder.close();
                    }

                    if (localFolder!=null)
                    {
                        localFolder.close();
                    }
                }//finally
            }//run
        });
    }

    public void loadMessageForView(final Account account, final String folder, final String uid,
                                   final MessagingListener listener)
    {
        for (MessagingListener l : getListeners())
        {
            l.loadMessageForViewStarted(account, folder, uid);
        }
        if (listener != null && !getListeners().contains(listener))
        {
            listener.loadMessageForViewStarted(account, folder, uid);
        }
        threadPool.execute(new Runnable()
        {
            public void run()
            {

                try
                {
                    LocalStore localStore = account.getLocalStore();
                    LocalFolder localFolder = localStore.getFolder(folder);
                    localFolder.open(OpenMode.READ_WRITE);

                    LocalMessage message = (LocalMessage)localFolder.getMessage(uid);
                    if (message==null
                            || message.getId()==0)
                    {
                        throw new IllegalArgumentException(""Message not found: folder="" + folder + "", uid="" + uid);
                    }

                    for (MessagingListener l : getListeners())
                    {
                        l.loadMessageForViewHeadersAvailable(account, folder, uid, message);
                    }
                    if (listener != null && !getListeners().contains(listener))
                    {
                        listener.loadMessageForViewHeadersAvailable(account, folder, uid, message);
                    }

                    if (!message.isSet(Flag.X_DOWNLOADED_FULL))
                    {
                        loadMessageForViewRemote(account, folder, uid, listener);
                        if (!message.isSet(Flag.X_DOWNLOADED_PARTIAL))
                        {
                            localFolder.close();
                            return;
                        }
                    }

                    FetchProfile fp = new FetchProfile();
                    fp.add(FetchProfile.Item.ENVELOPE);
                    fp.add(FetchProfile.Item.BODY);
                    localFolder.fetch(new Message[]
                                      {
                                          message
                                      }, fp, null);
                    localFolder.close();
                    if (!message.isSet(Flag.SEEN))
                    {
                        setFlag(new Message[] { message }, Flag.SEEN, true);
                    }

                    for (MessagingListener l : getListeners())
                    {
                        l.loadMessageForViewBodyAvailable(account, folder, uid, message);
                    }
                    if (listener != null && !getListeners().contains(listener))
                    {
                        listener.loadMessageForViewBodyAvailable(account, folder, uid, message);
                    }

                    for (MessagingListener l : getListeners())
                    {
                        l.loadMessageForViewFinished(account, folder, uid, message);
                    }
                    if (listener != null && !getListeners().contains(listener))
                    {
                        listener.loadMessageForViewFinished(account, folder, uid, message);
                    }

                }
                catch (Exception e)
                {
                    for (MessagingListener l : getListeners())
                    {
                        l.loadMessageForViewFailed(account, folder, uid, e);
                    }
                    if (listener != null && !getListeners().contains(listener))
                    {
                        listener.loadMessageForViewFailed(account, folder, uid, e);
                    }
                    addErrorMessage(account, e);

                }
            }
        });
    }

    /**
     * Attempts to load the attachment specified by part from the given account and message.
     * @param account
     * @param message
     * @param part
     * @param listener
     */
    public void loadAttachment(
        final Account account,
        final Message message,
        final Part part,
        final Object tag,
        final MessagingListener listener)
    {
        /*
         * Check if the attachment has already been downloaded. If it has there's no reason to
         * download it, so we just tell the listener that it's ready to go.
         */
        try
        {
            if (part.getBody() != null)
            {
                for (MessagingListener l : getListeners())
                {
                    l.loadAttachmentStarted(account, message, part, tag, false);
                }
                if (listener != null)
                {
                    listener.loadAttachmentStarted(account, message, part, tag, false);
                }

                for (MessagingListener l : getListeners())
                {
                    l.loadAttachmentFinished(account, message, part, tag);
                }

                if (listener != null)
                {
                    listener.loadAttachmentFinished(account, message, part, tag);
                }
                return;
            }
        }
        catch (MessagingException me)
        {
            /*
             * If the header isn't there the attachment isn't downloaded yet, so just continue
             * on.
             */
        }

        for (MessagingListener l : getListeners())
        {
            l.loadAttachmentStarted(account, message, part, tag, true);
        }
        if (listener != null)
        {
            listener.loadAttachmentStarted(account, message, part, tag, false);
        }

        put(""loadAttachment"", listener, new Runnable()
        {
            public void run()
            {
                Folder remoteFolder = null;
                LocalFolder localFolder = null;
                try
                {
                    LocalStore localStore = account.getLocalStore();

                    /*
                     * We clear out any attachments already cached in the entire store and then
                     * we update the passed in message to reflect that there are no cached
                     * attachments. This is in support of limiting the account to having one
                     * attachment downloaded at a time.
                     */
                    localStore.pruneCachedAttachments();
                    ArrayList<Part> viewables = new ArrayList<Part>();
                    ArrayList<Part> attachments = new ArrayList<Part>();
                    MimeUtility.collectParts(message, viewables, attachments);
                    for (Part attachment : attachments)
                    {
                        attachment.setBody(null);
                    }
                    Store remoteStore = account.getRemoteStore();
                    localFolder = localStore.getFolder(message.getFolder().getName());
                    remoteFolder = remoteStore.getFolder(message.getFolder().getName());
                    remoteFolder.open(OpenMode.READ_WRITE);

                    FetchProfile fp = new FetchProfile();
                    fp.add(part);
                    remoteFolder.fetch(new Message[] { message }, fp, null);
                    localFolder.updateMessage((LocalMessage)message);
                    for (MessagingListener l : getListeners())
                    {
                        l.loadAttachmentFinished(account, message, part, tag);
                    }
                    if (listener != null)
                    {
                        listener.loadAttachmentFinished(account, message, part, tag);
                    }
                }
                catch (MessagingException me)
                {
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""Exception loading attachment"", me);

                    for (MessagingListener l : getListeners())
                    {
                        l.loadAttachmentFailed(account, message, part, tag, me.getMessage());
                    }
                    if (listener != null)
                    {
                        listener.loadAttachmentFailed(account, message, part, tag, me.getMessage());
                    }
                    addErrorMessage(account, me);

                }
                finally
                {
                    if (remoteFolder != null)
                    {
                        remoteFolder.close();
                    }
                    if (localFolder != null)
                    {
                        localFolder.close();
                    }
                }
            }
        });
    }

    /**
     * Stores the given message in the Outbox and starts a sendPendingMessages command to
     * attempt to send the message.
     * @param account
     * @param message
     * @param listener
     */
    public void sendMessage(final Account account,
                            final Message message,
                            MessagingListener listener)
    {
        try
        {
            LocalStore localStore = account.getLocalStore();
            LocalFolder localFolder = localStore.getFolder(account.getOutboxFolderName());
            localFolder.open(OpenMode.READ_WRITE);
            localFolder.appendMessages(new Message[]
                                       {
                                           message
                                       });
            Message localMessage = localFolder.getMessage(message.getUid());
            localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);
            localFolder.close();
            sendPendingMessages(account, null);
        }
        catch (Exception e)
        {
            for (MessagingListener l : getListeners())
            {
                // TODO general failed
            }
            addErrorMessage(account, e);

        }
    }

    /**
     * Attempt to send any messages that are sitting in the Outbox.
     * @param account
     * @param listener
     */
    public void sendPendingMessages(final Account account,
                                    MessagingListener listener)
    {
        putBackground(""sendPendingMessages"", listener, new Runnable()
        {
            public void run()
            {
                sendPendingMessagesSynchronous(account);
            }
        });
    }


    public boolean messagesPendingSend(final Account account)
    {
        Folder localFolder = null;
        try
        {
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(
                              account.getOutboxFolderName());
            if (!localFolder.exists())
            {
                return false;
            }

            localFolder.open(OpenMode.READ_WRITE);

            int localMessages = localFolder.getMessageCount();
            if (localMessages > 0)
            {
                return true;
            }
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Exception while checking for unsent messages"", e);
        }
        finally
        {
            if (localFolder != null)
            {
                localFolder.close();
            }
        }
        return false;
    }

    /**
     * Attempt to send any messages that are sitting in the Outbox.
     * @param account
     * @param listener
     */
    public void sendPendingMessagesSynchronous(final Account account)
    {
        Folder localFolder = null;
        try
        {
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(
                              account.getOutboxFolderName());
            if (!localFolder.exists())
            {
                return;
            }
            for (MessagingListener l : getListeners())
            {
                l.sendPendingMessagesStarted(account);
            }
            localFolder.open(OpenMode.READ_WRITE);

            Message[] localMessages = localFolder.getMessages(null);
            boolean anyFlagged = false;
            int progress = 0;
            int todo = localMessages.length;
            for (MessagingListener l : getListeners())
            {
                l.synchronizeMailboxProgress(account, account.getSentFolderName(), progress, todo);
            }
            /*
             * The profile we will use to pull all of the content
             * for a given local message into memory for sending.
             */
            FetchProfile fp = new FetchProfile();
            fp.add(FetchProfile.Item.ENVELOPE);
            fp.add(FetchProfile.Item.BODY);

            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""Scanning folder '"" + account.getOutboxFolderName() + ""' ("" + ((LocalFolder)localFolder).getId() + "") for messages to send"");

            Transport transport = Transport.getInstance(account);
            for (Message message : localMessages)
            {
                if (message.isSet(Flag.DELETED))
                {
                    message.setFlag(Flag.X_DESTROYED, true);
                    continue;
                }
                if (message.isSet(Flag.FLAGGED))
                {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Skipping sending FLAGGED message "" + message.getUid());
                    continue;
                }
                try
                {
                    AtomicInteger count = new AtomicInteger(0);
                    AtomicInteger oldCount = sendCount.putIfAbsent(message.getUid(), count);
                    if (oldCount != null)
                    {
                        count = oldCount;
                    }

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Send count for message "" + message.getUid() + "" is "" + count.get());
                    if (count.incrementAndGet() > K9.MAX_SEND_ATTEMPTS)
                    {
                        Log.e(K9.LOG_TAG, ""Send count for message "" + message.getUid() + "" has exceeded maximum attempt threshold, flagging"");
                        message.setFlag(Flag.FLAGGED, true);
                        anyFlagged = true;
                        continue;
                    }

                    localFolder.fetch(new Message[] { message }, fp, null);
                    try
                    {
                        message.setFlag(Flag.X_SEND_IN_PROGRESS, true);
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Sending message with UID "" + message.getUid());
                        transport.sendMessage(message);
                        message.setFlag(Flag.X_SEND_IN_PROGRESS, false);
                        message.setFlag(Flag.SEEN, true);
                        progress++;
                        for (MessagingListener l : getListeners())
                        {
                            l.synchronizeMailboxProgress(account, account.getSentFolderName(), progress, todo);
                        }
                        if (K9.FOLDER_NONE.equals(account.getSentFolderName()))
                        {
                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Sent folder set to "" + K9.FOLDER_NONE + "", deleting sent message"");
                            message.setFlag(Flag.DELETED, true);
                        }
                        else
                        {
                            LocalFolder localSentFolder =
                                (LocalFolder) localStore.getFolder(
                                    account.getSentFolderName());
                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Moving sent message to folder '"" + account.getSentFolderName() + ""' ("" + localSentFolder.getId() + "") "");
    
                            localFolder.moveMessages(
                                new Message[] { message },
                                localSentFolder);
    
                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Moved sent message to folder '"" + account.getSentFolderName() + ""' ("" + localSentFolder.getId() + "") "");
    
                            PendingCommand command = new PendingCommand();
                            command.command = PENDING_COMMAND_APPEND;
                            command.arguments =
                                new String[]
                            {
                                localSentFolder.getName(),
                                message.getUid()
                            };
                            queuePendingCommand(account, command);
                            processPendingCommands(account);
                        }
                        
                    }
                    catch (Exception e)
                    {
                        if (e instanceof MessagingException)
                        {
                            MessagingException me = (MessagingException)e;
                            if (me.isPermanentFailure() == false)
                            {
                                // Decrement the counter if the message could not possibly have been sent
                                int newVal = count.decrementAndGet();
                                if (K9.DEBUG)
                                    Log.i(K9.LOG_TAG, ""Decremented send count for message "" + message.getUid() + "" to "" + newVal
                                          + ""; no possible send"");
                            }
                        }
                        message.setFlag(Flag.X_SEND_FAILED, true);
                        Log.e(K9.LOG_TAG, ""Failed to send message"", e);
                        for (MessagingListener l : getListeners())
                        {
                            l.synchronizeMailboxFailed(
                                account,
                                localFolder.getName(),
                                getRootCauseMessage(e));
                        }
                        addErrorMessage(account, e);

                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Failed to fetch message for sending"", e);
                    for (MessagingListener l : getListeners())
                    {
                        l.synchronizeMailboxFailed(
                            account,
                            localFolder.getName(),
                            getRootCauseMessage(e));
                    }
                    addErrorMessage(account, e);

                    /*
                     * We ignore this exception because a future refresh will retry this
                     * message.
                     */
                }
            }
            if (localFolder.getMessageCount() == 0)
            {
                localFolder.delete(false);
            }
            for (MessagingListener l : getListeners())
            {
                l.sendPendingMessagesCompleted(account);
            }
            if (anyFlagged)
            {
                addErrorMessage(account, mApplication.getString(R.string.send_failure_subject),
                                mApplication.getString(R.string.send_failure_body_fmt, K9.ERROR_FOLDER_NAME));

                NotificationManager notifMgr =
                    (NotificationManager)mApplication.getSystemService(Context.NOTIFICATION_SERVICE);

                Notification notif = new Notification(R.drawable.stat_notify_email_generic,
                                                      mApplication.getString(R.string.send_failure_subject), System.currentTimeMillis());

                Intent i = MessageList.actionHandleFolderIntent(mApplication, account, account.getErrorFolderName());

                PendingIntent pi = PendingIntent.getActivity(mApplication, 0, i, 0);

                notif.setLatestEventInfo(mApplication, mApplication.getString(R.string.send_failure_subject),
                                         mApplication.getString(R.string.send_failure_body_abbrev, K9.ERROR_FOLDER_NAME), pi);

                notif.flags |= Notification.FLAG_SHOW_LIGHTS;
                notif.ledARGB = K9.NOTIFICATION_LED_SENDING_FAILURE_COLOR;
                notif.ledOnMS = K9.NOTIFICATION_LED_FAST_ON_TIME;
                notif.ledOffMS = K9.NOTIFICATION_LED_FAST_OFF_TIME;
                notifMgr.notify(-1000 - account.getAccountNumber(), notif);
            }
        }
        catch (Exception e)
        {
            for (MessagingListener l : getListeners())
            {
                l.sendPendingMessagesFailed(account);
            }
            addErrorMessage(account, e);

        }
        finally
        {
            if (localFolder != null)
            {
                try
                {
                    localFolder.close();
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Exception while closing folder"", e);
                }
            }
        }
    }

    public void getAccountUnreadCount(final Context context, final Account account,
                                      final MessagingListener l)
    {
        Runnable unreadRunnable = new Runnable()
        {
            public void run()
            {

                int unreadMessageCount = 0;
                try
                {
                    unreadMessageCount = account.getUnreadMessageCount(context);
                }
                catch (MessagingException me)
                {
                    Log.e(K9.LOG_TAG, ""Count not get unread count for account "" + account.getDescription(),
                          me);
                }
                l.accountStatusChanged(account, unreadMessageCount);
            }
        };


        put(""getAccountUnreadCount:"" + account.getDescription(), l, unreadRunnable);
    }

    public void getFolderUnreadMessageCount(final Account account, final String folderName,
                                            final MessagingListener l)
    {
        Runnable unreadRunnable = new Runnable()
        {
            public void run()
            {

                int unreadMessageCount = 0;
                try
                {
                    Folder localFolder = account.getLocalStore().getFolder(folderName);
                    unreadMessageCount = localFolder.getUnreadMessageCount();
                }
                catch (MessagingException me)
                {
                    Log.e(K9.LOG_TAG, ""Count not get unread count for account "" + account.getDescription(), me);
                }
                l.folderStatusChanged(account, folderName, unreadMessageCount);
            }
        };


        put(""getFolderUnread:"" + account.getDescription() + "":"" + folderName, l, unreadRunnable);
    }


  
    public boolean isMoveCapable(Message message)
    {
        if (!message.getUid().startsWith(K9.LOCAL_UID_PREFIX))
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    public boolean isCopyCapable(Message message)
    {
        return isMoveCapable(message);
    }

    public boolean isMoveCapable(final Account account)
    {
        try
        {
            Store localStore = account.getLocalStore();
            Store remoteStore = account.getRemoteStore();
            return localStore.isMoveCapable() && remoteStore.isMoveCapable();
        }
        catch (MessagingException me)
        {

            Log.e(K9.LOG_TAG, ""Exception while ascertaining move capability"", me);
            return false;
        }
    }
    public boolean isCopyCapable(final Account account)
    {
        try
        {
            Store localStore = account.getLocalStore();
            Store remoteStore = account.getRemoteStore();
            return localStore.isCopyCapable() && remoteStore.isCopyCapable();
        }
        catch (MessagingException me)
        {
            Log.e(K9.LOG_TAG, ""Exception while ascertaining copy capability"", me);
            return false;
        }
    }
    public void moveMessages(final Account account, final String srcFolder, final Message[] messages, final String destFolder,
            final MessagingListener listener)
    {
        for (Message message : messages)
        {
            suppressMessage(account, srcFolder, message);
        }
        putBackground(""moveMessages"", null, new Runnable()
        {
            public void run()
            {
                moveOrCopyMessageSynchronous(account, srcFolder, messages, destFolder, false, listener);
            }
        });
    }

    public void moveMessage(final Account account, final String srcFolder, final Message message, final String destFolder,
            final MessagingListener listener)
    {
        moveMessages(account, srcFolder, new Message[] { message }, destFolder, listener);
    }

    public void copyMessages(final Account account, final String srcFolder, final Message[] messages, final String destFolder,
                            final MessagingListener listener)
    {
        putBackground(""copyMessages"", null, new Runnable()
        {
            public void run()
            {
                moveOrCopyMessageSynchronous(account, srcFolder, messages, destFolder, true, listener);
            }
        });
    }
    public void copyMessage(final Account account, final String srcFolder, final Message message, final String destFolder,
                               final MessagingListener listener)
    {
        copyMessages(account, srcFolder, new Message[] { message }, destFolder, listener);
    }

    private void moveOrCopyMessageSynchronous(final Account account, final String srcFolder, final Message[] inMessages,
            final String destFolder, final boolean isCopy, MessagingListener listener)
    {
        try
        {
            Store localStore = account.getLocalStore();
            Store remoteStore = account.getRemoteStore();
            if (isCopy == false && (remoteStore.isMoveCapable() == false || localStore.isMoveCapable() == false))
            {
                return;
            }
            if (isCopy == true && (remoteStore.isCopyCapable() == false || localStore.isCopyCapable() == false))
            {
                return;
            }

            Folder localSrcFolder = localStore.getFolder(srcFolder);
            Folder localDestFolder = localStore.getFolder(destFolder);
            
            List<String> uids = new LinkedList<String>();
            for (Message message : inMessages)
            {
                String uid = message.getUid();
                if (!uid.startsWith(K9.LOCAL_UID_PREFIX))
                {
                    uids.add(uid);
                }
            }
            
            Message[] messages = localSrcFolder.getMessages(uids.toArray(new String[0]), null);
            if (messages.length > 0)
            {
                Map<String, Message> origUidMap = new HashMap<String, Message>();
                
                for (Message message : messages)
                {
                    origUidMap.put(message.getUid(), message);
                }
           
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""moveOrCopyMessageSynchronous: source folder = "" + srcFolder
                          + "", "" + messages.length + "" messages, "" + "", destination folder = "" + destFolder + "", isCopy = "" + isCopy);

                if (isCopy)
                {
                    FetchProfile fp = new FetchProfile();
                    fp.add(FetchProfile.Item.ENVELOPE);
                    fp.add(FetchProfile.Item.BODY);
                    localSrcFolder.fetch(messages, fp, null);
                    localSrcFolder.copyMessages(messages, localDestFolder);
                }
                else
                {
                    localSrcFolder.moveMessages(messages, localDestFolder);
                    for (String origUid : origUidMap.keySet())
                    {
                        for (MessagingListener l : getListeners())
                        {
                            l.messageUidChanged(account, srcFolder, origUid, origUidMap.get(origUid).getUid());
                        }
                        unsuppressMessage(account, srcFolder, origUid);
                    }
                }
            
                queueMoveOrCopy(account, srcFolder, destFolder, isCopy, origUidMap.keySet().toArray(new String[0]));
            }

            processPendingCommands(account);
        }
        catch (MessagingException me)
        {
            addErrorMessage(account, me);

            throw new RuntimeException(""Error moving message"", me);
        }
    }

    public void expunge(final Account account, final String folder, final MessagingListener listener)
    {
        putBackground(""expunge"", null, new Runnable()
        {
            public void run()
            {
                queueExpunge(account, folder);
            }
        });
    }
    
    public void deleteDraft(final Account account, String uid) 
    {
        LocalFolder localFolder = null;
        try
        {
            LocalStore localStore = account.getLocalStore();
            localFolder = localStore.getFolder(account.getDraftsFolderName());
            localFolder.open(OpenMode.READ_WRITE);
            Message message = localFolder.getMessage(uid);
            deleteMessages(new Message[] { message }, null);
        }
        catch (MessagingException me)
        {
            addErrorMessage(account, me);
        }
        finally
        {
            if (localFolder != null)
            {
                localFolder.close();
            }
        }
    }

    public void deleteMessages(final Message[] messages, final MessagingListener listener)
    {
        actOnMessages(messages, new MessageActor()
        {

            @Override
            public void act(final Account account, final Folder folder,
                    final List<Message> messages)
            {
                for (Message message : messages)
                {
                    suppressMessage(account, folder.getName(), message);
                }

                putBackground(""deleteMessages"", null, new Runnable()
                {
                    public void run()
                    {
                        deleteMessagesSynchronous(account, folder.getName(), messages.toArray(new Message[0]), listener);
                    }
                });
            }
            
        });
        
    }

    private void deleteMessagesSynchronous(final Account account, final String folder, final Message[] messages,
                                           MessagingListener listener)
    {
        Folder localFolder = null;
        Folder localTrashFolder = null;
        String[] uids = getUidsFromMessages(messages);
        try
        {
            //We need to make these callbacks before moving the messages to the trash
            //as messages get a new UID after being moved
            for (Message message : messages)
            {
                if (listener != null)
                {
                    listener.messageDeleted(account, folder, message);
                }
                for (MessagingListener l : getListeners())
                {
                    l.messageDeleted(account, folder, message);
                }
            }
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folder);
            if (folder.equals(account.getTrashFolderName()) || K9.FOLDER_NONE.equals(account.getTrashFolderName()))
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Deleting messages in trash folder or trash set to -None-, not copying"");

                localFolder.setFlags(messages, new Flag[] { Flag.DELETED }, true);
            }
            else
            {
                localTrashFolder = localStore.getFolder(account.getTrashFolderName());
                if (localTrashFolder.exists() == false)
                {
                    localTrashFolder.create(Folder.FolderType.HOLDS_MESSAGES);
                }
                if (localTrashFolder.exists() == true)
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Deleting messages in normal folder, moving"");

                    localFolder.moveMessages(messages, localTrashFolder);

                }
            }

            for (MessagingListener l : getListeners())
            {
                l.folderStatusChanged(account, folder, localFolder.getUnreadMessageCount());
                if (localTrashFolder != null)
                {
                    l.folderStatusChanged(account, account.getTrashFolderName(), localTrashFolder.getUnreadMessageCount());
                }
            }

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Delete policy for account "" + account.getDescription() + "" is "" + account.getDeletePolicy());

            if (folder.equals(account.getOutboxFolderName()))
            {
                for (Message message : messages)
                {
                    // If the message was in the Outbox, then it has been copied to local Trash, and has
                    // to be copied to remote trash
                    PendingCommand command = new PendingCommand();
                    command.command = PENDING_COMMAND_APPEND;
                    command.arguments =
                        new String[]
                    {
                        account.getTrashFolderName(),
                        message.getUid()
                    };
                    queuePendingCommand(account, command);
                }
                processPendingCommands(account);
            }
            else if (folder.equals(account.getTrashFolderName()) && account.getDeletePolicy() == Account.DELETE_POLICY_ON_DELETE)
            {
                queueSetFlag(account, folder, Boolean.toString(true), Flag.DELETED.toString(), uids);
                processPendingCommands(account);
            }
            else if (account.getDeletePolicy() == Account.DELETE_POLICY_ON_DELETE)
            {
                queueMoveOrCopy(account, folder, account.getTrashFolderName(), false, uids);
                processPendingCommands(account);
            }
            else if (account.getDeletePolicy() == Account.DELETE_POLICY_MARK_AS_READ)
            {
                queueSetFlag(account, folder, Boolean.toString(true), Flag.SEEN.toString(), uids);
                processPendingCommands(account);
            }
            else
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Delete policy "" + account.getDeletePolicy() + "" prevents delete from server"");
            }
            for (String uid : uids)
            {
                unsuppressMessage(account, folder, uid);
            }
        }
        catch (MessagingException me)
        {
            addErrorMessage(account, me);

            throw new RuntimeException(""Error deleting message from local store."", me);
        }
        finally
        {
            
            if (localFolder != null)
            {
                localFolder.close();
            }
            if (localTrashFolder != null)
            {
                localTrashFolder.close();
            }
        }
    }

    private String[] getUidsFromMessages(Message[] messages)
    {
        String[] uids = new String[messages.length];
        for (int i = 0; i < messages.length; i++)
        {
            uids[i] = messages[i].getUid();
        }
        return uids;
    }

    private void processPendingEmptyTrash(PendingCommand command, Account account) throws MessagingException
    {
        Store remoteStore = account.getRemoteStore();

        Folder remoteFolder = remoteStore.getFolder(account.getTrashFolderName());
        try
        {
            if (remoteFolder.exists())
            {
                remoteFolder.open(OpenMode.READ_WRITE);
                remoteFolder.setFlags(new Flag [] { Flag.DELETED }, true);
                if (Account.EXPUNGE_IMMEDIATELY.equals(account.getExpungePolicy()))
                {
                    remoteFolder.expunge();
                }
            }
        }
        finally
        {
            if (remoteFolder != null)
            {
                remoteFolder.close();
            }
        }
    }

    public void emptyTrash(final Account account, MessagingListener listener)
    {
        putBackground(""emptyTrash"", listener, new Runnable()
        {
            public void run()
            {
                Folder localFolder = null;
                try
                {
                    Store localStore = account.getLocalStore();
                    localFolder = localStore.getFolder(account.getTrashFolderName());
                    localFolder.open(OpenMode.READ_WRITE);
                    localFolder.setFlags(new Flag[] { Flag.DELETED }, true);

                    for (MessagingListener l : getListeners())
                    {
                        l.emptyTrashCompleted(account);
                    }
                    List<String> args = new ArrayList<String>();
                    PendingCommand command = new PendingCommand();
                    command.command = PENDING_COMMAND_EMPTY_TRASH;
                    command.arguments = args.toArray(new String[0]);
                    queuePendingCommand(account, command);
                    processPendingCommands(account);
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""emptyTrash failed"", e);

                    addErrorMessage(account, e);
                }
                finally
                {
                    if (localFolder != null)
                    {
                        localFolder.close();
                    }
                }
            }
        });
    }

    public void sendAlternate(final Context context, Account account, Message message)
    {
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""About to load message "" + account.getDescription() + "":"" + message.getFolder().getName()
                  + "":"" + message.getUid() + "" for sendAlternate"");

        loadMessageForView(account, message.getFolder().getName(),
                           message.getUid(), new MessagingListener()
        {
            @Override
            public void loadMessageForViewBodyAvailable(Account account, String folder, String uid,
                    Message message)
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Got message "" + account.getDescription() + "":"" + folder
                          + "":"" + message.getUid() + "" for sendAlternate"");

                try
                {
                    Intent msg=new Intent(Intent.ACTION_SEND);
                    String quotedText = null;
                    Part part = MimeUtility.findFirstPartByMimeType(message,
                                ""text/plain"");
                    if (part == null)
                    {
                        part = MimeUtility.findFirstPartByMimeType(message, ""text/html"");
                    }
                    if (part != null)
                    {
                        quotedText = MimeUtility.getTextFromPart(part);
                    }
                    if (quotedText != null)
                    {
                        msg.putExtra(Intent.EXTRA_TEXT, quotedText);
                    }
                    msg.putExtra(Intent.EXTRA_SUBJECT, ""Fwd: "" + message.getSubject());
                    msg.setType(""text/plain"");
                    context.startActivity(Intent.createChooser(msg, context.getString(R.string.send_alternate_chooser_title)));
                }
                catch (MessagingException me)
                {
                    Log.e(K9.LOG_TAG, ""Unable to send email through alternate program"", me);
                }
            }
        });

    }

    /**
     * Checks mail for one or multiple accounts. If account is null all accounts
     * are checked.
     *
     * @param context
     * @param account
     * @param listener
     */
    public void checkMail(final Context context, final Account account,
                          final boolean ignoreLastCheckedTime,
                          final boolean useManualWakeLock,
                          final MessagingListener listener)
    {

        WakeLock twakeLock = null;
        if (useManualWakeLock)
        {
            PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
            twakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""K9"");
            twakeLock.setReferenceCounted(false);
            twakeLock.acquire(K9.MANUAL_WAKE_LOCK_TIMEOUT);
        }
        final WakeLock wakeLock = twakeLock;

        for (MessagingListener l : getListeners())
        {
            l.checkMailStarted(context, account);
        }
        putBackground(""checkMail"", listener, new Runnable()
        {
            public void run()
            {

                final NotificationManager notifMgr = (NotificationManager)context
                                                     .getSystemService(Context.NOTIFICATION_SERVICE);
                try
                {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Starting mail check"");
                    Preferences prefs = Preferences.getPreferences(context);

                    Account[] accounts;
                    if (account != null)
                    {
                        accounts = new Account[]
                        {
                            account
                        };
                    }
                    else
                    {
                        accounts = prefs.getAccounts();
                    }

                    for (final Account account : accounts)
                    {
                        final long accountInterval = account.getAutomaticCheckIntervalMinutes() * 60 * 1000;
                        if (ignoreLastCheckedTime == false && accountInterval <= 0)
                        {
                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Skipping synchronizing account "" + account.getDescription());
                            continue;
                        }

                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Synchronizing account "" + account.getDescription());
                        
                        account.setRingNotified(false);
                        
                        putBackground(""sendPending "" + account.getDescription(), null, new Runnable()
                        {
                            public void run()
                            {
                                if (messagesPendingSend(account))
                                {
                                    if (account.isShowOngoing())
                                    {
                                        Notification notif = new Notification(R.drawable.ic_menu_refresh,
                                                                              context.getString(R.string.notification_bg_send_ticker, account.getDescription()), System.currentTimeMillis());
                                        Intent intent = MessageList.actionHandleFolderIntent(context, account, K9.INBOX);
                                        PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
                                        notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_send_title),
                                                                 account.getDescription() , pi);
                                        notif.flags = Notification.FLAG_ONGOING_EVENT;

                                        if (K9.NOTIFICATION_LED_WHILE_SYNCING)
                                        {
                                            notif.flags |= Notification.FLAG_SHOW_LIGHTS;
                                            notif.ledARGB = K9.NOTIFICATION_LED_DIM_COLOR;
                                            notif.ledOnMS = K9.NOTIFICATION_LED_FAST_ON_TIME;
                                            notif.ledOffMS = K9.NOTIFICATION_LED_FAST_OFF_TIME;
                                        }

                                        notifMgr.notify(K9.FETCHING_EMAIL_NOTIFICATION_ID, notif);
                                    }
                                    try
                                    {
                                        sendPendingMessagesSynchronous(account);
                                    }
                                    finally
                                    {
                                        if (account.isShowOngoing())
                                        {
                                            notifMgr.cancel(K9.FETCHING_EMAIL_NOTIFICATION_ID);
                                        }
                                    }
                                }
                            }
                        }
                                     );
                        try
                        {
                            Account.FolderMode aDisplayMode = account.getFolderDisplayMode();
                            Account.FolderMode aSyncMode = account.getFolderSyncMode();

                            Store localStore = account.getLocalStore();
                            for (final Folder folder : localStore.getPersonalNamespaces())
                            {

                                folder.open(Folder.OpenMode.READ_WRITE);
                                folder.refresh(prefs);

                                Folder.FolderClass fDisplayClass = folder.getDisplayClass();
                                Folder.FolderClass fSyncClass = folder.getSyncClass();

                                if (modeMismatch(aDisplayMode, fDisplayClass))
                                {
                                    // Never sync a folder that isn't displayed
                                    if (K9.DEBUG)
                                        Log.v(K9.LOG_TAG, ""Not syncing folder "" + folder.getName() +
                                              "" which is in display mode "" + fDisplayClass + "" while account is in display mode "" + aDisplayMode);

                                    continue;
                                }

                                if (modeMismatch(aSyncMode, fSyncClass))
                                {
                                    // Do not sync folders in the wrong class
                                    if (K9.DEBUG)
                                        Log.v(K9.LOG_TAG, ""Not syncing folder "" + folder.getName() +
                                              "" which is in sync mode "" + fSyncClass + "" while account is in sync mode "" + aSyncMode);

                                    continue;
                                }

                                if (K9.DEBUG)
                                    Log.v(K9.LOG_TAG, ""Folder "" + folder.getName() + "" was last synced @ "" +
                                          new Date(folder.getLastChecked()));

                                if (ignoreLastCheckedTime == false && folder.getLastChecked() >
                                        (System.currentTimeMillis() - accountInterval))
                                {
                                    if (K9.DEBUG)
                                        Log.v(K9.LOG_TAG, ""Not syncing folder "" + folder.getName()
                                              + "", previously synced @ "" + new Date(folder.getLastChecked())
                                              + "" which would be too recent for the account period"");

                                    continue;
                                }
                                putBackground(""sync"" + folder.getName(), null, new Runnable()
                                {
                                    public void run()
                                    {
                                        LocalFolder tLocalFolder = null;
                                        try
                                        {
                                            // In case multiple Commands get enqueued, don't run more than
                                            // once
                                            final LocalStore localStore = account.getLocalStore();
                                            tLocalFolder = localStore.getFolder(folder.getName());
                                            tLocalFolder.open(Folder.OpenMode.READ_WRITE);

                                            if (ignoreLastCheckedTime == false && tLocalFolder.getLastChecked() >
                                                    (System.currentTimeMillis() - accountInterval))
                                            {
                                                if (K9.DEBUG)
                                                    Log.v(K9.LOG_TAG, ""Not running Command for folder "" + folder.getName()
                                                          + "", previously synced @ "" + new Date(folder.getLastChecked())
                                                          + "" which would be too recent for the account period"");
                                                return;
                                            }
                                            if (account.isShowOngoing())
                                            {
                                                Notification notif = new Notification(R.drawable.ic_menu_refresh,
                                                                                      context.getString(R.string.notification_bg_sync_ticker, account.getDescription(), folder.getName()),
                                                                                      System.currentTimeMillis());
                                                Intent intent = MessageList.actionHandleFolderIntent(context, account, K9.INBOX);
                                                PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
                                                notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_sync_title), account.getDescription()
                                                                         + context.getString(R.string.notification_bg_title_separator) + folder.getName(), pi);
                                                notif.flags = Notification.FLAG_ONGOING_EVENT;
                                                if (K9.NOTIFICATION_LED_WHILE_SYNCING)
                                                {
                                                    notif.flags |= Notification.FLAG_SHOW_LIGHTS;
                                                    notif.ledARGB = K9.NOTIFICATION_LED_DIM_COLOR;
                                                    notif.ledOnMS = K9.NOTIFICATION_LED_FAST_ON_TIME;
                                                    notif.ledOffMS = K9.NOTIFICATION_LED_FAST_OFF_TIME;
                                                }

                                                notifMgr.notify(K9.FETCHING_EMAIL_NOTIFICATION_ID, notif);
                                            }
                                            try
                                            {
                                                synchronizeMailboxSynchronous(account, folder.getName(), listener);
                                            }
                                            finally
                                            {
                                                if (account.isShowOngoing())
                                                {
                                                    notifMgr.cancel(K9.FETCHING_EMAIL_NOTIFICATION_ID);
                                                }
                                            }
                                        }
                                        catch (Exception e)
                                        {

                                            Log.e(K9.LOG_TAG, ""Exception while processing folder "" +
                                                  account.getDescription() + "":"" + folder.getName(), e);
                                            addErrorMessage(account, e);
                                        }
                                        finally
                                        {
                                            if (tLocalFolder != null)
                                            {
                                                tLocalFolder.close();
                                            }
                                        }
                                    }
                                }
                                             );
                            }
                        }
                        catch (MessagingException e)
                        {
                            Log.e(K9.LOG_TAG, ""Unable to synchronize account "" + account.getName(), e);
                            addErrorMessage(account, e);
                        }
                        finally
                        {
                            putBackground(""clear notification flag for "" + account.getDescription(), null, new Runnable()
                            {
                                public void run()
                                {
                                    if (K9.DEBUG)
                                      Log.v(K9.LOG_TAG, ""Clearing notification flag for "" + account.getDescription());
                                    account.setRingNotified(false);
                                }
                            }
                                );
                        }


                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Unable to synchronize mail"", e);
                    addErrorMessage(account, e);
                }
                putBackground(""finalize sync"", null, new Runnable()
                {
                    public void run()
                    {

                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Finished mail sync"");

                        if (wakeLock != null)
                        {
                            wakeLock.release();
                        }
                        for (MessagingListener l : getListeners())
                        {
                            l.checkMailFinished(context, account);
                        }

                    }
                }
                             );
            }
        });
    }

    public void compact(final Account account, final MessagingListener ml)
    {
        putBackground(""compact:"" + account.getDescription(), ml, new Runnable()
        {
            public void run()
            {
                try
                {
                    LocalStore localStore = account.getLocalStore();
                    long oldSize = localStore.getSize();
                    localStore.compact();
                    long newSize = localStore.getSize();
                    if (ml != null)
                    {
                        ml.accountSizeChanged(account, oldSize, newSize);
                    }
                    for (MessagingListener l : getListeners())
                    {
                        l.accountSizeChanged(account, oldSize, newSize);
                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Failed to compact account "" + account.getDescription(), e);
                }
            }
        });
    }

    public void clear(final Account account, final MessagingListener ml)
    {
        putBackground(""clear:"" + account.getDescription(), ml, new Runnable()
        {
            public void run()
            {
                try
                {
                    LocalStore localStore = account.getLocalStore();
                    long oldSize = localStore.getSize();
                    localStore.clear();
                    localStore.resetVisibleLimits(account.getDisplayCount());
                    long newSize = localStore.getSize();
                    if (ml != null)
                    {
                        ml.accountSizeChanged(account, oldSize, newSize);
                    }
                    for (MessagingListener l : getListeners())
                    {
                        l.accountSizeChanged(account, oldSize, newSize);
                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Failed to compact account "" + account.getDescription(), e);
                }
            }
        });
    }

    /** Creates a notification of new email messages
      * ringtone, lights, and vibration to be played
    */
    private boolean notifyAccount(Context context, Account account, Message message)
    {
        // Do not notify if the user does not have notifications
        // enabled or if the message has been read
        if (!account.isNotifyNewMail() || message.isSet(Flag.SEEN))
        {
            return false;
        }

        // If we have a message, set the notification to ""<From>: <Subject>""
        StringBuffer messageNotice = new StringBuffer();
        try
        {
            if (message != null && message.getFrom() != null)
            {
                Address[] fromAddrs = message.getFrom();
                String from = fromAddrs.length > 0 ? fromAddrs[0].toFriendly() : null;
                String subject = message.getSubject();
                if (subject == null)
                {
                    subject = context.getString(R.string.general_no_subject);
                }

                if (from != null)
                {
                    // Show From: address by default
                    if (account.isAnIdentity(fromAddrs) == false)
                    {
                        messageNotice.append(from + "": "" + subject);
                    }
                    // show To: if the message was sent from me
                    else
                    {
                        // Do not notify of mail from self if !isNotifySelfNewMail
                        if (!account.isNotifySelfNewMail())
                        {
                            return false;
                        }

                        Address[] rcpts = message.getRecipients(Message.RecipientType.TO);
                        String to = rcpts.length > 0 ? rcpts[0].toFriendly() : null;
                        if (to != null)
                        {
                            messageNotice.append(String.format(context.getString(R.string.message_list_to_fmt), to) +"": ""+subject);
                        }
                        else
                        {
                            messageNotice.append(context.getString(R.string.general_no_sender) + "": ""+subject);

                        }

                    }
                }
            }
        }
        catch (MessagingException e)
        {
            Log.e(K9.LOG_TAG, ""Unable to get message information for notification."", e);
        }
        // If we could not set a per-message notification, revert to a default message
        if (messageNotice.length() == 0)
        {
            messageNotice.append(context.getString(R.string.notification_new_title));
        }

        int unreadMessageCount = 0;
        try
        {
            unreadMessageCount = account.getUnreadMessageCount(context);
        }
        catch (MessagingException e)
        {
            Log.e(K9.LOG_TAG, ""Unable to getUnreadMessageCount for account: "" + account, e);
        }

        NotificationManager notifMgr =
            (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
        Notification notif = new Notification(R.drawable.stat_notify_email_generic, messageNotice, System.currentTimeMillis());
        notif.number = unreadMessageCount;

        Intent i = FolderList.actionHandleAccountIntent(context, account, account.getAutoExpandFolderName());
        PendingIntent pi = PendingIntent.getActivity(context, 0, i, 0);

        // 279 Unread (someone@gmail.com)
        String accountNotice = context.getString(R.string.notification_new_one_account_fmt, unreadMessageCount, account.getDescription());
        notif.setLatestEventInfo(context, accountNotice, messageNotice, pi);

        // Only ring or vibrate if we have not done so already on this
        // account and fetch
        if (!account.isRingNotified())
        {
            account.setRingNotified(true);
            if (account.isRing())
            {
                String ringtone = account.getRingtone();
                notif.sound = TextUtils.isEmpty(ringtone) ? null : Uri.parse(ringtone);
            }
            if (account.isVibrate())
            {
                notif.defaults |= Notification.DEFAULT_VIBRATE;
            }
        }

        notif.flags |= Notification.FLAG_SHOW_LIGHTS;
        notif.ledARGB = K9.NOTIFICATION_LED_COLOR;
        notif.ledOnMS = K9.NOTIFICATION_LED_ON_TIME;
        notif.ledOffMS = K9.NOTIFICATION_LED_OFF_TIME;

        notifMgr.notify(account.getAccountNumber(), notif);
        return true;
    }

    /** Cancel a notification of new email messages */
    public void notifyAccountCancel(Context context, Account account)
    {
        NotificationManager notifMgr =
            (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
        notifMgr.cancel(account.getAccountNumber());
    }


    public Message saveDraft(final Account account, final Message message)
    {
        Message localMessage = null;
        try
        {
            LocalStore localStore = account.getLocalStore();
            LocalFolder localFolder = localStore.getFolder(account.getDraftsFolderName());
            localFolder.open(OpenMode.READ_WRITE);
            localFolder.appendMessages(new Message[]
                                       {
                                           message
                                       });
            localMessage = localFolder.getMessage(message.getUid());
            localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);

            PendingCommand command = new PendingCommand();
            command.command = PENDING_COMMAND_APPEND;
            command.arguments = new String[]
            {
                localFolder.getName(),
                localMessage.getUid()
            };
            queuePendingCommand(account, command);
            processPendingCommands(account);
            
        }
        catch (MessagingException e)
        {
            Log.e(K9.LOG_TAG, ""Unable to save message as draft."", e);
            addErrorMessage(account, e);
        }
        return localMessage;
    }

    public boolean modeMismatch(Account.FolderMode aMode, Folder.FolderClass fMode)
    {
        if (aMode == Account.FolderMode.NONE
                || (aMode == Account.FolderMode.FIRST_CLASS &&
                    fMode != Folder.FolderClass.FIRST_CLASS)
                || (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
                    fMode != Folder.FolderClass.FIRST_CLASS &&
                    fMode != Folder.FolderClass.SECOND_CLASS)
                || (aMode == Account.FolderMode.NOT_SECOND_CLASS &&
                    fMode == Folder.FolderClass.SECOND_CLASS))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    static AtomicInteger sequencing = new AtomicInteger(0);
    class Command implements Comparable
    {
        public Runnable runnable;

        public MessagingListener listener;

        public String description;

        boolean isForeground;

        int sequence = sequencing.getAndIncrement();

        public int compareTo(Object arg0)
        {
            if (arg0 instanceof Command)
            {
                Command other = (Command)arg0;
                if (other.isForeground == true && isForeground == false)
                {
                    return 1;
                }
                else if (other.isForeground == false && isForeground == true)
                {
                    return -1;
                }
                else
                {
                    return (sequence - other.sequence);
                }
            }
            return 0;
        }
    }

    public MessagingListener getCheckMailListener()
    {
        return checkMailListener;
    }

    public void setCheckMailListener(MessagingListener checkMailListener)
    {
        if (this.checkMailListener != null)
        {
            removeListener(this.checkMailListener);
        }
        this.checkMailListener = checkMailListener;
        if (this.checkMailListener != null)
        {
            addListener(this.checkMailListener);
        }
    }

    public SORT_TYPE getSortType()
    {
        return sortType;
    }

    public void setSortType(SORT_TYPE sortType)
    {
        this.sortType = sortType;
    }

    public boolean isSortAscending(SORT_TYPE sortType)
    {
        Boolean sortAsc = sortAscending.get(sortType);
        if (sortAsc == null)
        {
            return sortType.isDefaultAscending();
        }
        else return sortAsc;
    }

    public void setSortAscending(SORT_TYPE sortType, boolean nsortAscending)
    {
        sortAscending.put(sortType, nsortAscending);
    }

    public Collection<Pusher> getPushers()
    {
        return pushers.values();
    }

    public boolean setupPushing(final Account account)
    {
        try
        {
            Pusher previousPusher = pushers.remove(account);
            if (previousPusher != null)
            {
                previousPusher.stop();
            }
            Preferences prefs = Preferences.getPreferences(mApplication);

            Account.FolderMode aDisplayMode = account.getFolderDisplayMode();
            Account.FolderMode aPushMode = account.getFolderPushMode();

            List<String> names = new ArrayList<String>();

            Store localStore = account.getLocalStore();
            for (final Folder folder : localStore.getPersonalNamespaces())
            {
                if (folder.getName().equals(account.getErrorFolderName())
                        || folder.getName().equals(account.getOutboxFolderName()))
                {
                    if (K9.DEBUG && false)
                        Log.v(K9.LOG_TAG, ""Not pushing folder "" + folder.getName() +
                              "" which should never be pushed"");

                    continue;
                }
                folder.open(Folder.OpenMode.READ_WRITE);
                folder.refresh(prefs);

                Folder.FolderClass fDisplayClass = folder.getDisplayClass();
                Folder.FolderClass fPushClass = folder.getPushClass();

                if (modeMismatch(aDisplayMode, fDisplayClass))
                {
                    // Never push a folder that isn't displayed
                    if (K9.DEBUG && false)
                        Log.v(K9.LOG_TAG, ""Not pushing folder "" + folder.getName() +
                              "" which is in display class "" + fDisplayClass + "" while account is in display mode "" + aDisplayMode);

                    continue;
                }

                if (modeMismatch(aPushMode, fPushClass))
                {
                    // Do not push folders in the wrong class
                    if (K9.DEBUG && false)
                        Log.v(K9.LOG_TAG, ""Not pushing folder "" + folder.getName() +
                              "" which is in push mode "" + fPushClass + "" while account is in push mode "" + aPushMode);

                    continue;
                }
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Starting pusher for "" + account.getDescription() + "":"" + folder.getName());

                names.add(folder.getName());
            }

            if (names.size() > 0)
            {
                PushReceiver receiver = new MessagingControllerPushReceiver(mApplication, account, this);
                int maxPushFolders = account.getMaxPushFolders();

                if (names.size() > maxPushFolders)
                {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Count of folders to push for account "" + account.getDescription() + "" is "" + names.size()
                              + "", greater than limit of "" + maxPushFolders + "", truncating"");

                    names = names.subList(0, maxPushFolders);
                }

                try
                {
                    Store store = account.getRemoteStore();
                    if (store.isPushCapable() == false)
                    {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Account "" + account.getDescription() + "" is not push capable, skipping"");

                        return false;
                    }
                    Pusher pusher = store.getPusher(receiver);
                    Pusher oldPusher = null;
                    if (pusher != null)
                    {
                        oldPusher = pushers.putIfAbsent(account, pusher);
                    }
                    if (oldPusher != null)
                    {
                        pusher = oldPusher;
                    }
                    else
                    {
                        pusher.start(names);
                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Could not get remote store"", e);
                    return false;
                }

                return true;
            }
            else
            {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""No folders are configured for pushing in account "" + account.getDescription());
                return false;
            }

        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Got exception while setting up pushing"", e);
        }
        return false;
    }

    public void stopAllPushing()
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Stopping all pushers"");

        Iterator<Pusher> iter = pushers.values().iterator();
        while (iter.hasNext())
        {
            Pusher pusher = iter.next();
            iter.remove();
            pusher.stop();
        }
    }

    public void messagesArrived(final Account account, final Folder remoteFolder, final List<Message> messages, final boolean flagSyncOnly)
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Got new pushed email messages for account "" + account.getDescription()
                  + "", folder "" + remoteFolder.getName());

        final CountDownLatch latch = new CountDownLatch(1);
        putBackground(""Push messageArrived of account "" + account.getDescription()
                      + "", folder "" + remoteFolder.getName(), null, new Runnable()
        {
            public void run()
            {
                LocalFolder localFolder = null;
                try
                {
                    LocalStore localStore = account.getLocalStore();
                    localFolder= localStore.getFolder(remoteFolder.getName());
                    localFolder.open(OpenMode.READ_WRITE);

                    account.setRingNotified(false);
                    int newCount = downloadMessages(account, remoteFolder, localFolder, messages, flagSyncOnly);
                    int unreadMessageCount = setLocalUnreadCountToRemote(localFolder, remoteFolder,  messages.size());

                    localFolder.setLastPush(System.currentTimeMillis());
                    localFolder.setStatus(null);

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""messagesArrived newCount = "" + newCount + "", unread count = "" + unreadMessageCount);

                    if (unreadMessageCount == 0)
                    {
                        notifyAccountCancel(mApplication, account);
                    }

                    for (MessagingListener l : getListeners())
                    {
                        l.folderStatusChanged(account, remoteFolder.getName(), unreadMessageCount);
                    }

                }
                catch (Exception e)
                {
                    String rootMessage = getRootCauseMessage(e);
                    String errorMessage = ""Push failed: "" + rootMessage;
                    try
                    {
                        localFolder.setStatus(errorMessage);
                    }
                    catch (Exception se)
                    {
                        Log.e(K9.LOG_TAG, ""Unable to set failed status on localFolder"", se);
                    }
                    for (MessagingListener l : getListeners())
                    {
                        l.synchronizeMailboxFailed(account, remoteFolder.getName(), errorMessage);
                    }
                    addErrorMessage(account, e);
                }
                finally
                {
                    if (localFolder != null)
                    {
                        try
                        {
                            localFolder.close();
                        }
                        catch (Exception e)
                        {
                            Log.e(K9.LOG_TAG, ""Unable to close localFolder"", e);
                        }
                    }
                    latch.countDown();
                }

            }
        });
        try
        {
            latch.await();
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Interrupted while awaiting latch release"", e);
        }
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""MessagingController.messagesArrivedLatch released"");
    }
    enum MemorizingState { STARTED, FINISHED, FAILED };

    class Memory
    {
        Account account;
        String folderName;
        MemorizingState syncingState = null;
        MemorizingState sendingState = null;
        MemorizingState pushingState = null;
        MemorizingState processingState = null;
        String failureMessage = null;

        int syncingTotalMessagesInMailbox;
        int syncingNumNewMessages;

        int folderCompleted = 0;
        int folderTotal = 0;
        String processingCommandTitle = null;

        Memory(Account nAccount, String nFolderName)
        {
            account = nAccount;
            folderName = nFolderName;
        }

        String getKey()
        {
            return getMemoryKey(account, folderName);
        }


    }
    static String getMemoryKey(Account taccount, String tfolderName)
    {
        return taccount.getDescription() + "":"" + tfolderName;
    }
    class MemorizingListener extends MessagingListener
    {
        HashMap<String, Memory> memories = new HashMap<String, Memory>(31);

        Memory getMemory(Account account, String folderName)
        {
            Memory memory = memories.get(getMemoryKey(account, folderName));
            if (memory == null)
            {
                memory = new Memory(account, folderName);
                memories.put(memory.getKey(), memory);
            }
            return memory;
        }

        public synchronized void synchronizeMailboxStarted(Account account, String folder)
        {
            Memory memory = getMemory(account, folder);
            memory.syncingState = MemorizingState.STARTED;
            memory.folderCompleted = 0;
            memory.folderTotal = 0;
        }

        public synchronized void synchronizeMailboxFinished(Account account, String folder,
                int totalMessagesInMailbox, int numNewMessages)
        {
            Memory memory = getMemory(account, folder);
            memory.syncingState = MemorizingState.FINISHED;
            memory.syncingTotalMessagesInMailbox = totalMessagesInMailbox;
            memory.syncingNumNewMessages = numNewMessages;
        }

        public synchronized void synchronizeMailboxFailed(Account account, String folder,
                String message)
        {

            Memory memory = getMemory(account, folder);
            memory.syncingState = MemorizingState.FAILED;
            memory.failureMessage = message;
        }
        synchronized void refreshOther(MessagingListener other)
        {
            if (other != null)
            {

                Memory syncStarted = null;
                Memory sendStarted = null;
                Memory processingStarted = null;

                for (Memory memory : memories.values())
                {

                    if (memory.syncingState != null)
                    {
                        switch (memory.syncingState)
                        {
                            case STARTED:
                                syncStarted = memory;
                                break;
                            case FINISHED:
                                other.synchronizeMailboxFinished(memory.account, memory.folderName,
                                                                 memory.syncingTotalMessagesInMailbox, memory.syncingNumNewMessages);
                                break;
                            case FAILED:
                                other.synchronizeMailboxFailed(memory.account, memory.folderName,
                                                               memory.failureMessage);
                                break;
                        }
                    }

                    if (memory.sendingState != null)
                    {
                        switch (memory.sendingState)
                        {
                            case STARTED:
                                sendStarted = memory;
                                break;
                            case FINISHED:
                                other.sendPendingMessagesCompleted(memory.account);
                                break;
                            case FAILED:
                                other.sendPendingMessagesFailed(memory.account);
                                break;
                        }
                    }
                    if (memory.pushingState != null)
                    {
                        switch (memory.pushingState)
                        {
                            case STARTED:
                                other.setPushActive(memory.account, memory.folderName, true);
                                break;
                            case FINISHED:
                                other.setPushActive(memory.account, memory.folderName, false);
                                break;
                        }
                    }
                    if (memory.processingState != null)
                    {
                        switch (memory.processingState)
                        {
                            case STARTED:
                                processingStarted = memory;
                                break;
                            case FINISHED:
                            case FAILED:
                                other.pendingCommandsFinished(memory.account);
                                break;
                        }
                    }
                }
                Memory somethingStarted = null;
                if (syncStarted != null)
                {
                    other.synchronizeMailboxStarted(syncStarted.account, syncStarted.folderName);
                    somethingStarted = syncStarted;
                }
                if (sendStarted != null)
                {
                    other.sendPendingMessagesStarted(sendStarted.account);
                    somethingStarted = sendStarted;
                }
                if (processingStarted != null)
                {
                    other.pendingCommandsProcessing(processingStarted.account);
                    if (processingStarted.processingCommandTitle != null)
                    {
                        other.pendingCommandStarted(processingStarted.account, processingStarted.processingCommandTitle);

                    }
                    else
                    {
                        other.pendingCommandCompleted(processingStarted.account, processingStarted.processingCommandTitle);
                    }
                    somethingStarted = processingStarted;
                }
                if (somethingStarted != null && somethingStarted.folderTotal > 0)
                {
                    other.synchronizeMailboxProgress(somethingStarted.account, somethingStarted.folderName, somethingStarted.folderCompleted, somethingStarted.folderTotal);
                }

            }
        }
        @Override
        public synchronized void setPushActive(Account account, String folderName, boolean active)
        {
            Memory memory = getMemory(account, folderName);
            memory.pushingState = (active ? MemorizingState.STARTED : MemorizingState.FINISHED);
        }

        public synchronized void sendPendingMessagesStarted(Account account)
        {
            Memory memory = getMemory(account, null);
            memory.sendingState = MemorizingState.STARTED;
            memory.folderCompleted = 0;
            memory.folderTotal = 0;
        }

        public synchronized void sendPendingMessagesCompleted(Account account)
        {
            Memory memory = getMemory(account, null);
            memory.sendingState = MemorizingState.FINISHED;
        }

        public synchronized void sendPendingMessagesFailed(Account account)
        {
            Memory memory = getMemory(account, null);
            memory.sendingState = MemorizingState.FAILED;
        }


        public synchronized void synchronizeMailboxProgress(Account account, String folderName, int completed, int total)
        {
            Memory memory = getMemory(account, folderName);
            memory.folderCompleted = completed;
            memory.folderTotal = total;
        }


        public synchronized void pendingCommandsProcessing(Account account)
        {
            Memory memory = getMemory(account, null);
            memory.processingState = MemorizingState.STARTED;
            memory.folderCompleted = 0;
            memory.folderTotal = 0;
        }
        public synchronized void pendingCommandsFinished(Account account)
        {
            Memory memory = getMemory(account, null);
            memory.processingState = MemorizingState.FINISHED;
        }
        public synchronized void pendingCommandStarted(Account account, String commandTitle)
        {
            Memory memory = getMemory(account, null);
            memory.processingCommandTitle = commandTitle;
        }

        public synchronized void pendingCommandCompleted(Account account, String commandTitle)
        {
            Memory memory = getMemory(account, null);
            memory.processingCommandTitle = null;
        }

    }

    private void actOnMessages(Message[] messages, MessageActor actor)
    {
        Map<Account, Map<Folder, List<Message>>> accountMap = new HashMap<Account, Map<Folder, List<Message>>>();
        
        for (Message message : messages)
        {
            Folder folder = message.getFolder();
            Account account = folder.getAccount();
            
            Map<Folder, List<Message>> folderMap = accountMap.get(account);
            if (folderMap == null)
            {
                folderMap = new HashMap<Folder, List<Message>>();
                accountMap.put(account, folderMap);
            }
            List<Message> messageList = folderMap.get(folder);
            if (messageList == null)
            {
                messageList = new LinkedList<Message>();
                folderMap.put(folder, messageList);
            }
            
            messageList.add(message);
        }
        for (Map.Entry<Account, Map<Folder, List<Message>>> entry : accountMap.entrySet())
        {
            Account account = entry.getKey();

            //account.refresh(Preferences.getPreferences(K9.app));
            Map<Folder, List<Message>> folderMap = entry.getValue();
            for (Map.Entry<Folder, List<Message>> folderEntry : folderMap.entrySet())
            {
                Folder folder = folderEntry.getKey();
                List<Message> messageList = folderEntry.getValue();
                actor.act(account, folder, messageList);
            }
        }
    }
    
    interface MessageActor 
    {
        public void act(final Account account, final Folder folder, final List<Message> messages);
    }
}
",True,189,0,0,7,50,11,24,L1
15,com.fsck.k9.EmailAddressAdapterSdk5.java,"/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9;

import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.provider.ContactsContract.Contacts;
import android.provider.ContactsContract.CommonDataKinds.Email;
import android.provider.ContactsContract.Contacts.Data;
import android.view.View;
import android.widget.TextView;
import com.fsck.k9.mail.Address;

public class EmailAddressAdapterSdk5 extends EmailAddressAdapter
{
    public static final int NAME_INDEX = 1;
    public static final int DATA_INDEX = 2;

    private static final String SORT_ORDER = Contacts.TIMES_CONTACTED
            + "" DESC, "" + Contacts.DISPLAY_NAME;

    private static final String[] PROJECTION = {
        Data._ID, // 0
        Contacts.DISPLAY_NAME, // 1
        Email.DATA // 2
    };

    @Override
    public final String convertToString(Cursor cursor)
    {
        String name = cursor.getString(NAME_INDEX);
        String address = cursor.getString(DATA_INDEX);

        return new Address(address, name).toString();
    }

    @Override
    public final void bindView(View view, Context context, Cursor cursor)
    {
        TextView text1 = (TextView) view.findViewById(R.id.text1);
        TextView text2 = (TextView) view.findViewById(R.id.text2);
        text1.setText(cursor.getString(NAME_INDEX));
        text2.setText(cursor.getString(DATA_INDEX));
    }

    @Override
    public Cursor runQueryOnBackgroundThread(CharSequence constraint)
    {
        String filter = constraint == null ? """" : constraint.toString();
        Uri uri = Uri.withAppendedPath(Email.CONTENT_FILTER_URI, Uri.encode(filter));
        Cursor c = mContentResolver.query(uri, PROJECTION, null, null, SORT_ORDER);
        // To prevent expensive execution in the UI thread
        // Cursors get lazily executed, so if you don't call anything on the cursor before
        // returning it from the background thread you'll have a complied program for the cursor,
        // but it won't have been executed to generate the data yet. Often the execution is more
        // expensive than the compilation...
        if (c != null)
        {
            c.getCount();
        }
        return c;
    }
}
",False,190,0,0,10,56,0,2,L4
16,com.fsck.k9.MessagingListener.java,"
package com.fsck.k9;

import android.content.Context;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.Part;

import java.util.List;

/**
 * Defines the interface that MessagingController will use to callback to requesters. This class
 * is defined as non-abstract so that someone who wants to receive only a few messages can
 * do so without implementing the entire interface. It is highly recommended that users of
 * this interface use the @Override annotation in their implementations to avoid being caught by
 * changes in this class.
 */
public class MessagingListener
{

    public void accountStatusChanged(Account account, int unreadMessageCount)
    {
    }

    public void accountSizeChanged(Account account, long oldSize, long newSize)
    {
    }

    public void listFoldersStarted(Account account)
    {
    }

    public void listFolders(Account account, Folder[] folders)
    {
    }

    public void listFoldersFailed(Account account, String message)
    {
    }

    public void listFoldersFinished(Account account)
    {
    }

    public void listLocalMessagesStarted(Account account, String folder)
    {
    }

    public void listLocalMessages(Account account, String folder, Message[] messages)
    {
    }

    public void listLocalMessagesAddMessages(Account account, String folder, List<Message> messages)
    {
    }

    public void listLocalMessagesUpdateMessage(Account account, String folder, Message message)
    {
    }

    public void listLocalMessagesRemoveMessage(Account account, String folder, Message message)
    {
    }

    public void listLocalMessagesFailed(Account account, String folder, String message)
    {
    }

    public void listLocalMessagesFinished(Account account, String folder)
    {
    }

    public void synchronizeMailboxStarted(Account account, String folder)
    {
    }

    public void synchronizeMailboxProgress(Account account, String folder, int completed, int total)
    {}

    public void synchronizeMailboxNewMessage(Account account, String folder, Message message)
    {
    }

    public void synchronizeMailboxAddOrUpdateMessage(Account account, String folder, Message message)
    {
    }

    public void synchronizeMailboxRemovedMessage(Account account, String folder,Message message)
    {
    }

    public void synchronizeMailboxFinished(Account account, String folder,
                                           int totalMessagesInMailbox, int numNewMessages)
    {
    }

    public void synchronizeMailboxFailed(Account account, String folder,
                                         String message)
    {
    }

    public void loadMessageForViewStarted(Account account, String folder, String uid)
    {
    }

    public void loadMessageForViewHeadersAvailable(Account account, String folder, String uid,
            Message message)
    {
    }

    public void loadMessageForViewBodyAvailable(Account account, String folder, String uid,
            Message message)
    {
    }

    public void loadMessageForViewFinished(Account account, String folder, String uid,
                                           Message message)
    {
    }

    public void loadMessageForViewFailed(Account account, String folder, String uid, Throwable t)
    {
    }

    public void checkMailStarted(Context context, Account account)
    {
    }

    public void checkMailFinished(Context context, Account account)
    {
    }

    public void checkMailFailed(Context context, Account account, String reason)
    {
    }

    public void sendPendingMessagesStarted(Account account)
    {
    }

    public void sendPendingMessagesCompleted(Account account)
    {
    }

    public void sendPendingMessagesFailed(Account account)
    {
    }

    public void messageDeleted(Account account, String folder, Message message)
    {

    }
    public void emptyTrashCompleted(Account account)
    {
    }

    public void folderStatusChanged(Account account, String folderName, int unreadMessageCount)
    {
    }

    public void folderStatusChanged(Account account, String folderName)
    {
    }

    public void messageUidChanged(Account account, String folder, String oldUid, String newUid)
    {

    }

    public void setPushActive(Account account, String folderName, boolean enabled)
    {

    }

    public void loadAttachmentStarted(
        Account account,
        Message message,
        Part part,
        Object tag,
        boolean requiresDownload)
    {
    }

    public void loadAttachmentFinished(
        Account account,
        Message message,
        Part part,
        Object tag)
    {
    }

    public void loadAttachmentFailed(
        Account account,
        Message message,
        Part part,
        Object tag,
        String reason)
    {
    }

    public void pendingCommandsProcessing(Account account) {}
    public void pendingCommandsFinished(Account account) {}
    public void pendingCommandStarted(Account account, String commandTitle)
    {}

    public void pendingCommandCompleted(Account account, String commandTitle)
    {}

    /**
     * General notification messages subclasses can override to be notified that the controller
     * has completed a command. This is useful for turning off progress indicators that may have
     * been left over from previous commands.
     * @param moreCommandsToRun True if the controller will continue on to another command
     * immediately.
     */
    public void controllerCommandCompleted(boolean moreCommandsToRun)
    {

    }
}
",False,189,0,0,8,49,10,4,L1
17,com.fsck.k9.EmailAddressValidator.java,"
package com.fsck.k9;

import java.util.regex.Pattern;

import android.text.util.Rfc822Tokenizer;
import android.widget.AutoCompleteTextView.Validator;

public class EmailAddressValidator implements Validator
{
    // Source: http://www.regular-expressions.info/email.html
    private static Pattern p = Pattern.compile(
            ""[a-z0-9!#$%&'*+/=?^_`{|}~-]+"" +
            ""(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*"" +
            ""@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+"" +
            ""[a-z0-9](?:[a-z0-9-]*[a-z0-9])?"");

    public CharSequence fixText(CharSequence invalidText)
    {
        return """";
    }

    public boolean isValid(CharSequence text)
    {
        return Rfc822Tokenizer.tokenize(text).length > 0;
    }

    public boolean isValidAddressOnly(CharSequence text)
    {
        return p.matcher(text).matches();
    }
}
",False,73,6,41,0,0,2,0,L1
18,com.fsck.k9.codec.binary.Base64OutputStream.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.codec.binary;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

/**
 * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).
 * When encoding the default lineLength is 76 characters and the default
 * lineEnding is CRLF, but these can be overridden by using the appropriate
 * constructor.
 * <p>
 * The default behaviour of the Base64OutputStream is to ENCODE, whereas the
 * default behaviour of the Base64InputStream is to DECODE.  But this behaviour
 * can be overridden by using a different constructor.
 * </p><p>
 * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
 * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
 * </p>
 *
 * @author Apache Software Foundation
 * @version $Id $
 * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045</a>
 * @since 1.0-dev
 */
public class Base64OutputStream extends FilterOutputStream
{
    private final boolean doEncode;
    private final Base64 base64;
    private final byte[] singleByte = new byte[1];

    /**
     * Creates a Base64OutputStream such that all data written is Base64-encoded
     * to the original provided OutputStream.
     *
     * @param out OutputStream to wrap.
     */
    public Base64OutputStream(OutputStream out)
    {
        this(out, true);
    }

    /**
     * Creates a Base64OutputStream such that all data written is either
     * Base64-encoded or Base64-decoded to the original provided OutputStream.
     *
     * @param out      OutputStream to wrap.
     * @param doEncode true if we should encode all data written to us,
     *                 false if we should decode.
     */
    public Base64OutputStream(OutputStream out, boolean doEncode)
    {
        super(out);
        this.doEncode = doEncode;
        this.base64 = new Base64();
    }

    /**
     * Creates a Base64OutputStream such that all data written is either
     * Base64-encoded or Base64-decoded to the original provided OutputStream.
     *
     * @param out           OutputStream to wrap.
     * @param doEncode      true if we should encode all data written to us,
     *                      false if we should decode.
     * @param lineLength    If doEncode is true, each line of encoded
     *                      data will contain lineLength characters.
     *                      If lineLength <=0, the encoded data is not divided into lines.
     *                      If doEncode is false, lineLength is ignored.
     * @param lineSeparator If doEncode is true, each line of encoded
     *                      data will be terminated with this byte sequence (e.g. \r\n).
     *                      If lineLength <= 0, the lineSeparator is not used.
     *                      If doEncode is false lineSeparator is ignored.
     */
    public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator)
    {
        super(out);
        this.doEncode = doEncode;
        this.base64 = new Base64(lineLength, lineSeparator);
    }

    /**
     * Writes the specified <code>byte</code> to this output stream.
     */
    public void write(int i) throws IOException
    {
        singleByte[0] = (byte) i;
        write(singleByte, 0, 1);
    }

    /**
     * Writes <code>len</code> bytes from the specified
     * <code>b</code> array starting at <code>offset</code> to
     * this output stream.
     *
     * @param b source byte array
     * @param offset where to start reading the bytes
     * @param len maximum number of bytes to write
     *
     * @throws IOException if an I/O error occurs.
     * @throws NullPointerException if the byte array parameter is null
     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid
     */
    public void write(byte b[], int offset, int len) throws IOException
    {
        if (b == null)
        {
            throw new NullPointerException();
        }
        else if (offset < 0 || len < 0 || offset + len < 0)
        {
            throw new IndexOutOfBoundsException();
        }
        else if (offset > b.length || offset + len > b.length)
        {
            throw new IndexOutOfBoundsException();
        }
        else if (len > 0)
        {
            if (doEncode)
            {
                base64.encode(b, offset, len);
            }
            else
            {
                base64.decode(b, offset, len);
            }
            flush(false);
        }
    }

    /**
     * Flushes this output stream and forces any buffered output bytes
     * to be written out to the stream.  If propogate is true, the wrapped
     * stream will also be flushed.
     *
     * @param propogate boolean flag to indicate whether the wrapped
     *                  OutputStream should also be flushed.
     * @throws IOException if an I/O error occurs.
     */
    private void flush(boolean propogate) throws IOException
    {
        int avail = base64.avail();
        if (avail > 0)
        {
            byte[] buf = new byte[avail];
            int c = base64.readResults(buf, 0, avail);
            if (c > 0)
            {
                out.write(buf, 0, c);
            }
        }
        if (propogate)
        {
            out.flush();
        }
    }

    /**
     * Flushes this output stream and forces any buffered output bytes
     * to be written out to the stream.
     *
     * @throws IOException if an I/O error occurs.
     */
    public void flush() throws IOException
    {
        flush(true);
    }

    /**
     * Closes this output stream, flushing any remaining bytes that must be encoded. The
     * underlying stream is flushed but not closed.
     */
    public void close() throws IOException
    {
        // Notify encoder of EOF (-1).
        if (doEncode)
        {
            base64.encode(singleByte, 0, -1);
        }
        else
        {
            base64.decode(singleByte, 0, -1);
        }
        flush();
    }

}
",True,75,5,48,1,1,2,1,L1
19,com.fsck.k9.codec.binary.Base64.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.codec.binary;

import org.apache.commons.codec.BinaryDecoder;
import org.apache.commons.codec.BinaryEncoder;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.EncoderException;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;

/**
 * Provides Base64 encoding and decoding as defined by RFC 2045.
 *
 * <p>
 * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
 * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
 * </p>
 *
 * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045</a>
 * @author Apache Software Foundation
 * @since 1.0-dev
 * @version $Id$
 */
public class Base64 implements BinaryEncoder, BinaryDecoder
{
    /**
     * Chunk size per RFC 2045 section 6.8.
     *
     * <p>
     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any
     * equal signs.
     * </p>
     *
     * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045 section 6.8</a>
     */
    static final int CHUNK_SIZE = 76;

    /**
     * Chunk separator per RFC 2045 section 2.1.
     *
     * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045 section 2.1</a>
     */
    static final byte[] CHUNK_SEPARATOR = {'\r','\n'};

    /**
     * This array is a lookup table that translates 6-bit positive integer
     * index values into their ""Base64 Alphabet"" equivalents as specified
     * in Table 1 of RFC 2045.
     *
     * Thanks to ""commons"" project in ws.apache.org for this code.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     */
    private static final byte[] intToBase64 =
    {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
    };

    /**
     * Byte used to pad output.
     */
    private static final byte PAD = '=';

    /**
     * This array is a lookup table that translates unicode characters
     * drawn from the ""Base64 Alphabet"" (as specified in Table 1 of RFC 2045)
     * into their 6-bit positive integer equivalents.  Characters that
     * are not in the Base64 alphabet but fall within the bounds of the
     * array are translated to -1.
     *
     * Thanks to ""commons"" project in ws.apache.org for this code.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     */
    private static final byte[] base64ToInt =
    {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,
        55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,
        5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
        24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,
        35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
    };

    /** Mask used to extract 6 bits, used when encoding */
    private static final int MASK_6BITS = 0x3f;

    /** Mask used to extract 8 bits, used in decoding base64 bytes */
    private static final int MASK_8BITS = 0xff;

    // The static final fields above are used for the original static byte[] methods on Base64.
    // The private member fields below are used with the new streaming approach, which requires
    // some state be preserved between calls of encode() and decode().


    /**
     * Line length for encoding.  Not used when decoding.  A value of zero or less implies
     * no chunking of the base64 encoded data.
     */
    private final int lineLength;

    /**
     * Line separator for encoding.  Not used when decoding.  Only used if lineLength > 0.
     */
    private final byte[] lineSeparator;

    /**
     * Convenience variable to help us determine when our buffer is going to run out of
     * room and needs resizing.  <code>decodeSize = 3 + lineSeparator.length;</code>
     */
    private final int decodeSize;

    /**
     * Convenience variable to help us determine when our buffer is going to run out of
     * room and needs resizing.  <code>encodeSize = 4 + lineSeparator.length;</code>
     */
    private final int encodeSize;

    /**
     * Buffer for streaming.
     */
    private byte[] buf;

    /**
     * Position where next character should be written in the buffer.
     */
    private int pos;

    /**
     * Position where next character should be read from the buffer.
     */
    private int readPos;

    /**
     * Variable tracks how many characters have been written to the current line.
     * Only used when encoding.  We use it to make sure each encoded line never
     * goes beyond lineLength (if lineLength > 0).
     */
    private int currentLinePos;

    /**
     * Writes to the buffer only occur after every 3 reads when encoding, an
     * every 4 reads when decoding.  This variable helps track that.
     */
    private int modulus;

    /**
     * Boolean flag to indicate the EOF has been reached.  Once EOF has been
     * reached, this Base64 object becomes useless, and must be thrown away.
     */
    private boolean eof;

    /**
     * Place holder for the 3 bytes we're dealing with for our base64 logic.
     * Bitwise operations store and extract the base64 encoding or decoding from
     * this variable.
     */
    private int x;

    /**
     * Default constructor:  lineLength is 76, and the lineSeparator is CRLF
     * when encoding, and all forms can be decoded.
     */
    public Base64()
    {
        this(CHUNK_SIZE, CHUNK_SEPARATOR);
    }

    /**
     * <p>
     * Consumer can use this constructor to choose a different lineLength
     * when encoding (lineSeparator is still CRLF).  All forms of data can
     * be decoded.
     * </p><p>
     * Note:  lineLengths that aren't multiples of 4 will still essentially
     * end up being multiples of 4 in the encoded data.
     * </p>
     *
     * @param lineLength each line of encoded data will be at most this long
     * (rounded up to nearest multiple of 4).
     * If lineLength <= 0, then the output will not be divided into lines (chunks).
     * Ignored when decoding.
     */
    public Base64(int lineLength)
    {
        this(lineLength, CHUNK_SEPARATOR);
    }

    /**
     * <p>
     * Consumer can use this constructor to choose a different lineLength
     * and lineSeparator when encoding.  All forms of data can
     * be decoded.
     * </p><p>
     * Note:  lineLengths that aren't multiples of 4 will still essentially
     * end up being multiples of 4 in the encoded data.
     * </p>
     * @param lineLength    Each line of encoded data will be at most this long
     *                      (rounded up to nearest multiple of 4).  Ignored when decoding.
     *                      If <= 0, then output will not be divided into lines (chunks).
     * @param lineSeparator Each line of encoded data will end with this
     *                      sequence of bytes.
     *                      If lineLength <= 0, then the lineSeparator is not used.
     * @throws IllegalArgumentException The provided lineSeparator included
     *                                  some base64 characters.  That's not going to work!
     */
    public Base64(int lineLength, byte[] lineSeparator)
    {
        this.lineLength = lineLength;
        this.lineSeparator = new byte[lineSeparator.length];
        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
        if (lineLength > 0)
        {
            this.encodeSize = 4 + lineSeparator.length;
        }
        else
        {
            this.encodeSize = 4;
        }
        this.decodeSize = encodeSize - 1;
        if (containsBase64Byte(lineSeparator))
        {
            String sep;
            try
            {
                sep = new String(lineSeparator, ""UTF-8"");
            }
            catch (UnsupportedEncodingException uee)
            {
                sep = new String(lineSeparator);
            }
            throw new IllegalArgumentException(""lineSeperator must not contain base64 characters: ["" + sep + ""]"");
        }
    }

    /**
     * Returns true if this Base64 object has buffered data for reading.
     *
     * @return true if there is Base64 object still available for reading.
     */
    boolean hasData()
    {
        return buf != null;
    }

    /**
     * Returns the amount of buffered data available for reading.
     *
     * @return The amount of buffered data available for reading.
     */
    int avail()
    {
        return buf != null ? pos - readPos : 0;
    }

    /** Doubles our buffer. */
    private void resizeBuf()
    {
        if (buf == null)
        {
            buf = new byte[8192];
            pos = 0;
            readPos = 0;
        }
        else
        {
            byte[] b = new byte[buf.length * 2];
            System.arraycopy(buf, 0, b, 0, buf.length);
            buf = b;
        }
    }

    /**
     * Extracts buffered data into the provided byte[] array, starting
     * at position bPos, up to a maximum of bAvail bytes.  Returns how
     * many bytes were actually extracted.
     *
     * @param b      byte[] array to extract the buffered data into.
     * @param bPos   position in byte[] array to start extraction at.
     * @param bAvail amount of bytes we're allowed to extract.  We may extract
     *               fewer (if fewer are available).
     * @return The number of bytes successfully extracted into the provided
     *         byte[] array.
     */
    int readResults(byte[] b, int bPos, int bAvail)
    {
        if (buf != null)
        {
            int len = Math.min(avail(), bAvail);
            if (buf != b)
            {
                System.arraycopy(buf, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos)
                {
                    buf = null;
                }
            }
            else
            {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buf = null;
            }
            return len;
        }
        else
        {
            return eof ? -1 : 0;
        }
    }

    /**
     * Small optimization where we try to buffer directly to the consumer's
     * output array for one round (if consumer calls this method first!) instead
     * of starting our own buffer.
     *
     * @param out byte[] array to buffer directly to.
     * @param outPos Position to start buffering into.
     * @param outAvail Amount of bytes available for direct buffering.
     */
    void setInitialBuffer(byte[] out, int outPos, int outAvail)
    {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail)
        {
            buf = out;
            pos = outPos;
            readPos = outPos;
        }
    }

    /**
     * <p>
     * Encodes all of the provided data, starting at inPos, for inAvail bytes.
     * Must be called at least twice:  once with the data to encode, and once
     * with inAvail set to ""-1"" to alert encoder that EOF has been reached,
     * so flush last remaining bytes (if not multiple of 3).
     * </p><p>
     * Thanks to ""commons"" project in ws.apache.org for the bitwise operations,
     * and general approach.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * </p>
     *
     * @param in byte[] array of binary data to base64 encode.
     * @param inPos Position to start reading data from.
     * @param inAvail Amount of bytes available from input for encoding.
     */
    void encode(byte[] in, int inPos, int inAvail)
    {
        if (eof)
        {
            return;
        }

        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0)
        {
            eof = true;
            if (buf == null || buf.length - pos < encodeSize)
            {
                resizeBuf();
            }
            switch (modulus)
            {
                case 1:
                    buf[pos++] = intToBase64[(x >> 2) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x << 4) & MASK_6BITS];
                    buf[pos++] = PAD;
                    buf[pos++] = PAD;
                    break;

                case 2:
                    buf[pos++] = intToBase64[(x >> 10) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x >> 4) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x << 2) & MASK_6BITS];
                    buf[pos++] = PAD;
                    break;
            }
            if (lineLength > 0)
            {
                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        }
        else
        {
            for (int i = 0; i < inAvail; i++)
            {
                if (buf == null || buf.length - pos < encodeSize)
                {
                    resizeBuf();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0)
                {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus)
                {
                    buf[pos++] = intToBase64[(x >> 18) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x >> 12) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x >> 6) & MASK_6BITS];
                    buf[pos++] = intToBase64[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos)
                    {
                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }

    /**
     * <p>
     * Decodes all of the provided data, starting at inPos, for inAvail bytes.
     * Should be called at least twice:  once with the data to decode, and once
     * with inAvail set to ""-1"" to alert decoder that EOF has been reached.
     * The ""-1"" call is not necessary when decoding, but it doesn't hurt, either.
     * </p><p>
     * Ignores all non-base64 characters.  This is how chunked (e.g. 76 character)
     * data is handled, since CR and LF are silently ignored, but has implications
     * for other bytes, too.  This method subscribes to the garbage-in, garbage-out
     * philosophy:  it will not check the provided data for validity.
     * </p><p>
     * Thanks to ""commons"" project in ws.apache.org for the bitwise operations,
     * and general approach.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * </p>

     * @param in byte[] array of ascii data to base64 decode.
     * @param inPos Position to start reading data from.
     * @param inAvail Amount of bytes available from input for encoding.
     */
    void decode(byte[] in, int inPos, int inAvail)
    {
        if (eof)
        {
            return;
        }
        if (inAvail < 0)
        {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++)
        {
            if (buf == null || buf.length - pos < decodeSize)
            {
                resizeBuf();
            }
            byte b = in[inPos++];
            if (b == PAD)
            {
                x = x << 6;
                switch (modulus)
                {
                    case 2:
                        x = x << 6;
                        buf[pos++] = (byte)((x >> 16) & MASK_8BITS);
                        break;
                    case 3:
                        buf[pos++] = (byte)((x >> 16) & MASK_8BITS);
                        buf[pos++] = (byte)((x >> 8) & MASK_8BITS);
                        break;
                }
                // WE'RE DONE!!!!
                eof = true;
                return;
            }
            else
            {
                if (b >= 0 && b < base64ToInt.length)
                {
                    int result = base64ToInt[b];
                    if (result >= 0)
                    {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0)
                        {
                            buf[pos++] = (byte)((x >> 16) & MASK_8BITS);
                            buf[pos++] = (byte)((x >> 8) & MASK_8BITS);
                            buf[pos++] = (byte)(x & MASK_8BITS);
                        }
                    }
                }
            }
        }
    }

    /**
     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
     *
     * @param octet
     *            The value to test
     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
     */
    public static boolean isBase64(byte octet)
    {
        return octet == PAD || (octet >= 0 && octet < base64ToInt.length && base64ToInt[octet] != -1);
    }

    /**
     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.
     * Currently the method treats whitespace as valid.
     *
     * @param arrayOctet
     *            byte array to test
     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is
     *         empty; false, otherwise
     */
    public static boolean isArrayByteBase64(byte[] arrayOctet)
    {
        for (int i = 0; i < arrayOctet.length; i++)
        {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i]))
            {
                return false;
            }
        }
        return true;
    }

    /*
     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.
     *
     * @param arrayOctet
     *            byte array to test
     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise
     */
    private static boolean containsBase64Byte(byte[] arrayOctet)
    {
        for (int i = 0; i < arrayOctet.length; i++)
        {
            if (isBase64(arrayOctet[i]))
            {
                return true;
            }
        }
        return false;
    }

    /**
     * Encodes binary data using the base64 algorithm but does not chunk the output.
     *
     * @param binaryData
     *            binary data to encode
     * @return Base64 characters
     */
    public static byte[] encodeBase64(byte[] binaryData)
    {
        return encodeBase64(binaryData, false);
    }

    /**
     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
     *
     * @param binaryData
     *            binary data to encode
     * @return Base64 characters chunked in 76 character blocks
     */
    public static byte[] encodeBase64Chunked(byte[] binaryData)
    {
        return encodeBase64(binaryData, true);
    }

    /**
     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[].
     *
     * @param pObject
     *            Object to decode
     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] supplied.
     * @throws DecoderException
     *             if the parameter supplied is not of type byte[]
     */
    public Object decode(Object pObject) throws DecoderException
    {
        if (!(pObject instanceof byte[]))
        {
            throw new DecoderException(""Parameter supplied to Base64 decode is not a byte[]"");
        }
        return decode((byte[]) pObject);
    }

    /**
     * Decodes a byte[] containing containing characters in the Base64 alphabet.
     *
     * @param pArray
     *            A byte array containing Base64 character data
     * @return a byte array containing binary data
     */
    public byte[] decode(byte[] pArray)
    {
        return decodeBase64(pArray);
    }

    /**
     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
     *
     * @param binaryData
     *            Array containing binary data to encode.
     * @param isChunked
     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
     * @return Base64-encoded data.
     * @throws IllegalArgumentException
     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
     */
    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked)
    {
        if (binaryData == null || binaryData.length == 0)
        {
            return binaryData;
        }
        Base64 b64 = isChunked ? new Base64() : new Base64(0);

        long len = (binaryData.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0)
        {
            len += 4 - mod;
        }
        if (isChunked)
        {
            len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;
        }

        if (len > Integer.MAX_VALUE)
        {
            throw new IllegalArgumentException(
                ""Input array too big, output array would be bigger than Integer.MAX_VALUE="" + Integer.MAX_VALUE);
        }
        byte[] buf = new byte[(int) len];
        b64.setInitialBuffer(buf, 0, buf.length);
        b64.encode(binaryData, 0, binaryData.length);
        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.

        // Encoder might have resized, even though it was unnecessary.
        if (b64.buf != buf)
        {
            b64.readResults(buf, 0, buf.length);
        }
        return buf;
    }

    /**
     * Decodes Base64 data into octets
     *
     * @param base64Data Byte array containing Base64 data
     * @return Array containing decoded data.
     */
    public static byte[] decodeBase64(byte[] base64Data)
    {
        if (base64Data == null || base64Data.length == 0)
        {
            return base64Data;
        }
        Base64 b64 = new Base64();

        long len = (base64Data.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        b64.setInitialBuffer(buf, 0, buf.length);
        b64.decode(base64Data, 0, base64Data.length);
        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.

        // We have no idea what the line-length was, so we
        // cannot know how much of our array wasn't used.
        byte[] result = new byte[b64.pos];
        b64.readResults(result, 0, result.length);
        return result;
    }

    /**
     * Discards any whitespace from a base-64 encoded block.
     *
     * @param data
     *            The base-64 encoded data to discard the whitespace from.
     * @return The data, less whitespace (see RFC 2045).
     * @deprecated This method is no longer needed
     */
    static byte[] discardWhitespace(byte[] data)
    {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;

        for (int i = 0; i < data.length; i++)
        {
            switch (data[i])
            {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }

        byte packedData[] = new byte[bytesCopied];

        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);

        return packedData;
    }


    /**
     * Check if a byte value is whitespace or not.
     *
     * @param byteToCheck the byte to check
     * @return true if byte is whitespace, false otherwise
     */
    private static boolean isWhiteSpace(byte byteToCheck)
    {
        switch (byteToCheck)
        {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }

    /**
     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - ""Any
     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.""
     *
     * @param data
     *            The base-64 encoded data to groom
     * @return The data, less non-base64 characters (see RFC 2045).
     */
    static byte[] discardNonBase64(byte[] data)
    {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;

        for (int i = 0; i < data.length; i++)
        {
            if (isBase64(data[i]))
            {
                groomedData[bytesCopied++] = data[i];
            }
        }

        byte packedData[] = new byte[bytesCopied];

        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);

        return packedData;
    }

    // Implementation of the Encoder Interface

    /**
     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].
     *
     * @param pObject
     *            Object to encode
     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.
     * @throws EncoderException
     *             if the parameter supplied is not of type byte[]
     */
    public Object encode(Object pObject) throws EncoderException
    {
        if (!(pObject instanceof byte[]))
        {
            throw new EncoderException(""Parameter supplied to Base64 encode is not a byte[]"");
        }
        return encode((byte[]) pObject);
    }

    /**
     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.
     *
     * @param pArray
     *            a byte array containing binary data
     * @return A byte array containing only Base64 character data
     */
    public byte[] encode(byte[] pArray)
    {
        return encodeBase64(pArray, false);
    }

    // Implementation of integer encoding used for crypto
    /**
     * Decode a byte64-encoded integer according to crypto
     * standards such as W3C's XML-Signature
     *
     * @param pArray a byte array containing base64 character data
     * @return A BigInteger
     */
    public static BigInteger decodeInteger(byte[] pArray)
    {
        return new BigInteger(1, decodeBase64(pArray));
    }

    /**
     * Encode to a byte64-encoded integer according to crypto
     * standards such as W3C's XML-Signature
     *
     * @param bigInt a BigInteger
     * @return A byte array containing base64 character data
     * @throws NullPointerException if null is passed in
     */
    public static byte[] encodeInteger(BigInteger bigInt)
    {
        if (bigInt == null)
        {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }

        return encodeBase64(toIntegerBytes(bigInt), false);
    }

    /**
     * Returns a byte-array representation of a <code>BigInteger</code>
     * without sign bit.
     *
     * @param bigInt <code>BigInteger</code> to be converted
     * @return a byte array representation of the BigInteger parameter
     */
    static byte[] toIntegerBytes(BigInteger bigInt)
    {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) &&
                (((bigInt.bitLength() / 8) + 1) == (bitlen / 8)))
        {
            return bigBytes;
        }

        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0)
        {
            startSrc = 1;
            len--;
        }

        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];

        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);

        return resizedBytes;
    }
}
",False,76,5,35,0,0,3,0,L1
20,com.fsck.k9.activity.SizeFormatter.java,"package com.fsck.k9.activity;

import android.content.Context;
import com.fsck.k9.R;

public class SizeFormatter
{
    public static String formatSize(Context context, long size)
    {
        if (size > 1024000000)
        {
            return ((float)(size / 102400000) / 10) + context.getString(R.string.abbrev_gigabytes);
        }
        if (size > 1024000)
        {
            return ((float)(size / 102400) / 10) + context.getString(R.string.abbrev_megabytes);
        }
        if (size > 1024)
        {
            return ((float)(size / 102) / 10) + context.getString(R.string.abbrev_kilobytes);
        }
        return size + context.getString(R.string.abbrev_bytes);
    }

}
",False,73,7,35,0,0,2,0,L1
21,com.fsck.k9.activity.ChooseFolder.java,"
package com.fsck.k9.activity;

import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.View;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.TextView;
import com.fsck.k9.*;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.MessagingException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class ChooseFolder extends K9ListActivity
{
    String mFolder;
    Account mAccount;
    String mUID;
    ArrayAdapter<String> adapter;
    private ChooseFolderHandler mHandler = new ChooseFolderHandler();
    String heldInbox = null;
    boolean hideCurrentFolder = true;
    boolean showOptionNone = false;
    boolean showDisplayableOnly = false;

    public static final String EXTRA_ACCOUNT = ""com.fsck.k9.ChooseFolder_account"";
    public static final String EXTRA_CUR_FOLDER = ""com.fsck.k9.ChooseFolder_curfolder"";
    public static final String EXTRA_NEW_FOLDER = ""com.fsck.k9.ChooseFolder_newfolder"";
    public static final String EXTRA_MESSAGE_UID = ""com.fsck.k9.ChooseFolder_messageuid"";
    public static final String EXTRA_SHOW_CURRENT = ""com.fsck.k9.ChooseFolder_showcurrent"";
    public static final String EXTRA_SHOW_FOLDER_NONE = ""com.fsck.k9.ChooseFolder_showOptionNone"";
    public static final String EXTRA_SHOW_DISPLAYABLE_ONLY = ""com.fsck.k9.ChooseFolder_showDisplayableOnly"";

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        getListView().setFastScrollEnabled(true);
        getListView().setTextFilterEnabled(true);
        getListView().setItemsCanFocus(false);
        getListView().setChoiceMode(ListView.CHOICE_MODE_NONE);
        Intent intent = getIntent();
        String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mUID = intent.getStringExtra(EXTRA_MESSAGE_UID);
        mFolder = intent.getStringExtra(EXTRA_CUR_FOLDER);
        if (intent.getStringExtra(EXTRA_SHOW_CURRENT) != null)
        {
            hideCurrentFolder = false;
        }
        if (intent.getStringExtra(EXTRA_SHOW_FOLDER_NONE) != null)
        {
            showOptionNone = true;
        }
        if (intent.getStringExtra(EXTRA_SHOW_DISPLAYABLE_ONLY) != null)
        {
            showDisplayableOnly = true;
        }
        if (mFolder == null)
            mFolder = """";

        adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1);

        setListAdapter(adapter);


        MessagingController.getInstance(getApplication()).listFolders(mAccount,
                false, mListener);


        this.getListView().setOnItemClickListener(new AdapterView.OnItemClickListener()
        {
            public void onItemClick(AdapterView adapterview, View view, int i, long l)
            {
                Intent intent = new Intent();
                intent.putExtra(EXTRA_CUR_FOLDER, mFolder);
                String destFolderName = (String)((TextView)view).getText();
                if (heldInbox != null && getString(R.string.special_mailbox_name_inbox).equals(destFolderName))
                {
                    destFolderName = heldInbox;
                }
                intent.putExtra(EXTRA_NEW_FOLDER, destFolderName);
                intent.putExtra(EXTRA_MESSAGE_UID, mUID);
                setResult(RESULT_OK, intent);
                finish();
            }
        });

    }

    class ChooseFolderHandler extends Handler
    {

        private static final int MSG_PROGRESS = 2;

        private static final int MSG_DATA_CHANGED = 3;
        private static final int MSG_SET_SELECTED_FOLDER = 4;

        public void handleMessage(android.os.Message msg)
        {
            switch (msg.what)
            {
                case MSG_PROGRESS:
                    setProgressBarIndeterminateVisibility(msg.arg1 != 0);
                    break;
                case MSG_DATA_CHANGED:
                    adapter.notifyDataSetChanged();
                    break;
                case MSG_SET_SELECTED_FOLDER:
                    // TODO: I want this to highlight the chosen folder, but this doesn't work.
//          getListView().setSelection(msg.arg1);
//          getListView().setItemChecked(msg.arg1, true);
                    break;
            }
        }

        public void progress(boolean progress)
        {
            android.os.Message msg = new android.os.Message();
            msg.what = MSG_PROGRESS;
            msg.arg1 = progress ? 1 : 0;
            sendMessage(msg);
        }

        public void setSelectedFolder(int position)
        {
            android.os.Message msg = new android.os.Message();
            msg.what = MSG_SET_SELECTED_FOLDER;
            msg.arg1 = position;
            sendMessage(msg);
        }

        public void dataChanged()
        {
            sendEmptyMessage(MSG_DATA_CHANGED);
        }
    }

    private MessagingListener mListener = new MessagingListener()
    {
        public void listFoldersStarted(Account account)
        {
            if (!account.equals(mAccount))
            {
                return;
            }
            mHandler.progress(true);
        }

        @Override
        public void listFoldersFailed(Account account, String message)
        {
            if (!account.equals(mAccount))
            {
                return;
            }
            mHandler.progress(false);
        }

        @Override
        public void listFoldersFinished(Account account)
        {
            if (!account.equals(mAccount))
            {
                return;
            }
            mHandler.progress(false);
        }
        @Override
        public void listFolders(Account account, Folder[] folders)
        {
            if (!account.equals(mAccount))
            {
                return;
            }
            Account.FolderMode aMode = Account.FolderMode.ALL;
            if (showDisplayableOnly)
            {
                aMode = account.getFolderDisplayMode();
            }
            else
            {
                aMode = account.getFolderTargetMode();
            }
            Preferences prefs = Preferences.getPreferences(getApplication().getApplicationContext());
            ArrayList<String> localFolders = new ArrayList<String>();

            for (Folder folder : folders)
            {
                String name = folder.getName();

                // Inbox needs to be compared case-insensitively
                if (hideCurrentFolder && (name.equals(mFolder) || (K9.INBOX.equalsIgnoreCase(mFolder) && K9.INBOX.equalsIgnoreCase(name))))
                {
                    continue;
                }
                try
                {
                    folder.refresh(prefs);
                    Folder.FolderClass fMode = folder.getDisplayClass();

                    if ((aMode == Account.FolderMode.FIRST_CLASS && fMode != Folder.FolderClass.FIRST_CLASS)
                            || (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
                                fMode != Folder.FolderClass.FIRST_CLASS &&
                                fMode != Folder.FolderClass.SECOND_CLASS)
                            || (aMode == Account.FolderMode.NOT_SECOND_CLASS && fMode == Folder.FolderClass.SECOND_CLASS))
                    {
                        continue;
                    }
                }
                catch (MessagingException me)
                {
                    Log.e(K9.LOG_TAG, ""Couldn't get prefs to check for displayability of folder "" + folder.getName(), me);
                }

                localFolders.add(folder.getName());

            }

            if (showOptionNone)
            {
                localFolders.add(K9.FOLDER_NONE);
            }

            Collections.sort(localFolders, new Comparator<String>()
            {
                public int compare(String aName, String bName)
                {
                    if (K9.FOLDER_NONE.equalsIgnoreCase(aName))
                    {
                        return -1;
                    }
                    if (K9.FOLDER_NONE.equalsIgnoreCase(bName))
                    {
                        return 1;
                    }
                    if (K9.INBOX.equalsIgnoreCase(aName))
                    {
                        return -1;
                    }
                    if (K9.INBOX.equalsIgnoreCase(bName))
                    {
                        return 1;
                    }

                    return aName.compareToIgnoreCase(bName);
                }
            });
            adapter.setNotifyOnChange(false);
            adapter.clear();
            int selectedFolder = -1;
            int position = 0;
            for (String name : localFolders)
            {
                if (K9.INBOX.equalsIgnoreCase(name))
                {
                    adapter.add(getString(R.string.special_mailbox_name_inbox));
                    heldInbox = name;
                }
                else
                {
                    adapter.add(name);
                }

                if ((name.equals(mFolder) || (K9.INBOX.equalsIgnoreCase(mFolder) && K9.INBOX.equalsIgnoreCase(name))))
                {
                    selectedFolder = position;
                }
                position++;
            }
            if (selectedFolder != -1)
            {
                mHandler.setSelectedFolder(selectedFolder);
            }
            mHandler.dataChanged();

        }
    };
}
",True,189,0,0,8,48,4,8,L1
22,com.fsck.k9.activity.ProgressListener.java,"
package com.fsck.k9.activity;

import android.content.Context;

/**
 * A listener that the user can register for global, persistent progress events.
 */
public interface ProgressListener
{
    /**
     * @param context
     * @param title
     * @param message
     * @param currentProgress
     * @param maxProgress
     * @param indeterminate
     */
    void showProgress(Context context, String title, String message, long currentProgress,
                      long maxProgress, boolean indeterminate);

    /**
     * @param context
     * @param title
     * @param message
     * @param currentProgress
     * @param maxProgress
     * @param indeterminate
     */
    void updateProgress(Context context, String title, String message, long currentProgress,
                        long maxProgress, boolean indeterminate);

    /**
     * @param context
     */
    void hideProgress(Context context);
}
",False,1,0,0,0,0,0,0,I0
23,com.fsck.k9.activity.FolderList.java,"package com.fsck.k9.activity;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.NotificationManager;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Config;
import android.util.Log;
import android.view.*;
import android.view.ContextMenu.ContextMenuInfo;
import android.widget.*;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.AdapterView.OnItemClickListener;
import com.fsck.k9.*;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.activity.setup.AccountSettings;
import com.fsck.k9.activity.setup.FolderSettings;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.service.MailService;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;

/**
 * FolderList is the primary user interface for the program. This
 * Activity shows list of the Account's folders
 */

public class FolderList extends K9ListActivity
{

    private static final int DIALOG_MARK_ALL_AS_READ = 1;

    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_INITIAL_FOLDER = ""initialFolder"";

    //private static final String STATE_CURRENT_FOLDER = ""com.fsck.k9.activity.folderlist_folder"";

    private static final String EXTRA_CLEAR_NOTIFICATION = ""clearNotification"";

    private static final boolean REFRESH_REMOTE = true;

    private ListView mListView;

    private FolderListAdapter mAdapter;

    private LayoutInflater mInflater;

    private Account mAccount;

    private FolderListHandler mHandler = new FolderListHandler();

    private int mUnreadMessageCount;

    class FolderListHandler extends Handler
    {

        public void refreshTitle()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    String dispString = mAdapter.mListener.formatHeader(FolderList.this, getString(R.string.folder_list_title, mAccount.getDescription()), mUnreadMessageCount, getTimeFormat());


                    setTitle(dispString);
                }
            });
        }


        public void newFolders(final List<FolderInfoHolder> newFolders)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    mAdapter.mFolders.clear();
                    mAdapter.mFolders.addAll(newFolders);
                    mHandler.dataChanged();
                }
            });
        }

        public void workingAccount(final int res)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    String toastText = getString(res, mAccount.getDescription());
                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_SHORT);
                    toast.show();
                }
            });
        }

        public void accountSizeChanged(final long oldSize, final long newSize)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    String toastText = getString(R.string.account_size_changed, mAccount.getDescription(), SizeFormatter.formatSize(getApplication(), oldSize), SizeFormatter.formatSize(getApplication(), newSize));

                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
                    toast.show();
                }
            });
        }

        public void folderLoading(final String folder, final boolean loading)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    FolderInfoHolder folderHolder = mAdapter.getFolder(folder);


                    if (folderHolder != null)
                    {
                        folderHolder.loading = loading;
                    }

                }
            });
        }

        public void progress(final boolean progress)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    setProgressBarIndeterminateVisibility(progress);
                }
            });

        }

        public void dataChanged()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    mAdapter.notifyDataSetChanged();
                }
            });
        }
    }

    /**
    * This class is responsible for reloading the list of local messages for a
    * given folder, notifying the adapter that the message have been loaded and
    * queueing up a remote update of the folder.
     */

    private void checkMail(FolderInfoHolder folder)
    {
        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
        final WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""Email - UpdateWorker"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(K9.WAKE_LOCK_TIMEOUT);
        MessagingListener listener = new MessagingListener()
        {
            public void synchronizeMailboxFinished(Account account, String folder, int totalMessagesInMailbox, int numNewMessages)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }
                wakeLock.release();
            }

            @Override
            public void synchronizeMailboxFailed(Account account, String folder,
                                                 String message)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }
                wakeLock.release();
            }
        };
        MessagingController.getInstance(getApplication()).synchronizeMailbox(mAccount, folder.name, listener);
        sendMail(mAccount);
    }

    private static void actionHandleAccount(Context context, Account account, String initialFolder)
    {
        Intent intent = new Intent(context, FolderList.class);
        intent.putExtra(EXTRA_ACCOUNT, account.getUuid());

        if (initialFolder != null)
        {
            intent.putExtra(EXTRA_INITIAL_FOLDER, initialFolder);
        }

        context.startActivity(intent);
    }

    public static void actionHandleAccount(Context context, Account account)
    {
        actionHandleAccount(context, account, null);
    }

    public static Intent actionHandleAccountIntent(Context context, Account account, String initialFolder)
    {
        Intent intent = new Intent(
            Intent.ACTION_VIEW,
            Uri.parse(""email://accounts/"" + account.getAccountNumber()),
            context,
            FolderList.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.putExtra(EXTRA_ACCOUNT, account.getUuid());
        intent.putExtra(EXTRA_CLEAR_NOTIFICATION, true);

        if (initialFolder != null)
        {
            intent.putExtra(EXTRA_INITIAL_FOLDER, initialFolder);
        }
        return intent;
    }

    public static Intent actionHandleAccountIntent(Context context, Account account)
    {
        return actionHandleAccountIntent(context, account, null);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);

        mListView = getListView();
        mListView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_INSET);
        mListView.setLongClickable(true);
        mListView.setFastScrollEnabled(true);
        mListView.setScrollingCacheEnabled(true);
        mListView.setOnItemClickListener(new OnItemClickListener()
        {
            public void onItemClick(AdapterView parent, View v, int itemPosition, long id)
            {
                onOpenFolder(((FolderInfoHolder)mAdapter.getItem(id)).name);
            }
        });
        registerForContextMenu(mListView);
        
        mListView.setSaveEnabled(true);

        mInflater = getLayoutInflater();

        onNewIntent(getIntent());
    }

    public void onNewIntent(Intent intent)
    {
        setIntent(intent); // onNewIntent doesn't autoset our ""internal"" intent

        String savedFolderName = null;
        String initialFolder;

        mUnreadMessageCount = 0;
        String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        initialFolder = intent.getStringExtra(EXTRA_INITIAL_FOLDER);
        if (
            initialFolder != null
            && !K9.FOLDER_NONE.equals(initialFolder))
        {
            onOpenFolder(initialFolder);
            finish();
        }
        else
        {

            initializeActivityView();
        }
    }

    private void initializeActivityView()
    {
        mAdapter = new FolderListAdapter();

        final Object previousData = getLastNonConfigurationInstance();

        if (previousData != null)
        {
            //noinspection unchecked
            mAdapter.mFolders = (ArrayList<FolderInfoHolder>) previousData;
        }

        setListAdapter(mAdapter);

        setTitle(mAccount.getDescription());

    }


    @Override public Object onRetainNonConfigurationInstance()
    {
        return mAdapter.mFolders;
    }

    @Override public void onPause()
    {
        super.onPause();
        MessagingController.getInstance(getApplication()).removeListener(mAdapter.mListener);
    }

    /**
    * On resume we refresh the folder list (in the background) and we refresh the
    * messages for any folder that is currently open. This guarantees that things
    * like unread message count and read status are updated.
     */
    @Override public void onResume()
    {
        super.onResume();

        if (mAdapter == null)
            initializeActivityView();

        MessagingController.getInstance(getApplication()).addListener(mAdapter.mListener);
        //mAccount.refresh(Preferences.getPreferences(this));
        MessagingController.getInstance(getApplication()).getAccountUnreadCount(this, mAccount, mAdapter.mListener);

        onRefresh(!REFRESH_REMOTE);

        NotificationManager notifMgr = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        notifMgr.cancel(mAccount.getAccountNumber());
        notifMgr.cancel(-1000 - mAccount.getAccountNumber());

    }


    @Override public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        //Shortcuts that work no matter what is selected
        switch (keyCode)
        {
            case KeyEvent.KEYCODE_Q:
                //case KeyEvent.KEYCODE_BACK:
            {
                onAccounts();
                return true;
            }

            case KeyEvent.KEYCODE_S:
            {
                onEditAccount();
                return true;
            }

            case KeyEvent.KEYCODE_H:
            {
                Toast toast = Toast.makeText(this, R.string.folder_list_help_key, Toast.LENGTH_LONG);
                toast.show();
                return true;
            }
            
            case KeyEvent.KEYCODE_1:
            {
                setDisplayMode(FolderMode.FIRST_CLASS);
                return true;
            }
            case KeyEvent.KEYCODE_2:
            {
                setDisplayMode(FolderMode.FIRST_AND_SECOND_CLASS);
                return true;
            }
            case KeyEvent.KEYCODE_3:
            {
                setDisplayMode(FolderMode.NOT_SECOND_CLASS);
                return true;
            }
            case KeyEvent.KEYCODE_4:
            {
                setDisplayMode(FolderMode.ALL);
                return true;
            }
        }//switch


        return super.onKeyDown(keyCode, event);
    }//onKeyDown

    private void setDisplayMode(FolderMode newMode)
    {
        mAccount.setFolderDisplayMode(newMode);
        mAccount.save(Preferences.getPreferences(this));
        if (mAccount.getFolderPushMode() != FolderMode.NONE)
        {
            MailService.actionRestartPushers(this, null);
        }
        onRefresh(false);
    }
    
    
    private void onRefresh(final boolean forceRemote)
    {

        MessagingController.getInstance(getApplication()).listFolders(mAccount, forceRemote, mAdapter.mListener);

    }

    private void onEditAccount()
    {
        AccountSettings.actionSettings(this, mAccount);
    }

    private void onEditFolder(Account account, String folderName)
    {
        FolderSettings.actionSettings(this, account, folderName);
    }

    private void onAccounts()
    {
        Accounts.listAccounts(this);
        finish();
    }

    private void onEmptyTrash(final Account account)
    {
        mHandler.dataChanged();

        MessagingController.getInstance(getApplication()).emptyTrash(account, null);
    }

    private void onExpunge(final Account account, String folderName)
    {
        MessagingController.getInstance(getApplication()).expunge(account, folderName, null);
    }

    private void checkMail(final Account account)
    {
        MessagingController.getInstance(getApplication()).checkMail(this, account, true, true, mAdapter.mListener);
    }

    private void sendMail(Account account)
    {
        MessagingController.getInstance(getApplication()).sendPendingMessages(account, mAdapter.mListener);
    }

    @Override public boolean onOptionsItemSelected(MenuItem item)
    {
        switch (item.getItemId())
        {
            case R.id.compose:
                MessageCompose.actionCompose(this, mAccount);

                return true;

            case R.id.check_mail:
                checkMail(mAccount);

                return true;

            case R.id.send_messages:
                MessagingController.getInstance(getApplication()).sendPendingMessages(mAccount, null);
                return true;
            case R.id.accounts:
                onAccounts();

                return true;

            case R.id.list_folders:
                onRefresh(REFRESH_REMOTE);

                return true;

            case R.id.account_settings:
                onEditAccount();

                return true;

            case R.id.empty_trash:
                onEmptyTrash(mAccount);

                return true;

            case R.id.compact:
                onCompact(mAccount);

                return true;

            case R.id.clear:
                onClear(mAccount);

                return true;
            case R.id.display_1st_class:
            {
                setDisplayMode(FolderMode.FIRST_CLASS);
                return true;
            }
            case R.id.display_1st_and_2nd_class:
            {
                setDisplayMode(FolderMode.FIRST_AND_SECOND_CLASS);
                return true;
            }
            case R.id.display_not_second_class:
            {
                setDisplayMode(FolderMode.NOT_SECOND_CLASS);
                return true;
            }
            case R.id.display_all:
            {
                setDisplayMode(FolderMode.ALL);
                return true;
            }
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    private void onOpenFolder(String folder)
    {
        MessageList.actionHandleFolder(this, mAccount, folder);
    }

    private void onCompact(Account account)
    {
        mHandler.workingAccount(R.string.compacting_account);
        MessagingController.getInstance(getApplication()).compact(account, null);
    }

    private void onClear(Account account)
    {
        mHandler.workingAccount(R.string.clearing_account);
        MessagingController.getInstance(getApplication()).clear(account, null);
    }

    @Override public boolean onCreateOptionsMenu(Menu menu)
    {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.folder_list_option, menu);
        return true;
    }

    @Override public boolean onContextItemSelected(MenuItem item)
    {
        AdapterContextMenuInfo info = (AdapterContextMenuInfo) item .getMenuInfo();
        FolderInfoHolder folder = (FolderInfoHolder) mAdapter.getItem(info.position);

        switch (item.getItemId())
        {
            case R.id.open_folder:
                onOpenFolder(folder.name);
                break;

            case R.id.mark_all_as_read:
                onMarkAllAsRead(mAccount, folder.name);
                break;

            case R.id.send_messages:
                sendMail(mAccount);

                break;

            case R.id.check_mail:
                checkMail(folder);

                break;

            case R.id.folder_settings:
                onEditFolder(mAccount, folder.name);

                break;

            case R.id.empty_trash:
                onEmptyTrash(mAccount);

                break;
            case R.id.expunge:
                onExpunge(mAccount, folder.name);

                break;
        }

        return super.onContextItemSelected(item);
    }

    private FolderInfoHolder mSelectedContextFolder = null;


    private void onMarkAllAsRead(final Account account, final String folder)
    {
        mSelectedContextFolder = mAdapter.getFolder(folder);
        showDialog(DIALOG_MARK_ALL_AS_READ);
    }


    @Override
    public Dialog onCreateDialog(int id)
    {
        switch (id)
        {
            case DIALOG_MARK_ALL_AS_READ:
                return createMarkAllAsReadDialog();
        }

        return super.onCreateDialog(id);
    }

    public void onPrepareDialog(int id, Dialog dialog)
    {
        switch (id)
        {
            case DIALOG_MARK_ALL_AS_READ:
                ((AlertDialog)dialog).setMessage(getString(R.string.mark_all_as_read_dlg_instructions_fmt,
                                                 mSelectedContextFolder.displayName));

                break;

            default:
                super.onPrepareDialog(id, dialog);
        }
    }

    private Dialog createMarkAllAsReadDialog()
    {
        return new AlertDialog.Builder(this)
               .setTitle(R.string.mark_all_as_read_dlg_title)
               .setMessage(getString(R.string.mark_all_as_read_dlg_instructions_fmt,
                                     mSelectedContextFolder.displayName))
               .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_MARK_ALL_AS_READ);

                try
                {

                    MessagingController.getInstance(getApplication()).markAllMessagesRead(mAccount, mSelectedContextFolder.name);

                    mSelectedContextFolder.unreadMessageCount = 0;

                    mHandler.dataChanged();


                }
                catch (Exception e)
                {
                    // Ignore
                }
            }
        })

               .setNegativeButton(R.string.cancel_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_MARK_ALL_AS_READ);
            }
        })

               .create();
    }


    @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)
    {
        super.onCreateContextMenu(menu, v, menuInfo);
        AdapterContextMenuInfo info = (AdapterContextMenuInfo) menuInfo;
        getMenuInflater().inflate(R.menu.folder_context, menu);

        FolderInfoHolder folder = (FolderInfoHolder) mAdapter.getItem(info.position);

        menu.setHeaderTitle((CharSequence) folder.displayName);

        if (!folder.name.equals(mAccount.getTrashFolderName()))
            menu.findItem(R.id.empty_trash).setVisible(false);

        if (folder.outbox)
        {
            menu.findItem(R.id.check_mail).setVisible(false);
        }
        else
        {
            menu.findItem(R.id.send_messages).setVisible(false);
        }
        if (K9.ERROR_FOLDER_NAME.equals(folder.name))
        {
            menu.findItem(R.id.expunge).setVisible(false);
        }

        menu.setHeaderTitle(folder.displayName);
    }

    private String truncateStatus(String mess)
    {
        if (mess != null && mess.length() > 27)
        {
            mess = mess.substring(0, 27);
        }

        return mess;
    }

    class FolderListAdapter extends BaseAdapter
    {
        private ArrayList<FolderInfoHolder> mFolders = new ArrayList<FolderInfoHolder>();

        public Object getItem(long position)
        {
            return getItem((int)position);
        }

        public Object getItem(int position)
        {
            return mFolders.get(position);
        }


        public long getItemId(int position)
        {
            return position ;
        }

        public int getCount()
        {
            return mFolders.size();
        }

        public boolean isEnabled(int item)
        {
            return true;
        }

        public boolean areAllItemsEnabled()
        {
            return true;
        }

        private ActivityListener mListener = new ActivityListener()
        {
            @Override
            public void accountStatusChanged(Account account, int unreadMessageCount)
            {
                mUnreadMessageCount = unreadMessageCount;
                mHandler.refreshTitle();
            }

            @Override
            public void listFoldersStarted(Account account)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }

                mHandler.progress(true);
            }

            @Override
            public void listFoldersFailed(Account account, String message)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }

                mHandler.progress(false);

                if (Config.LOGV)
                {
                    Log.v(K9.LOG_TAG, ""listFoldersFailed "" + message);
                }
            }

            @Override
            public void listFoldersFinished(Account account)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }

                mHandler.progress(false);
                MessagingController.getInstance(getApplication()).refreshListener(mAdapter.mListener);
                mHandler.dataChanged();

            }

            @Override
            public void listFolders(Account account, Folder[] folders)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }

                List<FolderInfoHolder> newFolders = new LinkedList<FolderInfoHolder>();
                List<FolderInfoHolder> topFolders = new LinkedList<FolderInfoHolder>();

                Account.FolderMode aMode = account.getFolderDisplayMode();

                for (Folder folder : folders)
                {
                    try
                    {
                        folder.refresh(Preferences.getPreferences(getApplication().getApplicationContext()));

                        Folder.FolderClass fMode = folder.getDisplayClass();

                        if ((aMode == Account.FolderMode.FIRST_CLASS && fMode != Folder.FolderClass.FIRST_CLASS)
                                || (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
                                    fMode != Folder.FolderClass.FIRST_CLASS &&
                                    fMode != Folder.FolderClass.SECOND_CLASS)
                                || (aMode == Account.FolderMode.NOT_SECOND_CLASS && fMode == Folder.FolderClass.SECOND_CLASS))
                        {
                            continue;
                        }
                    }
                    catch (MessagingException me)
                    {
                        Log.e(K9.LOG_TAG, ""Couldn't get prefs to check for displayability of folder "" + folder.getName(), me);
                    }

                    FolderInfoHolder holder = null;

                    int folderIndex = getFolderIndex(folder.getName());
                    if (folderIndex >= 0)
                    {
                        holder = (FolderInfoHolder) getItem(folderIndex);
                    }
                    int unreadMessageCount = 0;
                    try
                    {
                        unreadMessageCount  = folder.getUnreadMessageCount();
                    }
                    catch (Exception e)
                    {
                        Log.e(K9.LOG_TAG, ""Unable to get unreadMessageCount for "" + mAccount.getDescription() + "":""
                              + folder.getName());
                    }

                    if (holder == null)
                    {
                        holder = new FolderInfoHolder(folder, unreadMessageCount);
                    }
                    else
                    {
                        holder.populate(folder, unreadMessageCount);

                    }
                    if (folder.isInTopGroup())
                    {
                        topFolders.add(holder);
                    }
                    else
                    {
                        newFolders.add(holder);
                    }
                }
                Collections.sort(newFolders);
                Collections.sort(topFolders);
                topFolders.addAll(newFolders);
                mHandler.newFolders(topFolders);
                mHandler.refreshTitle();

            }

            public void synchronizeMailboxStarted(Account account, String folder)
            {
                super.synchronizeMailboxStarted(account, folder);
                mHandler.refreshTitle();
                if (!account.equals(mAccount))
                {
                    return;
                }

                mHandler.progress(true);
                mHandler.folderLoading(folder, true);
                mHandler.dataChanged();

            }

            @Override
            public void synchronizeMailboxProgress(Account account, String folder, int completed, int total)
            {
                super.synchronizeMailboxProgress(account, folder, completed, total);
                mHandler.refreshTitle();
                if (true) return;
                if (!account.equals(mAccount))
                {
                    return;
                }
                mHandler.dataChanged();
            }

            @Override
            public void synchronizeMailboxFinished(Account account, String folder, int totalMessagesInMailbox, int numNewMessages)
            {
                super.synchronizeMailboxFinished(account, folder, totalMessagesInMailbox, numNewMessages);
                mHandler.refreshTitle();
                if (!account.equals(mAccount))
                {
                    return;
                }
                mHandler.progress(false);
                mHandler.folderLoading(folder, false);

                refreshFolder(account, folder);


            }

            private void refreshFolder(Account account, String folderName)
            {
                // There has to be a cheaper way to get at the localFolder object than this
                Folder localFolder = null;
                try
                {
                    if (account != null && folderName != null)
                    {
                        localFolder = account.getLocalStore().getFolder(folderName);
                        int unreadMessageCount = localFolder.getUnreadMessageCount();
                        if (localFolder != null)
                        {
                            FolderInfoHolder folderHolder = getFolder(folderName);
                            if (folderHolder != null)
                            {
                                folderHolder.populate(localFolder, unreadMessageCount);
                                mHandler.dataChanged();
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Exception while populating folder"", e);
                }
                finally
                {
                    if (localFolder != null)
                    {
                        localFolder.close();
                    }
                }

            }

            @Override
            public void synchronizeMailboxFailed(Account account, String folder,
                                                 String message)
            {
                super.synchronizeMailboxFailed(account, folder, message);
                mHandler.refreshTitle();
                if (!account.equals(mAccount))
                {
                    return;
                }


                mHandler.progress(false);

                mHandler.folderLoading(folder, false);

                //   String mess = truncateStatus(message);

                //   mHandler.folderStatus(folder, mess);
                FolderInfoHolder holder = getFolder(folder);

                if (holder != null)
                {
                    holder.lastChecked = 0;
                }

                mHandler.dataChanged();

            }

            @Override
            public void setPushActive(Account account, String folderName, boolean enabled)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }
                FolderInfoHolder holder = getFolder(folderName);

                if (holder != null)
                {
                    holder.pushActive = enabled;

                    mHandler.dataChanged();
                }
            }


            @Override
            public void messageDeleted(Account account,
                                       String folder, Message message)
            {
                synchronizeMailboxRemovedMessage(account,
                                                 folder, message);
            }

            @Override
            public void emptyTrashCompleted(Account account)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }
                refreshFolder(account, mAccount.getTrashFolderName());
            }

            @Override
            public void folderStatusChanged(Account account, String folderName, int unreadMessageCount)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }
                refreshFolder(account, folderName);
            }

            @Override
            public void sendPendingMessagesCompleted(Account account)
            {
                super.sendPendingMessagesCompleted(account);
                mHandler.refreshTitle();
                if (!account.equals(mAccount))
                {
                    return;
                }

                refreshFolder(account, mAccount.getOutboxFolderName());


            }

            @Override
            public void sendPendingMessagesStarted(Account account)
            {
                super.sendPendingMessagesStarted(account);
                mHandler.refreshTitle();

                if (!account.equals(mAccount))
                {
                    return;
                }

                mHandler.dataChanged();

            }

            @Override
            public void sendPendingMessagesFailed(Account account)
            {
                super.sendPendingMessagesFailed(account);
                mHandler.refreshTitle();
                if (!account.equals(mAccount))
                {
                    return;
                }

                refreshFolder(account, mAccount.getOutboxFolderName());

            }

            public void accountSizeChanged(Account account, long oldSize, long newSize)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }

                mHandler.accountSizeChanged(oldSize, newSize);

            }
            public void pendingCommandsProcessing(Account account)
            {
                super.pendingCommandsProcessing(account);
                mHandler.refreshTitle();
            }
            public void pendingCommandsFinished(Account account)
            {
                super.pendingCommandsFinished(account);
                mHandler.refreshTitle();
            }
            public void pendingCommandStarted(Account account, String commandTitle)
            {
                super.pendingCommandStarted(account, commandTitle);
                mHandler.refreshTitle();
            }
            public void pendingCommandCompleted(Account account, String commandTitle)
            {
                super.pendingCommandCompleted(account, commandTitle);
                mHandler.refreshTitle();
            }

        };


        public int getFolderIndex(String folder)
        {
            FolderInfoHolder searchHolder = new FolderInfoHolder();
            searchHolder.name = folder;
            return   mFolders.indexOf((Object) searchHolder);
        }

        public FolderInfoHolder getFolder(String folder)
        {
            FolderInfoHolder holder = null;

            int index = getFolderIndex(folder);
            if (index >= 0)
            {
                holder = (FolderInfoHolder) getItem(index);
                if (holder != null)
                {
                    return holder;
                }
            }
            return null;
        }

        public View getView(int position, View convertView, ViewGroup parent)
        {
            if (position <= getCount())
            {
                return  getItemView(position, convertView, parent);
            }
            else
            {
                // XXX TODO - should catch an exception here
                return null;
            }
        }

        public View getItemView(int itemPosition, View convertView, ViewGroup parent)
        {
            FolderInfoHolder folder = (FolderInfoHolder) getItem(itemPosition);
            View view;
            if ((convertView != null) && (convertView.getId() == R.layout.folder_list_item))
            {
                view = convertView;
            }
            else
            {
                view = mInflater.inflate(R.layout.folder_list_item, parent, false);
                view.setId(R.layout.folder_list_item);
            }


            FolderViewHolder holder = (FolderViewHolder) view.getTag();

            if (holder == null)
            {
                holder = new FolderViewHolder();
                holder.folderName = (TextView) view.findViewById(R.id.folder_name);
                holder.newMessageCount = (TextView) view.findViewById(R.id.folder_unread_message_count);
                holder.folderStatus = (TextView) view.findViewById(R.id.folder_status);
                holder.chip = view.findViewById(R.id.chip);
                holder.rawFolderName = folder.name;

                view.setTag(holder);
            }

            if (folder == null)
            {
                return view;
            }

            holder.folderName.setText(folder.displayName);
            String statusText = """";

            if (folder.loading)
            {
                String progress = false && mAdapter.mListener.getFolderTotal() > 0 ? getString(R.string.folder_progress, mAdapter.mListener.getFolderCompleted(), mAdapter.mListener.getFolderTotal()) : """";
                statusText = getString(R.string.status_loading, progress);
            }
            else if (folder.status != null)
            {
                statusText = folder.status;
            }
            else if (folder.lastChecked != 0)
            {
                Date lastCheckedDate = new Date(folder.lastChecked);

                statusText = getTimeFormat().format(lastCheckedDate) + "" ""+
                             getDateFormat().format(lastCheckedDate);
            }

            if (folder.pushActive)
            {
                statusText = getString(R.string.folder_push_active_symbol) + "" ""+ statusText;
            }

            if (statusText != null)
            {
                holder.folderStatus.setText(statusText);
                holder.folderStatus.setVisibility(View.VISIBLE);
            }
            else
            {
                holder.folderStatus.setText(null);
                holder.folderStatus.setVisibility(View.GONE);
            }

            if (folder.unreadMessageCount != 0)
            {
                holder.newMessageCount.setText(Integer
                                               .toString(folder.unreadMessageCount));
                holder.newMessageCount.setVisibility(View.VISIBLE);
            }
            else
            {
                holder.newMessageCount.setVisibility(View.GONE);
            }

            holder.chip.setBackgroundResource(K9.COLOR_CHIP_RES_IDS[mAccount.getAccountNumber() % K9.COLOR_CHIP_RES_IDS.length]);

            holder.chip.getBackground().setAlpha(folder.unreadMessageCount == 0 ? 127 : 255);

            return view;
        }

        public boolean hasStableIds()
        {
            return false;
        }

        public boolean isItemSelectable(int position)
        {
            return true;
        }

    }

    public class FolderInfoHolder implements Comparable<FolderInfoHolder>
    {
        public String name;

        public String displayName;

        public long lastChecked;

        public int unreadMessageCount;

        public boolean loading;

        public String status;

        public boolean pushActive;

        public boolean lastCheckFailed;

        /**
         * Outbox is handled differently from any other folder.
         */
        public boolean outbox;


        public boolean equals(Object o)
        {
            if (this.name.equals(((FolderInfoHolder)o).name))
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        public int compareTo(FolderInfoHolder o)
        {
            String s1 = this.name;
            String s2 = o.name;

            int ret = s1.compareToIgnoreCase(s2);
            if (ret != 0)
            {
                return ret;
            }
            else
            {
                return s1.compareTo(s2);
            }

        }

        // constructor for an empty object for comparisons
        public FolderInfoHolder()
        {
        }

        public FolderInfoHolder(Folder folder, int unreadCount)
        {
            populate(folder, unreadCount);
        }
        public void populate(Folder folder, int unreadCount)
        {

            try
            {
                folder.open(Folder.OpenMode.READ_WRITE);
                unreadCount = folder.getUnreadMessageCount();
            }
            catch (MessagingException me)
            {
                Log.e(K9.LOG_TAG, ""Folder.getUnreadMessageCount() failed"", me);
            }

            this.name = folder.getName();

            if (this.name.equalsIgnoreCase(K9.INBOX))
            {
                this.displayName = getString(R.string.special_mailbox_name_inbox);
            }
            else
            {
                this.displayName = folder.getName();
            }

            if (this.name.equals(mAccount.getOutboxFolderName()))
            {
                this.displayName = String.format(getString(R.string.special_mailbox_name_outbox_fmt), this.name);
                this.outbox = true;
            }

            if (this.name.equals(mAccount.getDraftsFolderName()))
            {
                this.displayName = String.format(getString(R.string.special_mailbox_name_drafts_fmt), this.name);
            }

            if (this.name.equals(mAccount.getTrashFolderName()))
            {
                this.displayName = String.format(getString(R.string.special_mailbox_name_trash_fmt), this.name);
            }

            if (this.name.equals(mAccount.getSentFolderName()))
            {
                this.displayName = String.format(getString(R.string.special_mailbox_name_sent_fmt), this.name);
            }

            this.lastChecked = folder.getLastUpdate();

            String mess = truncateStatus(folder.getStatus());

            this.status = mess;

            this.unreadMessageCount = unreadCount;

            folder.close();

        }
    }

    class FolderViewHolder
    {
        public TextView folderName;

        public TextView folderStatus;

        public TextView newMessageCount;

        public String rawFolderName;
        public View chip;
    }

}
",True,189,0,0,8,47,3,18,L1
24,com.fsck.k9.activity.Accounts.java,"
package com.fsck.k9.activity;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.Handler;
import android.view.*;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.View.OnClickListener;
import android.webkit.WebView;
import android.widget.*;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.AdapterView.OnItemClickListener;
import com.fsck.k9.*;
import com.fsck.k9.activity.setup.AccountSettings;
import com.fsck.k9.activity.setup.AccountSetupBasics;
import com.fsck.k9.activity.setup.Prefs;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class Accounts extends K9ListActivity implements OnItemClickListener, OnClickListener
{
    private static final int DIALOG_REMOVE_ACCOUNT = 1;
    private ConcurrentHashMap<String, Integer> unreadMessageCounts = new ConcurrentHashMap<String, Integer>();

    private ConcurrentHashMap<Account, String> pendingWork = new ConcurrentHashMap<Account, String>();

    private Account mSelectedContextAccount;
    private int mUnreadMessageCount = 0;

    private AccountsHandler mHandler = new AccountsHandler();
    private AccountsAdapter mAdapter;


    class AccountsHandler extends Handler
    {
        private void setViewTitle()
        {
            String dispString = mListener.formatHeader(Accounts.this, getString(R.string.accounts_title), mUnreadMessageCount, getTimeFormat());

            setTitle(dispString);
        }
        public void refreshTitle()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    setViewTitle();
                }
            });
        }

        public void dataChanged()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    if (mAdapter != null)
                    {
                        mAdapter.notifyDataSetChanged();
                    }
                }
            });
        }

        public void workingAccount(final Account account, final int res)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    String toastText = getString(res, account.getDescription());

                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_SHORT);
                    toast.show();
                }
            });
        }

        public void accountSizeChanged(final Account account, final long oldSize, final long newSize)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    String toastText = getString(R.string.account_size_changed, account.getDescription(),
                                                 SizeFormatter.formatSize(getApplication(), oldSize), SizeFormatter.formatSize(getApplication(), newSize));;

                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
                    toast.show();
                }
            });
        }

        public void progress(final boolean progress)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    setProgressBarIndeterminateVisibility(progress);
                }
            });
        }
        public void progress(final int progress)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    getWindow().setFeatureInt(Window.FEATURE_PROGRESS, progress);
                }
            });
        }
    }

    ActivityListener mListener = new ActivityListener()
    {
        @Override
        public void accountStatusChanged(Account account, int unreadMessageCount)
        {
            Integer oldUnreadMessageCountInteger = unreadMessageCounts.get(account.getUuid());
            int oldUnreadMessageCount = 0;
            if (oldUnreadMessageCountInteger != null)
            {
                oldUnreadMessageCount = oldUnreadMessageCountInteger;
            }

            unreadMessageCounts.put(account.getUuid(), unreadMessageCount);
            mUnreadMessageCount += unreadMessageCount - oldUnreadMessageCount;
            mHandler.dataChanged();
            pendingWork.remove(account);


            if (pendingWork.isEmpty())
            {
                mHandler.progress(Window.PROGRESS_END);
                mHandler.refreshTitle();
            }
            else
            {
                int level = (Window.PROGRESS_END / mAdapter.getCount()) * (mAdapter.getCount() - pendingWork.size()) ;
                mHandler.progress(level);
            }
        }

        @Override
        public void accountSizeChanged(Account account, long oldSize, long newSize)
        {

            mHandler.accountSizeChanged(account, oldSize, newSize);

        }

        @Override
        public void synchronizeMailboxFinished(
            Account account,
            String folder,
            int totalMessagesInMailbox,
            int numNewMessages)
        {
            super.synchronizeMailboxFinished(account, folder, totalMessagesInMailbox, numNewMessages);
            MessagingController.getInstance(getApplication()).getAccountUnreadCount(Accounts.this, account, mListener);

            mHandler.progress(false);

            mHandler.refreshTitle();
        }

        @Override
        public void synchronizeMailboxStarted(Account account, String folder)
        {
            super.synchronizeMailboxStarted(account, folder);
            mHandler.progress(true);
            mHandler.refreshTitle();
        }

        public void synchronizeMailboxProgress(Account account, String folder, int completed, int total)
        {
            super.synchronizeMailboxProgress(account, folder, completed, total);
            mHandler.refreshTitle();
        }

        @Override
        public void synchronizeMailboxFailed(Account account, String folder,
                                             String message)
        {
            super.synchronizeMailboxFailed(account, folder, message);
            mHandler.progress(false);
            mHandler.refreshTitle();

        }

        @Override
        public void sendPendingMessagesStarted(Account account)
        {
            super.sendPendingMessagesStarted(account);
            mHandler.refreshTitle();
        }

        @Override
        public void sendPendingMessagesCompleted(Account account)
        {
            super.sendPendingMessagesCompleted(account);
            mHandler.refreshTitle();
        }


        @Override
        public void sendPendingMessagesFailed(Account account)
        {
            super.sendPendingMessagesFailed(account);
            mHandler.refreshTitle();
        }

        public void pendingCommandsProcessing(Account account)
        {
            super.pendingCommandsProcessing(account);
            mHandler.refreshTitle();
        }
        public void pendingCommandsFinished(Account account)
        {
            super.pendingCommandsFinished(account);
            mHandler.refreshTitle();
        }
        public void pendingCommandStarted(Account account, String commandTitle)
        {
            super.pendingCommandStarted(account, commandTitle);
            mHandler.refreshTitle();
        }
        public void pendingCommandCompleted(Account account, String commandTitle)
        {
            super.pendingCommandCompleted(account, commandTitle);
            mHandler.refreshTitle();
        }


    };

    private static String UNREAD_MESSAGE_COUNTS = ""unreadMessageCounts"";
    private static String SELECTED_CONTEXT_ACCOUNT = ""selectedContextAccount"";

    public static final String EXTRA_STARTUP = ""startup"";


    public static void actionLaunch(Context context)
    {
        Intent intent = new Intent(context, Accounts.class);
        intent.putExtra(EXTRA_STARTUP, true);
        context.startActivity(intent);
    }

    public static void listAccounts(Context context)
    {
        Intent intent = new Intent(context, Accounts.class);
        intent.putExtra(EXTRA_STARTUP, false);
        context.startActivity(intent);
    }


    @Override
    public void onCreate(Bundle icicle)
    {
        super.onCreate(icicle);

        Account[] accounts = Preferences.getPreferences(this).getAccounts();
        Intent intent = getIntent();
        boolean startup = (boolean)intent.getBooleanExtra(EXTRA_STARTUP, true);
        if (startup && accounts.length == 1)
        {
            onOpenAccount(accounts[0]);
            finish();
        }
        else
        {
            requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
            requestWindowFeature(Window.FEATURE_PROGRESS);

            setContentView(R.layout.accounts);
            ListView listView = getListView();
            listView.setOnItemClickListener(this);
            listView.setItemsCanFocus(false);
            listView.setEmptyView(findViewById(R.id.empty));
            findViewById(R.id.next).setOnClickListener(this);
            registerForContextMenu(listView);

            if (icicle != null && icicle.containsKey(SELECTED_CONTEXT_ACCOUNT))
            {
                String accountUuid = icicle.getString(""selectedContextAccount"");
                mSelectedContextAccount = Preferences.getPreferences(this).getAccount(accountUuid);
            }

            if (icicle != null)
            {
                Map<String, Integer> oldUnreadMessageCounts = (Map<String, Integer>)icicle.get(UNREAD_MESSAGE_COUNTS);
                if (oldUnreadMessageCounts != null)
                {
                    unreadMessageCounts.putAll(oldUnreadMessageCounts);
                }
            }
        }
    }

    @Override
    public void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        if (mSelectedContextAccount != null)
        {
            outState.putString(SELECTED_CONTEXT_ACCOUNT, mSelectedContextAccount.getUuid());
        }
        outState.putSerializable(UNREAD_MESSAGE_COUNTS, unreadMessageCounts);
    }

    @Override
    public void onResume()
    {
        super.onResume();

        refresh();
        MessagingController.getInstance(getApplication()).addListener(mListener);
    }

    @Override
    public void onPause()
    {
        super.onPause();
        MessagingController.getInstance(getApplication()).removeListener(mListener);
    }

    private void refresh()
    {
        Account[] accounts = Preferences.getPreferences(this).getAccounts();
        mAdapter = new AccountsAdapter(accounts);
        getListView().setAdapter(mAdapter);
        if (accounts.length > 0)
        {
            mHandler.progress(Window.PROGRESS_START);
        }
        pendingWork.clear();
        mUnreadMessageCount = 0;
        unreadMessageCounts.clear();

        for (Account account : accounts)
        {
            pendingWork.put(account, ""true"");
            MessagingController.getInstance(getApplication()).getAccountUnreadCount(Accounts.this, account, mListener);

        }
    }

    private void onAddNewAccount()
    {
        AccountSetupBasics.actionNewAccount(this);
    }

    private void onEditAccount(Account account)
    {
        AccountSettings.actionSettings(this, account);
    }

    private void onEditPrefs()
    {
        Prefs.actionPrefs(this);
    }


    /*
     * This method is called with 'null' for the argument 'account' if
     * all accounts are to be checked. This is handled accordingly in
     * MessagingController.checkMail().
     */
    private void onCheckMail(Account account)
    {
        MessagingController.getInstance(getApplication()).checkMail(this, account, true, true, null);
    }

    private void onClearCommands(Account account)
    {
        MessagingController.getInstance(getApplication()).clearAllPending(account);
    }

    private void onEmptyTrash(Account account)
    {
        MessagingController.getInstance(getApplication()).emptyTrash(account, null);
    }


    private void onCompose()
    {
        Account defaultAccount = Preferences.getPreferences(this).getDefaultAccount();
        if (defaultAccount != null)
        {
            MessageCompose.actionCompose(this, defaultAccount);
        }
        else
        {
            onAddNewAccount();
        }
    }

    private void onOpenAccount(Account account)
    {
        if (K9.FOLDER_NONE.equals(account.getAutoExpandFolderName()))
        {
            FolderList.actionHandleAccount(this, account);
        }
        else
        {
            MessageList.actionHandleFolder(this, account, account.getAutoExpandFolderName());
        }
    }

    public void onClick(View view)
    {
        if (view.getId() == R.id.next)
        {
            onAddNewAccount();
        }
    }

    private void onDeleteAccount(Account account)
    {
        mSelectedContextAccount = account;
        showDialog(DIALOG_REMOVE_ACCOUNT);
    }

    @Override
    public Dialog onCreateDialog(int id)
    {
        switch (id)
        {
            case DIALOG_REMOVE_ACCOUNT:
                return createRemoveAccountDialog();
        }
        return super.onCreateDialog(id);
    }

    public void onPrepareDialog(int id, Dialog d)
    {
        switch (id)
        {
            case DIALOG_REMOVE_ACCOUNT:
                AlertDialog alert = (AlertDialog) d;
                alert.setMessage(getString(R.string.account_delete_dlg_instructions_fmt,
                                           mSelectedContextAccount.getDescription()));
                break;
        }

        super.onPrepareDialog(id, d);
    }


    private Dialog createRemoveAccountDialog()
    {
        return new AlertDialog.Builder(this)
               .setTitle(R.string.account_delete_dlg_title)
               .setMessage(getString(R.string.account_delete_dlg_instructions_fmt, mSelectedContextAccount.getDescription()))
               .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_REMOVE_ACCOUNT);
                try
                {
                    mSelectedContextAccount.getLocalStore().delete();
                }
                catch (Exception e)
                {
                    // Ignore
                }
                MessagingController.getInstance(getApplication()).notifyAccountCancel(Accounts.this, mSelectedContextAccount);
                Preferences.getPreferences(Accounts.this).deleteAccount(mSelectedContextAccount);
                K9.setServicesEnabled(Accounts.this);
                refresh();
            }
        })
               .setNegativeButton(R.string.cancel_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_REMOVE_ACCOUNT);
            }
        })
               .create();
    }

    public boolean onContextItemSelected(MenuItem item)
    {
        AdapterContextMenuInfo menuInfo = (AdapterContextMenuInfo)item.getMenuInfo();
        // submenus don't actually set the menuInfo, so the ""advanced""
        // submenu wouldn't work.
        if (menuInfo != null)
        {
            mSelectedContextAccount = (Account)getListView().getItemAtPosition(menuInfo.position);
        }
        switch (item.getItemId())
        {
            case R.id.delete_account:
                onDeleteAccount(mSelectedContextAccount);
                break;
            case R.id.edit_account:
                onEditAccount(mSelectedContextAccount);
                break;
            case R.id.open:
                onOpenAccount(mSelectedContextAccount);
                break;
            case R.id.check_mail:
                onCheckMail(mSelectedContextAccount);
                break;
            case R.id.clear_pending:
                onClearCommands(mSelectedContextAccount);
                break;
            case R.id.empty_trash:
                onEmptyTrash(mSelectedContextAccount);
                break;
            case R.id.compact:
                onCompact(mSelectedContextAccount);
                break;
            case R.id.clear:
                onClear(mSelectedContextAccount);
                break;
        }
        return true;
    }



    private void onCompact(Account account)
    {
        mHandler.workingAccount(account, R.string.compacting_account);
        MessagingController.getInstance(getApplication()).compact(account, null);
    }

    private void onClear(Account account)
    {
        mHandler.workingAccount(account, R.string.clearing_account);
        MessagingController.getInstance(getApplication()).clear(account, null);
    }


    public void onItemClick(AdapterView parent, View view, int position, long id)
    {
        Account account = (Account)parent.getItemAtPosition(position);
        onOpenAccount(account);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item)
    {
        switch (item.getItemId())
        {
            case R.id.add_new_account:
                onAddNewAccount();
                break;
            case R.id.edit_prefs:
                onEditPrefs();
                break;
            case R.id.check_mail:
                onCheckMail(null);
                break;
            case R.id.compose:
                onCompose();
                break;
            case R.id.about:
                onAbout();
                break;
            case R.id.search:
                onSearchRequested();
                break;
            default:
                return super.onOptionsItemSelected(item);
        }
        return true;
    }

    private void onAbout()
    {
        String appName = getString(R.string.app_name);
        WebView wv = new WebView(this);
        String html = ""<h1>"" + String.format(getString(R.string.about_title_fmt),
                                             ""<a href=\"""" + getString(R.string.app_webpage_url) + ""\"">"" + appName + ""</a>"") + ""</h1>"" +
                      ""<p>"" + appName + "" "" +
                      String.format(getString(R.string.debug_version_fmt),
                                    getVersionNumber()) + ""</p>"" +
                      ""<p>"" + String.format(getString(R.string.app_authors_fmt),
                                            getString(R.string.app_authors)) + ""</p>"" +
                      ""<p>"" + String.format(getString(R.string.app_revision_fmt),
                                            ""<a href=\"""" + getString(R.string.app_revision_url) + ""\"">"" +
                                            getString(R.string.app_revision_url) + ""</a></p>"");
        wv.loadData(html, ""text/html"", ""utf-8"");
        new AlertDialog.Builder(this)
        .setView(wv)
        .setCancelable(true)
        .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface d, int c)
            {
                d.dismiss();
            }
        })
        .show();
    }

    /**
     * Get current version number.
     *
     * @return String version
     */
    private String getVersionNumber()
    {
        String version = ""?"";
        try
        {
            PackageInfo pi = getPackageManager().getPackageInfo(getPackageName(), 0);
            version = pi.versionName;
        }
        catch (PackageManager.NameNotFoundException e)
        {
            //Log.e(TAG, ""Package name not found"", e);
        };
        return version;
    }

    public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id)
    {
        return true;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu)
    {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.accounts_option, menu);
        return true;
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)
    {
        super.onCreateContextMenu(menu, v, menuInfo);
        menu.setHeaderTitle(R.string.accounts_context_menu_title);
        getMenuInflater().inflate(R.menu.accounts_context, menu);
    }

    class AccountsAdapter extends ArrayAdapter<Account>
    {
        public AccountsAdapter(Account[] accounts)
        {
            super(Accounts.this, 0, accounts);
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent)
        {
            Account account = getItem(position);
            View view;
            if (convertView != null)
            {
                view = convertView;
            }
            else
            {
                view = getLayoutInflater().inflate(R.layout.accounts_item, parent, false);
            }
            AccountViewHolder holder = (AccountViewHolder) view.getTag();
            if (holder == null)
            {
                holder = new AccountViewHolder();
                holder.description = (TextView) view.findViewById(R.id.description);
                holder.email = (TextView) view.findViewById(R.id.email);
                holder.newMessageCount = (TextView) view.findViewById(R.id.new_message_count);

                holder.chip = view.findViewById(R.id.chip);

                view.setTag(holder);
            }
            holder.description.setText(account.getDescription());
            holder.email.setText(account.getEmail());
            if (account.getEmail().equals(account.getDescription()))
            {
                holder.email.setVisibility(View.GONE);
            }

            Integer unreadMessageCount = unreadMessageCounts.get(account.getUuid());
            if (unreadMessageCount != null)
            {
                holder.newMessageCount.setText(Integer.toString(unreadMessageCount));
                holder.newMessageCount.setVisibility(unreadMessageCount > 0 ? View.VISIBLE : View.GONE);
            }
            else
            {
                //holder.newMessageCount.setText(""-"");
                holder.newMessageCount.setVisibility(View.GONE);
            }
            holder.chip.setBackgroundResource(K9.COLOR_CHIP_RES_IDS[account.getAccountNumber() % K9.COLOR_CHIP_RES_IDS.length]);

            if (unreadMessageCount == null)
            {
                holder.chip.getBackground().setAlpha(0);
            }
            else if (unreadMessageCount == 0)
            {
                holder.chip.getBackground().setAlpha(127);
            }
            else
            {
                holder.chip.getBackground().setAlpha(255);
            }


            return view;
        }

        class AccountViewHolder
        {
            public TextView description;
            public TextView email;
            public TextView newMessageCount;
            public View chip;
        }
    }
}
",True,189,0,0,8,51,2,14,L1
25,com.fsck.k9.activity.Search.java,"package com.fsck.k9.activity;
import com.fsck.k9.activity.MessageList;


public class Search extends MessageList
{

};
",False,190,0,0,9,54,0,1,L4
26,com.fsck.k9.activity.ChooseIdentity.java,"
package com.fsck.k9.activity;

import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.view.View;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.Toast;
import com.fsck.k9.Account;
import com.fsck.k9.Identity;
import com.fsck.k9.K9ListActivity;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import java.util.List;

public class ChooseIdentity extends K9ListActivity
{
    Account mAccount;
    String mUID;
    ArrayAdapter<String> adapter;
    private ChooseIdentityHandler mHandler = new ChooseIdentityHandler();

    public static final String EXTRA_ACCOUNT = ""com.fsck.k9.ChooseIdentity_account"";
    public static final String EXTRA_IDENTITY = ""com.fsck.k9.ChooseIdentity_identity"";

    protected List<Identity> identities = null;

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);

        getListView().setTextFilterEnabled(true);
        getListView().setItemsCanFocus(false);
        getListView().setChoiceMode(ListView.CHOICE_MODE_NONE);
        Intent intent = getIntent();
        String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1);

        setListAdapter(adapter);
        setupClickListeners();
    }


    @Override
    public void onResume()
    {
        super.onResume();
        refreshView();
    }


    protected void refreshView()
    {
        adapter.clear();

        identities = mAccount.getIdentities();
        for (Identity identity : identities)
        {
            String email = identity.getEmail();
            String description = identity.getDescription();
            if (description == null || description.trim().length() == 0)
            {
                description = getString(R.string.message_view_from_format, identity.getName(), identity.getEmail());
            }
            adapter.add(description);
        }

    }

    protected void setupClickListeners()
    {
        this.getListView().setOnItemClickListener(new AdapterView.OnItemClickListener()
        {
            public void onItemClick(AdapterView adapterview, View view, int i, long l)
            {
                Identity identity = mAccount.getIdentity(i);
                String email = identity.getEmail();
                if (email != null && email.trim().equals("""") == false)
                {
                    Intent intent = new Intent();

                    intent.putExtra(EXTRA_IDENTITY, mAccount.getIdentity(i));
                    setResult(RESULT_OK, intent);
                    finish();
                }
                else
                {
                    Toast.makeText(ChooseIdentity.this, getString(R.string.identity_has_no_email),
                                   Toast.LENGTH_LONG).show();
                }
            }
        });

    }

    class ChooseIdentityHandler extends Handler
    {

        private static final int MSG_PROGRESS = 2;
        private static final int MSG_DATA_CHANGED = 3;

        public void handleMessage(android.os.Message msg)
        {
            switch (msg.what)
            {
                case MSG_PROGRESS:
                    setProgressBarIndeterminateVisibility(msg.arg1 != 0);
                    break;
                case MSG_DATA_CHANGED:
                    adapter.notifyDataSetChanged();
                    break;
            }
        }

        public void progress(boolean progress)
        {
            android.os.Message msg = new android.os.Message();
            msg.what = MSG_PROGRESS;
            msg.arg1 = progress ? 1 : 0;
            sendMessage(msg);
        }

        public void dataChanged()
        {
            sendEmptyMessage(MSG_DATA_CHANGED);
        }
    }

}
",False,189,0,0,8,47,3,4,L1
27,com.fsck.k9.activity.DateFormatter.java,"package com.fsck.k9.activity;

import android.content.Context;
import android.content.SharedPreferences.Editor;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Map;

public class DateFormatter
{
    private DateFormatter()
    {
    }
    private final static Calendar SAMPLE_DATE = Calendar.getInstance();
    static
    {
        SAMPLE_DATE.set(SAMPLE_DATE.get(Calendar.YEAR), SAMPLE_DATE.getActualMaximum(Calendar.MONTH), SAMPLE_DATE.getActualMaximum(Calendar.DAY_OF_MONTH));
    }

    public static final String SHORT_FORMAT = ""SHORT"";
    public static final String MEDIUM_FORMAT = ""MEDIUM"";
    public static final String DEFAULT_FORMAT = SHORT_FORMAT;

    public static final String PREF_KEY = ""dateFormat"";

    private static volatile String sChosenFormat = null;

    public static String getSampleDate(Context context, String formatString)
    {
        java.text.DateFormat formatter = getDateFormat(context, formatString);
        return formatter.format(SAMPLE_DATE.getTime());
    }

    public static String[] getFormats(Context context)
    {
        return context.getResources().getStringArray(R.array.date_formats);
    }

    private static ThreadLocal<Map<String, DateFormat>> storedFormats = new ThreadLocal<Map<String, DateFormat>>()
    {
        @Override
        public synchronized Map<String, DateFormat> initialValue()
        {
            return new HashMap<String, DateFormat>();
        }
    };

    public static DateFormat getDateFormat(Context context, String formatString)
    {
        java.text.DateFormat dateFormat;

        if (SHORT_FORMAT.equals(formatString))
        {
            dateFormat = android.text.format.DateFormat.getDateFormat(context);
        }
        else if (MEDIUM_FORMAT.equals(formatString))
        {
            dateFormat = android.text.format.DateFormat.getMediumDateFormat(context);
        }
        else
        {
            Map<String, DateFormat> formatMap = storedFormats.get();
            dateFormat = formatMap.get(formatString);

            if (dateFormat == null)
            {
                dateFormat = new SimpleDateFormat(formatString);
                formatMap.put(formatString, dateFormat);
            }
        }
        return dateFormat;
    }

    public static void setDateFormat(Editor editor, String formatString)
    {
        sChosenFormat = formatString;
        editor.putString(PREF_KEY, formatString);
    }

    public static String getFormat(Context context)
    {
        if (sChosenFormat == null)
        {
            Preferences prefs = Preferences.getPreferences(context);
            String chosenFormat = prefs.getPreferences().getString(PREF_KEY, DEFAULT_FORMAT);

            sChosenFormat = chosenFormat;
        }
        return sChosenFormat;
    }

    public static DateFormat getDateFormat(Context context)
    {
        String formatString = getFormat(context);
        return getDateFormat(context, formatString);
    }
}
",True,189,0,0,9,46,3,1,L1
28,com.fsck.k9.activity.ManageIdentities.java,"package com.fsck.k9.activity;

import android.content.Intent;
import android.view.*;
import android.view.ContextMenu.ContextMenuInfo;
import android.widget.AdapterView;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.ListView;
import android.widget.Toast;
import com.fsck.k9.Identity;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;

public class ManageIdentities extends ChooseIdentity
{
    private boolean mIdentitiesChanged = false;
    public static final String EXTRA_IDENTITIES = ""com.fsck.k9.EditIdentity_identities"";

    private static final int ACTIVITY_EDIT_IDENTITY = 1;
    protected void setupClickListeners()
    {
        this.getListView().setOnItemClickListener(new AdapterView.OnItemClickListener()
        {
            public void onItemClick(AdapterView adapterview, View view, int i, long l)
            {
                editItem(i);
            }
        });

        ListView listView = getListView();
        registerForContextMenu(listView);
    }

    private void editItem(int i)
    {
        Intent intent = new Intent(ManageIdentities.this, EditIdentity.class);
        intent.putExtra(EditIdentity.EXTRA_ACCOUNT, mAccount.getUuid());
        intent.putExtra(EditIdentity.EXTRA_IDENTITY, mAccount.getIdentity(i));
        intent.putExtra(EditIdentity.EXTRA_IDENTITY_INDEX, i);
        startActivityForResult(intent, ACTIVITY_EDIT_IDENTITY);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu)
    {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.manage_identities_option, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item)
    {
        switch (item.getItemId())
        {
            case R.id.new_identity:
                Intent intent = new Intent(ManageIdentities.this, EditIdentity.class);
                intent.putExtra(EditIdentity.EXTRA_ACCOUNT, mAccount.getUuid());
                startActivityForResult(intent, ACTIVITY_EDIT_IDENTITY);
                break;
            default:
                return super.onOptionsItemSelected(item);
        }
        return true;
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)
    {
        super.onCreateContextMenu(menu, v, menuInfo);
        menu.setHeaderTitle(R.string.manage_identities_context_menu_title);
        getMenuInflater().inflate(R.menu.manage_identities_context, menu);
    }

    public boolean onContextItemSelected(MenuItem item)
    {
        AdapterContextMenuInfo menuInfo = (AdapterContextMenuInfo)item.getMenuInfo();
        switch (item.getItemId())
        {
            case R.id.edit:
                editItem(menuInfo.position);
                break;
            case R.id.up:
                if (menuInfo.position > 0)
                {
                    Identity identity = identities.remove(menuInfo.position);
                    identities.add(menuInfo.position - 1, identity);
                    mIdentitiesChanged = true;
                    refreshView();
                }

                break;
            case R.id.down:
                if (menuInfo.position < identities.size() - 1)
                {
                    Identity identity = identities.remove(menuInfo.position);
                    identities.add(menuInfo.position + 1, identity);
                    mIdentitiesChanged = true;
                    refreshView();
                }
                break;
            case R.id.top:
                Identity identity = identities.remove(menuInfo.position);
                identities.add(0, identity);
                mIdentitiesChanged = true;
                refreshView();
                break;
            case R.id.remove:
                if (identities.size() > 1)
                {
                    identities.remove(menuInfo.position);
                    mIdentitiesChanged = true;
                    refreshView();
                }
                else
                {
                    Toast.makeText(this, getString(R.string.no_removable_identity),
                                   Toast.LENGTH_LONG).show();
                }
                break;
        }
        return true;
    }


    @Override
    public void onResume()
    {
        super.onResume();
        //mAccount.refresh(Preferences.getPreferences(getApplication().getApplicationContext()));
        refreshView();
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (keyCode == KeyEvent.KEYCODE_BACK)
        {
            saveIdentities();
        }
        return super.onKeyDown(keyCode, event);
    }

    private void saveIdentities()
    {
        if (mIdentitiesChanged)
        {
            mAccount.setIdentities(identities);
            mAccount.save(Preferences.getPreferences(getApplication().getApplicationContext()));
        }
        finish();
    }
}
",False,189,0,0,8,47,1,5,L1
29,com.fsck.k9.activity.EditIdentity.java,"package com.fsck.k9.activity;

import android.os.Bundle;
import android.view.KeyEvent;
import android.view.View;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.EditText;
import android.widget.LinearLayout;
import com.fsck.k9.Account;
import com.fsck.k9.Identity;
import com.fsck.k9.K9Activity;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import java.util.List;

public class EditIdentity extends K9Activity
{

    public static final String EXTRA_IDENTITY = ""com.fsck.k9.EditIdentity_identity"";
    public static final String EXTRA_IDENTITY_INDEX = ""com.fsck.k9.EditIdentity_identity_index"";
    public static final String EXTRA_ACCOUNT = ""com.fsck.k9.EditIdentity_account"";

    private Account mAccount;
    private Identity mIdentity;
    private int mIdentityIndex;
    private EditText mDescriptionView;
    private CheckBox mSignatureUse;
    private EditText mSignatureView;
    private LinearLayout mSignatureLayout;
    private EditText mEmailView;
//  private EditText mAlwaysBccView;
    private EditText mNameView;

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        mIdentity = (Identity)getIntent().getSerializableExtra(EXTRA_IDENTITY);
        mIdentityIndex = getIntent().getIntExtra(EXTRA_IDENTITY_INDEX, -1);
        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        if (mIdentityIndex == -1)
        {
            mIdentity = new Identity();
        }

        setContentView(R.layout.edit_identity);

        /*
         * If we're being reloaded we override the original account with the one
         * we saved
         */
        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_IDENTITY))
        {
            mIdentity = (Identity)savedInstanceState.getSerializable(EXTRA_IDENTITY);
        }

        mDescriptionView = (EditText)findViewById(R.id.description);
        mDescriptionView.setText(mIdentity.getDescription());

        mNameView = (EditText)findViewById(R.id.name);
        mNameView.setText(mIdentity.getName());

        mEmailView = (EditText)findViewById(R.id.email);
        mEmailView.setText(mIdentity.getEmail());

//      mAccountAlwaysBcc = (EditText)findViewById(R.id.bcc);
//      mAccountAlwaysBcc.setText(mIdentity.getAlwaysBcc());

        mSignatureLayout = (LinearLayout)findViewById(R.id.signature_layout);
        mSignatureUse = (CheckBox)findViewById(R.id.signature_use);
        mSignatureView = (EditText)findViewById(R.id.signature);
        mSignatureUse.setChecked(mIdentity.getSignatureUse());
        mSignatureUse.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
            {
                if (isChecked)
                {
                    mSignatureLayout.setVisibility(View.VISIBLE);
                    mSignatureView.setText(mIdentity.getSignature());
                }
                else
                {
                    mSignatureLayout.setVisibility(View.GONE);
                }
            }
        });

        if (mSignatureUse.isChecked())
        {
            mSignatureView.setText(mIdentity.getSignature());
        }
        else
        {
            mSignatureLayout.setVisibility(View.GONE);
        }
    }

    @Override
    public void onResume()
    {
        super.onResume();
    }

    private void saveIdentity()
    {

        mIdentity.setDescription(mDescriptionView.getText().toString());
        mIdentity.setEmail(mEmailView.getText().toString());
        //      mIdentity.setAlwaysBcc(mAccountAlwaysBcc.getText().toString());
        mIdentity.setName(mNameView.getText().toString());
        mIdentity.setSignatureUse(mSignatureUse.isChecked());
        mIdentity.setSignature(mSignatureView.getText().toString());

        List<Identity> identities = mAccount.getIdentities();
        if (mIdentityIndex == -1)
        {
            identities.add(mIdentity);
        }
        else
        {
            identities.remove(mIdentityIndex);
            identities.add(mIdentityIndex, mIdentity);
        }

        mAccount.save(Preferences.getPreferences(getApplication().getApplicationContext()));

        finish();
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (keyCode == KeyEvent.KEYCODE_BACK)
        {
            saveIdentity();
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        outState.putSerializable(EXTRA_IDENTITY, mIdentity);
    }
}
",False,189,0,0,8,48,1,4,L1
30,com.fsck.k9.activity.MessageCompose.java,"
package com.fsck.k9.activity;

import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Parcelable;
import android.provider.OpenableColumns;
import android.text.TextWatcher;
import android.text.util.Rfc822Tokenizer;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnFocusChangeListener;
import android.view.Window;
import android.widget.AutoCompleteTextView.Validator;
import android.widget.*;
import com.fsck.k9.*;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.internet.*;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalAttachmentBody;
import java.io.File;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.StringTokenizer;

public class MessageCompose extends K9Activity implements OnClickListener, OnFocusChangeListener
{
    private static final String ACTION_REPLY = ""com.fsck.k9.intent.action.REPLY"";
    private static final String ACTION_REPLY_ALL = ""com.fsck.k9.intent.action.REPLY_ALL"";
    private static final String ACTION_FORWARD = ""com.fsck.k9.intent.action.FORWARD"";
    private static final String ACTION_EDIT_DRAFT = ""com.fsck.k9.intent.action.EDIT_DRAFT"";


    private static final String EXTRA_ACCOUNT = ""account"";
    private static final String EXTRA_FOLDER = ""folder"";
    private static final String EXTRA_MESSAGE = ""message"";

    private static final String STATE_KEY_ATTACHMENTS =
        ""com.fsck.k9.activity.MessageCompose.attachments"";
    private static final String STATE_KEY_CC_SHOWN =
        ""com.fsck.k9.activity.MessageCompose.ccShown"";
    private static final String STATE_KEY_BCC_SHOWN =
        ""com.fsck.k9.activity.MessageCompose.bccShown"";
    private static final String STATE_KEY_QUOTED_TEXT_SHOWN =
        ""com.fsck.k9.activity.MessageCompose.quotedTextShown"";
    private static final String STATE_KEY_SOURCE_MESSAGE_PROCED =
        ""com.fsck.k9.activity.MessageCompose.stateKeySourceMessageProced"";
    private static final String STATE_KEY_DRAFT_UID =
        ""com.fsck.k9.activity.MessageCompose.draftUid"";
    private static final String STATE_IDENTITY_CHANGED =
        ""com.fsck.k9.activity.MessageCompose.identityChanged"";
    private static final String STATE_IDENTITY =
        ""com.fsck.k9.activity.MessageCompose.identity"";

    private static final int MSG_PROGRESS_ON = 1;
    private static final int MSG_PROGRESS_OFF = 2;
    private static final int MSG_UPDATE_TITLE = 3;
    private static final int MSG_SKIPPED_ATTACHMENTS = 4;
    private static final int MSG_SAVED_DRAFT = 5;
    private static final int MSG_DISCARDED_DRAFT = 6;

    private static final int ACTIVITY_REQUEST_PICK_ATTACHMENT = 1;
    private static final int ACTIVITY_CHOOSE_IDENTITY = 2;

    private Account mAccount;
    private Identity mIdentity;
    private boolean mIdentityChanged = false;
    private boolean mSignatureChanged = false;
    private String mFolder;
    private String mSourceMessageUid;
    private Message mSourceMessage;
    /**
     * Indicates that the source message has been processed at least once and should not
     * be processed on any subsequent loads. This protects us from adding attachments that
     * have already been added from the restore of the view state.
     */
    private boolean mSourceMessageProcessed = false;


    private TextView mFromView;
    private MultiAutoCompleteTextView mToView;
    private MultiAutoCompleteTextView mCcView;
    private MultiAutoCompleteTextView mBccView;
    private EditText mSubjectView;
    private EditText mSignatureView;
    private EditText mMessageContentView;
    private LinearLayout mAttachments;
    private View mQuotedTextBar;
    private ImageButton mQuotedTextDelete;
    private EditText mQuotedText;

    private String mReferences;
    private String mInReplyTo;

    private boolean mDraftNeedsSaving = false;

    /**
     * The draft uid of this message. This is used when saving drafts so that the same draft is
     * overwritten instead of being created anew. This property is null until the first save.
     */
    private String mDraftUid;

    private Handler mHandler = new Handler()
    {
        @Override
        public void handleMessage(android.os.Message msg)
        {
            switch (msg.what)
            {
                case MSG_PROGRESS_ON:
                    setProgressBarIndeterminateVisibility(true);
                    break;
                case MSG_PROGRESS_OFF:
                    setProgressBarIndeterminateVisibility(false);
                    break;
                case MSG_UPDATE_TITLE:
                    updateTitle();
                    break;
                case MSG_SKIPPED_ATTACHMENTS:
                    Toast.makeText(
                        MessageCompose.this,
                        getString(R.string.message_compose_attachments_skipped_toast),
                        Toast.LENGTH_LONG).show();
                    break;
                case MSG_SAVED_DRAFT:
                    Toast.makeText(
                        MessageCompose.this,
                        getString(R.string.message_saved_toast),
                        Toast.LENGTH_LONG).show();
                    break;
                case MSG_DISCARDED_DRAFT:
                    Toast.makeText(
                        MessageCompose.this,
                        getString(R.string.message_discarded_toast),
                        Toast.LENGTH_LONG).show();
                    break;
                default:
                    super.handleMessage(msg);
                    break;
            }
        }
    };

    private Listener mListener = new Listener();
    private EmailAddressAdapter mAddressAdapter;
    private Validator mAddressValidator;


    class Attachment implements Serializable
    {
        public String name;
        public String contentType;
        public long size;
        public Uri uri;
    }

    /**
     * Compose a new message using the given account. If account is null the default account
     * will be used.
     * @param context
     * @param account
     */
    public static void actionCompose(Context context, Account account)
    {
        Intent i = new Intent(context, MessageCompose.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    /**
     * Compose a new message as a reply to the given message. If replyAll is true the function
     * is reply all instead of simply reply.
     * @param context
     * @param account
     * @param message
     * @param replyAll
     */
    public static void actionReply(
        Context context,
        Account account,
        Message message,
        boolean replyAll)
    {
        Intent i = new Intent(context, MessageCompose.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_FOLDER, message.getFolder().getName());
        i.putExtra(EXTRA_MESSAGE, message.getUid());
        if (replyAll)
        {
            i.setAction(ACTION_REPLY_ALL);
        }
        else
        {
            i.setAction(ACTION_REPLY);
        }
        context.startActivity(i);
    }

    /**
     * Compose a new message as a forward of the given message.
     * @param context
     * @param account
     * @param message
     */
    public static void actionForward(Context context, Account account, Message message)
    {
        Intent i = new Intent(context, MessageCompose.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_FOLDER, message.getFolder().getName());
        i.putExtra(EXTRA_MESSAGE, message.getUid());
        i.setAction(ACTION_FORWARD);
        context.startActivity(i);
    }

    /**
     * Continue composition of the given message. This action modifies the way this Activity
     * handles certain actions.
     * Save will attempt to replace the message in the given folder with the updated version.
     * Discard will delete the message from the given folder.
     * @param context
     * @param account
     * @param folder
     * @param message
     */
    public static void actionEditDraft(Context context, Account account, Message message)
    {
        Intent i = new Intent(context, MessageCompose.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_FOLDER, message.getFolder().getName());
        i.putExtra(EXTRA_MESSAGE, message.getUid());
        i.setAction(ACTION_EDIT_DRAFT);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);

        setContentView(R.layout.message_compose);

        Intent intent = getIntent();
        String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        if (mAccount == null)
        {
            mAccount = Preferences.getPreferences(this).getDefaultAccount();
        }
        if (mAccount == null)
        {
            /*
             * There are no accounts set up. This should not have happened. Prompt the
             * user to set up an account as an acceptable bailout.
             */
            startActivity(new Intent(this, Accounts.class));
            mDraftNeedsSaving = false;
            finish();
            return;
        }


        mAddressAdapter = EmailAddressAdapter.getInstance(this);
        mAddressValidator = new EmailAddressValidator();

        mFromView = (TextView)findViewById(R.id.from);
        mToView = (MultiAutoCompleteTextView)findViewById(R.id.to);
        mCcView = (MultiAutoCompleteTextView)findViewById(R.id.cc);
        mBccView = (MultiAutoCompleteTextView)findViewById(R.id.bcc);
        mSubjectView = (EditText)findViewById(R.id.subject);

        EditText upperSignature = (EditText)findViewById(R.id.upper_signature);
        EditText lowerSignature = (EditText)findViewById(R.id.lower_signature);

        mMessageContentView = (EditText)findViewById(R.id.message_content);
        mAttachments = (LinearLayout)findViewById(R.id.attachments);
        mQuotedTextBar = findViewById(R.id.quoted_text_bar);
        mQuotedTextDelete = (ImageButton)findViewById(R.id.quoted_text_delete);
        mQuotedText = (EditText)findViewById(R.id.quoted_text);

        TextWatcher watcher = new TextWatcher()
        {
            public void beforeTextChanged(CharSequence s, int start,
            int before, int after) { }

            public void onTextChanged(CharSequence s, int start,
                                      int before, int count)
            {
                mDraftNeedsSaving = true;
            }

            public void afterTextChanged(android.text.Editable s) { }
        };

        TextWatcher sigwatcher = new TextWatcher()
        {
            public void beforeTextChanged(CharSequence s, int start,
            int before, int after) { }

            public void onTextChanged(CharSequence s, int start,
                                      int before, int count)
            {
                mDraftNeedsSaving = true;
                mSignatureChanged = true;
            }

            public void afterTextChanged(android.text.Editable s) { }
        };

        mToView.addTextChangedListener(watcher);
        mCcView.addTextChangedListener(watcher);
        mBccView.addTextChangedListener(watcher);
        mSubjectView.addTextChangedListener(watcher);

        mMessageContentView.addTextChangedListener(watcher);
        mQuotedText.addTextChangedListener(watcher);

        /*
         * We set this to invisible by default. Other methods will turn it back on if it's
         * needed.
         */
        mQuotedTextBar.setVisibility(View.GONE);
        mQuotedText.setVisibility(View.GONE);

        mQuotedTextDelete.setOnClickListener(this);

        mFromView.setVisibility(View.GONE);

        mToView.setAdapter(mAddressAdapter);
        mToView.setTokenizer(new Rfc822Tokenizer());
        mToView.setValidator(mAddressValidator);

        mCcView.setAdapter(mAddressAdapter);
        mCcView.setTokenizer(new Rfc822Tokenizer());
        mCcView.setValidator(mAddressValidator);

        mBccView.setAdapter(mAddressAdapter);
        mBccView.setTokenizer(new Rfc822Tokenizer());
        mBccView.setValidator(mAddressValidator);


        mSubjectView.setOnFocusChangeListener(this);

        if (savedInstanceState != null)
        {
            /*
             * This data gets used in onCreate, so grab it here instead of onRestoreIntstanceState
             */
            mSourceMessageProcessed = savedInstanceState.getBoolean(STATE_KEY_SOURCE_MESSAGE_PROCED, false);
        }


        String action = intent.getAction();

        if (Intent.ACTION_VIEW.equals(action) || Intent.ACTION_SENDTO.equals(action))
        {
            /*
             * Someone has clicked a mailto: link. The address is in the URI.
             */
            if (intent.getData() != null)
            {
                Uri uri = intent.getData();
                if (""mailto"".equals(uri.getScheme()))
                {
                    initializeFromMailTo(uri.toString());
                } 
                else
                {
                    String toText = uri.getSchemeSpecificPart();
                    if (toText != null)
                    {
                        mToView.setText(toText);
                    }
                }
            }
        }
        //TODO: Use constant Intent.ACTION_SEND_MULTIPLE once we drop Android 1.5 support
        else if (Intent.ACTION_SEND.equals(action) || ""android.intent.action.SEND_MULTIPLE"".equals(action))
        {
            /*
             * Someone is trying to compose an email with an attachment, probably Pictures.
             * The Intent should contain an EXTRA_STREAM with the data to attach.
             */

            String text = intent.getStringExtra(Intent.EXTRA_TEXT);
            if (text != null)
            {
                mMessageContentView.setText(text);
            }
            String subject = intent.getStringExtra(Intent.EXTRA_SUBJECT);
            if (subject != null)
            {
                mSubjectView.setText(subject);
            }

            String type = intent.getType();
            //TODO: Use constant Intent.ACTION_SEND_MULTIPLE once we drop Android 1.5 support
            if (""android.intent.action.SEND_MULTIPLE"".equals(action))
            {
                ArrayList<Parcelable> list = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
                if (list != null)
                {
                    for (Parcelable parcelable : list)
                    {
                        Uri stream = (Uri) parcelable;
                        if (stream != null && type != null)
                        {
                            if (MimeUtility.mimeTypeMatches(type, K9.ACCEPTABLE_ATTACHMENT_SEND_TYPES))
                            {
                                addAttachment(stream);
                            }
                        }
                    }
                }
            }
            else
            {
                Uri stream = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);
                if (stream != null && type != null)
                {
                    if (MimeUtility.mimeTypeMatches(type, K9.ACCEPTABLE_ATTACHMENT_SEND_TYPES))
                    {
                        addAttachment(stream);
                    }
                }
            }

            /*
             * There might be an EXTRA_SUBJECT, EXTRA_TEXT, EXTRA_EMAIL, EXTRA_BCC or EXTRA_CC
             */

            String extraSubject = intent.getStringExtra(Intent.EXTRA_SUBJECT);
            String extraText = intent.getStringExtra(Intent.EXTRA_TEXT);

            mSubjectView.setText(extraSubject);
            mMessageContentView.setText(extraText);

            String[] extraEmail = intent.getStringArrayExtra(Intent.EXTRA_EMAIL);
            String[] extraCc = intent.getStringArrayExtra(Intent.EXTRA_CC);
            String[] extraBcc = intent.getStringArrayExtra(Intent.EXTRA_BCC);

            String addressList;
            // Cache array size, as per Google's recommendations.
            int arraySize;
            int i;

            addressList = """";
            if (extraEmail != null)
            {
                arraySize = extraEmail.length;
                for (i=0; i < arraySize; i++)
                {
                    addressList += extraEmail[i]+"", "";
                }
            }
            mToView.setText(addressList);

            addressList = """";
            if (extraCc != null)
            {
                arraySize = extraCc.length;
                for (i=0; i < arraySize; i++)
                {
                    addressList += extraCc[i]+"", "";
                }
            }
            mCcView.setText(addressList);

            addressList = """";
            if (extraBcc != null)
            {
                arraySize = extraBcc.length;
                for (i=0; i < arraySize; i++)
                {
                    addressList += extraBcc[i]+"", "";
                }
            }
            mBccView.setText(addressList);

        }
        else
        {
            mFolder = (String) intent.getStringExtra(EXTRA_FOLDER);
            mSourceMessageUid = (String) intent.getStringExtra(EXTRA_MESSAGE);
        }

        if (mIdentity == null)
        {
            mIdentity = mAccount.getIdentity(0);
        }

        if (mAccount.isSignatureBeforeQuotedText())
        {
            mSignatureView = upperSignature;
            lowerSignature.setVisibility(View.GONE);
        }
        else
        {
            mSignatureView = lowerSignature;
            upperSignature.setVisibility(View.GONE);
        }
        mSignatureView.addTextChangedListener(sigwatcher);

        if (!mIdentity.getSignatureUse())
        {
            mSignatureView.setVisibility(View.GONE);
        }

        if (!mSourceMessageProcessed)
        {
            updateFrom();
            updateSignature();

            if (ACTION_REPLY.equals(action) || ACTION_REPLY_ALL.equals(action) || ACTION_FORWARD.equals(action) || ACTION_EDIT_DRAFT.equals(action))
            {
                /*
                 * If we need to load the message we add ourself as a message listener here
                 * so we can kick it off. Normally we add in onResume but we don't
                 * want to reload the message every time the activity is resumed.
                 * There is no harm in adding twice.
                 */
                MessagingController.getInstance(getApplication()).addListener(mListener);
                MessagingController.getInstance(getApplication()).loadMessageForView(mAccount, mFolder, mSourceMessageUid, null);
            }

            if (!ACTION_EDIT_DRAFT.equals(action))
            {
                String bccAddress = mAccount.getAlwaysBcc();
                if (bccAddress!=null
                        && !"""".equals(bccAddress))
                {
                    addAddress(mBccView, new Address(mAccount.getAlwaysBcc(), """"));
                }
            }

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""action = "" + action + "", mAccount = "" + mAccount + "", mFolder = "" + mFolder + "", mSourceMessageUid = "" + mSourceMessageUid);
            if ((ACTION_REPLY.equals(action) || ACTION_REPLY_ALL.equals(action)) && mAccount != null && mFolder != null && mSourceMessageUid != null)
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Setting message ANSWERED flag to true"");
                // TODO: Really, we should wait until we send the message, but that would require saving the original
                // message info along with a Draft copy, in case it is left in Drafts for a while before being sent
                MessagingController.getInstance(getApplication()).setFlag(mAccount, mFolder, new String[] { mSourceMessageUid }, Flag.ANSWERED, true);
            }

            updateTitle();
        }

        if (ACTION_REPLY.equals(action) || ACTION_REPLY_ALL.equals(action) || ACTION_EDIT_DRAFT.equals(action))
        {
            //change focus to message body.
            mMessageContentView.requestFocus();
        }

        mDraftNeedsSaving = false;
    }

    public void onResume()
    {
        super.onResume();
        MessagingController.getInstance(getApplication()).addListener(mListener);
    }

    public void onPause()
    {
        super.onPause();
        saveIfNeeded();
        MessagingController.getInstance(getApplication()).removeListener(mListener);
    }

    /**
     * The framework handles most of the fields, but we need to handle stuff that we
     * dynamically show and hide:
     * Attachment list,
     * Cc field,
     * Bcc field,
     * Quoted text,
     */
    @Override
    protected void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        saveIfNeeded();
        ArrayList<Uri> attachments = new ArrayList<Uri>();
        for (int i = 0, count = mAttachments.getChildCount(); i < count; i++)
        {
            View view = mAttachments.getChildAt(i);
            Attachment attachment = (Attachment) view.getTag();
            attachments.add(attachment.uri);
        }
        outState.putParcelableArrayList(STATE_KEY_ATTACHMENTS, attachments);
        outState.putBoolean(STATE_KEY_CC_SHOWN, mCcView.getVisibility() == View.VISIBLE);
        outState.putBoolean(STATE_KEY_BCC_SHOWN, mBccView.getVisibility() == View.VISIBLE);
        outState.putBoolean(STATE_KEY_QUOTED_TEXT_SHOWN, mQuotedTextBar.getVisibility() == View.VISIBLE);
        outState.putBoolean(STATE_KEY_SOURCE_MESSAGE_PROCED, mSourceMessageProcessed);
        outState.putString(STATE_KEY_DRAFT_UID, mDraftUid);
        outState.putSerializable(STATE_IDENTITY, mIdentity);
        outState.putBoolean(STATE_IDENTITY_CHANGED, mIdentityChanged);
    }

    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState)
    {
        super.onRestoreInstanceState(savedInstanceState);
        ArrayList<Parcelable> attachments = (ArrayList<Parcelable>) savedInstanceState.getParcelableArrayList(STATE_KEY_ATTACHMENTS);
        mAttachments.removeAllViews();
        for (Parcelable p : attachments)
        {
            Uri uri = (Uri) p;
            addAttachment(uri);
        }

        mCcView.setVisibility(savedInstanceState.getBoolean(STATE_KEY_CC_SHOWN) ?  View.VISIBLE : View.GONE);
        mBccView.setVisibility(savedInstanceState.getBoolean(STATE_KEY_BCC_SHOWN) ?  View.VISIBLE : View.GONE);
        mQuotedTextBar.setVisibility(savedInstanceState.getBoolean(STATE_KEY_QUOTED_TEXT_SHOWN) ?  View.VISIBLE : View.GONE);
        mQuotedText.setVisibility(savedInstanceState.getBoolean(STATE_KEY_QUOTED_TEXT_SHOWN) ?  View.VISIBLE : View.GONE);
        mDraftUid = savedInstanceState.getString(STATE_KEY_DRAFT_UID);
        mIdentity = (Identity)savedInstanceState.getSerializable(STATE_IDENTITY);
        mIdentityChanged = savedInstanceState.getBoolean(STATE_IDENTITY_CHANGED);
        updateFrom();
        updateSignature();

        mDraftNeedsSaving = false;
    }

    private void updateTitle()
    {
        if (mSubjectView.getText().length() == 0)
        {
            setTitle(R.string.compose_title);
        }
        else
        {
            setTitle(mSubjectView.getText().toString());
        }
    }

    public void onFocusChange(View view, boolean focused)
    {
        if (!focused)
        {
            updateTitle();
        }
    }

    private void addAddresses(MultiAutoCompleteTextView view, Address[] addresses)
    {
        if (addresses == null)
        {
            return;
        }
        for (Address address : addresses)
        {
            addAddress(view, address);
        }
    }

    private void addAddress(MultiAutoCompleteTextView view, Address address)
    {
        view.append(address + "", "");
    }

    private Address[] getAddresses(MultiAutoCompleteTextView view)
    {
        Address[] addresses = Address.parseUnencoded(view.getText().toString().trim());
        return addresses;
    }

    private MimeMessage createMessage(boolean appendSig) throws MessagingException
    {
        MimeMessage message = new MimeMessage();
        message.addSentDate(new Date());
        Address from = new Address(mIdentity.getEmail(), mIdentity.getName());
        message.setFrom(from);
        message.setRecipients(RecipientType.TO, getAddresses(mToView));
        message.setRecipients(RecipientType.CC, getAddresses(mCcView));
        message.setRecipients(RecipientType.BCC, getAddresses(mBccView));
        message.setSubject(mSubjectView.getText().toString());
        message.setHeader(""X-User-Agent"", getString(R.string.message_header_mua));

        if (mInReplyTo != null)
        {
            message.setInReplyTo(mInReplyTo);
        }

        if (mReferences != null)
        {
            message.setReferences(mReferences);
        }


        /*
         * Build the Body that will contain the text of the message. We'll decide where to
         * include it later.
         */

        String text = mMessageContentView.getText().toString();
        if (appendSig && mAccount.isSignatureBeforeQuotedText())
        {
            text = appendSignature(text);
        }

        if (mQuotedTextBar.getVisibility() == View.VISIBLE)
        {
            text += ""\n"" + mQuotedText.getText().toString();
        }


        if (appendSig && mAccount.isSignatureBeforeQuotedText() == false)
        {
            text = appendSignature(text);
        }

        TextBody body = new TextBody(text);

        if (mAttachments.getChildCount() > 0)
        {
            /*
             * The message has attachments that need to be included. First we add the part
             * containing the text that will be sent and then we include each attachment.
             */

            MimeMultipart mp;

            mp = new MimeMultipart();
            mp.addBodyPart(new MimeBodyPart(body, ""text/plain""));

            for (int i = 0, count = mAttachments.getChildCount(); i < count; i++)
            {
                Attachment attachment = (Attachment) mAttachments.getChildAt(i).getTag();
                MimeBodyPart bp = new MimeBodyPart(new LocalStore.LocalAttachmentBody(attachment.uri, getApplication()));
                bp.addHeader(MimeHeader.HEADER_CONTENT_TYPE, String.format(""%s;\n name=\""%s\"""", attachment.contentType, attachment.name));
                bp.addHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, ""base64"");
                bp.addHeader(MimeHeader.HEADER_CONTENT_DISPOSITION, String.format(""attachment;\n filename=\""%s\"";\n size=%d"", attachment.name, attachment.size));
                mp.addBodyPart(bp);
            }

            message.setBody(mp);
        }
        else
        {
            /*
             * No attachments to include, just stick the text body in the message and call
             * it good.
             */
            message.setBody(body);
        }

        return message;
    }

    private String appendSignature(String text)
    {
        if (mIdentity.getSignatureUse())
        {
            String signature = mSignatureView.getText().toString();

            if (signature != null && !signature.contentEquals(""""))
            {
                text += ""\n"" + signature;
            }
        }

        return text;
    }

    private void sendOrSaveMessage(boolean save)
    {
        /*
         * Create the message from all the data the user has entered.
         */
        MimeMessage message;
        try
        {
            message = createMessage(!save);  // Only append sig on save
        }
        catch (MessagingException me)
        {
            Log.e(K9.LOG_TAG, ""Failed to create new message for send or save."", me);
            throw new RuntimeException(""Failed to create a new message for send or save."", me);
        }

        if (save)
        {
            /*
             * Save a draft
             */
            if (mDraftUid != null)
            {
                message.setUid(mDraftUid);
            }
            else if (ACTION_EDIT_DRAFT.equals(getIntent().getAction()))
            {
                /*
                 * We're saving a previously saved draft, so update the new message's uid
                 * to the old message's uid.
                 */
                message.setUid(mSourceMessageUid);
            }

            String k9identity = Utility.base64Encode("""" + mMessageContentView.getText().toString().length());

            if (mIdentityChanged || mSignatureChanged)
            {
                String signature  = mSignatureView.getText().toString();
                k9identity += "":"" + Utility.base64Encode(signature);
                if (mIdentityChanged)
                {

                    String name = mIdentity.getName();
                    String email = mIdentity.getEmail();

                    k9identity +=  "":"" + Utility.base64Encode(name) + "":"" + Utility.base64Encode(email);
                }
            }

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Saving identity: "" + k9identity);
            message.addHeader(K9.K9MAIL_IDENTITY, k9identity);

            Message draftMessage = MessagingController.getInstance(getApplication()).saveDraft(mAccount, message);
            mDraftUid = draftMessage.getUid();

            // Don't display the toast if the user is just changing the orientation
            if ((getChangingConfigurations() & ActivityInfo.CONFIG_ORIENTATION) == 0)
            {
                mHandler.sendEmptyMessage(MSG_SAVED_DRAFT);
            }
        }
        else
        {
            MessagingController.getInstance(getApplication()).sendMessage(mAccount, message, null);
            if (mDraftUid != null)
            {
                MessagingController.getInstance(getApplication()).deleteDraft(mAccount, mDraftUid);
                mDraftUid = null;
            }
        }
    }

    private void saveIfNeeded()
    {
        if (!mDraftNeedsSaving)
        {
            return;
        }
        mDraftNeedsSaving = false;
        sendOrSaveMessage(true);
    }

    private void onSend()
    {
        if (getAddresses(mToView).length == 0 && getAddresses(mCcView).length == 0 && getAddresses(mBccView).length == 0)
        {
            mToView.setError(getString(R.string.message_compose_error_no_recipients));
            Toast.makeText(this, getString(R.string.message_compose_error_no_recipients), Toast.LENGTH_LONG).show();
            return;
        }
        sendOrSaveMessage(false);
        mDraftNeedsSaving = false;
        finish();
    }

    private void onDiscard()
    {
        if (mDraftUid != null)
        {
            MessagingController.getInstance(getApplication()).deleteDraft(mAccount, mDraftUid);
            mDraftUid = null;
        }
        mHandler.sendEmptyMessage(MSG_DISCARDED_DRAFT);
        mDraftNeedsSaving = false;
        finish();
    }

    private void onSave()
    {
        mDraftNeedsSaving = true;
        saveIfNeeded();
        finish();
    }

    private void onAddCcBcc()
    {
        mCcView.setVisibility(View.VISIBLE);
        mBccView.setVisibility(View.VISIBLE);
    }

    /**
     * Kick off a picker for whatever kind of MIME types we'll accept and let Android take over.
     */
    private void onAddAttachment()
    {
        Intent i = new Intent(Intent.ACTION_GET_CONTENT);
        i.addCategory(Intent.CATEGORY_OPENABLE);
        i.setType(K9.ACCEPTABLE_ATTACHMENT_SEND_TYPES[0]);
        startActivityForResult(Intent.createChooser(i, null), ACTIVITY_REQUEST_PICK_ATTACHMENT);
    }

    private void addAttachment(Uri uri)
    {
        addAttachment(uri, -1, null);
    }

    private void addAttachment(Uri uri, int size, String name)
    {
        ContentResolver contentResolver = getContentResolver();

        Attachment attachment = new Attachment();
        attachment.name = name;
        attachment.size = size;
        attachment.uri = uri;

        if (attachment.size == -1 || attachment.name == null)
        {
            Cursor metadataCursor = contentResolver.query(uri, new String[] { OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE }, null, null, null);
            if (metadataCursor != null)
            {
                try
                {
                    if (metadataCursor.moveToFirst())
                    {
                        if (attachment.name == null)
                        {
                            attachment.name = metadataCursor.getString(0);
                        }
                        if (attachment.size == -1)
                        {
                            attachment.size = metadataCursor.getInt(1);
                            Log.v(K9.LOG_TAG, ""size: "" + attachment.size);
                        }
                    }
                }
                finally
                {
                    metadataCursor.close();
                }
            }
        }

        if (attachment.name == null)
        {
            attachment.name = uri.getLastPathSegment();
        }

        String contentType = contentResolver.getType(uri);

        if (contentType == null)
        {
            contentType = MimeUtility.getMimeTypeByExtension(attachment.name);
        }

        attachment.contentType = contentType;

        if (attachment.size<=0)
        {
            String uriString = uri.toString();
            if (uriString.startsWith(""file://""))
            {
                Log.v(K9.LOG_TAG, uriString.substring(""file://"".length()));
                File f = new File(uriString.substring(""file://"".length()));
                attachment.size = f.length();
            }
            else {
                Log.v(K9.LOG_TAG, ""Not a file: "" + uriString);
            }
        }
        else {
            Log.v(K9.LOG_TAG, ""old attachment.size: "" + attachment.size);
        }
        Log.v(K9.LOG_TAG, ""new attachment.size: "" + attachment.size);

        View view = getLayoutInflater().inflate(R.layout.message_compose_attachment, mAttachments, false);
        TextView nameView = (TextView)view.findViewById(R.id.attachment_name);
        ImageButton delete = (ImageButton)view.findViewById(R.id.attachment_delete);
        nameView.setText(attachment.name);
        delete.setOnClickListener(this);
        delete.setTag(view);
        view.setTag(attachment);
        mAttachments.addView(view);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        if (resultCode != RESULT_OK)
            return;
        if (data == null)
        {
            return;
        }
        switch (requestCode)
        {
            case ACTIVITY_REQUEST_PICK_ATTACHMENT:

                addAttachment(data.getData());
                mDraftNeedsSaving = true;
                break;
            case ACTIVITY_CHOOSE_IDENTITY:
                onIdentityChosen(data);
                break;
        }
    }

    private void onIdentityChosen(Intent intent)
    {
        Bundle bundle = intent.getExtras();;
        switchToIdentity((Identity)bundle.getSerializable(ChooseIdentity.EXTRA_IDENTITY));
    }

    private void switchToIdentity(Identity identity)
    {
        mIdentity = identity;
        mIdentityChanged = true;
        mDraftNeedsSaving = true;
        updateFrom();
        updateSignature();
    }

    private void updateFrom()
    {
        if (mIdentityChanged)
        {
            mFromView.setVisibility(View.VISIBLE);
        }
        mFromView.setText(getString(R.string.message_view_from_format, mIdentity.getName(), mIdentity.getEmail()));
    }

    private void updateSignature()
    {
        if (mIdentity.getSignatureUse())
        {
            mSignatureView.setText(mIdentity.getSignature());
            mSignatureView.setVisibility(View.VISIBLE);
        }
        else
        {
            mSignatureView.setVisibility(View.GONE);
        }
    }

    public void onClick(View view)
    {
        switch (view.getId())
        {
            case R.id.attachment_delete:
                /*
                 * The view is the delete button, and we have previously set the tag of
                 * the delete button to the view that owns it. We don't use parent because the
                 * view is very complex and could change in the future.
                 */
                mAttachments.removeView((View) view.getTag());
                mDraftNeedsSaving = true;
                break;
            case R.id.quoted_text_delete:
                mQuotedTextBar.setVisibility(View.GONE);
                mQuotedText.setVisibility(View.GONE);
                mDraftNeedsSaving = true;
                break;
        }
    }

    public boolean onOptionsItemSelected(MenuItem item)
    {
        switch (item.getItemId())
        {
            case R.id.send:
                onSend();
                break;
            case R.id.save:
                onSave();
                break;
            case R.id.discard:
                onDiscard();
                break;
            case R.id.add_cc_bcc:
                onAddCcBcc();
                break;
            case R.id.add_attachment:
                onAddAttachment();
                break;
            case R.id.choose_identity:
                onChooseIdentity();
                break;
            default:
                return super.onOptionsItemSelected(item);
        }
        return true;
    }

    private void onChooseIdentity()
    {
        if (mAccount.getIdentities().size() > 1)
        {
            Intent intent = new Intent(this, ChooseIdentity.class);
            intent.putExtra(ChooseIdentity.EXTRA_ACCOUNT, mAccount.getUuid());
            startActivityForResult(intent, ACTIVITY_CHOOSE_IDENTITY);
        }
        else
        {
            Toast.makeText(this, getString(R.string.no_identities),
                           Toast.LENGTH_LONG).show();
        }
    }

    public boolean onCreateOptionsMenu(Menu menu)
    {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.message_compose_option, menu);

        return true;
    }

    /**
     * Returns true if all attachments were able to be attached, otherwise returns false.
     */
    private boolean loadAttachments(Part part, int depth) throws MessagingException
    {
        if (part.getBody() instanceof Multipart)
        {
            Multipart mp = (Multipart) part.getBody();
            boolean ret = true;
            for (int i = 0, count = mp.getCount(); i < count; i++)
            {
                if (!loadAttachments(mp.getBodyPart(i), depth + 1))
                {
                    ret = false;
                }
            }
            return ret;
        }
        else
        {
            String contentType = MimeUtility.unfoldAndDecode(part.getContentType());
            String name = MimeUtility.getHeaderParameter(contentType, ""name"");
            if (name != null)
            {
                Body body = part.getBody();
                if (body != null && body instanceof LocalAttachmentBody)
                {
                    final Uri uri = ((LocalAttachmentBody) body).getContentUri();
                    mHandler.post(new Runnable()
                    {
                        public void run()
                        {
                            addAttachment(uri);
                        }
                    });
                }
                else
                {
                    return false;
                }
            }
            return true;
        }
    }

    /**
     * Pull out the parts of the now loaded source message and apply them to the new message
     * depending on the type of message being composed.
     * @param message
     */
    private void processSourceMessage(Message message)
    {
        String action = getIntent().getAction();
        if (ACTION_REPLY.equals(action) || ACTION_REPLY_ALL.equals(action))
        {
            try
            {
                if (message.getSubject() != null && !message.getSubject().toLowerCase().startsWith(""re:""))
                {
                    mSubjectView.setText(""Re: "" + message.getSubject());
                }
                else
                {
                    mSubjectView.setText(message.getSubject());
                }
                /*
                 * If a reply-to was included with the message use that, otherwise use the from
                 * or sender address.
                 */
                Address[] replyToAddresses;
                if (message.getReplyTo().length > 0)
                {
                    addAddresses(mToView, replyToAddresses = message.getReplyTo());
                }
                else
                {
                    addAddresses(mToView, replyToAddresses = message.getFrom());
                }

                if (message.getMessageId() != null && message.getMessageId().length() > 0)
                {
                    String messageId = message.getMessageId();
                    mInReplyTo = messageId;

                    if (message.getReferences() != null && message.getReferences().length > 0)
                    {
                        StringBuffer buffy = new StringBuffer();
                        for (int i=0; i < message.getReferences().length; i++)
                            buffy.append(message.getReferences()[i]);

                        mReferences = buffy.toString() + "" "" + mInReplyTo;
                    }
                    else
                    {
                        mReferences = mInReplyTo;
                    }

                }
                else
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""could not get Message-ID."");
                }

                Part part = MimeUtility.findFirstPartByMimeType(mSourceMessage,
                            ""text/plain"");
                if (part != null)
                {
                    String quotedText = String.format(
                                            getString(R.string.message_compose_reply_header_fmt),
                                            Address.toString(mSourceMessage.getFrom()));

                    quotedText += MimeUtility.getTextFromPart(part).replaceAll(""(?m)^"", "">"");
                    quotedText = quotedText.replaceAll(""\\\r"", """");
                    mQuotedText.setText(quotedText);

                    mQuotedTextBar.setVisibility(View.VISIBLE);
                    mQuotedText.setVisibility(View.VISIBLE);
                }

                if (ACTION_REPLY_ALL.equals(action) || ACTION_REPLY.equals(action))
                {
                    Identity useIdentity = null;
                    for (Address address : message.getRecipients(RecipientType.TO))
                    {
                        Identity identity = mAccount.findIdentity(address);
                        if (identity != null)
                        {
                            useIdentity = identity;
                            break;
                        }
                    }
                    if (useIdentity == null)
                    {
                        if (message.getRecipients(RecipientType.CC).length > 0)
                        {
                            for (Address address : message.getRecipients(RecipientType.CC))
                            {
                                Identity identity = mAccount.findIdentity(address);
                                if (identity != null)
                                {
                                    useIdentity = identity;
                                    break;
                                }
                            }
                        }
                    }
                    if (useIdentity != null)
                    {
                        Identity defaultIdentity = mAccount.getIdentity(0);
                        if (useIdentity != defaultIdentity)
                        {
                            switchToIdentity(useIdentity);
                        }
                    }
                }

                if (ACTION_REPLY_ALL.equals(action))
                {
                    for (Address address : message.getRecipients(RecipientType.TO))
                    {
                        Identity identity = mAccount.findIdentity(address);
                        if (!mAccount.isAnIdentity(address))
                        {
                            addAddress(mToView, address);
                        }

                    }
                    if (message.getRecipients(RecipientType.CC).length > 0)
                    {
                        for (Address address : message.getRecipients(RecipientType.CC))
                        {
                            if (!mAccount.isAnIdentity(address) && !Utility.arrayContains(replyToAddresses, address))
                            {
                                addAddress(mCcView, address);
                            }

                        }
                        mCcView.setVisibility(View.VISIBLE);
                    }
                }
            }
            catch (MessagingException me)
            {
                /*
                 * This really should not happen at this point but if it does it's okay.
                 * The user can continue composing their message.
                 */
            }
        }
        else if (ACTION_FORWARD.equals(action))
        {
            try
            {
                if (message.getSubject() != null && !message.getSubject().toLowerCase().startsWith(""fwd:""))
                {
                    mSubjectView.setText(""Fwd: "" + message.getSubject());
                }
                else
                {
                    mSubjectView.setText(message.getSubject());
                }
                Part part = MimeUtility.findFirstPartByMimeType(message, ""text/plain"");
                if (part == null)
                {
                    part = MimeUtility.findFirstPartByMimeType(message, ""text/html"");
                }
                if (part != null)
                {
                    String quotedText = MimeUtility.getTextFromPart(part);
                    if (quotedText != null)
                    {
                        String text = String.format(
                                          getString(R.string.message_compose_fwd_header_fmt),
                                          mSourceMessage.getSubject(),
                                          Address.toString(mSourceMessage.getFrom()),
                                          Address.toString(
                                              mSourceMessage.getRecipients(RecipientType.TO)),
                                          Address.toString(
                                              mSourceMessage.getRecipients(RecipientType.CC)));
                        quotedText = quotedText.replaceAll(""\\\r"", """");
                        text += quotedText;
                        mQuotedText.setText(text);
                        mQuotedTextBar.setVisibility(View.VISIBLE);
                        mQuotedText.setVisibility(View.VISIBLE);
                    }
                }
                if (!mSourceMessageProcessed)
                {
                    if (!loadAttachments(message, 0))
                    {
                        mHandler.sendEmptyMessage(MSG_SKIPPED_ATTACHMENTS);
                    }
                }
            }
            catch (MessagingException me)
            {
                /*
                 * This really should not happen at this point but if it does it's okay.
                 * The user can continue composing their message.
                 */
            }
        }
        else if (ACTION_EDIT_DRAFT.equals(action))
        {
            try
            {
                mDraftUid = message.getUid();
                mSubjectView.setText(message.getSubject());
                addAddresses(mToView, message.getRecipients(RecipientType.TO));
                if (message.getRecipients(RecipientType.CC).length > 0)
                {
                    addAddresses(mCcView, message.getRecipients(RecipientType.CC));
                    mCcView.setVisibility(View.VISIBLE);
                }
                if (message.getRecipients(RecipientType.BCC).length > 0)
                {
                    addAddresses(mBccView, message.getRecipients(RecipientType.BCC));
                    mBccView.setVisibility(View.VISIBLE);
                }

                if (!mSourceMessageProcessed)
                {
                    loadAttachments(message, 0);
                }
                Integer bodyLength = null;
                String[] k9identities = message.getHeader(K9.K9MAIL_IDENTITY);
                if (k9identities != null && k9identities.length > 0)
                {
                    String k9identity = k9identities[0];

                    if (k9identity != null)
                    {
                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""Got a saved identity: "" + k9identity);
                        StringTokenizer tokens = new StringTokenizer(k9identity, "":"", false);

                        String bodyLengthS = null;
                        String name = null;
                        String email = null;
                        String signature = null;
                        boolean signatureUse = message.getFolder().getAccount().getSignatureUse();
                        if (tokens.hasMoreTokens())
                        {
                            bodyLengthS = Utility.base64Decode(tokens.nextToken());
                            try
                            {
                                bodyLength = Integer.parseInt(bodyLengthS);
                            }
                            catch (Exception e)
                            {
                                Log.e(K9.LOG_TAG, ""Unable to parse bodyLength '"" + bodyLengthS + ""'"");
                            }
                        }
                        if (tokens.hasMoreTokens())
                        {
                            signatureUse = true;
                            signature = Utility.base64Decode(tokens.nextToken());
                        }
                        if (tokens.hasMoreTokens())
                        {
                            name = Utility.base64Decode(tokens.nextToken());
                        }
                        if (tokens.hasMoreTokens())
                        {
                            email = Utility.base64Decode(tokens.nextToken());
                        }

                        Identity newIdentity = new Identity();
                        newIdentity.setSignatureUse(signatureUse);
                        if (signature != null)
                        {
                            newIdentity.setSignature(signature);
                            mSignatureChanged = true;
                        }
                        else
                        {
                            newIdentity.setSignature(mIdentity.getSignature());
                        }

                        if (name != null)
                        {
                            newIdentity.setName(name);
                            mIdentityChanged = true;
                        }
                        else
                        {
                            newIdentity.setName(mIdentity.getName());
                        }

                        if (email != null)
                        {
                            newIdentity.setEmail(email);
                            mIdentityChanged = true;
                        }
                        else
                        {
                            newIdentity.setEmail(mIdentity.getEmail());
                        }

                        mIdentity = newIdentity;

                        updateSignature();
                        updateFrom();

                    }
                }
                Part part = MimeUtility.findFirstPartByMimeType(message, ""text/plain"");
                if (part != null)
                {
                    String text = MimeUtility.getTextFromPart(part);
                    if (bodyLength != null && bodyLength + 1 < text.length())   // + 1 to get rid of the newline we added when saving the draft
                    {
                        String bodyText = text.substring(0, bodyLength);
                        String quotedText = text.substring(bodyLength + 1, text.length());

                        mMessageContentView.setText(bodyText);
                        mQuotedText.setText(quotedText);

                        mQuotedTextBar.setVisibility(View.VISIBLE);
                        mQuotedText.setVisibility(View.VISIBLE);
                    }
                    else
                    {
                        mMessageContentView.setText(text);
                    }
                }
            }
            catch (MessagingException me)
            {
                // TODO
            }
        }
        mSourceMessageProcessed = true;
        mDraftNeedsSaving = false;
    }

    class Listener extends MessagingListener
    {
        @Override
        public void loadMessageForViewStarted(Account account, String folder, String uid)
        {
            if (mSourceMessageUid==null
                    || !mSourceMessageUid.equals(uid))
            {
                return;
            }

            mHandler.sendEmptyMessage(MSG_PROGRESS_ON);
        }

        @Override
        public void loadMessageForViewFinished(Account account, String folder, String uid, Message message)
        {
            if (mSourceMessageUid==null
                    || !mSourceMessageUid.equals(uid))
            {
                return;
            }

            mHandler.sendEmptyMessage(MSG_PROGRESS_OFF);
        }

        @Override
        public void loadMessageForViewBodyAvailable(Account account, String folder, String uid, final Message message)
        {
            if (mSourceMessageUid==null
                    || !mSourceMessageUid.equals(uid))
            {
                return;
            }

            mSourceMessage = message;
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    processSourceMessage(message);
                }
            });
        }

        @Override
        public void loadMessageForViewFailed(Account account, String folder, String uid, Throwable t)
        {
            if (mSourceMessageUid==null
                    || !mSourceMessageUid.equals(uid))
            {
                return;
            }
            mHandler.sendEmptyMessage(MSG_PROGRESS_OFF);
            // TODO show network error
        }

        @Override
        public void messageUidChanged(Account account, String folder, String oldUid, String newUid)
        {
            if (account.equals(mAccount) && folder.equals(mAccount.getDraftsFolderName()))
            {
                if (oldUid.equals(mDraftUid))
                {
                    mDraftUid = newUid;
                }
            }
            
            if (account.equals(mAccount) && (folder.equals(mFolder)))
            {
                if (oldUid.equals(mSourceMessageUid))
                {
                    mSourceMessageUid = newUid;
                }
                if (mSourceMessage != null && (oldUid.equals(mSourceMessage.getUid())))
                {
                    mSourceMessage.setUid(newUid);
                }
            }
        }
    }

    private String decode(String s)
        throws UnsupportedEncodingException
    {
        return URLDecoder.decode(s, ""UTF-8"");
    }

    /**
     * When we are launched with an intent that includes a mailto: URI, we can actually
     * gather quite a few of our message fields from it.
     * 
     * @mailToString the href (which must start with ""mailto:"").
     */
    private void initializeFromMailTo(String mailToString) {
        
        // Chop up everything between mailto: and ? to find recipients
        int index = mailToString.indexOf(""?"");
        int length = ""mailto"".length() + 1; 
        String to;
        try
        {
            // Extract the recipient after mailto:
            if (index == -1)
            {
                to = decode(mailToString.substring(length));
            } 
            else
            {
                to = decode(mailToString.substring(length, index));
            }
            mToView.setText(to);
        } 
        catch (UnsupportedEncodingException e)
        {
            Log.e(K9.LOG_TAG, e.getMessage() + "" while decoding '"" + mailToString + ""'"");
        }

        // Extract the other parameters

        // We need to disguise this string as a URI in order to parse it
        Uri uri = Uri.parse(""foo://"" + mailToString);

        String addressList;

        addressList = """";
        List<String> cc = uri.getQueryParameters(""cc"");
        for (String address : cc)
        {
            addressList += address + "","";
        }
        mCcView.setText(addressList);

        addressList = """";
        List<String> bcc = uri.getQueryParameters(""bcc"");
        for (String address : bcc)
        {
            addressList += address + "","";
        }
        mBccView.setText(addressList);

        List<String> subject = uri.getQueryParameters(""subject"");
        if (subject.size() > 0)
        {
            mSubjectView.setText(subject.get(0));
        }

        List<String> body = uri.getQueryParameters(""body"");
        if (body.size() > 0)
        {
            mMessageContentView.setText(body.get(0));
        }
    }    
}
",True,189,0,0,8,52,5,25,L1
31,com.fsck.k9.activity.MessageList.java,"package com.fsck.k9.activity;
// import android.os.Debug;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.NotificationManager;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.os.Handler;
import android.text.SpannableString;
import android.text.Spannable;
import android.text.style.ForegroundColorSpan;
import android.text.style.StyleSpan;
import android.text.style.TextAppearanceSpan;
import android.util.Config;
import android.util.Log;
import android.view.*;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.View.OnClickListener;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.widget.*;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.CompoundButton.OnCheckedChangeListener;
import com.fsck.k9.*;
import com.fsck.k9.MessagingController.SORT_TYPE;
import com.fsck.k9.activity.setup.AccountSettings;
import com.fsck.k9.activity.setup.FolderSettings;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import com.fsck.k9.mail.store.LocalStore.LocalMessage;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


/**
 * MessageList is the primary user interface for the program. This
 * Activity shows a list of messages.
 * From this Activity the user can perform all standard message
 * operations.
 *
 */

public class MessageList
        extends K9Activity
        implements OnClickListener, AdapterView.OnItemClickListener
{
    private static final int DIALOG_MARK_ALL_AS_READ = 1;

    private static final int ACTIVITY_CHOOSE_FOLDER_MOVE = 1;

    private static final int ACTIVITY_CHOOSE_FOLDER_COPY = 2;
    
    private static final int ACTIVITY_CHOOSE_FOLDER_MOVE_BATCH = 3;
    private static final int ACTIVITY_CHOOSE_FOLDER_COPY_BATCH = 4;

    private static final String EXTRA_ACCOUNT = ""account"";
    private static final String EXTRA_FOLDER  = ""folder"";
    private static final String EXTRA_QUERY = ""query"";

    private ListView mListView;

    private boolean mTouchView = true;

    private MessageListAdapter mAdapter;

    private FolderInfoHolder mCurrentFolder;

    private LayoutInflater mInflater;

    private MessagingController mController;

    private Account mAccount;
    private int mUnreadMessageCount = 0;

    private GestureDetector gestureDetector;
    private View.OnTouchListener gestureListener;
    /**
    * Stores the name of the folder that we want to open as soon as possible
    * after load.
     */
    private String mFolderName;

    /* if we're doing a search, this contains the query string */
    private String mQueryString;

    private MessageListHandler mHandler = new MessageListHandler();

    private SORT_TYPE sortType = SORT_TYPE.SORT_DATE;

    private boolean sortAscending = true;
    private boolean sortDateAscending = false;

    private boolean mStars = true;
    private boolean mCheckboxes = true;
    private int mSelectedCount = 0;

    private View mBatchButtonArea;
    private Button mBatchReadButton;
    private Button mBatchDeleteButton;
    private Button mBatchFlagButton;
    private Button mBatchDoneButton;

    class MessageListHandler extends Handler
    {

        public void removeMessage(final List<MessageInfoHolder> messages)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    for (MessageInfoHolder message : messages)
                    {
                        if (message != null)
                        {
                            if (mFolderName == null || (message.folder != null && message.folder.name.equals(mFolderName)))
                            {
                                if (message.selected && mSelectedCount > 0)
                                {
                                    mSelectedCount--;
                                }
                                mAdapter.messages.remove(message);
                            }
                        }
                    }
                    mAdapter.notifyDataSetChanged();
                    toggleBatchButtons();
                }
            });

        }

        public void addMessages(List<MessageInfoHolder> messages)
        {

            final boolean wasEmpty = mAdapter.messages.isEmpty();
            for (final MessageInfoHolder message : messages)
            {

                if (mFolderName == null || (message.folder != null && message.folder.name.equals(mFolderName)))
                {

                    runOnUiThread(new Runnable()
                    {
                        public void run()
                        {
                            int index = Collections.binarySearch(mAdapter.messages, message);

                            if (index < 0)
                            {
                                index = (index * -1) - 1;
                            }

                            mAdapter.messages.add(index, message);

                        }
                    });
                }
            }

            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    if (wasEmpty)
                    {
                        mListView.setSelection(0);
                    }
                    mAdapter.notifyDataSetChanged();
                }
            });
        }

        private void sortMessages()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    synchronized (mAdapter.messages)
                    {
                        Collections.sort(mAdapter.messages);
                    }
                    mAdapter.notifyDataSetChanged();
                }
            });

        }

        public void folderLoading(String folder, boolean loading)
        {

            if (mCurrentFolder != null && mCurrentFolder.name.equals(folder))
            {
                mCurrentFolder.loading = loading;
            }


        }
        private void refreshTitle()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    setWindowTitle();
                    setWindowProgress();
                }
            });
        }
        private void setWindowProgress()
        {
            int level = Window.PROGRESS_END;

            if (mCurrentFolder != null && mCurrentFolder.loading && mAdapter.mListener.getFolderTotal() > 0)
            {
                level = (Window.PROGRESS_END / mAdapter.mListener.getFolderTotal()) * (mAdapter.mListener.getFolderCompleted()) ;
                if (level > Window.PROGRESS_END)
                {
                    level = Window.PROGRESS_END;
                }
            }

            getWindow().setFeatureInt(Window.FEATURE_PROGRESS, level);
        }
        private void setWindowTitle()
        {

            String displayName;

            if (mFolderName != null)
            {
                displayName  = mFolderName;

                if (K9.INBOX.equalsIgnoreCase(displayName))
                {
                    displayName = getString(R.string.special_mailbox_name_inbox);
                }

                String dispString = mAdapter.mListener.formatHeader(MessageList.this, getString(R.string.message_list_title, mAccount.getDescription(), displayName), mUnreadMessageCount, getTimeFormat());

                setTitle(dispString);
            }
            else if (mQueryString != null)
            {
                setTitle(getString(R.string.search_results) + "": ""+ mQueryString);
            }
        }

        public void progress(final boolean progress)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    showProgressIndicator(progress);
                }
            });
        }

    }

    /**
    * This class is responsible for loading the list of local messages for a
    * given folder
     */

    public static void actionHandleFolder(Context context, Account account, String folder)
    {
        Intent intent = actionHandleFolderIntent(context,account,folder);
        context.startActivity(intent);

    }
    public static Intent actionHandleFolderIntent(Context context, Account account, String folder)
    {
        Intent intent = new Intent(context, MessageList.class);
        intent.putExtra(EXTRA_ACCOUNT, account.getUuid());

        if (folder != null)
        {
            intent.putExtra(EXTRA_FOLDER, folder);
        }
        return intent;
    }

    public void onItemClick(AdapterView parent, View v, int position, long id)
    {
        if (mCurrentFolder != null && ((position+1) == mAdapter.getCount()))
        {
            mController.loadMoreMessages(mAccount, mFolderName, mAdapter.mListener);
            return;
        }


        MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(position);
        if (mSelectedCount > 0)
        {
            // In multiselect mode make sure that clicking on the item results in
            // toggling the 'selected' checkbox
            setSelected(message, !message.selected);
            return;
        }
        else
        {
            onOpenMessage(message);
            return;
        }
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        // Debug.startMethodTracing(""k9"");
        super.onCreate(savedInstanceState);

        mInflater = getLayoutInflater();
        initializeLayout();
        onNewIntent(getIntent());
    }

    public void onNewIntent(Intent intent)
    {
        setIntent(intent); // onNewIntent doesn't autoset our ""internal"" intent
        String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mFolderName = intent.getStringExtra(EXTRA_FOLDER);
        mQueryString = intent.getStringExtra(EXTRA_QUERY);

        // Take the initial folder into account only if we are *not* restoring the
        // activity already

        if (mFolderName == null && mQueryString == null)
        {
            mFolderName = mAccount.getAutoExpandFolderName();
        }

        mAdapter = new MessageListAdapter();
        final Object previousData = getLastNonConfigurationInstance();

        if (previousData != null)
        {
            //noinspection unchecked
            mAdapter.messages.addAll((List<MessageInfoHolder>) previousData);
        }

        if (mFolderName != null)
        {
            mCurrentFolder = mAdapter.getFolder(mFolderName, mAccount);
        }

        mController = MessagingController.getInstance(getApplication());
        mListView.setAdapter(mAdapter);


    }

    @Override
    public void onPause()
    {
        super.onPause();
        //Debug.stopMethodTracing();
        mController.removeListener(mAdapter.mListener);
    }


    /**
    * On resume we refresh
    * messages for the folder that is currently open. This guarantees that things
    * like unread message count and read status are updated.
     */
    @Override
    public void onResume()
    {
        super.onResume();

        mStars = K9.messageListStars();
        mCheckboxes = K9.messageListCheckboxes();
        mTouchView = K9.messageListTouchable();

        sortType = mController.getSortType();
        sortAscending = mController.isSortAscending(sortType);
        sortDateAscending = mController.isSortAscending(SORT_TYPE.SORT_DATE);

        mController.addListener(mAdapter.mListener);
        mAdapter.messages.clear();
        mAdapter.notifyDataSetChanged();

        if (mFolderName != null)
        {
            mController.listLocalMessagesSynchronous(mAccount, mFolderName,  mAdapter.mListener);

            NotificationManager notifMgr = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            notifMgr.cancel(mAccount.getAccountNumber());
            notifMgr.cancel(-1000 - mAccount.getAccountNumber());

            mController.getFolderUnreadMessageCount(mAccount, mFolderName, mAdapter.mListener);
        }
        else if (mQueryString != null)
        {
            mController.searchLocalMessages(mAccount, mQueryString,  mAdapter.mListener);

        }

        mHandler.refreshTitle();

    }

    private void initializeLayout ()
    {
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        requestWindowFeature(Window.FEATURE_PROGRESS);
        setContentView(R.layout.message_list);

        mListView = (ListView) findViewById(R.id.message_list);
        mListView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_INSET);
        mListView.setLongClickable(true);
        mListView.setFastScrollEnabled(true);
        mListView.setScrollingCacheEnabled(true);
        mListView.setOnItemClickListener(this);


        registerForContextMenu(mListView);


        mBatchButtonArea = findViewById(R.id.batch_button_area);
        mBatchReadButton = (Button) findViewById(R.id.batch_read_button);
        mBatchReadButton.setOnClickListener(this);
        mBatchDeleteButton = (Button) findViewById(R.id.batch_delete_button);
        mBatchDeleteButton.setOnClickListener(this);
        mBatchFlagButton = (Button) findViewById(R.id.batch_flag_button);
        mBatchFlagButton.setOnClickListener(this);
        mBatchDoneButton = (Button) findViewById(R.id.batch_done_button);

        mBatchDoneButton.setOnClickListener(this);

        // Gesture detection
        gestureDetector = new GestureDetector(new MyGestureDetector());
        gestureListener = new View.OnTouchListener()
        {
            public boolean onTouch(View v, MotionEvent event)
            {
                if (gestureDetector.onTouchEvent(event))
                {
                    return true;
                }
                return false;
            }
        };

        mListView.setOnTouchListener(gestureListener);
    }

    @Override public Object onRetainNonConfigurationInstance()
    {
        return mAdapter.messages;
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        //Shortcuts that work no matter what is selected

        switch (keyCode)
        {


            case KeyEvent.KEYCODE_DPAD_LEFT:
            {
                if (mBatchButtonArea.hasFocus())
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            {
                if (mBatchButtonArea.hasFocus())
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }


            case KeyEvent.KEYCODE_C:
            {
                onCompose();
                return true;
            }

            case KeyEvent.KEYCODE_Q:
                //case KeyEvent.KEYCODE_BACK:
            {
                onShowFolderList();
                return true;
            }

            case KeyEvent.KEYCODE_O:
            {
                onCycleSort();
                return true;
            }

            case KeyEvent.KEYCODE_I:
            {
                onToggleSortAscending();
                return true;
            }

            case KeyEvent.KEYCODE_H:
            {
                Toast toast = Toast.makeText(this, R.string.message_list_help_key, Toast.LENGTH_LONG);
                toast.show();
                return true;
            }
        }//switch

        int position = mListView.getSelectedItemPosition();
        try
        {
            if (position >= 0)
            {
                MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(position);


                if (message != null)
                {
                    switch (keyCode)
                    {
                        case KeyEvent.KEYCODE_DEL:
                        {
                            onDelete(message, position);
                            return true;
                        }
                        
                        case KeyEvent.KEYCODE_S:
                        {
                            setSelected(message, !message.selected);
                            return true;
                        }

                        case KeyEvent.KEYCODE_D:
                        {
                            onDelete(message, position);
                            return true;
                        }

                        case KeyEvent.KEYCODE_F:
                        {
                            onForward(message);
                            return true;
                        }

                        case KeyEvent.KEYCODE_A:
                        {
                            onReplyAll(message);
                            return true;
                        }

                        case KeyEvent.KEYCODE_R:
                        {
                            onReply(message);
                            return true;
                        }

                        case KeyEvent.KEYCODE_G:
                        {
                            onToggleFlag(message);
                            return true;
                        }

                        case KeyEvent.KEYCODE_M:
                        {
                            onMove(message);
                            return true;
                        }

                        case KeyEvent.KEYCODE_Y:
                        {
                            onCopy(message);
                            return true;
                        }

                        case KeyEvent.KEYCODE_Z:
                        {
                            onToggleRead(message);
                            return true;
                        }
                    }
                }
            }
        }
        finally
        {
            return super.onKeyDown(keyCode, event);
        }
    }//onKeyDown

    private void onOpenMessage(MessageInfoHolder message)
    {
        if (message.folder.name.equals(message.account.getDraftsFolderName()))
        {
            MessageCompose.actionEditDraft(this, message.account, message.message);
        }
        else
        {
            // Need to get the list before the sort starts
            ArrayList<String> messageUids = new ArrayList<String>();

            for (MessageInfoHolder holder : mAdapter.messages)
            {
                messageUids.add(holder.uid);
            }

            MessageView.actionView(this, message.account, message.folder.name, message.uid, messageUids);
        }
        /*
        * We set read=true here for UI performance reasons. The actual value will
        * get picked up on the refresh when the Activity is resumed but that may
        * take a second or so and we don't want this to show and then go away. I've
        * gone back and forth on this, and this gives a better UI experience, so I
        * am putting it back in.
         */

        if (!message.read)
        {
            message.read = true;
            mHandler.sortMessages();
        }

    }

    private void onAccounts()
    {
        Accounts.listAccounts(this);
        finish();
    }

    private void onShowFolderList()
    {
        FolderList.actionHandleAccount(this, mAccount);
        finish();
    }

    private void onCompose()
    {

        if (mQueryString != null)
        {// if we have a query string, we don't have an account, to let compose start the default action
            MessageCompose.actionCompose(this, null);
        }
        else
        {

            MessageCompose.actionCompose(this, mAccount);
        }
    }

    private void onEditAccount()
    {
        AccountSettings.actionSettings(this, mAccount);
    }

    private void changeSort(SORT_TYPE newSortType)
    {
        if (sortType == newSortType)
        {
            onToggleSortAscending();
        }
        else
        {
            sortType = newSortType;
            mController.setSortType(sortType);
            sortAscending = mController.isSortAscending(sortType);
            sortDateAscending = mController.isSortAscending(SORT_TYPE.SORT_DATE);
            reSort();
        }
    }

    private void reSort()
    {
        int toastString = sortType.getToast(sortAscending);

        Toast toast = Toast.makeText(this, toastString, Toast.LENGTH_SHORT);
        toast.show();

        mHandler.sortMessages();

    }


    private void onCycleSort()
    {
        SORT_TYPE[] sorts = SORT_TYPE.values();
        int curIndex = 0;

        for (int i = 0; i < sorts.length; i++)
        {
            if (sorts[i] == sortType)
            {
                curIndex = i;
                break;
            }
        }

        curIndex++;

        if (curIndex == sorts.length)
        {
            curIndex = 0;
        }

        changeSort(sorts[curIndex]);
    }

    private void onToggleSortAscending()
    {
        mController.setSortAscending(sortType, !sortAscending);

        sortAscending = mController.isSortAscending(sortType);
        sortDateAscending = mController.isSortAscending(SORT_TYPE.SORT_DATE);

        reSort();
    }

    private void onDelete(MessageInfoHolder holder, int position)
    {
        mAdapter.removeMessage(holder);
        mController.deleteMessages(new Message[] { holder.message }, null);
    }


    private void onMove(MessageInfoHolder holder)
    {
        if (mController.isMoveCapable(holder.account) == false)
        {
            return;
        }

        if (mController.isMoveCapable(holder.message) == false)
        {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }

        Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, holder.account.getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, holder.folder.name);
        intent.putExtra(ChooseFolder.EXTRA_MESSAGE_UID, holder.message.getUid());
        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_MOVE);
    }

    private void onCopy(MessageInfoHolder holder)
    {
        if (mController.isCopyCapable(holder.account) == false)
        {
            return;
        }

        if (mController.isCopyCapable(holder.message) == false)
        {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }

        Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, holder.account.getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, holder.folder.name);
        intent.putExtra(ChooseFolder.EXTRA_MESSAGE_UID, holder.message.getUid());
        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_COPY);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        if (resultCode != RESULT_OK)
            return;

        switch (requestCode)
        {
            case ACTIVITY_CHOOSE_FOLDER_MOVE:
            case ACTIVITY_CHOOSE_FOLDER_COPY:
            {
                if (data == null)
                    return;

                String destFolderName = data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER);

                String uid = data.getStringExtra(ChooseFolder.EXTRA_MESSAGE_UID);

                MessageInfoHolder m = mAdapter.getMessage(uid);
                if (destFolderName != null && m != null)
                {
                    switch (requestCode)
                    {
                        case ACTIVITY_CHOOSE_FOLDER_MOVE:
                            onMoveChosen(m, destFolderName);
                            break;

                        case ACTIVITY_CHOOSE_FOLDER_COPY:
                            onCopyChosen(m, destFolderName);
                            break;
                    }
                }
                break;
            }
            case ACTIVITY_CHOOSE_FOLDER_MOVE_BATCH:
            {
                String destFolderName = data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER);
                onMoveChosenBatch(destFolderName);
                break;
            }
            case ACTIVITY_CHOOSE_FOLDER_COPY_BATCH:
            {
                String destFolderName = data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER);
                onCopyChosenBatch(destFolderName);
                break;
            }
        }
    }


    private void onMoveChosen(MessageInfoHolder holder, String folderName)
    {
        if (mController.isMoveCapable(holder.account) == true && folderName != null)
        {
            mAdapter.removeMessage(holder);
            mController.moveMessage(holder.account, holder.message.getFolder().getName(), holder.message, folderName, null);
        }
    }


    private void onCopyChosen(MessageInfoHolder holder, String folderName)
    {
        if (mController.isCopyCapable(holder.account) == true && folderName != null)
        {
            mController.copyMessage(holder.account,
                                    holder.message.getFolder().getName(), holder.message, folderName, null);
        }
    }


    private void onReply(MessageInfoHolder holder)
    {
        MessageCompose.actionReply(this, holder.account, holder.message, false);
    }

    private void onReplyAll(MessageInfoHolder holder)
    {
        MessageCompose.actionReply(this, holder.account, holder.message, true);
    }

    private void onForward(MessageInfoHolder holder)
    {
        MessageCompose.actionForward(this, holder.account, holder.message);
    }

    private void onMarkAllAsRead(final Account account, final String folder)
    {
        showDialog(DIALOG_MARK_ALL_AS_READ);
    }

    private void onExpunge(final Account account, String folderName)
    {
        mController.expunge(account, folderName, null);
    }


    @Override
    public Dialog onCreateDialog(int id)
    {
        switch (id)
        {
            case DIALOG_MARK_ALL_AS_READ:
                return createMarkAllAsReadDialog();

        }

        return super.onCreateDialog(id);
    }

    public void onPrepareDialog(int id, Dialog dialog)
    {
        switch (id)
        {
            case DIALOG_MARK_ALL_AS_READ:
                if (mCurrentFolder != null)
                {
                    ((AlertDialog)dialog).setMessage(getString(R.string.mark_all_as_read_dlg_instructions_fmt,
                                                     mCurrentFolder.displayName));
                }
                break;

            default:
                super.onPrepareDialog(id, dialog);
        }
    }

    private Dialog createMarkAllAsReadDialog()
    {
        return new AlertDialog.Builder(this)
               .setTitle(R.string.mark_all_as_read_dlg_title)
               .setMessage(getString(R.string.mark_all_as_read_dlg_instructions_fmt,
                                     mCurrentFolder.displayName))
               .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_MARK_ALL_AS_READ);

                try
                {

                    mController.markAllMessagesRead(mAccount, mCurrentFolder.name);

                    for (MessageInfoHolder holder : mAdapter.messages)
                    {
                        holder.read = true;
                    }

                    mHandler.sortMessages();


                }
                catch (Exception e)
                {
                    // Ignore
                }
            }
        })

               .setNegativeButton(R.string.cancel_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_MARK_ALL_AS_READ);
            }
        })

               .create();
    }

    private void onToggleRead(MessageInfoHolder holder)
    {
        mController.setFlag(holder.account, holder.message.getFolder().getName(), new String[] { holder.uid }, Flag.SEEN, !holder.read);
        holder.read = !holder.read;
        mHandler.sortMessages();
    }

    private void onToggleFlag(MessageInfoHolder holder)
    {

        mController.setFlag(holder.account, holder.message.getFolder().getName(), new String[] { holder.uid }, Flag.FLAGGED, !holder.flagged);
        holder.flagged = !holder.flagged;
        mHandler.sortMessages();
    }

    private void checkMail(Account account, String folderName)
    {
        mController.synchronizeMailbox(account, folderName, mAdapter.mListener);
        sendMail(account);
    }

    private void sendMail(Account account)
    {
        mController.sendPendingMessages(account, mAdapter.mListener);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item)
    {
        int itemId = item.getItemId();
        switch (itemId)
        {
            
            case R.id.compose:
                onCompose();

                return true;

            case R.id.accounts:
                onAccounts();

                return true;

            case R.id.set_sort_date:
                changeSort(SORT_TYPE.SORT_DATE);

                return true;

            case R.id.set_sort_subject:
                changeSort(SORT_TYPE.SORT_SUBJECT);

                return true;

            case R.id.set_sort_sender:
                changeSort(SORT_TYPE.SORT_SENDER);

                return true;

            case R.id.set_sort_flag:
                changeSort(SORT_TYPE.SORT_FLAGGED);

                return true;

            case R.id.set_sort_unread:
                changeSort(SORT_TYPE.SORT_UNREAD);

                return true;

            case R.id.set_sort_attach:
                changeSort(SORT_TYPE.SORT_ATTACHMENT);

                return true;

            case R.id.batch_select_all:
                setAllSelected(true);
                toggleBatchButtons();
                return true;

            case R.id.batch_deselect_all:
                setAllSelected(false);
                toggleBatchButtons();
                return true;
                
            case R.id.batch_delete_op:
                deleteSelected();
                return true;

            case R.id.batch_mark_read_op:
                flagSelected(Flag.SEEN, true);
                return true;

            case R.id.batch_mark_unread_op:
                flagSelected(Flag.SEEN, false);
                return true;

            case R.id.batch_flag_op:
                flagSelected(Flag.FLAGGED, true);
                return true;

            case R.id.batch_unflag_op:
                flagSelected(Flag.FLAGGED, false);
                return true;

        }

        if (mQueryString != null)
        {
            return false; // none of the options after this point are ""safe"" for search results
        }

        switch (itemId)
        {
            case R.id.check_mail:
                if (mFolderName != null)
                {
                    checkMail(mAccount, mFolderName);
                }
                return true;
            case R.id.send_messages:
                sendMail(mAccount);
                return true;

            case R.id.list_folders:
                onShowFolderList();

                return true;

            case R.id.mark_all_as_read:
                if (mFolderName != null)
                {
                    onMarkAllAsRead(mAccount, mFolderName);
                }
                return true;

            case R.id.folder_settings:
                if (mFolderName != null)
                {
                    FolderSettings.actionSettings(this, mAccount, mFolderName);
                }
                return true;

            case R.id.account_settings:
                onEditAccount();

                return true;

            case R.id.batch_copy_op:
                onCopyBatch();
                return true;

            case R.id.batch_move_op:
                onMoveBatch();
                return true;

           
            case R.id.expunge:
                if (mCurrentFolder != null)
                {
                    onExpunge(mAccount, mCurrentFolder.name);
                }
                return true;

            default:
                return super.onOptionsItemSelected(item);
        }
    }

    private final int[] batch_ops = { R.id.batch_copy_op, R.id.batch_delete_op, R.id.batch_flag_op,
                                      R.id.batch_unflag_op, R.id.batch_mark_read_op, R.id.batch_mark_unread_op, R.id.batch_move_op ,
                                      R.id.batch_select_all, R.id.batch_deselect_all
                                    };


    private void setOpsState(Menu menu, boolean state, boolean enabled)
    {
        for (int id : batch_ops)
        {
            menu.findItem(id).setVisible(state);
            menu.findItem(id).setEnabled(enabled);
        }
    }


    @Override
    public boolean onPrepareOptionsMenu(Menu menu)
    {
        boolean anySelected = anySelected();
        setOpsState(menu, true, anySelected);
        
        if (mQueryString != null)
        {
            menu.findItem(R.id.mark_all_as_read).setVisible(false);
            menu.findItem(R.id.folder_settings).setVisible(false);
            menu.findItem(R.id.account_settings).setVisible(false);
            menu.findItem(R.id.list_folders).setVisible(false);
            menu.findItem(R.id.expunge).setVisible(false);
            menu.findItem(R.id.batch_move_op).setVisible(false);
            menu.findItem(R.id.batch_copy_op).setVisible(false);
            menu.findItem(R.id.check_mail).setVisible(false);
            menu.findItem(R.id.send_messages).setVisible(false);
        }
        else
        {
            if (mCurrentFolder != null && mCurrentFolder.outbox)
            {
                menu.findItem(R.id.check_mail).setVisible(false);
            }
            else
            {
                menu.findItem(R.id.send_messages).setVisible(false);
            }

            if (mCurrentFolder != null && K9.ERROR_FOLDER_NAME.equals(mCurrentFolder.name))
            {
                menu.findItem(R.id.expunge).setVisible(false);
            }
        }

        boolean newFlagState = computeBatchDirection(true);
        boolean newReadState = computeBatchDirection(false);
        menu.findItem(R.id.batch_flag_op).setVisible(newFlagState);
        menu.findItem(R.id.batch_unflag_op).setVisible(!newFlagState);
        menu.findItem(R.id.batch_mark_read_op).setVisible(newReadState);
        menu.findItem(R.id.batch_mark_unread_op).setVisible(!newReadState);
        menu.findItem(R.id.batch_deselect_all).setVisible(anySelected);
        menu.findItem(R.id.batch_select_all).setEnabled(true);

        return true;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu)
    {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.message_list_option, menu);



        return true;
    }

    @Override
    public boolean onContextItemSelected(MenuItem item)
    {
        AdapterContextMenuInfo info = (AdapterContextMenuInfo) item .getMenuInfo();
        MessageInfoHolder holder = (MessageInfoHolder) mAdapter.getItem(info.position);

        switch (item.getItemId())
        {
            case R.id.open:
                onOpenMessage(holder);
                break;

            case R.id.select:
                setSelected(holder, true);
                break;

            case R.id.deselect:
                setSelected(holder, false);
                break;

            case R.id.delete:
                onDelete(holder, info.position);
                break;

            case R.id.reply:
                onReply(holder);
                break;

            case R.id.reply_all:
                onReplyAll(holder);

                break;

            case R.id.forward:
                onForward(holder);

                break;

            case R.id.mark_as_read:
                onToggleRead(holder);

                break;

            case R.id.flag:
                onToggleFlag(holder);

                break;

            case R.id.move:
                onMove(holder);

                break;

            case R.id.copy:
                onCopy(holder);

                break;

            case R.id.send_alternate:
                onSendAlternate(mAccount, holder);

                break;

        }

        return super.onContextItemSelected(item);
    }

    public void onSendAlternate(Account account, MessageInfoHolder holder)
    {
        mController.sendAlternate(this, account, holder.message);
    }

    public void showProgressIndicator(boolean status)
    {
        setProgressBarIndeterminateVisibility(status);
        ProgressBar bar = (ProgressBar)mListView.findViewById(R.id.message_list_progress);
        if (bar == null)
        {
            return;
        }

        bar.setIndeterminate(true);
        if (status)
        {
            bar.setVisibility(bar.VISIBLE);
        }
        else
        {
            bar.setVisibility(bar.INVISIBLE);

        }
    }

    class MyGestureDetector extends SimpleOnGestureListener
    {


        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)
        {

            if (e2 == null || e1 == null)
                return true;

            float deltaX = e2.getX() - e1.getX(),
                           deltaY = e2.getY() - e1.getY();

            boolean movedAcross = (Math.abs(deltaX) > Math.abs(deltaY * 4));
            boolean steadyHand = (Math.abs(deltaX / deltaY) > 2);

            if (movedAcross && steadyHand)
            {
                boolean selected = (deltaX > 0);
                int position = mListView.pointToPosition((int)e1.getX(), (int)e1.getY());

                if (position != AdapterView.INVALID_POSITION)
                {
                    MessageInfoHolder msgInfoHolder = (MessageInfoHolder) mAdapter.getItem(position);

                    if (msgInfoHolder != null)
                    {
                        msgInfoHolder.selected = selected;
                        mSelectedCount += (selected ? 1 : -1);
                        mAdapter.notifyDataSetChanged();
                        toggleBatchButtons();
                    }
                }
            }

            return false;
        }
    }

    @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)
    {
        super.onCreateContextMenu(menu, v, menuInfo);


        AdapterContextMenuInfo info = (AdapterContextMenuInfo) menuInfo;
        MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(info.position);

        if (message == null)
        {
            return;
        }

        getMenuInflater().inflate(R.menu.message_list_context, menu);

        menu.setHeaderTitle((CharSequence) message.subject);

        if (message.read)
        {
            menu.findItem(R.id.mark_as_read).setTitle(R.string.mark_as_unread_action);
        }

        if (message.flagged)
        {
            menu.findItem(R.id.flag).setTitle(R.string.unflag_action);
        }

        if (mController.isCopyCapable(message.account) == false)
        {
            menu.findItem(R.id.copy).setVisible(false);
        }

        if (mController.isMoveCapable(message.account) == false)
        {
            menu.findItem(R.id.move).setVisible(false);
        }
        if (message.selected)
        {
            menu.findItem(R.id.select).setVisible(false);
            menu.findItem(R.id.deselect).setVisible(true);
        }
        else
        {
            menu.findItem(R.id.select).setVisible(true);
            menu.findItem(R.id.deselect).setVisible(false);
        }

    }

    class MessageListAdapter extends BaseAdapter
    {
        private List<MessageInfoHolder> messages = java.util.Collections.synchronizedList(new ArrayList<MessageInfoHolder>());

        private ActivityListener mListener = new ActivityListener()
        {

            @Override
            public void synchronizeMailboxStarted(Account account, String folder)
            {
                super.synchronizeMailboxStarted(account, folder);

                if (updateForMe(account, folder))
                {
                    mHandler.progress(true);
                    mHandler.folderLoading(folder, true);
                }
                mHandler.refreshTitle();
            }



            @Override
            public void synchronizeMailboxFinished(Account account, String folder,
                                                   int totalMessagesInMailbox, int numNewMessages)
            {
                super.synchronizeMailboxFinished(account, folder, totalMessagesInMailbox, numNewMessages);

                if (updateForMe(account, folder))
                {
                    mHandler.progress(false);
                    mHandler.folderLoading(folder, false);
                    mHandler.sortMessages();
                }
                mHandler.refreshTitle();
            }

            @Override
            public void synchronizeMailboxFailed(Account account, String folder, String message)
            {
                super.synchronizeMailboxFailed(account, folder, message);

                if (updateForMe(account, folder))
                {
                    mHandler.progress(false);
                    mHandler.folderLoading(folder, false);
                    mHandler.sortMessages();
                }
                mHandler.refreshTitle();
            }

            @Override
            public void sendPendingMessagesStarted(Account account)
            {
                super.sendPendingMessagesStarted(account);
                mHandler.refreshTitle();
            }

            @Override
            public void sendPendingMessagesCompleted(Account account)
            {
                super.sendPendingMessagesCompleted(account);
                mHandler.refreshTitle();
            }

            @Override
            public void sendPendingMessagesFailed(Account account)
            {
                super.sendPendingMessagesFailed(account);
                mHandler.refreshTitle();
            }

            @Override
            public void synchronizeMailboxProgress(Account account, String folder, int completed, int total)
            {
                super.synchronizeMailboxProgress(account, folder, completed, total);
                mHandler.refreshTitle();
            }


            @Override
            public void synchronizeMailboxAddOrUpdateMessage(Account account, String folder, Message message)
            {
                // eventually, we may want to check a message added during sync against the query filter
                if (mQueryString == null)
                {
                    addOrUpdateMessage(account, folder, message);
                }
            }


            @Override
            public void synchronizeMailboxRemovedMessage(Account account, String folder,Message message)
            {
                MessageInfoHolder holder = getMessage(message.getUid());
                if (holder == null)
                {
                    Log.w(K9.LOG_TAG, ""Got callback to remove non-existent message with UID "" + message.getUid());
                }
                else
                {
                    removeMessage(holder);
                }
            }

            @Override
            public void listLocalMessagesStarted(Account account, String folder)
            {
                if ((mQueryString != null && folder == null) ||
                        (account != null && account.equals(mAccount))
                   )
                {
                    mHandler.progress(true);
                    if (folder != null)
                    {
                        mHandler.folderLoading(folder, true);
                    }
                }
            }

            @Override
            public void listLocalMessagesFailed(Account account, String folder, String message)
            {
                if ((mQueryString != null && folder == null) ||
                        (account != null && account.equals(mAccount)))
                {
                    mHandler.sortMessages();
                    mHandler.progress(false);
                    if (folder != null)
                    {
                        mHandler.folderLoading(folder, false);
                    }
                }

            }

            @Override
            public void listLocalMessagesFinished(Account account, String folder)
            {
                if ((mQueryString != null && folder == null) ||
                        (account != null && account.equals(mAccount)))
                {
                    mHandler.sortMessages();
                    mHandler.progress(false);
                    if (folder != null)
                    {
                        mHandler.folderLoading(folder, false);
                    }
                }

            }

            @Override
            public void listLocalMessagesRemoveMessage(Account account, String folder,Message message)
            {
                if (updateForMe(account, folder))
                {
                    MessageInfoHolder holder = getMessage(message.getUid());
                    if (holder != null)
                    {
                        removeMessage(getMessage(message.getUid()));
                    }
                }
            }


            @Override
            public void listLocalMessagesAddMessages(Account account, String folder, List<Message> messages)
            {
                addOrUpdateMessages(account, folder, messages);
            }

            @Override
            public void listLocalMessagesUpdateMessage(Account account, String folder, Message message)
            {
                addOrUpdateMessage(account, folder, message);
            }
            @Override
            public void folderStatusChanged(Account account, String folder, int unreadMessageCount)
            {
                super.folderStatusChanged(account, folder, unreadMessageCount);
                if (updateForMe(account, folder))
                {
                    mUnreadMessageCount = unreadMessageCount;
                    mHandler.refreshTitle();
                }
            }



            public void pendingCommandsProcessing(Account account)
            {
                super.pendingCommandsProcessing(account);
                mHandler.refreshTitle();
            }
            public void pendingCommandsFinished(Account account)
            {
                super.pendingCommandsFinished(account);
                mHandler.refreshTitle();
            }
            public void pendingCommandStarted(Account account, String commandTitle)
            {
                super.pendingCommandStarted(account, commandTitle);
                mHandler.refreshTitle();
            }
            public void pendingCommandCompleted(Account account, String commandTitle)
            {
                super.pendingCommandCompleted(account, commandTitle);
                mHandler.refreshTitle();
            }
            public void messageUidChanged(Account account, String folder, String oldUid, String newUid)
            {
                if (updateForMe(account, folder))
                {
                    MessageInfoHolder holder = getMessage(oldUid);
                    if (holder != null)
                    {
                        holder.uid = newUid;
                        holder.message.setUid(newUid);
                    }
                }
            }

        };



        private boolean updateForMe(Account account, String folder)
        {
            if (mQueryString != null || (account.equals(mAccount) && mFolderName != null && folder.equals(mFolderName)))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        private Drawable mAttachmentIcon;
        private Drawable mAnsweredIcon;
        private View footerView = null;

        MessageListAdapter()
        {
            mAttachmentIcon = getResources().getDrawable(R.drawable.ic_mms_attachment_small);
            mAnsweredIcon = getResources().getDrawable(R.drawable.ic_mms_answered_small);
        }

        public void removeMessages(List<MessageInfoHolder> holders)
        {
            if (holders != null)
            {
                mHandler.removeMessage(holders);
            }


        }

        public void removeMessage(MessageInfoHolder holder)
        {
            List<MessageInfoHolder> messages = new ArrayList<MessageInfoHolder>();
            messages.add(holder);
            removeMessages(messages);
        }

        private void addOrUpdateMessage(Account account, String folder, Message message)
        {
            List<Message> messages = new ArrayList<Message>();
            messages.add(message);
            addOrUpdateMessages(account, folder, messages);

        }

        private void addOrUpdateMessages(Account account, String folder, List<Message> messages)
        {
            boolean needsSort = false;
            List<MessageInfoHolder> messagesToAdd = new ArrayList<MessageInfoHolder>();
            List<MessageInfoHolder> messagesToRemove = new ArrayList<MessageInfoHolder>();

            for (Message message : messages)
            {
                if (updateForMe(account, folder))
                {
                    MessageInfoHolder m = getMessage(message.getUid());
                    if (message.isSet(Flag.DELETED))
                    {
                        if (m != null)
                        {
                            messagesToRemove.add(m);
                        }
                    }
                    else if (m == null)
                    {
                        m = new MessageInfoHolder(message, account);
                        messagesToAdd.add(m);
                    }
                    else
                    {
                        m.populate(message, new FolderInfoHolder(message.getFolder(), account), account);
                        needsSort = true;
                    }
                }
            }

            if (messagesToRemove.size() > 0)
            {
                removeMessages(messagesToRemove);
            }
            if (messagesToAdd.size() > 0)
            {
                mHandler.addMessages(messagesToAdd);
            }
            if (needsSort)
            {
                mHandler.sortMessages();
            }
        }

        // XXX TODO - make this not use a for loop
        public MessageInfoHolder getMessage(String messageUid)
        {
            MessageInfoHolder searchHolder = new MessageInfoHolder();
            searchHolder.uid = messageUid;
            int index = mAdapter.messages.indexOf((Object) searchHolder);
            if (index >= 0)
            {
                return (MessageInfoHolder)mAdapter.messages.get(index);
            }
            return null;
        }

        public FolderInfoHolder getFolder(String folder, Account account)
        {
            LocalFolder local_folder = null;
            try
            {
                LocalStore localStore = account.getLocalStore();
                local_folder = localStore.getFolder(folder);
                return new FolderInfoHolder((Folder)local_folder, account);
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""getFolder("" + folder + "") goes boom: "",e);
                return null;
            }
            finally
            {
                if (local_folder != null)
                {
                    local_folder.close();
                }
            }
        }

        private static final int NON_MESSAGE_ITEMS = 1;
        public int getCount()
        {
            if (mAdapter.messages == null || mAdapter.messages.size() == 0)
            {
                return NON_MESSAGE_ITEMS ;
            }

            return mAdapter.messages.size() +NON_MESSAGE_ITEMS  ;
        }

        public long getItemId(int position)
        {
            try
            {
                MessageInfoHolder messageHolder =(MessageInfoHolder) getItem(position);
                if (messageHolder != null)
                {
                    return ((LocalStore.LocalMessage)  messageHolder.message).getId();
                }
            }
            catch (Exception e)
            {
                Log.i(K9.LOG_TAG,""getItemId(""+position+"") "",e);
            }
            return -1;
        }

        public Object getItem(long position)
        {
            return getItem((int)position);
        }

        public Object getItem(int position)
        {
            try
            {
                if (position < mAdapter.messages.size())
                {
                    return mAdapter.messages.get(position);
                }
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""getItem("" + position + ""), but folder.messages.size() = "" + mAdapter.messages.size(), e);
            }
            return null;
        }

        public View getView(int position, View convertView, ViewGroup parent)
        {

            if (position == mAdapter.messages.size())
            {
                return getFooterView(position, convertView, parent);
            }
            else
            {
                return  getItemView(position, convertView, parent);
            }
        }


        public View getItemView(int position, View convertView, ViewGroup parent)
        {
            MessageInfoHolder message = (MessageInfoHolder) getItem(position);
            View view;

            if ((convertView != null) && (convertView.getId() == R.layout.message_list_item))
            {
                view = convertView;
            }
            else
            {
                if (mTouchView)
                {
                    view = mInflater.inflate(R.layout.message_list_item_touchable, parent, false);
                    view.setId(R.layout.message_list_item);
                }

                else
                {
                    view = mInflater.inflate(R.layout.message_list_item, parent, false);
                    view.setId(R.layout.message_list_item);
                }
            }


            MessageViewHolder holder = (MessageViewHolder) view.getTag();

            if (holder == null)
            {
                holder = new MessageViewHolder();
                holder.subject = (TextView) view.findViewById(R.id.subject);
                holder.from = (TextView) view.findViewById(R.id.from);
                holder.date = (TextView) view.findViewById(R.id.date);
                holder.chip = view.findViewById(R.id.chip);
                holder.preview = (TextView) view.findViewById(R.id.preview);
                holder.selected = (CheckBox) view.findViewById(R.id.selected_checkbox);
                holder.flagged = (CheckBox) view.findViewById(R.id.flagged);
                holder.flagged.setOnClickListener(new OnClickListener()
                {
                    public void onClick(View v)
                    {
                        // Perform action on clicks
                        MessageInfoHolder message = (MessageInfoHolder) getItem((Integer)v.getTag());
                        onToggleFlag(message);
                    }
                });

                if (mStars == false)
                    holder.flagged.setVisibility(View.GONE);

                if (mCheckboxes == true)
                    holder.selected.setVisibility(View.VISIBLE);



                if (holder.selected!=null)
                {
                    holder.selected.setOnCheckedChangeListener(holder);
                }
                view.setTag(holder);
            }


            if (message != null)
            {

                holder.subject.setTypeface(null, message.read ? Typeface.NORMAL  : Typeface.BOLD);

                // XXX TODO there has to be some way to walk our view hierarchy and get this
                holder.flagged.setTag((Integer)position);


                holder.flagged.setChecked(message.flagged);
                //So that the mSelectedCount is only incremented/decremented
                //when a user checks the checkbox (vs code)
                holder.position = -1;
                holder.selected.setChecked(message.selected);

                if (!mCheckboxes)
                {
                    if (message.selected == true)
                    {
                        holder.selected.setVisibility(View.VISIBLE);
                    }
                    else
                    {
                        holder.selected.setVisibility(View.GONE);
                    }
                }
                holder.chip.setBackgroundResource(K9.COLOR_CHIP_RES_IDS[message.account.getAccountNumber() % K9.COLOR_CHIP_RES_IDS.length]);
                holder.chip.getBackground().setAlpha(message.read ? 127 : 255);

                if (message.downloaded)
                {
                    view.getBackground().setAlpha(0);
                }
                else
                {
                    view.getBackground().setAlpha(127);
                }

                holder.subject.setText(message.subject);

                if (holder.preview != null)
                {
                    // in the touchable UI, we have previews
                    // otherwise, we have just a ""from"" line
                    // because text views can't wrap around each other(?)
                    // we compose a custom view containing the preview and the
                    // from


                    holder.preview.setText(message.sender+  "" "" + message.preview, TextView.BufferType.SPANNABLE);
                    Spannable str = (Spannable)holder.preview.getText();

// Create our span sections, and assign a format to each.
                    str.setSpan(new TextAppearanceSpan(null ,Typeface.BOLD ,-1, holder.subject.getTextColors(), holder.subject.getLinkTextColors()), 0, message.sender.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);


                }
                else
                {
                    holder.from.setText(message.sender);
                    holder.from.setTypeface(null, message.read ? Typeface.NORMAL : Typeface.BOLD);

                }

                holder.date.setText(message.date);
                holder.subject.setCompoundDrawablesWithIntrinsicBounds(
                    message.answered ? mAnsweredIcon : null, // left
                    null, // top
                    message.hasAttachments ? mAttachmentIcon : null, // right
                    null); // bottom
                holder.position = position;
            }
            else
            {
                holder.chip.getBackground().setAlpha(0);
                holder.subject.setText(""No subject"");
                holder.subject.setTypeface(null, Typeface.NORMAL);
                if (holder.preview != null)
                {
                    holder.preview.setText(""No sender"");
                    holder.preview.setTypeface(null, Typeface.NORMAL);
                    holder.preview.setCompoundDrawablesWithIntrinsicBounds(null, null, null, null);
                }
                else
                {
                    holder.from.setText(""No sender"");
                    holder.from.setTypeface(null, Typeface.NORMAL);
                    holder.from.setCompoundDrawablesWithIntrinsicBounds(null, null, null, null);

                }


                holder.date.setText(""No date"");
                //WARNING: Order of the next 2 lines matter
                holder.position = -1;
                holder.selected.setChecked(false);
                if (!mCheckboxes)
                    holder.selected.setVisibility(View.GONE);
                holder.flagged.setChecked(false);
            }
            return view;
        }

        public View getFooterView(int position, View convertView, ViewGroup parent)
        {
            if (footerView == null)
            {
                footerView = mInflater.inflate(R.layout.message_list_item_footer, parent, false);
                if (mQueryString != null)
                {
                    footerView.setVisibility(View.GONE);
                }
                footerView.setId(R.layout.message_list_item_footer);
                FooterViewHolder holder = new FooterViewHolder();
                holder.progress = (ProgressBar)footerView.findViewById(R.id.message_list_progress);
                holder.progress.setIndeterminate(true);
                holder.main = (TextView)footerView.findViewById(R.id.main_text);
                footerView.setTag(holder);
            }

            FooterViewHolder holder = (FooterViewHolder)footerView.getTag();

            if (mCurrentFolder != null && mCurrentFolder.loading)
            {
                holder.main.setText(getString(R.string.status_loading_more));
                holder.progress.setVisibility(ProgressBar.VISIBLE);
            }
            else
            {
                if (mCurrentFolder != null && mCurrentFolder.lastCheckFailed == false)
                {
                    holder.main.setText(String.format(getString(R.string.load_more_messages_fmt), mAccount.getDisplayCount()));
                }
                else
                {
                    holder.main.setText(getString(R.string.status_loading_more_failed));
                }
                holder.progress.setVisibility(ProgressBar.INVISIBLE);
            }

            return footerView;
        }

        public boolean hasStableIds()
        {
            return true;
        }

        public boolean isItemSelectable(int position)
        {
            if (position < mAdapter.messages.size())
            {
                return true;
            }
            else
            {
                return false;
            }
        }

    }

    public class MessageInfoHolder implements Comparable<MessageInfoHolder>
    {
        public String subject;

        public String date;

        public Date compareDate;

        public String compareSubject;

        public String sender;

        public String compareCounterparty;

        public String preview;

        public String[] recipients;

        public boolean hasAttachments;

        public String uid;

        public boolean read;

        public boolean answered;

        public boolean flagged;

        public boolean downloaded;

        public boolean partially_downloaded;

        public Message message;

        public Account account;

        public FolderInfoHolder folder;

        public boolean selected;

        // Empty constructor for comparison
        public MessageInfoHolder()
        {
            this.selected = false;
        }

        public MessageInfoHolder(Message m, Account account)
        {
            this();
            populate(m, new FolderInfoHolder(m.getFolder(), account), account);
        }

        public MessageInfoHolder(Message m, FolderInfoHolder folder, Account account)
        {
            this();
            populate(m, folder, account);
        }

        public void populate(Message m, FolderInfoHolder folder, Account account)
        {

            try
            {
                LocalMessage message = (LocalMessage) m;
                Date date = message.getSentDate();
                this.compareDate = date;
                this.folder = folder;

                if (Utility.isDateToday(date))
                {
                    this.date = getTimeFormat().format(date);
                }
                else
                {
                    this.date = getDateFormat().format(date);
                }


                this.hasAttachments = message.getAttachmentCount() > 0;

                this.read = message.isSet(Flag.SEEN);
                this.answered = message.isSet(Flag.ANSWERED);
                this.flagged = message.isSet(Flag.FLAGGED);
                this.downloaded = message.isSet(Flag.X_DOWNLOADED_FULL);
                this.partially_downloaded = message.isSet(Flag.X_DOWNLOADED_PARTIAL);

                Address[] addrs = message.getFrom();

                if (addrs.length > 0 &&  account.isAnIdentity(addrs[0]))
                {
                    this.compareCounterparty = Address.toFriendly(message .getRecipients(RecipientType.TO));
                    this.sender = String.format(getString(R.string.message_list_to_fmt), this.compareCounterparty);
                }
                else
                {
                    this.sender = Address.toFriendly(addrs);
                    this.compareCounterparty = this.sender;
                }

                this.subject = message.getSubject();

                this.uid = message.getUid();
                this.message = m;
                this.account = account;
                this.preview = message.getPreview();

            }
            catch (MessagingException me)
            {
                if (Config.LOGV)
                {
                    Log.v(K9.LOG_TAG, ""Unable to load message info"", me);
                }
            }
        }

        public boolean equals(Object o)
        {
            if (this.uid.equals(((MessageInfoHolder)o).uid))
            {
                return true;
            }
            else
            {
                return false;
            }
        }


        public int compareTo(MessageInfoHolder o)
        {
            int ascender = (sortAscending ? 1 : -1);
            int comparison = 0;

            if (sortType == SORT_TYPE.SORT_SUBJECT)
            {
                if (compareSubject == null)
                {
                    compareSubject = stripPrefixes(subject).toLowerCase();
                }

                if (o.compareSubject == null)
                {
                    o.compareSubject = stripPrefixes(o.subject).toLowerCase();
                }

                comparison = this.compareSubject.compareTo(o.compareSubject);
            }
            else if (sortType == SORT_TYPE.SORT_SENDER)
            {
                comparison = this.compareCounterparty.toLowerCase().compareTo(o.compareCounterparty.toLowerCase());
            }
            else if (sortType == SORT_TYPE.SORT_FLAGGED)
            {
                comparison = (this.flagged ? 0 : 1) - (o.flagged ? 0 : 1);

            }
            else if (sortType == SORT_TYPE.SORT_UNREAD)
            {
                comparison = (this.read ? 1 : 0) - (o.read ? 1 : 0);
            }
            else if (sortType == SORT_TYPE.SORT_ATTACHMENT)
            {
                comparison = (this.hasAttachments ? 0 : 1) - (o.hasAttachments ? 0 : 1);

            }

            if (comparison != 0)
            {
                return comparison * ascender;
            }

            int dateAscender = (sortDateAscending ? 1 : -1);


            return this.compareDate.compareTo(o.compareDate) * dateAscender;
        }

        Pattern pattern = null;
        String patternString = ""^ *(re|aw|fw|fwd): *"";
        private String stripPrefixes(String in)
        {
            synchronized (patternString)
            {
                if (pattern == null)
                {
                    pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
                }
            }

            Matcher matcher = pattern.matcher(in);

            int lastPrefix = -1;

            while (matcher.find())
            {
                lastPrefix = matcher.end();
            }

            if (lastPrefix > -1 && lastPrefix < in.length() - 1)
            {
                return in.substring(lastPrefix);
            }
            else
            {
                return in;
            }
        }

    }

    class MessageViewHolder
            implements OnCheckedChangeListener
    {
        public TextView subject;
        public TextView preview;
        public TextView from;
        public TextView time;
        public TextView date;
        public CheckBox flagged;
        public View chip;
        public CheckBox selected;
        public int position = -1;

        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
        {
            if (position!=-1)
            {
                MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(position);
                if (message.selected!=isChecked)
                {
                    if (isChecked)
                    {
                        mSelectedCount++;
                    }
                    else if (mSelectedCount > 0)
                    {
                        mSelectedCount--;
                    }
                    //We must set the flag before showing the buttons
                    //as the buttons text depends on what is selected
                    message.selected = isChecked;
                    if (!mCheckboxes)
                    {
                        if (isChecked == true)
                        {
                            selected.setVisibility(View.VISIBLE);
                        }
                        else
                        {
                            selected.setVisibility(View.GONE);
                        }
                    }
                    toggleBatchButtons();
                }
            }
        }
    }

    private void hideBatchButtons()
    {
        //TODO: Fade out animation
        mBatchButtonArea.setVisibility(View.GONE);
    }
    private void showBatchButtons()
    {
        //TODO: Fade in animation
        mBatchButtonArea.setVisibility(View.VISIBLE);
    }

    private void toggleBatchButtons()
    {
        if (mSelectedCount < 0)
        {
            mSelectedCount = 0;
        }

        int readButtonStringId;
        int flagButtonStringId;

        if (mSelectedCount==0)
        {
            readButtonStringId = R.string.message_list_mark_read_action;
            flagButtonStringId = R.string.message_list_flag_action;
            hideBatchButtons();
        }
        else
        {
            boolean newReadState = computeBatchDirection(false);
            if (newReadState)
            {
                readButtonStringId = R.string.message_list_mark_read_action;
            }
            else
            {
                readButtonStringId = R.string.message_list_mark_unread_action;
            }
            boolean newFlagState = computeBatchDirection(true);
            if (newFlagState)
            {
                flagButtonStringId = R.string.message_list_flag_action;
            }
            else
            {
                flagButtonStringId = R.string.message_list_unflag_action;
            }
            showBatchButtons();
        }

        mBatchReadButton.setText(readButtonStringId);
        mBatchFlagButton.setText(flagButtonStringId);
    }

    class FooterViewHolder
    {
        public ProgressBar progress;
        public TextView main;
    }

    public class FolderInfoHolder
    {
        public String name;

        public String displayName;

        public boolean loading;

        public boolean lastCheckFailed;

        public Folder folder;

        /**
         * Outbox is handled differently from any other folder.
         */
        public boolean outbox;

        public FolderInfoHolder(Folder folder, Account account)
        {
            populate(folder, account);
        }
        public void populate(Folder folder, Account account)
        {
            this.folder = folder;
            this.name = folder.getName();

            if (this.name.equalsIgnoreCase(K9.INBOX))
            {
                this.displayName = getString(R.string.special_mailbox_name_inbox);
            }
            else
            {
                this.displayName = this.name;
            }

            if (this.name.equals(account.getOutboxFolderName()))
            {
                this.displayName = String.format(getString(R.string.special_mailbox_name_outbox_fmt), this.name);
                this.outbox = true;
            }

            if (this.name.equals(account.getDraftsFolderName()))
            {
                this.displayName = String.format(getString(R.string.special_mailbox_name_drafts_fmt), this.name);
            }

            if (this.name.equals(account.getTrashFolderName()))
            {
                this.displayName = String.format(getString(R.string.special_mailbox_name_trash_fmt), this.name);
            }

            if (this.name.equals(account.getSentFolderName()))
            {
                this.displayName = String.format(getString(R.string.special_mailbox_name_sent_fmt), this.name);
            }
        }
    }

    private boolean computeBatchDirection(boolean flagged)
    {
        boolean newState = false;

        for (MessageInfoHolder holder : mAdapter.messages)
        {
            if (holder.selected)
            {
                if (flagged)
                {
                    if (!holder.flagged)
                    {
                        newState = true;
                    }
                }
                else
                {
                    if (!holder.read)
                    {
                        newState = true;
                    }
                }
            }
        }
        return newState;
    }

    private boolean anySelected()
    {
        for (MessageInfoHolder holder : mAdapter.messages)
        {
            if (holder.selected)
            {
                return true;
            }
        }
        return false;
    }

    public void onClick(View v)
    {
        boolean newState = false;
        List<Message> messageList = new ArrayList<Message>();
        List<MessageInfoHolder> removeHolderList = new ArrayList<MessageInfoHolder>();

        if (v == mBatchDoneButton)
        {
            setAllSelected(false);
            return;
        }

        if (v == mBatchFlagButton)
        {
            newState = computeBatchDirection(true);
        }
        else
        {
            newState = computeBatchDirection(false);
        }
        for (MessageInfoHolder holder : mAdapter.messages)
        {

            if (holder.selected)
            {
                if (v == mBatchDeleteButton)
                {
                    removeHolderList.add(holder);
                }
                else if (v == mBatchFlagButton)
                {
                    holder.flagged = newState;
                }
                else if (v == mBatchReadButton)
                {
                    holder.read = newState;
                }
                messageList.add(holder.message);
            }
        }
        mAdapter.removeMessages(removeHolderList);

        if (!messageList.isEmpty())
        {
            if (v == mBatchDeleteButton)
            {
                mController.deleteMessages(messageList.toArray(new Message[0]), null);
                mSelectedCount = 0;
                toggleBatchButtons();
            }
            else
            {
                mController.setFlag(messageList.toArray(new Message[0]), (v == mBatchReadButton ? Flag.SEEN : Flag.FLAGGED), newState);
            }
        }
        else
        {
            //Should not happen
            Toast.makeText(this, R.string.no_message_seletected_toast, Toast.LENGTH_SHORT).show();
        }
        mHandler.sortMessages();
    }

    private void setAllSelected(boolean isSelected)
    {
        mSelectedCount = 0;
        for (MessageInfoHolder holder : mAdapter.messages)
        {
            holder.selected = isSelected;
            mSelectedCount += (isSelected ? 1 : 0);
        }
        mAdapter.notifyDataSetChanged();
        toggleBatchButtons();
    }

    private void setSelected(MessageInfoHolder holder, boolean newState)
    {

        if (holder.selected != newState)
        {
            holder.selected = newState;
            mSelectedCount += (newState ? 1 : -1);
        }
        mAdapter.notifyDataSetChanged();
        toggleBatchButtons();

    }


    private void flagSelected(Flag flag, boolean newState)
    {
        List<Message> messageList = new ArrayList<Message>();
        for (MessageInfoHolder holder : mAdapter.messages)
        {
            if (holder.selected)
            {
                messageList.add(holder.message);
                if (flag == Flag.SEEN)
                {
                    holder.read = newState;
                }
                else if (flag == Flag.FLAGGED)
                {
                    holder.flagged = newState;
                }
            }
        }
        mController.setFlag(messageList.toArray(new Message[0]), flag, newState);
        mHandler.sortMessages();
    }

    private void deleteSelected()
    {
        List<Message> messageList = new ArrayList<Message>();
        List<MessageInfoHolder> removeHolderList = new ArrayList<MessageInfoHolder>();
        for (MessageInfoHolder holder : mAdapter.messages)
        {
            if (holder.selected)
            {
                removeHolderList.add(holder);
                messageList.add(holder.message);
            }
        }
        mAdapter.removeMessages(removeHolderList);

        mController.deleteMessages(messageList.toArray(new Message[0]), null);
        mSelectedCount = 0;
        toggleBatchButtons();
    }
    
    private void onMoveBatch()
    {
        if (mController.isMoveCapable(mAccount) == false)
        {
            return;
        }
        for (MessageInfoHolder holder : mAdapter.messages)
        {
            if (holder.selected)
            {
                Message message = holder.message;
                if (mController.isMoveCapable(message) == false)
                {
                    Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
                    toast.show();
                    return;
                }
            }
        }
        Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, mCurrentFolder.folder.getName());
        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_MOVE_BATCH);
    }
    private void onMoveChosenBatch(String folderName)
    {
        if (mController.isMoveCapable(mAccount) == false)
        {
            return;
        }
        List<Message> messageList = new ArrayList<Message>();

        List<MessageInfoHolder> removeHolderList = new ArrayList<MessageInfoHolder>();
        for (MessageInfoHolder holder : mAdapter.messages)
        {
            if (holder.selected)
            {
                Message message = holder.message;
                if (mController.isMoveCapable(message) == false)
                {
                    Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
                    toast.show();
                    return;
                }
                messageList.add(holder.message);
                removeHolderList.add(holder);
            }
        }
        mAdapter.removeMessages(removeHolderList);
        
        mController.moveMessages(mAccount, mCurrentFolder.name, messageList.toArray(new Message[0]), folderName, null);
        mSelectedCount = 0;
        toggleBatchButtons();
    }
    private void onCopyBatch()
    {
        if (mController.isCopyCapable(mAccount) == false)
        {
            return;
        }
        for (MessageInfoHolder holder : mAdapter.messages)
        {
            if (holder.selected)
            {
                Message message = holder.message;
                if (mController.isCopyCapable(message) == false)
                {
                    Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
                    toast.show();
                    return;
                }
            }
        }
        Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, mCurrentFolder.folder.getName());
        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_COPY_BATCH);
    }
    private void onCopyChosenBatch(String folderName)
    {
        if (mController.isCopyCapable(mAccount) == false)
        {
            return;
        }
        List<Message> messageList = new ArrayList<Message>();

        for (MessageInfoHolder holder : mAdapter.messages)
        {
            if (holder.selected)
            {
                Message message = holder.message;
                if (mController.isCopyCapable(message) == false)
                {
                    Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
                    toast.show();
                    return;
                }
                messageList.add(holder.message);
            }
        }
        
        mController.copyMessages(mAccount, mCurrentFolder.name, messageList.toArray(new Message[0]), folderName, null);
    }
}
",True,190,1,1,8,54,4,22,L1
32,com.fsck.k9.activity.MessageView.java,"
package com.fsck.k9.activity;

import android.content.Context;
import android.content.Intent;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.Drawable;
import android.media.MediaScannerConnection;
import android.media.MediaScannerConnection.MediaScannerConnectionClient;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.provider.Contacts;
import android.provider.Contacts.Intents;
import android.util.Config;
import android.util.Log;
import android.view.*;
import android.view.View.OnClickListener;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.TranslateAnimation;
import android.webkit.*;
import android.webkit.CacheManager.CacheResult;
import android.widget.*;
import com.fsck.k9.*;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.store.LocalStore.LocalAttachmentBodyPart;
import com.fsck.k9.mail.store.LocalStore.LocalMessage;
import com.fsck.k9.mail.store.LocalStore.LocalTextBody;
import com.fsck.k9.provider.AttachmentProvider;
import org.apache.commons.io.IOUtils;
import java.io.*;
import java.net.HttpURLConnection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MessageView extends K9Activity
        implements UrlInterceptHandler, OnClickListener
{
    private static final String EXTRA_ACCOUNT = ""com.fsck.k9.MessageView_account"";
    private static final String EXTRA_FOLDER = ""com.fsck.k9.MessageView_folder"";
    private static final String EXTRA_MESSAGE = ""com.fsck.k9.MessageView_message"";
    private static final String EXTRA_MESSAGE_UIDS = ""com.fsck.k9.MessageView_messageUids"";
    private static final String EXTRA_NEXT = ""com.fsck.k9.MessageView_next"";

    private static final String CID_PREFIX  = ""http://cid/"";

    private static final int ACTIVITY_CHOOSE_FOLDER_MOVE = 1;

    private static final int ACTIVITY_CHOOSE_FOLDER_COPY = 2;

    private TextView mFromView;
    private TextView mDateView;
    private TextView mTimeView;
    private TextView mToView;
    private TextView mCcView;
    private TextView mSubjectView;
    private CheckBox mFlagged;
    private int defaultSubjectColor;
    private WebView mMessageContentView;
    private LinearLayout mAttachments;
    private View mAttachmentIcon;
    private View mDownloadingIcon;
    private View mShowPicturesSection;
    View next;
    View next_scrolling;
    View previous;
    View previous_scrolling;

    private Account mAccount;
    private String mFolder;
    private String mMessageUid;
    private ArrayList<String> mMessageUids;

    private Message mMessage;

    private static final int PREVIOUS = 1;
    private static final int NEXT = 2;

    private int mLastDirection = PREVIOUS;


    private String mNextMessageUid = null;
    private String mPreviousMessageUid = null;



    private Menu optionsMenu = null;

    private Listener mListener = new Listener();
    private MessageViewHandler mHandler = new MessageViewHandler();


    @Override
    public boolean dispatchKeyEvent(KeyEvent event)
    {
        boolean ret = false;

        if (KeyEvent.ACTION_DOWN == event.getAction())
        {
            ret = onKeyDown(event.getKeyCode(), event);
        }
        if (ret == false)
        {
            ret = super.dispatchKeyEvent(event);
        }
        return ret;
    }

    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        switch (keyCode)
        {
            case KeyEvent.KEYCODE_DEL:
            {
                onDelete();
                return true;
            }
            case KeyEvent.KEYCODE_D:
            {
                onDelete();
                return true;
            }
            case KeyEvent.KEYCODE_F:
            {
                onForward();
                return true;
            }
            case KeyEvent.KEYCODE_A:
            {
                onReplyAll();
                return true;
            }
            case KeyEvent.KEYCODE_R:
            {
                onReply();
                return true;
            }
            case KeyEvent.KEYCODE_G:
            {
                onFlag();
                return true;
            }

            case KeyEvent.KEYCODE_M:
            {
                onMove();
                return true;
            }
            case KeyEvent.KEYCODE_Y:
            {
                onCopy();
                return true;
            }
            case KeyEvent.KEYCODE_J:
            case KeyEvent.KEYCODE_P:
            {
                onPrevious(K9.isAnimations());
                return true;
            }
            case KeyEvent.KEYCODE_N:
            case KeyEvent.KEYCODE_K:
            {
                onNext(K9.isAnimations());
                return true;
            }
            case KeyEvent.KEYCODE_Z:
            {
                if (event.isShiftPressed())
                {
                    mHandler.post(new Runnable()
                    {
                        public void run()
                        {
                            mMessageContentView.zoomIn();
                        }
                    });
                }
                else
                {
                    mHandler.post(new Runnable()
                    {
                        public void run()
                        {
                            mMessageContentView.zoomOut();
                        }
                    });
                }
                return true;
            }
            case KeyEvent.KEYCODE_H:
            {
                Toast toast = Toast.makeText(this, R.string.message_help_key, Toast.LENGTH_LONG);
                toast.show();
                return true;
            }
        }
        return super.onKeyDown(keyCode, event);
    }

    class MessageViewHandler extends Handler
    {
        public void progress(final boolean progress)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    setProgressBarIndeterminateVisibility(progress);

                }
            });
        }

        public void addAttachment(final View attachmentView)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    mAttachments.addView(attachmentView);
                    mAttachments.setVisibility(View.VISIBLE);

                }
            });
        }

        public void setAttachmentsEnabled(final boolean enabled)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    for (int i = 0, count = mAttachments.getChildCount(); i < count; i++)
                    {
                        Attachment attachment = (Attachment) mAttachments.getChildAt(i).getTag();
                        attachment.viewButton.setEnabled(enabled);
                        attachment.downloadButton.setEnabled(enabled);
                    }

                }
            });
        }

        public void setHeaders(
            final   String subject,
            final   String from,
            final   String date,
            final   String time,
            final   String to,
            final   String cc,
            final   boolean hasAttachments,
            final   boolean isDownloading,
            final   boolean flagged,
            final   boolean answered)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    setTitle(subject);
                    mSubjectView.setText(subject);
                    mFromView.setText(from);
                    if (date != null)
                    {
                        mDateView.setText(date);
                        mDateView.setVisibility(View.VISIBLE);
                    }
                    else
                    {
                        mDateView.setVisibility(View.GONE);
                    }
                    mTimeView.setText(time);
                    mToView.setText(to);
                    mCcView.setText(cc);
                    mAttachmentIcon.setVisibility(hasAttachments ? View.VISIBLE : View.GONE);
                    mDownloadingIcon.setVisibility(isDownloading ? View.VISIBLE : View.GONE);
                    if (flagged)
                    {
                        mFlagged.setChecked(true);
                    }
                    else
                    {
                        mFlagged.setChecked(false);
                    }
                    mSubjectView.setTextColor(0xff000000 | defaultSubjectColor);


                    if (answered)
                    {
                        Drawable answeredIcon = getResources().getDrawable(
                                                    R.drawable.ic_mms_answered_small);
                        mSubjectView.setCompoundDrawablesWithIntrinsicBounds(
                            answeredIcon, // left
                            null, // top
                            null, // right
                            null); // bottom
                    }
                    else
                    {
                        mSubjectView.setCompoundDrawablesWithIntrinsicBounds(
                            null, // left
                            null, // top
                            null, // right
                            null); // bottom
                    }


                }
            });
        }

        public void networkError()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    Toast.makeText(MessageView.this,
                                   R.string.status_network_error, Toast.LENGTH_LONG).show();

                }
            });
        }

        public void invalidIdError()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    Toast.makeText(MessageView.this,
                                   R.string.status_invalid_id_error, Toast.LENGTH_LONG).show();

                }
            });
        }

        public void attachmentSaved(final String filename)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    Toast.makeText(MessageView.this, String.format(
                                       getString(R.string.message_view_status_attachment_saved), filename),
                                   Toast.LENGTH_LONG).show();


                }
            });
        }

        public void attachmentNotSaved()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {

                    Toast.makeText(MessageView.this,
                                   getString(R.string.message_view_status_attachment_not_saved),
                                   Toast.LENGTH_LONG).show();

                }
            });
        }

        public void fetchingAttachment()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    Toast.makeText(MessageView.this,
                                   getString(R.string.message_view_fetching_attachment_toast),
                                   Toast.LENGTH_SHORT).show();
                }
            });
        }

        public void showShowPictures(final boolean show)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    mShowPicturesSection.setVisibility(show ? View.VISIBLE : View.GONE);
                }
            });

        }


    }

    class Attachment
    {
        public String name;
        public String contentType;
        public long size;
        public LocalAttachmentBodyPart part;
        public Button viewButton;
        public Button downloadButton;
        public ImageView iconView;
    }

    public static void actionView(Context context, Account account, String folder, String messageUid, ArrayList<String> folderUids)
    {
        actionView(context, account, folder, messageUid, folderUids, null);
    }

    public static void actionView(Context context, Account account, String folder, String messageUid, ArrayList<String> folderUids, Bundle extras)
    {
        Intent i = new Intent(context, MessageView.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_FOLDER, folder);
        i.putExtra(EXTRA_MESSAGE, messageUid);
        i.putExtra(EXTRA_MESSAGE_UIDS, folderUids);
        if (extras != null)
        {
            i.putExtras(extras);
        }
        context.startActivity(i);
    }

    public void onCreate(Bundle icicle)
    {
        super.onCreate(icicle);


        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        requestWindowFeature(Window.FEATURE_NO_TITLE);

        setContentView(R.layout.message_view);


        mFromView = (TextView)findViewById(R.id.from);
        mToView = (TextView)findViewById(R.id.to);
        mCcView = (TextView)findViewById(R.id.cc);
        mSubjectView = (TextView)findViewById(R.id.subject);
        defaultSubjectColor = mSubjectView.getCurrentTextColor();


        mDateView = (TextView)findViewById(R.id.date);
        mTimeView = (TextView)findViewById(R.id.time);
        mTopView = (ScrollView)findViewById(R.id.top_view);
        mMessageContentView = (WebView)findViewById(R.id.message_content);

        mAttachments = (LinearLayout)findViewById(R.id.attachments);
        mAttachmentIcon = findViewById(R.id.attachment);
        mDownloadingIcon = findViewById(R.id.downloading);
        mShowPicturesSection = findViewById(R.id.show_pictures_section);


        mFlagged = (CheckBox)findViewById(R.id.flagged);
        mFlagged.setOnClickListener(new OnClickListener()
        {
            public void onClick(View v)
            {
                onFlag();
            }
        });

        mMessageContentView.setVerticalScrollBarEnabled(true);
        mMessageContentView.setVerticalScrollbarOverlay(true);
        mMessageContentView.setScrollBarStyle(View.SCROLLBARS_INSIDE_OVERLAY);

        final WebSettings webSettings = mMessageContentView.getSettings();

        webSettings.setSupportZoom(true);
        webSettings.setLoadsImagesAutomatically(true);
        //webSettings.setBuiltInZoomControls(true);
        webSettings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.NARROW_COLUMNS);

        mAttachments.setVisibility(View.GONE);
        mAttachmentIcon.setVisibility(View.GONE);

        setOnClickListener(R.id.from);
        setOnClickListener(R.id.reply);
        setOnClickListener(R.id.reply_all);
        setOnClickListener(R.id.delete);
        setOnClickListener(R.id.forward);
        setOnClickListener(R.id.next);
        setOnClickListener(R.id.previous);

        setOnClickListener(R.id.reply_scrolling);
//       setOnClickListener(R.id.reply_all_scrolling);
        setOnClickListener(R.id.delete_scrolling);
        setOnClickListener(R.id.forward_scrolling);
        setOnClickListener(R.id.next_scrolling);
        setOnClickListener(R.id.previous_scrolling);

        setOnClickListener(R.id.show_pictures);


        setTitle("""");

        Intent intent = getIntent();
        Uri uri = intent.getData();

        if (icicle!=null)
        {
            String accountUuid = icicle.getString(EXTRA_ACCOUNT);
            mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
            mFolder = icicle.getString(EXTRA_FOLDER);
            mMessageUid = icicle.getString(EXTRA_MESSAGE);
            mMessageUids = icicle.getStringArrayList(EXTRA_MESSAGE_UIDS);
        }
        else
        {
            if (uri==null)
            {
                String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
                mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
                mFolder = intent.getStringExtra(EXTRA_FOLDER);
                mMessageUid = intent.getStringExtra(EXTRA_MESSAGE);
                mMessageUids = intent.getStringArrayListExtra(EXTRA_MESSAGE_UIDS);
            }
            else
            {
                List<String> segmentList = uri.getPathSegments();
                if (segmentList.size()==3)
                {
                    String accountId = segmentList.get(0);
                    Account[] accounts = Preferences.getPreferences(this).getAccounts();
                    boolean found = false;
                    for (Account account : accounts)
                    {
                        if (String.valueOf(account.getAccountNumber()).equals(accountId))
                        {
                            mAccount = account;
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                    {
                        //TODO: Use ressource to externalize message
                        Toast.makeText(this, ""Invalid account id: "" + accountId, Toast.LENGTH_LONG).show();
                        return;
                    }
                    mFolder = segmentList.get(1);
                    mMessageUid = segmentList.get(2);
                    mMessageUids = new ArrayList<String>();
                }
                else
                {
                    //TODO: Use ressource to externalize message
                    Toast.makeText(this, ""Invalid intent uri: "" + uri.toString(), Toast.LENGTH_LONG).show();
                    return;
                }
            }
        }

        next = findViewById(R.id.next);
        previous = findViewById(R.id.previous);

        setOnClickListener(R.id.next);
        setOnClickListener(R.id.previous);

        next_scrolling = findViewById(R.id.next_scrolling);
        previous_scrolling = findViewById(R.id.previous_scrolling);


        boolean goNext = intent.getBooleanExtra(EXTRA_NEXT, false);
        if (goNext)
        {
            next.requestFocus();
        }

        Account.HideButtons hideButtons = mAccount.getHideMessageViewButtons();

        //MessagingController.getInstance(getApplication()).addListener(mListener);
        if (Account.HideButtons.ALWAYS == hideButtons)
        {
            hideButtons();
        }
        else if (Account.HideButtons.NEVER == hideButtons)
        {
            showButtons();
        }
        else   // Account.HideButtons.KEYBOARD_AVAIL
        {
            final Configuration config = this.getResources().getConfiguration();
            if (config.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO)
            {
                hideButtons();
            }
            else
            {
                showButtons();
            }
        }
        displayMessage(mMessageUid);
    }

    @Override
    protected void onSaveInstanceState(Bundle outState)
    {
        outState.putString(EXTRA_ACCOUNT, mAccount.getUuid());
        outState.putString(EXTRA_FOLDER, mFolder);
        outState.putString(EXTRA_MESSAGE, mMessageUid);
        outState.putStringArrayList(EXTRA_MESSAGE_UIDS, mMessageUids);
    }

    private void displayMessage(String uid)
    {
        mMessageUid = uid;
        mMessageContentView.getSettings().setBlockNetworkImage(true);
        K9.setBlockNetworkLoads(mMessageContentView.getSettings(), true);

        mAttachments.removeAllViews();
        findSurroundingMessagesUid();


        boolean enableNext = (mNextMessageUid != null);
        boolean enablePrev = (mPreviousMessageUid != null);

        if (next.isEnabled() != enableNext)
            next.setEnabled(enableNext);
        if (previous.isEnabled() != enablePrev)
            previous.setEnabled(enablePrev);

        if (next_scrolling != null && (next_scrolling.isEnabled() != enableNext))
            next_scrolling.setEnabled(enableNext);
        if (previous_scrolling != null && (previous_scrolling.isEnabled() != enablePrev))
            previous_scrolling.setEnabled(enablePrev);

        MessagingController.getInstance(getApplication()).loadMessageForView(
            mAccount,
            mFolder,
            mMessageUid,
            mListener);

        mTopView.scrollTo(0, 0);
        mMessageContentView.scrollTo(0, 0);
    }


    private void showButtons()
    {
        View buttons = findViewById(R.id.scrolling_buttons);
        if (buttons != null)
        {
            buttons.setVisibility(View.GONE);
        }
    }

    private void hideButtons()
    {
        View buttons = findViewById(R.id.bottom_buttons);
        if (buttons != null)
        {
            buttons.setVisibility(View.GONE);
        }
    }

    private void setOnClickListener(int viewCode)
    {
        View thisView = findViewById(viewCode);
        if (thisView != null)
        {
            thisView.setOnClickListener(this);
        }
    }

    private void findSurroundingMessagesUid()
    {
        mNextMessageUid = mPreviousMessageUid = null;
        int i = mMessageUids.indexOf(mMessageUid);
        if (i < 0)
            return;
        if (i != 0)
            mNextMessageUid = mMessageUids.get(i - 1);
        if (i != (mMessageUids.size() - 1))
            mPreviousMessageUid = mMessageUids.get(i + 1);
    }

    public void onResume()
    {
        super.onResume();
    }

    private void onDelete()
    {
        if (mMessage != null)
        {
            Message messageToDelete = mMessage;

            findSurroundingMessagesUid();

            // Remove this message's Uid locally
            mMessageUids.remove(messageToDelete.getUid());

            MessagingController.getInstance(getApplication()).deleteMessages(
                new Message[] { messageToDelete },
                null);

            if (mLastDirection == NEXT && mNextMessageUid != null)
            {
                onNext(K9.isAnimations());
            }
            else if (mLastDirection == PREVIOUS && mPreviousMessageUid != null)
            {
                onPrevious(K9.isAnimations());
            }
            else if (mNextMessageUid != null)
            {
                onNext(K9.isAnimations());
            }
            else if (mPreviousMessageUid != null)
            {
                onPrevious(K9.isAnimations());
            }



            else
            {
                finish();
            }
        }
    }

    private void onClickSender()
    {
        if (mMessage != null)
        {
            try
            {
                Address senderEmail = mMessage.getFrom()[0];
                Uri contactUri = Uri.fromParts(""mailto"", senderEmail.getAddress(), null);

                Intent contactIntent = new Intent(Contacts.Intents.SHOW_OR_CREATE_CONTACT);
                contactIntent.setData(contactUri);

                // Pass along full E-mail string for possible create dialog
                contactIntent.putExtra(Contacts.Intents.EXTRA_CREATE_DESCRIPTION,
                                       senderEmail.toString());

                // Only provide personal name hint if we have one
                String senderPersonal = senderEmail.getPersonal();
                if (senderPersonal != null)
                {
                    contactIntent.putExtra(Intents.Insert.NAME, senderPersonal);
                }

                startActivity(contactIntent);
            }
            catch (MessagingException me)
            {
                if (Config.LOGV)
                {
                    Log.v(K9.LOG_TAG, ""loadMessageForViewHeadersAvailable"", me);
                }
            }
        }
    }

    private void onReply()
    {
        if (mMessage != null)
        {
            MessageCompose.actionReply(this, mAccount, mMessage, false);
            finish();
        }
    }

    private void onReplyAll()
    {
        if (mMessage != null)
        {
            MessageCompose.actionReply(this, mAccount, mMessage, true);
            finish();
        }
    }

    private void onForward()
    {
        if (mMessage != null)
        {
            MessageCompose.actionForward(this, mAccount, mMessage);
            finish();
        }
    }

    private void onFlag()
    {
        if (mMessage != null)
        {
            MessagingController.getInstance(getApplication()).setFlag(mAccount,
                    mMessage.getFolder().getName(), new String[] { mMessage.getUid() }, Flag.FLAGGED, !mMessage.isSet(Flag.FLAGGED));
            try
            {
                mMessage.setFlag(Flag.FLAGGED, !mMessage.isSet(Flag.FLAGGED));
                setHeaders(mAccount, mMessage.getFolder().getName(), mMessage.getUid(), mMessage);
                setMenuFlag();
            }
            catch (MessagingException me)
            {
                Log.e(K9.LOG_TAG, ""Could not set flag on local message"", me);
            }
        }
    }

    private void onMove()
    {
        if (MessagingController.getInstance(getApplication()).isMoveCapable(mAccount) == false)
        {
            return;
        }
        if (MessagingController.getInstance(getApplication()).isMoveCapable(mMessage) == false)
        {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }
        Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, mFolder);
        intent.putExtra(ChooseFolder.EXTRA_MESSAGE_UID, mMessageUid);
        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_MOVE);
    }

    private void onCopy()
    {
        if (MessagingController.getInstance(getApplication()).isCopyCapable(mAccount) == false)
        {
            return;
        }
        if (MessagingController.getInstance(getApplication()).isCopyCapable(mMessage) == false)
        {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }
        Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, mFolder);
        intent.putExtra(ChooseFolder.EXTRA_MESSAGE_UID, mMessageUid);
        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_COPY);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        if (resultCode != RESULT_OK)
            return;

        switch (requestCode)
        {
            case ACTIVITY_CHOOSE_FOLDER_MOVE:
            case ACTIVITY_CHOOSE_FOLDER_COPY:
                if (data == null)
                    return;
                String destFolderName = data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER);
                String srcFolderName = data.getStringExtra(ChooseFolder.EXTRA_CUR_FOLDER);
                String uid = data.getStringExtra(ChooseFolder.EXTRA_MESSAGE_UID);

                if (uid.equals(mMessageUid) && srcFolderName.equals(mFolder))
                {

                    switch (requestCode)
                    {
                        case ACTIVITY_CHOOSE_FOLDER_MOVE:
                            MessagingController.getInstance(getApplication()).moveMessage(mAccount,
                                    srcFolderName, mMessage, destFolderName, null);
                            break;
                        case ACTIVITY_CHOOSE_FOLDER_COPY:
                            MessagingController.getInstance(getApplication()).copyMessage(mAccount,
                                    srcFolderName, mMessage, destFolderName, null);
                            break;
                    }
                }
        }
    }


    private void onSendAlternate()
    {
        if (mMessage != null)
        {
            MessagingController.getInstance(getApplication()).sendAlternate(this, mAccount, mMessage);

        }
    }

    @Override
    protected void onNext(boolean animate)
    {
        if (mNextMessageUid == null)
        {
            Toast.makeText(this, getString(R.string.end_of_folder), Toast.LENGTH_SHORT).show();
            return;
        }
        mLastDirection = NEXT;
        if (animate)
        {
            mTopView.startAnimation(outToLeftAnimation());
        }
        displayMessage(mNextMessageUid);
        next.requestFocus();
    }

    protected void onPrevious(boolean animate)
    {
        if (mPreviousMessageUid == null)
        {
            Toast.makeText(this, getString(R.string.end_of_folder), Toast.LENGTH_SHORT).show();
            return;
        }

        mLastDirection = PREVIOUS;
        if (animate)
        {
            mTopView.startAnimation(inFromRightAnimation());
        }
        displayMessage(mPreviousMessageUid);
        previous.requestFocus();
    }

    private void onMarkAsUnread()
    {
        if (mMessage != null)
        {
            MessagingController.getInstance(getApplication()).setFlag(
                mAccount,
                mFolder,
                new String[] { mMessage.getUid() },
                Flag.SEEN,
                false);
        }
    }

    /**
     * Creates a unique file in the given directory by appending a hyphen
     * and a number to the given filename.
     * @param directory
     * @param filename
     * @return
     */
    private File createUniqueFile(File directory, String filename)
    {
        File file = new File(directory, filename);
        if (!file.exists())
        {
            return file;
        }
        // Get the extension of the file, if any.
        int index = filename.lastIndexOf('.');
        String format;
        if (index != -1)
        {
            String name = filename.substring(0, index);
            String extension = filename.substring(index);
            format = name + ""-%d"" + extension;
        }
        else
        {
            format = filename + ""-%d"";
        }
        for (int i = 2; i < Integer.MAX_VALUE; i++)
        {
            file = new File(directory, String.format(format, i));
            if (!file.exists())
            {
                return file;
            }
        }
        return null;
    }

    private void onDownloadAttachment(Attachment attachment)
    {
        if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))
        {
            /*
             * Abort early if there's no place to save the attachment. We don't want to spend
             * the time downloading it and then abort.
             */
            Toast.makeText(this,
                           getString(R.string.message_view_status_attachment_not_saved),
                           Toast.LENGTH_SHORT).show();
            return;
        }
        if (mMessage != null)
        {
            MessagingController.getInstance(getApplication()).loadAttachment(
                mAccount,
                mMessage,
                attachment.part,
                new Object[] { true, attachment },
                mListener);
        }
    }

    private void onViewAttachment(Attachment attachment)
    {
        if (mMessage != null)
        {
            MessagingController.getInstance(getApplication()).loadAttachment(
                mAccount,
                mMessage,
                attachment.part,
                new Object[] { false, attachment },
                mListener);
        }
    }

    private void onShowPictures()
    {
        K9.setBlockNetworkLoads(mMessageContentView.getSettings(), false);
        mMessageContentView.getSettings().setBlockNetworkImage(false);
        mShowPicturesSection.setVisibility(View.GONE);
    }

  
    public void onClick(View view)
    {
        switch (view.getId())
        {
            case R.id.from:
                onClickSender();
                break;
            case R.id.reply:
            case R.id.reply_scrolling:
                onReply();
                break;
            case R.id.reply_all:
                onReplyAll();
                break;
            case R.id.delete:
            case R.id.delete_scrolling:
                onDelete();
                break;
            case R.id.forward:
            case R.id.forward_scrolling:
                onForward();
                break;
            case R.id.next:
            case R.id.next_scrolling:
                onNext(K9.isAnimations());
                break;
            case R.id.previous:
            case R.id.previous_scrolling:
                onPrevious(K9.isAnimations());
                break;
            case R.id.download:
                onDownloadAttachment((Attachment) view.getTag());
                break;
            case R.id.view:
                onViewAttachment((Attachment) view.getTag());
                break;
            case R.id.show_pictures:
                onShowPictures();
                break;
        }
    }

    public boolean onOptionsItemSelected(MenuItem item)
    {
        switch (item.getItemId())
        {
            case R.id.delete:
                onDelete();
                break;
            case R.id.reply:
                onReply();
                break;
            case R.id.reply_all:
                onReplyAll();
                break;
            case R.id.forward:
                onForward();
                break;
            case R.id.send_alternate:
                onSendAlternate();
                break;
            case R.id.mark_as_unread:
                onMarkAsUnread();
                break;
            case R.id.flag:
                onFlag();
                break;
            case R.id.move:
                onMove();
                break;
            case R.id.copy:
                onCopy();
                break;
            default:
                return super.onOptionsItemSelected(item);
        }
        return true;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu)
    {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.message_view_option, menu);
        optionsMenu = menu;
        setMenuFlag();
        if (MessagingController.getInstance(getApplication()).isCopyCapable(mAccount) == false)
        {
            menu.findItem(R.id.copy).setVisible(false);
        }
        if (MessagingController.getInstance(getApplication()).isMoveCapable(mAccount) == false)
        {
            menu.findItem(R.id.move).setVisible(false);
        }
        return true;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu)
    {
        setMenuFlag();
        return super.onPrepareOptionsMenu(menu);
    }

    private void setMenuFlag()
    {
        Menu menu = optionsMenu;
        if (menu != null)
        {
            MenuItem flagItem = menu.findItem(R.id.flag);
            if (flagItem != null && mMessage != null)
            {
                flagItem.setTitle((mMessage.isSet(Flag.FLAGGED) ? R.string.unflag_action : R.string.flag_action));
            }
        }
    }

    public CacheResult service(String url, Map<String, String> headers)
    {
        if (url.startsWith(CID_PREFIX) && mMessage != null)
        {
            try
            {
                String contentId = url.substring(CID_PREFIX.length());
                final Part part = MimeUtility.findPartByContentId(mMessage, ""<"" + contentId + "">"");
                if (part != null)
                {
                    CacheResult cr = new CacheManager.CacheResult();
                    // TODO looks fixed in Mainline, cr.setInputStream
                    // part.getBody().writeTo(cr.getStream());
                    return cr;
                }
            }
            catch (Exception e)
            {
                // TODO
            }
        }
        return null;
    }

    public PluginData getPluginData(String url, Map<String, String> headers)
    {
        if (url.startsWith(CID_PREFIX) && mMessage != null)
        {
            try
            {
                String contentId = url.substring(CID_PREFIX.length());
                final Part part = MimeUtility.findPartByContentId(mMessage, ""<"" + contentId + "">"");
                if (part != null)
                {
                    Map<String, String[]> splittedHeaders = new HashMap<String, String[]>();
                    for (String headerName : headers.keySet())
                    {
                        String heaverValue = headers.get(headerName);
                        //There must be a better way to do this split and trim...
                        String[] headerValues = heaverValue.split("","");
                        for (int i=0; i<headerValues.length; i++)
                        {
                            headerValues[i] = headerValues[i].trim();
                        }
                        splittedHeaders.put(headerName, headerValues);
                    }
                    return new PluginData(
                               part.getBody().getInputStream(),
                               part.getSize(),
                               splittedHeaders,
                               HttpURLConnection.HTTP_OK);
                }
            }
            catch (Exception e)
            {
                // TODO
            }
        }
        return null;
    }

    private Bitmap getPreviewIcon(Attachment attachment) throws MessagingException
    {
        try
        {
            return BitmapFactory.decodeStream(
                       getContentResolver().openInputStream(
                           AttachmentProvider.getAttachmentThumbnailUri(mAccount,
                                   attachment.part.getAttachmentId(),
                                   62,
                                   62)));
        }
        catch (Exception e)
        {
            /*
             * We don't care what happened, we just return null for the preview icon.
             */
            return null;
        }
    }

    /*
     * Formats the given size as a String in bytes, kB, MB or GB with a single digit
     * of precision. Ex: 12,315,000 = 12.3 MB
     */
    public static String formatSize(float size)
    {
        long kb = 1024;
        long mb = (kb * 1024);
        long gb  = (mb * 1024);
        if (size < kb)
        {
            return String.format(""%d bytes"", (int) size);
        }
        else if (size < mb)
        {
            return String.format(""%.1f kB"", size / kb);
        }
        else if (size < gb)
        {
            return String.format(""%.1f MB"", size / mb);
        }
        else
        {
            return String.format(""%.1f GB"", size / gb);
        }
    }

    private void renderAttachments(Part part, int depth) throws MessagingException
    {
        String contentType = MimeUtility.unfoldAndDecode(part.getContentType());
        String contentDisposition = MimeUtility.unfoldAndDecode(part.getDisposition());
        String name = MimeUtility.getHeaderParameter(contentType, ""name"");
        if (name == null)
        {
            name = MimeUtility.getHeaderParameter(contentDisposition, ""filename"");
        }
        if (name != null)
        {
            /*
             * We're guaranteed size because LocalStore.fetch puts it there.
             */
            int size = Integer.parseInt(MimeUtility.getHeaderParameter(contentDisposition, ""size""));

            Attachment attachment = new Attachment();
            attachment.size = size;
            String mimeType = part.getMimeType();
            if (MimeUtility.DEFAULT_ATTACHMENT_MIME_TYPE.equals(mimeType))
            {
                mimeType = MimeUtility.getMimeTypeByExtension(name);
            }
            attachment.contentType = mimeType;
            attachment.name = name;
            attachment.part = (LocalAttachmentBodyPart) part;

            LayoutInflater inflater = getLayoutInflater();
            View view = inflater.inflate(R.layout.message_view_attachment, null);

            TextView attachmentName = (TextView)view.findViewById(R.id.attachment_name);
            TextView attachmentInfo = (TextView)view.findViewById(R.id.attachment_info);
            ImageView attachmentIcon = (ImageView)view.findViewById(R.id.attachment_icon);
            Button attachmentView = (Button)view.findViewById(R.id.view);
            Button attachmentDownload = (Button)view.findViewById(R.id.download);

            if ((!MimeUtility.mimeTypeMatches(attachment.contentType,
                                              K9.ACCEPTABLE_ATTACHMENT_VIEW_TYPES))
                    || (MimeUtility.mimeTypeMatches(attachment.contentType,
                                                    K9.UNACCEPTABLE_ATTACHMENT_VIEW_TYPES)))
            {
                attachmentView.setVisibility(View.GONE);
            }
            if ((!MimeUtility.mimeTypeMatches(attachment.contentType,
                                              K9.ACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES))
                    || (MimeUtility.mimeTypeMatches(attachment.contentType,
                                                    K9.UNACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES)))
            {
                attachmentDownload.setVisibility(View.GONE);
            }

            if (attachment.size > K9.MAX_ATTACHMENT_DOWNLOAD_SIZE)
            {
                attachmentView.setVisibility(View.GONE);
                attachmentDownload.setVisibility(View.GONE);
            }

            attachment.viewButton = attachmentView;
            attachment.downloadButton = attachmentDownload;
            attachment.iconView = attachmentIcon;

            view.setTag(attachment);
            attachmentView.setOnClickListener(this);
            attachmentView.setTag(attachment);
            attachmentDownload.setOnClickListener(this);
            attachmentDownload.setTag(attachment);

            attachmentName.setText(name);
            attachmentInfo.setText(formatSize(size));

            Bitmap previewIcon = getPreviewIcon(attachment);
            if (previewIcon != null)
            {
                attachmentIcon.setImageBitmap(previewIcon);
            }
            else
            {
                attachmentIcon.setImageResource(R.drawable.attached_image_placeholder);
            }

            mHandler.addAttachment(view);
        }

        if (part.getBody() instanceof Multipart)
        {
            Multipart mp = (Multipart)part.getBody();
            for (int i = 0; i < mp.getCount(); i++)
            {
                renderAttachments(mp.getBodyPart(i), depth + 1);
            }
        }
    }

    private void setHeaders(Account account, String folder, String uid,
                            final Message message) throws MessagingException
    {
        String subjectText = message.getSubject();
        String fromText = Address.toFriendly(message.getFrom());
        String dateText = Utility.isDateToday(message.getSentDate()) ?
                          null :
                          getDateFormat().format(message.getSentDate());
        String timeText = getTimeFormat().format(message.getSentDate());
        String toText = Address.toFriendly(message.getRecipients(RecipientType.TO));
        String ccText = Address.toFriendly(message.getRecipients(RecipientType.CC));
        boolean hasAttachments = ((LocalMessage) message).getAttachmentCount() > 0;
        boolean isDownloading = !message.isSet(Flag.X_DOWNLOADED_FULL);
        mHandler.setHeaders(subjectText,
                            fromText,
                            dateText,
                            timeText,
                            toText,
                            ccText,
                            hasAttachments,
                            isDownloading,
                            message.isSet(Flag.FLAGGED),
                            message.isSet(Flag.ANSWERED));
    }

    class Listener extends MessagingListener
    {

        @Override
        public void loadMessageForViewHeadersAvailable(Account account, String folder, String uid,
                final Message message)
        {
            if (!mMessageUid.equals(uid))
            {
                return;
            }

            MessageView.this.mMessage = message;
            if (!message.isSet(Flag.X_DOWNLOADED_FULL)
                && !message.isSet(Flag.X_DOWNLOADED_PARTIAL))
            {
                mHandler.post(new Runnable()
                {
                    public void run()
                    {
                        mMessageContentView.loadUrl(""file:///android_asset/downloading.html"");
                    }
                });
            }
            try
            {
                setHeaders(account, folder, uid, message);
            }
            catch (MessagingException me)
            {
                if (Config.LOGV)
                {
                    Log.v(K9.LOG_TAG, ""loadMessageForViewHeadersAvailable"", me);
                }
            }
        }

        @Override
        public void loadMessageForViewBodyAvailable(Account account, String folder, String uid,
                Message message)
        {
            if (!mMessageUid.equals(uid))
            {
                return;
            }

            try
            {
                if (MessageView.this.mMessage!=null
                    && MessageView.this.mMessage.isSet(Flag.X_DOWNLOADED_PARTIAL)
                    && message.isSet(Flag.X_DOWNLOADED_FULL))
                {

                    setHeaders(account, folder, uid, message);
                }

                MessageView.this.mMessage = message;

                String text;
                Part part = MimeUtility.findFirstPartByMimeType(mMessage, ""text/html"");
                if (part == null)
                {
                    part = MimeUtility.findFirstPartByMimeType(mMessage, ""text/plain"");
                    if (part == null)
                    {
                        text = null;
                    }
                    else
                    {
                        LocalTextBody body = (LocalTextBody)part.getBody();
                        if (body == null)
                        {
                            text = null;
                        }
                        else
                        {
                            text = body.getBodyForDisplay();
                        }
                    }
                }
                else
                {
                    text = MimeUtility.getTextFromPart(part);
                }

                if (text != null)
                {
                    /*
                     * TODO this should be smarter, change to regex for img, but consider how to
                     * get background images and a million other things that HTML allows.
                     */
                    final String emailText = text;
                    mHandler.post(new Runnable()
                    {
                        public void run()
                        {
                            mMessageContentView.loadDataWithBaseURL(""email://"", emailText, ""text/html"", ""utf-8"", null);
                        }
                    });
                    mHandler.showShowPictures(text.contains(""<img""));
                }
                else
                {
                    mHandler.post(new Runnable()
                    {
                        public void run()
                        {
                            mMessageContentView.loadUrl(""file:///android_asset/empty.html"");
                        }
                    });
                }

                renderAttachments(mMessage, 0);
            }
            catch (Exception e)
            {
                if (Config.LOGV)
                {
                    Log.v(K9.LOG_TAG, ""loadMessageForViewBodyAvailable"", e);
                }
            }
        }//loadMessageForViewBodyAvailable


        @Override
        public void loadMessageForViewFailed(Account account, String folder, String uid,
                                             final Throwable t)
        {
            if (!mMessageUid.equals(uid))
            {
                return;
            }

            mHandler.post(new Runnable()
            {
                public void run()
                {
                    setProgressBarIndeterminateVisibility(false);
                    if (t instanceof IllegalArgumentException)
                    {
                        mHandler.invalidIdError();
                    }
                    else
                    {
                        mHandler.networkError();
                    }
                    if (!MessageView.this.mMessage.isSet(Flag.X_DOWNLOADED_PARTIAL))
                    {
                        mMessageContentView.loadUrl(""file:///android_asset/empty.html"");
                    }
                }
            });
        }

        @Override
        public void loadMessageForViewFinished(Account account, String folder, String uid,
                                               Message message)
        {
            if (!mMessageUid.equals(uid))
            {
                return;
            }

            mHandler.post(new Runnable()
            {
                public void run()
                {
                    setProgressBarIndeterminateVisibility(false);
                }
            });
        }

        @Override
        public void loadMessageForViewStarted(Account account, String folder, String uid)
        {
            if (!mMessageUid.equals(uid))
            {
                return;
            }

            mHandler.post(new Runnable()
            {
                public void run()
                {
                    mMessageContentView.loadUrl(""file:///android_asset/loading.html"");
                    setProgressBarIndeterminateVisibility(true);
                }
            });
        }

        @Override
        public void loadAttachmentStarted(Account account, Message message,
                                          Part part, Object tag, boolean requiresDownload)
        {
            if (mMessage!=message)
            {
                return;
            }

            mHandler.setAttachmentsEnabled(false);
            mHandler.progress(true);
            if (requiresDownload)
            {
                mHandler.fetchingAttachment();
            }
        }

        @Override
        public void loadAttachmentFinished(Account account, Message message,
                                           Part part, Object tag)
        {
            if (mMessage!=message)
            {
                return;
            }

            mHandler.setAttachmentsEnabled(true);
            mHandler.progress(false);

            Object[] params = (Object[]) tag;
            boolean download = (Boolean) params[0];
            Attachment attachment = (Attachment) params[1];

            if (download)
            {
                try
                {
                    File file = createUniqueFile(Environment.getExternalStorageDirectory(),
                                                 attachment.name);
                    Uri uri = AttachmentProvider.getAttachmentUri(
                                  mAccount,
                                  attachment.part.getAttachmentId());
                    InputStream in = getContentResolver().openInputStream(uri);
                    OutputStream out = new FileOutputStream(file);
                    IOUtils.copy(in, out);
                    out.flush();
                    out.close();
                    in.close();
                    mHandler.attachmentSaved(file.getName());
                    new MediaScannerNotifier(MessageView.this, file);
                }
                catch (IOException ioe)
                {
                    mHandler.attachmentNotSaved();
                }
            }
            else
            {
                Uri uri = AttachmentProvider.getAttachmentUri(
                              mAccount,
                              attachment.part.getAttachmentId());
                Intent intent = new Intent(Intent.ACTION_VIEW);
                intent.setData(uri);
                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
                try
                {
                    startActivity(intent);
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Could not display attachment of type "" + attachment.contentType, e);
                    Toast toast = Toast.makeText(MessageView.this, getString(R.string.message_view_no_viewer, attachment.contentType), Toast.LENGTH_LONG);
                    toast.show();
                }
            }
        }

        @Override
        public void loadAttachmentFailed(Account account, Message message, Part part,
                                         Object tag, String reason)
        {
            if (mMessage!=message)
            {
                return;
            }

            mHandler.setAttachmentsEnabled(true);
            mHandler.progress(false);
            mHandler.networkError();
        }
    }

    class MediaScannerNotifier implements MediaScannerConnectionClient
    {
        private MediaScannerConnection mConnection;
        private File mFile;

        public MediaScannerNotifier(Context context, File file)
        {
            mFile = file;
            mConnection = new MediaScannerConnection(context, this);
            mConnection.connect();
        }

        public void onMediaScannerConnected()
        {
            mConnection.scanFile(mFile.getAbsolutePath(), null);
        }

        public void onScanCompleted(String path, Uri uri)
        {
            try
            {
                if (uri != null)
                {
                    Intent intent = new Intent(Intent.ACTION_VIEW);
                    intent.setData(uri);
                    startActivity(intent);
                }
            }
            finally
            {
                mConnection.disconnect();
            }
        }
    }


    private Animation inFromRightAnimation()
    {
        return slideAnimation(0.0f, +1.0f);
    }

    private Animation outToLeftAnimation()
    {
        return slideAnimation(0.0f, -1.0f);
    }

    private Animation slideAnimation(float right, float left)
    {

        Animation slide = new TranslateAnimation(
            Animation.RELATIVE_TO_PARENT,  right, Animation.RELATIVE_TO_PARENT,  left,
            Animation.RELATIVE_TO_PARENT,  0.0f, Animation.RELATIVE_TO_PARENT,   0.0f
        );
        slide.setDuration(125);
        slide.setFillBefore(true);
        slide.setInterpolator(new AccelerateInterpolator());
        return slide;
    }
}
",True,189,0,0,8,52,1,21,L1
33,com.fsck.k9.activity.ActivityListener.java,"package com.fsck.k9.activity;

import java.text.DateFormat;

import android.content.Context;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.MessagingListener;
import com.fsck.k9.R;
import com.fsck.k9.service.MailService;

public class ActivityListener extends MessagingListener
{
    private String mLoadingFolderName = null;
    private String mLoadingAccountDescription = null;
    private String mSendingAccountDescription = null;
    private int mFolderCompleted = 0;
    private int mFolderTotal = 0;
    private String mProcessingAccountDescription = null;
    private String mProcessingCommandTitle = null;

    public String formatHeader(Context context, String activityPrefix, int unreadMessageCount, DateFormat timeFormat)
    {
        String operation = null;
        String progress = null;
        if (mLoadingAccountDescription  != null || mSendingAccountDescription != null || mProcessingAccountDescription != null)
        {
            progress = (mFolderTotal > 0 ? context.getString(R.string.folder_progress, mFolderCompleted, mFolderTotal) : """");

            if (mLoadingFolderName != null)
            {
                String displayName = mLoadingFolderName;
                if (K9.INBOX.equalsIgnoreCase(displayName))
                {
                    displayName = context.getString(R.string.special_mailbox_name_inbox);
                }
                operation = context.getString(R.string.status_loading_account_folder, mLoadingAccountDescription, displayName, progress);
            }

            else if (mSendingAccountDescription != null)
            {
                operation = context.getString(R.string.status_sending_account, mSendingAccountDescription, progress);
            }
            else if (mProcessingAccountDescription != null)
            {
                operation = context.getString(R.string.status_processing_account, mProcessingAccountDescription,
                                              mProcessingCommandTitle != null ? mProcessingCommandTitle : """",
                                              progress);
            }
        }
        else
        {
            long nextPollTime = MailService.getNextPollTime();
            if (nextPollTime != -1)
            {
                operation = context.getString(R.string.status_next_poll, timeFormat.format(nextPollTime));
            }
            else
            {
                operation = context.getString(R.string.status_polling_off);
            }
        }

        return context.getString(R.string.activity_header_format, activityPrefix,
                                 (unreadMessageCount > 0 ? context.getString(R.string.activity_unread_count, unreadMessageCount) : """"),
                                 operation);


    }

    @Override
    public void synchronizeMailboxFinished(
        Account account,
        String folder,
        int totalMessagesInMailbox,
        int numNewMessages)
    {
        mLoadingAccountDescription = null;
        mLoadingFolderName = null;
    }

    @Override
    public void synchronizeMailboxStarted(Account account, String folder)
    {
        mLoadingAccountDescription = account.getDescription();
        mLoadingFolderName = folder;
        mFolderCompleted = 0;
        mFolderTotal = 0;
    }

    public void synchronizeMailboxProgress(Account account, String folder, int completed, int total)
    {
        mFolderCompleted = completed;
        mFolderTotal = total;
    }

    @Override
    public void synchronizeMailboxFailed(Account account, String folder,
                                         String message)
    {
        mLoadingAccountDescription = null;
        mLoadingFolderName = null;

    }

    @Override
    public void sendPendingMessagesStarted(Account account)
    {
        mSendingAccountDescription = account.getDescription();
    }

    @Override
    public void sendPendingMessagesCompleted(Account account)
    {
        mSendingAccountDescription = null;
    }


    @Override
    public void sendPendingMessagesFailed(Account account)
    {
        mSendingAccountDescription = null;
    }
    public void pendingCommandsProcessing(Account account)
    {
        mProcessingAccountDescription = account.getDescription();
        mFolderCompleted = 0;
        mFolderTotal = 0;
    }
    public void pendingCommandsFinished(Account account)
    {
        mProcessingAccountDescription = null;
    }
    public void pendingCommandStarted(Account account, String commandTitle)
    {
        mProcessingCommandTitle = commandTitle;
    }

    public void pendingCommandCompleted(Account account, String commandTitle)
    {
        mProcessingCommandTitle = null;
    }

    public int getFolderCompleted()
    {
        return mFolderCompleted;
    }

    public int getFolderTotal()
    {
        return mFolderTotal;
    }


}
",False,189,0,0,8,46,3,4,L1
34,com.fsck.k9.activity.setup.FolderSettings.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.util.Log;
import android.view.KeyEvent;
import com.fsck.k9.*;
import com.fsck.k9.mail.Folder.FolderClass;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import com.fsck.k9.service.MailService;

public class FolderSettings extends K9PreferenceActivity
{

    private static final String EXTRA_FOLDER_NAME = ""com.fsck.k9.folderName"";
    private static final String EXTRA_ACCOUNT = ""com.fsck.k9.account"";

    private static final String PREFERENCE_TOP_CATERGORY = ""folder_settings"";
    private static final String PREFERENCE_DISPLAY_CLASS = ""folder_settings_folder_display_mode"";
    private static final String PREFERENCE_SYNC_CLASS = ""folder_settings_folder_sync_mode"";
    private static final String PREFERENCE_PUSH_CLASS = ""folder_settings_folder_push_mode"";
    private static final String PREFERENCE_IN_TOP_GROUP = ""folder_settings_in_top_group"";

    private LocalFolder mFolder;

    private CheckBoxPreference mInTopGroup;
    private ListPreference mDisplayClass;
    private ListPreference mSyncClass;
    private ListPreference mPushClass;

    public static void actionSettings(Context context, Account account, String folderName)
    {
        Intent i = new Intent(context, FolderSettings.class);
        i.putExtra(EXTRA_FOLDER_NAME, folderName);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        String folderName = (String)getIntent().getSerializableExtra(EXTRA_FOLDER_NAME);
        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        Account mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        try
        {
            LocalStore localStore = mAccount.getLocalStore();
            mFolder = localStore.getFolder(folderName);
            mFolder.refresh(Preferences.getPreferences(this));
        }
        catch (MessagingException me)
        {
            Log.e(K9.LOG_TAG, ""Unable to edit folder "" + folderName + "" preferences"", me);
            return;
        }

        boolean isPushCapable = false;
        Store store = null;
        try
        {
            store = mAccount.getRemoteStore();
            isPushCapable = store.isPushCapable();
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Could not get remote store"", e);
        }

        addPreferencesFromResource(R.xml.folder_settings_preferences);

        Preference category = findPreference(PREFERENCE_TOP_CATERGORY);
        category.setTitle(folderName);

        
        mInTopGroup = (CheckBoxPreference)findPreference(PREFERENCE_IN_TOP_GROUP);
        mInTopGroup.setChecked(mFolder.isInTopGroup());
        
        mDisplayClass = (ListPreference) findPreference(PREFERENCE_DISPLAY_CLASS);
        mDisplayClass.setValue(mFolder.getDisplayClass().name());
        mDisplayClass.setSummary(mDisplayClass.getEntry());
        mDisplayClass.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mDisplayClass.findIndexOfValue(summary);
                mDisplayClass.setSummary(mDisplayClass.getEntries()[index]);
                mDisplayClass.setValue(summary);
                return false;
            }
        });

        mSyncClass = (ListPreference) findPreference(PREFERENCE_SYNC_CLASS);
        mSyncClass.setValue(mFolder.getRawSyncClass().name());
        mSyncClass.setSummary(mSyncClass.getEntry());
        mSyncClass.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mSyncClass.findIndexOfValue(summary);
                mSyncClass.setSummary(mSyncClass.getEntries()[index]);
                mSyncClass.setValue(summary);
                return false;
            }
        });

        mPushClass = (ListPreference) findPreference(PREFERENCE_PUSH_CLASS);
        mPushClass.setEnabled(isPushCapable);
        mPushClass.setValue(mFolder.getRawPushClass().name());
        mPushClass.setSummary(mPushClass.getEntry());
        mPushClass.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mPushClass.findIndexOfValue(summary);
                mPushClass.setSummary(mPushClass.getEntries()[index]);
                mPushClass.setValue(summary);
                return false;
            }
        });
    }

    @Override
    public void onResume()
    {
        super.onResume();
        try
        {
            mFolder.refresh(Preferences.getPreferences(this));
        }
        catch (MessagingException me)
        {
            Log.e(K9.LOG_TAG, ""Could not refresh folder preferences for folder "" + mFolder.getName(), me);
        }
    }

    private void saveSettings()
    {
        mFolder.setInTopGroup(mInTopGroup.isChecked());
        // We call getPushClass() because display class changes can affect push class when push class is set to inherit
        FolderClass oldPushClass = mFolder.getPushClass();
        FolderClass oldDisplayClass = mFolder.getDisplayClass();
        mFolder.setDisplayClass(FolderClass.valueOf(mDisplayClass.getValue()));
        mFolder.setSyncClass(FolderClass.valueOf(mSyncClass.getValue()));
        mFolder.setPushClass(FolderClass.valueOf(mPushClass.getValue()));
        
        FolderClass newPushClass = mFolder.getPushClass();
        FolderClass newDisplayClass = mFolder.getDisplayClass();
        
        try
        {
            mFolder.save(Preferences.getPreferences(this));
            if (oldPushClass != newPushClass 
                    || (newPushClass != FolderClass.NO_CLASS && oldDisplayClass != newDisplayClass))
            {
                MailService.actionRestartPushers(getApplication(), null);
            }
        }
        catch (MessagingException me)
        {
            Log.e(K9.LOG_TAG, ""Could not refresh folder preferences for folder "" + mFolder.getName(), me);
        }
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (keyCode == KeyEvent.KEYCODE_BACK)
        {
            saveSettings();
        }
        return super.onKeyDown(keyCode, event);
    }


}
",True,189,0,0,7,44,2,9,L1
35,com.fsck.k9.activity.setup.AccountSetupOptions.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.Spinner;
import com.fsck.k9.*;
import com.fsck.k9.mail.Store;

public class AccountSetupOptions extends K9Activity implements OnClickListener
{
    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_MAKE_DEFAULT = ""makeDefault"";

    private Spinner mCheckFrequencyView;

    private Spinner mDisplayCountView;


    private CheckBox mNotifyView;
    private CheckBox mNotifySyncView;
    private CheckBox mPushEnable;

    private Account mAccount;

    public static void actionOptions(Context context, Account account, boolean makeDefault)
    {
        Intent i = new Intent(context, AccountSetupOptions.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_options);

        mCheckFrequencyView = (Spinner)findViewById(R.id.account_check_frequency);
        mDisplayCountView = (Spinner)findViewById(R.id.account_display_count);
        mNotifyView = (CheckBox)findViewById(R.id.account_notify);
        mNotifySyncView = (CheckBox)findViewById(R.id.account_notify_sync);
        mPushEnable = (CheckBox)findViewById(R.id.account_enable_push);

        findViewById(R.id.next).setOnClickListener(this);

        SpinnerOption checkFrequencies[] =
        {
            new SpinnerOption(-1,
            getString(R.string.account_setup_options_mail_check_frequency_never)),
            new SpinnerOption(1,
            getString(R.string.account_setup_options_mail_check_frequency_1min)),
            new SpinnerOption(5,
            getString(R.string.account_setup_options_mail_check_frequency_5min)),
            new SpinnerOption(10,
            getString(R.string.account_setup_options_mail_check_frequency_10min)),
            new SpinnerOption(15,
            getString(R.string.account_setup_options_mail_check_frequency_15min)),
            new SpinnerOption(30,
            getString(R.string.account_setup_options_mail_check_frequency_30min)),
            new SpinnerOption(60,
            getString(R.string.account_setup_options_mail_check_frequency_1hour)),
            new SpinnerOption(120,
            getString(R.string.account_setup_options_mail_check_frequency_2hour)),
            new SpinnerOption(180,
            getString(R.string.account_setup_options_mail_check_frequency_3hour)),
            new SpinnerOption(360,
            getString(R.string.account_setup_options_mail_check_frequency_6hour)),
            new SpinnerOption(720,
            getString(R.string.account_setup_options_mail_check_frequency_12hour)),
            new SpinnerOption(1440,
            getString(R.string.account_setup_options_mail_check_frequency_24hour)),

        };

        ArrayAdapter<SpinnerOption> checkFrequenciesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, checkFrequencies);
        checkFrequenciesAdapter
        .setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mCheckFrequencyView.setAdapter(checkFrequenciesAdapter);

        SpinnerOption displayCounts[] =
        {
            new SpinnerOption(10, getString(R.string.account_setup_options_mail_display_count_10)),
            new SpinnerOption(25, getString(R.string.account_setup_options_mail_display_count_25)),
            new SpinnerOption(50, getString(R.string.account_setup_options_mail_display_count_50)),
            new SpinnerOption(100, getString(R.string.account_setup_options_mail_display_count_100)),
            new SpinnerOption(250, getString(R.string.account_setup_options_mail_display_count_250)),
            new SpinnerOption(500, getString(R.string.account_setup_options_mail_display_count_500)),
            new SpinnerOption(1000, getString(R.string.account_setup_options_mail_display_count_1000)),
        };

        ArrayAdapter<SpinnerOption> displayCountsAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, displayCounts);
        displayCountsAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mDisplayCountView.setAdapter(displayCountsAdapter);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        mNotifyView.setChecked(mAccount.isNotifyNewMail());
        mNotifySyncView.setChecked(mAccount.isShowOngoing());
        SpinnerOption.setSpinnerOptionValue(mCheckFrequencyView, mAccount
                                            .getAutomaticCheckIntervalMinutes());
        SpinnerOption.setSpinnerOptionValue(mDisplayCountView, mAccount
                                            .getDisplayCount());


        boolean isPushCapable = false;
        try
        {
            Store store = mAccount.getRemoteStore();
            isPushCapable = store.isPushCapable();
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Could not get remote store"", e);
        }


        if (!isPushCapable)
        {
            mPushEnable.setVisibility(View.GONE);
        }
        else
        {
            mPushEnable.setChecked(true);
        }


    }

    private void onDone()
    {
        mAccount.setDescription(mAccount.getEmail());
        mAccount.setNotifyNewMail(mNotifyView.isChecked());
        mAccount.setShowOngoing(mNotifySyncView.isChecked());
        mAccount.setAutomaticCheckIntervalMinutes((Integer)((SpinnerOption)mCheckFrequencyView
                .getSelectedItem()).value);
        mAccount.setDisplayCount((Integer)((SpinnerOption)mDisplayCountView
                                           .getSelectedItem()).value);

        if (mPushEnable.isChecked())
        {
            mAccount.setFolderPushMode(Account.FolderMode.FIRST_CLASS);
        }
        else
        {
            mAccount.setFolderPushMode(Account.FolderMode.NONE);
        }

        mAccount.save(Preferences.getPreferences(this));
        if (mAccount.equals(Preferences.getPreferences(this).getDefaultAccount()) ||
                getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false))
        {
            Preferences.getPreferences(this).setDefaultAccount(mAccount);
        }
        K9.setServicesEnabled(this);
        AccountSetupNames.actionSetNames(this, mAccount);
        finish();
    }

    public void onClick(View v)
    {
        switch (v.getId())
        {
            case R.id.next:
                onDone();
                break;
        }
    }
}
",True,189,0,0,8,49,1,7,L1
36,com.fsck.k9.activity.setup.Prefs.java,"package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.EditTextPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.view.KeyEvent;
import com.fsck.k9.K9;
import com.fsck.k9.K9PreferenceActivity;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.activity.DateFormatter;
import com.fsck.k9.service.MailService;

public class Prefs extends K9PreferenceActivity
{

    private static final String PREFERENCE_THEME = ""theme"";
    private static final String PREFERENCE_DATE_FORMAT = ""dateFormat"";
    private static final String PREFERENCE_BACKGROUND_OPS = ""background_ops"";
    private static final String PREFERENCE_DEBUG_LOGGING = ""debug_logging"";
    private static final String PREFERENCE_SENSITIVE_LOGGING = ""sensitive_logging"";

    private static final String PREFERENCE_ANIMATIONS = ""animations"";
    private static final String PREFERENCE_GESTURES = ""gestures"";
    private static final String PREFERENCE_MESSAGELIST_STARS = ""messagelist_stars"";
    private static final String PREFERENCE_MESSAGELIST_CHECKBOXES = ""messagelist_checkboxes"";
    private static final String PREFERENCE_MESSAGELIST_TOUCHABLE = ""messagelist_touchable"";

    private ListPreference mTheme;
    private ListPreference mDateFormat;
    private ListPreference mBackgroundOps;
    private CheckBoxPreference mDebugLogging;
    private CheckBoxPreference mSensitiveLogging;
    private CheckBoxPreference mGestures;
    private CheckBoxPreference mAnimations;
    private CheckBoxPreference mStars;
    private CheckBoxPreference mCheckboxes;
    private CheckBoxPreference mTouchable;


    private String initBackgroundOps;


    public static void actionPrefs(Context context)
    {
        Intent i = new Intent(context, Prefs.class);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);


        addPreferencesFromResource(R.xml.global_preferences);

        mTheme = (ListPreference) findPreference(PREFERENCE_THEME);
        mTheme.setValue(String.valueOf(K9.getK9Theme() == android.R.style.Theme ? ""dark"" : ""light""));
        mTheme.setSummary(mTheme.getEntry());
        mTheme.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mTheme.findIndexOfValue(summary);
                mTheme.setSummary(mTheme.getEntries()[index]);
                mTheme.setValue(summary);
                return false;
            }
        });

        mDateFormat = (ListPreference) findPreference(PREFERENCE_DATE_FORMAT);
        String[] formats = DateFormatter.getFormats(this);
        CharSequence[] entries = new CharSequence[formats.length];
        CharSequence[] values = new CharSequence[formats.length];
        for (int i = 0 ; i < formats.length; i++)
        {
            String format = formats[i];
            entries[i] = DateFormatter.getSampleDate(this, format);;
            values[i] = format;
        }
        mDateFormat.setEntries(entries);
        mDateFormat.setEntryValues(values);

        mDateFormat.setValue(DateFormatter.getFormat(this));
        mDateFormat.setSummary(mDateFormat.getEntry());
        mDateFormat.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mDateFormat.findIndexOfValue(summary);
                mDateFormat.setSummary(mDateFormat.getEntries()[index]);
                mDateFormat.setValue(summary);
                return false;
            }
        });

        mBackgroundOps = (ListPreference) findPreference(PREFERENCE_BACKGROUND_OPS);
        initBackgroundOps = K9.getBackgroundOps().toString();
        mBackgroundOps.setValue(initBackgroundOps);
        mBackgroundOps.setSummary(mBackgroundOps.getEntry());
        mBackgroundOps.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mBackgroundOps.findIndexOfValue(summary);
                mBackgroundOps.setSummary(mBackgroundOps.getEntries()[index]);
                mBackgroundOps.setValue(summary);
                return false;
            }
        });

        mDebugLogging = (CheckBoxPreference)findPreference(PREFERENCE_DEBUG_LOGGING);
        mSensitiveLogging = (CheckBoxPreference)findPreference(PREFERENCE_SENSITIVE_LOGGING);

        mDebugLogging.setChecked(K9.DEBUG);
        mSensitiveLogging.setChecked(K9.DEBUG_SENSITIVE);

        mAnimations = (CheckBoxPreference)findPreference(PREFERENCE_ANIMATIONS);
        mAnimations.setChecked(K9.isAnimations());
        mGestures = (CheckBoxPreference)findPreference(PREFERENCE_GESTURES);
        mGestures.setChecked(K9.gesturesEnabled());

        mStars = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGELIST_STARS);
        mStars.setChecked(K9.messageListStars());

        mCheckboxes = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGELIST_CHECKBOXES);
        mCheckboxes.setChecked(K9.messageListCheckboxes());

        mTouchable = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGELIST_TOUCHABLE);
        mTouchable.setChecked(K9.messageListTouchable());
    }

    @Override
    public void onResume()
    {
        super.onResume();
    }

    private void saveSettings()
    {
        SharedPreferences preferences = Preferences.getPreferences(this).getPreferences();
        K9.setK9Theme(mTheme.getValue().equals(""dark"") ? android.R.style.Theme : android.R.style.Theme_Light);
        K9.DEBUG = mDebugLogging.isChecked();
        K9.DEBUG_SENSITIVE = mSensitiveLogging.isChecked();
        boolean needsRefresh = K9.setBackgroundOps(mBackgroundOps.getValue());

        K9.setAnimations(mAnimations.isChecked());
        K9.setGesturesEnabled(mGestures.isChecked());
        K9.setMessageListStars(mStars.isChecked());
        K9.setMessageListCheckboxes(mCheckboxes.isChecked());

        K9.setMessageListTouchable(mTouchable.isChecked());

        Editor editor = preferences.edit();
        K9.save(editor);
        DateFormatter.setDateFormat(editor, mDateFormat.getValue());
        editor.commit();
        if (needsRefresh)
        {
            MailService.actionReset(this, null);
        }
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (keyCode == KeyEvent.KEYCODE_BACK)
        {
            saveSettings();
        }
        return super.onKeyDown(keyCode, event);
    }

}
",False,189,0,0,9,50,1,5,L1
37,com.fsck.k9.activity.setup.AccountSetupNames.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.text.method.TextKeyListener;
import android.text.method.TextKeyListener.Capitalize;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import com.fsck.k9.*;

public class AccountSetupNames extends K9Activity implements OnClickListener
{
    private static final String EXTRA_ACCOUNT = ""account"";

    private EditText mDescription;

    private EditText mName;

    private Account mAccount;

    private Button mDoneButton;

    public static void actionSetNames(Context context, Account account)
    {
        Intent i = new Intent(context, AccountSetupNames.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_names);
        mDescription = (EditText)findViewById(R.id.account_description);
        mName = (EditText)findViewById(R.id.account_name);
        mDoneButton = (Button)findViewById(R.id.done);
        mDoneButton.setOnClickListener(this);

        TextWatcher validationTextWatcher = new TextWatcher()
        {
            public void afterTextChanged(Editable s)
            {
                validateFields();
            }

            public void beforeTextChanged(CharSequence s, int start, int count, int after)
            {
            }

            public void onTextChanged(CharSequence s, int start, int before, int count)
            {
            }
        };
        mName.addTextChangedListener(validationTextWatcher);

        mName.setKeyListener(TextKeyListener.getInstance(false, Capitalize.WORDS));

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        /*
         * Since this field is considered optional, we don't set this here. If
         * the user fills in a value we'll reset the current value, otherwise we
         * just leave the saved value alone.
         */
        // mDescription.setText(mAccount.getDescription());
        if (mAccount.getName() != null)
        {
            mName.setText(mAccount.getName());
        }
        if (!Utility.requiredFieldValid(mName))
        {
            mDoneButton.setEnabled(false);
        }
    }

    private void validateFields()
    {
        mDoneButton.setEnabled(Utility.requiredFieldValid(mName));
        Utility.setCompoundDrawablesAlpha(mDoneButton, mDoneButton.isEnabled() ? 255 : 128);
    }

    private void onNext()
    {
        if (Utility.requiredFieldValid(mDescription))
        {
            mAccount.setDescription(mDescription.getText().toString());
        }
        mAccount.setName(mName.getText().toString());
        mAccount.save(Preferences.getPreferences(this));
        finish();
    }

    public void onClick(View v)
    {
        switch (v.getId())
        {
            case R.id.done:
                onNext();
                break;
        }
    }
}
",False,189,0,0,8,48,2,4,L1
38,com.fsck.k9.activity.setup.SpinnerOption.java,"/**
 *
 */

package com.fsck.k9.activity.setup;

import android.widget.Spinner;

public class SpinnerOption
{
    public Object value;

    public String label;

    public static void setSpinnerOptionValue(Spinner spinner, Object value)
    {
        for (int i = 0, count = spinner.getCount(); i < count; i++)
        {
            SpinnerOption so = (SpinnerOption)spinner.getItemAtPosition(i);
            if (so.value.equals(value))
            {
                spinner.setSelection(i, true);
                return;
            }
        }
    }

    public SpinnerOption(Object value, String label)
    {
        this.value = value;
        this.label = label;
    }

    @Override
    public String toString()
    {
        return label;
    }
}
",True,73,9,29,0,0,3,0,L1
39,com.fsck.k9.activity.setup.AccountSettings.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.preference.*;
import android.util.Log;
import android.view.KeyEvent;
import com.fsck.k9.*;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.activity.ChooseFolder;
import com.fsck.k9.activity.ChooseIdentity;
import com.fsck.k9.activity.ManageIdentities;
import com.fsck.k9.mail.Store;
import com.fsck.k9.service.MailService;

public class AccountSettings extends K9PreferenceActivity
{
    private static final String EXTRA_ACCOUNT = ""account"";

    private static final int SELECT_AUTO_EXPAND_FOLDER = 1;

    private static final int ACTIVITY_MANAGE_IDENTITIES = 2;

    private static final String PREFERENCE_TOP_CATERGORY = ""account_settings"";
    private static final String PREFERENCE_DESCRIPTION = ""account_description"";
    private static final String PREFERENCE_COMPOSITION = ""composition"";
    private static final String PREFERENCE_MANAGE_IDENTITIES = ""manage_identities"";
    private static final String PREFERENCE_FREQUENCY = ""account_check_frequency"";
    private static final String PREFERENCE_DISPLAY_COUNT = ""account_display_count"";
    private static final String PREFERENCE_DEFAULT = ""account_default"";
    private static final String PREFERENCE_HIDE_BUTTONS = ""hide_buttons_enum"";
    private static final String PREFERENCE_NOTIFY = ""account_notify"";
    private static final String PREFERENCE_NOTIFY_SELF = ""account_notify_self"";
    private static final String PREFERENCE_NOTIFY_SYNC = ""account_notify_sync"";
    private static final String PREFERENCE_VIBRATE = ""account_vibrate"";
    private static final String PREFERENCE_RINGTONE = ""account_ringtone"";
    private static final String PREFERENCE_INCOMING = ""incoming"";
    private static final String PREFERENCE_OUTGOING = ""outgoing"";
    private static final String PREFERENCE_DISPLAY_MODE = ""folder_display_mode"";
    private static final String PREFERENCE_SYNC_MODE = ""folder_sync_mode"";
    private static final String PREFERENCE_PUSH_MODE = ""folder_push_mode"";
    private static final String PREFERENCE_PUSH_LIMIT = ""folder_push_limit"";
    private static final String PREFERENCE_TARGET_MODE = ""folder_target_mode"";
    private static final String PREFERENCE_DELETE_POLICY = ""delete_policy"";
    private static final String PREFERENCE_EXPUNGE_POLICY = ""expunge_policy"";
    private static final String PREFERENCE_AUTO_EXPAND_FOLDER = ""account_setup_auto_expand_folder"";


    private Account mAccount;

    private EditTextPreference mAccountDescription;
    private ListPreference mCheckFrequency;
    private ListPreference mDisplayCount;
    private CheckBoxPreference mAccountDefault;
    private CheckBoxPreference mAccountNotify;
    private CheckBoxPreference mAccountNotifySelf;
    private ListPreference mAccountHideButtons;
    private CheckBoxPreference mAccountNotifySync;
    private CheckBoxPreference mAccountVibrate;
    private RingtonePreference mAccountRingtone;
    private ListPreference mDisplayMode;
    private ListPreference mSyncMode;
    private ListPreference mPushMode;
    private ListPreference mPushLimit;
    private ListPreference mTargetMode;
    private ListPreference mDeletePolicy;
    private ListPreference mExpungePolicy;
    private Preference mAutoExpandFolder;
    private boolean mIncomingChanged = false;


    public static void actionSettings(Context context, Account account)
    {
        Intent i = new Intent(context, AccountSettings.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        boolean isPushCapable = false;
        boolean isExpungeCapable = false;
        Store store = null;
        try
        {
            store = mAccount.getRemoteStore();
            isPushCapable = store.isPushCapable();
            isExpungeCapable = store.isExpungeCapable();
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Could not get remote store"", e);
        }

        addPreferencesFromResource(R.xml.account_settings_preferences);

        Preference category = findPreference(PREFERENCE_TOP_CATERGORY);
        category.setTitle(getString(R.string.account_settings_title_fmt));

        mAccountDescription = (EditTextPreference) findPreference(PREFERENCE_DESCRIPTION);
        mAccountDescription.setSummary(mAccount.getDescription());
        mAccountDescription.setText(mAccount.getDescription());
        mAccountDescription.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                mAccountDescription.setSummary(summary);
                mAccountDescription.setText(summary);
                return false;
            }
        });


        mCheckFrequency = (ListPreference) findPreference(PREFERENCE_FREQUENCY);
        mCheckFrequency.setValue(String.valueOf(mAccount.getAutomaticCheckIntervalMinutes()));
        mCheckFrequency.setSummary(mCheckFrequency.getEntry());
        mCheckFrequency.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mCheckFrequency.findIndexOfValue(summary);
                mCheckFrequency.setSummary(mCheckFrequency.getEntries()[index]);
                mCheckFrequency.setValue(summary);
                return false;
            }
        });

        mDisplayMode = (ListPreference) findPreference(PREFERENCE_DISPLAY_MODE);
        mDisplayMode.setValue(mAccount.getFolderDisplayMode().name());
        mDisplayMode.setSummary(mDisplayMode.getEntry());
        mDisplayMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mDisplayMode.findIndexOfValue(summary);
                mDisplayMode.setSummary(mDisplayMode.getEntries()[index]);
                mDisplayMode.setValue(summary);
                return false;
            }
        });

        mSyncMode = (ListPreference) findPreference(PREFERENCE_SYNC_MODE);
        mSyncMode.setValue(mAccount.getFolderSyncMode().name());
        mSyncMode.setSummary(mSyncMode.getEntry());
        mSyncMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mSyncMode.findIndexOfValue(summary);
                mSyncMode.setSummary(mSyncMode.getEntries()[index]);
                mSyncMode.setValue(summary);
                return false;
            }
        });

        mPushMode = (ListPreference) findPreference(PREFERENCE_PUSH_MODE);
        mPushMode.setEnabled(isPushCapable);
        mPushMode.setValue(mAccount.getFolderPushMode().name());
        mPushMode.setSummary(mPushMode.getEntry());
        mPushMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mPushMode.findIndexOfValue(summary);
                mPushMode.setSummary(mPushMode.getEntries()[index]);
                mPushMode.setValue(summary);
                return false;
            }
        });

        mPushLimit = (ListPreference) findPreference(PREFERENCE_PUSH_LIMIT);
        mPushLimit.setEnabled(isPushCapable);
        mPushLimit.setValue(String.valueOf(mAccount.getMaxPushFolders()));
        mPushLimit.setSummary(mPushLimit.getEntry());
        mPushLimit.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mPushLimit.findIndexOfValue(summary);
                mPushLimit.setSummary(mPushLimit.getEntries()[index]);
                mPushLimit.setValue(summary);
                return false;
            }
        });

        mTargetMode = (ListPreference) findPreference(PREFERENCE_TARGET_MODE);
        mTargetMode.setValue(mAccount.getFolderTargetMode().name());
        mTargetMode.setSummary(mTargetMode.getEntry());
        mTargetMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mTargetMode.findIndexOfValue(summary);
                mTargetMode.setSummary(mTargetMode.getEntries()[index]);
                mTargetMode.setValue(summary);
                return false;
            }
        });

        mDeletePolicy = (ListPreference) findPreference(PREFERENCE_DELETE_POLICY);
        mDeletePolicy.setValue("""" + mAccount.getDeletePolicy());
        mDeletePolicy.setSummary(mDeletePolicy.getEntry());
        mDeletePolicy.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mDeletePolicy.findIndexOfValue(summary);
                mDeletePolicy.setSummary(mDeletePolicy.getEntries()[index]);
                mDeletePolicy.setValue(summary);
                return false;
            }
        });


        mExpungePolicy = (ListPreference) findPreference(PREFERENCE_EXPUNGE_POLICY);
        mExpungePolicy.setEnabled(isExpungeCapable);
        mExpungePolicy.setValue(mAccount.getExpungePolicy());
        mExpungePolicy.setSummary(mExpungePolicy.getEntry());
        mExpungePolicy.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mExpungePolicy.findIndexOfValue(summary);
                mExpungePolicy.setSummary(mExpungePolicy.getEntries()[index]);
                mExpungePolicy.setValue(summary);
                return false;
            }
        });

        mDisplayCount = (ListPreference) findPreference(PREFERENCE_DISPLAY_COUNT);
        mDisplayCount.setValue(String.valueOf(mAccount.getDisplayCount()));
        mDisplayCount.setSummary(mDisplayCount.getEntry());
        mDisplayCount.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mDisplayCount.findIndexOfValue(summary);
                mDisplayCount.setSummary(mDisplayCount.getEntries()[index]);
                mDisplayCount.setValue(summary);
                return false;
            }
        });

        mAccountDefault = (CheckBoxPreference) findPreference(PREFERENCE_DEFAULT);
        mAccountDefault.setChecked(
            mAccount.equals(Preferences.getPreferences(this).getDefaultAccount()));


        mAccountHideButtons = (ListPreference) findPreference(PREFERENCE_HIDE_BUTTONS);
        mAccountHideButtons.setValue("""" + mAccount.getHideMessageViewButtons());
        mAccountHideButtons.setSummary(mAccountHideButtons.getEntry());
        mAccountHideButtons.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mAccountHideButtons.findIndexOfValue(summary);
                mAccountHideButtons.setSummary(mAccountHideButtons.getEntries()[index]);
                mAccountHideButtons.setValue(summary);
                return false;
            }
        });

        mAccountNotify = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFY);
        mAccountNotify.setChecked(mAccount.isNotifyNewMail());

        mAccountNotifySelf = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFY_SELF);
        mAccountNotifySelf.setChecked(mAccount.isNotifySelfNewMail());

        mAccountNotifySync = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFY_SYNC);
        mAccountNotifySync.setChecked(mAccount.isShowOngoing());

        mAccountRingtone = (RingtonePreference) findPreference(PREFERENCE_RINGTONE);

        // XXX: The following two lines act as a workaround for the RingtonePreference
        //      which does not let us set/get the value programmatically
        SharedPreferences prefs = mAccountRingtone.getPreferenceManager().getSharedPreferences();
        String currentRingtone = (!mAccount.isRing() ? null : mAccount.getRingtone());
        prefs.edit().putString(PREFERENCE_RINGTONE, currentRingtone).commit();

        mAccountVibrate = (CheckBoxPreference) findPreference(PREFERENCE_VIBRATE);
        mAccountVibrate.setChecked(mAccount.isVibrate());

        mAutoExpandFolder = (Preference)findPreference(PREFERENCE_AUTO_EXPAND_FOLDER);

        mAutoExpandFolder.setSummary(translateFolder(mAccount.getAutoExpandFolderName()));

        mAutoExpandFolder.setOnPreferenceClickListener(
            new Preference.OnPreferenceClickListener()
        {
            public boolean onPreferenceClick(Preference preference)
            {
                onChooseAutoExpandFolder();
                return false;
            }
        });

        findPreference(PREFERENCE_COMPOSITION).setOnPreferenceClickListener(
            new Preference.OnPreferenceClickListener()
        {
            public boolean onPreferenceClick(Preference preference)
            {
                onCompositionSettings();
                return true;
            }
        });

        findPreference(PREFERENCE_MANAGE_IDENTITIES).setOnPreferenceClickListener(
            new Preference.OnPreferenceClickListener()
        {
            public boolean onPreferenceClick(Preference preference)
            {
                onManageIdentities();
                return true;
            }
        });

        findPreference(PREFERENCE_INCOMING).setOnPreferenceClickListener(
            new Preference.OnPreferenceClickListener()
        {
            public boolean onPreferenceClick(Preference preference)
            {
                mIncomingChanged = true;
                onIncomingSettings();
                return true;
            }
        });

        findPreference(PREFERENCE_OUTGOING).setOnPreferenceClickListener(
            new Preference.OnPreferenceClickListener()
        {
            public boolean onPreferenceClick(Preference preference)
            {
                onOutgoingSettings();
                return true;
            }
        });
    }

    @Override
    public void onResume()
    {
        super.onResume();
        //mAccount.refresh(Preferences.getPreferences(this));
    }

    private void saveSettings()
    {
        if (mAccountDefault.isChecked())
        {
            Preferences.getPreferences(this).setDefaultAccount(mAccount);
        }

        mAccount.setDescription(mAccountDescription.getText());
        mAccount.setNotifyNewMail(mAccountNotify.isChecked());
        mAccount.setNotifySelfNewMail(mAccountNotifySelf.isChecked());
        mAccount.setShowOngoing(mAccountNotifySync.isChecked());
        mAccount.setDisplayCount(Integer.parseInt(mDisplayCount.getValue()));
        mAccount.setVibrate(mAccountVibrate.isChecked());
        mAccount.setFolderTargetMode(Account.FolderMode.valueOf(mTargetMode.getValue()));
        mAccount.setDeletePolicy(Integer.parseInt(mDeletePolicy.getValue()));
        mAccount.setExpungePolicy(mExpungePolicy.getValue());
        
        boolean needsRefresh = mAccount.setAutomaticCheckIntervalMinutes(Integer.parseInt(mCheckFrequency.getValue()));
        needsRefresh |= mAccount.setFolderSyncMode(Account.FolderMode.valueOf(mSyncMode.getValue()));
        
        boolean needsPushRestart = mAccount.setFolderPushMode(Account.FolderMode.valueOf(mPushMode.getValue()));
        if (mAccount.getFolderPushMode() != FolderMode.NONE)
        {
            needsPushRestart |= mAccount.setFolderDisplayMode(Account.FolderMode.valueOf(mDisplayMode.getValue()));
            needsPushRestart |= mAccount.setMaxPushFolders(Integer.parseInt(mPushLimit.getValue()));
            needsPushRestart |= mIncomingChanged;  
        }
        
        SharedPreferences prefs = mAccountRingtone.getPreferenceManager().getSharedPreferences();
        String newRingtone = prefs.getString(PREFERENCE_RINGTONE, null);
        if (newRingtone != null)
        {
            mAccount.setRing(true);
            mAccount.setRingtone(newRingtone);
        }
        else
        {
            if (mAccount.isRing())
            {
                mAccount.setRingtone(null);
            }
        }

        mAccount.setHideMessageViewButtons(Account.HideButtons.valueOf(mAccountHideButtons.getValue()));
        mAccount.setAutoExpandFolderName(reverseTranslateFolder(mAutoExpandFolder.getSummary().toString()));
        mAccount.save(Preferences.getPreferences(this));
        if (needsRefresh && needsPushRestart)
        {
            MailService.actionReset(this, null);
        }
        else if (needsRefresh)
        {
            MailService.actionReschedulePoll(this, null);
        }
        else if (needsPushRestart)
        {
            MailService.actionRestartPushers(this, null);
        }
        // TODO: refresh folder list here
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        if (resultCode == RESULT_OK)
        {
            switch (requestCode)
            {
                case SELECT_AUTO_EXPAND_FOLDER:
                    mAutoExpandFolder.setSummary(translateFolder(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER)));
                    break;
            }
        }
        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (keyCode == KeyEvent.KEYCODE_BACK)
        {
            saveSettings();
        }
        return super.onKeyDown(keyCode, event);
    }

    private void onCompositionSettings()
    {
        AccountSetupComposition.actionEditCompositionSettings(this, mAccount);
    }

    private void onManageIdentities()
    {
        Intent intent = new Intent(this, ManageIdentities.class);
        intent.putExtra(ChooseIdentity.EXTRA_ACCOUNT, mAccount.getUuid());
        startActivityForResult(intent, ACTIVITY_MANAGE_IDENTITIES);
    }

    private void onIncomingSettings()
    {
        AccountSetupIncoming.actionEditIncomingSettings(this, mAccount);
    }

    private void onOutgoingSettings()
    {
        AccountSetupOutgoing.actionEditOutgoingSettings(this, mAccount);
    }

    public void onChooseAutoExpandFolder()
    {
        Intent selectIntent = new Intent(this, ChooseFolder.class);
        selectIntent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());

        selectIntent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, mAutoExpandFolder.getSummary());
        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_CURRENT, ""yes"");
        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_FOLDER_NONE, ""yes"");
        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_DISPLAYABLE_ONLY, ""yes"");
        startActivityForResult(selectIntent, SELECT_AUTO_EXPAND_FOLDER);

    }

    private String translateFolder(String in)
    {

        if (K9.INBOX.equalsIgnoreCase(in))
        {
            return getString(R.string.special_mailbox_name_inbox);
        }
        else
        {
            return in;
        }
    }

    private String reverseTranslateFolder(String in)
    {

        if (getString(R.string.special_mailbox_name_inbox).equals(in))
        {
            return K9.INBOX;
        }
        else
        {
            return in;
        }
    }

}
",True,189,0,0,8,47,3,12,L1
40,com.fsck.k9.activity.setup.AccountSetupIncoming.java,"
package com.fsck.k9.activity.setup;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.text.method.DigitsKeyListener;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.*;

import com.fsck.k9.*;
import com.fsck.k9.activity.ChooseFolder;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public class AccountSetupIncoming extends K9Activity implements OnClickListener
{
    private static final String EXTRA_ACCOUNT = ""account"";
    private static final String EXTRA_MAKE_DEFAULT = ""makeDefault"";

    private static final int SELECT_DRAFT_FOLDER = 100;
    private static final int SELECT_SENT_FOLDER = 101;
    private static final int SELECT_TRASH_FOLDER = 102;
    //private static final int SELECT_OUTBOX_FOLDER = 103;

    private static final int popPorts[] =
    {
        110, 995, 995, 110, 110
    };
    private static final String popSchemes[] =
    {
        ""pop3"", ""pop3+ssl"", ""pop3+ssl+"", ""pop3+tls"", ""pop3+tls+""
    };
    private static final int imapPorts[] =
    {
        143, 993, 993, 143, 143
    };
    private static final String imapSchemes[] =
    {
        ""imap"", ""imap+ssl"", ""imap+ssl+"", ""imap+tls"", ""imap+tls+""
    };
    private static final int webdavPorts[] =
    {
        80, 443, 443, 443, 443
    };
    private static final String webdavSchemes[] =
    {
        ""webdav"", ""webdav+ssl"", ""webdav+ssl+"", ""webdav+tls"", ""webdav+tls+""
    };

    private static final String authTypes[] =
    {
        ""PLAIN"", ""CRAM_MD5""
    };


    private int mAccountPorts[];
    private String mAccountSchemes[];
    private EditText mUsernameView;
    private EditText mPasswordView;
    private EditText mServerView;
    private EditText mPortView;
    private Spinner mSecurityTypeView;
    private Spinner mAuthTypeView;
    private EditText mImapPathPrefixView;
    private Button mImapFolderDrafts;
    private Button mImapFolderSent;
    private Button mImapFolderTrash;
    private EditText mImapFolderOutbox;
    private EditText mWebdavPathPrefixView;
    private EditText mWebdavAuthPathView;
    private EditText mWebdavMailboxPathView;
    private Button mNextButton;
    private Account mAccount;
    private boolean mMakeDefault;
    private CheckBox compressionMobile;
    private CheckBox compressionWifi;
    private CheckBox compressionOther;

    public static void actionIncomingSettings(Activity context, Account account, boolean makeDefault)
    {
        Intent i = new Intent(context, AccountSetupIncoming.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
        context.startActivity(i);
    }

    public static void actionEditIncomingSettings(Activity context, Account account)
    {
        Intent i = new Intent(context, AccountSetupIncoming.class);
        i.setAction(Intent.ACTION_EDIT);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_incoming);

        mUsernameView = (EditText)findViewById(R.id.account_username);
        mPasswordView = (EditText)findViewById(R.id.account_password);
        TextView serverLabelView = (TextView) findViewById(R.id.account_server_label);
        mServerView = (EditText)findViewById(R.id.account_server);
        mPortView = (EditText)findViewById(R.id.account_port);
        mSecurityTypeView = (Spinner)findViewById(R.id.account_security_type);
        mAuthTypeView = (Spinner)findViewById(R.id.account_auth_type);
        mImapPathPrefixView = (EditText)findViewById(R.id.imap_path_prefix);
        mImapFolderDrafts = (Button)findViewById(R.id.account_imap_folder_drafts);
        mImapFolderSent = (Button)findViewById(R.id.account_imap_folder_sent);
        mImapFolderTrash = (Button)findViewById(R.id.account_imap_folder_trash);
        mImapFolderOutbox = (EditText)findViewById(R.id.account_imap_folder_outbox);
        mWebdavPathPrefixView = (EditText)findViewById(R.id.webdav_path_prefix);
        mWebdavAuthPathView = (EditText)findViewById(R.id.webdav_auth_path);
        mWebdavMailboxPathView = (EditText)findViewById(R.id.webdav_mailbox_path);
        mNextButton = (Button)findViewById(R.id.next);
        compressionMobile = (CheckBox)findViewById(R.id.compression_mobile);
        compressionWifi = (CheckBox)findViewById(R.id.compression_wifi);
        compressionOther = (CheckBox)findViewById(R.id.compression_other);

        mImapFolderDrafts.setOnClickListener(this);
        mImapFolderSent.setOnClickListener(this);
        mImapFolderTrash.setOnClickListener(this);
        mNextButton.setOnClickListener(this);

        SpinnerOption securityTypes[] =
        {
            new SpinnerOption(0, getString(R.string.account_setup_incoming_security_none_label)),
            new SpinnerOption(1,
            getString(R.string.account_setup_incoming_security_ssl_optional_label)),
            new SpinnerOption(2, getString(R.string.account_setup_incoming_security_ssl_label)),
            new SpinnerOption(3,
            getString(R.string.account_setup_incoming_security_tls_optional_label)),
            new SpinnerOption(4, getString(R.string.account_setup_incoming_security_tls_label)),
        };

        // This needs to be kept in sync with the list at the top of the file.
        // that makes me somewhat unhappy
        SpinnerOption authTypeSpinnerOptions[] =
        {
            new SpinnerOption(0, ""PLAIN""),
            new SpinnerOption(1, ""CRAM_MD5"")
        };

        ArrayAdapter<SpinnerOption> securityTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, securityTypes);
        securityTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mSecurityTypeView.setAdapter(securityTypesAdapter);

        ArrayAdapter<SpinnerOption> authTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, authTypeSpinnerOptions);
        authTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mAuthTypeView.setAdapter(authTypesAdapter);

        /*
         * Updates the port when the user changes the security type. This allows
         * us to show a reasonable default which the user can change.
         */
        mSecurityTypeView.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener()
        {
            public void onItemSelected(AdapterView arg0, View arg1, int arg2, long arg3)
            {
                updatePortFromSecurityType();
            }

            public void onNothingSelected(AdapterView<?> arg0)
            {
            }
        });

        /*
         * Calls validateFields() which enables or disables the Next button
         * based on the fields' validity.
         */
        TextWatcher validationTextWatcher = new TextWatcher()
        {
            public void afterTextChanged(Editable s)
            {
                validateFields();
            }

            public void beforeTextChanged(CharSequence s, int start, int count, int after)
            {
            }

            public void onTextChanged(CharSequence s, int start, int before, int count)
            {
            }
        };
        mUsernameView.addTextChangedListener(validationTextWatcher);
        mPasswordView.addTextChangedListener(validationTextWatcher);
        mServerView.addTextChangedListener(validationTextWatcher);
        mPortView.addTextChangedListener(validationTextWatcher);

        /*
         * Only allow digits in the port field.
         */
        mPortView.setKeyListener(DigitsKeyListener.getInstance(""0123456789""));

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mMakeDefault = (boolean)getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false);

        /*
         * If we're being reloaded we override the original account with the one
         * we saved
         */
        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT))
        {
            accountUuid = savedInstanceState.getString(EXTRA_ACCOUNT);
            mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        }

        try
        {
            URI uri = new URI(mAccount.getStoreUri());
            String username = null;
            String password = null;
            String authType = null;

            if (uri.getUserInfo() != null)
            {
                String[] userInfoParts = uri.getUserInfo().split("":"");
                if (userInfoParts.length == 3)
                {
                    authType = userInfoParts[0];
                    username = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                    password = URLDecoder.decode(userInfoParts[2], ""UTF-8"");
                }
                else if (userInfoParts.length == 2)
                {
                    username = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                    password = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
                else if (userInfoParts.length == 1)
                {
                    username = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                }
            }



            if (username != null)
            {
                mUsernameView.setText(username);
            }

            if (password != null)
            {
                mPasswordView.setText(password);
            }

            if (authType != null)
            {
                for (int i = 0; i < authTypes.length; i++)
                {
                    if (authTypes[i].equals(authType))
                    {
                        SpinnerOption.setSpinnerOptionValue(mAuthTypeView, i);
                    }
                }
            }


            mImapFolderDrafts.setText(mAccount.getDraftsFolderName());
            mImapFolderSent.setText(mAccount.getSentFolderName());
            mImapFolderTrash.setText(mAccount.getTrashFolderName());
            mImapFolderOutbox.setText(mAccount.getOutboxFolderName());

            if (uri.getScheme().startsWith(""pop3""))
            {
                serverLabelView.setText(R.string.account_setup_incoming_pop_server_label);
                mAccountPorts = popPorts;
                mAccountSchemes = popSchemes;

                findViewById(R.id.imap_path_prefix_section).setVisibility(View.GONE);
                findViewById(R.id.imap_folder_setup_section).setVisibility(View.GONE);
                findViewById(R.id.webdav_path_prefix_section).setVisibility(View.GONE);
                findViewById(R.id.webdav_path_debug_section).setVisibility(View.GONE);
                findViewById(R.id.account_auth_type).setVisibility(View.GONE);
                findViewById(R.id.compression_section).setVisibility(View.GONE);
                mAccount.setDeletePolicy(Account.DELETE_POLICY_NEVER);


            }
            else if (uri.getScheme().startsWith(""imap""))
            {
                serverLabelView.setText(R.string.account_setup_incoming_imap_server_label);
                mAccountPorts = imapPorts;
                mAccountSchemes = imapSchemes;

                if (uri.getPath() != null && uri.getPath().length() > 0)
                {
                    mImapPathPrefixView.setText(uri.getPath().substring(1));
                }
                findViewById(R.id.webdav_path_prefix_section).setVisibility(View.GONE);
                findViewById(R.id.webdav_path_debug_section).setVisibility(View.GONE);
                mAccount.setDeletePolicy(Account.DELETE_POLICY_ON_DELETE);

                if (! Intent.ACTION_EDIT.equals(getIntent().getAction()))
                {
                    findViewById(R.id.imap_folder_setup_section).setVisibility(View.GONE);
                }

            }
            else if (uri.getScheme().startsWith(""webdav""))
            {
                serverLabelView.setText(R.string.account_setup_incoming_webdav_server_label);
                mAccountPorts = webdavPorts;
                mAccountSchemes = webdavSchemes;

                /** Hide the unnecessary fields */
                findViewById(R.id.imap_path_prefix_section).setVisibility(View.GONE);
                findViewById(R.id.account_auth_type).setVisibility(View.GONE);
                findViewById(R.id.compression_section).setVisibility(View.GONE);
                if (uri.getPath() != null && uri.getPath().length() > 0)
                {
                    String[] pathParts = uri.getPath().split(""\\|"");

                    for (int i = 0, count = pathParts.length; i < count; i++)
                    {
                        if (i == 0)
                        {
                            if (pathParts[0] != null &&
                                    pathParts[0].length() > 1)
                            {
                                mWebdavPathPrefixView.setText(pathParts[0].substring(1));
                            }
                        }
                        else if (i == 1)
                        {
                            if (pathParts[1] != null &&
                                    pathParts[1].length() > 1)
                            {
                                mWebdavAuthPathView.setText(pathParts[1]);
                            }
                        }
                        else if (i == 2)
                        {
                            if (pathParts[2] != null &&
                                    pathParts[2].length() > 1)
                            {
                                mWebdavMailboxPathView.setText(pathParts[2]);
                            }
                        }
                    }
                }
                mAccount.setDeletePolicy(Account.DELETE_POLICY_ON_DELETE);
            }
            else
            {
                throw new Exception(""Unknown account type: "" + mAccount.getStoreUri());
            }

            for (int i = 0; i < mAccountSchemes.length; i++)
            {
                if (mAccountSchemes[i].equals(uri.getScheme()))
                {
                    SpinnerOption.setSpinnerOptionValue(mSecurityTypeView, i);
                }
            }
            compressionMobile.setChecked(mAccount.useCompression(Account.TYPE_MOBILE));
            compressionWifi.setChecked(mAccount.useCompression(Account.TYPE_WIFI));
            compressionOther.setChecked(mAccount.useCompression(Account.TYPE_OTHER));
            if (uri.getHost() != null)
            {
                mServerView.setText(uri.getHost());
            }

            if (uri.getPort() != -1)
            {
                mPortView.setText(Integer.toString(uri.getPort()));
            }
            else
            {
                updatePortFromSecurityType();
            }

            validateFields();
        }
        catch (Exception e)
        {
            failure(e);
        }

    }

    @Override
    public void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        outState.putString(EXTRA_ACCOUNT, mAccount.getUuid());
    }

    private void validateFields()
    {
        mNextButton
        .setEnabled(Utility.requiredFieldValid(mUsernameView)
                    && Utility.requiredFieldValid(mPasswordView)
                    && Utility.domainFieldValid(mServerView)
                    && Utility.requiredFieldValid(mPortView));
        Utility.setCompoundDrawablesAlpha(mNextButton, mNextButton.isEnabled() ? 255 : 128);
    }

    private void updatePortFromSecurityType()
    {
        if (mAccountPorts != null)
        {
            int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
            mPortView.setText(Integer.toString(mAccountPorts[securityType]));
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        if (resultCode == RESULT_OK)
        {
            switch (requestCode)
            {
                case SELECT_DRAFT_FOLDER:
                    mImapFolderDrafts.setText(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER));
                    return;
                case SELECT_SENT_FOLDER:
                    mImapFolderSent.setText(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER));
                    return;
                case SELECT_TRASH_FOLDER:
                    mImapFolderTrash.setText(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER));
                    return;
            }
            if (Intent.ACTION_EDIT.equals(getIntent().getAction()))
            {
                mAccount.save(Preferences.getPreferences(this));
                finish();
            }
            else
            {
                /*
                 * Set the username and password for the outgoing settings to the username and
                 * password the user just set for incoming.
                 */
                try
                {
                    String usernameEnc = URLEncoder.encode(mUsernameView.getText().toString(), ""UTF-8""); 
                    String passwordEnc = URLEncoder.encode(mPasswordView.getText().toString(), ""UTF-8""); 
                    URI oldUri = new URI(mAccount.getTransportUri());
                    URI uri = new URI(
                        oldUri.getScheme(),
                        usernameEnc + "":"" + passwordEnc,
                        oldUri.getHost(),
                        oldUri.getPort(),
                        null,
                        null,
                        null);
                    mAccount.setTransportUri(uri.toString());
                }
                catch (UnsupportedEncodingException enc)
                {
                    // This really shouldn't happen since the encoding is hardcoded to UTF-8
                    Log.e(K9.LOG_TAG, ""Couldn't urlencode username or password."", enc);
                }
                catch (URISyntaxException use)
                {
                    /*
                     * If we can't set up the URL we just continue. It's only for
                     * convenience.
                     */
                }


                AccountSetupOutgoing.actionOutgoingSettings(this, mAccount, mMakeDefault);
                finish();
            }
        }
    }

    private void onNext()
    {
        try
        {
            int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
            String path = null;
            if (mAccountSchemes[securityType].startsWith(""imap""))
            {
                path = ""/"" + mImapPathPrefixView.getText();
            }
            else if (mAccountSchemes[securityType].startsWith(""webdav""))
            {
                path = ""/"" + mWebdavPathPrefixView.getText();
                path = path + ""|"" + mWebdavAuthPathView.getText();
                path = path + ""|"" + mWebdavMailboxPathView.getText();
            }

            final String userInfo;
            String user = mUsernameView.getText().toString();
            String password = mPasswordView.getText().toString();
            String userEnc = URLEncoder.encode(user, ""UTF-8"");        
            String passwordEnc = URLEncoder.encode(password, ""UTF-8"");

            if (mAccountSchemes[securityType].startsWith(""imap""))
            {
                String authType = ((SpinnerOption)mAuthTypeView.getSelectedItem()).label;
                userInfo = authType + "":"" + userEnc + "":"" + passwordEnc;
            }
            else
            {
                userInfo = userEnc + "":"" + passwordEnc;
            }
            URI uri = new URI(
                mAccountSchemes[securityType],
                userInfo,
                mServerView.getText().toString(),
                Integer.parseInt(mPortView.getText().toString()),
                path, // path
                null, // query
                null);
            mAccount.setStoreUri(uri.toString());


            mAccount.setDraftsFolderName(mImapFolderDrafts.getText().toString());
            mAccount.setSentFolderName(mImapFolderSent.getText().toString());
            mAccount.setTrashFolderName(mImapFolderTrash.getText().toString());
            mAccount.setOutboxFolderName(mImapFolderOutbox.getText().toString());
            mAccount.setCompression(Account.TYPE_MOBILE, compressionMobile.isChecked());
            mAccount.setCompression(Account.TYPE_WIFI, compressionWifi.isChecked());
            mAccount.setCompression(Account.TYPE_OTHER, compressionOther.isChecked());
            AccountSetupCheckSettings.actionCheckSettings(this, mAccount, true, false);
        }
        catch (Exception e)
        {
            failure(e);
        }

    }

    public void onClick(View v)
    {
        try
        {
            switch (v.getId())
            {
                case R.id.next:
                    onNext();
                    break;
                case R.id.account_imap_folder_drafts:
                    selectImapFolder(SELECT_DRAFT_FOLDER);
                    break;
                case R.id.account_imap_folder_sent:
                    selectImapFolder(SELECT_SENT_FOLDER);
                    break;
                case R.id.account_imap_folder_trash:
                    selectImapFolder(SELECT_TRASH_FOLDER);
                    break;
            }
        }
        catch (Exception e)
        {
            failure(e);
        }
    }

    private void selectImapFolder(int activityCode)
    {
        String curFolder = null;
        boolean showFolderNone = false;
        switch (activityCode)
        {
            case SELECT_DRAFT_FOLDER:
                curFolder = mImapFolderDrafts.getText().toString();
                break;
            case SELECT_SENT_FOLDER:
                curFolder = mImapFolderSent.getText().toString();
                showFolderNone = true;
                break;
            case SELECT_TRASH_FOLDER:
                curFolder = mImapFolderTrash.getText().toString();
                showFolderNone = true;
                break;
            default:
                throw new IllegalArgumentException(
                    ""Cannot select folder for: "" + activityCode);
        }

        Intent selectIntent = new Intent(this, ChooseFolder.class);
        String uri = mAccount.getStoreUri();
        if (showFolderNone && uri.startsWith(""imap""))
        {
            selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_FOLDER_NONE, ""yes"");
        }
        selectIntent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());
        selectIntent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, curFolder);
        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_CURRENT, ""yes"");
        startActivityForResult(selectIntent, activityCode);
    }

    private void failure(Exception use)
    {
        Log.e(K9.LOG_TAG, ""Failure"", use);
        String toastText = getString(R.string.account_setup_bad_uri, use.getMessage());

        Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
        toast.show();
    }
}
",True,189,0,0,8,44,2,9,L1
41,com.fsck.k9.activity.setup.AccountSetupOutgoing.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.text.method.DigitsKeyListener;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.*;
import android.widget.CompoundButton.OnCheckedChangeListener;
import com.fsck.k9.*;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public class AccountSetupOutgoing extends K9Activity implements OnClickListener,
        OnCheckedChangeListener
{
    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_MAKE_DEFAULT = ""makeDefault"";

    private static final int smtpPorts[] =
    {
        25, 465, 465, 25, 25
    };

    private static final String smtpSchemes[] =
    {
        ""smtp"", ""smtp+ssl"", ""smtp+ssl+"", ""smtp+tls"", ""smtp+tls+""
    };
    /*
    private static final int webdavPorts[] =
    {
        80, 443, 443, 443, 443
    };
    private static final String webdavSchemes[] =
    {
        ""webdav"", ""webdav+ssl"", ""webdav+ssl+"", ""webdav+tls"", ""webdav+tls+""
    };
    */

    private static final String authTypes[] =
    {
        ""PLAIN"", ""CRAM_MD5""
    };
    private EditText mUsernameView;
    private EditText mPasswordView;
    private EditText mServerView;
    private EditText mPortView;
    private CheckBox mRequireLoginView;
    private ViewGroup mRequireLoginSettingsView;
    private Spinner mSecurityTypeView;
    private Spinner mAuthTypeView;
    private Button mNextButton;
    private Account mAccount;
    private boolean mMakeDefault;

    public static void actionOutgoingSettings(Context context, Account account, boolean makeDefault)
    {
        Intent i = new Intent(context, AccountSetupOutgoing.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
        context.startActivity(i);
    }

    public static void actionEditOutgoingSettings(Context context, Account account)
    {
        Intent i = new Intent(context, AccountSetupOutgoing.class);
        i.setAction(Intent.ACTION_EDIT);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_outgoing);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        try
        {
            if (new URI(mAccount.getStoreUri()).getScheme().startsWith(""webdav""))
            {
                mAccount.setTransportUri(mAccount.getStoreUri());
                AccountSetupCheckSettings.actionCheckSettings(this, mAccount, false, true);
            }
        }
        catch (URISyntaxException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }


        mUsernameView = (EditText)findViewById(R.id.account_username);
        mPasswordView = (EditText)findViewById(R.id.account_password);
        mServerView = (EditText)findViewById(R.id.account_server);
        mPortView = (EditText)findViewById(R.id.account_port);
        mRequireLoginView = (CheckBox)findViewById(R.id.account_require_login);
        mRequireLoginSettingsView = (ViewGroup)findViewById(R.id.account_require_login_settings);
        mSecurityTypeView = (Spinner)findViewById(R.id.account_security_type);
        mAuthTypeView = (Spinner)findViewById(R.id.account_auth_type);
        mNextButton = (Button)findViewById(R.id.next);

        mNextButton.setOnClickListener(this);
        mRequireLoginView.setOnCheckedChangeListener(this);

        SpinnerOption securityTypes[] =
        {
            new SpinnerOption(0, getString(R.string.account_setup_incoming_security_none_label)),
            new SpinnerOption(1,
            getString(R.string.account_setup_incoming_security_ssl_optional_label)),
            new SpinnerOption(2, getString(R.string.account_setup_incoming_security_ssl_label)),
            new SpinnerOption(3,
            getString(R.string.account_setup_incoming_security_tls_optional_label)),
            new SpinnerOption(4, getString(R.string.account_setup_incoming_security_tls_label)),
        };

        // This needs to be kept in sync with the list at the top of the file.
        // that makes me somewhat unhappy
        SpinnerOption authTypeSpinnerOptions[] =
        {
            new SpinnerOption(0, ""PLAIN""),
            new SpinnerOption(1, ""CRAM_MD5"")
        };



        ArrayAdapter<SpinnerOption> securityTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, securityTypes);
        securityTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mSecurityTypeView.setAdapter(securityTypesAdapter);

        ArrayAdapter<SpinnerOption> authTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, authTypeSpinnerOptions);
        authTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mAuthTypeView.setAdapter(authTypesAdapter);

        /*
         * Updates the port when the user changes the security type. This allows
         * us to show a reasonable default which the user can change.
         */
        mSecurityTypeView.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener()
        {
            public void onItemSelected(AdapterView arg0, View arg1, int arg2, long arg3)
            {
                updatePortFromSecurityType();
            }

            public void onNothingSelected(AdapterView<?> arg0)
            {
            }
        });

        /*
         * Calls validateFields() which enables or disables the Next button
         * based on the fields' validity.
         */
        TextWatcher validationTextWatcher = new TextWatcher()
        {
            public void afterTextChanged(Editable s)
            {
                validateFields();
            }

            public void beforeTextChanged(CharSequence s, int start, int count, int after)
            {
            }

            public void onTextChanged(CharSequence s, int start, int before, int count)
            {
            }
        };
        mUsernameView.addTextChangedListener(validationTextWatcher);
        mPasswordView.addTextChangedListener(validationTextWatcher);
        mServerView.addTextChangedListener(validationTextWatcher);
        mPortView.addTextChangedListener(validationTextWatcher);

        /*
         * Only allow digits in the port field.
         */
        mPortView.setKeyListener(DigitsKeyListener.getInstance(""0123456789""));

        //FIXME: get Account object again?
        accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mMakeDefault = (boolean)getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false);

        /*
         * If we're being reloaded we override the original account with the one
         * we saved
         */
        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT))
        {
            accountUuid = savedInstanceState.getString(EXTRA_ACCOUNT);
            mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        }

        try
        {
            URI uri = new URI(mAccount.getTransportUri());
            String username = null;
            String password = null;
            String authType = null;
            if (uri.getUserInfo() != null)
            {
                String[] userInfoParts = uri.getUserInfo().split("":"");

                username = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                if (userInfoParts.length > 1)
                {
                    password = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
                if (userInfoParts.length > 2)
                {
                    authType = userInfoParts[2];
                }
            }

            if (username != null)
            {
                mUsernameView.setText(username);
                mRequireLoginView.setChecked(true);
            }

            if (password != null)
            {
                mPasswordView.setText(password);
            }

            if (authType != null)
            {
                for (int i = 0; i < authTypes.length; i++)
                {
                    if (authTypes[i].equals(authType))
                    {
                        SpinnerOption.setSpinnerOptionValue(mAuthTypeView, i);
                    }
                }
            }


            for (int i = 0; i < smtpSchemes.length; i++)
            {
                if (smtpSchemes[i].equals(uri.getScheme()))
                {
                    SpinnerOption.setSpinnerOptionValue(mSecurityTypeView, i);
                }
            }

            if (uri.getHost() != null)
            {
                mServerView.setText(uri.getHost());
            }

            if (uri.getPort() != -1)
            {
                mPortView.setText(Integer.toString(uri.getPort()));
            }
            else
            {
                updatePortFromSecurityType();
            }

            validateFields();
        }
        catch (Exception e)
        {
            /*
             * We should always be able to parse our own settings.
             */
            failure(e);
        }

    }

    @Override
    public void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        outState.putString(EXTRA_ACCOUNT, mAccount.getUuid());
    }

    private void validateFields()
    {
        mNextButton
        .setEnabled(
            Utility.domainFieldValid(mServerView) &&
            Utility.requiredFieldValid(mPortView) &&
            (!mRequireLoginView.isChecked() ||
             (Utility.requiredFieldValid(mUsernameView) &&
              Utility.requiredFieldValid(mPasswordView))));
        Utility.setCompoundDrawablesAlpha(mNextButton, mNextButton.isEnabled() ? 255 : 128);
    }

    private void updatePortFromSecurityType()
    {
        int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
        mPortView.setText(Integer.toString(smtpPorts[securityType]));
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        if (resultCode == RESULT_OK)
        {
            if (Intent.ACTION_EDIT.equals(getIntent().getAction()))
            {
                mAccount.save(Preferences.getPreferences(this));
                finish();
            }
            else
            {
                AccountSetupOptions.actionOptions(this, mAccount, mMakeDefault);
                finish();
            }
        }
    }

    private void onNext()
    {
        int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
        URI uri;
        try
        {
            String usernameEnc = URLEncoder.encode(mUsernameView.getText().toString(), ""UTF-8"");
            String passwordEnc = URLEncoder.encode(mPasswordView.getText().toString(), ""UTF-8"");

            String userInfo = null;
            String authType = ((SpinnerOption)mAuthTypeView.getSelectedItem()).label;
            if (mRequireLoginView.isChecked())
            {
                userInfo = usernameEnc + "":"" + passwordEnc + "":"" + authType;
            }
            uri = new URI(smtpSchemes[securityType], userInfo, mServerView.getText().toString(),
                          Integer.parseInt(mPortView.getText().toString()), null, null, null);
            mAccount.setTransportUri(uri.toString());
            AccountSetupCheckSettings.actionCheckSettings(this, mAccount, false, true);
        }
        catch (UnsupportedEncodingException enc)
        {
            // This really shouldn't happen since the encoding is hardcoded to UTF-8
            Log.e(K9.LOG_TAG, ""Couldn't urlencode username or password."", enc);
        }
        catch (Exception e)
        {
            /*
             * It's unrecoverable if we cannot create a URI from components that
             * we validated to be safe.
             */
            failure(e);
        }

    }

    public void onClick(View v)
    {
        switch (v.getId())
        {
            case R.id.next:
                onNext();
                break;
        }
    }

    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
    {
        mRequireLoginSettingsView.setVisibility(isChecked ? View.VISIBLE : View.GONE);
        validateFields();
    }
    private void failure(Exception use)
    {
        Log.e(K9.LOG_TAG, ""Failure"", use);
        String toastText = getString(R.string.account_setup_bad_uri, use.getMessage());

        Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
        toast.show();
    }
}
",True,189,0,0,8,43,2,8,L1
42,com.fsck.k9.activity.setup.AccountSetupCheckSettings.java,"
package com.fsck.k9.activity.setup;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.os.Process;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.TextView;
import com.fsck.k9.*;
import com.fsck.k9.mail.AuthenticationFailedException;
import com.fsck.k9.mail.CertificateValidationException;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.Transport;
import com.fsck.k9.mail.store.TrustManagerFactory;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

/**
 * Checks the given settings to make sure that they can be used to send and
 * receive mail.
 *
 * XXX NOTE: The manifest for this app has it ignore config changes, because
 * it doesn't correctly deal with restarting while its thread is running.
 */
public class AccountSetupCheckSettings extends K9Activity implements OnClickListener
{

    public static final int ACTIVITY_REQUEST_CODE = 1;

    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_CHECK_INCOMING = ""checkIncoming"";

    private static final String EXTRA_CHECK_OUTGOING = ""checkOutgoing"";

    private Handler mHandler = new Handler();

    private ProgressBar mProgressBar;

    private TextView mMessageView;

    private Account mAccount;

    private boolean mCheckIncoming;

    private boolean mCheckOutgoing;

    private boolean mCanceled;

    private boolean mDestroyed;

    public static void actionCheckSettings(Activity context, Account account,
                                           boolean checkIncoming, boolean checkOutgoing)
    {
        Intent i = new Intent(context, AccountSetupCheckSettings.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_CHECK_INCOMING, checkIncoming);
        i.putExtra(EXTRA_CHECK_OUTGOING, checkOutgoing);
        context.startActivityForResult(i, ACTIVITY_REQUEST_CODE);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_check_settings);
        mMessageView = (TextView)findViewById(R.id.message);
        mProgressBar = (ProgressBar)findViewById(R.id.progress);
        ((Button)findViewById(R.id.cancel)).setOnClickListener(this);

        setMessage(R.string.account_setup_check_settings_retr_info_msg);
        mProgressBar.setIndeterminate(true);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mCheckIncoming = (boolean)getIntent().getBooleanExtra(EXTRA_CHECK_INCOMING, false);
        mCheckOutgoing = (boolean)getIntent().getBooleanExtra(EXTRA_CHECK_OUTGOING, false);

        new Thread()
        {
            public void run()
            {
                Store store = null;
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                try
                {
                    if (mDestroyed)
                    {
                        return;
                    }
                    if (mCanceled)
                    {
                        finish();
                        return;
                    }
                    if (mCheckIncoming)
                    {
                        setMessage(R.string.account_setup_check_settings_check_incoming_msg);
                        store = mAccount.getRemoteStore();
                        store.checkSettings();

                        MessagingController.getInstance(getApplication()).listFolders(mAccount, true, null);
                        MessagingController.getInstance(getApplication()).synchronizeMailbox(mAccount, K9.INBOX , null);

                    }
                    if (mDestroyed)
                    {
                        return;
                    }
                    if (mCanceled)
                    {
                        finish();
                        return;
                    }
                    if (mCheckOutgoing)
                    {
                        setMessage(R.string.account_setup_check_settings_check_outgoing_msg);
                        Transport transport = Transport.getInstance(mAccount);
                        transport.close();
                        transport.open();
                        transport.close();
                    }
                    if (mDestroyed)
                    {
                        return;
                    }
                    if (mCanceled)
                    {
                        finish();
                        return;
                    }
                    setResult(RESULT_OK);
                    finish();
                }
                catch (final AuthenticationFailedException afe)
                {
                    Log.e(K9.LOG_TAG, ""Error while testing settings"", afe);
                    showErrorDialog(
                        R.string.account_setup_failed_dlg_auth_message_fmt,
                        afe.getMessage() == null ? """" : afe.getMessage());
                }
                catch (final CertificateValidationException cve)
                {
                    Log.e(K9.LOG_TAG, ""Error while testing settings"", cve);
                    acceptKeyDialog(
                        R.string.account_setup_failed_dlg_certificate_message_fmt,
                        cve);
                }
                catch (final Throwable t)
                {
                    Log.e(K9.LOG_TAG, ""Error while testing settings"", t);
                    showErrorDialog(
                        R.string.account_setup_failed_dlg_server_message_fmt,
                        (t.getMessage() == null ? """" : t.getMessage()));

                }
            }

        }
        .start();
    }

    @Override
    public void onDestroy()
    {
        super.onDestroy();
        mDestroyed = true;
        mCanceled = true;
    }

    private void setMessage(final int resId)
    {
        mHandler.post(new Runnable()
        {
            public void run()
            {
                if (mDestroyed)
                {
                    return;
                }
                mMessageView.setText(getString(resId));
            }
        });
    }

    private void showErrorDialog(final int msgResId, final Object... args)
    {
        mHandler.post(new Runnable()
        {
            public void run()
            {
                if (mDestroyed)
                {
                    return;
                }
                mProgressBar.setIndeterminate(false);
                new AlertDialog.Builder(AccountSetupCheckSettings.this)
                .setTitle(getString(R.string.account_setup_failed_dlg_title))
                .setMessage(getString(msgResId, args))
                .setCancelable(true)
                .setNegativeButton(
                    getString(R.string.account_setup_failed_dlg_continue_action),

                    new DialogInterface.OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        mCanceled=false;
                        setResult(RESULT_OK);
                        finish();
                    }
                })
                .setPositiveButton(
                    getString(R.string.account_setup_failed_dlg_edit_details_action),
                    new DialogInterface.OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        finish();
                    }
                })
                .show();
            }
        });
    }
    private void acceptKeyDialog(final int msgResId, final Object... args)
    {
        mHandler.post(new Runnable()
        {
            public void run()
            {
                if (mDestroyed)
                {
                    return;
                }
                final X509Certificate[] chain = TrustManagerFactory.getLastCertChain();
                String exMessage = ""Unknown Error"";

                Exception ex = ((Exception)args[0]);
                if (ex != null)
                {
                    if (ex.getCause() != null)
                    {
                        if (ex.getCause().getCause() != null)
                        {
                            exMessage = ex.getCause().getCause().getMessage();

                        }
                        else
                        {
                            exMessage = ex.getCause().getMessage();
                        }
                    }
                    else
                    {
                        exMessage = ex.getMessage();
                    }
                }

                mProgressBar.setIndeterminate(false);
                StringBuffer chainInfo = new StringBuffer(100);
                for (int i = 0; i < chain.length; i++)
                {
                    // display certificate chain information
                    chainInfo.append(""Certificate chain["" + i + ""]:\n"");
                    chainInfo.append(""Subject: "" + chain[i].getSubjectDN().toString() + ""\n"");
                    chainInfo.append(""Issuer: "" + chain[i].getIssuerDN().toString() + ""\n"");
                }

                new AlertDialog.Builder(AccountSetupCheckSettings.this)
                .setTitle(getString(R.string.account_setup_failed_dlg_invalid_certificate_title))
                //.setMessage(getString(R.string.account_setup_failed_dlg_invalid_certificate)
                .setMessage(getString(msgResId,exMessage)
                            + "" "" + chainInfo.toString()
                           )
                .setCancelable(true)
                .setPositiveButton(
                    getString(R.string.account_setup_failed_dlg_invalid_certificate_accept),
                    new DialogInterface.OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        try
                        {
                            String alias = mAccount.getUuid();
                            if (mCheckIncoming)
                            {
                                alias = alias + "".incoming"";
                            }
                            if (mCheckOutgoing)
                            {
                                alias = alias + "".outgoing"";
                            }
                            TrustManagerFactory.addCertificateChain(alias, chain);
                        }
                        catch (CertificateException e)
                        {
                            showErrorDialog(
                                R.string.account_setup_failed_dlg_certificate_message_fmt,
                                e.getMessage() == null ? """" : e.getMessage());
                        }
                        AccountSetupCheckSettings.actionCheckSettings(AccountSetupCheckSettings.this, mAccount,
                                mCheckIncoming, mCheckOutgoing);
                    }
                })
                .setNegativeButton(
                    getString(R.string.account_setup_failed_dlg_invalid_certificate_reject),
                    new DialogInterface.OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        finish();
                    }
                })
                .show();
            }
        });
    }

    public void onActivityResult(int reqCode, int resCode, Intent data)
    {
        setResult(resCode);
        finish();
    }


    private void onCancel()
    {
        mCanceled = true;
        setMessage(R.string.account_setup_check_settings_canceling_msg);
    }

    public void onClick(View v)
    {
        switch (v.getId())
        {
            case R.id.cancel:
                onCancel();
                break;
        }
    }
}
",True,189,0,0,7,56,3,10,L1
43,com.fsck.k9.activity.setup.AccountSetupAccountType.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.Toast;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.K9Activity;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import java.net.URI;

/**
 * Prompts the user to select an account type. The account type, along with the
 * passed in email address, password and makeDefault are then passed on to the
 * AccountSetupIncoming activity.
 */
public class AccountSetupAccountType extends K9Activity implements OnClickListener
{
    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_MAKE_DEFAULT = ""makeDefault"";

    private Account mAccount;

    private boolean mMakeDefault;

    public static void actionSelectAccountType(Context context, Account account, boolean makeDefault)
    {
        Intent i = new Intent(context, AccountSetupAccountType.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_account_type);
        ((Button)findViewById(R.id.pop)).setOnClickListener(this);
        ((Button)findViewById(R.id.imap)).setOnClickListener(this);
        ((Button)findViewById(R.id.webdav)).setOnClickListener(this);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mMakeDefault = (boolean)getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false);
    }

    private void onPop()
    {
        try
        {
            URI uri = new URI(mAccount.getStoreUri());
            uri = new URI(""pop3"", uri.getUserInfo(), uri.getHost(), uri.getPort(), null, null, null);
            mAccount.setStoreUri(uri.toString());
            AccountSetupIncoming.actionIncomingSettings(this, mAccount, mMakeDefault);
            finish();
        }
        catch (Exception use)
        {
            failure(use);
        }

    }

    private void onImap()
    {
        try
        {
            URI uri = new URI(mAccount.getStoreUri());
            uri = new URI(""imap"", uri.getUserInfo(), uri.getHost(), uri.getPort(), null, null, null);
            mAccount.setStoreUri(uri.toString());
            AccountSetupIncoming.actionIncomingSettings(this, mAccount, mMakeDefault);
            finish();
        }
        catch (Exception use)
        {
            failure(use);
        }

    }

    private void onWebDav()
    {
        try
        {
            URI uri = new URI(mAccount.getStoreUri());
            uri = new URI(""webdav"", uri.getUserInfo(), uri.getHost(), uri.getPort(), null, null, null);
            mAccount.setStoreUri(uri.toString());
            AccountSetupIncoming.actionIncomingSettings(this, mAccount, mMakeDefault);
            finish();
        }
        catch (Exception use)
        {
            failure(use);
        }

    }

    public void onClick(View v)
    {
        switch (v.getId())
        {
            case R.id.pop:
                onPop();
                break;
            case R.id.imap:
                onImap();
                break;
            case R.id.webdav:
                onWebDav();
                break;
        }
    }
    private void failure(Exception use)
    {
        Log.e(K9.LOG_TAG, ""Failure"", use);
        String toastText = getString(R.string.account_setup_bad_uri, use.getMessage());

        Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
        toast.show();
    }
}
",True,189,0,0,8,47,1,5,L1
44,com.fsck.k9.activity.setup.AccountSetupComposition.java,"package com.fsck.k9.activity.setup;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.KeyEvent;
import android.view.View;
import android.widget.CompoundButton;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.RadioButton;
import com.fsck.k9.Account;
import com.fsck.k9.K9Activity;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;

public class AccountSetupComposition extends K9Activity
{

    private static final String EXTRA_ACCOUNT = ""account"";

    private Account mAccount;

    private EditText mAccountSignature;
    private EditText mAccountEmail;
    private EditText mAccountAlwaysBcc;
    private EditText mAccountName;
    private CheckBox mAccountSignatureUse;
    private RadioButton mAccountSignatureBeforeLocation;
    private RadioButton mAccountSignatureAfterLocation;
    private LinearLayout mAccountSignatureLayout;

    public static void actionEditCompositionSettings(Activity context, Account account)
    {
        Intent i = new Intent(context, AccountSetupComposition.class);
        i.setAction(Intent.ACTION_EDIT);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }


    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        setContentView(R.layout.account_setup_composition);

        /*
         * If we're being reloaded we override the original account with the one
         * we saved
         */
        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT))
        {
            accountUuid = savedInstanceState.getString(EXTRA_ACCOUNT);
            mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        }

        mAccountName = (EditText)findViewById(R.id.account_name);
        mAccountName.setText(mAccount.getName());

        mAccountEmail = (EditText)findViewById(R.id.account_email);
        mAccountEmail.setText(mAccount.getEmail());

        mAccountAlwaysBcc = (EditText)findViewById(R.id.account_always_bcc);
        mAccountAlwaysBcc.setText(mAccount.getAlwaysBcc());

    	mAccountSignatureLayout = (LinearLayout)findViewById(R.id.account_signature_layout);

    	mAccountSignatureUse = (CheckBox)findViewById(R.id.account_signature_use);
        boolean useSignature = mAccount.getSignatureUse();
        mAccountSignatureUse.setChecked(useSignature);
        mAccountSignatureUse.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
            {
                if (isChecked)
                {
    				mAccountSignatureLayout.setVisibility(View.VISIBLE);
    	            mAccountSignature.setText(mAccount.getSignature());
    	            boolean isSignatureBeforeQuotedText = mAccount.isSignatureBeforeQuotedText();
    	            mAccountSignatureBeforeLocation.setChecked(isSignatureBeforeQuotedText);
    	            mAccountSignatureAfterLocation.setChecked(!isSignatureBeforeQuotedText);
                }
                else
                {
    				mAccountSignatureLayout.setVisibility(View.GONE);
                }
            }
        });

        mAccountSignature = (EditText)findViewById(R.id.account_signature);

        mAccountSignatureBeforeLocation = (RadioButton)findViewById(R.id.account_signature_location_before_quoted_text);
        mAccountSignatureAfterLocation = (RadioButton)findViewById(R.id.account_signature_location_after_quoted_text);

        if (useSignature)
        {
            mAccountSignature.setText(mAccount.getSignature());

            boolean isSignatureBeforeQuotedText = mAccount.isSignatureBeforeQuotedText();
            mAccountSignatureBeforeLocation.setChecked(isSignatureBeforeQuotedText);
            mAccountSignatureAfterLocation.setChecked(!isSignatureBeforeQuotedText);
        }
        else
        {
        	mAccountSignatureLayout.setVisibility(View.GONE);
        }
    }

    @Override
    public void onResume()
    {
        super.onResume();
        //mAccount.refresh(Preferences.getPreferences(this));
    }

    private void saveSettings()
    {
        mAccount.setEmail(mAccountEmail.getText().toString());
        mAccount.setAlwaysBcc(mAccountAlwaysBcc.getText().toString());
        mAccount.setName(mAccountName.getText().toString());
        mAccount.setSignatureUse(mAccountSignatureUse.isChecked());
        if (mAccountSignatureUse.isChecked())
        {
        	mAccount.setSignature(mAccountSignature.getText().toString());
        	boolean isSignatureBeforeQuotedText = mAccountSignatureBeforeLocation.isChecked();
        	mAccount.setSignatureBeforeQuotedText(isSignatureBeforeQuotedText);
        }

        mAccount.save(Preferences.getPreferences(this));
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (keyCode == KeyEvent.KEYCODE_BACK)
        {
            saveSettings();
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        outState.putSerializable(EXTRA_ACCOUNT, mAccount.getUuid());
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        mAccount.save(Preferences.getPreferences(this));
        finish();
    }
}
",False,189,0,0,8,48,1,3,L1
45,com.fsck.k9.activity.setup.AccountSetupBasics.java,"
package com.fsck.k9.activity.setup;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.XmlResourceParser;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.provider.Contacts;
import android.provider.Contacts.People.ContactMethods;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import com.fsck.k9.*;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLEncoder;

/**
 * Prompts the user for the email address and password. Also prompts for
 * ""Use this account as default"" if this is the 2nd+ account being set up.
 * Attempts to lookup default settings for the domain the user specified. If the
 * domain is known the settings are handed off to the AccountSetupCheckSettings
 * activity. If no settings are found the settings are handed off to the
 * AccountSetupAccountType activity.
 */
public class AccountSetupBasics extends K9Activity
        implements OnClickListener, TextWatcher
{
    private final static String EXTRA_ACCOUNT = ""com.fsck.k9.AccountSetupBasics.account"";
    private final static int DIALOG_NOTE = 1;
    private final static String STATE_KEY_PROVIDER =
        ""com.fsck.k9.AccountSetupBasics.provider"";

    private Preferences mPrefs;
    private EditText mEmailView;
    private EditText mPasswordView;
    private CheckBox mDefaultView;
    private Button mNextButton;
    private Button mManualSetupButton;
    private Account mAccount;
    private Provider mProvider;

    private EmailAddressValidator mEmailValidator = new EmailAddressValidator();

    public static void actionNewAccount(Context context)
    {
        Intent i = new Intent(context, AccountSetupBasics.class);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_basics);
        mPrefs = Preferences.getPreferences(this);
        mEmailView = (EditText)findViewById(R.id.account_email);
        mPasswordView = (EditText)findViewById(R.id.account_password);
        mDefaultView = (CheckBox)findViewById(R.id.account_default);
        mNextButton = (Button)findViewById(R.id.next);
        mManualSetupButton = (Button)findViewById(R.id.manual_setup);

        mNextButton.setOnClickListener(this);
        mManualSetupButton.setOnClickListener(this);

        mEmailView.addTextChangedListener(this);
        mPasswordView.addTextChangedListener(this);

        if (mPrefs.getAccounts().length > 0)
        {
            mDefaultView.setVisibility(View.VISIBLE);
        }

        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT))
        {
            String accountUuid = savedInstanceState.getString(EXTRA_ACCOUNT);
            mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        }

        if (savedInstanceState != null && savedInstanceState.containsKey(STATE_KEY_PROVIDER))
        {
            mProvider = (Provider)savedInstanceState.getSerializable(STATE_KEY_PROVIDER);
        }
    }

    @Override
    public void onResume()
    {
        super.onResume();
        validateFields();
    }

    @Override
    public void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        outState.putString(EXTRA_ACCOUNT, mAccount.getUuid());
        if (mProvider != null)
        {
            outState.putSerializable(STATE_KEY_PROVIDER, mProvider);
        }
    }

    public void afterTextChanged(Editable s)
    {
        validateFields();
    }

    public void beforeTextChanged(CharSequence s, int start, int count, int after)
    {
    }

    public void onTextChanged(CharSequence s, int start, int before, int count)
    {
    }

    private void validateFields()
    {
        String email = mEmailView.getText().toString();
        boolean valid = Utility.requiredFieldValid(mEmailView)
                        && Utility.requiredFieldValid(mPasswordView)
                        && mEmailValidator.isValidAddressOnly(email);

        mNextButton.setEnabled(valid);
        mManualSetupButton.setEnabled(valid);
        /*
         * Dim the next button's icon to 50% if the button is disabled.
         * TODO this can probably be done with a stateful drawable. Check into it.
         * android:state_enabled
         */
        Utility.setCompoundDrawablesAlpha(mNextButton, mNextButton.isEnabled() ? 255 : 128);
    }

    private String getOwnerName()
    {
        String name = null;
        try
        {
            String projection[] =
            {
                ContactMethods.NAME
            };
            Cursor c = getContentResolver().query(
                           // TODO: For Android 2.0, needs to change to ContactsContract.People...
                           Uri.withAppendedPath(Contacts.People.CONTENT_URI, ""owner""), projection, null, null,
                           null);
            if (c.getCount() > 0)
            {
                c.moveToFirst();
                name = c.getString(0);
                c.close();
            }
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Could not get owner name, using default account name"", e);
        }
        if (name == null || name.length() == 0)
        {
            try
            {
                name = getDefaultAccountName();
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Could not get default account name"", e);
            }
        }
        if (name == null)
        {
            name = """";
        }
        return name;
    }

    private String getDefaultAccountName()
    {
        String name = null;
        Account account = Preferences.getPreferences(this).getDefaultAccount();
        if (account != null)
        {
            name = account.getName();
        }
        return name;
    }

    @Override
    public Dialog onCreateDialog(int id)
    {
        if (id == DIALOG_NOTE)
        {
            if (mProvider != null && mProvider.note != null)
            {
                return new AlertDialog.Builder(this)
                       .setMessage(mProvider.note)
                       .setPositiveButton(
                           getString(R.string.okay_action),
                           new DialogInterface.OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        finishAutoSetup();
                    }
                })
                       .setNegativeButton(
                           getString(R.string.cancel_action),
                           null)
                       .create();
            }
        }
        return null;
    }

    private void finishAutoSetup()
    {
        String email = mEmailView.getText().toString();
        String password = mPasswordView.getText().toString();
        String[] emailParts = splitEmail(email);
        String user = emailParts[0];
        String domain = emailParts[1];
        URI incomingUri = null;
        URI outgoingUri = null;
        try
        {
            String userEnc = URLEncoder.encode(user, ""UTF-8"");        
            String passwordEnc = URLEncoder.encode(password, ""UTF-8"");

            String incomingUsername = mProvider.incomingUsernameTemplate;
            incomingUsername = incomingUsername.replaceAll(""\\$email"", email);
            incomingUsername = incomingUsername.replaceAll(""\\$user"", userEnc);
            incomingUsername = incomingUsername.replaceAll(""\\$domain"", domain);

            URI incomingUriTemplate = mProvider.incomingUriTemplate;
            incomingUri = new URI(incomingUriTemplate.getScheme(), incomingUsername + "":""
                                  + passwordEnc, incomingUriTemplate.getHost(), incomingUriTemplate.getPort(), null,
                                  null, null);

            String outgoingUsername = mProvider.outgoingUsernameTemplate;
            outgoingUsername = outgoingUsername.replaceAll(""\\$email"", email);
            outgoingUsername = outgoingUsername.replaceAll(""\\$user"", userEnc);
            outgoingUsername = outgoingUsername.replaceAll(""\\$domain"", domain);

            URI outgoingUriTemplate = mProvider.outgoingUriTemplate;
            outgoingUri = new URI(outgoingUriTemplate.getScheme(), outgoingUsername + "":""
                                  + passwordEnc, outgoingUriTemplate.getHost(), outgoingUriTemplate.getPort(), null,
                                  null, null);
        }
        catch (UnsupportedEncodingException enc)
        {
            // This really shouldn't happen since the encoding is hardcoded to UTF-8
            Log.e(K9.LOG_TAG, ""Couldn't urlencode username or password."", enc);
        }
        catch (URISyntaxException use)
        {
            /*
             * If there is some problem with the URI we give up and go on to
             * manual setup.
             */
            onManualSetup();
            return;
        }

        mAccount = Preferences.getPreferences(this).newAccount();
        mAccount.setName(getOwnerName());
        mAccount.setEmail(email);
        mAccount.setStoreUri(incomingUri.toString());
        mAccount.setTransportUri(outgoingUri.toString());
        mAccount.setDraftsFolderName(getString(R.string.special_mailbox_name_drafts));
        mAccount.setTrashFolderName(getString(R.string.special_mailbox_name_trash));
        mAccount.setOutboxFolderName(getString(R.string.special_mailbox_name_outbox));
        mAccount.setSentFolderName(getString(R.string.special_mailbox_name_sent));
        AccountSetupCheckSettings.actionCheckSettings(this, mAccount, true, true);
    }

    private void onNext()
    {
        String email = mEmailView.getText().toString();
        String[] emailParts = splitEmail(email);
        String domain = emailParts[1];
        mProvider = findProviderForDomain(domain);
        if (mProvider == null)
        {
            /*
             * We don't have default settings for this account, start the manual
             * setup process.
             */
            onManualSetup();
            return;
        }

        if (mProvider.note != null)
        {
            showDialog(DIALOG_NOTE);
        }
        else
        {
            finishAutoSetup();
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        if (resultCode == RESULT_OK)
        {
            mAccount.setDescription(mAccount.getEmail());
            mAccount.save(Preferences.getPreferences(this));
            if (mDefaultView.isChecked())
            {
                Preferences.getPreferences(this).setDefaultAccount(mAccount);
            }
            K9.setServicesEnabled(this);
            AccountSetupNames.actionSetNames(this, mAccount);
            finish();
        }
    }

    private void onManualSetup()
    {
        String email = mEmailView.getText().toString();
        String password = mPasswordView.getText().toString();
        String[] emailParts = splitEmail(email);
        String user = emailParts[0];
        String domain = emailParts[1];

        mAccount = Preferences.getPreferences(this).newAccount();
        mAccount.setName(getOwnerName());
        mAccount.setEmail(email);
        try
        {
            String userEnc = URLEncoder.encode(user, ""UTF-8"");        
            String passwordEnc = URLEncoder.encode(password, ""UTF-8"");

            URI uri = new URI(""placeholder"", userEnc + "":"" + passwordEnc, ""mail."" + domain, -1, null,
                              null, null);
            mAccount.setStoreUri(uri.toString());
            mAccount.setTransportUri(uri.toString());
        }
        catch (UnsupportedEncodingException enc)
        {
            // This really shouldn't happen since the encoding is hardcoded to UTF-8
            Log.e(K9.LOG_TAG, ""Couldn't urlencode username or password."", enc);
        }
        catch (URISyntaxException use)
        {
            /*
             * If we can't set up the URL we just continue. It's only for
             * convenience.
             */
        }
        mAccount.setDraftsFolderName(getString(R.string.special_mailbox_name_drafts));
        mAccount.setTrashFolderName(getString(R.string.special_mailbox_name_trash));
        mAccount.setOutboxFolderName(getString(R.string.special_mailbox_name_outbox));
        mAccount.setSentFolderName(getString(R.string.special_mailbox_name_sent));

        AccountSetupAccountType.actionSelectAccountType(this, mAccount, mDefaultView.isChecked());
        finish();
    }

    public void onClick(View v)
    {
        switch (v.getId())
        {
            case R.id.next:
                onNext();
                break;
            case R.id.manual_setup:
                onManualSetup();
                break;
        }
    }

    /**
     * Attempts to get the given attribute as a String resource first, and if it fails
     * returns the attribute as a simple String value.
     * @param xml
     * @param name
     * @return
     */
    private String getXmlAttribute(XmlResourceParser xml, String name)
    {
        int resId = xml.getAttributeResourceValue(null, name, 0);
        if (resId == 0)
        {
            return xml.getAttributeValue(null, name);
        }
        else
        {
            return getString(resId);
        }
    }

    private Provider findProviderForDomain(String domain)
    {
        try
        {
            XmlResourceParser xml = getResources().getXml(R.xml.providers);
            int xmlEventType;
            Provider provider = null;
            while ((xmlEventType = xml.next()) != XmlResourceParser.END_DOCUMENT)
            {
                if (xmlEventType == XmlResourceParser.START_TAG
                        && ""provider"".equals(xml.getName())
                        && domain.equalsIgnoreCase(getXmlAttribute(xml, ""domain"")))
                {
                    provider = new Provider();
                    provider.id = getXmlAttribute(xml, ""id"");
                    provider.label = getXmlAttribute(xml, ""label"");
                    provider.domain = getXmlAttribute(xml, ""domain"");
                    provider.note = getXmlAttribute(xml, ""note"");
                }
                else if (xmlEventType == XmlResourceParser.START_TAG
                         && ""incoming"".equals(xml.getName())
                         && provider != null)
                {
                    provider.incomingUriTemplate = new URI(getXmlAttribute(xml, ""uri""));
                    provider.incomingUsernameTemplate = getXmlAttribute(xml, ""username"");
                }
                else if (xmlEventType == XmlResourceParser.START_TAG
                         && ""outgoing"".equals(xml.getName())
                         && provider != null)
                {
                    provider.outgoingUriTemplate = new URI(getXmlAttribute(xml, ""uri""));
                    provider.outgoingUsernameTemplate = getXmlAttribute(xml, ""username"");
                }
                else if (xmlEventType == XmlResourceParser.END_TAG
                         && ""provider"".equals(xml.getName())
                         && provider != null)
                {
                    return provider;
                }
            }
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Error while trying to load provider settings."", e);
        }
        return null;
    }

    private String[] splitEmail(String email)
    {
        String[] retParts = new String[2];
        String[] emailParts = email.split(""@"");
        retParts[0] = (emailParts.length > 0) ? emailParts[0] : """";
        retParts[1] = (emailParts.length > 1) ? emailParts[1] : """";
        return retParts;
    }

    static class Provider implements Serializable
    {
        private static final long serialVersionUID = 8511656164616538989L;

        public String id;

        public String label;

        public String domain;

        public URI incomingUriTemplate;

        public String incomingUsernameTemplate;

        public URI outgoingUriTemplate;

        public String outgoingUsernameTemplate;

        public String note;
    }
}
",True,189,0,0,8,45,1,9,L1
46,com.fsck.k9.remotecontrol.K9RemoteControl.java,"package com.fsck.k9.remotecontrol;


import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

/**
 * Utillity definitions for Android applications to control the behavior of K-9 Mail.  All such applications must declare the following permission:
 * <uses-permission android:name=""com.fsck.k9.permission.REMOTE_CONTROL""/>
 * in their AndroidManifest.xml  In addition, all applications sending remote control messages to K-9 Mail must
 *
 * An application that wishes to act on a particular Account in K-9 needs to fetch the list of configured Accounts by broadcasting an
 * {@link Intent} using K9_REQUEST_ACCOUNTS as the Action.  The broadcast must be made using the {@link ContextWrapper}
 * sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver,
 * Handler scheduler, int initialCode, String initialData, Bundle initialExtras).sendOrderedBroadcast}
 * method in order to receive the list of Account UUIDs and descriptions that K-9 will provide.
 *
 * @author Daniel I. Applebaum
 *
 */
public class K9RemoteControl
{
    /**
     * Permission that every application sending a broadcast to K-9 for Remote Control purposes should send on every broadcast.
     * Prevent other applications from intercepting the broadcasts.
     */
    public final static String K9_REMOTE_CONTROL_PERMISSION = ""com.fsck.k9.permission.REMOTE_CONTROL"";
    /**
     * {@link Intent} Action to be sent to K-9 using {@link ContextWrapper.sendOrderedBroadcast} in order to fetch the list of configured Accounts.
     * The responseData will contain two String[] with keys K9_ACCOUNT_UUIDS and K9_ACCOUNT_DESCRIPTIONS
     */
    public final static String K9_REQUEST_ACCOUNTS = ""com.fsck.k9.K9RemoteControl.requestAccounts"";
    public final static String K9_ACCOUNT_UUIDS = ""com.fsck.k9.K9RemoteControl.accountUuids"";
    public final static String K9_ACCOUNT_DESCRIPTIONS = ""com.fsck.k9.K9RemoteControl.accountDescriptions"";

    /**
     * The {@link {@link Intent}} Action to set in order to cause K-9 to check mail.  (Not yet implemented)
     */
    //public final static String K9_CHECK_MAIL = ""com.fsck.k9.K9RemoteControl.checkMail"";

    /**
     * The {@link {@link Intent}} Action to set when remotely changing K-9 Mail settings
     */
    public final static String K9_SET = ""com.fsck.k9.K9RemoteControl.set"";
    /**
     * The key of the {@link Intent} Extra to set to hold the UUID of a single Account's settings to change.  Used only if K9_ALL_ACCOUNTS
     * is absent or false.
     */
    public final static String K9_ACCOUNT_UUID = ""com.fsck.k9.K9RemoteControl.accountUuid"";
    /**
     * The key of the {@link Intent} Extra to set to control if the settings will apply to all Accounts, or to the one
     * specified with K9_ACCOUNT_UUID
     */
    public final static String K9_ALL_ACCOUNTS = ""com.fsck.k9.K9RemoteControl.allAccounts"";

    public final static String K9_ENABLED = ""true"";
    public final static String K9_DISABLED = ""false"";

    /*
     * Key for the {@link Intent} Extra for controlling whether notifications will be generated for new unread mail.
     * Acceptable values are K9_ENABLED and K9_DISABLED
     */
    public final static String K9_NOTIFICATION_ENABLED = ""com.fsck.k9.K9RemoteControl.notificationEnabled"";
    /*
     * Key for the {@link Intent} Extra for controlling whether K-9 will sound the ringtone for new unread mail.
     * Acceptable values are K9_ENABLED and K9_DISABLED
     */
    public final static String K9_RING_ENABLED = ""com.fsck.k9.K9RemoteControl.ringEnabled"";
    /*
     * Key for the {@link Intent} Extra for controlling whether K-9 will activate the vibrator for new unread mail.
     * Acceptable values are K9_ENABLED and K9_DISABLED
     */
    public final static String K9_VIBRATE_ENABLED = ""com.fsck.k9.K9RemoteControl.vibrateEnabled"";

    public final static String K9_FOLDERS_NONE = ""NONE"";
    public final static String K9_FOLDERS_ALL = ""ALL"";
    public final static String K9_FOLDERS_FIRST_CLASS = ""FIRST_CLASS"";
    public final static String K9_FOLDERS_FIRST_AND_SECOND_CLASS = ""FIRST_AND_SECOND_CLASS"";
    public final static String K9_FOLDERS_NOT_SECOND_CLASS = ""NOT_SECOND_CLASS"";
    /**
     * Key for the {@link Intent} Extra to set for controlling which folders to be synchronized with Push.
     * Acceptable values are K9_FOLDERS_ALL, K9_FOLDERS_FIRST_CLASS, K9_FOLDERS_FIRST_AND_SECOND_CLASS,
     * K9_FOLDERS_NOT_SECOND_CLASS, K9_FOLDERS_NONE
     */
    public final static String K9_PUSH_CLASSES = ""com.fsck.k9.K9RemoteControl.pushClasses"";
    /**
     * Key for the {@link Intent} Extra to set for controlling which folders to be synchronized with Poll.
     * Acceptable values are K9_FOLDERS_ALL, K9_FOLDERS_FIRST_CLASS, K9_FOLDERS_FIRST_AND_SECOND_CLASS,
     * K9_FOLDERS_NOT_SECOND_CLASS, K9_FOLDERS_NONE
     */
    public final static String K9_POLL_CLASSES = ""com.fsck.k9.K9RemoteControl.pollClasses"";

    public final static String[] K9_POLL_FREQUENCIES = { ""-1"", ""1"", ""5"", ""10"", ""15"", ""30"", ""60"", ""120"", ""180"", ""360"", ""720"", ""1440""};
    /**
     * Key for the {@link Intent} Extra to set with the desired poll frequency.  The value is a String representing a number of minutes.
     * Acceptable values are available in K9_POLL_FREQUENCIES
     */
    public final static String K9_POLL_FREQUENCY = ""com.fsck.k9.K9RemoteControl.pollFrequency"";

    /**
     * Key for the {@link Intent} Extra to set for controlling K-9's global ""Background sync"" setting.
     * Acceptable values are K9_BACKGROUND_OPERATIONS_ALWAYS, K9_BACKGROUND_OPERATIONS_NEVER
     * K9_BACKGROUND_OPERATIONS_WHEN_CHECKED
     */
    public final static String K9_BACKGROUND_OPERATIONS = ""com.fsck.k9.K9RemoteControl.backgroundOperations"";
    public final static String K9_BACKGROUND_OPERATIONS_WHEN_CHECKED = ""WHEN_CHECKED"";
    public final static String K9_BACKGROUND_OPERATIONS_ALWAYS = ""ALWAYS"";
    public final static String K9_BACKGROUND_OPERATIONS_NEVER = ""NEVER"";

    /**
     * Key for the {@link Intent} Extra to set for controlling which display theme K-9 will use.  Acceptable values are
     * K9_THEME_LIGHT, K9_THEME_DARK
     */
    public final static String K9_THEME = ""com.fsck.k9.K9RemoteControl.theme"";
    public final static String K9_THEME_LIGHT = ""LIGHT"";
    public final static String K9_THEME_DARK = ""DARK"";

    protected static String LOG_TAG = ""K9RemoteControl"";

    public static void set(Context context, Intent broadcastIntent)
    {
        broadcastIntent.setAction(K9RemoteControl.K9_SET);
        context.sendBroadcast(broadcastIntent, K9RemoteControl.K9_REMOTE_CONTROL_PERMISSION);
    }

    public static void fetchAccounts(Context context, K9AccountReceptor receptor)
    {
        Intent accountFetchIntent = new Intent();
        accountFetchIntent.setAction(K9RemoteControl.K9_REQUEST_ACCOUNTS);
        AccountReceiver receiver = new AccountReceiver(receptor);
        context.sendOrderedBroadcast(accountFetchIntent, K9RemoteControl.K9_REMOTE_CONTROL_PERMISSION, receiver, null, Activity.RESULT_OK, null, null);
    }

}


",False,5,1,2,1,2,3,2,L4
47,com.fsck.k9.remotecontrol.K9AccountReceptor.java,"package com.fsck.k9.remotecontrol;
/**
 *
 * @author Daniel I. Applebaum
 * The interface to implement in order to accept the arrays containing the UUIDs and descriptions of
 * the accounts configured in K-9 Mail.  Should be passed to fetchAccounts(Context, K9AccountReceptor)
 */
public interface K9AccountReceptor
{
    public void accounts(String[] uuids, String[] descriptions);
}",False,5,2,2,0,0,2,0,L4
48,com.fsck.k9.remotecontrol.AccountReceiver.java,"package com.fsck.k9.remotecontrol;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

class AccountReceiver extends BroadcastReceiver
{
    K9AccountReceptor receptor = null;

    protected AccountReceiver(K9AccountReceptor nReceptor)
    {
        receptor = nReceptor;
    }

    @Override
    public void onReceive(Context context, Intent intent)
    {
        if (K9RemoteControl.K9_REQUEST_ACCOUNTS.equals(intent.getAction()))
        {
            Bundle bundle = getResultExtras(false);
            if (bundle == null)
            {
                Log.w(K9RemoteControl.LOG_TAG, ""Response bundle is empty"");
                return;
            }
            receptor.accounts(bundle.getStringArray(K9RemoteControl.K9_ACCOUNT_UUIDS), bundle.getStringArray(K9RemoteControl.K9_ACCOUNT_DESCRIPTIONS));
        }
    }

}
",False,3,0,0,1,2,1,2,L4
49,com.fsck.k9.provider.AttachmentProvider.java,"package com.fsck.k9.provider;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.database.sqlite.SQLiteDatabase;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.os.Environment;
import android.os.ParcelFileDescriptor;
import android.util.Log;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.mail.internet.MimeUtility;

import java.io.*;
import java.util.List;

/*
 * A simple ContentProvider that allows file access to Email's attachments.
 */
public class AttachmentProvider extends ContentProvider
{
    public static final Uri CONTENT_URI = Uri.parse(""content://com.fsck.k9.attachmentprovider"");

    private static final String FORMAT_RAW = ""RAW"";
    private static final String FORMAT_THUMBNAIL = ""THUMBNAIL"";

    public static class AttachmentProviderColumns
    {
        public static final String _ID = ""_id"";
        public static final String DATA = ""_data"";
        public static final String DISPLAY_NAME = ""_display_name"";
        public static final String SIZE = ""_size"";
    }

    public static Uri getAttachmentUri(Account account, long id)
    {
        return CONTENT_URI.buildUpon()
               .appendPath(account.getUuid() + "".db"")
               .appendPath(Long.toString(id))
               .appendPath(FORMAT_RAW)
               .build();
    }

    public static Uri getAttachmentThumbnailUri(Account account, long id, int width, int height)
    {
        return CONTENT_URI.buildUpon()
               .appendPath(account.getUuid() + "".db"")
               .appendPath(Long.toString(id))
               .appendPath(FORMAT_THUMBNAIL)
               .appendPath(Integer.toString(width))
               .appendPath(Integer.toString(height))
               .build();
    }

    public static Uri getAttachmentUri(String db, long id)
    {
        return CONTENT_URI.buildUpon()
               .appendPath(db)
               .appendPath(Long.toString(id))
               .appendPath(FORMAT_RAW)
               .build();
    }

    @Override
    public boolean onCreate()
    {
        /*
         * We use the cache dir as a temporary directory (since Android doesn't give us one) so
         * on startup we'll clean up any .tmp files from the last run.
         */
        File[] files = getContext().getCacheDir().listFiles();
        for (File file : files)
        {
            if (file.getName().endsWith("".tmp""))
            {
                file.delete();
            }
        }
        return true;
    }

    public static void clear(Context lContext)
    {
        /*
         * We use the cache dir as a temporary directory (since Android doesn't give us one) so
         * on startup we'll clean up any .tmp files from the last run.
         */
        File[] files = lContext.getCacheDir().listFiles();
        for (File file : files)
        {
            try
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Deleting file "" + file.getCanonicalPath());
            }
            catch (IOException ioe) {}   // No need to log failure to log
            file.delete();
        }
    }

    @Override
    public String getType(Uri uri)
    {
        List<String> segments = uri.getPathSegments();
        String dbName = segments.get(0);
        String id = segments.get(1);
        String format = segments.get(2);
        if (FORMAT_THUMBNAIL.equals(format))
        {
            return ""image/png"";
        }
        else
        {
            String path = getContext().getDatabasePath(dbName).getAbsolutePath();
            SQLiteDatabase db = null;
            Cursor cursor = null;
            try
            {
                db = SQLiteDatabase.openDatabase(path, null, 0);
                cursor = db.query(
                             ""attachments"",
                             new String[] { ""mime_type"", ""name"" },
                             ""id = ?"",
                             new String[] { id },
                             null,
                             null,
                             null);
                cursor.moveToFirst();
                String type = cursor.getString(0);
                String name = cursor.getString(1);
                cursor.close();
                db.close();

                if (MimeUtility.DEFAULT_ATTACHMENT_MIME_TYPE.equals(type))
                {
                    type = MimeUtility.getMimeTypeByExtension(name);
                }
                return type;
            }
            finally
            {
                if (cursor != null)
                {
                    cursor.close();
                }
                if (db != null)
                {
                    db.close();
                }

            }
        }
    }

    private File getFile(String dbName, String id)
        throws FileNotFoundException
    {
        try
        {
            File attachmentsDir = getContext().getDatabasePath(dbName + ""_att"");
            File file = new File(attachmentsDir, id);
            if (!file.exists())
            {
                file = new File(""/sdcard""  + attachmentsDir.getCanonicalPath().substring(""/data"".length()), id);
                if (!file.exists()) {
                    throw new FileNotFoundException();
                }
            }
            return file;
        }
        catch (IOException e)
        {
            Log.w(K9.LOG_TAG, null, e);
            throw new FileNotFoundException(e.getMessage());
        }
    }

    @Override
    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException
    {
        List<String> segments = uri.getPathSegments();
        String dbName = segments.get(0);
        String id = segments.get(1);
        String format = segments.get(2);
        if (FORMAT_THUMBNAIL.equals(format))
        {
            int width = Integer.parseInt(segments.get(3));
            int height = Integer.parseInt(segments.get(4));
            String filename = ""thmb_"" + dbName + ""_"" + id;
            File dir = getContext().getCacheDir();
            File file = new File(dir, filename);
            if (!file.exists())
            {
                Uri attachmentUri = getAttachmentUri(dbName, Long.parseLong(id));
                String type = getType(attachmentUri);
                try
                {
                    FileInputStream in = new FileInputStream(getFile(dbName, id));
                    Bitmap thumbnail = createThumbnail(type, in);
                    thumbnail = Bitmap.createScaledBitmap(thumbnail, width, height, true);
                    FileOutputStream out = new FileOutputStream(file);
                    thumbnail.compress(Bitmap.CompressFormat.PNG, 100, out);
                    out.close();
                    in.close();
                }
                catch (IOException ioe)
                {
                    return null;
                }
            }
            return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
        }
        else
        {
            return ParcelFileDescriptor.open(
                       getFile(dbName, id),
                       ParcelFileDescriptor.MODE_READ_ONLY);
        }
    }

    @Override
    public int delete(Uri uri, String arg1, String[] arg2)
    {
        return 0;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values)
    {
        return null;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
                        String sortOrder)
    {
        if (projection == null)
        {
            projection =
                new String[]
            {
                AttachmentProviderColumns._ID,
                AttachmentProviderColumns.DATA,
            };
        }

        List<String> segments = uri.getPathSegments();
        String dbName = segments.get(0);
        String id = segments.get(1);
        String format = segments.get(2);
        String path = getContext().getDatabasePath(dbName).getAbsolutePath();
        String name = null;
        int size = -1;
        SQLiteDatabase db = null;
        Cursor cursor = null;
        try
        {
            db = SQLiteDatabase.openDatabase(path, null, 0);
            cursor = db.query(
                         ""attachments"",
                         new String[] { ""name"", ""size"" },
                         ""id = ?"",
                         new String[] { id },
                         null,
                         null,
                         null);
            if (!cursor.moveToFirst())
            {
                return null;
            }
            name = cursor.getString(0);
            size = cursor.getInt(1);
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
            if (db != null)
            {
                db.close();
            }
        }

        MatrixCursor ret = new MatrixCursor(projection);
        Object[] values = new Object[projection.length];
        for (int i = 0, count = projection.length; i < count; i++)
        {
            String column = projection[i];
            if (AttachmentProviderColumns._ID.equals(column))
            {
                values[i] = id;
            }
            else if (AttachmentProviderColumns.DATA.equals(column))
            {
                values[i] = uri.toString();
            }
            else if (AttachmentProviderColumns.DISPLAY_NAME.equals(column))
            {
                values[i] = name;
            }
            else if (AttachmentProviderColumns.SIZE.equals(column))
            {
                values[i] = size;
            }
        }
        ret.addRow(values);
        return ret;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
    {
        return 0;
    }

    private Bitmap createThumbnail(String type, InputStream data)
    {
        if (MimeUtility.mimeTypeMatches(type, ""image/*""))
        {
            return createImageThumbnail(data);
        }
        return null;
    }

    private Bitmap createImageThumbnail(InputStream data)
    {
        try
        {
            Bitmap bitmap = BitmapFactory.decodeStream(data);
            return bitmap;
        }
        catch (OutOfMemoryError oome)
        {
            /*
             * Improperly downloaded images, corrupt bitmaps and the like can commonly
             * cause OOME due to invalid allocation sizes. We're happy with a null bitmap in
             * that case. If the system is really out of memory we'll know about it soon
             * enough.
             */
            return null;
        }
        catch (Exception e)
        {
            return null;
        }
    }
}
",True,189,0,0,8,44,2,3,L1
50,com.fsck.k9.service.PollService.java,"package com.fsck.k9.service;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.IBinder;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Log;
import com.fsck.k9.*;

import java.util.HashMap;

public class PollService extends CoreService
{
    private static String START_SERVICE = ""com.fsck.k9.service.PollService.startService"";
    private static String STOP_SERVICE = ""com.fsck.k9.service.PollService.stopService"";

    private Listener mListener = new Listener();

    public static void startService(Context context)
    {
        Intent i = new Intent();
        i.setClass(context, PollService.class);
        i.setAction(PollService.START_SERVICE);
        addWakeLock(context, i);
        context.startService(i);
    }

    public static void stopService(Context context)
    {
        Intent i = new Intent();
        i.setClass(context, PollService.class);
        i.setAction(PollService.STOP_SERVICE);
        addWakeLock(context, i);
        context.startService(i);
    }

    @Override
    public void startService(Intent intent, int startId)
    {
        if (START_SERVICE.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PollService started with startId = "" + startId);

            MessagingController controller = MessagingController.getInstance(getApplication());
            Listener listener = (Listener)controller.getCheckMailListener();
            if (listener == null)
            {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""***** PollService *****: starting new check"");
                mListener.setStartId(startId);
                mListener.wakeLockAcquire();
                controller.setCheckMailListener(mListener);
                controller.checkMail(this, null, false, false, mListener);
            }
            else
            {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG,""***** PollService *****: renewing WakeLock"");
                listener.setStartId(startId);
                listener.wakeLockAcquire();
            }
        }
        else if (STOP_SERVICE.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PollService stopping"");
            stopSelf();
        }

    }

    @Override
    public IBinder onBind(Intent arg0)
    {
        return null;
    }

    class Listener extends MessagingListener
    {
        HashMap<String, Integer> accountsChecked = new HashMap<String, Integer>();
        private WakeLock wakeLock = null;
        private int startId = -1;

        // wakelock strategy is to be very conservative.  If there is any reason to release, then release
        // don't want to take the chance of running wild
        public synchronized void wakeLockAcquire()
        {
            WakeLock oldWakeLock = wakeLock;

            PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
            wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""K9"");
            wakeLock.setReferenceCounted(false);
            wakeLock.acquire(K9.WAKE_LOCK_TIMEOUT);

            if (oldWakeLock != null)
            {
                oldWakeLock.release();
            }

        }
        public synchronized void wakeLockRelease()
        {
            if (wakeLock != null)
            {
                wakeLock.release();
                wakeLock = null;
            }
        }
        @Override
        public void checkMailStarted(Context context, Account account)
        {
            accountsChecked.clear();
        }

        @Override
        public void checkMailFailed(Context context, Account account, String reason)
        {
            release();
        }

        @Override
        public void synchronizeMailboxFinished(
            Account account,
            String folder,
            int totalMessagesInMailbox,
            int numNewMessages)
        {
            if (account.isNotifyNewMail())
            {
                Integer existingNewMessages = accountsChecked.get(account.getUuid());
                if (existingNewMessages == null)
                {
                    existingNewMessages = 0;
                }
                accountsChecked.put(account.getUuid(), existingNewMessages + numNewMessages);
            }
        }

        private void release()
        {
            MailService.saveLastCheckEnd(getApplication());
            
            MessagingController controller = MessagingController.getInstance(getApplication());
            controller.setCheckMailListener(null);
            MailService.actionReschedulePoll(PollService.this, null);
            wakeLockRelease();
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PollService stopping with startId = "" + startId);

            stopSelf(startId);
        }

        @Override
        public void checkMailFinished(Context context, Account account)
        {

            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""***** PollService *****: checkMailFinished"");
            release();
        }
        public int getStartId()
        {
            return startId;
        }
        public void setStartId(int startId)
        {
            this.startId = startId;
        }
    }

}
",False,189,0,0,8,48,1,6,L1
51,com.fsck.k9.service.PushService.java,"package com.fsck.k9.service;

import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.util.Log;
import com.fsck.k9.K9;

public class PushService extends CoreService
{
    private static String START_SERVICE = ""com.fsck.k9.service.PushService.startService"";
    private static String STOP_SERVICE = ""com.fsck.k9.service.PushService.stopService"";

    public static void startService(Context context)
    {
        Intent i = new Intent();
        i.setClass(context, PushService.class);
        i.setAction(PushService.START_SERVICE);
        addWakeLock(context, i);
        context.startService(i);
    }

    public static void stopService(Context context)
    {
        Intent i = new Intent();
        i.setClass(context, PushService.class);
        i.setAction(PushService.STOP_SERVICE);
        addWakeLock(context, i);
        context.startService(i);
    }

    @Override
    public void startService(Intent intent, int startId)
    {
        if (START_SERVICE.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PushService started with startId = "" + startId);
        }
        else if (STOP_SERVICE.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PushService stopping with startId = "" + startId);
            stopSelf(startId);
        }

    }

    @Override
    public IBinder onBind(Intent arg0)
    {
        // TODO Auto-generated method stub
        return null;
    }
}
",False,189,0,0,9,52,1,2,L1
52,com.fsck.k9.service.RemoteControlReceiver.java,"
package com.fsck.k9.service;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.remotecontrol.K9RemoteControl;
import com.fsck.k9.Preferences;

import static com.fsck.k9.remotecontrol.K9RemoteControl.*;

public class RemoteControlReceiver extends CoreReceiver
{
    public Integer receive(Context context, Intent intent, Integer tmpWakeLockId)
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""RemoteControlReceiver.onReceive"" + intent);

        if (K9RemoteControl.K9_SET.equals(intent.getAction()))
        {
            RemoteControlService.set(context, intent, tmpWakeLockId);
            tmpWakeLockId = null;
        }
        else if (K9RemoteControl.K9_REQUEST_ACCOUNTS.equals(intent.getAction()))
        {
            try
            {
                Preferences preferences = Preferences.getPreferences(context);
                Account[] accounts = preferences.getAccounts();
                String[] uuids = new String[accounts.length];
                String[] descriptions = new String[accounts.length];
                for (int i = 0; i < accounts.length; i++)
                {
                    Account account = accounts[i];

                    uuids[i] = account.getUuid();
                    descriptions[i] = account.getDescription();
                }
                Bundle bundle = getResultExtras(true);
                bundle.putStringArray(K9_ACCOUNT_UUIDS, uuids);
                bundle.putStringArray(K9_ACCOUNT_DESCRIPTIONS, descriptions);
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Could not handle K9_RESPONSE_INTENT"", e);
            }

        }

        return tmpWakeLockId;
    }

}
",True,194,0,0,8,46,0,6,L4
53,com.fsck.k9.service.RemoteControlService.java,"package com.fsck.k9.service;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.remotecontrol.K9RemoteControl;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.K9.BACKGROUND_OPS;

import static com.fsck.k9.remotecontrol.K9RemoteControl.*;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.util.Log;
import android.widget.Toast;

public class RemoteControlService extends CoreService
{
    private final static String RESCHEDULE_ACTION = ""com.fsck.k9.service.RemoteControlService.RESCHEDULE_ACTION"";
    private final static String PUSH_RESTART_ACTION = ""com.fsck.k9.service.RemoteControlService.PUSH_RESTART_ACTION"";

    private final static String SET_ACTION = ""com.fsck.k9.service.RemoteControlService.SET_ACTION"";

    public static void set(Context context, Intent i, Integer wakeLockId)
    {
        //  Intent i = new Intent();
        i.setClass(context, RemoteControlService.class);
        i.setAction(RemoteControlService.SET_ACTION);
        addWakeLockId(i, wakeLockId);
        if (wakeLockId == null)
        {
            addWakeLock(context, i);
        }
        context.startService(i);
    }

    public static final int REMOTE_CONTROL_SERVICE_WAKE_LOCK_TIMEOUT = 20000;

    @Override
    public void startService(final Intent intent, final int startId)
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""RemoteControlService started with startId = "" + startId);
        final Preferences preferences = Preferences.getPreferences(this);

        if (RESCHEDULE_ACTION.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""RemoteControlService requesting MailService poll reschedule"");
            MailService.actionReschedulePoll(this, null);
        }
        if (PUSH_RESTART_ACTION.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""RemoteControlService requesting MailService push restart"");
            MailService.actionRestartPushers(this, null);
        }
        else if (RemoteControlService.SET_ACTION.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""RemoteControlService got request to change settings"");
            execute(getApplication(), new Runnable()
            {
                public void run()
                {
                    try
                    {
                        boolean needsReschedule = false;
                        boolean needsPushRestart = false;
                        String uuid = intent.getStringExtra(K9_ACCOUNT_UUID);
                        boolean allAccounts = intent.getBooleanExtra(K9_ALL_ACCOUNTS, false);
                        if (K9.DEBUG)
                        {
                            if (allAccounts)
                            {
                                Log.i(K9.LOG_TAG, ""RemoteControlService changing settings for all accounts"");
                            }
                            else
                            {
                                Log.i(K9.LOG_TAG, ""RemoteControlService changing settings for account with UUID "" + uuid);
                            }
                        }
                        Account[] accounts = preferences.getAccounts();
                        for (Account account : accounts)
                        {
                            if (allAccounts || account.getUuid().equals(uuid))
                            {

                                if (K9.DEBUG)
                                    Log.i(K9.LOG_TAG, ""RemoteControlService changing settings for account "" + account.getDescription());

                                String notificationEnabled = intent.getStringExtra(K9_NOTIFICATION_ENABLED);
                                String ringEnabled = intent.getStringExtra(K9_RING_ENABLED);
                                String vibrateEnabled = intent.getStringExtra(K9_VIBRATE_ENABLED);
                                String pushClasses = intent.getStringExtra(K9_PUSH_CLASSES);
                                String pollClasses = intent.getStringExtra(K9_POLL_CLASSES);
                                String pollFrequency = intent.getStringExtra(K9_POLL_FREQUENCY);

                                if (notificationEnabled != null)
                                {
                                    account.setNotifyNewMail(Boolean.parseBoolean(notificationEnabled));
                                }
                                if (ringEnabled != null)
                                {
                                    account.setRing(Boolean.parseBoolean(ringEnabled));
                                }
                                if (vibrateEnabled != null)
                                {
                                    account.setVibrate(Boolean.parseBoolean(vibrateEnabled));
                                }
                                if (pushClasses != null)
                                {
                                    needsPushRestart |= account.setFolderPushMode(FolderMode.valueOf(pushClasses));
                                }
                                if (pollClasses != null)
                                {
                                    needsReschedule |= account.setFolderSyncMode(FolderMode.valueOf(pollClasses));
                                }
                                if (pollFrequency != null)
                                {
                                    String[] allowedFrequencies = getResources().getStringArray(R.array.account_settings_check_frequency_values);
                                    for (String allowedFrequency : allowedFrequencies)
                                    {
                                        if (allowedFrequency.equals(pollFrequency))
                                        {
                                            Integer newInterval = Integer.parseInt(allowedFrequency);
                                            needsReschedule |= account.setAutomaticCheckIntervalMinutes(newInterval);
                                        }
                                    }
                                }
                                account.save(Preferences.getPreferences(RemoteControlService.this));
                            }
                        }
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""RemoteControlService changing global settings"");

                        String backgroundOps = intent.getStringExtra(K9_BACKGROUND_OPERATIONS);
                        if (K9RemoteControl.K9_BACKGROUND_OPERATIONS_ALWAYS.equals(backgroundOps)
                                || K9RemoteControl.K9_BACKGROUND_OPERATIONS_NEVER.equals(backgroundOps)
                                || K9RemoteControl.K9_BACKGROUND_OPERATIONS_WHEN_CHECKED.equals(backgroundOps))
                        {
                            BACKGROUND_OPS newBackgroundOps = BACKGROUND_OPS.valueOf(backgroundOps);
                            boolean needsReset = K9.setBackgroundOps(newBackgroundOps);
                            needsPushRestart |= needsReset;
                            needsReschedule |= needsReset;
                        }

                        String theme = intent.getStringExtra(K9_THEME);
                        if (theme != null)
                        {
                            K9.setK9Theme(K9RemoteControl.K9_THEME_DARK.equals(theme) ? android.R.style.Theme : android.R.style.Theme_Light);
                        }

                        SharedPreferences sPrefs = preferences.getPreferences();

                        Editor editor = sPrefs.edit();
                        K9.save(editor);
                        editor.commit();
                        
                        if (needsReschedule)
                        {
                            Intent i = new Intent();
                            i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.RemoteControlService"");
                            i.setAction(RESCHEDULE_ACTION);
                            long nextTime = System.currentTimeMillis() + 10000;
                            BootReceiver.scheduleIntent(RemoteControlService.this, nextTime, i);
                        }
                        if (needsPushRestart)
                        {
                            Intent i = new Intent();
                            i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.RemoteControlService"");
                            i.setAction(PUSH_RESTART_ACTION);
                            long nextTime = System.currentTimeMillis() + 10000;
                            BootReceiver.scheduleIntent(RemoteControlService.this, nextTime, i);
                        }
                    }
                    catch (Exception e)
                    {
                        Log.e(K9.LOG_TAG, ""Could not handle K9_SET"", e);
                        Toast toast = Toast.makeText(RemoteControlService.this, e.getMessage(), Toast.LENGTH_LONG);
                        toast.show();
                    }
                }
            }
            , RemoteControlService.REMOTE_CONTROL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
        }
    }

}
",True,194,1,1,8,46,1,7,L4
54,com.fsck.k9.service.SleepService.java,"package com.fsck.k9.service;

import android.content.Context;
import android.content.Intent;
import android.os.PowerManager.WakeLock;
import android.util.Log;
import com.fsck.k9.K9;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class SleepService extends CoreService
{

    private static String ALARM_FIRED = ""com.fsck.k9.service.SleepService.ALARM_FIRED"";
    private static String LATCH_ID = ""com.fsck.k9.service.SleepService.LATCH_ID_EXTRA"";


    private static ConcurrentHashMap<Integer, SleepDatum> sleepData = new ConcurrentHashMap<Integer, SleepDatum>();

    private static AtomicInteger latchId = new AtomicInteger();

    public static void sleep(Context context, long sleepTime, WakeLock wakeLock, long wakeLockTimeout)
    {
        Integer id = latchId.getAndIncrement();
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SleepService Preparing CountDownLatch with id = "" + id + "", thread "" + Thread.currentThread().getName());
        SleepDatum sleepDatum = new SleepDatum();
        CountDownLatch latch = new CountDownLatch(1);
        sleepDatum.latch = latch;
        sleepData.put(id, sleepDatum);

        Intent i = new Intent();
        i.setClassName(context.getPackageName(), ""com.fsck.k9.service.SleepService"");
        i.putExtra(LATCH_ID, id);
        i.setAction(ALARM_FIRED + ""."" + id);
        long startTime = System.currentTimeMillis();
        long nextTime = startTime + sleepTime;
        BootReceiver.scheduleIntent(context, nextTime, i);
        if (wakeLock != null)
        {
            sleepDatum.wakeLock = wakeLock;
            sleepDatum.timeout = wakeLockTimeout;
            wakeLock.release();
        }
        try
        {
            boolean timedOut = latch.await(sleepTime, TimeUnit.MILLISECONDS);
            if (timedOut == false)
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SleepService latch timed out for id = "" + id + "", thread "" + Thread.currentThread().getName());
                // don't call endSleep here or remove the sleepDatum here, instead of the following block.
                // We might not get the wakeLock before
                // falling asleep again, so we have to get the wakeLock *first*  The alarmed version will
                // already be running in a WakeLock due to the nature of AlarmManager
                sleepDatum = sleepData.get(id);
                if (sleepDatum != null)
                {
                    reacquireWakeLock(sleepDatum);
                    // OK, we have the wakeLock, now we can remove the sleepDatum
                    sleepData.remove(id);
                }

            }
        }
        catch (InterruptedException ie)
        {
            Log.e(K9.LOG_TAG, ""SleepService Interrupted"", ie);
        }
        long endTime = System.currentTimeMillis();
        long actualSleep = endTime - startTime;
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SleepService requested sleep time was "" + sleepTime + "", actual was "" + actualSleep);
        if (actualSleep < sleepTime)
        {
            Log.w(K9.LOG_TAG, ""SleepService sleep time too short: requested was "" + sleepTime + "", actual was "" + actualSleep);
        }
    }

    private static void endSleep(Integer id)
    {
        if (id != -1)
        {
            SleepDatum sleepDatum = sleepData.remove(id);
            if (sleepDatum != null)
            {
                CountDownLatch latch = sleepDatum.latch;
                if (latch == null)
                {
                    Log.e(K9.LOG_TAG, ""SleepService No CountDownLatch available with id = "" + id);
                }
                else
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""SleepService Counting down CountDownLatch with id = "" + id);
                    latch.countDown();
                }
                reacquireWakeLock(sleepDatum);
            }
            else
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SleepService Sleep for id "" + id + "" already finished"");
            }
        }
    }

    private static void reacquireWakeLock(SleepDatum sleepDatum)
    {
        WakeLock wakeLock = sleepDatum.wakeLock;
        if (wakeLock != null)
        {
            synchronized (wakeLock)
            {
                long timeout = sleepDatum.timeout;
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SleepService Acquring wakeLock for id for "" + timeout + ""ms"");
                wakeLock.acquire(timeout);
            }
        }
    }

    @Override
    public void startService(Intent intent, int startId)
    {
        if (intent.getAction().startsWith(ALARM_FIRED))
        {
            Integer id = intent.getIntExtra(LATCH_ID, -1);
            endSleep(id);
        }
        stopSelf(startId);
    }

    private static class SleepDatum
    {
        CountDownLatch latch;
        WakeLock wakeLock;
        long timeout;
    }

}
",False,189,0,0,9,52,1,3,L1
55,com.fsck.k9.service.MailService.java,"
package com.fsck.k9.service;

import java.util.Collection;
import java.util.Date;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.NetworkInfo.State;
import android.os.IBinder;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.MessagingController;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.mail.Pusher;

/**
 */
public class MailService extends CoreService
{
    private static final String ACTION_CHECK_MAIL = ""com.fsck.k9.intent.action.MAIL_SERVICE_WAKEUP"";
    private static final String ACTION_RESET = ""com.fsck.k9.intent.action.MAIL_SERVICE_RESET"";
    private static final String ACTION_RESCHEDULE_POLL = ""com.fsck.k9.intent.action.MAIL_SERVICE_RESCHEDULE_POLL"";
    private static final String ACTION_CANCEL = ""com.fsck.k9.intent.action.MAIL_SERVICE_CANCEL"";
    private static final String ACTION_REFRESH_PUSHERS = ""com.fsck.k9.intent.action.MAIL_SERVICE_REFRESH_PUSHERS"";
    private static final String ACTION_RESTART_PUSHERS = ""com.fsck.k9.intent.action.MAIL_SERVICE_RESTART_PUSHERS"";
    private static final String CONNECTIVITY_CHANGE = ""com.fsck.k9.intent.action.MAIL_SERVICE_CONNECTIVITY_CHANGE"";
    private static final String CANCEL_CONNECTIVITY_NOTICE = ""com.fsck.k9.intent.action.MAIL_SERVICE_CANCEL_CONNECTIVITY_NOTICE"";

    private static final String HAS_CONNECTIVITY = ""com.fsck.k9.intent.action.MAIL_SERVICE_HAS_CONNECTIVITY"";
    
    private static long nextCheck = -1;

    public static void actionReset(Context context, Integer wakeLockId)
    {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_RESET);
        addWakeLockId(i, wakeLockId);
        if (wakeLockId == null)
        {
            addWakeLock(context, i);
        }
        context.startService(i);
    }
    
    public static void actionRestartPushers(Context context, Integer wakeLockId)
    {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_RESTART_PUSHERS);
        addWakeLockId(i, wakeLockId);
        if (wakeLockId == null)
        {
            addWakeLock(context, i);
        }
        context.startService(i);
    }
    
    public static void actionReschedulePoll(Context context, Integer wakeLockId)
    {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_RESCHEDULE_POLL);
        addWakeLockId(i, wakeLockId);
        if (wakeLockId == null)
        {
            addWakeLock(context, i);
        }
        context.startService(i);
    }

    public static void actionCancel(Context context, Integer wakeLockId)
    {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_CANCEL);
        addWakeLockId(i, wakeLockId);
        context.startService(i);
    }

    public static void connectivityChange(Context context, boolean hasConnectivity, Integer wakeLockId)
    {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.CONNECTIVITY_CHANGE);
        i.putExtra(HAS_CONNECTIVITY, hasConnectivity);
        addWakeLockId(i, wakeLockId);
        context.startService(i);
    }

    @Override
    public void onCreate()
    {
        super.onCreate();
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""***** MailService *****: onCreate"");
    }

    @Override
    public void startService(Intent intent, int startId)
    {
        Integer startIdObj = startId;
        long startTime = System.currentTimeMillis();
        try
        {
            ConnectivityManager connectivityManager = (ConnectivityManager)getApplication().getSystemService(Context.CONNECTIVITY_SERVICE);
            boolean doBackground = true;
            boolean hasConnectivity = false;

            if (connectivityManager != null)
            {
                NetworkInfo netInfo = connectivityManager.getActiveNetworkInfo();
                if (netInfo != null)
                {
                    State state = netInfo.getState();
                    hasConnectivity = state == State.CONNECTED;
                }
                boolean backgroundData = connectivityManager.getBackgroundDataSetting();

                K9.BACKGROUND_OPS bOps = K9.getBackgroundOps();
                doBackground = (backgroundData == true && bOps != K9.BACKGROUND_OPS.NEVER)
                               | (backgroundData == false && bOps == K9.BACKGROUND_OPS.ALWAYS);

            }

            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""MailService.onStart("" + intent + "", "" + startId
                      + ""), hasConnectivity = "" + hasConnectivity + "", doBackground = "" + doBackground);

            // MessagingController.getInstance(getApplication()).addListener(mListener);
            if (ACTION_CHECK_MAIL.equals(intent.getAction()))
            {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""***** MailService *****: checking mail"");

                if (hasConnectivity && doBackground)
                {
                    PollService.startService(this);
                }
                reschedulePoll(hasConnectivity, doBackground, startIdObj, false);
                startIdObj = null;
            }
            else if (ACTION_CANCEL.equals(intent.getAction()))
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""***** MailService *****: cancel"");

                cancel();
            }
            else if (ACTION_RESET.equals(intent.getAction()))
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""***** MailService *****: reschedule"");

                rescheduleAll(hasConnectivity, doBackground, startIdObj);
                startIdObj = null;

            }
            else if (ACTION_RESTART_PUSHERS.equals(intent.getAction()))
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""***** MailService *****: restarting pushers"");
                reschedulePushers(hasConnectivity, doBackground, startIdObj);
                startIdObj = null;

            }
            else if (ACTION_RESCHEDULE_POLL.equals(intent.getAction()))
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""***** MailService *****: rescheduling poll"");
                reschedulePoll(hasConnectivity, doBackground, startIdObj, true);
                startIdObj = null;

            }
            else if (ACTION_REFRESH_PUSHERS.equals(intent.getAction()))
            {
                if (hasConnectivity && doBackground)
                {
                    schedulePushers(null);
                    refreshPushers(startIdObj);
                    startIdObj = null;
                }
            }
            else if (CONNECTIVITY_CHANGE.equals(intent.getAction()) )
            {
                notifyConnectionStatus(hasConnectivity);
                rescheduleAll(hasConnectivity, doBackground, startIdObj);
                startIdObj = null;
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Got connectivity action with hasConnectivity = "" + hasConnectivity + "", doBackground = "" + doBackground);
            }
            else if (CANCEL_CONNECTIVITY_NOTICE.equals(intent.getAction()))
            {
                notifyConnectionStatus(true);
            }
        }
        finally
        {
            if (startIdObj != null)
            {
                stopSelf(startId);
            }
        }
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""MailService.onStart took "" + (System.currentTimeMillis() - startTime) + ""ms"");
    }

    private void rescheduleAll(final boolean hasConnectivity, final boolean doBackground, final Integer startId)
    {
        reschedulePoll(hasConnectivity, doBackground, null, true);
        reschedulePushers(hasConnectivity, doBackground, startId);
        
    }

    private void notifyConnectionStatus(boolean hasConnectivity)
    {
        if (true) return;
        NotificationManager notifMgr =
            (NotificationManager)getApplication().getSystemService(Context.NOTIFICATION_SERVICE);
        if (hasConnectivity == false)
        {
            String notice = getApplication().getString(R.string.no_connection_alert);
            String header = getApplication().getString(R.string.alert_header);


            Notification notif = new Notification(R.drawable.stat_notify_email_generic,
                                                  header, System.currentTimeMillis());

            Intent i = new Intent();
            i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.MailService"");
            i.setAction(MailService.CANCEL_CONNECTIVITY_NOTICE);

            PendingIntent pi = PendingIntent.getService(this, 0, i, 0);

            notif.setLatestEventInfo(getApplication(), header, notice, pi);
            notif.flags = Notification.FLAG_ONGOING_EVENT;

            notifMgr.notify(K9.CONNECTIVITY_ID, notif);
        }
        else
        {
            notifMgr.cancel(K9.CONNECTIVITY_ID);
        }
    }

    @Override
    public void onDestroy()
    {
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""***** MailService *****: onDestroy()"");
        super.onDestroy();
        //     MessagingController.getInstance(getApplication()).removeListener(mListener);
    }

    private void cancel()
    {
        Intent i = new Intent();
        i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.MailService"");
        i.setAction(ACTION_CHECK_MAIL);
        BootReceiver.cancelIntent(this, i);
    }

    private final static String PREVIOUS_INTERVAL = ""MailService.previousInterval"";
    private final static String LAST_CHECK_END = ""MailService.lastCheckEnd"";
    
    public static void saveLastCheckEnd(Context context)
    {
        
        long lastCheckEnd = System.currentTimeMillis();
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Saving lastCheckEnd = "" + new Date(lastCheckEnd));
        Preferences prefs = Preferences.getPreferences(context);
        SharedPreferences sPrefs = prefs.getPreferences();
        SharedPreferences.Editor editor = sPrefs.edit();
        editor.putLong(LAST_CHECK_END, lastCheckEnd);
        editor.commit();
    }
   
    private void reschedulePoll(final boolean hasConnectivity, final boolean doBackground, Integer startId, final boolean considerLastCheckEnd)
    {
        if (hasConnectivity && doBackground)
        {
            execute(getApplication(), new Runnable()
            {
                public void run()
                {
                    int shortestInterval = -1;
                    
                    Preferences prefs = Preferences.getPreferences(MailService.this);
                    SharedPreferences sPrefs = prefs.getPreferences();
                    int previousInterval = sPrefs.getInt(PREVIOUS_INTERVAL, -1);
                    long lastCheckEnd = sPrefs.getLong(LAST_CHECK_END, -1);
                    for (Account account : prefs.getAccounts())
                    {
                        if (account.getAutomaticCheckIntervalMinutes() != -1
                                && account.getFolderSyncMode() != FolderMode.NONE
                                && (account.getAutomaticCheckIntervalMinutes() < shortestInterval || shortestInterval == -1))
                        {
                            shortestInterval = account.getAutomaticCheckIntervalMinutes();
                        }
                    }
                    SharedPreferences.Editor editor = sPrefs.edit();
                    editor.putInt(PREVIOUS_INTERVAL, shortestInterval);
                    editor.commit();
                    
                    if (shortestInterval == -1)
                    {
                        nextCheck = -1;
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""No next check scheduled for package "" + getApplication().getPackageName());
                        cancel();
                    }
                    else
                    {
                        long delay = (shortestInterval * (60 * 1000));
                        long base = (previousInterval == -1 || lastCheckEnd == -1 || considerLastCheckEnd == false ? System.currentTimeMillis() : lastCheckEnd);
                        long nextTime = base + delay;
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, 
                                    ""previousInterval = "" + previousInterval 
                                    + "", shortestInterval = "" + shortestInterval
                                    + "", lastCheckEnd = "" + new Date(lastCheckEnd)
                                    + "", considerLastCheckEnd = "" + considerLastCheckEnd);
                        nextCheck = nextTime;
                        try
                        {
                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Next check for package "" + getApplication().getPackageName() + "" scheduled for "" + new Date(nextTime));
                        }
                        catch (Exception e)
                        {
                            // I once got a NullPointerException deep in new Date();
                            Log.e(K9.LOG_TAG, ""Exception while logging"", e);
                        }
    
                        Intent i = new Intent();
                        i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.MailService"");
                        i.setAction(ACTION_CHECK_MAIL);
                        BootReceiver.scheduleIntent(MailService.this, nextTime, i);
    
                    }
                }
            }
            , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
        }
        else
        {
            nextCheck = -1;
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""No connectivity, canceling check for "" + getApplication().getPackageName());
            cancel();
        }
    }

    private void stopPushers(final Integer startId)
    {
        execute(getApplication(), new Runnable()
        {
            public void run()
            {
                MessagingController.getInstance(getApplication()).stopAllPushing();
                PushService.stopService(MailService.this);
            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
    }

    private void reschedulePushers(final boolean hasConnectivity, final boolean doBackground, final Integer startId)
    {
        execute(getApplication(), new Runnable()
        {
            public void run()
            {

                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Rescheduling pushers"");
                stopPushers(null);
                if (hasConnectivity && doBackground)
                {
                    setupPushers(null);
                    schedulePushers(startId);
                }

            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, null);
    }

    private void setupPushers(final Integer startId)
    {
        execute(getApplication(), new Runnable()
        {
            public void run()
            {
                boolean pushing = false;
                for (Account account : Preferences.getPreferences(MailService.this).getAccounts())
                {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Setting up pushers for account "" + account.getDescription());
                    pushing |= MessagingController.getInstance(getApplication()).setupPushing(account);
                }
                if (pushing)
                {
                    PushService.startService(MailService.this);
                }
            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
    }

    private void refreshPushers(final Integer startId)
    {
        execute(getApplication(), new Runnable()
        {
            public void run()
            {
                try
                {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Refreshing pushers"");
                    Collection<Pusher> pushers = MessagingController.getInstance(getApplication()).getPushers();
                    for (Pusher pusher : pushers)
                    {
                        pusher.refresh();
                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Exception while refreshing pushers"", e);
                }
            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
    }

    private void schedulePushers(final Integer startId)
    {
        execute(getApplication(), new Runnable()
        {
            public void run()
            {
                int minInterval = -1;

                Collection<Pusher> pushers = MessagingController.getInstance(getApplication()).getPushers();
                for (Pusher pusher : pushers)
                {
                    int interval = pusher.getRefreshInterval();
                    if (interval != -1 && (interval < minInterval || minInterval == -1))
                    {
                        minInterval = interval;
                    }
                }
                if (K9.DEBUG)
                {
                    Log.v(K9.LOG_TAG, ""Pusher refresh interval = "" + minInterval);
                }
                if (minInterval != -1)
                {
                    long nextTime = System.currentTimeMillis() + minInterval;
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Next pusher refresh scheduled for "" + new Date(nextTime));
                    Intent i = new Intent();
                    i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.MailService"");
                    i.setAction(ACTION_REFRESH_PUSHERS);
                    BootReceiver.scheduleIntent(MailService.this, nextTime, i);
                }
            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
    }


    public IBinder onBind(Intent intent)
    {
        return null;
    }

    public static long getNextPollTime()
    {
        return nextCheck;
    }


}
",True,191,2,1,8,46,9,9,L1
56,com.fsck.k9.service.CoreReceiver.java,"
package com.fsck.k9.service;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Log;

import com.fsck.k9.K9;

public class CoreReceiver extends BroadcastReceiver
{

    public static String WAKE_LOCK_RELEASE = ""com.fsck.k9.service.CoreReceiver.wakeLockRelease"";

    public static String WAKE_LOCK_ID = ""com.fsck.k9.service.CoreReceiver.wakeLockId"";

    private static ConcurrentHashMap<Integer, WakeLock> wakeLocks = new ConcurrentHashMap<Integer, WakeLock>();
    private static AtomicInteger wakeLockSeq = new AtomicInteger(0);

    private static Integer getWakeLock(Context context)
    {
        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
        WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""K9"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(K9.BOOT_RECEIVER_WAKE_LOCK_TIMEOUT);
        Integer tmpWakeLockId = wakeLockSeq.getAndIncrement();
        wakeLocks.put(tmpWakeLockId, wakeLock);
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""CoreReceiver Created wakeLock "" + tmpWakeLockId);
        return tmpWakeLockId;
    }

    private static void releaseWakeLock(Integer wakeLockId)
    {
        if (wakeLockId != null)
        {
            WakeLock wl = wakeLocks.remove(wakeLockId);
            if (wl != null)
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""CoreReceiver Releasing wakeLock "" + wakeLockId);
                wl.release();
            }
            else
            {
                Log.w(K9.LOG_TAG, ""BootReceiver WakeLock "" + wakeLockId + "" doesn't exist"");
            }
        }
    }

    public void onReceive(Context context, Intent intent)
    {
        Integer tmpWakeLockId = CoreReceiver.getWakeLock(context);
        try
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""CoreReceiver.onReceive"" + intent);
            if (CoreReceiver.WAKE_LOCK_RELEASE.equals(intent.getAction()))
            {
                Integer wakeLockId = intent.getIntExtra(WAKE_LOCK_ID, -1);
                if (wakeLockId != -1)
                {
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""CoreReceiver Release wakeLock "" + wakeLockId);
                    CoreReceiver.releaseWakeLock(wakeLockId);
                }
            }
            else
            {
                tmpWakeLockId = receive(context, intent, tmpWakeLockId);
            }
        }
        finally
        {
            CoreReceiver.releaseWakeLock(tmpWakeLockId);
        }
    }

    public Integer receive(Context context, Intent intent, Integer wakeLockId)
    {
        return wakeLockId;
    }

    public static void releaseWakeLock(Context context, int wakeLockId)
    {
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""CoreReceiver Got request to release wakeLock "" + wakeLockId);
        Intent i = new Intent();
        i.setClass(context, CoreReceiver.class);
        i.setAction(WAKE_LOCK_RELEASE);
        i.putExtra(WAKE_LOCK_ID, wakeLockId);
        context.sendBroadcast(i);
    }
}
",True,190,1,1,9,52,3,1,L1
57,com.fsck.k9.service.CoreService.java,"package com.fsck.k9.service;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Log;
import com.fsck.k9.K9;

public abstract class CoreService extends Service
{

    public static String WAKE_LOCK_ID = ""com.fsck.k9.service.CoreService.wakeLockId"";
    private static ConcurrentHashMap<Integer, WakeLock> wakeLocks = new ConcurrentHashMap<Integer, WakeLock>();
    private static AtomicInteger wakeLockSeq = new AtomicInteger(0);
    private final ExecutorService threadPool = Executors.newFixedThreadPool(1);  // Must be single threaded

    protected static void addWakeLockId(Intent i, Integer wakeLockId)
    {
        if (wakeLockId != null)
        {
            i.putExtra(BootReceiver.WAKE_LOCK_ID, wakeLockId);
        }
    }

    protected static void addWakeLock(Context context, Intent i)
    {
        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
        WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""K9"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT);

        Integer tmpWakeLockId = wakeLockSeq.getAndIncrement();
        wakeLocks.put(tmpWakeLockId, wakeLock);

        i.putExtra(WAKE_LOCK_ID, tmpWakeLockId);
    }

    @Override
    public void onStart(Intent intent, int startId)
    {

        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
        WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""K9"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT);

        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""CoreService: "" + this.getClass().getName() + "".onStart("" + intent + "", "" + startId);

        int wakeLockId = intent.getIntExtra(BootReceiver.WAKE_LOCK_ID, -1);
        if (wakeLockId != -1)
        {
            BootReceiver.releaseWakeLock(this, wakeLockId);
        }
        Integer coreWakeLockId = intent.getIntExtra(WAKE_LOCK_ID, -1);
        if (coreWakeLockId != null && coreWakeLockId != -1)
        {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Got core wake lock id "" + coreWakeLockId);
            WakeLock coreWakeLock = wakeLocks.remove(coreWakeLockId);
            if (coreWakeLock != null)
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Found core wake lock with id "" + coreWakeLockId + "", releasing"");
                coreWakeLock.release();
            }
        }

        try
        {
            super.onStart(intent, startId);
            startService(intent, startId);
        }
        finally
        {
            if (wakeLock != null)
            {
                wakeLock.release();
            }
        }

    }

    public void execute(Context context, final Runnable runner, int wakeLockTime, final Integer startId)
    {
        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
        final WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""K9"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(wakeLockTime);
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""CoreService ("" + getClass().getName() + "") queueing Runnable "" + runner.hashCode() + "" with startId "" + startId);
        Runnable myRunner = new Runnable()
        {
            public void run()
            {
                try
                {

                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""CoreService ("" + getClass().getName() + "") running Runnable "" + runner.hashCode() + "" with startId "" + startId);
                    runner.run();
                }
                finally
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""CoreService ("" + getClass().getName() + "") completed Runnable "" + runner.hashCode() + "" with startId "" + startId);
                    wakeLock.release();
                    if (startId != null)
                    {
                        stopSelf(startId);
                    }
                }
            }

        };

        threadPool.execute(myRunner);
    }

    public abstract void startService(Intent intent, int startId);

    @Override
    public IBinder onBind(Intent arg0)
    {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public void onDestroy()
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""CoreService: "" + this.getClass().getName() + "".onDestroy()"");
        super.onDestroy();
        //     MessagingController.getInstance(getApplication()).removeListener(mListener);
    }
}
",True,191,2,1,9,52,5,2,L1
58,com.fsck.k9.service.BootReceiver.java,"
package com.fsck.k9.service;

import java.util.Date;

import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.net.ConnectivityManager;
import android.net.Uri;
import android.util.Log;

import com.fsck.k9.K9;

public class BootReceiver extends CoreReceiver
{

    public static String FIRE_INTENT = ""com.fsck.k9.service.BroadcastReceiver.fireIntent"";
    public static String SCHEDULE_INTENT = ""com.fsck.k9.service.BroadcastReceiver.scheduleIntent"";
    public static String CANCEL_INTENT = ""com.fsck.k9.service.BroadcastReceiver.cancelIntent"";

    public static String ALARMED_INTENT = ""com.fsck.k9.service.BroadcastReceiver.pendingIntent"";
    public static String AT_TIME = ""com.fsck.k9.service.BroadcastReceiver.atTime"";

    public Integer receive(Context context, Intent intent, Integer tmpWakeLockId)
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""BootReceiver.onReceive"" + intent);

        if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction()))
        {
            //K9.setServicesEnabled(context, tmpWakeLockId);
            //tmpWakeLockId = null;
        }
        else if (Intent.ACTION_DEVICE_STORAGE_LOW.equals(intent.getAction()))
        {
            MailService.actionCancel(context, tmpWakeLockId);
            tmpWakeLockId = null;
        }
        else if (Intent.ACTION_DEVICE_STORAGE_OK.equals(intent.getAction()))
        {
            MailService.actionReset(context, tmpWakeLockId);
            tmpWakeLockId = null;
        }
        else if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction()))
        {
            boolean noConnectivity = intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, false);
            MailService.connectivityChange(context, !noConnectivity, tmpWakeLockId);
            tmpWakeLockId = null;
        }
        else if (ConnectivityManager.ACTION_BACKGROUND_DATA_SETTING_CHANGED.equals(intent.getAction()))
        {
            MailService.actionReset(context, tmpWakeLockId);
            tmpWakeLockId = null;
        }
        else if (FIRE_INTENT.equals(intent.getAction()))
        {
            Intent alarmedIntent = intent.getParcelableExtra(ALARMED_INTENT);
            String alarmedAction = alarmedIntent.getAction();
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""BootReceiver Got alarm to fire alarmedIntent "" + alarmedAction);
            alarmedIntent.putExtra(WAKE_LOCK_ID, tmpWakeLockId);
            tmpWakeLockId = null;
            if (alarmedIntent != null)
            {
                context.startService(alarmedIntent);
            }
        }
        else if (SCHEDULE_INTENT.equals(intent.getAction()))
        {
            long atTime = intent.getLongExtra(AT_TIME, -1);
            Intent alarmedIntent = intent.getParcelableExtra(ALARMED_INTENT);
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG,""BootReceiver Scheduling intent "" + alarmedIntent + "" for "" + new Date(atTime));

            PendingIntent pi = buildPendingIntent(context, intent);
            AlarmManager alarmMgr = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);

            alarmMgr.set(AlarmManager.RTC_WAKEUP, atTime, pi);
        }
        else if (CANCEL_INTENT.equals(intent.getAction()))
        {
            Intent alarmedIntent = intent.getParcelableExtra(ALARMED_INTENT);
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""BootReceiver Canceling alarmedIntent "" + alarmedIntent);

            PendingIntent pi = buildPendingIntent(context, intent);

            AlarmManager alarmMgr = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
            alarmMgr.cancel(pi);
        }


        return tmpWakeLockId;
    }

    private PendingIntent buildPendingIntent(Context context, Intent intent)
    {
        Intent alarmedIntent = intent.getParcelableExtra(ALARMED_INTENT);
        String alarmedAction = alarmedIntent.getAction();

        Intent i = new Intent(context, BootReceiver.class);
        i.setAction(FIRE_INTENT);
        i.putExtra(ALARMED_INTENT, alarmedIntent);
        Uri uri = Uri.parse(""action://"" + alarmedAction);
        i.setData(uri);
        PendingIntent pi = PendingIntent.getBroadcast(context, 0, i, 0);
        return pi;
    }

    public static void scheduleIntent(Context context, long atTime, Intent alarmedIntent)
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""BootReceiver Got request to schedule alarmedIntent "" + alarmedIntent.getAction());
        Intent i = new Intent();
        i.setClass(context, BootReceiver.class);
        i.setAction(SCHEDULE_INTENT);
        i.putExtra(ALARMED_INTENT, alarmedIntent);
        i.putExtra(AT_TIME, atTime);
        context.sendBroadcast(i);
    }

    public static void cancelIntent(Context context, Intent alarmedIntent)
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""BootReceiver Got request to cancel alarmedIntent "" + alarmedIntent.getAction());
        Intent i = new Intent();
        i.setClass(context, BootReceiver.class);
        i.setAction(CANCEL_INTENT);
        i.putExtra(ALARMED_INTENT, alarmedIntent);
        context.sendBroadcast(i);
    }

}
",True,191,2,1,9,52,4,3,L1
59,com.fsck.k9.mail.CertificateValidationException.java,"
package com.fsck.k9.mail;

public class CertificateValidationException extends MessagingException
{
    public static final long serialVersionUID = -1;

    public CertificateValidationException(String message)
    {
        super(message);
    }

    public CertificateValidationException(String message, Throwable throwable)
    {
        super(message, throwable);
    }
}",False,74,8,20,1,1,5,1,L1
60,com.fsck.k9.mail.Folder.java,"package com.fsck.k9.mail;

import com.fsck.k9.Account;
import com.fsck.k9.Preferences;


public abstract class Folder
{
    protected final Account mAccount;

    private String status = null;
    private long lastChecked = 0;
    private long lastPush = 0;
    public enum OpenMode
    {
        READ_WRITE, READ_ONLY,
    }
    // NONE is obsolete, it will be translated to NO_CLASS for display and to INHERITED for sync and push
    public enum FolderClass
    {
        NONE, NO_CLASS, INHERITED, FIRST_CLASS, SECOND_CLASS;
    }

    public enum FolderType
    {
        HOLDS_FOLDERS, HOLDS_MESSAGES,
    }

    protected Folder(Account account)
    {
        mAccount = account;
    }

    /**
     * Forces an open of the MailProvider. If the provider is already open this
     * function returns without doing anything.
     *
     * @param mode READ_ONLY or READ_WRITE
     */
    public abstract void open(OpenMode mode) throws MessagingException;

    /**
     * Forces a close of the MailProvider. Any further access will attempt to
     * reopen the MailProvider.
     */
    public abstract void close();

    /**
     * @return True if further commands are not expected to have to open the
     *         connection.
     */
    public abstract boolean isOpen();

    /**
     * Get the mode the folder was opened with. This may be different than the mode the open
     * was requested with.
     * @return
     */
    public abstract OpenMode getMode() throws MessagingException;

    public abstract boolean create(FolderType type) throws MessagingException;

    /**
     * Create a new folder with a specified display limit.  Not abstract to allow
     * remote folders to not override or worry about this call if they don't care to.
     */
    public boolean create(FolderType type, int displayLimit) throws MessagingException
    {
        return create(type);
    }

    public abstract boolean exists() throws MessagingException;

    /**
     * @return A count of the messages in the selected folder.
     */
    public abstract int getMessageCount() throws MessagingException;

    public abstract int getUnreadMessageCount() throws MessagingException;

    public abstract Message getMessage(String uid) throws MessagingException;

    public abstract Message[] getMessages(int start, int end, MessageRetrievalListener listener)
    throws MessagingException;

    /**
     * Fetches the given list of messages. The specified listener is notified as
     * each fetch completes. Messages are downloaded as (as) lightweight (as
     * possible) objects to be filled in with later requests. In most cases this
     * means that only the UID is downloaded.
     *
     * @param uids
     * @param listener
     */
    public abstract Message[] getMessages(MessageRetrievalListener listener)
    throws MessagingException;

    public Message[] getMessages(MessageRetrievalListener listener, boolean includeDeleted) throws MessagingException
    {
        return getMessages(listener);
    }

    public abstract Message[] getMessages(String[] uids, MessageRetrievalListener listener)
    throws MessagingException;

    public abstract void appendMessages(Message[] messages) throws MessagingException;

    public void copyMessages(Message[] msgs, Folder folder) throws MessagingException {} ;

    public void moveMessages(Message[] msgs, Folder folder) throws MessagingException {} ;

    public void delete(Message[] msgs, String trashFolderName) throws MessagingException
    {
        for (Message message : msgs)
        {
            Message myMessage = getMessage(message.getUid());
            myMessage.delete(trashFolderName);
        }
    }

    public abstract void setFlags(Message[] messages, Flag[] flags, boolean value)
    throws MessagingException;

    public abstract void setFlags(Flag[] flags, boolean value) throws MessagingException;

    public abstract String getUidFromMessageId(Message message) throws MessagingException;

    public void expunge() throws MessagingException
        {}

    public abstract void fetch(Message[] messages, FetchProfile fp,
                               MessageRetrievalListener listener) throws MessagingException;

    public abstract void delete(boolean recurse) throws MessagingException;

    public abstract String getName();

    public abstract Flag[] getPermanentFlags() throws MessagingException;

    /**
     *
     * @param oldPushState
     * @param message
     * @return empty string to clear the pushState, null to leave the state as-is
     */
    public String getNewPushState(String oldPushState, Message message)
    {
        return null;
    }

    public boolean supportsFetchingFlags()
    {
        return true;
    }//isFlagSupported

    @Override
    public String toString()
    {
        return getName();
    }

    public long getLastChecked()
    {
        return lastChecked;
    }

    public void setLastChecked(long lastChecked) throws MessagingException
    {
        this.lastChecked = lastChecked;
    }

    public long getLastPush()
    {
        return lastPush;
    }

    public void setLastPush(long lastCheckedDisplay) throws MessagingException
    {
        this.lastPush = lastCheckedDisplay;
    }

    public long getLastUpdate()
    {
        return Math.max(getLastChecked(), getLastPush());
    }

    public FolderClass getDisplayClass()
    {
        return FolderClass.NO_CLASS;
    }

    public FolderClass getSyncClass()
    {
        return getDisplayClass();
    }
    public FolderClass getPushClass()
    {
        return getSyncClass();
    }

    public void refresh(Preferences preferences) throws MessagingException
    {

    }
    
    public boolean isInTopGroup()
    {
        return false;
    }

    public String getStatus()
    {
        return status;
    }

    public void setStatus(String status) throws MessagingException
    {
        this.status = status;
    }

    public Account getAccount()
    {
        return mAccount;
    }
}
",False,189,0,0,8,49,16,7,L1
61,com.fsck.k9.mail.MessageRetrievalListener.java,"
package com.fsck.k9.mail;

public interface MessageRetrievalListener
{
    public void messageStarted(String uid, int number, int ofTotal);

    public void messageFinished(Message message, int number, int ofTotal);

    public void messagesFinished(int total);
}
",False,189,0,0,10,52,6,1,L1
62,com.fsck.k9.mail.MessageRemovalListener.java,"package com.fsck.k9.mail;

public interface MessageRemovalListener
{
    public void messageRemoved(Message message);
}
",False,189,0,0,10,51,2,1,L1
63,com.fsck.k9.mail.MessageDateComparator.java,"
package com.fsck.k9.mail;

import java.util.Comparator;

public class MessageDateComparator implements Comparator<Message>
{
    public int compare(Message o1, Message o2)
    {
        try
        {
            if (o1.getSentDate() == null)
            {
                return 1;
            }
            else if (o2.getSentDate() == null)
            {
                return -1;
            }
            else
                return o2.getSentDate().compareTo(o1.getSentDate());
        }
        catch (Exception e)
        {
            return 0;
        }
    }
}
",True,190,0,0,10,52,0,1,L4
64,com.fsck.k9.mail.FetchProfile.java,"
package com.fsck.k9.mail;

import java.util.ArrayList;

/**
 * <pre>
 * A FetchProfile is a list of items that should be downloaded in bulk for a set of messages.
 * FetchProfile can contain the following objects:
 *      FetchProfile.Item:      Described below.
 *      Message:                Indicates that the body of the entire message should be fetched.
 *                              Synonymous with FetchProfile.Item.BODY.
 *      Part:                   Indicates that the given Part should be fetched. The provider
 *                              is expected have previously created the given BodyPart and stored
 *                              any information it needs to download the content.
 * </pre>
 */
public class FetchProfile extends ArrayList
{
    /**
     * Default items available for pre-fetching. It should be expected that any
     * item fetched by using these items could potentially include all of the
     * previous items.
     */
    public enum Item
    {
        /**
         * Download the flags of the message.
         */
        FLAGS,

        /**
         * Download the envelope of the message. This should include at minimum
         * the size and the following headers: date, subject, from, content-type, to, cc
         */
        ENVELOPE,

        /**
         * Download the structure of the message. This maps directly to IMAP's BODYSTRUCTURE
         * and may map to other providers.
         * The provider should, if possible, fill in a properly formatted MIME structure in
         * the message without actually downloading any message data. If the provider is not
         * capable of this operation it should specifically set the body of the message to null
         * so that upper levels can detect that a full body download is needed.
         */
        STRUCTURE,

        /**
         * A sane portion of the entire message, cut off at a provider determined limit.
         * This should generaly be around 50kB.
         */
        BODY_SANE,

        /**
         * The entire message.
         */
        BODY,
    }
}
",False,73,6,39,0,0,6,0,L1
65,com.fsck.k9.mail.PushReceiver.java,"package com.fsck.k9.mail;

import java.util.List;

public interface PushReceiver
{
    public void acquireWakeLock();
    public void releaseWakeLock();
    public void messagesArrived(Folder folder, List<Message> mess);
    public void messagesFlagsChanged(Folder folder, List<Message> mess);
    public String getPushState(String folderName);
    public void pushError(String errorMessage, Exception e);
    public void setPushActive(String folderName, boolean enabled);
    public void sleep(long millis);
}
",False,189,0,0,9,57,4,2,L1
66,com.fsck.k9.mail.Part.java,"
package com.fsck.k9.mail;

import java.io.IOException;
import java.io.OutputStream;

public interface Part
{
    public void addHeader(String name, String value) throws MessagingException;

    public void removeHeader(String name) throws MessagingException;

    public void setHeader(String name, String value) throws MessagingException;

    public Body getBody() throws MessagingException;

    public String getContentType() throws MessagingException;

    public String getDisposition() throws MessagingException;

    public String[] getHeader(String name) throws MessagingException;

    public int getSize() throws MessagingException;

    public boolean isMimeType(String mimeType) throws MessagingException;

    public String getMimeType() throws MessagingException;

    public void setBody(Body body) throws MessagingException;

    public void writeTo(OutputStream out) throws IOException, MessagingException;
}
",False,75,4,30,1,2,14,2,L1
67,com.fsck.k9.mail.Flag.java,"
package com.fsck.k9.mail;

/**
 * Flags that can be applied to Messages.
 */
public enum Flag
{
    DELETED,
    SEEN,
    ANSWERED,
    FLAGGED,
    DRAFT,
    RECENT,

    /*
     * The following flags are for internal library use only.
     * TODO Eventually we should creates a Flags class that extends ArrayList that allows
     * these flags and Strings to represent user defined flags. At that point the below
     * flags should become user defined flags.
     */
    /*
     * For POP3 to indicate that the message does not have SEEN info
     */
    X_NO_SEEN_INFO,
    /**
     * Delete and remove from the LocalStore immediately.
     */
    X_DESTROYED,

    /**
     * Sending of an unsent message failed. It will be retried. Used to show status.
     */
    X_SEND_FAILED,

    /**
     * Sending of an unsent message is in progress.
     */
    X_SEND_IN_PROGRESS,

    /**
     * Indicates that a message is fully downloaded from the server and can be viewed normally.
     * This does not include attachments, which are never downloaded fully.
     */
    X_DOWNLOADED_FULL,

    /**
     * Indicates that a message is partially downloaded from the server and can be viewed but
     * more content is available on the server.
     * This does not include attachments, which are never downloaded fully.
     */
    X_DOWNLOADED_PARTIAL,

    /**
     * Indicates that the copy of a message to the Sent folder has started.
     */
    X_REMOTE_COPY_STARTED,
}
",False,73,5,34,0,0,10,0,L1
68,com.fsck.k9.mail.Pusher.java,"package com.fsck.k9.mail;

import java.util.List;


public interface Pusher
{
    public void start(List<String> folderNames);
    public void refresh();
    public void stop();
    /**
     *
     * @return milliseconds of required refresh interval
     */
    public int getRefreshInterval();
}
",False,73,6,32,0,0,4,0,L1
69,com.fsck.k9.mail.AuthenticationFailedException.java,"
package com.fsck.k9.mail;

public class AuthenticationFailedException extends MessagingException
{
    public static final long serialVersionUID = -1;

    public AuthenticationFailedException(String message)
    {
        super(message);
    }

    public AuthenticationFailedException(String message, Throwable throwable)
    {
        super(message, throwable);
    }
}
",False,74,8,20,1,1,4,1,L1
70,com.fsck.k9.mail.Message.java,"
package com.fsck.k9.mail;

import java.util.Date;
import java.util.HashSet;

public abstract class Message implements Part, Body
{
    public enum RecipientType
    {
        TO, CC, BCC,
    }

    protected String mUid;

    protected HashSet<Flag> mFlags = new HashSet<Flag>();

    protected Date mInternalDate;

    protected Folder mFolder;

    public String getUid()
    {
        return mUid;
    }

    public void setUid(String uid)
    {
        this.mUid = uid;
    }

    public Folder getFolder()
    {
        return mFolder;
    }

    public abstract String getSubject() throws MessagingException;

    public abstract void setSubject(String subject) throws MessagingException;

    public Date getInternalDate()
    {
        return mInternalDate;
    }

    public void setInternalDate(Date internalDate)
    {
        this.mInternalDate = internalDate;
    }

    public abstract Date getReceivedDate() throws MessagingException;

    public abstract Date getSentDate() throws MessagingException;

    public abstract void setSentDate(Date sentDate) throws MessagingException;

    public abstract Address[] getRecipients(RecipientType type) throws MessagingException;

    public abstract void setRecipients(RecipientType type, Address[] addresses)
    throws MessagingException;

    public void setRecipient(RecipientType type, Address address) throws MessagingException
    {
        setRecipients(type, new Address[]
                      {
                          address
                      });
    }

    public abstract Address[] getFrom() throws MessagingException;

    public abstract void setFrom(Address from) throws MessagingException;

    public abstract Address[] getReplyTo() throws MessagingException;

    public abstract void setReplyTo(Address[] from) throws MessagingException;

    public abstract String getMessageId() throws MessagingException;

    public abstract void setInReplyTo(String inReplyTo) throws MessagingException;

    public abstract String[] getReferences() throws MessagingException;

    public abstract void setReferences(String references) throws MessagingException;

    public abstract Body getBody() throws MessagingException;

    public abstract String getContentType() throws MessagingException;

    public abstract void addHeader(String name, String value) throws MessagingException;

    public abstract void setHeader(String name, String value) throws MessagingException;

    public abstract String[] getHeader(String name) throws MessagingException;

    public abstract void removeHeader(String name) throws MessagingException;

    public abstract void setBody(Body body) throws MessagingException;

    public boolean isMimeType(String mimeType) throws MessagingException
    {
        return getContentType().startsWith(mimeType);
    }

    public void delete(String trashFolderName) throws MessagingException {} ;

    /*
     * TODO Refactor Flags at some point to be able to store user defined flags.
     */
    public Flag[] getFlags()
    {
        return mFlags.toArray(new Flag[] {});
    }

    public void setFlag(Flag flag, boolean set) throws MessagingException
    {
        if (set)
        {
            mFlags.add(flag);
        }
        else
        {
            mFlags.remove(flag);
        }
    }

    /**
     * This method calls setFlag(Flag, boolean)
     * @param flags
     * @param set
     */
    public void setFlags(Flag[] flags, boolean set) throws MessagingException
    {
        for (Flag flag : flags)
        {
            setFlag(flag, set);
        }
    }

    public boolean isSet(Flag flag)
    {
        return mFlags.contains(flag);
    }

    public abstract void saveChanges() throws MessagingException;

    public abstract void setEncoding(String encoding);
}
",False,190,1,1,9,52,23,6,L1
71,com.fsck.k9.mail.Body.java,"
package com.fsck.k9.mail;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public interface Body
{
    public InputStream getInputStream() throws MessagingException;
    public void writeTo(OutputStream out) throws IOException, MessagingException;
}
",False,77,4,35,1,1,11,1,L1
72,com.fsck.k9.mail.Transport.java,"
package com.fsck.k9.mail;

import com.fsck.k9.Account;
import com.fsck.k9.mail.transport.SmtpTransport;
import com.fsck.k9.mail.transport.WebDavTransport;

public abstract class Transport
{
    protected static final int SOCKET_CONNECT_TIMEOUT = 10000;

    // RFC 1047
    protected static final int SOCKET_READ_TIMEOUT = 300000;

    public synchronized static Transport getInstance(Account account) throws MessagingException
    {
        String uri = account.getTransportUri();
        if (uri.startsWith(""smtp""))
        {
            return new SmtpTransport(uri);
        }
        else if (uri.startsWith(""webdav""))
        {
            return new WebDavTransport(account);
        }
        else
        {
            throw new MessagingException(""Unable to locate an applicable Transport for "" + uri);
        }
    }

    public abstract void open() throws MessagingException;

    public abstract void sendMessage(Message message) throws MessagingException;

    public abstract void close() throws MessagingException;
}
",False,189,0,0,8,46,4,5,L1
73,com.fsck.k9.mail.BodyPart.java,"
package com.fsck.k9.mail;

public abstract class BodyPart implements Part
{
    protected Multipart mParent;

    public Multipart getParent()
    {
        return mParent;
    }
}
",False,189,0,0,12,50,5,2,L1
74,com.fsck.k9.mail.Store.java,"
package com.fsck.k9.mail;

import android.app.Application;

import com.fsck.k9.Account;
import com.fsck.k9.mail.store.ImapStore;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.Pop3Store;
import com.fsck.k9.mail.store.WebDavStore;

import java.util.HashMap;

/**
 * Store is the access point for an email message store. It's location can be
 * local or remote and no specific protocol is defined. Store is intended to
 * loosely model in combination the JavaMail classes javax.mail.Store and
 * javax.mail.Folder along with some additional functionality to improve
 * performance on mobile devices. Implementations of this class should focus on
 * making as few network connections as possible.
 */
public abstract class Store
{
    /**
     * A global suggestion to Store implementors on how much of the body
     * should be returned on FetchProfile.Item.BODY_SANE requests.
     */
    //Matching MessagingController.MAX_SMALL_MESSAGE_SIZE
    public static final int FETCH_BODY_SANE_SUGGESTED_SIZE = (50 * 1024);

    protected static final int SOCKET_CONNECT_TIMEOUT = 10000;
    protected static final int SOCKET_READ_TIMEOUT = 60000;

    private static HashMap<String, Store> mStores = new HashMap<String, Store>();

    protected final Account mAccount;

    protected Store(Account account)
    {
        mAccount = account;
    }

    /**
     * Get an instance of a remote mail store.
     */
    public synchronized static Store getRemoteInstance(Account account) throws MessagingException
    {
        String uri = account.getStoreUri();

        if (uri.startsWith(""local""))
        {
            throw new RuntimeException(""Asked to get non-local Store object but given LocalStore URI"");
        }

        Store store = mStores.get(uri);
        if (store == null)
        {
            if (uri.startsWith(""imap""))
            {
                store = new ImapStore(account);
            }
            else if (uri.startsWith(""pop3""))
            {
                store = new Pop3Store(account);
            }
            else if (uri.startsWith(""webdav""))
            {
                store = new WebDavStore(account);
            }

            if (store != null)
            {
                mStores.put(uri, store);
            }
        }

        if (store == null)
        {
            throw new MessagingException(""Unable to locate an applicable Store for "" + uri);
        }

        return store;
    }

    /**
     * Get an instance of a local mail store.
     */
    public synchronized static LocalStore getLocalInstance(Account account, Application application) throws MessagingException
    {
        String uri = account.getLocalStoreUri();

        if (!uri.startsWith(""local""))
        {
            throw new RuntimeException(""LocalStore URI doesn't start with 'local'"");
        }

        Store store = mStores.get(uri);
        if (store == null)
        {
            store = new LocalStore(account, application);

            if (store != null)
            {
                mStores.put(uri, store);
            }
        }

        if (store == null)
        {
            throw new MessagingException(""Unable to locate an applicable Store for "" + uri);
        }

        return (LocalStore)store;
    }

    public abstract Folder getFolder(String name) throws MessagingException;

    public abstract Folder[] getPersonalNamespaces() throws MessagingException;

    public abstract void checkSettings() throws MessagingException;

    public boolean isCopyCapable()
    {
        return false;
    }
    public boolean isMoveCapable()
    {
        return false;
    }
    public boolean isPushCapable()
    {
        return false;
    }
    public boolean isSendCapable()
    {
        return false;
    }
    public boolean isExpungeCapable()
    {
        return false;
    }


    public void sendMessages(Message[] messages) throws MessagingException
    {
    }

    public Pusher getPusher(PushReceiver receiver)
    {
        return null;
    }

    public Account getAccount()
    {
        return mAccount;
    }
}
",False,189,0,0,7,49,11,10,L1
75,com.fsck.k9.mail.Address.java,"
package com.fsck.k9.mail;

import android.text.util.Rfc822Token;
import android.text.util.Rfc822Tokenizer;
import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.Utility;
import org.apache.james.mime4j.codec.EncoderUtil;
import org.apache.james.mime4j.field.address.AddressList;
import org.apache.james.mime4j.field.address.Mailbox;
import org.apache.james.mime4j.field.address.MailboxList;
import org.apache.james.mime4j.field.address.NamedMailbox;
import org.apache.james.mime4j.field.address.parser.ParseException;

import java.util.ArrayList;
import java.util.List;

public class Address
{
    String mAddress;

    String mPersonal;

    public Address(String address, String personal)
    {
        this.mAddress = address;
        if ("""".equals(personal))
        {
            personal = null;
        }
        if (personal!=null)
        {
            personal = personal.trim();
        }
        this.mPersonal = personal;
    }

    public Address(String address)
    {
        this.mAddress = address;
    }

    public String getAddress()
    {
        return mAddress;
    }

    public void setAddress(String address)
    {
        this.mAddress = address;
    }

    public String getPersonal()
    {
        return mPersonal;
    }

    public void setPersonal(String personal)
    {
        if ("""".equals(personal))
        {
            personal = null;
        }
        if (personal!=null)
        {
            personal = personal.trim();
        }
        this.mPersonal = personal;
    }

    /**
     * Parse a comma separated list of email addresses in human readable format and return an
     * array of Address objects, RFC-822 encoded.
     *
     * @param addressList
     * @return An array of 0 or more Addresses.
     */
    public static Address[] parseUnencoded(String addressList)
    {
        List<Address> addresses = new ArrayList<Address>();
        if (addressList!=null
                && !"""".equals(addressList))
        {
            Rfc822Token[] tokens =  Rfc822Tokenizer.tokenize(addressList);
            for (Rfc822Token token : tokens)
            {
                String address = token.getAddress();
                if (address!=null
                        && !"""".equals(address))
                {
                    addresses.add(new Address(token.getAddress(), token.getName()));
                }
            }
        }
        return addresses.toArray(new Address[0]);
    }

    /**
     * Parse a comma separated list of addresses in RFC-822 format and return an
     * array of Address objects.
     *
     * @param addressList
     * @return An array of 0 or more Addresses.
     */
    public static Address[] parse(String addressList)
    {
        ArrayList<Address> addresses = new ArrayList<Address>();
        if (addressList == null
                && !"""".equals(addressList))
        {
            return new Address[] {};
        }
        try
        {
            MailboxList parsedList = AddressList.parse(addressList).flatten();
            for (int i = 0, count = parsedList.size(); i < count; i++)
            {
                org.apache.james.mime4j.field.address.Address address = parsedList.get(i);
                if (address instanceof NamedMailbox)
                {
                    NamedMailbox namedMailbox = (NamedMailbox)address;
                    addresses.add(new Address(namedMailbox.getLocalPart() + ""@""
                                              + namedMailbox.getDomain(), namedMailbox.getName()));
                }
                else if (address instanceof Mailbox)
                {
                    Mailbox mailbox = (Mailbox)address;
                    addresses.add(new Address(mailbox.getLocalPart() + ""@"" + mailbox.getDomain()));
                }
                else
                {
                    Log.e(K9.LOG_TAG, ""Unknown address type from Mime4J: ""
                          + address.getClass().toString());
                }

            }
        }
        catch (ParseException pe)
        {
        }
        return addresses.toArray(new Address[] {});
    }

    @Override
    public boolean equals(Object o)
    {
        if (o instanceof Address)
        {
            return getAddress().equals(((Address) o).getAddress());
        }
        return super.equals(o);
    }

    @Override
    public String toString()
    {
        if (mPersonal != null)
        {
            return Utility.quoteString(mPersonal) + "" <"" + mAddress + "">"";
        }
        else
        {
            return mAddress;
        }
    }

    public static String toString(Address[] addresses)
    {
        if (addresses == null)
        {
            return null;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < addresses.length; i++)
        {
            sb.append(addresses[i].toString());
            if (i < addresses.length - 1)
            {
                sb.append(',');
            }
        }
        return sb.toString();
    }

    public String toEncodedString()
    {
        if (mPersonal != null)
        {
            return EncoderUtil.encodeAddressDisplayName(mPersonal) + "" <"" + mAddress + "">"";
        }
        else
        {
            return mAddress;
        }
    }

    public static String toEncodedString(Address[] addresses)
    {
        if (addresses == null)
        {
            return null;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < addresses.length; i++)
        {
            sb.append(addresses[i].toEncodedString());
            if (i < addresses.length - 1)
            {
                sb.append(',');
            }
        }
        return sb.toString();
    }

    /**
     * Returns either the personal portion of the Address or the address portion if the personal
     * is not available.
     * @return
     */
    public String toFriendly()
    {
        if (mPersonal != null && mPersonal.length() > 0)
        {
            return  mPersonal;
        }
        else
        {
            return mAddress;
        }
    }

    public static String toFriendly(Address[] addresses)
    {
        if (addresses == null)
        {
            return null;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < addresses.length; i++)
        {
            sb.append(addresses[i].toFriendly());
            if (i < addresses.length - 1)
            {
                sb.append(',');
            }
        }
        return sb.toString();
    }

    /**
     * Unpacks an address list previously packed with packAddressList()
     * @param list
     * @return
     */
    public static Address[] unpack(String addressList)
    {
        if (addressList == null)
        {
            return new Address[] { };
        }
        ArrayList<Address> addresses = new ArrayList<Address>();
        int length = addressList.length();
        int pairStartIndex = 0;
        int pairEndIndex = 0;
        int addressEndIndex = 0;
        while (pairStartIndex < length)
        {
            pairEndIndex = addressList.indexOf("",\u0000"", pairStartIndex);
            if (pairEndIndex == -1)
            {
                pairEndIndex = length;
            }
            addressEndIndex = addressList.indexOf("";\u0000"", pairStartIndex);
            String address = null;
            String personal = null;
            if (addressEndIndex == -1 || addressEndIndex > pairEndIndex)
            {
                address = addressList.substring(pairStartIndex, pairEndIndex);
            }
            else
            {
                address = addressList.substring(pairStartIndex, addressEndIndex);
                personal =addressList.substring(addressEndIndex + 2, pairEndIndex);
            }
            addresses.add(new Address(address, personal));
            pairStartIndex = pairEndIndex + 2;
        }
        return addresses.toArray(new Address[] { });
    }

    /**
     * Packs an address list into a String that is very quick to read
     * and parse. Packed lists can be unpacked with unpackAddressList()
     * The packed list is a ""\u0000,"" seperated list of:
     * address\u0000;personal
     * @param list
     * @return
     */
    public static String pack(Address[] addresses)
    {
        if (addresses == null)
        {
            return null;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0, count = addresses.length; i < count; i++)
        {
            Address address = addresses[i];
            sb.append(address.getAddress());
            String personal = address.getPersonal();
            if (personal != null)
            {
                sb.append("";\u0000"");
                // Escape quotes in the address part on the way in
                personal.replaceAll(""\"""",""\\\"""");
                sb.append(personal);
            }
            if (i < count - 1)
            {
                sb.append("",\u0000"");
            }
        }
        return sb.toString();
    }
}
",True,191,1,2,9,57,12,9,L1
76,com.fsck.k9.mail.MessagingException.java,"
package com.fsck.k9.mail;

public class MessagingException extends Exception
{
    public static final long serialVersionUID = -1;

    boolean permanentFailure = false;

    public MessagingException(String message)
    {
        super(message);
    }

    public MessagingException(String message, boolean perm)
    {
        super(message);
        permanentFailure = perm;
    }

    public MessagingException(String message, Throwable throwable)
    {
        super(message, throwable);
    }

    public MessagingException(String message, boolean perm, Throwable throwable)
    {
        super(message, throwable);
        permanentFailure = perm;
    }

    public boolean isPermanentFailure()
    {
        return permanentFailure;
    }

    public void setPermanentFailure(boolean permanentFailure)
    {
        this.permanentFailure = permanentFailure;
    }


}
",True,80,3,42,0,0,33,0,L0
77,com.fsck.k9.mail.Multipart.java,"
package com.fsck.k9.mail;

import java.util.ArrayList;

import com.fsck.k9.mail.internet.MimeHeader;
import com.fsck.k9.mail.internet.TextBody;

public abstract class Multipart implements Body
{
    protected Part mParent;

    protected ArrayList<BodyPart> mParts = new ArrayList<BodyPart>();

    protected String mContentType;

    public void addBodyPart(BodyPart part) throws MessagingException
    {
        mParts.add(part);
    }

    public void addBodyPart(BodyPart part, int index) throws MessagingException
    {
        mParts.add(index, part);
    }

    public BodyPart getBodyPart(int index) throws MessagingException
    {
        return mParts.get(index);
    }

    public String getContentType() throws MessagingException
    {
        return mContentType;
    }

    public int getCount() throws MessagingException
    {
        return mParts.size();
    }

    public boolean removeBodyPart(BodyPart part) throws MessagingException
    {
        return mParts.remove(part);
    }

    public void removeBodyPart(int index) throws MessagingException
    {
        mParts.remove(index);
    }

    public Part getParent() throws MessagingException
    {
        return mParent;
    }

    public void setParent(Part parent) throws MessagingException
    {
        this.mParent = parent;
    }

	public void setEncoding(String encoding)
	{
		for (BodyPart part : mParts)
		{
			try
			{
				Body body = part.getBody();
				if (body instanceof TextBody)
				{
					part.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, encoding);
					((TextBody)body).setEncoding(encoding);
				}
			}
			catch (MessagingException e)
			{
				// Ignore
			}
		}
		
	}
}
",True,189,0,0,11,50,9,6,L1
78,com.fsck.k9.mail.NoSuchProviderException.java,"
package com.fsck.k9.mail;

public class NoSuchProviderException extends MessagingException
{
    public static final long serialVersionUID = -1;

    public NoSuchProviderException(String message)
    {
        super(message);
    }

    public NoSuchProviderException(String message, Throwable throwable)
    {
        super(message, throwable);
    }
}
",False,2,0,0,1,1,0,1,L4
79,com.fsck.k9.mail.transport.EOLConvertingOutputStream.java,"package com.fsck.k9.mail.transport;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class EOLConvertingOutputStream extends FilterOutputStream
{
    private int lastChar;
    private boolean ignoreNextIfLF = false;

    public EOLConvertingOutputStream(OutputStream out)
    {
        super(out);
    }

    @Override
    public void write(int oneByte) throws IOException
    {
        if (!ignoreNextIfLF)
        {
            if ((oneByte == '\n') && (lastChar != '\r'))
            {
                super.write('\r');
            }
            super.write(oneByte);
            lastChar = oneByte;
        }
        ignoreNextIfLF = false;
    }

    @Override
    public void flush() throws IOException
    {
        if (lastChar == '\r')
        {
            super.write('\n');
            lastChar = '\n';
            
            // We have to ignore the next character if it is <LF>. Otherwise it
            // will be expanded to an additional <CR><LF> sequence although it
            // belongs to the one just completed.
            ignoreNextIfLF = true;
        }
        super.flush();
    }
}
",True,73,8,25,0,0,3,0,L1
80,com.fsck.k9.mail.transport.StatusOutputStream.java,"package com.fsck.k9.mail.transport;

import android.util.Config;
import android.util.Log;
import com.fsck.k9.K9;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class StatusOutputStream extends FilterOutputStream
{
    private long mCount = 0;

    public StatusOutputStream(OutputStream out)
    {
        super(out);
    }

    @Override
    public void write(int oneByte) throws IOException
    {
        super.write(oneByte);
        mCount++;
        if (Config.LOGV)
        {
            if (mCount % 1024 == 0)
            {
                Log.v(K9.LOG_TAG, ""# "" + mCount);
            }
        }
    }
}
",True,190,0,0,9,52,0,1,L4
81,com.fsck.k9.mail.transport.CountingOutputStream.java,"package com.fsck.k9.mail.transport;

import java.io.IOException;
import java.io.OutputStream;

/**
 * A simple OutputStream that does nothing but count how many bytes are written to it and
 * makes that count available to callers.
 */
public class CountingOutputStream extends OutputStream
{
    private long mCount;

    public CountingOutputStream()
    {
    }

    public long getCount()
    {
        return mCount;
    }

    @Override
    public void write(int oneByte) throws IOException
    {
        mCount++;
    }
}
",False,73,8,27,0,0,1,0,L1
82,com.fsck.k9.mail.transport.LineWrapOutputStream.java,"package com.fsck.k9.mail.transport;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class LineWrapOutputStream extends FilterOutputStream
{
    private static final byte[] CRLF = new byte[] {'\r', '\n'};

    private byte[] buffer;
    private int bufferStart = 0;
    private int lineLength = 0;
    private int endOfLastWord = 0;


    public LineWrapOutputStream(OutputStream out, int maxLineLength)
    {
        super(out);
        buffer = new byte[maxLineLength - 2];
    }

    @Override
    public void write(int oneByte) throws IOException
    {
        // Buffer full?
        if (lineLength == buffer.length)
        {
            // Usable word-boundary found earlier? 
            if (endOfLastWord > 0)
            {
                // Yes, so output everything up to that word-boundary 
                out.write(buffer, bufferStart, endOfLastWord - bufferStart);
                out.write(CRLF);

                bufferStart = 0;

                // Skip the <SPACE> in the buffer
                endOfLastWord++;
                lineLength = buffer.length - endOfLastWord;
                if (lineLength > 0)
                {
                    // Copy rest of the buffer to the front
                    for (int i = 0; i < lineLength; i++)
                    {
                        buffer[i] = buffer[endOfLastWord + i];
                    }
                }
                endOfLastWord = 0;
            }
            else
            {
                // No word-boundary found, so output whole buffer
                out.write(buffer, bufferStart, buffer.length - bufferStart);
                out.write(CRLF);
                lineLength = 0;
                bufferStart = 0;
            }
        }

        if ((oneByte == '\n') || (oneByte == '\r'))
        {
            // <CR> or <LF> character found, so output buffer ...
            if (lineLength - bufferStart > 0)
            {
                out.write(buffer, bufferStart, lineLength - bufferStart);
            }
            // ... and that character
            out.write(oneByte);
            lineLength = 0;
            bufferStart = 0;
            endOfLastWord = 0;
        }
        else
        {
            // Remember this position as last word-boundary if <SPACE> found
            if (oneByte == ' ')
            {
                endOfLastWord = lineLength;
            }

            // Write character to the buffer
            buffer[lineLength] = (byte)oneByte;
            lineLength++;
        }
    }

    @Override
    public void flush() throws IOException
    {
        // Buffer empty?
        if (lineLength > bufferStart)
        {
            // Output everything we have up till now
            out.write(buffer, bufferStart, lineLength - bufferStart);

            // Mark current position as new start of the buffer
            bufferStart = (lineLength == buffer.length) ? 0 : lineLength;
            endOfLastWord = 0;
        }
        out.flush();
    }
}
",True,73,8,31,0,0,1,0,L1
83,com.fsck.k9.mail.transport.WebDavTransport.java,"
package com.fsck.k9.mail.transport;

import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.PeekableInputStream;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Transport;
import com.fsck.k9.mail.store.WebDavStore;

import java.io.OutputStream;
import java.net.Socket;

public class WebDavTransport extends Transport
{
    public static final int CONNECTION_SECURITY_NONE = 0;
    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

    String host;
    int mPort;
    private int mConnectionSecurity;
    private String mUsername; /* Stores the username for authentications */
    private String mPassword; /* Stores the password for authentications */
    private String mUrl;      /* Stores the base URL for the server */

    boolean mSecure;
    Socket mSocket;
    PeekableInputStream mIn;
    OutputStream mOut;
    private WebDavStore store;

    /**
     * webdav://user:password@server:port CONNECTION_SECURITY_NONE
     * webdav+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * webdav+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * webdav+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * webdav+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     *
     * @param _uri
     */
    public WebDavTransport(Account account) throws MessagingException
    {
        store = new WebDavStore(account);
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, "">>> New WebDavTransport creation complete"");
    }

    public void open() throws MessagingException
    {
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, "">>> open called on WebDavTransport "");

        store.getHttpClient();
    }

    public void close()
    {
    }

    public void sendMessage(Message message) throws MessagingException
    {

        store.sendMessages(new Message[] { message });


    }

}
",True,189,0,0,8,47,1,7,L1
84,com.fsck.k9.mail.transport.SmtpDataStuffing.java,"package com.fsck.k9.mail.transport;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class SmtpDataStuffing extends FilterOutputStream
{
    private static final int STATE_NORMAL = 0;
    private static final int STATE_CR = 1;
    private static final int STATE_CRLF = 2;
    
    private int state = STATE_NORMAL;

    public SmtpDataStuffing(OutputStream out)
    {
        super(out);
    }

    @Override
    public void write(int oneByte) throws IOException
    {
        if (oneByte == '\r')
        {
            state = STATE_CR;
        }
        else if ((state == STATE_CR) && (oneByte == '\n'))
        {
            state = STATE_CRLF;
        }
        else if ((state == STATE_CRLF) && (oneByte == '.'))
        {
            // Read <CR><LF><DOT> so this line needs an additional period.
            super.write('.');
            state = STATE_NORMAL;
        }
        else
        {
            state = STATE_NORMAL;
        }
        super.write(oneByte);
    }
}
",False,73,8,31,0,0,1,0,L1
85,com.fsck.k9.mail.transport.TrustedSocketFactory.java,"package com.fsck.k9.mail.transport;

import com.fsck.k9.mail.store.TrustManagerFactory;
import org.apache.http.conn.ConnectTimeoutException;
import org.apache.http.conn.scheme.LayeredSocketFactory;
import org.apache.http.params.HttpParams;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

public class TrustedSocketFactory implements LayeredSocketFactory
{
    private SSLSocketFactory mSocketFactory;
    private org.apache.http.conn.ssl.SSLSocketFactory mSchemeSocketFactory;

    public TrustedSocketFactory(String host, boolean secure) throws NoSuchAlgorithmException, KeyManagementException
    {
        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, new TrustManager[]
                        {
                            TrustManagerFactory.get(host, secure)
                        }, new SecureRandom());
        mSocketFactory = sslContext.getSocketFactory();
        mSchemeSocketFactory = org.apache.http.conn.ssl.SSLSocketFactory.getSocketFactory();
        mSchemeSocketFactory.setHostnameVerifier(
            org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
    }

    public Socket connectSocket(Socket sock, String host, int port,
                                InetAddress localAddress, int localPort, HttpParams params)
    throws IOException, UnknownHostException, ConnectTimeoutException
    {
        return mSchemeSocketFactory.connectSocket(sock, host, port, localAddress, localPort, params);
    }

    public Socket createSocket() throws IOException
    {
        return mSocketFactory.createSocket();
    }

    public boolean isSecure(Socket sock) throws IllegalArgumentException
    {
        return mSchemeSocketFactory.isSecure(sock);
    }
    public Socket createSocket(
        final Socket socket,
        final String host,
        final int port,
        final boolean autoClose
    ) throws IOException, UnknownHostException
    {
        SSLSocket sslSocket = (SSLSocket) mSocketFactory.createSocket(
                                  socket,
                                  host,
                                  port,
                                  autoClose
                              );
        //hostnameVerifier.verify(host, sslSocket);
        // verifyHostName() didn't blowup - good!
        return sslSocket;
    }
}
",False,189,0,0,10,50,1,1,L1
86,com.fsck.k9.mail.transport.SmtpTransport.java,"
package com.fsck.k9.mail.transport;

import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.PeekableInputStream;
import com.fsck.k9.codec.binary.Base64;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.store.TrustManagerFactory;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.TrustManager;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.*;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import org.apache.commons.codec.binary.Hex;
import java.util.ArrayList;
import java.util.List;

public class SmtpTransport extends Transport
{
    public static final int CONNECTION_SECURITY_NONE = 0;

    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;

    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;

    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;

    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

    String mHost;

    int mPort;

    String mUsername;

    String mPassword;

    String mAuthType;

    int mConnectionSecurity;

    boolean mSecure;

    Socket mSocket;

    PeekableInputStream mIn;

    OutputStream mOut;
    private boolean m8bitEncodingAllowed;

    /**
     * smtp://user:password@server:port CONNECTION_SECURITY_NONE
     * smtp+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * smtp+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * smtp+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * smtp+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     *
     * @param _uri
     */
    public SmtpTransport(String _uri) throws MessagingException
    {
        URI uri;
        try
        {
            uri = new URI(_uri);
        }
        catch (URISyntaxException use)
        {
            throw new MessagingException(""Invalid SmtpTransport URI"", use);
        }

        String scheme = uri.getScheme();
        if (scheme.equals(""smtp""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_NONE;
            mPort = 25;
        }
        else if (scheme.equals(""smtp+tls""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
            mPort = 25;
        }
        else if (scheme.equals(""smtp+tls+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
            mPort = 25;
        }
        else if (scheme.equals(""smtp+ssl+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
            mPort = 465;
        }
        else if (scheme.equals(""smtp+ssl""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
            mPort = 465;
        }
        else
        {
            throw new MessagingException(""Unsupported protocol"");
        }

        mHost = uri.getHost();

        if (uri.getPort() != -1)
        {
            mPort = uri.getPort();
        }

        if (uri.getUserInfo() != null)
        {
            try
            {
                String[] userInfoParts = uri.getUserInfo().split("":"");
                mUsername = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                if (userInfoParts.length > 1)
                {
                    mPassword = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
                if (userInfoParts.length > 2)
                {
                    mAuthType = userInfoParts[2];
                }
            }
            catch (UnsupportedEncodingException enc)
            {
                // This shouldn't happen since the encoding is hardcoded to UTF-8
                Log.e(K9.LOG_TAG, ""Couldn't urldecode username or password."", enc);
            }
        }
    }

    public void open() throws MessagingException
    {
        try
        {
            SocketAddress socketAddress = new InetSocketAddress(mHost, mPort);
            if (mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
                    mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL)
            {
                SSLContext sslContext = SSLContext.getInstance(""TLS"");
                boolean secure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
                sslContext.init(null, new TrustManager[]
                                {
                                    TrustManagerFactory.get(mHost, secure)
                                }, new SecureRandom());
                mSocket = sslContext.getSocketFactory().createSocket();
                mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                mSecure = true;
            }
            else
            {
                mSocket = new Socket();
                mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
            }

            // RFC 1047
            mSocket.setSoTimeout(SOCKET_READ_TIMEOUT);

            mIn = new PeekableInputStream(new BufferedInputStream(mSocket.getInputStream(), 1024));
            mOut = mSocket.getOutputStream();

            // Eat the banner
            executeSimpleCommand(null);

            InetAddress localAddress = mSocket.getLocalAddress();
            String localHost = localAddress.getHostName();

            if (localHost.equals(localAddress.getHostAddress()))
            {
                // IP was returned
                localHost = ""["" + localHost + ""]"";
            }

            List<String> results = executeSimpleCommand(""EHLO "" + localHost);

            m8bitEncodingAllowed = results.contains(""8BITMIME"");

            /*
             * TODO may need to add code to fall back to HELO I switched it from
             * using HELO on non STARTTLS connections because of AOL's mail
             * server. It won't let you use AUTH without EHLO.
             * We should really be paying more attention to the capabilities
             * and only attempting auth if it's available, and warning the user
             * if not.
             */
            if (mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL
                    || mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED)
            {
                if (results.contains(""STARTTLS""))
                {
                    executeSimpleCommand(""STARTTLS"");

                    SSLContext sslContext = SSLContext.getInstance(""TLS"");
                    boolean secure = mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED;
                    sslContext.init(null, new TrustManager[]
                                    {
                                        TrustManagerFactory.get(mHost, secure)
                                    }, new SecureRandom());
                    mSocket = sslContext.getSocketFactory().createSocket(mSocket, mHost, mPort,
                              true);
                    mIn = new PeekableInputStream(new BufferedInputStream(mSocket.getInputStream(),
                                                  1024));
                    mOut = mSocket.getOutputStream();
                    mSecure = true;
                    /*
                     * Now resend the EHLO. Required by RFC2487 Sec. 5.2, and more specifically,
                     * Exim.
                     */
                    results = executeSimpleCommand(""EHLO "" + localHost);
                }
                else if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED)
                {
                    throw new MessagingException(""TLS not supported but required"");
                }
            }

            /*
             * result contains the results of the EHLO in concatenated form
             */
            boolean authLoginSupported = false;
            boolean authPlainSupported = false;
            boolean authCramMD5Supported = false;
            for (String result : results)
            {
                if (result.matches("".*AUTH.*LOGIN.*$"") == true)
                {
                    authLoginSupported = true;
                }
                if (result.matches("".*AUTH.*PLAIN.*$"") == true)
                {
                    authPlainSupported = true;
                }
                if (result.matches("".*AUTH.*CRAM-MD5.*$"") == true && mAuthType != null && mAuthType.equals(""CRAM_MD5""))
                {
                    authCramMD5Supported = true;
                }
            }

            if (mUsername != null && mUsername.length() > 0 && mPassword != null
                    && mPassword.length() > 0)
            {
                if (authCramMD5Supported)
                {
                    saslAuthCramMD5(mUsername, mPassword);
                }
                else if (authPlainSupported)
                {
                    saslAuthPlain(mUsername, mPassword);
                }
                else if (authLoginSupported)
                {
                    saslAuthLogin(mUsername, mPassword);
                }
                else
                {
                    throw new MessagingException(""No valid authentication mechanism found."");
                }
            }
        }
        catch (SSLException e)
        {
            throw new CertificateValidationException(e.getMessage(), e);
        }
        catch (GeneralSecurityException gse)
        {
            throw new MessagingException(
                ""Unable to open connection to SMTP server due to security error."", gse);
        }
        catch (IOException ioe)
        {
            throw new MessagingException(""Unable to open connection to SMTP server."", ioe);
        }
    }

    public void sendMessage(Message message) throws MessagingException
    {
        close();
        open();

        if (m8bitEncodingAllowed)
        {
            message.setEncoding(""8bit"");
        }

        Address[] from = message.getFrom();
        boolean possibleSend = false;
        try
        {
        	//TODO: Add BODY=8BITMIME parameter if appropriate?
            executeSimpleCommand(""MAIL FROM: "" + ""<"" + from[0].getAddress() + "">"");
            for (Address address : message.getRecipients(RecipientType.TO))
            {
                executeSimpleCommand(""RCPT TO: "" + ""<"" + address.getAddress() + "">"");
            }
            for (Address address : message.getRecipients(RecipientType.CC))
            {
                executeSimpleCommand(""RCPT TO: "" + ""<"" + address.getAddress() + "">"");
            }
            for (Address address : message.getRecipients(RecipientType.BCC))
            {
                executeSimpleCommand(""RCPT TO: "" + ""<"" + address.getAddress() + "">"");
            }
            message.setRecipients(RecipientType.BCC, null);
            executeSimpleCommand(""DATA"");
            
            EOLConvertingOutputStream msgOut = new EOLConvertingOutputStream(
                    new SmtpDataStuffing(
                            new LineWrapOutputStream(
                                    new BufferedOutputStream(mOut, 1024),
                                    1000)));

            message.writeTo(msgOut);

            // We use BufferedOutputStream. So make sure to call flush() !
            msgOut.flush();

            possibleSend = true; // After the ""\r\n."" is attempted, we may have sent the message
            executeSimpleCommand(""\r\n."");
        }
        catch (Exception e)
        {
            MessagingException me = new MessagingException(""Unable to send message"", e);
            me.setPermanentFailure(possibleSend);
            throw me;
        }
        finally
        {
            close();
        }



    }

    public void close()
    {
        try
        {
            executeSimpleCommand(""QUIT"");
        }
        catch (Exception e)
        {

        }
        try
        {
            mIn.close();
        }
        catch (Exception e)
        {

        }
        try
        {
            mOut.close();
        }
        catch (Exception e)
        {

        }
        try
        {
            mSocket.close();
        }
        catch (Exception e)
        {

        }
        mIn = null;
        mOut = null;
        mSocket = null;
    }

    private String readLine() throws IOException
    {
        StringBuffer sb = new StringBuffer();
        int d;
        while ((d = mIn.read()) != -1)
        {
            if (((char)d) == '\r')
            {
                continue;
            }
            else if (((char)d) == '\n')
            {
                break;
            }
            else
            {
                sb.append((char)d);
            }
        }
        String ret = sb.toString();
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SMTP <<< "" + ret);

        return ret;
    }

    private void writeLine(String s) throws IOException
    {
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SMTP >>> "" + s);

        /*
         * Note: We can use the string length to compute the buffer size since
         * only ASCII characters are allowed in SMTP commands i.e. this string
         * will never contain multi-byte characters.
         */
        int len = s.length();
        byte[] data = new byte[len + 2];
        s.getBytes(0, len, data, 0);
        data[len+0] = '\r';
        data[len+1] = '\n';

        /*
         * Important: Send command + CRLF using just one write() call. Using
         * multiple calls will likely result in multiple TCP packets and some
         * SMTP servers misbehave if CR and LF arrive in separate pakets.
         * See issue 799.
         */
        mOut.write(data);
        mOut.flush();
    }

    private void checkLine(String line) throws MessagingException
    {
        if (line.length() < 1)
        {
            throw new MessagingException(""SMTP response is 0 length"");
        }
        char c = line.charAt(0);
        if ((c == '4') || (c == '5'))
        {
            throw new MessagingException(line);
        }
    }

    private List<String> executeSimpleCommand(String command) throws IOException, MessagingException
    {
        List<String> results = new ArrayList<String>();
        if (command != null)
        {
            writeLine(command);
        }

        boolean cont = false;
        do
        {
            String line = readLine();
            checkLine(line);
            if (line.length() > 4)
            {
                results.add(line.substring(4));
                if (line.charAt(3) == '-')
                {
                    cont = true;
                }
                else
                {
                    cont = false;
                }
            }
        }
        while (cont);
        return results;

    }


//    C: AUTH LOGIN
//    S: 334 VXNlcm5hbWU6
//    C: d2VsZG9u
//    S: 334 UGFzc3dvcmQ6
//    C: dzNsZDBu
//    S: 235 2.0.0 OK Authenticated
//
//    Lines 2-5 of the conversation contain base64-encoded information. The same conversation, with base64 strings decoded, reads:
//
//
//    C: AUTH LOGIN
//    S: 334 Username:
//    C: weldon
//    S: 334 Password:
//    C: w3ld0n
//    S: 235 2.0.0 OK Authenticated

    private void saslAuthLogin(String username, String password) throws MessagingException,
                AuthenticationFailedException, IOException
    {
        try
        {
            executeSimpleCommand(""AUTH LOGIN"");
            executeSimpleCommand(new String(Base64.encodeBase64(username.getBytes())));
            executeSimpleCommand(new String(Base64.encodeBase64(password.getBytes())));
        }
        catch (MessagingException me)
        {
            if (me.getMessage().length() > 1 && me.getMessage().charAt(1) == '3')
            {
                throw new AuthenticationFailedException(""AUTH LOGIN failed ("" + me.getMessage()
                                                        + "")"");
            }
            throw me;
        }
    }

    private void saslAuthPlain(String username, String password) throws MessagingException,
                AuthenticationFailedException, IOException
    {
        byte[] data = (""\000"" + username + ""\000"" + password).getBytes();
        data = new Base64().encode(data);
        try
        {
            executeSimpleCommand(""AUTH PLAIN "" + new String(data));
        }
        catch (MessagingException me)
        {
            if (me.getMessage().length() > 1 && me.getMessage().charAt(1) == '3')
            {
                throw new AuthenticationFailedException(""AUTH PLAIN failed ("" + me.getMessage()
                                                        + "")"");
            }
            throw me;
        }
    }

    private void saslAuthCramMD5(String username, String password) throws MessagingException,
                AuthenticationFailedException, IOException
    {
        List<String> respList = executeSimpleCommand(""AUTH CRAM-MD5"");
        if (respList.size() != 1) throw new AuthenticationFailedException(""Unable to negotiate CRAM-MD5"");
        String b64Nonce = respList.get(0);
        byte[] nonce = Base64.decodeBase64(b64Nonce.getBytes(""US-ASCII""));
        byte[] ipad = new byte[64];
        byte[] opad = new byte[64];
        byte[] secretBytes = password.getBytes(""US-ASCII"");
        MessageDigest md;
        try
        {
            md = MessageDigest.getInstance(""MD5"");
        }
        catch (NoSuchAlgorithmException nsae)
        {
            throw new AuthenticationFailedException(""MD5 Not Available."");
        }
        if (secretBytes.length > 64)
        {
            secretBytes = md.digest(secretBytes);
        }
        System.arraycopy(secretBytes, 0, ipad, 0, secretBytes.length);
        System.arraycopy(secretBytes, 0, opad, 0, secretBytes.length);
        for (int i = 0; i < ipad.length; i++) ipad[i] ^= 0x36;
        for (int i = 0; i < opad.length; i++) opad[i] ^= 0x5c;
        md.update(ipad);
        byte[] firstPass = md.digest(nonce);
        md.update(opad);
        byte[] result = md.digest(firstPass);
        String plainCRAM = username + "" "" + new String(Hex.encodeHex(result));
        byte[] b64CRAM = Base64.encodeBase64(plainCRAM.getBytes(""US-ASCII""));
        String b64CRAMString = new String(b64CRAM, ""US-ASCII"");
        try
        {
            executeSimpleCommand(b64CRAMString);
        }
        catch (MessagingException me)
        {
            throw new AuthenticationFailedException(""Unable to negotiate MD5 CRAM"");
        }
    }
}
",True,189,0,0,9,49,1,13,L1
87,com.fsck.k9.mail.internet.TextBody.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.Body;
import com.fsck.k9.mail.MessagingException;

import java.io.*;

import org.apache.james.mime4j.codec.QuotedPrintableOutputStream;

public class TextBody implements Body
{
    private String mBody;
    private String mEncoding;

    public TextBody(String body)
    {
        this.mBody = body;
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException
    {
        if (mBody != null)
        {
            byte[] bytes = mBody.getBytes(""UTF-8"");
            if (""8bit"".equals(mEncoding))
            {
                out.write(bytes);
            }
            else
            {
                QuotedPrintableOutputStream qp = new QuotedPrintableOutputStream(out, false);
                qp.write(bytes);
                qp.flush();
            }
        }
    }

    /**
     * Get the text of the body in it's unencoded format.
     * @return
     */
    public String getText()
    {
        return mBody;
    }

    /**
     * Returns an InputStream that reads this body's text in UTF-8 format.
     */
    public InputStream getInputStream() throws MessagingException
    {
        try
        {
            byte[] b;
            if (mBody!=null)
            {
                b = mBody.getBytes(""UTF-8"");
            }
            else
            {
                b = new byte[0];
            }
            return new ByteArrayInputStream(b);
        }
        catch (UnsupportedEncodingException usee)
        {
            return null;
        }
    }

    public void setEncoding(String encoding)
    {
    	mEncoding = encoding;
    }
}
",False,77,5,36,2,3,7,3,L1
88,com.fsck.k9.mail.internet.MimeMessage.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.*;
import org.apache.james.mime4j.BodyDescriptor;
import org.apache.james.mime4j.ContentHandler;
import org.apache.james.mime4j.EOLConvertingInputStream;
import org.apache.james.mime4j.MimeStreamParser;
import org.apache.james.mime4j.field.DateTimeField;
import org.apache.james.mime4j.field.Field;

import java.io.*;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * An implementation of Message that stores all of it's metadata in RFC 822 and
 * RFC 2045 style headers.
 */
public class MimeMessage extends Message
{
    protected MimeHeader mHeader = new MimeHeader();
    protected Address[] mFrom;
    protected Address[] mTo;
    protected Address[] mCc;
    protected Address[] mBcc;
    protected Address[] mReplyTo;

    protected String mMessageId;
    protected String[] mReferences;
    protected String[] mInReplyTo;

    protected Date mSentDate;
    protected SimpleDateFormat mDateFormat;

    protected Body mBody;
    protected int mSize;

    public MimeMessage()
    {
    }


    /**
     * Parse the given InputStream using Apache Mime4J to build a MimeMessage.
     *
     * @param in
     * @throws IOException
     * @throws MessagingException
     */
    public MimeMessage(InputStream in) throws IOException, MessagingException
    {
        parse(in);
    }

    protected void parse(InputStream in) throws IOException, MessagingException
    {
        mHeader.clear();
        mFrom = null;
        mTo = null;
        mCc = null;
        mBcc = null;
        mReplyTo = null;

        mMessageId = null;
        mReferences = null;
        mInReplyTo = null;

        mSentDate = null;

        mBody = null;

        MimeStreamParser parser = new MimeStreamParser();
        parser.setContentHandler(new MimeMessageBuilder());
        parser.parse(new EOLConvertingInputStream(in));
    }

    public Date getReceivedDate() throws MessagingException
    {
        return null;
    }

    public Date getSentDate() throws MessagingException
    {
        if (mSentDate == null)
        {
            try
            {
                DateTimeField field = (DateTimeField)Field.parse(""Date: ""
                                      + MimeUtility.unfoldAndDecode(getFirstHeader(""Date"")));
                mSentDate = field.getDate();
            }
            catch (Exception e)
            {

            }
        }
        return mSentDate;
    }

    /**
     * Sets the sent date object member as well as *adds* the 'Date' header
     * instead of setting it (for performance reasons).
     *
     * @see #mSentDate
     * @param sentDate
     * @throws com.fsck.k9.mail.MessagingException
     */
    public void addSentDate(Date sentDate) throws MessagingException
    {
        if (mDateFormat == null)
        {
            mDateFormat = new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss Z"", Locale.US);
        }
        addHeader(""Date"", mDateFormat.format(sentDate));
        setInternalSentDate(sentDate);
    }

    public void setSentDate(Date sentDate) throws MessagingException
    {
        removeHeader(""Date"");
        addSentDate(sentDate);
    }

    public void setInternalSentDate(Date sentDate) throws MessagingException
    {
        this.mSentDate = sentDate;
    }

    public String getContentType() throws MessagingException
    {
        String contentType = getFirstHeader(MimeHeader.HEADER_CONTENT_TYPE);
        if (contentType == null)
        {
            return ""text/plain"";
        }
        else
        {
            return contentType.toLowerCase();
        }
    }

    public String getDisposition() throws MessagingException
    {
        String contentDisposition = getFirstHeader(MimeHeader.HEADER_CONTENT_DISPOSITION);
        if (contentDisposition == null)
        {
            return null;
        }
        else
        {
            return contentDisposition;
        }
    }

    public String getMimeType() throws MessagingException
    {
        return MimeUtility.getHeaderParameter(getContentType(), null);
    }

    public int getSize() throws MessagingException
    {
        return mSize;
    }

    /**
     * Returns a list of the given recipient type from this message. If no addresses are
     * found the method returns an empty array.
     */
    public Address[] getRecipients(RecipientType type) throws MessagingException
    {
        if (type == RecipientType.TO)
        {
            if (mTo == null)
            {
                mTo = Address.parse(MimeUtility.unfold(getFirstHeader(""To"")));
            }
            return mTo;
        }
        else if (type == RecipientType.CC)
        {
            if (mCc == null)
            {
                mCc = Address.parse(MimeUtility.unfold(getFirstHeader(""CC"")));
            }
            return mCc;
        }
        else if (type == RecipientType.BCC)
        {
            if (mBcc == null)
            {
                mBcc = Address.parse(MimeUtility.unfold(getFirstHeader(""BCC"")));
            }
            return mBcc;
        }
        else
        {
            throw new MessagingException(""Unrecognized recipient type."");
        }
    }

    public void setRecipients(RecipientType type, Address[] addresses) throws MessagingException
    {
        if (type == RecipientType.TO)
        {
            if (addresses == null || addresses.length == 0)
            {
                removeHeader(""To"");
                this.mTo = null;
            }
            else
            {
                setHeader(""To"", Address.toEncodedString(addresses));
                this.mTo = addresses;
            }
        }
        else if (type == RecipientType.CC)
        {
            if (addresses == null || addresses.length == 0)
            {
                removeHeader(""CC"");
                this.mCc = null;
            }
            else
            {
                setHeader(""CC"", Address.toEncodedString(addresses));
                this.mCc = addresses;
            }
        }
        else if (type == RecipientType.BCC)
        {
            if (addresses == null || addresses.length == 0)
            {
                removeHeader(""BCC"");
                this.mBcc = null;
            }
            else
            {
                setHeader(""BCC"", Address.toEncodedString(addresses));
                this.mBcc = addresses;
            }
        }
        else
        {
            throw new MessagingException(""Unrecognized recipient type."");
        }
    }

    /**
     * Returns the unfolded, decoded value of the Subject header.
     */
    public String getSubject() throws MessagingException
    {
        return MimeUtility.unfoldAndDecode(getFirstHeader(""Subject""));
    }

    public void setSubject(String subject) throws MessagingException
    {
        setHeader(""Subject"", subject);
    }

    public Address[] getFrom() throws MessagingException
    {
        if (mFrom == null)
        {
            String list = MimeUtility.unfold(getFirstHeader(""From""));
            if (list == null || list.length() == 0)
            {
                list = MimeUtility.unfold(getFirstHeader(""Sender""));
            }
            mFrom = Address.parse(list);
        }
        return mFrom;
    }

    public void setFrom(Address from) throws MessagingException
    {
        if (from != null)
        {
            setHeader(""From"", from.toEncodedString());
            this.mFrom = new Address[]
            {
                from
            };
        }
        else
        {
            this.mFrom = null;
        }
    }

    public Address[] getReplyTo() throws MessagingException
    {
        if (mReplyTo == null)
        {
            mReplyTo = Address.parse(MimeUtility.unfold(getFirstHeader(""Reply-to"")));
        }
        return mReplyTo;
    }

    public void setReplyTo(Address[] replyTo) throws MessagingException
    {
        if (replyTo == null || replyTo.length == 0)
        {
            removeHeader(""Reply-to"");
            mReplyTo = null;
        }
        else
        {
            setHeader(""Reply-to"", Address.toEncodedString(replyTo));
            mReplyTo = replyTo;
        }
    }

    public String getMessageId() throws MessagingException
    {
        if (mMessageId == null)
        {
            mMessageId = getFirstHeader(""Message-ID"");
        }
        if (mMessageId == null) //  even after checking the header
        {
            setMessageId(generateMessageId());
        }
        return mMessageId;
    }

    private String generateMessageId()
    {
        return ""<""+UUID.randomUUID().toString()+""@email.android.com>"";
    }

    public void setMessageId(String messageId)
    {
        setHeader(""Message-ID"", messageId);
        mMessageId = messageId;
    }

    public void setInReplyTo(String inReplyTo) throws MessagingException
    {
        setHeader(""In-Reply-To"", inReplyTo);
    }

    public String[] getReferences() throws MessagingException
    {
        if (mReferences == null)
        {
            mReferences = getHeader(""References"");
        }
        return mReferences;
    }

    public void setReferences(String references) throws MessagingException
    {
        setHeader(""References"", references);
    }

    public void saveChanges() throws MessagingException
    {
        throw new MessagingException(""saveChanges not yet implemented"");
    }

    public Body getBody() throws MessagingException
    {
        return mBody;
    }

    public void setBody(Body body) throws MessagingException
    {
        this.mBody = body;
        setHeader(""MIME-Version"", ""1.0"");
        if (body instanceof Multipart)
        {
            Multipart multipart = ((Multipart)body);
            multipart.setParent(this);
            setHeader(MimeHeader.HEADER_CONTENT_TYPE, multipart.getContentType());
        }
        else if (body instanceof TextBody)
        {
            setHeader(MimeHeader.HEADER_CONTENT_TYPE, String.format(""%s;\n charset=utf-8"",
                      getMimeType()));
            setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, ""quoted-printable"");
        }
    }

    protected String getFirstHeader(String name)
    {
        return mHeader.getFirstHeader(name);
    }

    public void addHeader(String name, String value)
    {
        mHeader.addHeader(name, value);
    }

    public void setHeader(String name, String value)
    {
        mHeader.setHeader(name, value);
    }

    public String[] getHeader(String name)
    {
        return mHeader.getHeader(name);
    }

    public void removeHeader(String name)
    {
        mHeader.removeHeader(name);
    }

    public List<String> getHeaderNames()
    {
        return mHeader.getHeaderNames();
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException
    {

        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out), 1024);
        mHeader.writeTo(out);
        writer.write(""\r\n"");
        writer.flush();
        if (mBody != null)
        {
            mBody.writeTo(out);
        }
    }

    public InputStream getInputStream() throws MessagingException
    {
        return null;
    }

    public void setEncoding(String encoding)
    {
    	if (mBody instanceof Multipart)
    	{
    		((Multipart)mBody).setEncoding(encoding);
    	}
    	else if (mBody instanceof TextBody)
        {
            setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, encoding);
            ((TextBody)mBody).setEncoding(encoding);
        }
    }

    class MimeMessageBuilder implements ContentHandler
    {
        private Stack stack = new Stack();

        public MimeMessageBuilder()
        {
        }

        private void expect(Class c)
        {
            if (!c.isInstance(stack.peek()))
            {
                throw new IllegalStateException(""Internal stack error: "" + ""Expected '""
                                                + c.getName() + ""' found '"" + stack.peek().getClass().getName() + ""'"");
            }
        }

        public void startMessage()
        {
            if (stack.isEmpty())
            {
                stack.push(MimeMessage.this);
            }
            else
            {
                expect(Part.class);
                try
                {
                    MimeMessage m = new MimeMessage();
                    ((Part)stack.peek()).setBody(m);
                    stack.push(m);
                }
                catch (MessagingException me)
                {
                    throw new Error(me);
                }
            }
        }

        public void endMessage()
        {
            expect(MimeMessage.class);
            stack.pop();
        }

        public void startHeader()
        {
            expect(Part.class);
        }

        public void field(String fieldData)
        {
            expect(Part.class);
            try
            {
                String[] tokens = fieldData.split("":"", 2);
                ((Part)stack.peek()).addHeader(tokens[0], tokens[1].trim());
            }
            catch (MessagingException me)
            {
                throw new Error(me);
            }
        }

        public void endHeader()
        {
            expect(Part.class);
        }

        public void startMultipart(BodyDescriptor bd)
        {
            expect(Part.class);

            Part e = (Part)stack.peek();
            try
            {
                MimeMultipart multiPart = new MimeMultipart(e.getContentType());
                e.setBody(multiPart);
                stack.push(multiPart);
            }
            catch (MessagingException me)
            {
                throw new Error(me);
            }
        }

        public void body(BodyDescriptor bd, InputStream in) throws IOException
        {
            expect(Part.class);
            Body body = MimeUtility.decodeBody(in, bd.getTransferEncoding());
            try
            {
                ((Part)stack.peek()).setBody(body);
            }
            catch (MessagingException me)
            {
                throw new Error(me);
            }
        }

        public void endMultipart()
        {
            stack.pop();
        }

        public void startBodyPart()
        {
            expect(MimeMultipart.class);

            try
            {
                MimeBodyPart bodyPart = new MimeBodyPart();
                ((MimeMultipart)stack.peek()).addBodyPart(bodyPart);
                stack.push(bodyPart);
            }
            catch (MessagingException me)
            {
                throw new Error(me);
            }
        }

        public void endBodyPart()
        {
            expect(BodyPart.class);
            stack.pop();
        }

        public void epilogue(InputStream is) throws IOException
        {
            expect(MimeMultipart.class);
            StringBuffer sb = new StringBuffer();
            int b;
            while ((b = is.read()) != -1)
            {
                sb.append((char)b);
            }
            // ((Multipart) stack.peek()).setEpilogue(sb.toString());
        }

        public void preamble(InputStream is) throws IOException
        {
            expect(MimeMultipart.class);
            StringBuffer sb = new StringBuffer();
            int b;
            while ((b = is.read()) != -1)
            {
                sb.append((char)b);
            }
            try
            {
                ((MimeMultipart)stack.peek()).setPreamble(sb.toString());
            }
            catch (MessagingException me)
            {
                throw new Error(me);
            }
        }

        public void raw(InputStream is) throws IOException
        {
            throw new UnsupportedOperationException(""Not supported"");
        }
    }
}
",True,189,0,0,10,48,7,17,L1
89,com.fsck.k9.mail.internet.MimeHeader.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.Utility;
import com.fsck.k9.mail.MessagingException;
import org.apache.james.mime4j.codec.EncoderUtil;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.List;

public class MimeHeader
{
    /**
     * Application specific header that contains Store specific information about an attachment.
     * In IMAP this contains the IMAP BODYSTRUCTURE part id so that the ImapStore can later
     * retrieve the attachment at will from the server.
     * The info is recorded from this header on LocalStore.appendMessages and is put back
     * into the MIME data by LocalStore.fetch.
     */
    public static final String HEADER_ANDROID_ATTACHMENT_STORE_DATA = ""X-Android-Attachment-StoreData"";

    public static final String HEADER_CONTENT_TYPE = ""Content-Type"";
    public static final String HEADER_CONTENT_TRANSFER_ENCODING = ""Content-Transfer-Encoding"";
    public static final String HEADER_CONTENT_DISPOSITION = ""Content-Disposition"";

    /**
     * Fields that should be omitted when writing the header using writeTo()
     */
    private static final String[] writeOmitFields =
    {
//        HEADER_ANDROID_ATTACHMENT_DOWNLOADED,
//        HEADER_ANDROID_ATTACHMENT_ID,
        HEADER_ANDROID_ATTACHMENT_STORE_DATA
    };

    protected ArrayList<Field> mFields = new ArrayList<Field>();

    public void clear()
    {
        mFields.clear();
    }

    public String getFirstHeader(String name)
    {
        String[] header = getHeader(name);
        if (header == null)
        {
            return null;
        }
        return header[0];
    }

    public void addHeader(String name, String value)
    {
        mFields.add(new Field(name, MimeUtility.foldAndEncode(value)));
    }

    public void setHeader(String name, String value)
    {
        if (name == null || value == null)
        {
            return;
        }
        removeHeader(name);
        addHeader(name, value);
    }

    public List<String> getHeaderNames()
    {
        ArrayList<String> names = new ArrayList<String>();
        for (Field field : mFields)
        {
            names.add(field.name);
        }
        return names;
    }

    public String[] getHeader(String name)
    {
        ArrayList<String> values = new ArrayList<String>();
        for (Field field : mFields)
        {
            if (field.name.equalsIgnoreCase(name))
            {
                values.add(field.value);
            }
        }
        if (values.size() == 0)
        {
            return null;
        }
        return values.toArray(new String[] {});
    }

    public void removeHeader(String name)
    {
        ArrayList<Field> removeFields = new ArrayList<Field>();
        for (Field field : mFields)
        {
            if (field.name.equalsIgnoreCase(name))
            {
                removeFields.add(field);
            }
        }
        mFields.removeAll(removeFields);
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException
    {
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out), 1024);
        for (Field field : mFields)
        {
            if (!Utility.arrayContains(writeOmitFields, field.name))
            {
                String v = field.value;

                if (hasToBeEncoded(v))
                {
                    v = EncoderUtil.encodeEncodedWord(
                            field.value,
                            EncoderUtil.Usage.WORD_ENTITY
                        );
                }

                writer.write(field.name + "": "" + v + ""\r\n"");
            }
        }
        writer.flush();
    }

    // encode non printable characters except LF/CR codes.
    public boolean hasToBeEncoded(String text)
    {
        for (int i = 0; i < text.length(); i++)
        {
            char c = text.charAt(i);
            if (c < 0x20 || 0x7e < c)   // non printable
            {
                if (c != 0x0a && c != 0x0d)   // non LF/CR
                {
                    return true;
                }
            }
        }

        return false;
    }

    class Field
    {
        String name;

        String value;

        public Field(String name, String value)
        {
            this.name = name;
            this.value = value;
        }
    }
}
",True,189,0,0,10,50,6,4,L1
90,com.fsck.k9.mail.internet.MimeBodyPart.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.Body;
import com.fsck.k9.mail.BodyPart;
import com.fsck.k9.mail.MessagingException;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

/**
 * TODO this is a close approximation of Message, need to update along with
 * Message.
 */
public class MimeBodyPart extends BodyPart
{
    protected MimeHeader mHeader = new MimeHeader();
    protected Body mBody;
    protected int mSize;

    public MimeBodyPart() throws MessagingException
    {
        this(null);
    }

    public MimeBodyPart(Body body) throws MessagingException
    {
        this(body, null);
    }

    public MimeBodyPart(Body body, String mimeType) throws MessagingException
    {
        if (mimeType != null)
        {
            addHeader(MimeHeader.HEADER_CONTENT_TYPE, mimeType);
        }
        setBody(body);
    }

    protected String getFirstHeader(String name) throws MessagingException
    {
        return mHeader.getFirstHeader(name);
    }

    public void addHeader(String name, String value) throws MessagingException
    {
        mHeader.addHeader(name, value);
    }

    public void setHeader(String name, String value) throws MessagingException
    {
        mHeader.setHeader(name, value);
    }

    public String[] getHeader(String name) throws MessagingException
    {
        return mHeader.getHeader(name);
    }

    public void removeHeader(String name) throws MessagingException
    {
        mHeader.removeHeader(name);
    }

    public Body getBody() throws MessagingException
    {
        return mBody;
    }

    public void setBody(Body body) throws MessagingException
    {
        this.mBody = body;
        if (body instanceof com.fsck.k9.mail.Multipart)
        {
            com.fsck.k9.mail.Multipart multipart = ((com.fsck.k9.mail.Multipart)body);
            multipart.setParent(this);
            setHeader(MimeHeader.HEADER_CONTENT_TYPE, multipart.getContentType());
        }
        else if (body instanceof TextBody)
        {
            String contentType = String.format(""%s;\n charset=utf-8"", getMimeType());
            String name = MimeUtility.getHeaderParameter(getContentType(), ""name"");
            if (name != null)
            {
                contentType += String.format("";\n name=\""%s\"""", name);
            }
            setHeader(MimeHeader.HEADER_CONTENT_TYPE, contentType);
            setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, ""quoted-printable"");
        }
    }

    public String getContentType() throws MessagingException
    {
        String contentType = getFirstHeader(MimeHeader.HEADER_CONTENT_TYPE);
        if (contentType == null)
        {
            return ""text/plain"";
        }
        else
        {
            return contentType;
        }
    }

    public String getDisposition() throws MessagingException
    {
        String contentDisposition = getFirstHeader(MimeHeader.HEADER_CONTENT_DISPOSITION);
        if (contentDisposition == null)
        {
            return null;
        }
        else
        {
            return contentDisposition;
        }
    }

    public String getMimeType() throws MessagingException
    {
        return MimeUtility.getHeaderParameter(getContentType(), null);
    }

    public boolean isMimeType(String mimeType) throws MessagingException
    {
        return getMimeType().equals(mimeType);
    }

    public int getSize() throws MessagingException
    {
        return mSize;
    }

    /**
     * Write the MimeMessage out in MIME format.
     */
    public void writeTo(OutputStream out) throws IOException, MessagingException
    {
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out), 1024);
        mHeader.writeTo(out);
        writer.write(""\r\n"");
        writer.flush();
        if (mBody != null)
        {
            mBody.writeTo(out);
        }
    }
}
",False,189,0,0,10,50,4,7,L1
91,com.fsck.k9.mail.internet.BinaryTempFileBody.java,"package com.fsck.k9.mail.internet;

import com.fsck.k9.codec.binary.Base64OutputStream;
import com.fsck.k9.mail.Body;
import com.fsck.k9.mail.MessagingException;
import org.apache.commons.io.IOUtils;

import java.io.*;

/**
 * A Body that is backed by a temp file. The Body exposes a getOutputStream method that allows
 * the user to write to the temp file. After the write the body is available via getInputStream
 * and writeTo one time. After writeTo is called, or the InputStream returned from
 * getInputStream is closed the file is deleted and the Body should be considered disposed of.
 */
public class BinaryTempFileBody implements Body
{
    private static File mTempDirectory;

    private File mFile;

    public static void setTempDirectory(File tempDirectory)
    {
        mTempDirectory = tempDirectory;
    }

    public BinaryTempFileBody() throws IOException
    {
        if (mTempDirectory == null)
        {
            throw new
            RuntimeException(""setTempDirectory has not been called on BinaryTempFileBody!"");
        }
    }

    public OutputStream getOutputStream() throws IOException
    {
        mFile = File.createTempFile(""body"", null, mTempDirectory);
        mFile.deleteOnExit();
        return new FileOutputStream(mFile);
    }

    public InputStream getInputStream() throws MessagingException
    {
        try
        {
            return new BinaryTempFileBodyInputStream(new FileInputStream(mFile));
        }
        catch (IOException ioe)
        {
            throw new MessagingException(""Unable to open body"", ioe);
        }
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException
    {
        InputStream in = getInputStream();
        Base64OutputStream base64Out = new Base64OutputStream(out);
        IOUtils.copy(in, base64Out);
        base64Out.close();
        mFile.delete();
    }

    class BinaryTempFileBodyInputStream extends FilterInputStream
    {
        public BinaryTempFileBodyInputStream(InputStream in)
        {
            super(in);
        }

        @Override
        public void close() throws IOException
        {
            super.close();
            mFile.delete();
        }
    }
}
",True,80,4,49,2,4,2,4,L1
92,com.fsck.k9.mail.internet.MimeUtility.java,"
package com.fsck.k9.mail.internet;

import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.mail.*;
import org.apache.commons.io.IOUtils;
import org.apache.james.mime4j.decoder.Base64InputStream;
import org.apache.james.mime4j.decoder.DecoderUtil;
import org.apache.james.mime4j.decoder.QuotedPrintableInputStream;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.regex.Pattern;

public class MimeUtility
{
    public static final String DEFAULT_ATTACHMENT_MIME_TYPE = ""application/octet-stream"";

    /*
     * http://www.w3schools.com/media/media_mimeref.asp
     * + png
     */
    public static final String[][] MIME_TYPE_BY_EXTENSION_MAP = new String[][]
    {
        { """",       ""application/octet-stream"" },
        { ""323"",    ""text/h323""},
        { ""acx"",    ""application/internet-property-stream""},
        { ""ai"",     ""application/postscript""},
        { ""aif"",    ""audio/x-aiff""},
        { ""aifc"",   ""audio/x-aiff""},
        { ""aiff"",   ""audio/x-aiff""},
        { ""asf"",    ""video/x-ms-asf""},
        { ""asr"",    ""video/x-ms-asf""},
        { ""asx"",    ""video/x-ms-asf""},
        { ""au"",     ""audio/basic""},
        { ""avi"",    ""video/x-msvideo""},
        { ""axs"",    ""application/olescript""},
        { ""bas"",    ""text/plain""},
        { ""bcpio"",  ""application/x-bcpio""},
        { ""bin"",    ""application/octet-stream""},
        { ""bmp"",    ""image/bmp""},
        { ""c"",      ""text/plain""},
        { ""cat"",    ""application/vnd.ms-pkiseccat""},
        { ""cdf"",    ""application/x-cdf""},
        { ""cer"",    ""application/x-x509-ca-cert""},
        { ""class"",  ""application/octet-stream""},
        { ""clp"",    ""application/x-msclip""},
        { ""cmx"",    ""image/x-cmx""},
        { ""cod"",    ""image/cis-cod""},
        { ""cpio"",   ""application/x-cpio""},
        { ""crd"",    ""application/x-mscardfile""},
        { ""crl"",    ""application/pkix-crl""},
        { ""crt"",    ""application/x-x509-ca-cert""},
        { ""csh"",    ""application/x-csh""},
        { ""css"",    ""text/css""},
        { ""dcr"",    ""application/x-director""},
        { ""der"",    ""application/x-x509-ca-cert""},
        { ""dir"",    ""application/x-director""},
        { ""dll"",    ""application/x-msdownload""},
        { ""dms"",    ""application/octet-stream""},
        { ""doc"",    ""application/msword""},
        { ""dot"",    ""application/msword""},
        { ""dvi"",    ""application/x-dvi""},
        { ""dxr"",    ""application/x-director""},
        { ""eps"",    ""application/postscript""},
        { ""etx"",    ""text/x-setext""},
        { ""evy"",    ""application/envoy""},
        { ""exe"",    ""application/octet-stream""},
        { ""fif"",    ""application/fractals""},
        { ""flr"",    ""x-world/x-vrml""},
        { ""gif"",    ""image/gif""},
        { ""gtar"",   ""application/x-gtar""},
        { ""gz"",     ""application/x-gzip""},
        { ""h"",      ""text/plain""},
        { ""hdf"",    ""application/x-hdf""},
        { ""hlp"",    ""application/winhlp""},
        { ""hqx"",    ""application/mac-binhex40""},
        { ""hta"",    ""application/hta""},
        { ""htc"",    ""text/x-component""},
        { ""htm"",    ""text/html""},
        { ""html"",   ""text/html""},
        { ""htt"",    ""text/webviewhtml""},
        { ""ico"",    ""image/x-icon""},
        { ""ief"",    ""image/ief""},
        { ""iii"",    ""application/x-iphone""},
        { ""ins"",    ""application/x-internet-signup""},
        { ""isp"",    ""application/x-internet-signup""},
        { ""jfif"",   ""image/pipeg""},
        { ""jpe"",    ""image/jpeg""},
        { ""jpeg"",   ""image/jpeg""},
        { ""jpg"",    ""image/jpeg""},
        { ""js"",     ""application/x-javascript""},
        { ""latex"",  ""application/x-latex""},
        { ""lha"",    ""application/octet-stream""},
        { ""lsf"",    ""video/x-la-asf""},
        { ""lsx"",    ""video/x-la-asf""},
        { ""lzh"",    ""application/octet-stream""},
        { ""m13"",    ""application/x-msmediaview""},
        { ""m14"",    ""application/x-msmediaview""},
        { ""m3u"",    ""audio/x-mpegurl""},
        { ""man"",    ""application/x-troff-man""},
        { ""mdb"",    ""application/x-msaccess""},
        { ""me"",     ""application/x-troff-me""},
        { ""mht"",    ""message/rfc822""},
        { ""mhtml"",  ""message/rfc822""},
        { ""mid"",    ""audio/mid""},
        { ""mny"",    ""application/x-msmoney""},
        { ""mov"",    ""video/quicktime""},
        { ""movie"",  ""video/x-sgi-movie""},
        { ""mp2"",    ""video/mpeg""},
        { ""mp3"",    ""audio/mpeg""},
        { ""mpa"",    ""video/mpeg""},
        { ""mpe"",    ""video/mpeg""},
        { ""mpeg"",   ""video/mpeg""},
        { ""mpg"",    ""video/mpeg""},
        { ""mpp"",    ""application/vnd.ms-project""},
        { ""mpv2"",   ""video/mpeg""},
        { ""ms"",     ""application/x-troff-ms""},
        { ""mvb"",    ""application/x-msmediaview""},
        { ""nws"",    ""message/rfc822""},
        { ""oda"",    ""application/oda""},
        { ""p10"",    ""application/pkcs10""},
        { ""p12"",    ""application/x-pkcs12""},
        { ""p7b"",    ""application/x-pkcs7-certificates""},
        { ""p7c"",    ""application/x-pkcs7-mime""},
        { ""p7m"",    ""application/x-pkcs7-mime""},
        { ""p7r"",    ""application/x-pkcs7-certreqresp""},
        { ""p7s"",    ""application/x-pkcs7-signature""},
        { ""pbm"",    ""image/x-portable-bitmap""},
        { ""pdf"",    ""application/pdf""},
        { ""pfx"",    ""application/x-pkcs12""},
        { ""pgm"",    ""image/x-portable-graymap""},
        { ""pko"",    ""application/ynd.ms-pkipko""},
        { ""pma"",    ""application/x-perfmon""},
        { ""pmc"",    ""application/x-perfmon""},
        { ""pml"",    ""application/x-perfmon""},
        { ""pmr"",    ""application/x-perfmon""},
        { ""pmw"",    ""application/x-perfmon""},
        { ""png"",    ""image/png""},
        { ""pnm"",    ""image/x-portable-anymap""},
        { ""pot,"",   ""application/vnd.ms-powerpoint""},
        { ""ppm"",    ""image/x-portable-pixmap""},
        { ""pps"",    ""application/vnd.ms-powerpoint""},
        { ""ppt"",    ""application/vnd.ms-powerpoint""},
        { ""prf"",    ""application/pics-rules""},
        { ""ps"",     ""application/postscript""},
        { ""pub"",    ""application/x-mspublisher""},
        { ""qt"",     ""video/quicktime""},
        { ""ra"",     ""audio/x-pn-realaudio""},
        { ""ram"",    ""audio/x-pn-realaudio""},
        { ""ras"",    ""image/x-cmu-raster""},
        { ""rgb"",    ""image/x-rgb""},
        { ""rmi"",    ""audio/mid""},
        { ""roff"",   ""application/x-troff""},
        { ""rtf"",    ""application/rtf""},
        { ""rtx"",    ""text/richtext""},
        { ""scd"",    ""application/x-msschedule""},
        { ""sct"",    ""text/scriptlet""},
        { ""setpay"", ""application/set-payment-initiation""},
        { ""setreg"", ""application/set-registration-initiation""},
        { ""sh"",     ""application/x-sh""},
        { ""shar"",   ""application/x-shar""},
        { ""sit"",    ""application/x-stuffit""},
        { ""snd"",    ""audio/basic""},
        { ""spc"",    ""application/x-pkcs7-certificates""},
        { ""spl"",    ""application/futuresplash""},
        { ""src"",    ""application/x-wais-source""},
        { ""sst"",    ""application/vnd.ms-pkicertstore""},
        { ""stl"",    ""application/vnd.ms-pkistl""},
        { ""stm"",    ""text/html""},
        { ""svg"",    ""image/svg+xml""},
        { ""sv4cpio"",""application/x-sv4cpio""},
        { ""sv4crc"", ""application/x-sv4crc""},
        { ""swf"",    ""application/x-shockwave-flash""},
        { ""t"",      ""application/x-troff""},
        { ""tar"",    ""application/x-tar""},
        { ""tcl"",    ""application/x-tcl""},
        { ""tex"",    ""application/x-tex""},
        { ""texi"",   ""application/x-texinfo""},
        { ""texinfo"",""application/x-texinfo""},
        { ""tgz"",    ""application/x-compressed""},
        { ""tif"",    ""image/tiff""},
        { ""tiff"",   ""image/tiff""},
        { ""tr"",     ""application/x-troff""},
        { ""trm"",    ""application/x-msterminal""},
        { ""tsv"",    ""text/tab-separated-values""},
        { ""txt"",    ""text/plain""},
        { ""uls"",    ""text/iuls""},
        { ""ustar"",  ""application/x-ustar""},
        { ""vcf"",    ""text/x-vcard""},
        { ""vrml"",   ""x-world/x-vrml""},
        { ""wav"",    ""audio/x-wav""},
        { ""wcm"",    ""application/vnd.ms-works""},
        { ""wdb"",    ""application/vnd.ms-works""},
        { ""wks"",    ""application/vnd.ms-works""},
        { ""wmf"",    ""application/x-msmetafile""},
        { ""wps"",    ""application/vnd.ms-works""},
        { ""wri"",    ""application/x-mswrite""},
        { ""wrl"",    ""x-world/x-vrml""},
        { ""wrz"",    ""x-world/x-vrml""},
        { ""xaf"",    ""x-world/x-vrml""},
        { ""xbm"",    ""image/x-xbitmap""},
        { ""xla"",    ""application/vnd.ms-excel""},
        { ""xlc"",    ""application/vnd.ms-excel""},
        { ""xlm"",    ""application/vnd.ms-excel""},
        { ""xls"",    ""application/vnd.ms-excel""},
        { ""xlt"",    ""application/vnd.ms-excel""},
        { ""xlw"",    ""application/vnd.ms-excel""},
        { ""xof"",    ""x-world/x-vrml""},
        { ""xpm"",    ""image/x-xpixmap""},
        { ""xwd"",    ""image/x-xwindowdump""},
        { ""z"",      ""application/x-compress""},
        { ""zip"",    ""application/zip""}
    };

    public static String unfold(String s)
    {
        if (s == null)
        {
            return null;
        }
        return s.replaceAll(""\r|\n"", """");
    }

    public static String decode(String s)
    {
        if (s == null)
        {
            return null;
        }
        return DecoderUtil.decodeEncodedWords(s);
    }

    public static String unfoldAndDecode(String s)
    {
        return decode(unfold(s));
    }

    // TODO implement proper foldAndEncode
    public static String foldAndEncode(String s)
    {
        return s;
    }

    /**
     * Returns the named parameter of a header field. If name is null the first
     * parameter is returned, or if there are no additional parameters in the
     * field the entire field is returned. Otherwise the named parameter is
     * searched for in a case insensitive fashion and returned. If the parameter
     * cannot be found the method returns null.
     *
     * @param header
     * @param name
     * @return
     */
    public static String getHeaderParameter(String header, String name)
    {
        if (header == null)
        {
            return null;
        }
        header = header.replaceAll(""\r|\n"", """");
        String[] parts = header.split("";"");
        if (name == null)
        {
            return parts[0];
        }
        for (String part : parts)
        {
            if (part.trim().toLowerCase().startsWith(name.toLowerCase()))
            {
                String parameter = part.split(""="", 2)[1].trim();
                if (parameter.startsWith(""\"""") && parameter.endsWith(""\""""))
                {
                    return parameter.substring(1, parameter.length() - 1);
                }
                else
                {
                    return parameter;
                }
            }
        }
        return null;
    }

    public static Part findFirstPartByMimeType(Part part, String mimeType)
    throws MessagingException
    {
        if (part.getBody() instanceof Multipart)
        {
            Multipart multipart = (Multipart)part.getBody();
            for (int i = 0, count = multipart.getCount(); i < count; i++)
            {
                BodyPart bodyPart = multipart.getBodyPart(i);
                Part ret = findFirstPartByMimeType(bodyPart, mimeType);
                if (ret != null)
                {
                    return ret;
                }
            }
        }
        else if (part.getMimeType().equalsIgnoreCase(mimeType))
        {
            return part;
        }
        return null;
    }

    public static Part findPartByContentId(Part part, String contentId) throws Exception
    {
        if (part.getBody() instanceof Multipart)
        {
            Multipart multipart = (Multipart)part.getBody();
            for (int i = 0, count = multipart.getCount(); i < count; i++)
            {
                BodyPart bodyPart = multipart.getBodyPart(i);
                Part ret = findPartByContentId(bodyPart, contentId);
                if (ret != null)
                {
                    return ret;
                }
            }
        }
        String[] header = part.getHeader(""Content-ID"");
        if (header != null)
        {
            for (String s : header)
            {
                if (s.equals(contentId))
                {
                    return part;
                }
            }
        }
        return null;
    }

    /**
     * Reads the Part's body and returns a String based on any charset conversion that needed
     * to be done.
     * @param part
     * @return
     * @throws IOException
     */
    public static String getTextFromPart(Part part)
    {
        Charset mCharsetConverter;

        try
        {
            if (part != null && part.getBody() != null)
            {
                Body body = part.getBody();
                if (body instanceof TextBody)
                {
                    return ((TextBody)body).getText();
                }
                else
                {
                    InputStream in = part.getBody().getInputStream();
                    String mimeType = part.getMimeType();
                    if (mimeType != null && MimeUtility.mimeTypeMatches(mimeType, ""text/*""))
                    {
                        /*
                         * Now we read the part into a buffer for further processing. Because
                         * the stream is now wrapped we'll remove any transfer encoding at this point.
                         */
                        ByteArrayOutputStream out = new ByteArrayOutputStream();
                        IOUtils.copy(in, out);

                        byte[] bytes = out.toByteArray();
                        in.close();
                        out.close();

                        String charset = getHeaderParameter(part.getContentType(), ""charset"");
                        /*
                         * We've got a text part, so let's see if it needs to be processed further.
                         */
                        if (charset != null)
                        {
                            /*
                             * See if there is conversion from the MIME charset to the Java one.
                             */
                            mCharsetConverter = Charset.forName(charset);
                            charset = mCharsetConverter.name();
                        }
                        if (charset != null)
                        {
                            /*
                             * We've got a charset encoding, so decode using it.
                             */
                            return new String(bytes, 0, bytes.length, charset);
                        }
                        else
                        {
                            /*
                             * No encoding, so use us-ascii, which is the standard.
                             */
                            return new String(bytes, 0, bytes.length, ""ASCII"");
                        }
                    }
                }
            }//if text body
        }
        catch (Exception e)
        {
            /*
             * If we are not able to process the body there's nothing we can do about it. Return
             * null and let the upper layers handle the missing content.
             */
            Log.e(K9.LOG_TAG, ""Unable to getTextFromPart"", e);
        }
        return null;
    }

    /**
     * Returns true if the given mimeType matches the matchAgainst specification.
     * @param mimeType A MIME type to check.
     * @param matchAgainst A MIME type to check against. May include wildcards such as image/* or
     * * /*.
     * @return
     */
    public static boolean mimeTypeMatches(String mimeType, String matchAgainst)
    {
        Pattern p = Pattern.compile(matchAgainst.replaceAll(""\\*"", ""\\.\\*""),
                                    Pattern.CASE_INSENSITIVE);
        return p.matcher(mimeType).matches();
    }

    /**
     * Returns true if the given mimeType matches any of the matchAgainst specifications.
     * @param mimeType A MIME type to check.
     * @param matchAgainst An array of MIME types to check against. May include wildcards such
     * as image/* or * /*.
     * @return
     */
    public static boolean mimeTypeMatches(String mimeType, String[] matchAgainst)
    {
        for (String matchType : matchAgainst)
        {
            if (mimeTypeMatches(mimeType, matchType))
            {
                return true;
            }
        }
        return false;
    }

    /**
     * Removes any content transfer encoding from the stream and returns a Body.
     */
    public static Body decodeBody(InputStream in, String contentTransferEncoding)
    throws IOException
    {
        /*
         * We'll remove any transfer encoding by wrapping the stream.
         */
        if (contentTransferEncoding != null)
        {
            contentTransferEncoding =
                MimeUtility.getHeaderParameter(contentTransferEncoding, null);
            if (""quoted-printable"".equalsIgnoreCase(contentTransferEncoding))
            {
                in = new QuotedPrintableInputStream(in);
            }
            else if (""base64"".equalsIgnoreCase(contentTransferEncoding))
            {
                in = new Base64InputStream(in);
            }
        }

        BinaryTempFileBody tempBody = new BinaryTempFileBody();
        OutputStream out = tempBody.getOutputStream();
        IOUtils.copy(in, out);
        out.close();
        return tempBody;
    }

    /**
     * An unfortunately named method that makes decisions about a Part (usually a Message)
     * as to which of it's children will be ""viewable"" and which will be attachments.
     * The method recursively sorts the viewables and attachments into seperate
     * lists for further processing.
     * @param part
     * @param viewables
     * @param attachments
     * @throws MessagingException
     */
    public static void collectParts(Part part, ArrayList<Part> viewables,
                                    ArrayList<Part> attachments) throws MessagingException
    {
        String disposition = part.getDisposition();
        String dispositionType = null;
        String dispositionFilename = null;
        if (disposition != null)
        {
            dispositionType = MimeUtility.getHeaderParameter(disposition, null);
            dispositionFilename = MimeUtility.getHeaderParameter(disposition, ""filename"");
        }

        /*
         * A best guess that this part is intended to be an attachment and not inline.
         */
        boolean attachment = (""attachment"".equalsIgnoreCase(dispositionType))
                             || (dispositionFilename != null)
                             && (!""inline"".equalsIgnoreCase(dispositionType));

        /*
         * If the part is Multipart but not alternative it's either mixed or
         * something we don't know about, which means we treat it as mixed
         * per the spec. We just process it's pieces recursively.
         */
        if (part.getBody() instanceof Multipart)
        {
            Multipart mp = (Multipart)part.getBody();
            for (int i = 0; i < mp.getCount(); i++)
            {
                collectParts(mp.getBodyPart(i), viewables, attachments);
            }
        }
        /*
         * If the part is an embedded message we just continue to process
         * it, pulling any viewables or attachments into the running list.
         */
        else if (part.getBody() instanceof Message)
        {
            Message message = (Message)part.getBody();
            collectParts(message, viewables, attachments);
        }
        /*
         * If the part is HTML and it got this far it's part of a mixed (et
         * al) and should be rendered inline.
         */
        else if ((!attachment) && (part.getMimeType().equalsIgnoreCase(""text/html"")))
        {
            viewables.add(part);
        }
        /*
         * If the part is plain text and it got this far it's part of a
         * mixed (et al) and should be rendered inline.
         */
        else if ((!attachment) && (part.getMimeType().equalsIgnoreCase(""text/plain"")))
        {
            viewables.add(part);
        }
        /*
         * Finally, if it's nothing else we will include it as an attachment.
         */
        else
        {
            attachments.add(part);
        }
    }

    public static String getMimeTypeByExtension(String filename)
    {
        if (filename!=null
                && filename.lastIndexOf('.')!=-1)
        {
            String extension = filename.substring(filename.lastIndexOf('.')+1).toLowerCase();
            for (String[] contentTypeMapEntry : MIME_TYPE_BY_EXTENSION_MAP)
            {
                if (contentTypeMapEntry[0].equals(extension))
                {
                    return contentTypeMapEntry[1];
                }
            }
        }
        return DEFAULT_ATTACHMENT_MIME_TYPE;
    }
}
",True,189,0,0,9,50,10,13,L1
93,com.fsck.k9.mail.internet.MimeMultipart.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.BodyPart;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Multipart;

import java.io.*;

public class MimeMultipart extends Multipart
{
    protected String mPreamble;

    protected String mContentType;

    protected String mBoundary;

    protected String mSubType;

    public MimeMultipart() throws MessagingException
    {
        mBoundary = generateBoundary();
        setSubType(""mixed"");
    }

    public MimeMultipart(String contentType) throws MessagingException
    {
        this.mContentType = contentType;
        try
        {
            mSubType = MimeUtility.getHeaderParameter(contentType, null).split(""/"")[1];
            mBoundary = MimeUtility.getHeaderParameter(contentType, ""boundary"");
            if (mBoundary == null)
            {
                throw new MessagingException(""MultiPart does not contain boundary: "" + contentType);
            }
        }
        catch (Exception e)
        {
            throw new MessagingException(
                ""Invalid MultiPart Content-Type; must contain subtype and boundary. (""
                + contentType + "")"", e);
        }
    }

    public String generateBoundary()
    {
        StringBuffer sb = new StringBuffer();
        sb.append(""----"");
        for (int i = 0; i < 30; i++)
        {
            sb.append(Integer.toString((int)(Math.random() * 35), 36));
        }
        return sb.toString().toUpperCase();
    }

    public String getPreamble() throws MessagingException
    {
        return mPreamble;
    }

    public void setPreamble(String preamble) throws MessagingException
    {
        this.mPreamble = preamble;
    }

    public String getContentType() throws MessagingException
    {
        return mContentType;
    }

    public void setSubType(String subType) throws MessagingException
    {
        this.mSubType = subType;
        mContentType = String.format(""multipart/%s; boundary=\""%s\"""", subType, mBoundary);
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException
    {
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out), 1024);

        if (mPreamble != null)
        {
            writer.write(mPreamble + ""\r\n"");
        }

        if (mParts.size() == 0)
        {
            writer.write(""--"" + mBoundary + ""\r\n"");
        }

        for (int i = 0, count = mParts.size(); i < count; i++)
        {
            BodyPart bodyPart = (BodyPart)mParts.get(i);
            writer.write(""--"" + mBoundary + ""\r\n"");
            writer.flush();
            bodyPart.writeTo(out);
            writer.write(""\r\n"");
        }

        writer.write(""--"" + mBoundary + ""--\r\n"");
        writer.flush();
    }

    public InputStream getInputStream() throws MessagingException
    {
        return null;
    }
}
",True,189,0,0,10,50,4,5,L1
94,com.fsck.k9.mail.store.WebDavStore.java,"package com.fsck.k9.mail.store;

import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.Utility;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Folder.OpenMode;
import com.fsck.k9.mail.internet.MimeMessage;
import com.fsck.k9.mail.transport.EOLConvertingOutputStream;
import com.fsck.k9.mail.transport.TrustedSocketFactory;
import org.apache.http.*;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.Credentials;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.CookieStore;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.protocol.ExecutionContext;
import org.apache.http.protocol.HttpContext;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;

import javax.net.ssl.SSLException;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.*;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Stack;
import java.util.zip.GZIPInputStream;

/**
 * <pre>
 * Uses WebDAV formatted HTTP calls to an MS Exchange server to fetch emails
 * and email information.  This has only been tested on an MS Exchange
 * Server 2003.  It uses Form-Based authentication and requires that
 * Outlook Web Access be enabled on the server.
 * </pre>
 */
public class WebDavStore extends Store
{
    public static final int CONNECTION_SECURITY_NONE = 0;
    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED, Flag.SEEN, Flag.ANSWERED };

    private int mConnectionSecurity;
    private String mUsername; /* Stores the username for authentications */
    private String alias;
    private String mPassword; /* Stores the password for authentications */
    private String mUrl;      /* Stores the base URL for the server */
    private String mHost;     /* Stores the host name for the server */
    private String mPath;     /* Stores the path for the server */
    private String mAuthPath; /* Stores the path off of the server to post data to for form based authentication */
    private String mMailboxPath; /* Stores the user specified path to the mailbox */
    private URI mUri;         /* Stores the Uniform Resource Indicator with all connection info */
    private String mRedirectUrl;
    private String mAuthString;
    private static String DAV_MAIL_SEND_FOLDER = ""##DavMailSubmissionURI##"";
    private static String DAV_MAIL_TMP_FOLDER = ""drafts"";


    private CookieStore mAuthCookies; /* Stores cookies from authentication */
    private boolean mAuthenticated = false; /* Stores authentication state */
    private long mLastAuth = -1; /* Stores the timestamp of last auth */
    private long mAuthTimeout = 5 * 60;

    private HashMap<String, WebDavFolder> mFolderList = new HashMap<String, WebDavFolder>();
    private boolean mSecure;
    private WebDavHttpClient mHttpClient = null;

    /**
     * webdav://user:password@server:port CONNECTION_SECURITY_NONE
     * webdav+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * webdav+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * webdav+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * webdav+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     */
    public WebDavStore(Account account) throws MessagingException
    {
        super(account);

        try
        {
            mUri = new URI(mAccount.getStoreUri());
        }
        catch (URISyntaxException use)
        {
            throw new MessagingException(""Invalid WebDavStore URI"", use);
        }
        String scheme = mUri.getScheme();
        if (scheme.equals(""webdav""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_NONE;
        }
        else if (scheme.equals(""webdav+ssl""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
        }
        else if (scheme.equals(""webdav+ssl+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
        }
        else if (scheme.equals(""webdav+tls""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
        }
        else if (scheme.equals(""webdav+tls+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
        }
        else
        {
            throw new MessagingException(""Unsupported protocol"");
        }

        mHost = mUri.getHost();
        if (mHost.startsWith(""http""))
        {
            String[] hostParts = mHost.split(""://"", 2);
            if (hostParts.length > 1)
            {
                mHost = hostParts[1];
            }
        }

        String[] pathParts = mUri.getPath().split(""\\|"");

        for (int i = 0, count = pathParts.length; i < count; i++)
        {
            if (i == 0)
            {
                if (pathParts[0] != null &&
                        pathParts[0].length() > 1)
                {
                    if (!pathParts[0].substring(1).equals(""""))
                    {
                        mPath = pathParts[0].substring(1);
                    }
                    else
                    {
                        mPath = """";
                    }
                }
                else
                {
                    mPath = """";
                }
            }
            else if (i == 1)
            {
                if (pathParts[1] != null &&
                        pathParts[1].length() > 1)
                {
                    mAuthPath = ""/"" + pathParts[1];
                }
            }
            else if (i == 2)
            {
                if (pathParts[2] != null &&
                        pathParts[2].length() > 1)
                {
                    mMailboxPath = ""/"" + pathParts[2];
                    if (mPath == null ||
                            mPath.equals(""""))
                    {
                        mPath = mMailboxPath;
                    }
                }
            }
        }
        String path = mPath;
        if (path.length() > 0 && path.startsWith(""/"") == false)
        {
            path = ""/"" + mPath;
        }

        this.mUrl = getRoot() + path;

        if (mUri.getUserInfo() != null)
        {
            try
            {
                String[] userInfoParts = mUri.getUserInfo().split("":"");
                mUsername = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                String userParts[] = mUsername.split(""/"", 2);

                if (userParts.length > 1)
                {
                    alias = userParts[1];
                }
                else
                {
                    alias = mUsername;
                }
                if (userInfoParts.length > 1)
                {
                    mPassword = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
            }
            catch (UnsupportedEncodingException enc)
            {
                // This shouldn't happen since the encoding is hardcoded to UTF-8
                Log.e(K9.LOG_TAG, ""Couldn't urldecode username or password."", enc);
            }
        }
        mSecure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
        mAuthString = ""Basic "" + Utility.base64Encode(mUsername + "":"" + mPassword);
    }

    private String getRoot()
    {
        String root;
        if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED ||
                mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
                mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL ||
                mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL)
        {
            root = ""https"";
        }
        else
        {
            root = ""http"";
        }
        root += ""://"" + mHost + "":"" + mUri.getPort();
        return root;
    }


    @Override
    public void checkSettings() throws MessagingException
    {
        Log.e(K9.LOG_TAG, ""WebDavStore.checkSettings() not implemented"");
    }

    @Override
    public Folder[] getPersonalNamespaces() throws MessagingException
    {
        ArrayList<Folder> folderList = new ArrayList<Folder>();
        HashMap<String, String> headers = new HashMap<String, String>();
        DataSet dataset = new DataSet();
        String messageBody;
        String[] folderUrls;
        int urlLength;

        /**
         * We have to check authentication here so we have the proper URL stored
         */
        getHttpClient();
        messageBody = getFolderListXml();
        headers.put(""Brief"", ""t"");
        dataset = processRequest(this.mUrl, ""SEARCH"", messageBody, headers);

        folderUrls = dataset.getHrefs();
        urlLength = folderUrls.length;

        for (int i = 0; i < urlLength; i++)
        {
//            Log.i(K9.LOG_TAG, ""folderUrls["" + i + ""] = '"" + folderUrls[i]);
            String[] urlParts = folderUrls[i].split(""/"");
//            Log.i(K9.LOG_TAG, ""urlParts = "" + urlParts);
            String folderName = urlParts[urlParts.length - 1];
            String fullPathName = """";
            WebDavFolder wdFolder;

            if (folderName.equalsIgnoreCase(K9.INBOX))
            {
                folderName = ""INBOX"";
            }
            else
            {
                for (int j = 5, count = urlParts.length; j < count; j++)
                {
                    if (j != 5)
                    {
                        fullPathName = fullPathName + ""/"" + urlParts[j];
                    }
                    else
                    {
                        fullPathName = urlParts[j];
                    }
                }
                try
                {
                    folderName = java.net.URLDecoder.decode(fullPathName, ""UTF-8"");
                }
                catch (UnsupportedEncodingException uee)
                {
                    /** If we don't support UTF-8 there's a problem, don't decode it then */
                    folderName = fullPathName;
                }
            }

            wdFolder = new WebDavFolder(this, folderName);
            wdFolder.setUrl(folderUrls[i]);
            folderList.add(wdFolder);
            this.mFolderList.put(folderName, wdFolder);
        }

        return folderList.toArray(new WebDavFolder[] {});
    }

    @Override
    public Folder getFolder(String name) throws MessagingException
    {
        WebDavFolder folder;

        if ((folder = this.mFolderList.get(name)) == null)
        {
            folder = new WebDavFolder(this, name);
        }

        return folder;
    }

    public Folder getSendSpoolFolder() throws MessagingException
    {
        return getFolder(DAV_MAIL_SEND_FOLDER);
    }

    @Override
    public boolean isMoveCapable()
    {
        return true;
    }

    @Override
    public boolean isCopyCapable()
    {
        return true;
    }

    /***************************************************************
     * WebDAV XML Request body retrieval functions
     */

    private String getFolderListXml()
    {
        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""DAV:uid\"", \""DAV:ishidden\""\r\n"");
        buffer.append("" FROM SCOPE('deep traversal of \""""+this.mUrl+""\""')\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=True\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessageCountXml(String messageState)
    {
        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""DAV:visiblecount\""\r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False AND \""urn:schemas:httpmail:read\""=""+messageState+""\r\n"");
        buffer.append("" GROUP BY \""DAV:ishidden\""\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessageEnvelopeXml(String[] uids)
    {
        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""DAV:uid\"", \""DAV:getcontentlength\"","");
        buffer.append("" \""urn:schemas:mailheader:mime-version\"","");
        buffer.append("" \""urn:schemas:mailheader:content-type\"","");
        buffer.append("" \""urn:schemas:mailheader:subject\"","");
        buffer.append("" \""urn:schemas:mailheader:date\"","");
        buffer.append("" \""urn:schemas:mailheader:thread-topic\"","");
        buffer.append("" \""urn:schemas:mailheader:thread-index\"","");
        buffer.append("" \""urn:schemas:mailheader:from\"","");
        buffer.append("" \""urn:schemas:mailheader:to\"","");
        buffer.append("" \""urn:schemas:mailheader:in-reply-to\"","");
        buffer.append("" \""urn:schemas:mailheader:cc\"","");
        buffer.append("" \""urn:schemas:httpmail:read\"""");
        buffer.append("" \r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False AND "");
        for (int i = 0, count = uids.length; i < count; i++)
        {
            if (i != 0)
            {
                buffer.append(""  OR "");
            }
            buffer.append("" \""DAV:uid\""='""+uids[i]+""' "");
        }
        buffer.append(""\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessagesXml()
    {
        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""DAV:uid\""\r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessageUrlsXml(String[] uids)
    {
        StringBuffer buffer = new StringBuffer(600);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""urn:schemas:httpmail:read\"", \""DAV:uid\""\r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False AND "");
        for (int i = 0, count = uids.length; i < count; i++)
        {
            if (i != 0)
            {
                buffer.append(""  OR "");
            }

            buffer.append("" \""DAV:uid\""='""+uids[i]+""' "");

        }
        buffer.append(""\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessageFlagsXml(String[] uids) throws MessagingException
    {
        if (uids.length == 0)
        {
            throw new MessagingException(""Attempt to get flags on 0 length array for uids"");
        }

        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""urn:schemas:httpmail:read\"", \""DAV:uid\""\r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False AND "");

        for (int i = 0, count = uids.length; i < count; i++)
        {
            if (i != 0)
            {
                buffer.append("" OR "");
            }
            buffer.append("" \""DAV:uid\""='""+uids[i]+""' "");
        }
        buffer.append(""\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMarkMessagesReadXml(String[] urls, boolean read)
    {
        StringBuffer buffer = new StringBuffer(600);
        buffer.append(""<?xml version='1.0' ?>\r\n"");
        buffer.append(""<a:propertyupdate xmlns:a='DAV:' xmlns:b='urn:schemas:httpmail:'>\r\n"");
        buffer.append(""<a:target>\r\n"");
        for (int i = 0, count = urls.length; i < count; i++)
        {
            buffer.append("" <a:href>""+urls[i]+""</a:href>\r\n"");
        }
        buffer.append(""</a:target>\r\n"");
        buffer.append(""<a:set>\r\n"");
        buffer.append("" <a:prop>\r\n"");
        buffer.append(""  <b:read>"" + (read ? ""1"" : ""0"") + ""</b:read>\r\n"");
        buffer.append("" </a:prop>\r\n"");
        buffer.append(""</a:set>\r\n"");
        buffer.append(""</a:propertyupdate>\r\n"");
        return buffer.toString();
    }

    // For flag:
//    http://www.devnewsgroups.net/group/microsoft.public.exchange.development/topic27175.aspx
    //""<m:0x10900003>1</m:0x10900003>"" & _

    private String getMoveOrCopyMessagesReadXml(String[] urls, boolean isMove)
    {

        String action = (isMove ? ""move"" : ""copy"");
        StringBuffer buffer = new StringBuffer(600);
        buffer.append(""<?xml version='1.0' ?>\r\n"");
        buffer.append(""<a:"" + action + "" xmlns:a='DAV:' xmlns:b='urn:schemas:httpmail:'>\r\n"");
        buffer.append(""<a:target>\r\n"");
        for (int i = 0, count = urls.length; i < count; i++)
        {
            buffer.append("" <a:href>""+urls[i]+""</a:href>\r\n"");
        }
        buffer.append(""</a:target>\r\n"");

        buffer.append(""</a:"" + action + "">\r\n"");
        return buffer.toString();
    }

    /***************************************************************
     * Authentication related methods
     */

    /**
     * Performs Form Based authentication regardless of the current
     * authentication state
     * @throws MessagingException
     */
    public void authenticate() throws MessagingException
    {
        try
        {
            doFBA();
            //this.mAuthCookies = doAuthentication(this.mUsername, this.mPassword, this.mUrl);
        }
        catch (IOException ioe)
        {
            Log.e(K9.LOG_TAG, ""Error during authentication: "" + ioe + ""\nStack: "" + processException(ioe));
            throw new MessagingException(""Error during authentication"", ioe);
        }

        if (this.mAuthCookies == null)
        {
            this.mAuthenticated = false;
        }
        else
        {
            this.mAuthenticated = true;
            this.mLastAuth = System.currentTimeMillis()/1000;
        }
    }

    /**
     * Determines if a new authentication is needed.
     * Returns true if new authentication is needed.
     */
    public boolean needAuth()
    {
        boolean status = false;
        long currentTime = -1;
        if (this.mAuthenticated == false)
        {
            status = true;
        }

        currentTime = System.currentTimeMillis()/1000;
        if ((currentTime - this.mLastAuth) > (this.mAuthTimeout))
        {
            status = true;
        }
        return status;
    }

    public static String getHttpRequestResponse(HttpEntity request, HttpEntity response) throws IllegalStateException, IOException
    {
        String responseText = """";
        String requestText = """";
        if (response != null)
        {
            BufferedReader reader = new BufferedReader(new InputStreamReader(WebDavHttpClient.getUngzippedContent(response)), 8192);
            String tempText = """";

            while ((tempText = reader.readLine()) != null)
            {
                responseText += tempText;
            }
        }
        if (request != null)
        {
            BufferedReader reader = new BufferedReader(new InputStreamReader(WebDavHttpClient.getUngzippedContent(response)), 8192);
            String tempText = """";

            while ((tempText = reader.readLine()) != null)
            {
                requestText += tempText;
            }
            requestText = requestText.replaceAll(""password=.*?&"", ""password=(omitted)&"");
        }
        return ""Request: "" + requestText +
               ""\n\nResponse: "" + responseText;

    }

    /**
     * Performs the Form Based Authentication
     * Returns the CookieStore object for later use or null
     * @throws MessagingException
     */
    public void doFBA() throws IOException, MessagingException
    {
        /*    public CookieStore doAuthentication(String username, String password,
              String url) throws IOException, MessagingException {*/
        String authPath;
        String url = this.mUrl;
        String username = this.mUsername;
        String password = this.mPassword;
        String[] urlParts = url.split(""/"");
        String finalUrl = """";
        String loginUrl = """";
        String destinationUrl = """";

        if (this.mAuthPath != null &&
                !this.mAuthPath.equals("""") &&
                !this.mAuthPath.equals(""/""))
        {
            authPath = this.mAuthPath;
        }
        else
        {
            authPath = ""/exchweb/bin/auth/owaauth.dll"";
        }

        for (int i = 0; i <= 2; i++)
        {
            if (i != 0)
            {
                finalUrl = finalUrl + ""/"" + urlParts[i];
            }
            else
            {
                finalUrl = urlParts[i];
            }
        }

        if (finalUrl.equals(""""))
        {
            throw new MessagingException(""doFBA failed, unable to construct URL to post login credentials to."");
        }

        loginUrl = finalUrl + authPath;

        try
        {
            /* Browser Client */
            WebDavHttpClient httpclient = mHttpClient;

            /**
             * This is in a separate block because I really don't like how it's done.
             * This basically scrapes the OWA login page for the form submission URL.
             * UGLY!WebDavHttpClient
             * Added an if-check to see if there's a user supplied authentication path for FBA
             */
            if (this.mAuthPath == null ||
                    this.mAuthPath.equals("""") ||
                    this.mAuthPath.equals(""/""))
            {

                httpclient.addRequestInterceptor(new HttpRequestInterceptor()
                {
                    public void process(HttpRequest request, HttpContext context)
                    throws HttpException, IOException
                    {
                        mRedirectUrl = ((HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST)).toURI() + request.getRequestLine().getUri();
                    }
                });
                HashMap<String, String> headers = new HashMap<String, String>();
                InputStream istream = sendRequest(finalUrl, ""GET"", null, headers, false);

                if (istream != null)
                {
                    BufferedReader reader = new BufferedReader(new InputStreamReader(istream), 4096);
                    String tempText = """";
                    boolean matched = false;

                    while ((tempText = reader.readLine()) != null &&
                            !matched)
                    {
                        if (tempText.indexOf("" action"") >= 0)
                        {
                            String[] tagParts = tempText.split(""\"""");
                            if (tagParts[1].lastIndexOf('/') < 0 &&
                                    mRedirectUrl != null &&
                                    !mRedirectUrl.equals(""""))
                            {
                                /* We have to do a multi-stage substring here because of potential GET parameters */
                                mRedirectUrl = mRedirectUrl.substring(0, mRedirectUrl.lastIndexOf('?'));
                                mRedirectUrl = mRedirectUrl.substring(0, mRedirectUrl.lastIndexOf('/'));
                                loginUrl = mRedirectUrl + ""/"" + tagParts[1];
                                this.mAuthPath = ""/"" + tagParts[1];
                            }
                            else
                            {
                                loginUrl = finalUrl + tagParts[1];
                                this.mAuthPath = ""/"" + tagParts[1];
                            }
                        }

                        if (tempText.indexOf(""destination"") >= 0)
                        {
                            String[] tagParts = tempText.split(""value"");
                            if (tagParts[1] != null)
                            {
                                String[] valueParts = tagParts[1].split(""\"""");
                                destinationUrl = valueParts[1];
                                matched = true;
                            }
                        }
                    }
                    istream.close();
                }
            }


            /** Build the POST data to use */
            ArrayList<BasicNameValuePair> pairs = new ArrayList<BasicNameValuePair>();
            pairs.add(new BasicNameValuePair(""username"", username));
            pairs.add(new BasicNameValuePair(""password"", password));
            if (this.mMailboxPath != null &&
                    !this.mMailboxPath.equals(""""))
            {
                pairs.add(new BasicNameValuePair(""destination"", finalUrl + this.mMailboxPath));
            }
            else if (destinationUrl != null &&
                     !destinationUrl.equals(""""))
            {
                pairs.add(new BasicNameValuePair(""destination"", destinationUrl));
            }
            else
            {
                pairs.add(new BasicNameValuePair(""destination"", ""/""));
            }
            pairs.add(new BasicNameValuePair(""flags"", ""0""));
            pairs.add(new BasicNameValuePair(""SubmitCreds"", ""Log+On""));
            pairs.add(new BasicNameValuePair(""forcedownlevel"", ""0""));
            pairs.add(new BasicNameValuePair(""trusted"", ""0""));

            try
            {
                UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(pairs);
                HashMap<String, String> headers = new HashMap<String, String>();
                String tempUrl = """";
                InputStream istream = sendRequest(loginUrl, ""POST"", formEntity, headers, false);

                /** Get the URL for the mailbox and set it for the store */
                if (istream != null)
                {
                    BufferedReader reader = new BufferedReader(new InputStreamReader(istream), 8192);
                    String tempText = """";

                    while ((tempText = reader.readLine()) != null)
                    {
                        if (tempText.indexOf(""BASE href"") >= 0)
                        {
                            String[] tagParts = tempText.split(""\"""");
                            tempUrl = tagParts[1];
                        }
                    }
                }

                if (this.mMailboxPath != null &&
                        !this.mMailboxPath.equals(""""))
                {
                    this.mUrl = finalUrl + ""/"" + this.mMailboxPath + ""/"";
                }
                else if (tempUrl.equals(""""))
                {
                    this.mUrl = finalUrl + ""/Exchange/"" + this.alias + ""/"";
                }
                else
                {
                    this.mUrl = tempUrl;
                }

            }
            catch (UnsupportedEncodingException uee)
            {
                Log.e(K9.LOG_TAG, ""Error encoding POST data for authentication: "" + uee + ""\nTrace: "" + processException(uee));
                throw new MessagingException(""Error encoding POST data for authentication"", uee);
            }
        }
        catch (SSLException e)
        {
            throw new CertificateValidationException(e.getMessage(), e);
        }

        this.mAuthenticated = true;
    }

    public CookieStore getAuthCookies()
    {
        return mAuthCookies;
    }

    public String getAlias()
    {
        return alias;
    }

    public String getUrl()
    {
        return mUrl;
    }

    public WebDavHttpClient getHttpClient() throws MessagingException
    {
        SchemeRegistry reg;
        Scheme s;
        boolean needAuth = false;

        if (mHttpClient == null)
        {
            mHttpClient = new WebDavHttpClient();
            needAuth = true;
        }

        reg = mHttpClient.getConnectionManager().getSchemeRegistry();
        try
        {
            // Log.i(K9.LOG_TAG, ""getHttpClient mHost = "" + mHost);
            s = new Scheme(""https"", new TrustedSocketFactory(mHost, mSecure), 443);
        }
        catch (NoSuchAlgorithmException nsa)
        {
            Log.e(K9.LOG_TAG, ""NoSuchAlgorithmException in getHttpClient: "" + nsa);
            throw new MessagingException(""NoSuchAlgorithmException in getHttpClient: "" + nsa);
        }
        catch (KeyManagementException kme)
        {
            Log.e(K9.LOG_TAG, ""KeyManagementException in getHttpClient: "" + kme);
            throw new MessagingException(""KeyManagementException in getHttpClient: "" + kme);
        }
        reg.register(s);

        if (needAuth)
        {
            HashMap<String, String> headers = new HashMap<String, String>();
            processRequest(this.mUrl, ""GET"", null, headers, false);
        }

        /*
        if (needAuth()) {
            if (!checkAuth()) {
                try {
                    CookieStore cookies = mHttpClient.getCookieStore();
                    cookies.clear();
                    mHttpClient.setCookieStore(cookies);
                    cookies = doAuthentication(this.mUsername, this.mPassword, this.mUrl);
                    if (cookies != null) {
                        this.mAuthenticated = true;
                        this.mLastAuth = System.currentTimeMillis()/1000;
                    }
                    mHttpClient.setCookieStore(cookies);
                } catch (IOException ioe) {
                    Log.e(K9.LOG_TAG, ""IOException: "" + ioe + ""\nTrace: "" + processException(ioe));
                }
            } else {
                Credentials creds = new UsernamePasswordCredentials(mUsername, mPassword);
                CredentialsProvider credsProvider = mHttpClient.getCredentialsProvider();
                credsProvider.setCredentials(new AuthScope(mHost, 80, AuthScope.ANY_REALM), creds);
                credsProvider.setCredentials(new AuthScope(mHost, 443, AuthScope.ANY_REALM), creds);
                credsProvider.setCredentials(new AuthScope(mHost, mUri.getPort(), AuthScope.ANY_REALM), creds);
                mHttpClient.setCredentialsProvider(credsProvider);
                // Assume we're authenticated and ok here since the checkAuth() was 401 and we've now set the credentials
                this.mAuthenticated = true;
                this.mLastAuth = System.currentTimeMillis()/1000;
            }
        }
        */
        return mHttpClient;
    }

    public WebDavHttpClient getTrustedHttpClient() throws KeyManagementException, NoSuchAlgorithmException
    {
        if (mHttpClient == null)
        {
            mHttpClient = new WebDavHttpClient();
            SchemeRegistry reg = mHttpClient.getConnectionManager().getSchemeRegistry();
            Scheme s = new Scheme(""https"",new TrustedSocketFactory(mHost,mSecure),443);
            reg.register(s);


            //Add credentials for NTLM/Digest/Basic Auth
            Credentials creds = new UsernamePasswordCredentials(mUsername, mPassword);
            CredentialsProvider credsProvider  = mHttpClient.getCredentialsProvider();
            // setting AuthScope for 80 and 443, in case we end up getting redirected
            // from 80 to 443.
            credsProvider.setCredentials(new AuthScope(mHost, 80, AuthScope.ANY_REALM), creds);
            credsProvider.setCredentials(new AuthScope(mHost, 443, AuthScope.ANY_REALM), creds);
            credsProvider.setCredentials(new AuthScope(mHost, mUri.getPort(), AuthScope.ANY_REALM), creds);
            mHttpClient.setCredentialsProvider(credsProvider);
        }

        return mHttpClient;
    }

    private InputStream sendRequest(String url, String method, StringEntity messageBody, HashMap<String, String> headers, boolean tryAuth)
    throws MessagingException
    {
        WebDavHttpClient httpclient;
        InputStream istream = null;

        if (url == null ||
                method == null)
        {
            return istream;
        }

        httpclient = getHttpClient();

        try
        {
            int statusCode = -1;
            StringEntity messageEntity = null;
            HttpGeneric httpmethod = new HttpGeneric(url);
            HttpResponse response;
            HttpEntity entity;

            if (messageBody != null)
            {
                httpmethod.setEntity(messageBody);
            }

            for (String headerName : headers.keySet())
            {
                httpmethod.setHeader(headerName, headers.get(headerName));
            }

            if (mAuthString != null && mAuthenticated)
            {
                httpmethod.setHeader(""Authorization"", mAuthString);
            }

            httpmethod.setMethod(method);
            response = httpclient.executeOverride(httpmethod);
            statusCode = response.getStatusLine().getStatusCode();

            entity = response.getEntity();

            if (statusCode == 401)
            {
                if (tryAuth)
                {
                    mAuthenticated = true;
                    sendRequest(url, method, messageBody, headers, false);
                }
                else
                {
                    throw new MessagingException(""Invalid username or password for Basic authentication"");
                }
            }
            else if (statusCode == 440)
            {
                if (tryAuth)
                {
                    doFBA();
                    sendRequest(url, method, messageBody, headers, false);
                }
                else
                {
                    throw new MessagingException(""Authentication failure in sendRequest"");
                }
            }
            else if (statusCode < 200 ||
                     statusCode >= 300)
            {
                throw new IOException(""Error with code "" + statusCode + "" during request processing: ""+
                                      response.getStatusLine().toString());
            }
            else
            {
                if (tryAuth &&
                        mAuthenticated == false)
                {
                    doFBA();
                    sendRequest(url, method, messageBody, headers, false);
                }
            }

            if (entity != null)
            {
                istream = WebDavHttpClient.getUngzippedContent(entity);
            }
        }
        catch (UnsupportedEncodingException uee)
        {
            Log.e(K9.LOG_TAG, ""UnsupportedEncodingException: "" + uee + ""\nTrace: "" + processException(uee));
            throw new MessagingException(""UnsupportedEncodingException"", uee);
        }
        catch (IOException ioe)
        {
            Log.e(K9.LOG_TAG, ""IOException: "" + ioe + ""\nTrace: "" + processException(ioe));
            throw new MessagingException(""IOException"", ioe);
        }

        return istream;
    }

    public String getAuthString()
    {
        return mAuthString;
    }

    /**
     * Performs an httprequest to the supplied url using the supplied method.
     * messageBody and headers are optional as not all requests will need them.
     * There are two signatures to support calls that don't require parsing of the response.
     */
    private DataSet processRequest(String url, String method, String messageBody, HashMap<String, String> headers)
    throws MessagingException
    {
        return processRequest(url, method, messageBody, headers, true);
    }

    private DataSet processRequest(String url, String method, String messageBody, HashMap<String, String> headers, boolean needsParsing)
    throws MessagingException
    {
        DataSet dataset = new DataSet();
        if (K9.DEBUG)
        {
            Log.v(K9.LOG_TAG, ""processRequest url = '"" + url + ""', method = '"" + method + ""', messageBody = '"" + messageBody + ""'"");
        }

        if (url == null ||
                method == null)
        {
            return dataset;
        }

        getHttpClient();

        try
        {
            StringEntity messageEntity = null;
            if (messageBody != null)
            {
                messageEntity = new StringEntity(messageBody);
                messageEntity.setContentType(""text/xml"");
                //                httpmethod.setEntity(messageEntity);
            }
            InputStream istream = sendRequest(url, method, messageEntity, headers, true);
            if (istream != null &&
                    needsParsing)
            {
                try
                {
                    SAXParserFactory spf = SAXParserFactory.newInstance();
                    SAXParser sp = spf.newSAXParser();
                    XMLReader xr = sp.getXMLReader();
                    WebDavHandler myHandler = new WebDavHandler();

                    xr.setContentHandler(myHandler);

                    xr.parse(new InputSource(istream));

                    dataset = myHandler.getDataSet();
                }
                catch (SAXException se)
                {
                    Log.e(K9.LOG_TAG, ""SAXException in processRequest() "" + se + ""\nTrace: "" + processException(se));
                    throw new MessagingException(""SAXException in processRequest() "", se);
                }
                catch (ParserConfigurationException pce)
                {
                    Log.e(K9.LOG_TAG, ""ParserConfigurationException in processRequest() "" + pce + ""\nTrace: "" + processException(pce));
                    throw new MessagingException(""ParserConfigurationException in processRequest() "", pce);
                }

                istream.close();
            }
        }
        catch (UnsupportedEncodingException uee)
        {
            Log.e(K9.LOG_TAG, ""UnsupportedEncodingException: "" + uee + ""\nTrace: "" + processException(uee));
            throw new MessagingException(""UnsupportedEncodingException in processRequest() "", uee);
        }
        catch (IOException ioe)
        {
            Log.e(K9.LOG_TAG, ""IOException: "" + ioe + ""\nTrace: "" + processException(ioe));
            throw new MessagingException(""IOException in processRequest() "", ioe);
        }

        return dataset;
    }

    /**
     * Returns a string of the stacktrace for a Throwable to allow for easy inline printing of errors.
     */
    private String processException(Throwable t)
    {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        PrintStream ps = new PrintStream(baos);

        t.printStackTrace(ps);
        ps.close();

        return baos.toString();
    }

    @Override
    public boolean isSendCapable()
    {
        return true;
    }

    @Override
    public void sendMessages(Message[] messages) throws MessagingException
    {
        WebDavFolder tmpFolder = (WebDavStore.WebDavFolder)getFolder(DAV_MAIL_TMP_FOLDER);
        try
        {
            tmpFolder.open(OpenMode.READ_WRITE);
            Message[] retMessages = tmpFolder.appendWebDavMessages(messages);

            tmpFolder.moveMessages(retMessages, getSendSpoolFolder());
        }
        finally
        {
            if (tmpFolder != null)
            {
                tmpFolder.close();
            }
        }
    }

    /*************************************************************************
     * Helper and Inner classes
     */

    /**
     * A WebDav Folder
     */
    class WebDavFolder extends Folder
    {
        private String mName;
        private String mFolderUrl;
        private boolean mIsOpen = false;
        private int mMessageCount = 0;
        private int mUnreadMessageCount = 0;
        private WebDavStore store;

        protected WebDavStore getStore()
        {
            return store;
        }


        public WebDavFolder(WebDavStore nStore, String name)
        {
            super(nStore.getAccount());
            store = nStore;
            this.mName = name;


            if (DAV_MAIL_SEND_FOLDER.equals(name))
            {
                this.mFolderUrl = getUrl() + ""/"" + name +""/"";
            }
            else
            {
                String encodedName = """";
                try
                {
                    String[] urlParts = name.split(""/"");
                    String url = """";
                    for (int i = 0, count = urlParts.length; i < count; i++)
                    {
                        if (i != 0)
                        {
                            url = url + ""/"" + java.net.URLEncoder.encode(urlParts[i], ""UTF-8"");
                        }
                        else
                        {
                            url = java.net.URLEncoder.encode(urlParts[i], ""UTF-8"");
                        }
                    }
                    encodedName = url;
                }
                catch (UnsupportedEncodingException uee)
                {
                    Log.e(K9.LOG_TAG, ""UnsupportedEncodingException URLEncoding folder name, skipping encoded"");
                    encodedName = name;
                }

                encodedName = encodedName.replaceAll(""\\+"", ""%20"");

                /**
                 * In some instances, it is possible that our folder objects have been collected,
                 * but getPersonalNamespaces() isn't called again (ex. Android destroys the email client).
                 * Perform an authentication to get the appropriate URLs in place again
                 */
                // TODO: danapple0 - huh?
                //getHttpClient();

                if (encodedName.equals(""INBOX""))
                {
                    encodedName = ""Inbox"";
                }
                this.mFolderUrl = WebDavStore.this.mUrl;
                if (WebDavStore.this.mUrl.endsWith(""/"") == false)
                {
                    this.mFolderUrl += ""/"";
                }
                this.mFolderUrl += encodedName;
            }
        }

        public void setUrl(String url)
        {
            if (url != null)
            {
                this.mFolderUrl = url;
            }
        }

        @Override
        public void open(OpenMode mode) throws MessagingException
        {
            getHttpClient();

            this.mIsOpen = true;
        }

        @Override
        public void copyMessages(Message[] messages, Folder folder) throws MessagingException
        {
            moveOrCopyMessages(messages, folder.getName(), false);
        }

        @Override
        public void moveMessages(Message[] messages, Folder folder) throws MessagingException
        {
            moveOrCopyMessages(messages, folder.getName(), true);
        }

        @Override
        public void delete(Message[] msgs, String trashFolderName) throws MessagingException
        {
            moveOrCopyMessages(msgs, trashFolderName, true);
        }
        private void moveOrCopyMessages(Message[] messages, String folderName, boolean isMove) throws MessagingException
        {
            String[] uids = new String[messages.length];

            for (int i = 0, count = messages.length; i < count; i++)
            {
                uids[i] = messages[i].getUid();
            }
            String messageBody = """";
            HashMap<String, String> headers = new HashMap<String, String>();
            HashMap<String, String> uidToUrl = getMessageUrls(uids);
            String[] urls = new String[uids.length];

            for (int i = 0, count = uids.length; i < count; i++)
            {
                urls[i] = uidToUrl.get(uids[i]);
                if (urls[i] == null && messages[i] instanceof WebDavMessage)
                {
                    WebDavMessage wdMessage = (WebDavMessage)messages[i];
                    urls[i] = wdMessage.getUrl();
                }
            }

            messageBody = getMoveOrCopyMessagesReadXml(urls, isMove);
            WebDavFolder destFolder = (WebDavFolder)store.getFolder(folderName);
            headers.put(""Destination"", destFolder.mFolderUrl);
            headers.put(""Brief"", ""t"");
            headers.put(""If-Match"", ""*"");
            String action = (isMove ? ""BMOVE"" : ""BCOPY"");
            Log.i(K9.LOG_TAG, ""Moving "" + messages.length + "" messages to "" + destFolder.mFolderUrl);

            processRequest(mFolderUrl, action, messageBody, headers, false);

        }

        private int getMessageCount(boolean read, CookieStore authCookies) throws MessagingException
        {
            String isRead;
            int messageCount = 0;
            DataSet dataset = new DataSet();
            HashMap<String, String> headers = new HashMap<String, String>();
            String messageBody;

            if (read)
            {
                isRead = ""True"";
            }
            else
            {
                isRead = ""False"";
            }

            messageBody = getMessageCountXml(isRead);
            headers.put(""Brief"", ""t"");
            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);
            if (dataset != null)
            {
                messageCount = dataset.getMessageCount();
            }


            return messageCount;
        }

        @Override
        public int getMessageCount() throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            this.mMessageCount = getMessageCount(true, WebDavStore.this.mAuthCookies);

            return this.mMessageCount;
        }

        @Override
        public int getUnreadMessageCount() throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            this.mUnreadMessageCount = getMessageCount(false, WebDavStore.this.mAuthCookies);

            return this.mUnreadMessageCount;
        }

        @Override
        public boolean isOpen()
        {
            return this.mIsOpen;
        }

        @Override
        public OpenMode getMode() throws MessagingException
        {
            return OpenMode.READ_WRITE;
        }

        @Override
        public String getName()
        {
            return this.mName;
        }

        @Override
        public boolean exists()
        {
            return true;
        }

        @Override
        public void close()
        {
            this.mMessageCount = 0;
            this.mUnreadMessageCount = 0;

            this.mIsOpen = false;
        }

        @Override
        public boolean create(FolderType type) throws MessagingException
        {
            return true;
        }

        @Override
        public void delete(boolean recursive) throws MessagingException
        {
            throw new Error(""WebDavFolder.delete() not implemeneted"");
        }

        @Override
        public Message getMessage(String uid) throws MessagingException
        {
            return new WebDavMessage(uid, this);
        }

        @Override
        public Message[] getMessages(int start, int end, MessageRetrievalListener listener)
        throws MessagingException
        {
            ArrayList<Message> messages = new ArrayList<Message>();
            String[] uids;
            DataSet dataset = new DataSet();
            HashMap<String, String> headers = new HashMap<String, String>();
            int uidsLength = -1;

            String messageBody;
            int prevStart = start;

            /** Reverse the message range since 0 index is newest */
            start = this.mMessageCount - end;
            end = start + (end - prevStart);

            //end = this.mMessageCount - prevStart;

            if (start < 0 || end < 0 || end < start)
            {
                throw new MessagingException(String.format(""Invalid message set %d %d"", start, end));
            }

            if (start == 0 && end < 10)
            {
                end = 10;
            }

            /** Verify authentication */
            messageBody = getMessagesXml();

            headers.put(""Brief"", ""t"");
            headers.put(""Range"", ""rows="" + start + ""-"" + end);
            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);

            uids = dataset.getUids();
            HashMap<String, String> uidToUrl = dataset.getUidToUrl();
            uidsLength = uids.length;

            for (int i = 0; i < uidsLength; i++)
            {
                if (listener != null)
                {
                    listener.messageStarted(uids[i], i, uidsLength);
                }
                WebDavMessage message = new WebDavMessage(uids[i], this);
                message.setUrl(uidToUrl.get(uids[i]));
                messages.add(message);

                if (listener != null)
                {
                    listener.messageFinished(message, i, uidsLength);
                }
            }

            return messages.toArray(new Message[] {});
        }


        @Override
        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException
        {
            return getMessages(null, listener);
        }

        @Override
        public Message[] getMessages(String[] uids, MessageRetrievalListener listener) throws MessagingException
        {
            ArrayList<Message> messageList = new ArrayList<Message>();
            Message[] messages;

            if (uids == null ||
                    uids.length == 0)
            {
                return messageList.toArray(new Message[] {});
            }

            for (int i = 0, count = uids.length; i < count; i++)
            {
                if (listener != null)
                {
                    listener.messageStarted(uids[i], i, count);
                }

                WebDavMessage message = new WebDavMessage(uids[i], this);
                messageList.add(message);

                if (listener != null)
                {
                    listener.messageFinished(message, i, count);
                }
            }
            messages = messageList.toArray(new Message[] {});

            return messages;
        }

        private HashMap<String, String> getMessageUrls(String[] uids) throws MessagingException
        {
            HashMap<String, String> uidToUrl = new HashMap<String, String>();
            HashMap<String, String> headers = new HashMap<String, String>();
            DataSet dataset = new DataSet();
            String messageBody;

            /** Retrieve and parse the XML entity for our messages */
            messageBody = getMessageUrlsXml(uids);
            headers.put(""Brief"", ""t"");

            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);
            uidToUrl = dataset.getUidToUrl();

            return uidToUrl;
        }

        @Override
        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
        throws MessagingException
        {

            if (messages == null ||
                    messages.length == 0)
            {
                return;
            }

            /**
             * Fetch message envelope information for the array
             */
            if (fp.contains(FetchProfile.Item.ENVELOPE))
            {
                fetchEnvelope(messages, listener);
            }
            /**
             * Fetch message flag info for the array
             */
            if (fp.contains(FetchProfile.Item.FLAGS))
            {
                fetchFlags(messages, listener);
            }



            if (fp.contains(FetchProfile.Item.BODY_SANE))
            {
                fetchMessages(messages, listener, FETCH_BODY_SANE_SUGGESTED_SIZE / 76);
            }

            if (fp.contains(FetchProfile.Item.BODY))
            {
                fetchMessages(messages, listener, -1);
            }

//            if (fp.contains(FetchProfile.Item.STRUCTURE)) {
//                for (int i = 0, count = messages.length; i < count; i++) {
//                    if (!(messages[i] instanceof WebDavMessage)) {
//                        throw new MessagingException(""WebDavStore fetch called with non-WebDavMessage"");
//                    }
//                    WebDavMessage wdMessage = (WebDavMessage) messages[i];
//
//                    if (listener != null) {
//                        listener.messageStarted(wdMessage.getUid(), i, count);
//                    }
//
//                    wdMessage.setBody(null);
//
//                    if (listener != null) {
//                        listener.messageFinished(wdMessage, i, count);
//                    }
//                }
//            }
        }

        /**
         * Fetches the full messages or up to lines lines and passes them to the message parser.
         */
        private void fetchMessages(Message[] messages, MessageRetrievalListener listener, int lines) throws MessagingException
        {
            WebDavHttpClient httpclient;
            httpclient = getHttpClient();

            /**
             * We can't hand off to processRequest() since we need the stream to parse.
             */
            for (int i = 0, count = messages.length; i < count; i++)
            {
                WebDavMessage wdMessage;
                int statusCode = 0;

                if (!(messages[i] instanceof WebDavMessage))
                {
                    throw new MessagingException(""WebDavStore fetch called with non-WebDavMessage"");
                }

                wdMessage = (WebDavMessage) messages[i];

                if (listener != null)
                {
                    listener.messageStarted(wdMessage.getUid(), i, count);
                }

                /**
                 * If fetch is called outside of the initial list (ie, a locally stored
                 * message), it may not have a URL associated.  Verify and fix that
                 */
                if (wdMessage.getUrl().equals(""""))
                {
                    wdMessage.setUrl(getMessageUrls(new String[] {wdMessage.getUid()}).get(wdMessage.getUid()));
                    Log.i(K9.LOG_TAG, ""Fetching messages with UID = '"" + wdMessage.getUid() + ""', URL = '"" + wdMessage.getUrl() + ""'"");
                    if (wdMessage.getUrl().equals(""""))
                    {
                        throw new MessagingException(""Unable to get URL for message"");
                    }
                }

                try
                {
                    Log.i(K9.LOG_TAG, ""Fetching message with UID = '"" + wdMessage.getUid() + ""', URL = '"" + wdMessage.getUrl() + ""'"");
                    HttpGet httpget = new HttpGet(new URI(wdMessage.getUrl()));
                    HttpResponse response;
                    HttpEntity entity;

                    httpget.setHeader(""translate"", ""f"");
                    if (mAuthString != null && mAuthenticated)
                    {
                        httpget.setHeader(""Authorization"", mAuthString);
                    }
                    response = httpclient.executeOverride(httpget);

                    statusCode = response.getStatusLine().getStatusCode();

                    entity = response.getEntity();

                    if (statusCode < 200 ||
                            statusCode > 300)
                    {
                        throw new IOException(""Error during with code "" + statusCode + "" during fetch: ""
                                + response.getStatusLine().toString());
                    }

                    if (entity != null)
                    {
                        InputStream istream = null;
                        StringBuffer buffer = new StringBuffer();
                        String tempText = """";
                        String resultText = """";
                        BufferedReader reader;
                        int currentLines = 0;

                        istream = WebDavHttpClient.getUngzippedContent(entity);

                        if (lines != -1)
                        {
                            reader = new BufferedReader(new InputStreamReader(istream), 8192);

                            while ((tempText = reader.readLine()) != null &&
                                    (currentLines < lines))
                            {
                                buffer.append(tempText+""\r\n"");
                                currentLines++;
                            }

                            istream.close();
                            resultText = buffer.toString();
                            istream = new ByteArrayInputStream(resultText.getBytes(""UTF-8""));
                        }

                        wdMessage.parse(istream);
                    }

                }
                catch (IllegalArgumentException iae)
                {
                    Log.e(K9.LOG_TAG, ""IllegalArgumentException caught "" + iae + ""\nTrace: "" + processException(iae));
                    throw new MessagingException(""IllegalArgumentException caught"", iae);
                }
                catch (URISyntaxException use)
                {
                    Log.e(K9.LOG_TAG, ""URISyntaxException caught "" + use + ""\nTrace: "" + processException(use));
                    throw new MessagingException(""URISyntaxException caught"", use);
                }
                catch (IOException ioe)
                {
                    Log.e(K9.LOG_TAG, ""Non-success response code loading message, response code was "" + statusCode + ""\nURL: "" + wdMessage.getUrl() + ""\nError: "" + ioe.getMessage() + ""\nTrace: "" + processException(ioe));
                    throw new MessagingException(""Failure code "" + statusCode, ioe);
                }

                if (listener != null)
                {
                    listener.messageFinished(wdMessage, i, count);
                }
            }
        }

        /**
         * Fetches and sets the message flags for the supplied messages.
         * The idea is to have this be recursive so that we do a series of medium calls
         * instead of one large massive call or a large number of smaller calls.
         */
        private void fetchFlags(Message[] startMessages, MessageRetrievalListener listener) throws MessagingException
        {
            HashMap<String, Boolean> uidToReadStatus = new HashMap<String, Boolean>();
            HashMap<String, String> headers = new HashMap<String, String>();
            DataSet dataset = new DataSet();
            String messageBody = """";
            Message[] messages = new Message[20];
            String[] uids;


            if (startMessages == null ||
                    startMessages.length == 0)
            {
                return;
            }

            if (startMessages.length > 20)
            {
                Message[] newMessages = new Message[startMessages.length - 20];
                for (int i = 0, count = startMessages.length; i < count; i++)
                {
                    if (i < 20)
                    {
                        messages[i] = startMessages[i];
                    }
                    else
                    {
                        newMessages[i - 20] = startMessages[i];
                    }
                }

                fetchFlags(newMessages, listener);
            }
            else
            {
                messages = startMessages;
            }

            uids = new String[messages.length];

            for (int i = 0, count = messages.length; i < count; i++)
            {
                uids[i] = messages[i].getUid();
            }

            messageBody = getMessageFlagsXml(uids);
            headers.put(""Brief"", ""t"");
            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);

            if (dataset == null)
            {
                throw new MessagingException(""Data Set from request was null"");
            }

            uidToReadStatus = dataset.getUidToRead();

            for (int i = 0, count = messages.length; i < count; i++)
            {
                if (!(messages[i] instanceof WebDavMessage))
                {
                    throw new MessagingException(""WebDavStore fetch called with non-WebDavMessage"");
                }
                WebDavMessage wdMessage = (WebDavMessage) messages[i];

                if (listener != null)
                {
                    listener.messageStarted(messages[i].getUid(), i, count);
                }

                wdMessage.setFlagInternal(Flag.SEEN, uidToReadStatus.get(wdMessage.getUid()));

                if (listener != null)
                {
                    listener.messageFinished(messages[i], i, count);
                }
            }
        }

        /**
         * Fetches and parses the message envelopes for the supplied messages.
         * The idea is to have this be recursive so that we do a series of medium calls
         * instead of one large massive call or a large number of smaller calls.
         * Call it a happy balance
         */
        private void fetchEnvelope(Message[] startMessages, MessageRetrievalListener listener) throws MessagingException
        {
            HashMap<String, ParsedMessageEnvelope> envelopes = new HashMap<String, ParsedMessageEnvelope>();
            HashMap<String, String> headers = new HashMap<String, String>();
            DataSet dataset = new DataSet();
            String messageBody = """";
            String[] uids;
            Message[] messages = new Message[10];

            if (startMessages == null ||
                    startMessages.length == 0)
            {
                return;
            }

            if (startMessages.length > 10)
            {
                Message[] newMessages = new Message[startMessages.length - 10];
                for (int i = 0, count = startMessages.length; i < count; i++)
                {
                    if (i < 10)
                    {
                        messages[i] = startMessages[i];
                    }
                    else
                    {
                        newMessages[i - 10] = startMessages[i];
                    }
                }

                fetchEnvelope(newMessages, listener);
            }
            else
            {
                messages = startMessages;
            }

            uids = new String[messages.length];

            for (int i = 0, count = messages.length; i < count; i++)
            {
                uids[i] = messages[i].getUid();
            }

            messageBody = getMessageEnvelopeXml(uids);
            headers.put(""Brief"", ""t"");
            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);

            envelopes = dataset.getMessageEnvelopes();

            int count = messages.length;
            for (int i = messages.length - 1; i >= 0; i--)
            {
                if (!(messages[i] instanceof WebDavMessage))
                {
                    throw new MessagingException(""WebDavStore fetch called with non-WebDavMessage"");
                }
                WebDavMessage wdMessage = (WebDavMessage) messages[i];

                if (listener != null)
                {
                    listener.messageStarted(messages[i].getUid(), i, count);
                }

                wdMessage.setNewHeaders(envelopes.get(wdMessage.getUid()));
                wdMessage.setFlagInternal(Flag.SEEN, envelopes.get(wdMessage.getUid()).getReadStatus());

                if (listener != null)
                {
                    listener.messageFinished(messages[i], i, count);
                }
            }
        }

        @Override
        public Flag[] getPermanentFlags() throws MessagingException
        {
            return PERMANENT_FLAGS;
        }

        @Override
        public void setFlags(Message[] messages, Flag[] flags, boolean value)
        throws MessagingException
        {
            String[] uids = new String[messages.length];

            for (int i = 0, count = messages.length; i < count; i++)
            {
                uids[i] = messages[i].getUid();
            }

            for (int i = 0, count = flags.length; i < count; i++)
            {
                Flag flag = flags[i];

                if (flag == Flag.SEEN)
                {
                    markServerMessagesRead(uids, value);
                }
                else if (flag == Flag.DELETED)
                {
                    deleteServerMessages(uids);
                }
            }
        }

        private void markServerMessagesRead(String[] uids, boolean read) throws MessagingException
        {
            String messageBody = """";
            HashMap<String, String> headers = new HashMap<String, String>();
            HashMap<String, String> uidToUrl = getMessageUrls(uids);
            DataSet dataset = new DataSet();
            String[] urls = new String[uids.length];

            for (int i = 0, count = uids.length; i < count; i++)
            {
                urls[i] = uidToUrl.get(uids[i]);
            }

            messageBody = getMarkMessagesReadXml(urls, read);
            headers.put(""Brief"", ""t"");
            headers.put(""If-Match"", ""*"");

            processRequest(this.mFolderUrl, ""BPROPPATCH"", messageBody, headers, false);
        }

        private void deleteServerMessages(String[] uids) throws MessagingException
        {
            HashMap<String, String> uidToUrl = getMessageUrls(uids);
            String[] urls = new String[uids.length];

            for (int i = 0, count = uids.length; i < count; i++)
            {
                HashMap<String, String> headers = new HashMap<String, String>();
                String uid = uids[i];
                String url = uidToUrl.get(uid);
                String destinationUrl = generateDeleteUrl(url);

                /**
                 * If the destination is the same as the origin, assume delete forever
                 */
                if (destinationUrl.equals(url))
                {
                    headers.put(""Brief"", ""t"");
                    processRequest(url, ""DELETE"", null, headers, false);
                }
                else
                {
                    headers.put(""Destination"", generateDeleteUrl(url));
                    headers.put(""Brief"", ""t"");
                    processRequest(url, ""MOVE"", null, headers, false);
                }
            }
        }

        private String generateDeleteUrl(String startUrl)
        {
            String[] urlParts = startUrl.split(""/"");
            String filename = urlParts[urlParts.length - 1];
            String finalUrl = WebDavStore.this.mUrl + ""Deleted%20Items/"" + filename;

            return finalUrl;
        }

        @Override
        public void appendMessages(Message[] messages) throws MessagingException
        {
            appendWebDavMessages(messages);
        }

        public Message[] appendWebDavMessages(Message[] messages) throws MessagingException
        {

            Message[] retMessages = new Message[messages.length];
            int ind = 0;

            WebDavHttpClient httpclient = getHttpClient();

            for (Message message : messages)
            {
                HttpGeneric httpmethod;
                HttpResponse response;
                StringEntity bodyEntity;
                int statusCode;

                try
                {
                    String subject;

                    try
                    {
                        subject = message.getSubject();
                    }
                    catch (MessagingException e)
                    {
                        Log.e(K9.LOG_TAG, ""MessagingException while retrieving Subject: "" + e);
                        subject = """";
                    }
                    ByteArrayOutputStream out;
                    try
                    {
                        out = new ByteArrayOutputStream(message.getSize());
                    }
                    catch (MessagingException e)
                    {
                        Log.e(K9.LOG_TAG, ""MessagingException while getting size of message: "" + e);
                        out = new ByteArrayOutputStream();
                    }
                    open(OpenMode.READ_WRITE);
                    EOLConvertingOutputStream msgOut = new EOLConvertingOutputStream(
                            new BufferedOutputStream(out, 1024));
                    message.writeTo(msgOut);
                    msgOut.flush();

                    bodyEntity = new StringEntity(out.toString(), ""UTF-8"");
                    bodyEntity.setContentType(""message/rfc822"");

                    String messageURL = mFolderUrl;
                    if (messageURL.endsWith(""/"") == false)
                    {
                        messageURL += ""/"";
                    }
                    messageURL += URLEncoder.encode(message.getUid() + "":"" + System.currentTimeMillis() + "".eml"");

                    Log.i(K9.LOG_TAG, ""Uploading message as "" + messageURL);

                    httpmethod = new HttpGeneric(messageURL);
                    httpmethod.setMethod(""PUT"");
                    httpmethod.setEntity(bodyEntity);

                    String mAuthString = getAuthString();

                    if (mAuthString != null)
                    {
                        httpmethod.setHeader(""Authorization"", mAuthString);
                    }

                    response = httpclient.executeOverride(httpmethod);
                    statusCode = response.getStatusLine().getStatusCode();

                    if (statusCode < 200 ||
                            statusCode > 300)
                    {
                        throw new IOException(""Error with status code "" + statusCode 
                                + "" while sending/appending message.  Response = ""
                                + response.getStatusLine().toString() + "" for message "" + messageURL);
                    }
                    WebDavMessage retMessage = new WebDavMessage(message.getUid(), this);

                    retMessage.setUrl(messageURL);
                    retMessages[ind++] = retMessage;
                }
                catch (Exception e)
                {
                    throw new MessagingException(""Unable to append"", e);
                }

            }
            return retMessages;
        }

        @Override
        public boolean equals(Object o)
        {
            return false;
        }

        public String getUidFromMessageId(Message message) throws MessagingException
        {
            Log.e(K9.LOG_TAG, ""Unimplemented method getUidFromMessageId in WebDavStore.WebDavFolder could lead to duplicate messages ""
                  + "" being uploaded to the Sent folder"");
            return null;
        }

        public void setFlags(Flag[] flags, boolean value) throws MessagingException
        {
            Log.e(K9.LOG_TAG, ""Unimplemented method setFlags(Flag[], boolean) breaks markAllMessagesAsRead and EmptyTrash"");
            // Try to make this efficient by not retrieving all of the messages
            return;
        }
    }

    /**
     * A WebDav Message
     */
    class WebDavMessage extends MimeMessage
    {
        private String mUrl = """";


        WebDavMessage(String uid, Folder folder) throws MessagingException
        {
            this.mUid = uid;
            this.mFolder = folder;
        }

        public void setUrl(String url)
        {
            //TODO: This is a not as ugly hack (ie, it will actually work)
            //XXX: prevent URLs from getting to us that are broken
            if (!(url.toLowerCase().contains(""http"")))
            {
                if (!(url.startsWith(""/"")))
                {
                    url = ""/"" + url;
                }
                url = WebDavStore.this.mUrl + this.mFolder + url;
            }

            String[] urlParts = url.split(""/"");
            int length = urlParts.length;
            String end = urlParts[length - 1];

            this.mUrl = """";
            url = """";

            /**
             * We have to decode, then encode the URL because Exchange likes to
             * not properly encode all characters
             */
            try
            {
                end = java.net.URLDecoder.decode(end, ""UTF-8"");
                end = java.net.URLEncoder.encode(end, ""UTF-8"");
                end = end.replaceAll(""\\+"", ""%20"");
            }
            catch (UnsupportedEncodingException uee)
            {
                Log.e(K9.LOG_TAG, ""UnsupportedEncodingException caught in setUrl: "" + uee + ""\nTrace: "" + processException(uee));
            }
            catch (IllegalArgumentException iae)
            {
                Log.e(K9.LOG_TAG, ""IllegalArgumentException caught in setUrl: "" + iae + ""\nTrace: "" + processException(iae));
            }

            for (int i = 0; i < length - 1; i++)
            {
                if (i != 0)
                {
                    url = url + ""/"" + urlParts[i];
                }
                else
                {
                    url = urlParts[i];
                }
            }

            url = url + ""/"" + end;

            this.mUrl = url;
        }

        public String getUrl()
        {
            return this.mUrl;
        }

        public void setSize(int size)
        {
            this.mSize = size;
        }

        public void parse(InputStream in) throws IOException, MessagingException
        {
            super.parse(in);
        }

        public void setFlagInternal(Flag flag, boolean set) throws MessagingException
        {
            super.setFlag(flag, set);
        }

        public void setNewHeaders(ParsedMessageEnvelope envelope) throws MessagingException
        {
            String[] headers = envelope.getHeaderList();
            HashMap<String, String> messageHeaders = envelope.getMessageHeaders();

            for (int i = 0, count = headers.length; i < count; i++)
            {
                String headerValue = messageHeaders.get(headers[i]);
                if (headers[i].equals(""Content-Length""))
                {
                    int size = Integer.parseInt(messageHeaders.get(headers[i]));
                    this.setSize(size);
                }

                if (headerValue != null &&
                        !headerValue.equals(""""))
                {
                    this.addHeader(headers[i], headerValue);
                }
            }
        }


        @Override
        public void delete(String trashFolderName) throws MessagingException
        {
            WebDavFolder wdFolder = (WebDavFolder)getFolder();
            Log.i(K9.LOG_TAG, ""Deleting message by moving to "" + trashFolderName);
            wdFolder.moveMessages(new Message[] { this }, wdFolder.getStore().getFolder(trashFolderName));

        }

        @Override
        public void setFlag(Flag flag, boolean set) throws MessagingException
        {
            super.setFlag(flag, set);
            mFolder.setFlags(new Message[] { this }, new Flag[] { flag }, set);
        }
    }

    /**
     * XML Parsing Handler
     * Can handle all XML handling needs
     */
    public class WebDavHandler extends DefaultHandler
    {
        private DataSet mDataSet = new DataSet();
        private Stack<String> mOpenTags = new Stack<String>();

        public DataSet getDataSet()
        {
            return this.mDataSet;
        }

        @Override
        public void startDocument() throws SAXException
        {
            this.mDataSet = new DataSet();
        }

        @Override
        public void endDocument() throws SAXException
        {
            /* Do nothing */
        }

        @Override
        public void startElement(String namespaceURI, String localName,
                                 String qName, Attributes atts) throws SAXException
        {
            mOpenTags.push(localName);
        }

        @Override
        public void endElement(String namespaceURI, String localName, String qName)
        {
            mOpenTags.pop();

            /** Reset the hash temp variables */
            if (localName.equals(""response""))
            {
                this.mDataSet.finish();
            }
        }

        @Override
        public void characters(char ch[], int start, int length)
        {
            String value = new String(ch, start, length);
            mDataSet.addValue(value, mOpenTags.peek());
        }
    }

    /**
     * Data set for a single E-Mail message's required headers (the envelope)
     * Only provides accessor methods to the stored data.  All processing should be
     * done elsewhere.  This is done rather than having multiple hashmaps
     * associating UIDs to values
     */
    public class ParsedMessageEnvelope
    {
        /**
         * Holds the mappings from the name returned from Exchange to the MIME format header name
         */
        private final HashMap<String, String> mHeaderMappings = new HashMap<String, String>()
        {
            {
                put(""mime-version"", ""MIME-Version"");
                put(""content-type"", ""Content-Type"");
                put(""subject"", ""Subject"");
                put(""date"", ""Date"");
                put(""thread-topic"", ""Thread-Topic"");
                put(""thread-index"", ""Thread-Index"");
                put(""from"", ""From"");
                put(""to"", ""To"");
                put(""in-reply-to"", ""In-Reply-To"");
                put(""cc"", ""Cc"");
                put(""getcontentlength"", ""Content-Length"");
            }
        };

        private boolean mReadStatus = false;
        private String mUid = """";
        private HashMap<String, String> mMessageHeaders = new HashMap<String, String>();
        private ArrayList<String> mHeaders = new ArrayList<String>();

        public void addHeader(String field, String value)
        {
            String headerName = mHeaderMappings.get(field);
            //Log.i(K9.LOG_TAG, ""header "" + headerName + "" = '"" + value + ""'"");

            if (headerName != null)
            {
                this.mMessageHeaders.put(mHeaderMappings.get(field), value);
                this.mHeaders.add(mHeaderMappings.get(field));
            }
        }

        public HashMap<String, String> getMessageHeaders()
        {
            return this.mMessageHeaders;
        }

        public String[] getHeaderList()
        {
            return this.mHeaders.toArray(new String[] {});
        }

        public void setReadStatus(boolean status)
        {
            this.mReadStatus = status;
        }

        public boolean getReadStatus()
        {
            return this.mReadStatus;
        }

        public void setUid(String uid)
        {
            if (uid != null)
            {
                this.mUid = uid;
            }
        }

        public String getUid()
        {
            return this.mUid;
        }
    }

    /**
     * Dataset for all XML parses.
     * Data is stored in a single format inside the class and is formatted appropriately depending on the accessor calls made.
     */
    public class DataSet
    {
        private HashMap<String, HashMap> mData = new HashMap<String, HashMap>();
        private HashMap<String, String> mLostData = new HashMap<String, String>();
        private String mUid = """";
        private HashMap<String, String> mTempData = new HashMap<String, String>();

        public void addValue(String value, String tagName)
        {
            if (tagName.equals(""uid""))
            {
                mUid = value;
            }

            if (mTempData.containsKey(tagName))
            {
                mTempData.put(tagName, mTempData.get(tagName) + value);
            }
            else
            {
                mTempData.put(tagName, value);
            }
        }

        public void finish()
        {
            if (mUid != null &&
                    mTempData != null)
            {
                mData.put(mUid, mTempData);
            }
            else if (mTempData != null)
            {
                /* Lost Data are for requests that don't include a message UID.
                 * These requests should only have a depth of one for the response so it will never get stomped over.
                 */
                mLostData = mTempData;
                String visibleCount = mLostData.get(""visiblecount"");
            }

            mUid = """";
            mTempData = new HashMap<String, String>();
        }

        /**
         * Returns a hashmap of Message UID => Message Url
         */
        public HashMap<String, String> getUidToUrl()
        {
            HashMap<String, String> uidToUrl = new HashMap<String, String>();

            for (String uid : mData.keySet())
            {
                HashMap<String, String> data = mData.get(uid);
                String value = data.get(""href"");
                if (value != null &&
                        !value.equals(""""))
                {
                    uidToUrl.put(uid, value);
                }
            }

            return uidToUrl;
        }

        /**
         * Returns a hashmap of Message UID => Read Status
         */
        public HashMap<String, Boolean> getUidToRead()
        {
            HashMap<String, Boolean> uidToRead = new HashMap<String, Boolean>();

            for (String uid : mData.keySet())
            {
                HashMap<String, String> data = mData.get(uid);
                String readStatus = data.get(""read"");
                if (readStatus != null &&
                        !readStatus.equals(""""))
                {
                    Boolean value = readStatus.equals(""0"") ? false : true;
                    uidToRead.put(uid, value);
                }
            }

            return uidToRead;
        }

        /**
         * Returns an array of all hrefs (urls) that were received
         */
        public String[] getHrefs()
        {
            ArrayList<String> hrefs = new ArrayList<String>();

            for (String uid : mData.keySet())
            {
                HashMap<String, String> data = mData.get(uid);
                String href = data.get(""href"");
                hrefs.add(href);
            }

            return hrefs.toArray(new String[] {});
        }

        /**
         * Return an array of all Message UIDs that were received
         */
        public String[] getUids()
        {
            ArrayList<String> uids = new ArrayList<String>();

            for (String uid : mData.keySet())
            {
                uids.add(uid);
            }

            return uids.toArray(new String[] {});
        }

        /**
         * Returns the message count as it was retrieved
         */
        public int getMessageCount()
        {
            int messageCount = -1;

            for (String uid : mData.keySet())
            {
                HashMap<String, String> data = mData.get(uid);
                String count = data.get(""visiblecount"");

                if (count != null &&
                        !count.equals(""""))
                {
                    messageCount = Integer.parseInt(count);
                }

            }

            return messageCount;
        }

        /**
         * Returns a HashMap of message UID => ParsedMessageEnvelope
         */
        public HashMap<String, ParsedMessageEnvelope> getMessageEnvelopes()
        {
            HashMap<String, ParsedMessageEnvelope> envelopes = new HashMap<String, ParsedMessageEnvelope>();

            for (String uid : mData.keySet())
            {
                ParsedMessageEnvelope envelope = new ParsedMessageEnvelope();
                HashMap<String, String> data = mData.get(uid);

                if (data != null)
                {
                    for (String header : data.keySet())
                    {
                        if (header.equals(""read""))
                        {
                            String read = data.get(header);
                            Boolean readStatus = read.equals(""0"") ? false : true;

                            envelope.setReadStatus(readStatus);
                        }
                        else if (header.equals(""date""))
                        {
                            /**
                             * Exchange doesn't give us rfc822 dates like it claims.  The date is in the format:
                             * yyyy-MM-dd'T'HH:mm:ss.SSS<Single digit representation of timezone, so far, all instances are Z>
                             */
                            String date = data.get(header);
                            date = date.substring(0, date.length() - 1);

                            DateFormat dfInput = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS"");
                            DateFormat dfOutput = new SimpleDateFormat(""EEE, d MMM yy HH:mm:ss Z"");
                            String tempDate = """";

                            try
                            {
                                Date parsedDate = dfInput.parse(date);
                                tempDate = dfOutput.format(parsedDate);
                            }
                            catch (java.text.ParseException pe)
                            {
                                Log.e(K9.LOG_TAG, ""Error parsing date: ""+ pe + ""\nTrace: "" + processException(pe));
                            }
                            envelope.addHeader(header, tempDate);
                        }
                        else
                        {
                            envelope.addHeader(header, data.get(header));
                        }
                    }
                }

                if (envelope != null)
                {
                    envelopes.put(uid, envelope);
                }
            }

            return envelopes;
        }
    }

    /**
     * New HTTP Method that allows changing of the method and generic handling
     * Needed for WebDAV custom methods such as SEARCH and PROPFIND
     */
    public class HttpGeneric extends HttpEntityEnclosingRequestBase
    {
        public String METHOD_NAME = ""POST"";

        public HttpGeneric()
        {
            super();
        }

        public HttpGeneric(final URI uri)
        {
            super();
            setURI(uri);
        }

        /**
         * @throws IllegalArgumentException if the uri is invalid.
         */
        public HttpGeneric(final String uri)
        {
            super();

            if (K9.DEBUG)
            {
                Log.v(K9.LOG_TAG, ""Starting uri = '"" + uri + ""'"");
            }

            String[] urlParts = uri.split(""/"");
            int length = urlParts.length;
            String end = urlParts[length - 1];
            String url = """";

            /**
             * We have to decode, then encode the URL because Exchange likes to
             * not properly encode all characters
             */
            try
            {
                if (length > 3)
                {
                    end = java.net.URLDecoder.decode(end, ""UTF-8"");
                    end = java.net.URLEncoder.encode(end, ""UTF-8"");
                    end = end.replaceAll(""\\+"", ""%20"");
                }
            }
            catch (UnsupportedEncodingException uee)
            {
                Log.e(K9.LOG_TAG, ""UnsupportedEncodingException caught in HttpGeneric(String uri): "" + uee + ""\nTrace: "" + processException(uee));
            }
            catch (IllegalArgumentException iae)
            {
                Log.e(K9.LOG_TAG, ""IllegalArgumentException caught in HttpGeneric(String uri): "" + iae + ""\nTrace: "" + processException(iae));
            }

            for (int i = 0; i < length - 1; i++)
            {
                if (i != 0)
                {
                    url = url + ""/"" + urlParts[i];
                }
                else
                {
                    url = urlParts[i];
                }
            }
            if (K9.DEBUG)
            {
                Log.v(K9.LOG_TAG, ""url = '"" + url + ""' length = "" + url.length()
                      + "", end = '"" + end + ""' length = "" + end.length());
            }
            url = url + ""/"" + end;

            Log.i(K9.LOG_TAG, ""url = "" + url);
            setURI(URI.create(url));
        }

        @Override
        public String getMethod()
        {
            return METHOD_NAME;
        }

        public void setMethod(String method)
        {
            if (method != null)
            {
                METHOD_NAME = method;
            }
        }
    }
    public static class WebDavHttpClient extends DefaultHttpClient
    {
        /*
        * Copyright (C) 2007 The Android Open Source Project
        *
        * Licensed under the Apache License, Version 2.0 (the ""License"");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an ""AS IS"" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        public static void modifyRequestToAcceptGzipResponse(HttpRequest request)
        {
            Log.i(K9.LOG_TAG, ""Requesting gzipped data"");
            request.addHeader(""Accept-Encoding"", ""gzip"");
        }
        public static InputStream getUngzippedContent(HttpEntity entity)
        throws IOException
        {
            InputStream responseStream = entity.getContent();
            if (responseStream == null) return responseStream;
            Header header = entity.getContentEncoding();
            if (header == null) return responseStream;
            String contentEncoding = header.getValue();
            if (contentEncoding == null) return responseStream;
            if (contentEncoding.contains(""gzip""))
            {
                Log.i(K9.LOG_TAG, ""Response is gzipped"");
                responseStream = new GZIPInputStream(responseStream);
            }
            return responseStream;
        }


        public HttpResponse executeOverride(HttpUriRequest request) throws IOException
        {
            modifyRequestToAcceptGzipResponse(request);
            return super.execute(request);
        }

    }
}
",True,189,0,0,7,48,2,15,L1
95,com.fsck.k9.mail.store.Pop3Store.java,"
package com.fsck.k9.mail.store;

import android.util.Config;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.Utility;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Folder.OpenMode;
import com.fsck.k9.mail.internet.MimeMessage;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.TrustManager;
import java.io.*;
import java.net.*;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class Pop3Store extends Store
{
    public static final int CONNECTION_SECURITY_NONE = 0;
    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED };

    private String mHost;
    private int mPort;
    private String mUsername;
    private String mPassword;
    private int mConnectionSecurity;
    private HashMap<String, Folder> mFolders = new HashMap<String, Folder>();
    private Pop3Capabilities mCapabilities;

//    /**
//     * Detected latency, used for usage scaling.
//     * Usage scaling occurs when it is neccesary to get information about
//     * messages that could result in large data loads. This value allows
//     * the code that loads this data to decide between using large downloads
//     * (high latency) or multiple round trips (low latency) to accomplish
//     * the same thing.
//     * Default is Integer.MAX_VALUE implying massive latency so that the large
//     * download method is used by default until latency data is collected.
//     */
//    private int mLatencyMs = Integer.MAX_VALUE;
//
//    /**
//     * Detected throughput, used for usage scaling.
//     * Usage scaling occurs when it is neccesary to get information about
//     * messages that could result in large data loads. This value allows
//     * the code that loads this data to decide between using large downloads
//     * (high latency) or multiple round trips (low latency) to accomplish
//     * the same thing.
//     * Default is Integer.MAX_VALUE implying massive bandwidth so that the
//     * large download method is used by default until latency data is
//     * collected.
//     */
//    private int mThroughputKbS = Integer.MAX_VALUE;

    /**
     * pop3://user:password@server:port CONNECTION_SECURITY_NONE
     * pop3+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * pop3+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * pop3+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * pop3+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     */
    public Pop3Store(Account account) throws MessagingException
    {
        super(account);

        URI uri;
        try
        {
            uri = new URI(mAccount.getStoreUri());
        }
        catch (URISyntaxException use)
        {
            throw new MessagingException(""Invalid Pop3Store URI"", use);
        }

        String scheme = uri.getScheme();
        if (scheme.equals(""pop3""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_NONE;
            mPort = 110;
        }
        else if (scheme.equals(""pop3+tls""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
            mPort = 110;
        }
        else if (scheme.equals(""pop3+tls+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
            mPort = 110;
        }
        else if (scheme.equals(""pop3+ssl+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
            mPort = 995;
        }
        else if (scheme.equals(""pop3+ssl""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
            mPort = 995;
        }
        else
        {
            throw new MessagingException(""Unsupported protocol"");
        }

        mHost = uri.getHost();

        if (uri.getPort() != -1)
        {
            mPort = uri.getPort();
        }

        if (uri.getUserInfo() != null)
        {
            try
            {
                String[] userInfoParts = uri.getUserInfo().split("":"");
                mUsername = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                if (userInfoParts.length > 1)
                {
                    mPassword = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
            }
            catch (UnsupportedEncodingException enc)
            {
                // This shouldn't happen since the encoding is hardcoded to UTF-8
                Log.e(K9.LOG_TAG, ""Couldn't urldecode username or password."", enc);
            }
        }
    }

    @Override
    public Folder getFolder(String name) throws MessagingException
    {
        Folder folder = mFolders.get(name);
        if (folder == null)
        {
            folder = new Pop3Folder(name);
            mFolders.put(folder.getName(), folder);
        }
        return folder;
    }

    @Override
    public Folder[] getPersonalNamespaces() throws MessagingException
    {
        return new Folder[]
               {
                   getFolder(""INBOX""),
               };
    }

    @Override
    public void checkSettings() throws MessagingException
    {
        Pop3Folder folder = new Pop3Folder(""INBOX"");
        folder.open(OpenMode.READ_WRITE);
        if (!mCapabilities.uidl)
        {
            /*
             * Run an additional test to see if UIDL is supported on the server. If it's not we
             * can't service this account.
             */

            /*
             * If the server doesn't support UIDL it will return a - response, which causes
             * executeSimpleCommand to throw a MessagingException, exiting this method.
             */
            folder.executeSimpleCommand(""UIDL"");

        }
        folder.close();
    }

    class Pop3Folder extends Folder
    {
        private Socket mSocket;
        private InputStream mIn;
        private OutputStream mOut;
        private HashMap<String, Pop3Message> mUidToMsgMap = new HashMap<String, Pop3Message>();
        private HashMap<Integer, Pop3Message> mMsgNumToMsgMap = new HashMap<Integer, Pop3Message>();
        private HashMap<String, Integer> mUidToMsgNumMap = new HashMap<String, Integer>();
        private String mName;
        private int mMessageCount;

        public Pop3Folder(String name)
        {
            super(Pop3Store.this.mAccount);
            this.mName = name;
            if (mName.equalsIgnoreCase(""INBOX""))
            {
                mName = ""INBOX"";
            }
        }

        @Override
        public synchronized void open(OpenMode mode) throws MessagingException
        {
            if (isOpen())
            {
                return;
            }

            if (!mName.equalsIgnoreCase(""INBOX""))
            {
                throw new MessagingException(""Folder does not exist"");
            }

            try
            {
                SocketAddress socketAddress = new InetSocketAddress(mHost, mPort);
                if (mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
                        mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL)
                {
                    SSLContext sslContext = SSLContext.getInstance(""TLS"");
                    final boolean secure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
                    sslContext.init(null, new TrustManager[]
                                    {
                                        TrustManagerFactory.get(mHost, secure)
                                    }, new SecureRandom());
                    mSocket = sslContext.getSocketFactory().createSocket();
                    mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                    mIn = new BufferedInputStream(mSocket.getInputStream(), 1024);
                    mOut = new BufferedOutputStream(mSocket.getOutputStream(), 512);
                }
                else
                {
                    mSocket = new Socket();
                    mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                    mIn = new BufferedInputStream(mSocket.getInputStream(), 1024);
                    mOut = new BufferedOutputStream(mSocket.getOutputStream(), 512);
                }

                mSocket.setSoTimeout(Store.SOCKET_READ_TIMEOUT);
                if (!isOpen())
                {
                    throw new MessagingException(""Unable to connect socket"");
                }

                // Eat the banner
                executeSimpleCommand(null);

                mCapabilities = getCapabilities();

                if (mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL
                        || mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED)
                {
                    if (mCapabilities.stls)
                    {
                        writeLine(""STLS"");

                        SSLContext sslContext = SSLContext.getInstance(""TLS"");
                        boolean secure = mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED;
                        sslContext.init(null, new TrustManager[]
                                        {
                                            TrustManagerFactory.get(mHost, secure)
                                        }, new SecureRandom());
                        mSocket = sslContext.getSocketFactory().createSocket(mSocket, mHost, mPort,
                                  true);
                        mSocket.setSoTimeout(Store.SOCKET_READ_TIMEOUT);
                        mIn = new BufferedInputStream(mSocket.getInputStream(), 1024);
                        mOut = new BufferedOutputStream(mSocket.getOutputStream(), 512);
                        if (!isOpen())
                        {
                            throw new MessagingException(""Unable to connect socket"");
                        }
                    }
                    else if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED)
                    {
                        throw new MessagingException(""TLS not supported but required"");
                    }
                }

                try
                {
                    executeSimpleCommand(""USER "" + mUsername);
                    executeSimpleCommand(""PASS "" + mPassword);
                }
                catch (MessagingException me)
                {
                    throw new AuthenticationFailedException(null, me);
                }
            }
            catch (SSLException e)
            {
                throw new CertificateValidationException(e.getMessage(), e);
            }
            catch (GeneralSecurityException gse)
            {
                throw new MessagingException(
                    ""Unable to open connection to POP server due to security error."", gse);
            }
            catch (IOException ioe)
            {
                throw new MessagingException(""Unable to open connection to POP server."", ioe);
            }

            String response = executeSimpleCommand(""STAT"");
            String[] parts = response.split("" "");
            mMessageCount = Integer.parseInt(parts[1]);

            mUidToMsgMap.clear();
            mMsgNumToMsgMap.clear();
            mUidToMsgNumMap.clear();
        }

        public boolean isOpen()
        {
            return (mIn != null && mOut != null && mSocket != null
                    && mSocket.isConnected() && !mSocket.isClosed());
        }

        @Override
        public OpenMode getMode() throws MessagingException
        {
            return OpenMode.READ_WRITE;
        }

        @Override
        public void close()
        {
            try
            {
                executeSimpleCommand(""QUIT"");
            }
            catch (Exception e)
            {
                /*
                 * QUIT may fail if the connection is already closed. We don't care. It's just
                 * being friendly.
                 */
            }

            closeIO();
        }

        private void closeIO()
        {
            try
            {
                mIn.close();
            }
            catch (Exception e)
            {
                /*
                 * May fail if the connection is already closed.
                 */
            }
            try
            {
                mOut.close();
            }
            catch (Exception e)
            {
                /*
                 * May fail if the connection is already closed.
                 */
            }
            try
            {
                mSocket.close();
            }
            catch (Exception e)
            {
                /*
                 * May fail if the connection is already closed.
                 */
            }
            mIn = null;
            mOut = null;
            mSocket = null;
        }

        @Override
        public String getName()
        {
            return mName;
        }

        @Override
        public boolean create(FolderType type) throws MessagingException
        {
            return false;
        }

        @Override
        public boolean exists() throws MessagingException
        {
            return mName.equalsIgnoreCase(""INBOX"");
        }

        @Override
        public int getMessageCount()
        {
            return mMessageCount;
        }

        @Override
        public int getUnreadMessageCount() throws MessagingException
        {
            return -1;
        }

        @Override
        public Message getMessage(String uid) throws MessagingException
        {
            Pop3Message message = mUidToMsgMap.get(uid);
            if (message == null)
            {
                message = new Pop3Message(uid, this);
            }
            return message;
        }

        @Override
        public Message[] getMessages(int start, int end, MessageRetrievalListener listener)
        throws MessagingException
        {
            if (start < 1 || end < 1 || end < start)
            {
                throw new MessagingException(String.format(""Invalid message set %d %d"",
                                             start, end));
            }
            try
            {
                indexMsgNums(start, end);
            }
            catch (IOException ioe)
            {
                throw new MessagingException(""getMessages"", ioe);
            }
            ArrayList<Message> messages = new ArrayList<Message>();
            int i = 0;
            for (int msgNum = start; msgNum <= end; msgNum++)
            {
                Pop3Message message = mMsgNumToMsgMap.get(msgNum);
                if (listener != null)
                {
                    listener.messageStarted(message.getUid(), i++, (end - start) + 1);
                }
                messages.add(message);
                if (listener != null)
                {
                    listener.messageFinished(message, i++, (end - start) + 1);
                }
            }
            return messages.toArray(new Message[messages.size()]);
        }

        /**
         * Ensures that the given message set (from start to end inclusive)
         * has been queried so that uids are available in the local cache.
         * @param start
         * @param end
         * @throws MessagingException
         * @throws IOException
         */
        private void indexMsgNums(int start, int end)
        throws MessagingException, IOException
        {
            int unindexedMessageCount = 0;
            for (int msgNum = start; msgNum <= end; msgNum++)
            {
                if (mMsgNumToMsgMap.get(msgNum) == null)
                {
                    unindexedMessageCount++;
                }
            }
            if (unindexedMessageCount == 0)
            {
                return;
            }
            if (unindexedMessageCount < 50 && mMessageCount > 5000)
            {
                /*
                 * In extreme cases we'll do a UIDL command per message instead of a bulk
                 * download.
                 */
                for (int msgNum = start; msgNum <= end; msgNum++)
                {
                    Pop3Message message = mMsgNumToMsgMap.get(msgNum);
                    if (message == null)
                    {
                        String response = executeSimpleCommand(""UIDL "" + msgNum);
                        int uidIndex = response.lastIndexOf(' ');
                        String msgUid = response.substring(uidIndex + 1);
                        message = new Pop3Message(msgUid, this);
                        indexMessage(msgNum, message);
                    }
                }
            }
            else
            {
                String response = executeSimpleCommand(""UIDL"");
                while ((response = readLine()) != null)
                {
                    if (response.equals("".""))
                    {
                        break;
                    }
                    String[] uidParts = response.split("" "");
                    if ((uidParts.length >= 3) && ""+OK"".equals(uidParts[0]))
                    {
                        /*
                         * At least one server software places a ""+OK"" in
                         * front of every line in the unique-id listing.
                         * 
                         * Fix up the array if we detected this behavior.
                         * See Issue 1237
                         */ 
                        uidParts[0] = uidParts[1];
                        uidParts[1] = uidParts[2];
                    }
                    if (uidParts.length >= 2)
                    {
                        Integer msgNum = Integer.valueOf(uidParts[0]);
                        String msgUid = uidParts[1];
                        if (msgNum >= start && msgNum <= end)
                        {
                            Pop3Message message = mMsgNumToMsgMap.get(msgNum);
                            if (message == null)
                            {
                                message = new Pop3Message(msgUid, this);
                                indexMessage(msgNum, message);
                            }
                        }
                    }
                }
            }
        }

        private void indexUids(ArrayList<String> uids)
        throws MessagingException, IOException
        {
            HashSet<String> unindexedUids = new HashSet<String>();
            for (String uid : uids)
            {
                if (mUidToMsgMap.get(uid) == null)
                {
                    if (Config.LOGD)
                    {
                        Log.d(K9.LOG_TAG, ""Need to index UID "" + uid);
                    }
                    unindexedUids.add(uid);
                }
            }
            if (unindexedUids.size() == 0)
            {
                return;
            }
            /*
             * If we are missing uids in the cache the only sure way to
             * get them is to do a full UIDL list. A possible optimization
             * would be trying UIDL for the latest X messages and praying.
             */
            String response = executeSimpleCommand(""UIDL"");
            while ((response = readLine()) != null)
            {
                if (response.equals("".""))
                {
                    break;
                }
                String[] uidParts = response.split("" "");
                Integer msgNum = Integer.valueOf(uidParts[0]);
                String msgUid = uidParts[1];
                if (unindexedUids.contains(msgUid))
                {
                    if (Config.LOGD)
                    {
                        Log.d(K9.LOG_TAG, ""Got msgNum "" + msgNum + "" for UID "" + msgUid);
                    }

                    Pop3Message message = mUidToMsgMap.get(msgUid);
                    if (message == null)
                    {
                        message = new Pop3Message(msgUid, this);
                    }
                    indexMessage(msgNum, message);
                }
            }
        }

        private void indexMessage(int msgNum, Pop3Message message)
        {
            if (Config.LOGD)
            {
                Log.d(K9.LOG_TAG, ""Adding index for UID "" + message.getUid() + "" to msgNum "" + msgNum);
            }
            mMsgNumToMsgMap.put(msgNum, message);
            mUidToMsgMap.put(message.getUid(), message);
            mUidToMsgNumMap.put(message.getUid(), msgNum);
        }

        @Override
        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException
        {
            throw new UnsupportedOperationException(""Pop3: No getMessages"");
        }

        @Override
        public Message[] getMessages(String[] uids, MessageRetrievalListener listener)
        throws MessagingException
        {
            throw new UnsupportedOperationException(""Pop3: No getMessages by uids"");
        }

        /**
         * Fetch the items contained in the FetchProfile into the given set of
         * Messages in as efficient a manner as possible.
         * @param messages
         * @param fp
         * @throws MessagingException
         */
        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
        throws MessagingException
        {
            if (messages == null || messages.length == 0)
            {
                return;
            }
            ArrayList<String> uids = new ArrayList<String>();
            for (Message message : messages)
            {
                uids.add(message.getUid());
            }
            try
            {
                indexUids(uids);
            }
            catch (IOException ioe)
            {
                throw new MessagingException(""fetch"", ioe);
            }
            try
            {
                if (fp.contains(FetchProfile.Item.ENVELOPE))
                {
                    /*
                     * We pass the listener only if there are other things to do in the
                     * FetchProfile. Since fetchEnvelop works in bulk and eveything else
                     * works one at a time if we let fetchEnvelope send events the
                     * event would get sent twice.
                     */
                    fetchEnvelope(messages, fp.size() == 1 ? listener : null);
                }
            }
            catch (IOException ioe)
            {
                throw new MessagingException(""fetch"", ioe);
            }
            for (int i = 0, count = messages.length; i < count; i++)
            {
                Message message = messages[i];
                if (!(message instanceof Pop3Message))
                {
                    throw new MessagingException(""Pop3Store.fetch called with non-Pop3 Message"");
                }
                Pop3Message pop3Message = (Pop3Message)message;
                try
                {
                    if (listener != null && !fp.contains(FetchProfile.Item.ENVELOPE))
                    {
                        listener.messageStarted(pop3Message.getUid(), i, count);
                    }
                    if (fp.contains(FetchProfile.Item.BODY))
                    {
                        fetchBody(pop3Message, -1);
                    }
                    else if (fp.contains(FetchProfile.Item.BODY_SANE))
                    {
                        /*
                         * To convert the suggested download size we take the size
                         * divided by the maximum line size (76).
                         */
                        fetchBody(pop3Message,
                                  FETCH_BODY_SANE_SUGGESTED_SIZE / 76);
                    }
                    else if (fp.contains(FetchProfile.Item.STRUCTURE))
                    {
                        /*
                         * If the user is requesting STRUCTURE we are required to set the body
                         * to null since we do not support the function.
                         */
                        pop3Message.setBody(null);
                    }
                    if (listener != null && !(fp.contains(FetchProfile.Item.ENVELOPE) && fp.size() == 1))
                    {
                        listener.messageFinished(message, i, count);
                    }
                }
                catch (IOException ioe)
                {
                    throw new MessagingException(""Unable to fetch message"", ioe);
                }
            }
        }

        private void fetchEnvelope(Message[] messages,
                                   MessageRetrievalListener listener)  throws IOException, MessagingException
        {
            int unsizedMessages = 0;
            for (Message message : messages)
            {
                if (message.getSize() == -1)
                {
                    unsizedMessages++;
                }
            }
            if (unsizedMessages == 0)
            {
                return;
            }
            if (unsizedMessages < 50 && mMessageCount > 5000)
            {
                /*
                 * In extreme cases we'll do a command per message instead of a bulk request
                 * to hopefully save some time and bandwidth.
                 */
                for (int i = 0, count = messages.length; i < count; i++)
                {
                    Message message = messages[i];
                    if (!(message instanceof Pop3Message))
                    {
                        throw new MessagingException(""Pop3Store.fetch called with non-Pop3 Message"");
                    }
                    Pop3Message pop3Message = (Pop3Message)message;
                    if (listener != null)
                    {
                        listener.messageStarted(pop3Message.getUid(), i, count);
                    }
                    String response = executeSimpleCommand(String.format(""LIST %d"",
                                                           mUidToMsgNumMap.get(pop3Message.getUid())));
                    String[] listParts = response.split("" "");
                    int msgNum = Integer.parseInt(listParts[1]);
                    int msgSize = Integer.parseInt(listParts[2]);
                    pop3Message.setSize(msgSize);
                    if (listener != null)
                    {
                        listener.messageFinished(pop3Message, i, count);
                    }
                }
            }
            else
            {
                HashSet<String> msgUidIndex = new HashSet<String>();
                for (Message message : messages)
                {
                    msgUidIndex.add(message.getUid());
                }
                int i = 0, count = messages.length;
                String response = executeSimpleCommand(""LIST"");
                while ((response = readLine()) != null)
                {
                    if (response.equals("".""))
                    {
                        break;
                    }
                    String[] listParts = response.split("" "");
                    int msgNum = Integer.parseInt(listParts[0]);
                    int msgSize = Integer.parseInt(listParts[1]);
                    Pop3Message pop3Message = mMsgNumToMsgMap.get(msgNum);
                    if (pop3Message != null && msgUidIndex.contains(pop3Message.getUid()))
                    {
                        if (listener != null)
                        {
                            listener.messageStarted(pop3Message.getUid(), i, count);
                        }
                        pop3Message.setSize(msgSize);
                        if (listener != null)
                        {
                            listener.messageFinished(pop3Message, i, count);
                        }
                        i++;
                    }
                }
            }
        }

        /**
         * Fetches the body of the given message, limiting the stored data
         * to the specified number of lines. If lines is -1 the entire message
         * is fetched. This is implemented with RETR for lines = -1 or TOP
         * for any other value. If the server does not support TOP it is
         * emulated with RETR and extra lines are thrown away.
         * @param message
         * @param lines
         */
        private void fetchBody(Pop3Message message, int lines)
        throws IOException, MessagingException
        {
            String response = null;
            if (lines == -1 || !mCapabilities.top)
            {
                response = executeSimpleCommand(String.format(""RETR %d"",
                                                mUidToMsgNumMap.get(message.getUid())));
            }
            else
            {
                response = executeSimpleCommand(String.format(""TOP %d %d"",
                                                mUidToMsgNumMap.get(message.getUid()),
                                                lines));
            }
            if (response != null)
            {
                try
                {
                    message.parse(new Pop3ResponseInputStream(mIn));
                    if (lines == -1 || !mCapabilities.top)
                    {
                        message.setFlag(Flag.X_DOWNLOADED_FULL, true);
                    }
                }
                catch (MessagingException me)
                {
                    /*
                     * If we're only downloading headers it's possible
                     * we'll get a broken MIME message which we're not
                     * real worried about. If we've downloaded the body
                     * and can't parse it we need to let the user know.
                     */
                    if (lines == -1)
                    {
                        throw me;
                    }
                }
            }
        }

        @Override
        public Flag[] getPermanentFlags() throws MessagingException
        {
            return PERMANENT_FLAGS;
        }

        public void appendMessages(Message[] messages) throws MessagingException
        {
        }

        public void delete(boolean recurse) throws MessagingException
        {
        }

        public void delete(Message[] msgs, String trashFolderName) throws MessagingException
        {
            setFlags(msgs, new Flag[] { Flag.DELETED }, true);
        }

        @Override
        public String getUidFromMessageId(Message message) throws MessagingException
        {
            return null;
        }

        @Override
        public void setFlags(Flag[] flags, boolean value)
        throws MessagingException
        {
            Message[] messages = getMessages(null);
            setFlags(messages, flags, value);
        }

        public void setFlags(Message[] messages, Flag[] flags, boolean value)
        throws MessagingException
        {
            if (!value || !Utility.arrayContains(flags, Flag.DELETED))
            {
                /*
                 * The only flagging we support is setting the Deleted flag.
                 */
                return;
            }
            ArrayList<String> uids = new ArrayList<String>();
            try
            {
                for (Message message : messages)
                {
                    uids.add(message.getUid());
                }

                indexUids(uids);
            }
            catch (IOException ioe)
            {
                throw new MessagingException(""Could not get message number for uid "" + uids, ioe);
            }
            for (Message message : messages)
            {

                Integer msgNum = mUidToMsgNumMap.get(message.getUid());
                if (msgNum == null)
                {
                    MessagingException me = new MessagingException(""Could not delete message "" + message.getUid()
                            + "" because no msgNum found; permanent error"");
                    me.setPermanentFailure(true);
                    throw me;
                }
                executeSimpleCommand(String.format(""DELE %s"", msgNum));
            }
        }

//        private boolean isRoundTripModeSuggested() {
//            long roundTripMethodMs =
//                (uncachedMessageCount * 2 * mLatencyMs);
//            long bulkMethodMs =
//                    (mMessageCount * 58) / (mThroughputKbS * 1024 / 8) * 1000;
//        }

        private String readLine() throws IOException
        {
            StringBuffer sb = new StringBuffer();
            int d = mIn.read();
            if (d == -1)
            {
                throw new IOException(""End of stream reached while trying to read line."");
            }
            do
            {
                if (((char)d) == '\r')
                {
                    continue;
                }
                else if (((char)d) == '\n')
                {
                    break;
                }
                else
                {
                    sb.append((char)d);
                }
            }
            while ((d = mIn.read()) != -1);
            String ret = sb.toString();
            if (Config.LOGD)
            {
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""<<< "" + ret);
                }
            }
            return ret;
        }

        private void writeLine(String s) throws IOException
        {
            if (Config.LOGD)
            {
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, "">>> "" + s);
                }
            }
            mOut.write(s.getBytes());
            mOut.write('\r');
            mOut.write('\n');
            mOut.flush();
        }

        private Pop3Capabilities getCapabilities() throws IOException, MessagingException
        {
            Pop3Capabilities capabilities = new Pop3Capabilities();
            try
            {
                String response = executeSimpleCommand(""CAPA"");
                while ((response = readLine()) != null)
                {
                    if (response.equals("".""))
                    {
                        break;
                    }
                    if (response.equalsIgnoreCase(""STLS""))
                    {
                        capabilities.stls = true;
                    }
                    else if (response.equalsIgnoreCase(""UIDL""))
                    {
                        capabilities.uidl = true;
                    }
                    else if (response.equalsIgnoreCase(""PIPELINING""))
                    {
                        capabilities.pipelining = true;
                    }
                    else if (response.equalsIgnoreCase(""USER""))
                    {
                        capabilities.user = true;
                    }
                    else if (response.equalsIgnoreCase(""TOP""))
                    {
                        capabilities.top = true;
                    }
                }
            }
            catch (MessagingException me)
            {
                /*
                 * The server may not support the CAPA command, so we just eat this Exception
                 * and allow the empty capabilities object to be returned.
                 */
            }
            return capabilities;
        }

        private String executeSimpleCommand(String command) throws MessagingException
        {
            try
            {
                open(OpenMode.READ_WRITE);
                if (Config.LOGV)
                {
                    Log.v(K9.LOG_TAG, ""POP3: command '"" + command + ""'"");
                }
                if (command != null)
                {
                    writeLine(command);
                }

                String response = readLine();
                if (Config.LOGV)
                {
                    Log.v(K9.LOG_TAG, ""POP3: response '"" + command + ""'"");
                }

                if (response.length() > 1 && response.charAt(0) == '-')
                {
                    throw new MessagingException(response);
                }

                return response;
            }
            catch (MessagingException me)
            {
                throw me;
            }
            catch (Exception e)
            {
                closeIO();
                throw new MessagingException(""Unable to execute POP3 command"", e);
            }
        }

        @Override
        public boolean supportsFetchingFlags()
        {
            return false;
        }//isFlagSupported

        @Override
        public boolean equals(Object o)
        {
            if (o instanceof Pop3Folder)
            {
                return ((Pop3Folder) o).mName.equals(mName);
            }
            return super.equals(o);
        }

    }//Pop3Folder

    class Pop3Message extends MimeMessage
    {
        public Pop3Message(String uid, Pop3Folder folder) throws MessagingException
        {
            mUid = uid;
            mFolder = folder;
            mSize = -1;
            mFlags.add(Flag.X_NO_SEEN_INFO);
        }

        public void setSize(int size)
        {
            mSize = size;
        }

        protected void parse(InputStream in) throws IOException, MessagingException
        {
            super.parse(in);
        }

        @Override
        public void setFlag(Flag flag, boolean set) throws MessagingException
        {
            super.setFlag(flag, set);
            mFolder.setFlags(new Message[] { this }, new Flag[] { flag }, set);
        }

        @Override
        public void delete(String trashFolderName) throws MessagingException
        {
            //  try
            //  {
            //  Poor POP3 users, we can't copy the message to the Trash folder, but they still want a delete
            setFlag(Flag.DELETED, true);
            //   }
//         catch (MessagingException me)
//         {
//          Log.w(K9.LOG_TAG, ""Could not delete non-existant message"", me);
//         }
        }
    }

    class Pop3Capabilities
    {
        public boolean stls;
        public boolean top;
        public boolean user;
        public boolean uidl;
        public boolean pipelining;

        public String toString()
        {
            return String.format(""STLS %b, TOP %b, USER %b, UIDL %b, PIPELINING %b"",
                                 stls,
                                 top,
                                 user,
                                 uidl,
                                 pipelining);
        }
    }

    class Pop3ResponseInputStream extends InputStream
    {
        InputStream mIn;
        boolean mStartOfLine = true;
        boolean mFinished;

        public Pop3ResponseInputStream(InputStream in)
        {
            mIn = in;
        }

        @Override
        public int read() throws IOException
        {
            if (mFinished)
            {
                return -1;
            }
            int d = mIn.read();
            if (mStartOfLine && d == '.')
            {
                d = mIn.read();
                if (d == '\r')
                {
                    mFinished = true;
                    mIn.read();
                    return -1;
                }
            }

            mStartOfLine = (d == '\n');

            return d;
        }
    }
}
",True,189,0,0,7,49,1,15,L1
96,com.fsck.k9.mail.store.ImapResponseParser.java,"/**
 *
 */

package com.fsck.k9.mail.store;

import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.FixedLengthInputStream;
import com.fsck.k9.PeekableInputStream;
import com.fsck.k9.mail.MessagingException;

import java.io.IOException;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Locale;

public class ImapResponseParser
{
    SimpleDateFormat mDateTimeFormat = new SimpleDateFormat(""dd-MMM-yyyy HH:mm:ss Z"", Locale.US);

    SimpleDateFormat badDateTimeFormat = new SimpleDateFormat(""dd MMM yyyy HH:mm:ss Z"", Locale.US);
    SimpleDateFormat badDateTimeFormat2 = new SimpleDateFormat(""E, dd MMM yyyy HH:mm:ss Z"", Locale.US);

    PeekableInputStream mIn;
    InputStream mActiveLiteral;

    public ImapResponseParser(PeekableInputStream in)
    {
        this.mIn = in;
    }

    /**
     * Reads the next response available on the stream and returns an
     * ImapResponse object that represents it.
     *
     * @return
     * @throws IOException
     */
    public ImapResponse readResponse() throws IOException
    {
        ImapResponse response = new ImapResponse();
        if (mActiveLiteral != null)
        {
            while (mActiveLiteral.read() != -1)
                ;
            mActiveLiteral = null;
        }
        int ch = mIn.peek();
        if (ch == '*')
        {
            parseUntaggedResponse();
            readTokens(response);
        }
        else if (ch == '+')
        {
            response.mCommandContinuationRequested =
                parseCommandContinuationRequest();
            readTokens(response);
        }
        else
        {
            response.mTag = parseTaggedResponse();
            readTokens(response);
        }
        if (K9.DEBUG)
        {
            Log.v(K9.LOG_TAG, ""<<< "" + response.toString());
        }
        return response;
    }

    private void readTokens(ImapResponse response) throws IOException
    {
        response.clear();
        Object token;
        while ((token = readToken()) != null)
        {
            if (response != null)
            {
                response.add(token);
            }
            if (mActiveLiteral != null)
            {
                break;
            }
        }
        response.mCompleted = token == null;
    }

    /**
     * Reads the next token of the response. The token can be one of: String -
     * for NIL, QUOTED, NUMBER, ATOM. InputStream - for LITERAL.
     * InputStream.available() returns the total length of the stream.
     * ImapResponseList - for PARENTHESIZED LIST. Can contain any of the above
     * elements including List.
     *
     * @return The next token in the response or null if there are no more
     *         tokens.
     * @throws IOException
     */
    public Object readToken() throws IOException
    {
        while (true)
        {
            Object token = parseToken();
            if (token == null || !token.equals("")"") || !token.equals(""]""))
            {
                return token;
            }
        }
    }

    private Object parseToken() throws IOException
    {
        if (mActiveLiteral != null)
        {
            while (mActiveLiteral.read() != -1)
                ;
            mActiveLiteral = null;
        }
        while (true)
        {
            int ch = mIn.peek();
            if (ch == '(')
            {
                return parseList();
            }
            else if (ch == '[')
            {
                return parseSequence();
            }
            else if (ch == ')')
            {
                expect(')');
                return "")"";
            }
            else if (ch == ']')
            {
                expect(']');
                return ""]"";
            }
            else if (ch == '""')
            {
                return parseQuoted();
            }
            else if (ch == '{')
            {
                mActiveLiteral = parseLiteral();
                return mActiveLiteral;
            }
            else if (ch == ' ')
            {
                expect(' ');
            }
            else if (ch == '\r')
            {
                expect('\r');
                expect('\n');
                return null;
            }
            else if (ch == '\n')
            {
                expect('\n');
                return null;
            }
            else if (ch == '\t')
            {
                expect('\t');
            }
            else
            {
                return parseAtom();
            }
        }
    }

    private boolean parseCommandContinuationRequest() throws IOException
    {
        expect('+');
        expect(' ');
        return true;
    }

    // * OK [UIDNEXT 175] Predicted next UID
    private void parseUntaggedResponse() throws IOException
    {
        expect('*');
        expect(' ');
    }

    // 3 OK [READ-WRITE] Select completed.
    private String parseTaggedResponse() throws IOException
    {
        String tag = readStringUntil(' ');
        return tag;
    }

    private ImapList parseList() throws IOException
    {
        expect('(');
        ImapList list = new ImapList();
        Object token;
        while (true)
        {
            token = parseToken();
            if (token == null)
            {
                break;
            }
            else if (token instanceof InputStream)
            {
                list.add(token);
                break;
            }
            else if (token.equals("")""))
            {
                break;
            }
            else
            {
                list.add(token);
            }
        }
        return list;
    }

    private ImapList parseSequence() throws IOException
    {
        expect('[');
        ImapList list = new ImapList();
        Object token;
        while (true)
        {
            token = parseToken();
            if (token == null)
            {
                break;
            }
            else if (token instanceof InputStream)
            {
                list.add(token);
                break;
            }
            else if (token.equals(""]""))
            {
                break;
            }
            else
            {
                list.add(token);
            }
        }
        return list;
    }

    private String parseAtom() throws IOException
    {
        StringBuffer sb = new StringBuffer();
        int ch;
        while (true)
        {
            ch = mIn.peek();
            if (ch == -1)
            {
                throw new IOException(""parseAtom(): end of stream reached"");
            }
            else if (ch == '(' || ch == ')' || ch == '{' || ch == ' ' ||
                     ch == '[' || ch == ']' ||
                     // docs claim that flags are \ atom but atom isn't supposed to
                     // contain
                     // * and some falgs contain *
                     // ch == '%' || ch == '*' ||
//                    ch == '%' ||
                     // TODO probably should not allow \ and should recognize
                     // it as a flag instead
                     // ch == '""' || ch == '\' ||
                     ch == '""' || (ch >= 0x00 && ch <= 0x1f) || ch == 0x7f)
            {
                if (sb.length() == 0)
                {
                    throw new IOException(String.format(""parseAtom(): (%04x %c)"", (int)ch, ch));
                }
                return sb.toString();
            }
            else
            {
                sb.append((char)mIn.read());
            }
        }
    }

    /**
     * A { has been read, read the rest of the size string, the space and then
     * notify the listener with an InputStream.
     *
     * @param mListener
     * @throws IOException
     */
    private InputStream parseLiteral() throws IOException
    {
        expect('{');
        int size = Integer.parseInt(readStringUntil('}'));
        expect('\r');
        expect('\n');
        FixedLengthInputStream fixed = new FixedLengthInputStream(mIn, size);
        return fixed;
    }

    /**
     * A "" has been read, read to the end of the quoted string and notify the
     * listener.
     *
     * @param mListener
     * @throws IOException
     */
    private String parseQuoted() throws IOException
    {
        expect('""');
        return readStringUntil('""');
    }

    private String readStringUntil(char end) throws IOException
    {
        StringBuffer sb = new StringBuffer();
        int ch;
        while ((ch = mIn.read()) != -1)
        {
            if (ch == end)
            {
                return sb.toString();
            }
            else
            {
                sb.append((char)ch);
            }
        }
        throw new IOException(""readQuotedString(): end of stream reached"");
    }

    private int expect(char ch) throws IOException
    {
        int d;
        if ((d = mIn.read()) != ch)
        {
            throw new IOException(String.format(""Expected %04x (%c) but got %04x (%c)"", (int)ch,
                                                ch, d, (char)d));
        }
        return d;
    }

    /**
     * Represents an IMAP LIST response and is also the base class for the
     * ImapResponse.
     */
    public class ImapList extends ArrayList<Object>
    {
        public ImapList getList(int index)
        {
            return (ImapList)get(index);
        }

        public Object getObject(int index)
        {
            return get(index);
        }

        public String getString(int index)
        {
            return (String)get(index);
        }

        public InputStream getLiteral(int index)
        {
            return (InputStream)get(index);
        }

        public int getNumber(int index)
        {
            return Integer.parseInt(getString(index));
        }

        public Date getDate(int index) throws MessagingException
        {
            try
            {
                return parseDate(getString(index));
            }
            catch (ParseException pe)
            {
                throw new MessagingException(""Unable to parse IMAP datetime"", pe);
            }
        }

        public Object getKeyedValue(Object key)
        {
            for (int i = 0, count = size(); i < count; i++)
            {
                if (get(i).equals(key))
                {
                    return get(i + 1);
                }
            }
            return null;
        }

        public ImapList getKeyedList(Object key)
        {
            return (ImapList)getKeyedValue(key);
        }

        public String getKeyedString(Object key)
        {
            return (String)getKeyedValue(key);
        }

        public InputStream getKeyedLiteral(Object key)
        {
            return (InputStream)getKeyedValue(key);
        }

        public int getKeyedNumber(Object key)
        {
            return Integer.parseInt(getKeyedString(key));
        }

        public Date getKeyedDate(Object key) throws MessagingException
        {
            try
            {
                String value = getKeyedString(key);
                if (value == null)
                {
                    return null;
                }
                return parseDate(value);
            }
            catch (ParseException pe)
            {
                throw new MessagingException(""Unable to parse IMAP datetime"", pe);
            }
        }
        
        public boolean containsKey(Object key)
        {
            if (key == null)
            {
                return false;
            }
            
            for (int i = 0, count = size(); i < count; i++)
            {
                if (key.equals(get(i)))
                {
                    return true;
                }
            }
            return false;
        }
        
        public int getKeyIndex(Object key)
        {
            for (int i = 0, count = size(); i < count; i++)
            {
                if (key.equals(get(i)))
                {
                    return i;
                }
            }
            
            throw new IllegalArgumentException(""getKeyIndex() only works for keys that are in the collection."");
        }

        private Date parseDate(String value) throws ParseException
        {
            //TODO: clean this up a bit
            try
            {
                synchronized (mDateTimeFormat)
                {
                    return mDateTimeFormat.parse(value);
                }
            }
            catch (Exception e)
            {
                try
                {
                    synchronized (badDateTimeFormat)
                    {
                        return badDateTimeFormat.parse(value);
                    }
                }
                catch (Exception e2)
                {
                    synchronized (badDateTimeFormat2)
                    {
                        return badDateTimeFormat2.parse(value);
                    }
                }
            }

        }

    }

    /**
     * Represents a single response from the IMAP server. Tagged responses will
     * have a non-null tag. Untagged responses will have a null tag. The object
     * will contain all of the available tokens at the time the response is
     * received. In general, it will either contain all of the tokens of the
     * response or all of the tokens up until the first LITERAL. If the object
     * does not contain the entire response the caller must call more() to
     * continue reading the response until more returns false.
     */
    public class ImapResponse extends ImapList
    {
        private boolean mCompleted;

        boolean mCommandContinuationRequested;
        String mTag;

        public boolean more() throws IOException
        {
            if (mCompleted)
            {
                return false;
            }
            readTokens(this);
            return true;
        }

        public String getAlertText()
        {
            if (size() > 1 && ""[ALERT]"".equals(get(1)))
            {
                StringBuffer sb = new StringBuffer();
                for (int i = 2, count = size(); i < count; i++)
                {
                    sb.append(get(i).toString());
                    sb.append(' ');
                }
                return sb.toString();
            }
            else
            {
                return null;
            }
        }

        public String toString()
        {
            return ""#"" + mTag + ""# "" + super.toString();
        }
    }
}
",True,189,0,0,9,50,1,4,L1
97,com.fsck.k9.mail.store.LocalStore.java,"
package com.fsck.k9.mail.store;

import android.app.Application;
import android.content.ContentValues;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.net.Uri;
import android.text.util.Regex;
import android.util.Log;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.Utility;
import com.fsck.k9.codec.binary.Base64OutputStream;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.internet.*;
import com.fsck.k9.provider.AttachmentProvider;
import org.apache.commons.io.IOUtils;

import java.io.*;
import java.net.URI;
import java.net.URLEncoder;
import java.util.*;
import java.util.regex.Matcher;

/**
 * <pre>
 * Implements a SQLite database backed local store for Messages.
 * </pre>
 */
public class LocalStore extends Store implements Serializable
{
    private static final int DB_VERSION = 33;
    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED, Flag.X_DESTROYED, Flag.SEEN };

    private String mPath;
    private SQLiteDatabase mDb;
    private File mAttachmentsDir;
    private Application mApplication;
    private String uUid = null;

    private static Set<String> HEADERS_TO_SAVE = new HashSet<String>();
    static
    {
        HEADERS_TO_SAVE.add(K9.K9MAIL_IDENTITY);
        HEADERS_TO_SAVE.add(""In-Reply-To"");
        HEADERS_TO_SAVE.add(""References"");
        HEADERS_TO_SAVE.add(""X-User-Agent"");
    }
    /*
     * a String containing the columns getMessages expects to work with
     * in the correct order.
     */
    static private String GET_MESSAGES_COLS =
        ""subject, sender_list, date, uid, flags, id, to_list, cc_list, ""
        + ""bcc_list, reply_to_list, attachment_count, internal_date, message_id, folder_id, preview "";

    /**
     * local://localhost/path/to/database/uuid.db
     */
    public LocalStore(Account account, Application application) throws MessagingException
    {
        super(account);
        mApplication = application;
        URI uri = null;
        try
        {
            uri = new URI(mAccount.getLocalStoreUri());
        }
        catch (Exception e)
        {
            throw new MessagingException(""Invalid uri for LocalStore"");
        }
        if (!uri.getScheme().equals(""local""))
        {
            throw new MessagingException(""Invalid scheme"");
        }
        mPath = uri.getPath();


        // We need to associate the localstore with the account.  Since we don't have the account
        // handy here, we'll take the filename from the DB and use the basename of the filename
        // Folders probably should have references to their containing accounts
        //TODO: We do have an account object now
        File dbFile = new File(mPath);
        String[] tokens = dbFile.getName().split(""\\."");
        uUid = tokens[0];

        File parentDir = new File(mPath).getParentFile();
        if (!parentDir.exists())
        {
            parentDir.mkdirs();
        }

        mAttachmentsDir = new File(mPath + ""_att"");
        if (!mAttachmentsDir.exists())
        {
            mAttachmentsDir.mkdirs();
        }

        mDb = SQLiteDatabase.openOrCreateDatabase(mPath, null);
        if (mDb.getVersion() != DB_VERSION)
        {
            doDbUpgrade(mDb, application);
        }

    }

    private void doDbUpgrade(SQLiteDatabase mDb, Application application)
    {
        Log.i(K9.LOG_TAG, String.format(""Upgrading database from version %d to version %d"",
                                        mDb.getVersion(), DB_VERSION));


        AttachmentProvider.clear(application);

        try
        {
            // schema version 29 was when we moved to incremental updates
            // in the case of a new db or a < v29 db, we blow away and start from scratch
            if (mDb.getVersion() < 29)
            {

                mDb.execSQL(""DROP TABLE IF EXISTS folders"");
                mDb.execSQL(""CREATE TABLE folders (id INTEGER PRIMARY KEY, name TEXT, ""
                            + ""last_updated INTEGER, unread_count INTEGER, visible_limit INTEGER, status TEXT, push_state TEXT, last_pushed INTEGER)"");

                mDb.execSQL(""CREATE INDEX IF NOT EXISTS folder_name ON folders (name)"");
                mDb.execSQL(""DROP TABLE IF EXISTS messages"");
                mDb.execSQL(""CREATE TABLE messages (id INTEGER PRIMARY KEY, deleted INTEGER default 0, folder_id INTEGER, uid TEXT, subject TEXT, ""
                            + ""date INTEGER, flags TEXT, sender_list TEXT, to_list TEXT, cc_list TEXT, bcc_list TEXT, reply_to_list TEXT, ""
                            + ""html_content TEXT, text_content TEXT, attachment_count INTEGER, internal_date INTEGER, message_id TEXT, preview TEXT)"");

                mDb.execSQL(""DROP TABLE IF EXISTS headers"");
                mDb.execSQL(""CREATE TABLE headers (id INTEGER PRIMARY KEY, message_id INTEGER, name TEXT, value TEXT)"");
                mDb.execSQL(""CREATE INDEX IF NOT EXISTS header_folder ON headers (message_id)"");

                mDb.execSQL(""CREATE INDEX IF NOT EXISTS msg_uid ON messages (uid, folder_id)"");
                mDb.execSQL(""DROP INDEX IF EXISTS msg_folder_id"");
                mDb.execSQL(""DROP INDEX IF EXISTS msg_folder_id_date"");
                mDb.execSQL(""CREATE INDEX IF NOT EXISTS msg_folder_id_deleted_date ON messages (folder_id,deleted,internal_date)"");
                mDb.execSQL(""DROP TABLE IF EXISTS attachments"");
                mDb.execSQL(""CREATE TABLE attachments (id INTEGER PRIMARY KEY, message_id INTEGER,""
                            + ""store_data TEXT, content_uri TEXT, size INTEGER, name TEXT,""
                            + ""mime_type TEXT)"");

                mDb.execSQL(""DROP TABLE IF EXISTS pending_commands"");
                mDb.execSQL(""CREATE TABLE pending_commands "" +
                            ""(id INTEGER PRIMARY KEY, command TEXT, arguments TEXT)"");

                mDb.execSQL(""DROP TRIGGER IF EXISTS delete_folder"");
                mDb.execSQL(""CREATE TRIGGER delete_folder BEFORE DELETE ON folders BEGIN DELETE FROM messages WHERE old.id = folder_id; END;"");

                mDb.execSQL(""DROP TRIGGER IF EXISTS delete_message"");
                mDb.execSQL(""CREATE TRIGGER delete_message BEFORE DELETE ON messages BEGIN DELETE FROM attachments WHERE old.id = message_id; ""
                            + ""DELETE FROM headers where old.id = message_id; END;"");
            }
            else
            { // in the case that we're starting out at 29 or newer, run all the needed updates

                if (mDb.getVersion() < 30)
                {
                    try
                    {
                        mDb.execSQL(""ALTER TABLE messages ADD deleted INTEGER default 0"");
                    }
                    catch (SQLiteException e)
                    {
                        if (! e.toString().startsWith(""duplicate column name: deleted""))
                        {
                            throw e;
                        }
                    }
                }
                if (mDb.getVersion() < 31)
                {
                    mDb.execSQL(""DROP INDEX IF EXISTS msg_folder_id_date"");
                    mDb.execSQL(""CREATE INDEX IF NOT EXISTS msg_folder_id_deleted_date ON messages (folder_id,deleted,internal_date)"");
                }
                if (mDb.getVersion() < 32)
                {
                    mDb.execSQL(""UPDATE messages SET deleted = 1 WHERE flags LIKE '%DELETED%'"");
                }
                if (mDb.getVersion() < 33)
                {

                    try
                    {
                        mDb.execSQL(""ALTER TABLE messages ADD preview TEXT"");
                    }
                    catch (SQLiteException e)
                    {
                        if (! e.toString().startsWith(""duplicate column name: preview""))
                        {
                            throw e;
                        }
                    }

                }


            }

        }
        catch (SQLiteException e)
        {
            Log.e(K9.LOG_TAG, ""Exception while upgrading database. Resetting the DB to v0"");
            mDb.setVersion(0);
            throw new Error(""Database upgrade failed! Resetting your DB version to 0 to force a full schema recreation."");
        }



        mDb.setVersion(DB_VERSION);

        if (mDb.getVersion() != DB_VERSION)
        {
            throw new Error(""Database upgrade failed!"");
        }

        try
        {
            pruneCachedAttachments(true);
        }
        catch (Exception me)
        {
            Log.e(K9.LOG_TAG, ""Exception while force pruning attachments during DB update"", me);
        }
    }

    public long getSize()
    {
        long attachmentLength = 0;

        File[] files = mAttachmentsDir.listFiles();
        for (File file : files)
        {
            if (file.exists())
            {
                attachmentLength += file.length();
            }
        }


        File dbFile = new File(mPath);
        return dbFile.length() + attachmentLength;
    }

    public void compact() throws MessagingException
    {
        Log.i(K9.LOG_TAG, ""Before prune size = "" + getSize());

        pruneCachedAttachments();
        Log.i(K9.LOG_TAG, ""After prune / before compaction size = "" + getSize());

        mDb.execSQL(""VACUUM"");
        Log.i(K9.LOG_TAG, ""After compaction size = "" + getSize());
    }


    public void clear() throws MessagingException
    {
        Log.i(K9.LOG_TAG, ""Before prune size = "" + getSize());

        pruneCachedAttachments(true);

        Log.i(K9.LOG_TAG, ""After prune / before compaction size = "" + getSize());

        Log.i(K9.LOG_TAG, ""Before clear folder count = "" + getFolderCount());
        Log.i(K9.LOG_TAG, ""Before clear message count = "" + getMessageCount());

        Log.i(K9.LOG_TAG, ""After prune / before clear size = "" + getSize());
        // don't delete messages that are Local, since there is no copy on the server.
        // Don't delete deleted messages.  They are essentially placeholders for UIDs of messages that have
        // been deleted locally.  They take up insignificant space
        mDb.execSQL(""DELETE FROM messages WHERE deleted = 0 and uid not like 'Local%'"");

        compact();
        Log.i(K9.LOG_TAG, ""After clear message count = "" + getMessageCount());

        Log.i(K9.LOG_TAG, ""After clear size = "" + getSize());
    }

    public int getMessageCount() throws MessagingException
    {
        Cursor cursor = null;
        try
        {
            cursor = mDb.rawQuery(""SELECT COUNT(*) FROM messages"", null);
            cursor.moveToFirst();
            int messageCount = cursor.getInt(0);
            return messageCount;
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
        }
    }

    public int getFolderCount() throws MessagingException
    {
        Cursor cursor = null;
        try
        {
            cursor = mDb.rawQuery(""SELECT COUNT(*) FROM folders"", null);
            cursor.moveToFirst();
            int messageCount = cursor.getInt(0);
            return messageCount;
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
        }
    }

    @Override
    public LocalFolder getFolder(String name) throws MessagingException
    {
        return new LocalFolder(name);
    }

    // TODO this takes about 260-300ms, seems slow.
    @Override
    public LocalFolder[] getPersonalNamespaces() throws MessagingException
    {
        ArrayList<LocalFolder> folders = new ArrayList<LocalFolder>();
        Cursor cursor = null;


        try
        {
            cursor = mDb.rawQuery(""SELECT id, name, unread_count, visible_limit, last_updated, status, push_state, last_pushed FROM folders"", null);
            while (cursor.moveToNext())
            {
                LocalFolder folder = new LocalFolder(cursor.getString(1));
                folder.open(cursor.getInt(0), cursor.getString(1), cursor.getInt(2), cursor.getInt(3), cursor.getLong(4), cursor.getString(5), cursor.getString(6), cursor.getLong(7));

                folders.add(folder);
            }
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
        }
        return folders.toArray(new LocalFolder[] {});
    }

    @Override
    public void checkSettings() throws MessagingException
    {
    }

    /**
     * Delete the entire Store and it's backing database.
     */
    public void delete()
    {
        try
        {
            mDb.close();
        }
        catch (Exception e)
        {

        }
        try
        {
            File[] attachments = mAttachmentsDir.listFiles();
            for (File attachment : attachments)
            {
                if (attachment.exists())
                {
                    attachment.delete();
                }
            }
            if (mAttachmentsDir.exists())
            {
                mAttachmentsDir.delete();
            }
        }
        catch (Exception e)
        {
        }
        try
        {
            new File(mPath).delete();
        }
        catch (Exception e)
        {

        }
    }

    public void pruneCachedAttachments() throws MessagingException
    {
        pruneCachedAttachments(false);
    }

    /**
     * Deletes all cached attachments for the entire store.
     */
    public void pruneCachedAttachments(boolean force) throws MessagingException
    {

        if (force)
        {
            ContentValues cv = new ContentValues();
            cv.putNull(""content_uri"");
            mDb.update(""attachments"", cv, null, null);
        }
        File[] files = mAttachmentsDir.listFiles();
        for (File file : files)
        {
            if (file.exists())
            {
                if (!force)
                {
                    Cursor cursor = null;
                    try
                    {
                        cursor = mDb.query(
                                     ""attachments"",
                                     new String[] { ""store_data"" },
                                     ""id = ?"",
                                     new String[] { file.getName() },
                                     null,
                                     null,
                                     null);
                        if (cursor.moveToNext())
                        {
                            if (cursor.getString(0) == null)
                            {
                                Log.d(K9.LOG_TAG, ""Attachment "" + file.getAbsolutePath() + "" has no store data, not deleting"");
                                /*
                                 * If the attachment has no store data it is not recoverable, so
                                 * we won't delete it.
                                 */
                                continue;
                            }
                        }
                    }
                    finally
                    {
                        if (cursor != null)
                        {
                            cursor.close();
                        }
                    }
                }
                if (!force)
                {
                    try
                    {
                        ContentValues cv = new ContentValues();
                        cv.putNull(""content_uri"");
                        mDb.update(""attachments"", cv, ""id = ?"", new String[] { file.getName() });
                    }
                    catch (Exception e)
                    {
                        /*
                         * If the row has gone away before we got to mark it not-downloaded that's
                         * okay.
                         */
                    }
                }
                if (!file.delete())
                {
                    file.deleteOnExit();
                }
            }
        }
    }

    public void resetVisibleLimits()
    {
        resetVisibleLimits(K9.DEFAULT_VISIBLE_LIMIT);
    }

    public void resetVisibleLimits(int visibleLimit)
    {
        ContentValues cv = new ContentValues();
        cv.put(""visible_limit"", Integer.toString(visibleLimit));
        mDb.update(""folders"", cv, null, null);
    }

    public ArrayList<PendingCommand> getPendingCommands()
    {
        Cursor cursor = null;
        try
        {
            cursor = mDb.query(""pending_commands"",
                               new String[] { ""id"", ""command"", ""arguments"" },
                               null,
                               null,
                               null,
                               null,
                               ""id ASC"");
            ArrayList<PendingCommand> commands = new ArrayList<PendingCommand>();
            while (cursor.moveToNext())
            {
                PendingCommand command = new PendingCommand();
                command.mId = cursor.getLong(0);
                command.command = cursor.getString(1);
                String arguments = cursor.getString(2);
                command.arguments = arguments.split("","");
                for (int i = 0; i < command.arguments.length; i++)
                {
                    command.arguments[i] = Utility.fastUrlDecode(command.arguments[i]);
                }
                commands.add(command);
            }
            return commands;
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
        }
    }

    public void addPendingCommand(PendingCommand command)
    {
        try
        {
            for (int i = 0; i < command.arguments.length; i++)
            {
                command.arguments[i] = URLEncoder.encode(command.arguments[i], ""UTF-8"");
            }
            ContentValues cv = new ContentValues();
            cv.put(""command"", command.command);
            cv.put(""arguments"", Utility.combine(command.arguments, ','));
            mDb.insert(""pending_commands"", ""command"", cv);
        }
        catch (UnsupportedEncodingException usee)
        {
            throw new Error(""Aparently UTF-8 has been lost to the annals of history."");
        }
    }

    public void removePendingCommand(PendingCommand command)
    {
        mDb.delete(""pending_commands"", ""id = ?"", new String[] { Long.toString(command.mId) });
    }

    public void removePendingCommands()
    {
        mDb.delete(""pending_commands"", null, null);
    }

    public static class PendingCommand
    {
        private long mId;
        public String command;
        public String[] arguments;

        @Override
        public String toString()
        {
            StringBuffer sb = new StringBuffer();
            sb.append(command);
            sb.append("": "");
            for (String argument : arguments)
            {
                sb.append("", "");
                sb.append(argument);
                //sb.append(""\n"");
            }
            return sb.toString();
        }
    }

    public boolean isMoveCapable()
    {
        return true;
    }

    public boolean isCopyCapable()
    {
        return true;
    }

    public Message[] searchForMessages(MessageRetrievalListener listener, String queryString) throws MessagingException
    {

        queryString = ""%""+queryString+""%"";
        return getMessages(
                   listener,
                   null,
                   ""SELECT ""
                   + GET_MESSAGES_COLS
                   + ""FROM messages WHERE deleted = 0 AND (html_content LIKE ? OR subject LIKE ? OR sender_list LIKE ?) ORDER BY date DESC""
                   , new String[]
                   {
                       queryString,
                       queryString,
                       queryString
                   }
               );
    }
    /*
     * Given a query string, actually do the query for the messages and
     * call the MessageRetrievalListener for each one
     */
    private Message[] getMessages(
        MessageRetrievalListener listener,
        LocalFolder folder,
        String queryString, String[] placeHolders
    ) throws MessagingException
    {
        ArrayList<LocalMessage> messages = new ArrayList<LocalMessage>();
        Cursor cursor = null;
        try
        {
            // pull out messages most recent first, since that's what the default sort is
            cursor = mDb.rawQuery(queryString, placeHolders);


            int i = 0;
            ArrayList<LocalMessage> messagesForHeaders = new ArrayList<LocalMessage>();
            while (cursor.moveToNext())
            {
                LocalMessage message = new LocalMessage(null, folder);
                message.populateFromGetMessageCursor(cursor);

                messages.add(message);
                if (listener != null)
                {
                    listener.messageFinished(message, i, -1);
                }
                i++;
            }
            if (listener != null)
            {
                listener.messagesFinished(i);
            }
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
        }

        return messages.toArray(new Message[] {});

    }


    public class LocalFolder extends Folder implements Serializable
    {
        private String mName = null;
        private long mFolderId = -1;
        private int mUnreadMessageCount = -1;
        private int mVisibleLimit = -1;
        private FolderClass displayClass = FolderClass.NO_CLASS;
        private FolderClass syncClass = FolderClass.INHERITED;
        private FolderClass pushClass = FolderClass.SECOND_CLASS;
        private boolean inTopGroup = false;
        private String prefId = null;
        private String mPushState = null;


        public LocalFolder(String name)
        {
            super(LocalStore.this.mAccount);
            this.mName = name;

            if (K9.INBOX.equals(getName()))
            {
                syncClass =  FolderClass.FIRST_CLASS;
                pushClass =  FolderClass.FIRST_CLASS;
                inTopGroup = true;
            }


        }

        public LocalFolder(long id)
        {
            super(LocalStore.this.mAccount);
            this.mFolderId = id;
        }

        public long getId()
        {
            return mFolderId;
        }

        @Override
        public void open(OpenMode mode) throws MessagingException
        {
            if (isOpen())
            {
                return;
            }
            Cursor cursor = null;
            try
            {
                String baseQuery =
                    ""SELECT id, name,unread_count, visible_limit, last_updated, status, push_state, last_pushed FROM folders "";
                if (mName != null)
                {
                    cursor = mDb.rawQuery(baseQuery + ""where folders.name = ?"", new String[] { mName });
                }
                else
                {
                    cursor = mDb.rawQuery(baseQuery + ""where folders.id = ?"", new String[] { Long.toString(mFolderId) });


                }

                if (cursor.moveToFirst())
                {
                    int folderId = cursor.getInt(0);
                    if (folderId > 0)
                    {
                        open(folderId, cursor.getString(1), cursor.getInt(2), cursor.getInt(3), cursor.getLong(4), cursor.getString(5), cursor.getString(6), cursor.getLong(7));
                    }
                }
                else
                {
                    create(FolderType.HOLDS_MESSAGES);
                    open(mode);
                }
            }
            finally
            {
                if (cursor != null)
                {
                    cursor.close();
                }
            }
        }

        private void open(int id, String name, int unreadCount, int visibleLimit, long lastChecked, String status, String pushState, long lastPushed) throws MessagingException
        {
            mFolderId = id;
            mName = name;
            mUnreadMessageCount = unreadCount;
            mVisibleLimit = visibleLimit;
            mPushState = pushState;
            super.setStatus(status);
            // Only want to set the local variable stored in the super class.  This class
            // does a DB update on setLastChecked
            super.setLastChecked(lastChecked);
            super.setLastPush(lastPushed);
        }

        @Override
        public boolean isOpen()
        {
            return (mFolderId != -1 && mName != null);
        }

        @Override
        public OpenMode getMode() throws MessagingException
        {
            return OpenMode.READ_WRITE;
        }

        @Override
        public String getName()
        {
            return mName;
        }

        @Override
        public boolean exists() throws MessagingException
        {
            Cursor cursor = null;
            try
            {
                cursor = mDb.rawQuery(""SELECT id FROM folders ""
                                      + ""where folders.name = ?"", new String[] { this
                                              .getName()
                                                                               });
                if (cursor.moveToFirst())
                {
                    int folderId = cursor.getInt(0);
                    return (folderId > 0) ? true : false;
                }
                else
                {
                    return false;
                }
            }
            finally
            {
                if (cursor != null)
                {
                    cursor.close();
                }
            }
        }

        @Override
        public boolean create(FolderType type) throws MessagingException
        {
            if (exists())
            {
                throw new MessagingException(""Folder "" + mName + "" already exists."");
            }
            mDb.execSQL(""INSERT INTO folders (name, visible_limit) VALUES (?, ?)"", new Object[]
                        {
                            mName,
                            K9.DEFAULT_VISIBLE_LIMIT
                        });
            return true;
        }

        public boolean create(FolderType type, int visibleLimit) throws MessagingException
        {
            if (exists())
            {
                throw new MessagingException(""Folder "" + mName + "" already exists."");
            }
            mDb.execSQL(""INSERT INTO folders (name, visible_limit) VALUES (?, ?)"", new Object[]
                        {
                            mName,
                            visibleLimit
                        });
            return true;
        }

        @Override
        public void close()
        {
            mFolderId = -1;
        }

        @Override
        public int getMessageCount() throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            Cursor cursor = null;
            try
            {
                cursor = mDb.rawQuery(""SELECT COUNT(*) FROM messages WHERE messages.folder_id = ?"",
                                      new String[]
                                      {
                                          Long.toString(mFolderId)
                                      });
                cursor.moveToFirst();
                int messageCount = cursor.getInt(0);
                return messageCount;
            }
            finally
            {
                if (cursor != null)
                {
                    cursor.close();
                }
            }
        }

        @Override
        public int getUnreadMessageCount() throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            return mUnreadMessageCount;
        }


        public void setUnreadMessageCount(int unreadMessageCount) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            mUnreadMessageCount = Math.max(0, unreadMessageCount);
            mDb.execSQL(""UPDATE folders SET unread_count = ? WHERE id = ?"",
                        new Object[] { mUnreadMessageCount, mFolderId });
        }

        public void setLastChecked(long lastChecked) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            super.setLastChecked(lastChecked);
            mDb.execSQL(""UPDATE folders SET last_updated = ? WHERE id = ?"",
                        new Object[] { lastChecked, mFolderId });
        }

        public void setLastPush(long lastChecked) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            super.setLastPush(lastChecked);
            mDb.execSQL(""UPDATE folders SET last_pushed = ? WHERE id = ?"",
                        new Object[] { lastChecked, mFolderId });
        }

        public int getVisibleLimit() throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            return mVisibleLimit;
        }

        public void purgeToVisibleLimit(MessageRemovalListener listener) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            Message[] messages = getMessages(null, false);
            for (int i = mVisibleLimit; i < messages.length; i++)
            {
                if (listener != null)
                {
                    listener.messageRemoved(messages[i]);
                }
                messages[i].setFlag(Flag.X_DESTROYED, true);

            }
        }


        public void setVisibleLimit(int visibleLimit) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            mVisibleLimit = visibleLimit;
            mDb.execSQL(""UPDATE folders SET visible_limit = ? WHERE id = ?"",
                        new Object[] { mVisibleLimit, mFolderId });
        }

        public void setStatus(String status) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            super.setStatus(status);
            mDb.execSQL(""UPDATE folders SET status = ? WHERE id = ?"",
                        new Object[] { status, mFolderId });
        }
        public void setPushState(String pushState) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            mPushState = pushState;
            mDb.execSQL(""UPDATE folders SET push_state = ? WHERE id = ?"",
                        new Object[] { pushState, mFolderId });
        }
        public String getPushState()
        {
            return mPushState;
        }
        @Override
        public FolderClass getDisplayClass()
        {
            return displayClass;
        }

        @Override
        public FolderClass getSyncClass()
        {
            if (FolderClass.INHERITED == syncClass)
            {
                return getDisplayClass();
            }
            else
            {
                return syncClass;
            }
        }

        public FolderClass getRawSyncClass()
        {
            return syncClass;

        }

        public FolderClass getPushClass()
        {
            if (FolderClass.INHERITED == pushClass)
            {
                return getSyncClass();
            }
            else
            {
                return pushClass;
            }
        }

        public FolderClass getRawPushClass()
        {
            return pushClass;

        }

        public void setDisplayClass(FolderClass displayClass)
        {
            this.displayClass = displayClass;
        }

        public void setSyncClass(FolderClass syncClass)
        {
            this.syncClass = syncClass;
        }
        public void setPushClass(FolderClass pushClass)
        {
            this.pushClass = pushClass;
        }

        private String getPrefId() throws MessagingException
        {
            open(OpenMode.READ_WRITE);

            if (prefId == null)
            {
                prefId = uUid + ""."" + mName;
            }

            return prefId;
        }

        public void delete(Preferences preferences) throws MessagingException
        {
            String id = getPrefId();

            SharedPreferences.Editor editor = preferences.getPreferences().edit();

            editor.remove(id + "".displayMode"");
            editor.remove(id + "".syncMode"");
            editor.remove(id + "".pushMode"");
            editor.remove(id + "".inTopGroup"");

            editor.commit();
        }

        public void save(Preferences preferences) throws MessagingException
        {
            String id = getPrefId();

            SharedPreferences.Editor editor = preferences.getPreferences().edit();
            // there can be a lot of folders.  For the defaults, let's not save prefs, saving space, except for INBOX
            if (displayClass == FolderClass.NO_CLASS && !K9.INBOX.equals(getName()))
            {
                editor.remove(id + "".displayMode"");
            }
            else
            {
                editor.putString(id + "".displayMode"", displayClass.name());
            }

            if (syncClass == FolderClass.INHERITED && !K9.INBOX.equals(getName()))
            {
                editor.remove(id + "".syncMode"");
            }
            else
            {
                editor.putString(id + "".syncMode"", syncClass.name());
            }

            if (pushClass == FolderClass.SECOND_CLASS && !K9.INBOX.equals(getName()))
            {
                editor.remove(id + "".pushMode"");
            }
            else
            {
                editor.putString(id + "".pushMode"", pushClass.name());
            }
            editor.putBoolean(id + "".inTopGroup"", inTopGroup);

            editor.commit();
        }
        public void refresh(Preferences preferences) throws MessagingException
        {

            String id = getPrefId();

            try
            {
                displayClass = FolderClass.valueOf(preferences.getPreferences().getString(id + "".displayMode"",
                                                   FolderClass.NO_CLASS.name()));
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to load displayMode for "" + getName(), e);

                displayClass = FolderClass.NO_CLASS;
            }
            if (displayClass == FolderClass.NONE)
            {
                displayClass = FolderClass.NO_CLASS;
            }


            FolderClass defSyncClass = FolderClass.INHERITED;
            if (K9.INBOX.equals(getName()))
            {
                defSyncClass =  FolderClass.FIRST_CLASS;
            }

            try
            {
                syncClass = FolderClass.valueOf(preferences.getPreferences().getString(id  + "".syncMode"",
                                                defSyncClass.name()));
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to load syncMode for "" + getName(), e);

                syncClass = defSyncClass;
            }
            if (syncClass == FolderClass.NONE)
            {
                syncClass = FolderClass.INHERITED;
            }

            FolderClass defPushClass = FolderClass.SECOND_CLASS;
            boolean defInTopGroup = false;
            if (K9.INBOX.equals(getName()))
            {
                defPushClass =  FolderClass.FIRST_CLASS;
                defInTopGroup = true;
            }

            try
            {
                pushClass = FolderClass.valueOf(preferences.getPreferences().getString(id  + "".pushMode"",
                                                defPushClass.name()));
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to load pushMode for "" + getName(), e);

                pushClass = defPushClass;
            }
            if (pushClass == FolderClass.NONE)
            {
                pushClass = FolderClass.INHERITED;
            }
            inTopGroup = preferences.getPreferences().getBoolean(id + "".inTopGroup"", defInTopGroup);

        }

        @Override
        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
        throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            if (fp.contains(FetchProfile.Item.BODY))
            {
                for (Message message : messages)
                {
                    LocalMessage localMessage = (LocalMessage)message;
                    Cursor cursor = null;
                    MimeMultipart mp = new MimeMultipart();
                    mp.setSubType(""mixed"");
                    try
                    {
                        cursor = mDb.rawQuery(""SELECT html_content, text_content FROM messages ""
                                              + ""WHERE id = ?"",
                                              new String[] { Long.toString(localMessage.mId) });
                        cursor.moveToNext();
                        String htmlContent = cursor.getString(0);
                        String textContent = cursor.getString(1);

                        if (textContent != null)
                        {
                            LocalTextBody body = new LocalTextBody(textContent, htmlContent);
                            MimeBodyPart bp = new MimeBodyPart(body, ""text/plain"");
                            mp.addBodyPart(bp);
                        }
                        else
                        {
                            TextBody body = new TextBody(htmlContent);
                            MimeBodyPart bp = new MimeBodyPart(body, ""text/html"");
                            mp.addBodyPart(bp);
                        }
                    }
                    finally
                    {
                        if (cursor != null)
                        {
                            cursor.close();
                        }
                    }

                    try
                    {
                        cursor = mDb.query(
                                     ""attachments"",
                                     new String[]
                                     {
                                         ""id"",
                                         ""size"",
                                         ""name"",
                                         ""mime_type"",
                                         ""store_data"",
                                         ""content_uri""
                                     },
                                     ""message_id = ?"",
                                     new String[] { Long.toString(localMessage.mId) },
                                     null,
                                     null,
                                     null);

                        while (cursor.moveToNext())
                        {
                            long id = cursor.getLong(0);
                            int size = cursor.getInt(1);
                            String name = cursor.getString(2);
                            String type = cursor.getString(3);
                            String storeData = cursor.getString(4);
                            String contentUri = cursor.getString(5);
                            Body body = null;
                            if (contentUri != null)
                            {
                                body = new LocalAttachmentBody(Uri.parse(contentUri), mApplication);
                            }
                            MimeBodyPart bp = new LocalAttachmentBodyPart(body, id);
                            bp.setHeader(MimeHeader.HEADER_CONTENT_TYPE,
                                         String.format(""%s;\n name=\""%s\"""",
                                                       type,
                                                       name));
                            bp.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, ""base64"");
                            bp.setHeader(MimeHeader.HEADER_CONTENT_DISPOSITION,
                                         String.format(""attachment;\n filename=\""%s\"";\n size=%d"",
                                                       name,
                                                       size));

                            /*
                             * HEADER_ANDROID_ATTACHMENT_STORE_DATA is a custom header we add to that
                             * we can later pull the attachment from the remote store if neccesary.
                             */
                            bp.setHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA, storeData);

                            mp.addBodyPart(bp);
                        }
                    }
                    finally
                    {
                        if (cursor != null)
                        {
                            cursor.close();
                        }
                    }

                    if (mp.getCount() == 1)
                    {
                        BodyPart part = mp.getBodyPart(0);
                        localMessage.setHeader(MimeHeader.HEADER_CONTENT_TYPE, part.getContentType());
                        localMessage.setBody(part.getBody());
                    }
                    else
                    {
                        localMessage.setHeader(MimeHeader.HEADER_CONTENT_TYPE, ""multipart/mixed"");
                        localMessage.setBody(mp);
                    }
                }
            }
        }

        @Override
        public Message[] getMessages(int start, int end, MessageRetrievalListener listener)
        throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            throw new MessagingException(
                ""LocalStore.getMessages(int, int, MessageRetrievalListener) not yet implemented"");
        }

        private void populateHeaders(List<LocalMessage> messages)
        {
            Cursor cursor = null;
            if (messages.size() == 0)
            {
                return;
            }
            try
            {
                Map<Long, LocalMessage> popMessages = new HashMap<Long, LocalMessage>();
                List<String> ids = new ArrayList<String>();
                StringBuffer questions = new StringBuffer();

                for (int i = 0; i < messages.size(); i++)
                {
                    if (i != 0)
                    {
                        questions.append("", "");
                    }
                    questions.append(""?"");
                    LocalMessage message = messages.get(i);
                    Long id = message.getId();
                    ids.add(Long.toString(id));
                    popMessages.put(id, message);

                }

                cursor = mDb.rawQuery(
                             ""SELECT message_id, name, value FROM headers "" + ""WHERE message_id in ( "" + questions + "") "",
                             ids.toArray(new String[] {}));


                while (cursor.moveToNext())
                {
                    Long id = cursor.getLong(0);
                    String name = cursor.getString(1);
                    String value = cursor.getString(2);
                    //Log.i(K9.LOG_TAG, ""Retrieved header name= "" + name + "", value = "" + value + "" for message "" + id);
                    popMessages.get(id).addHeader(name, value);
                }
            }
            finally
            {
                if (cursor != null)
                {
                    cursor.close();
                }
            }
        }

        @Override
        public Message getMessage(String uid) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            LocalMessage message = new LocalMessage(uid, this);
            Cursor cursor = null;

            try
            {
                cursor = mDb.rawQuery(
                             ""SELECT ""
                             + GET_MESSAGES_COLS
                             + ""FROM messages WHERE uid = ? AND folder_id = ?"",
                             new String[]
                             {
                                 message.getUid(), Long.toString(mFolderId)
                             });
                if (!cursor.moveToNext())
                {
                    return null;
                }
                message.populateFromGetMessageCursor(cursor);
            }
            finally
            {
                if (cursor != null)
                {
                    cursor.close();
                }
            }
            return message;
        }

        @Override
        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException
        {
            return getMessages(listener, true);
        }

        @Override
        public Message[] getMessages(MessageRetrievalListener listener, boolean includeDeleted) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            return LocalStore.this.getMessages(
                       listener,
                       this,
                       ""SELECT "" + GET_MESSAGES_COLS
                       + ""FROM messages WHERE ""
                       + (includeDeleted ? """" : ""deleted = 0 AND "")
                       + "" folder_id = ? ORDER BY date DESC""
                       , new String[]
                       {
                           Long.toString(mFolderId)
                       }
                   );

        }


        @Override
        public Message[] getMessages(String[] uids, MessageRetrievalListener listener)
        throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            if (uids == null)
            {
                return getMessages(listener);
            }
            ArrayList<Message> messages = new ArrayList<Message>();
            for (String uid : uids)
            {
                Message message = getMessage(uid);
                if (message != null)
                {
                    messages.add(message);
                }
            }
            return messages.toArray(new Message[] {});
        }

        @Override
        public void copyMessages(Message[] msgs, Folder folder) throws MessagingException
        {
            if (!(folder instanceof LocalFolder))
            {
                throw new MessagingException(""copyMessages called with incorrect Folder"");
            }
            ((LocalFolder) folder).appendMessages(msgs, true);
        }

        @Override
        public void moveMessages(Message[] msgs, Folder destFolder) throws MessagingException
        {
            if (!(destFolder instanceof LocalFolder))
            {
                throw new MessagingException(""moveMessages called with non-LocalFolder"");
            }

            LocalFolder lDestFolder = (LocalFolder)destFolder;
            lDestFolder.open(OpenMode.READ_WRITE);
            for (Message message : msgs)
            {
                LocalMessage lMessage = (LocalMessage)message;

                if (!message.isSet(Flag.SEEN))
                {
                    setUnreadMessageCount(getUnreadMessageCount() - 1);
                    lDestFolder.setUnreadMessageCount(lDestFolder.getUnreadMessageCount() + 1);
                }

                String oldUID = message.getUid();

                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Updating folder_id to "" + lDestFolder.getId() + "" for message with UID ""
                          + message.getUid() + "", id "" + lMessage.getId() + "" currently in folder "" + getName());

                message.setUid(K9.LOCAL_UID_PREFIX + UUID.randomUUID().toString());

                mDb.execSQL(""UPDATE messages "" + ""SET folder_id = ?, uid = ? "" + ""WHERE id = ?"", new Object[]
                            {
                                lDestFolder.getId(),
                                message.getUid(),
                                lMessage.getId()
                            });

                LocalMessage placeHolder = new LocalMessage(oldUID, this);
                placeHolder.setFlagInternal(Flag.DELETED, true);
                placeHolder.setFlagInternal(Flag.SEEN, true);
                appendMessages(new Message[] { placeHolder });
            }

        }

        /**
         * The method differs slightly from the contract; If an incoming message already has a uid
         * assigned and it matches the uid of an existing message then this message will replace the
         * old message. It is implemented as a delete/insert. This functionality is used in saving
         * of drafts and re-synchronization of updated server messages.
         */
        @Override
        public void appendMessages(Message[] messages) throws MessagingException
        {
            appendMessages(messages, false);
        }

        /**
         * The method differs slightly from the contract; If an incoming message already has a uid
         * assigned and it matches the uid of an existing message then this message will replace the
         * old message. It is implemented as a delete/insert. This functionality is used in saving
         * of drafts and re-synchronization of updated server messages.
         */
        private void appendMessages(Message[] messages, boolean copy) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            for (Message message : messages)
            {
                if (!(message instanceof MimeMessage))
                {
                    throw new Error(""LocalStore can only store Messages that extend MimeMessage"");
                }

                String uid = message.getUid();
                if (uid == null || copy)
                {
                    uid = K9.LOCAL_UID_PREFIX + UUID.randomUUID().toString();
                    if (!copy)
                    {
                        message.setUid(uid);
                    }
                }
                else
                {
                    Message oldMessage = getMessage(uid);
                    if (oldMessage != null && oldMessage.isSet(Flag.SEEN) == false)
                    {
                        setUnreadMessageCount(getUnreadMessageCount() - 1);
                    }
                    /*
                     * The message may already exist in this Folder, so delete it first.
                     */
                    deleteAttachments(message.getUid());
                    mDb.execSQL(""DELETE FROM messages WHERE folder_id = ? AND uid = ?"",
                                new Object[] { mFolderId, message.getUid() });
                }

                ArrayList<Part> viewables = new ArrayList<Part>();
                ArrayList<Part> attachments = new ArrayList<Part>();
                MimeUtility.collectParts(message, viewables, attachments);

                StringBuffer sbHtml = new StringBuffer();
                StringBuffer sbText = new StringBuffer();
                for (Part viewable : viewables)
                {
                    try
                    {
                        String text = MimeUtility.getTextFromPart(viewable);
                        /*
                         * Anything with MIME type text/html will be stored as such. Anything
                         * else will be stored as text/plain.
                         */
                        if (viewable.getMimeType().equalsIgnoreCase(""text/html""))
                        {
                            sbHtml.append(text);
                        }
                        else
                        {
                            sbText.append(text);
                        }
                    }
                    catch (Exception e)
                    {
                        throw new MessagingException(""Unable to get text for message part"", e);
                    }
                }

                String text = sbText.toString();
                String html = markupContent(text, sbHtml.toString());
                String preview = calculateContentPreview(text);

                try
                {
                    ContentValues cv = new ContentValues();
                    cv.put(""uid"", uid);
                    cv.put(""subject"", message.getSubject());
                    cv.put(""sender_list"", Address.pack(message.getFrom()));
                    cv.put(""date"", message.getSentDate() == null
                           ? System.currentTimeMillis() : message.getSentDate().getTime());
                    cv.put(""flags"", Utility.combine(message.getFlags(), ',').toUpperCase());
                    cv.put(""deleted"", message.isSet(Flag.DELETED) ? 1 : 0);
                    cv.put(""folder_id"", mFolderId);
                    cv.put(""to_list"", Address.pack(message.getRecipients(RecipientType.TO)));
                    cv.put(""cc_list"", Address.pack(message.getRecipients(RecipientType.CC)));
                    cv.put(""bcc_list"", Address.pack(message.getRecipients(RecipientType.BCC)));
                    cv.put(""html_content"", html.length() > 0 ? html : null);
                    cv.put(""text_content"", text.length() > 0 ? text : null);
                    cv.put(""preview"", preview.length() > 0 ? preview : null);
                    cv.put(""reply_to_list"", Address.pack(message.getReplyTo()));
                    cv.put(""attachment_count"", attachments.size());
                    cv.put(""internal_date"",  message.getInternalDate() == null
                           ? System.currentTimeMillis() : message.getInternalDate().getTime());
                    String messageId = message.getMessageId();
                    if (messageId != null)
                    {
                        cv.put(""message_id"", messageId);
                    }
                    long messageUid = mDb.insert(""messages"", ""uid"", cv);
                    for (Part attachment : attachments)
                    {
                        saveAttachment(messageUid, attachment, copy);
                    }
                    saveHeaders(messageUid, (MimeMessage)message);
                    if (message.isSet(Flag.SEEN) == false)
                    {
                        setUnreadMessageCount(getUnreadMessageCount() + 1);
                    }
                }
                catch (Exception e)
                {
                    throw new MessagingException(""Error appending message"", e);
                }
            }
        }

        /**
         * Update the given message in the LocalStore without first deleting the existing
         * message (contrast with appendMessages). This method is used to store changes
         * to the given message while updating attachments and not removing existing
         * attachment data.
         * TODO In the future this method should be combined with appendMessages since the Message
         * contains enough data to decide what to do.
         * @param message
         * @throws MessagingException
         */
        public void updateMessage(LocalMessage message) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            ArrayList<Part> viewables = new ArrayList<Part>();
            ArrayList<Part> attachments = new ArrayList<Part>();

            message.buildMimeRepresentation();

            MimeUtility.collectParts(message, viewables, attachments);

            StringBuffer sbHtml = new StringBuffer();
            StringBuffer sbText = new StringBuffer();
            for (int i = 0, count = viewables.size(); i < count; i++)
            {
                Part viewable = viewables.get(i);
                try
                {
                    String text = MimeUtility.getTextFromPart(viewable);
                    /*
                     * Anything with MIME type text/html will be stored as such. Anything
                     * else will be stored as text/plain.
                     */
                    if (viewable.getMimeType().equalsIgnoreCase(""text/html""))
                    {
                        sbHtml.append(text);
                    }
                    else
                    {
                        sbText.append(text);
                    }
                }
                catch (Exception e)
                {
                    throw new MessagingException(""Unable to get text for message part"", e);
                }
            }

            String text = sbText.toString();
            String html = markupContent(text, sbHtml.toString());
            String preview = calculateContentPreview(text);

            try
            {
                mDb.execSQL(""UPDATE messages SET ""
                            + ""uid = ?, subject = ?, sender_list = ?, date = ?, flags = ?, ""
                            + ""folder_id = ?, to_list = ?, cc_list = ?, bcc_list = ?, ""
                            + ""html_content = ?, text_content = ?, preview = ?, reply_to_list = ?, ""
                            + ""attachment_count = ? WHERE id = ?"",
                            new Object[]
                            {
                                message.getUid(),
                                message.getSubject(),
                                Address.pack(message.getFrom()),
                                message.getSentDate() == null ? System
                                .currentTimeMillis() : message.getSentDate()
                                .getTime(),
                                Utility.combine(message.getFlags(), ',').toUpperCase(),
                                mFolderId,
                                Address.pack(message
                                             .getRecipients(RecipientType.TO)),
                                Address.pack(message
                                             .getRecipients(RecipientType.CC)),
                                Address.pack(message
                                             .getRecipients(RecipientType.BCC)),
                                html.length() > 0 ? html : null,
                                text.length() > 0 ? text : null,
                                preview.length() > 0 ? preview : null,
                                Address.pack(message.getReplyTo()),
                                attachments.size(),
                                message.mId
                            });

                for (int i = 0, count = attachments.size(); i < count; i++)
                {
                    Part attachment = attachments.get(i);
                    saveAttachment(message.mId, attachment, false);
                }
                saveHeaders(message.getId(), message);
            }
            catch (Exception e)
            {
                throw new MessagingException(""Error appending message"", e);
            }
        }

        private void saveHeaders(long id, MimeMessage message)
        {
            deleteHeaders(id);
            for (String name : message.getHeaderNames())
            {
                if (HEADERS_TO_SAVE.contains(name))
                {
                    String[] values = message.getHeader(name);
                    for (String value : values)
                    {
                        ContentValues cv = new ContentValues();
                        cv.put(""message_id"", id);
                        cv.put(""name"", name);
                        cv.put(""value"", value);
                        mDb.insert(""headers"", ""name"", cv);
                    }
                }
            }
        }

        private void deleteHeaders(long id)
        {
            mDb.execSQL(""DELETE FROM headers WHERE id = ?"",
                        new Object[]
                        {
                            id
                        });
        }

        /**
         * @param messageId
         * @param attachment
         * @param attachmentId -1 to create a new attachment or >= 0 to update an existing
         * @throws IOException
         * @throws MessagingException
         */
        private void saveAttachment(long messageId, Part attachment, boolean saveAsNew)
        throws IOException, MessagingException
        {
            long attachmentId = -1;
            Uri contentUri = null;
            int size = -1;
            File tempAttachmentFile = null;

            if ((!saveAsNew) && (attachment instanceof LocalAttachmentBodyPart))
            {
                attachmentId = ((LocalAttachmentBodyPart) attachment).getAttachmentId();
            }

            if (attachment.getBody() != null)
            {
                Body body = attachment.getBody();
                if (body instanceof LocalAttachmentBody)
                {
                    contentUri = ((LocalAttachmentBody) body).getContentUri();
                }
                else
                {
                    /*
                     * If the attachment has a body we're expected to save it into the local store
                     * so we copy the data into a cached attachment file.
                     */
                    InputStream in = attachment.getBody().getInputStream();
                    tempAttachmentFile = File.createTempFile(""att"", null, mAttachmentsDir);
                    FileOutputStream out = new FileOutputStream(tempAttachmentFile);
                    size = IOUtils.copy(in, out);
                    in.close();
                    out.close();
                }
            }

            if (size == -1)
            {
                /*
                 * If the attachment is not yet downloaded see if we can pull a size
                 * off the Content-Disposition.
                 */
                String disposition = attachment.getDisposition();
                if (disposition != null)
                {
                    String s = MimeUtility.getHeaderParameter(disposition, ""size"");
                    if (s != null)
                    {
                        size = Integer.parseInt(s);
                    }
                }
            }
            if (size == -1)
            {
                size = 0;
            }

            String storeData =
                Utility.combine(attachment.getHeader(
                                    MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA), ',');

            String name = MimeUtility.getHeaderParameter(attachment.getContentType(), ""name"");
            String contentDisposition = MimeUtility.unfoldAndDecode(attachment.getDisposition());
            if (name == null && contentDisposition != null)
            {
                name = MimeUtility.getHeaderParameter(contentDisposition, ""filename"");
            }
            if (attachmentId == -1)
            {
                ContentValues cv = new ContentValues();
                cv.put(""message_id"", messageId);
                cv.put(""content_uri"", contentUri != null ? contentUri.toString() : null);
                cv.put(""store_data"", storeData);
                cv.put(""size"", size);
                cv.put(""name"", name);
                cv.put(""mime_type"", attachment.getMimeType());

                attachmentId = mDb.insert(""attachments"", ""message_id"", cv);
            }
            else
            {
                ContentValues cv = new ContentValues();
                cv.put(""content_uri"", contentUri != null ? contentUri.toString() : null);
                cv.put(""size"", size);
                mDb.update(
                    ""attachments"",
                    cv,
                    ""id = ?"",
                    new String[] { Long.toString(attachmentId) });
            }

            if (tempAttachmentFile != null)
            {
                File attachmentFile = new File(mAttachmentsDir, Long.toString(attachmentId));
                tempAttachmentFile.renameTo(attachmentFile);
                contentUri = AttachmentProvider.getAttachmentUri(
                                 new File(mPath).getName(),
                                 attachmentId);
                attachment.setBody(new LocalAttachmentBody(contentUri, mApplication));
                ContentValues cv = new ContentValues();
                cv.put(""content_uri"", contentUri != null ? contentUri.toString() : null);
                mDb.update(
                    ""attachments"",
                    cv,
                    ""id = ?"",
                    new String[] { Long.toString(attachmentId) });
            }

            if (attachment instanceof LocalAttachmentBodyPart)
            {
                ((LocalAttachmentBodyPart) attachment).setAttachmentId(attachmentId);
            }
        }

        /**
         * Changes the stored uid of the given message (using it's internal id as a key) to
         * the uid in the message.
         * @param message
         */
        public void changeUid(LocalMessage message) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            ContentValues cv = new ContentValues();
            cv.put(""uid"", message.getUid());
            mDb.update(""messages"", cv, ""id = ?"", new String[] { Long.toString(message.mId) });
        }

        @Override
        public void setFlags(Message[] messages, Flag[] flags, boolean value)
        throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            for (Message message : messages)
            {
                message.setFlags(flags, value);
            }
        }

        @Override
        public void setFlags(Flag[] flags, boolean value)
        throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            for (Message message : getMessages(null))
            {
                message.setFlags(flags, value);
            }
        }

        @Override
        public String getUidFromMessageId(Message message) throws MessagingException
        {
            throw new MessagingException(""Cannot call getUidFromMessageId on LocalFolder"");
        }

        public void deleteMessagesOlderThan(long cutoff) throws MessagingException
        {
            open(OpenMode.READ_ONLY);
            mDb.execSQL(""DELETE FROM messages WHERE folder_id = ? and date < ?"", new Object[]
                        {
                            Long.toString(mFolderId), new Long(cutoff)
                        });
            resetUnreadCount();
        }

        private void resetUnreadCount()
        {
            try
            {
                int newUnread = 0;
                Message[] messages = getMessages(null);
                for (Message message : messages)
                {
                    if (message.isSet(Flag.SEEN) == false)
                    {
                        newUnread++;
                    }
                }
                setUnreadMessageCount(newUnread);
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to fetch all messages from LocalStore"", e);
            }
        }

        @Override
        public void delete(boolean recurse) throws MessagingException
        {
            // We need to open the folder first to make sure we've got it's id
            open(OpenMode.READ_ONLY);
            Message[] messages = getMessages(null);
            for (Message message : messages)
            {
                deleteAttachments(message.getUid());
            }
            mDb.execSQL(""DELETE FROM folders WHERE id = ?"", new Object[]
                        {
                            Long.toString(mFolderId),
                        });
        }

        @Override
        public boolean equals(Object o)
        {
            if (o instanceof LocalFolder)
            {
                return ((LocalFolder)o).mName.equals(mName);
            }
            return super.equals(o);
        }

        @Override
        public int hashCode()
        {
            return mName.hashCode();
        }

        @Override
        public Flag[] getPermanentFlags() throws MessagingException
        {
            return PERMANENT_FLAGS;
        }

        private void deleteAttachments(String uid) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            Cursor messagesCursor = null;
            try
            {
                messagesCursor = mDb.query(
                                     ""messages"",
                                     new String[] { ""id"" },
                                     ""folder_id = ? AND uid = ?"",
                                     new String[] { Long.toString(mFolderId), uid },
                                     null,
                                     null,
                                     null);
                while (messagesCursor.moveToNext())
                {
                    long messageId = messagesCursor.getLong(0);
                    Cursor attachmentsCursor = null;
                    try
                    {
                        attachmentsCursor = mDb.query(
                                                ""attachments"",
                                                new String[] { ""id"" },
                                                ""message_id = ?"",
                                                new String[] { Long.toString(messageId) },
                                                null,
                                                null,
                                                null);
                        while (attachmentsCursor.moveToNext())
                        {
                            long attachmentId = attachmentsCursor.getLong(0);
                            try
                            {
                                File file = new File(mAttachmentsDir, Long.toString(attachmentId));
                                if (file.exists())
                                {
                                    file.delete();
                                }
                            }
                            catch (Exception e)
                            {

                            }
                        }
                    }
                    finally
                    {
                        if (attachmentsCursor != null)
                        {
                            attachmentsCursor.close();
                        }
                    }
                }
            }
            finally
            {
                if (messagesCursor != null)
                {
                    messagesCursor.close();
                }
            }
        }

        /*
         * calcualteContentPreview
         * Takes a plain text message body as a string.
         * Returns a message summary as a string suitable for showing in a message list
         *
         * A message summary should be about the first 160 characters
         * of unique text written by the message sender
         * Quoted text, ""On $date"" and so on will be stripped out.
         * All newlines and whitespace will be compressed.
         *
         */
        public String calculateContentPreview(String text)
        {
            if (text == null)
            {
                return null;
            }

            text = text.replaceAll(""^.*:"","""");
            text = text.replaceAll(""(?m)^>.*$"","""");
            text = text.replaceAll(""^On .*wrote.?$"","""");
            text = text.replaceAll(""(\\r|\\n)+"","" "");
            text = text.replaceAll(""\\s+"","" "");
            if (text.length() <= 160)
            {
                return text;
            }
            else
            {
                text = text.substring(0,160);
                return text;
            }

        }

        public String markupContent(String text, String html)
        {
            if (text.length() > 0 && html.length() == 0)
            {
                html = htmlifyString(text);
            }

            if (html.indexOf(""cid:"") != -1)
            {
                return html.replaceAll(""cid:"", ""http://cid/"");
            }
            else
            {
                return html;
            }
        }

        public String htmlifyString(String text)
        {
            StringReader reader = new StringReader(text);
            StringBuilder buff = new StringBuilder(text.length() + 512);
            int c = 0;
            try
            {
                while ((c = reader.read()) != -1)
                {
                    switch (c)
                    {
                        case '&':
                            buff.append(""&amp;"");
                            break;
                        case '<':
                            buff.append(""&lt;"");
                            break;
                        case '>':
                            buff.append(""&gt;"");
                            break;
                        case '\r':
                            break;
                        default:
                            buff.append((char)c);
                    }//switch
                }
            }
            catch (IOException e)
            {
                //Should never happen
                Log.e(K9.LOG_TAG, null, e);
            }
            text = buff.toString();
            text = text.replaceAll(""\\s*([-=_]{30,}+)\\s*"",""<hr />"");
            text = text.replaceAll(""(?m)^([^\r\n]{4,}[\\s\\w,:;+/])(?:\r\n|\n|\r)(?=[a-z]\\S{0,10}[\\s\\n\\r])"",""$1 "");
            text = text.replaceAll(""(?m)(\r\n|\n|\r){4,}"",""\n\n"");

            Matcher m = Regex.WEB_URL_PATTERN.matcher(text);
            StringBuffer sb = new StringBuffer(text.length() + 512);
            sb.append(""<html><body><pre style=\""white-space: pre-wrap; word-wrap:break-word; \"">"");
            while (m.find())
            {
                int start = m.start();
                if (start == 0 || (start != 0 && text.charAt(start - 1) != '@'))
                {
                    m.appendReplacement(sb, ""<a href=\""$0\"">$0</a>"");
                }
                else
                {
                    m.appendReplacement(sb, ""$0"");
                }
            }




            m.appendTail(sb);
            sb.append(""</pre></body></html>"");
            text = sb.toString();

            return text;
        }

        @Override
        public boolean isInTopGroup()
        {
            return inTopGroup;
        }
        
        public void setInTopGroup(boolean inTopGroup)
        {
            this.inTopGroup = inTopGroup;
        }
    }

    public class LocalTextBody extends TextBody
    {
        private String mBodyForDisplay;

        public LocalTextBody(String body)
        {
            super(body);
        }

        public LocalTextBody(String body, String bodyForDisplay) throws MessagingException
        {
            super(body);
            this.mBodyForDisplay = bodyForDisplay;
        }

        public String getBodyForDisplay()
        {
            return mBodyForDisplay;
        }

        public void setBodyForDisplay(String mBodyForDisplay)
        {
            this.mBodyForDisplay = mBodyForDisplay;
        }

    }//LocalTextBody

    public class LocalMessage extends MimeMessage
    {
        private long mId;
        private int mAttachmentCount;
        private String mSubject;

        private String mPreview = """";

        private boolean mHeadersLoaded = false;
        private boolean mMessageDirty = false;

        public LocalMessage()
        {
        }

        LocalMessage(String uid, Folder folder) throws MessagingException
        {
            this.mUid = uid;
            this.mFolder = folder;
        }

        private void populateFromGetMessageCursor(Cursor cursor)
        throws MessagingException
        {
            this.setSubject(cursor.getString(0) == null ? """" : cursor.getString(0));
            Address[] from = Address.unpack(cursor.getString(1));
            if (from.length > 0)
            {
                this.setFrom(from[0]);
            }
            this.setInternalSentDate(new Date(cursor.getLong(2)));
            this.setUid(cursor.getString(3));
            String flagList = cursor.getString(4);
            if (flagList != null && flagList.length() > 0)
            {
                String[] flags = flagList.split("","");
                try
                {
                    for (String flag : flags)
                    {
                        this.setFlagInternal(Flag.valueOf(flag), true);
                    }
                }
                catch (Exception e)
                {
                }
            }
            this.mId = cursor.getLong(5);
            this.setRecipients(RecipientType.TO, Address.unpack(cursor.getString(6)));
            this.setRecipients(RecipientType.CC, Address.unpack(cursor.getString(7)));
            this.setRecipients(RecipientType.BCC, Address.unpack(cursor.getString(8)));
            this.setReplyTo(Address.unpack(cursor.getString(9)));
            this.mAttachmentCount = cursor.getInt(10);
            this.setInternalDate(new Date(cursor.getLong(11)));
            this.setMessageId(cursor.getString(12));
            mPreview = (cursor.getString(14) == null ? """" : cursor.getString(14));
            if (this.mFolder == null)
            {
                LocalFolder f = new LocalFolder(cursor.getInt(13));
                f.open(LocalFolder.OpenMode.READ_WRITE);
                this.mFolder = f;
            }
        }


        /* Custom version of writeTo that updates the MIME message based on localMessage
         * changes.
         */

        public void writeTo(OutputStream out) throws IOException, MessagingException
        {
            if (mMessageDirty) buildMimeRepresentation();
            super.writeTo(out);
        }

        private void buildMimeRepresentation() throws MessagingException
        {
            if (!mMessageDirty)
            {
                return;
            }

            super.setSubject(mSubject);
            if (this.mFrom != null && this.mFrom.length > 0)
            {
                super.setFrom(this.mFrom[0]);
            }

            super.setReplyTo(mReplyTo);
            super.setSentDate(this.getSentDate());
            super.setRecipients(RecipientType.TO, mTo);
            super.setRecipients(RecipientType.CC, mCc);
            super.setRecipients(RecipientType.BCC, mBcc);
            if (mMessageId != null) super.setMessageId(mMessageId);

            mMessageDirty = false;
            return;
        }

        public String getPreview()
        {
            return mPreview;
        }

        @Override
        public String getSubject() throws MessagingException
        {
            return mSubject;
        }


        @Override
        public void setSubject(String subject) throws MessagingException
        {
            mSubject = subject;
            mMessageDirty = true;
        }


        public void setMessageId(String messageId)
        {
            mMessageId = messageId;
            mMessageDirty = true;
        }



        public int getAttachmentCount()
        {
            return mAttachmentCount;
        }

        public void setFrom(Address from) throws MessagingException
        {
            this.mFrom = new Address[] { from };
            mMessageDirty = true;
        }


        public void setReplyTo(Address[] replyTo) throws MessagingException
        {
            if (replyTo == null || replyTo.length == 0)
            {
                mReplyTo = null;
            }
            else
            {
                mReplyTo = replyTo;
            }
            mMessageDirty = true;
        }


        /*
         * For performance reasons, we add headers instead of setting them (see super implementation)
         * which removes (expensive) them before adding them
         */
        @Override
        public void setRecipients(RecipientType type, Address[] addresses) throws MessagingException
        {
            if (type == RecipientType.TO)
            {
                if (addresses == null || addresses.length == 0)
                {
                    this.mTo = null;
                }
                else
                {
                    this.mTo = addresses;
                }
            }
            else if (type == RecipientType.CC)
            {
                if (addresses == null || addresses.length == 0)
                {
                    this.mCc = null;
                }
                else
                {
                    this.mCc = addresses;
                }
            }
            else if (type == RecipientType.BCC)
            {
                if (addresses == null || addresses.length == 0)
                {
                    this.mBcc = null;
                }
                else
                {
                    this.mBcc = addresses;
                }
            }
            else
            {
                throw new MessagingException(""Unrecognized recipient type."");
            }
            mMessageDirty = true;
        }



        public void setFlagInternal(Flag flag, boolean set) throws MessagingException
        {
            super.setFlag(flag, set);
        }

        public long getId()
        {
            return mId;
        }

        public void setFlag(Flag flag, boolean set) throws MessagingException
        {
            if (flag == Flag.DELETED && set)
            {
                /*
                 * If a message is being marked as deleted we want to clear out it's content
                 * and attachments as well. Delete will not actually remove the row since we need
                 * to retain the uid for synchronization purposes.
                 */

                /*
                 * Delete all of the messages' content to save space.
                 */
                ((LocalFolder) mFolder).deleteAttachments(getUid());

                mDb.execSQL(
                    ""UPDATE messages SET "" +
                    ""deleted = 1,"" +
                    ""subject = NULL, "" +
                    ""sender_list = NULL, "" +
                    ""date = NULL, "" +
                    ""to_list = NULL, "" +
                    ""cc_list = NULL, "" +
                    ""bcc_list = NULL, "" +
                    ""preview = NULL, "" +
                    ""html_content = NULL, "" +
                    ""text_content = NULL, "" +
                    ""reply_to_list = NULL "" +
                    ""WHERE id = ?"",
                    new Object[]
                    {
                        mId
                    });

                /*
                 * Delete all of the messages' attachments to save space.
                 */
                mDb.execSQL(""DELETE FROM attachments WHERE message_id = ?"",
                            new Object[]
                            {
                                mId
                            });

                ((LocalFolder)mFolder).deleteHeaders(mId);

            }
            else if (flag == Flag.X_DESTROYED && set)
            {
                ((LocalFolder) mFolder).deleteAttachments(getUid());
                mDb.execSQL(""DELETE FROM messages WHERE id = ?"",
                            new Object[] { mId });
                ((LocalFolder)mFolder).deleteHeaders(mId);
            }

            /*
             * Update the unread count on the folder.
             */
            try
            {
                if (flag == Flag.DELETED || flag == Flag.X_DESTROYED
                        || (flag == Flag.SEEN && !isSet(Flag.DELETED)))
                {
                    LocalFolder folder = (LocalFolder)mFolder;
                    if (set && !isSet(Flag.SEEN))
                    {
                        folder.setUnreadMessageCount(folder.getUnreadMessageCount() - 1);
                    }
                    else if (!set && isSet(Flag.SEEN))
                    {
                        folder.setUnreadMessageCount(folder.getUnreadMessageCount() + 1);
                    }
                }
            }
            catch (MessagingException me)
            {
                Log.e(K9.LOG_TAG, ""Unable to update LocalStore unread message count"",
                      me);
                throw new RuntimeException(me);
            }

            super.setFlag(flag, set);
            /*
             * Set the flags on the message.
             */
            mDb.execSQL(""UPDATE messages "" + ""SET flags = ? "" + "" WHERE id = ?"", new Object[]
                        {
                            Utility.combine(getFlags(), ',').toUpperCase(), mId
                        });
        }


        private void loadHeaders()
        {
            ArrayList<LocalMessage> messages = new ArrayList<LocalMessage>();
            messages.add(this);
            mHeadersLoaded = true; // set true before calling populate headers to stop recursion
            ((LocalFolder) mFolder).populateHeaders(messages);

        }

        public void addHeader(String name, String value)
        {
            if (!mHeadersLoaded)
            {
                loadHeaders();
            }
            super.addHeader(name, value);
        }

        public void setHeader(String name, String value)
        {
            if (!mHeadersLoaded)
                loadHeaders();
            super.setHeader(name, value);
        }

        public String[] getHeader(String name)
        {
            if (!mHeadersLoaded)
                loadHeaders();

            return super.getHeader(name);
        }

        public void removeHeader(String name)
        {
            if (!mHeadersLoaded)
                loadHeaders();
            super.removeHeader(name);
        }



    }

    public class LocalAttachmentBodyPart extends MimeBodyPart
    {
        private long mAttachmentId = -1;

        public LocalAttachmentBodyPart(Body body, long attachmentId) throws MessagingException
        {
            super(body);
            mAttachmentId = attachmentId;
        }

        /**
         * Returns the local attachment id of this body, or -1 if it is not stored.
         * @return
         */
        public long getAttachmentId()
        {
            return mAttachmentId;
        }

        public void setAttachmentId(long attachmentId)
        {
            mAttachmentId = attachmentId;
        }

        public String toString()
        {
            return """" + mAttachmentId;
        }
    }

    public static class LocalAttachmentBody implements Body
    {
        private Application mApplication;
        private Uri mUri;

        public LocalAttachmentBody(Uri uri, Application application)
        {
            mApplication = application;
            mUri = uri;
        }

        public InputStream getInputStream() throws MessagingException
        {
            try
            {
                return mApplication.getContentResolver().openInputStream(mUri);
            }
            catch (FileNotFoundException fnfe)
            {
                /*
                 * Since it's completely normal for us to try to serve up attachments that
                 * have been blown away, we just return an empty stream.
                 */
                return new ByteArrayInputStream(new byte[0]);
            }
            catch (IOException ioe)
            {
                throw new MessagingException(""Invalid attachment."", ioe);
            }
        }

        public void writeTo(OutputStream out) throws IOException, MessagingException
        {
            InputStream in = getInputStream();
            Base64OutputStream base64Out = new Base64OutputStream(out);
            IOUtils.copy(in, base64Out);
            base64Out.close();
        }

        public Uri getContentUri()
        {
            return mUri;
        }
    }
}
",True,189,0,0,7,49,10,27,L1
98,com.fsck.k9.mail.store.TrustManagerFactory.java,"
package com.fsck.k9.mail.store;

import android.app.Application;
import android.content.Context;
import android.net.http.DomainNameChecker;
import android.util.Log;
import com.fsck.k9.K9;

import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

public final class TrustManagerFactory
{
    private static final String LOG_TAG = ""TrustManagerFactory"";

    private static X509TrustManager defaultTrustManager;
    private static X509TrustManager unsecureTrustManager;
    private static X509TrustManager localTrustManager;

    private static X509Certificate[] lastCertChain = null;

    private static File keyStoreFile;
    private static KeyStore keyStore;


    private static class SimpleX509TrustManager implements X509TrustManager
    {
        public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException
        {
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException
        {
        }

        public X509Certificate[] getAcceptedIssuers()
        {
            return null;
        }
    }

    private static class SecureX509TrustManager implements X509TrustManager
    {
        private String mHost;
        private static SecureX509TrustManager me;

        private SecureX509TrustManager()
        {
        }

        public static X509TrustManager getInstance(String host)
        {
            if (me == null)
            {
                me = new SecureX509TrustManager();
            }
            me.mHost = host;
            return me;
        }

        public void setHost(String host)
        {
            mHost = host;
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException
        {
            defaultTrustManager.checkClientTrusted(chain, authType);
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException
        {
            TrustManagerFactory.setLastCertChain(chain);
            try
            {
                defaultTrustManager.checkServerTrusted(chain, authType);
            }
            catch (CertificateException e)
            {
                localTrustManager.checkServerTrusted(new X509Certificate[] {chain[0]}, authType);
            }
            if (!DomainNameChecker.match(chain[0], mHost))
            {
                try
                {
                    String dn = chain[0].getSubjectDN().toString();
                    if ((dn != null) && (dn.equalsIgnoreCase(keyStore.getCertificateAlias(chain[0]))))
                    {
                        return;
                    }
                }
                catch (KeyStoreException e)
                {
                    throw new CertificateException(""Certificate cannot be verified; KeyStore Exception: "" + e);
                }
                throw new CertificateException(""Certificate domain name does not match ""
                                               + mHost);
            }
        }

        public X509Certificate[] getAcceptedIssuers()
        {
            return defaultTrustManager.getAcceptedIssuers();
        }

    }

    static
    {
        try
        {
            javax.net.ssl.TrustManagerFactory tmf = javax.net.ssl.TrustManagerFactory.getInstance(""X509"");
            Application app = K9.app;
            keyStoreFile = new File(app.getDir(""KeyStore"", Context.MODE_PRIVATE) + File.separator + ""KeyStore.bks"");
            keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            java.io.FileInputStream fis;
            try
            {
                fis = new java.io.FileInputStream(keyStoreFile);
            }
            catch (FileNotFoundException e1)
            {
                fis = null;
            }
            try
            {
                keyStore.load(fis, """".toCharArray());
                //if (fis != null) {
                // fis.close();
                //}
            }
            catch (IOException e)
            {
                Log.e(LOG_TAG, ""KeyStore IOException while initializing TrustManagerFactory "", e);
                keyStore = null;
            }
            catch (CertificateException e)
            {
                Log.e(LOG_TAG, ""KeyStore CertificateException while initializing TrustManagerFactory "", e);
                keyStore = null;
            }
            tmf.init(keyStore);
            TrustManager[] tms = tmf.getTrustManagers();
            if (tms != null)
            {
                for (TrustManager tm : tms)
                {
                    if (tm instanceof X509TrustManager)
                    {
                        localTrustManager = (X509TrustManager)tm;
                        break;
                    }
                }
            }
            tmf = javax.net.ssl.TrustManagerFactory.getInstance(""X509"");
            tmf.init((KeyStore)null);
            tms = tmf.getTrustManagers();
            if (tms != null)
            {
                for (TrustManager tm : tms)
                {
                    if (tm instanceof X509TrustManager)
                    {
                        defaultTrustManager = (X509TrustManager) tm;
                        break;
                    }
                }
            }

        }
        catch (NoSuchAlgorithmException e)
        {
            Log.e(LOG_TAG, ""Unable to get X509 Trust Manager "", e);
        }
        catch (KeyStoreException e)
        {
            Log.e(LOG_TAG, ""Key Store exception while initializing TrustManagerFactory "", e);
        }
        unsecureTrustManager = new SimpleX509TrustManager();
    }

    private TrustManagerFactory()
    {
    }

    public static X509TrustManager get(String host, boolean secure)
    {
        return secure ? SecureX509TrustManager.getInstance(host) :
               unsecureTrustManager;
    }

    public static KeyStore getKeyStore()
    {
        return keyStore;
    }

    public static void setLastCertChain(X509Certificate[] chain)
    {
        lastCertChain = chain;
    }
    public static X509Certificate[] getLastCertChain()
    {
        return lastCertChain;
    }

    public static void addCertificateChain(String alias, X509Certificate[] chain) throws CertificateException
    {
        try
        {
            javax.net.ssl.TrustManagerFactory tmf = javax.net.ssl.TrustManagerFactory.getInstance(""X509"");
            for (int i = 0; i < chain.length; i++)
            {
                keyStore.setCertificateEntry
                (chain[i].getSubjectDN().toString(), chain[i]);
            }

            tmf.init(keyStore);
            TrustManager[] tms = tmf.getTrustManagers();
            if (tms != null)
            {
                for (TrustManager tm : tms)
                {
                    if (tm instanceof X509TrustManager)
                    {
                        localTrustManager = (X509TrustManager) tm;
                        break;
                    }
                }
            }
            java.io.FileOutputStream keyStoreStream;
            try
            {
                keyStoreStream = new java.io.FileOutputStream(keyStoreFile);
                keyStore.store(keyStoreStream, """".toCharArray());
                keyStoreStream.close();
            }
            catch (FileNotFoundException e)
            {
                throw new CertificateException(""Unable to write KeyStore: "" + e.getMessage());
            }
            catch (CertificateException e)
            {
                throw new CertificateException(""Unable to write KeyStore: "" + e.getMessage());
            }
            catch (IOException e)
            {
                throw new CertificateException(""Unable to write KeyStore: "" + e.getMessage());
            }

        }
        catch (NoSuchAlgorithmException e)
        {
            Log.e(LOG_TAG, ""Unable to get X509 Trust Manager "", e);
        }
        catch (KeyStoreException e)
        {
            Log.e(LOG_TAG, ""Key Store exception while initializing TrustManagerFactory "", e);
        }
    }
}
",True,189,0,0,9,51,5,2,L1
99,com.fsck.k9.mail.store.ImapStore.java,"
package com.fsck.k9.mail.store;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.util.Log;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.PeekableInputStream;
import com.fsck.k9.Utility;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.internet.*;
import com.fsck.k9.mail.store.ImapResponseParser.ImapList;
import com.fsck.k9.mail.store.ImapResponseParser.ImapResponse;
import com.fsck.k9.mail.transport.CountingOutputStream;
import com.fsck.k9.mail.transport.EOLConvertingOutputStream;
import com.jcraft.jzlib.JZlib;
import com.jcraft.jzlib.ZInputStream;
import com.jcraft.jzlib.ZOutputStream;
import com.beetstra.jutf7.CharsetProvider;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.TrustManager;


import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.binary.Hex;

import java.io.*;
import java.net.*;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.Security;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * <pre>
 * TODO Need to start keeping track of UIDVALIDITY
 * TODO Need a default response handler for things like folder updates
 * TODO In fetch(), if we need a ImapMessage and were given
 * something else we can try to do a pre-fetch first.
 * </pre>
 */
public class ImapStore extends Store
{
    public static final int CONNECTION_SECURITY_NONE = 0;
    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

    private enum AuthType { PLAIN, CRAM_MD5 };

    private static final int IDLE_READ_TIMEOUT = 29 * 60 * 1000; // 29 minutes
    private static final int IDLE_REFRESH_INTERVAL = 20 * 60 * 1000; // 20 minutes

    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED, Flag.SEEN };

    private static final String CAPABILITY_IDLE = ""IDLE"";
    private static final String COMMAND_IDLE = ""IDLE"";
    private static final String CAPABILITY_NAMESPACE = ""NAMESPACE"";
    private static final String COMMAND_NAMESPACE = ""NAMESPACE"";

    private static final String CAPABILITY_CAPABILITY = ""CAPABILITY"";
    private static final String COMMAND_CAPABILITY = ""CAPABILITY"";
    
    private static final String CAPABILITY_COMPRESS_DEFLATE = ""COMPRESS=DEFLATE"";
    private static final String COMMAND_COMPRESS_DEFLATE = ""COMPRESS DEFLATE"";

    private String mHost;
    private int mPort;
    private String mUsername;
    private String mPassword;
    private int mConnectionSecurity;
    private AuthType mAuthType;
    private volatile String mPathPrefix;
    private volatile String mCombinedPrefix = null;
    private volatile String mPathDelimeter;

    private LinkedList<ImapConnection> mConnections =
        new LinkedList<ImapConnection>();

    /**
     * Charset used for converting folder names to and from UTF-7 as defined by RFC 3501.
     */
    private Charset mModifiedUtf7Charset;

    /**
     * Cache of ImapFolder objects. ImapFolders are attached to a given folder on the server
     * and as long as their associated connection remains open they are reusable between
     * requests. This cache lets us make sure we always reuse, if possible, for a given
     * folder name.
     */
    private HashMap<String, ImapFolder> mFolderCache = new HashMap<String, ImapFolder>();

    /**
     * imap://auth:user:password@server:port CONNECTION_SECURITY_NONE
     * imap+tls://auth:user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * imap+tls+://auth:user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * imap+ssl+://auth:user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * imap+ssl://auth:user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     *
     * @param _uri
     */
    public ImapStore(Account account) throws MessagingException
    {
        super(account);
        URI uri;
        try
        {
            uri = new URI(mAccount.getStoreUri());
        }
        catch (URISyntaxException use)
        {
            throw new MessagingException(""Invalid ImapStore URI"", use);
        }

        String scheme = uri.getScheme();
        if (scheme.equals(""imap""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_NONE;
            mPort = 143;
        }
        else if (scheme.equals(""imap+tls""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
            mPort = 143;
        }
        else if (scheme.equals(""imap+tls+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
            mPort = 143;
        }
        else if (scheme.equals(""imap+ssl+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
            mPort = 993;
        }
        else if (scheme.equals(""imap+ssl""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
            mPort = 993;
        }
        else
        {
            throw new MessagingException(""Unsupported protocol"");
        }

        mHost = uri.getHost();

        if (uri.getPort() != -1)
        {
            mPort = uri.getPort();
        }

        if (uri.getUserInfo() != null)
        {
            try
            {
                String[] userInfoParts = uri.getUserInfo().split("":"");
                if (userInfoParts.length == 2)
                {
                    mAuthType = AuthType.PLAIN;
                    mUsername = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                    mPassword = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
                else
                {
                    mAuthType = AuthType.valueOf(userInfoParts[0]);
                    mUsername = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                    mPassword = URLDecoder.decode(userInfoParts[2], ""UTF-8"");
                }
            }
            catch (UnsupportedEncodingException enc)
            {
                // This shouldn't happen since the encoding is hardcoded to UTF-8
                Log.e(K9.LOG_TAG, ""Couldn't urldecode username or password."", enc);
            }
        }

        if ((uri.getPath() != null) && (uri.getPath().length() > 0))
        {
            mPathPrefix = uri.getPath().substring(1);
            if (mPathPrefix != null && mPathPrefix.trim().length() == 0)
            {
                mPathPrefix = null;
            }
        }

        mModifiedUtf7Charset = new CharsetProvider().charsetForName(""X-RFC-3501"");
    }

    @Override
    public Folder getFolder(String name) throws MessagingException
    {
        ImapFolder folder;
        synchronized (mFolderCache)
        {
            folder = mFolderCache.get(name);
            if (folder == null)
            {
                folder = new ImapFolder(this, name);
                mFolderCache.put(name, folder);
            }
        }
        return folder;
    }

    private String getCombinedPrefix()
    {
        if (mCombinedPrefix == null)
        {
            if (mPathPrefix != null)
            {
                String tmpPrefix = mPathPrefix.trim();
                String tmpDelim = (mPathDelimeter != null ? mPathDelimeter.trim() : """");
                if (tmpPrefix.endsWith(tmpDelim))
                {
                    mCombinedPrefix = tmpPrefix;
                }
                else if (tmpPrefix.length() > 0)
                {
                    mCombinedPrefix = tmpPrefix + tmpDelim;
                }
                else
                {
                    mCombinedPrefix = """";
                }
            }
            else
            {
                mCombinedPrefix = """";
            }
        }
        return mCombinedPrefix;
    }

    @Override
    public Folder[] getPersonalNamespaces() throws MessagingException
    {
        ImapConnection connection = getConnection();
        try
        {
            ArrayList<Folder> folders = new ArrayList<Folder>();

            List<ImapResponse> responses =
                connection.executeSimpleCommand(String.format(""LIST \""\"" \""%s*\"""",
                                                getCombinedPrefix()));

            for (ImapResponse response : responses)
            {
                if (response.get(0).equals(""LIST""))
                {
                    boolean includeFolder = true;
                    String folder = decodeFolderName(response.getString(3));

                    if (mPathDelimeter == null)
                    {
                        mPathDelimeter = response.getString(2);
                        mCombinedPrefix = null;
                    }

                    if (folder.equalsIgnoreCase(K9.INBOX))
                    {
                        continue;
                    }
                    else
                    {

                        if (getCombinedPrefix().length() > 0)
                        {
                            if (folder.length() >= getCombinedPrefix().length())
                            {
                                folder = folder.substring(getCombinedPrefix().length());
                            }
                            if (!decodeFolderName(response.getString(3)).equals(getCombinedPrefix() + folder))
                            {
                                includeFolder = false;
                            }
                        }
                    }

                    ImapList attributes = response.getList(1);
                    for (int i = 0, count = attributes.size(); i < count; i++)
                    {
                        String attribute = attributes.getString(i);
                        if (attribute.equalsIgnoreCase(""\\NoSelect""))
                        {
                            includeFolder = false;
                        }
                    }
                    if (includeFolder)
                    {
                        folders.add(getFolder(folder));
                    }
                }
            }
            folders.add(getFolder(""INBOX""));
            return folders.toArray(new Folder[] {});
        }
        catch (IOException ioe)
        {
            connection.close();
            throw new MessagingException(""Unable to get folder list."", ioe);
        }
        finally
        {
            releaseConnection(connection);
        }
    }

    @Override
    public void checkSettings() throws MessagingException
    {
        try
        {
            ImapConnection connection = new ImapConnection();
            connection.open();
            connection.close();
        }
        catch (IOException ioe)
        {
            throw new MessagingException(""Unable to connect."", ioe);
        }
    }

    /**
     * Gets a connection if one is available for reuse, or creates a new one if not.
     * @return
     */
    private ImapConnection getConnection() throws MessagingException
    {
        synchronized (mConnections)
        {
            ImapConnection connection = null;
            while ((connection = mConnections.poll()) != null)
            {
                try
                {
                    connection.executeSimpleCommand(""NOOP"");
                    break;
                }
                catch (IOException ioe)
                {
                    connection.close();
                }
            }
            if (connection == null)
            {
                connection = new ImapConnection();
            }
            return connection;
        }
    }

    private void releaseConnection(ImapConnection connection)
    {
        if (connection != null && connection.isOpen())
        {
            synchronized (mConnections)
            {
                mConnections.offer(connection);
            }
        }
    }

    private String encodeFolderName(String name)
    {
        try
        {
            ByteBuffer bb = mModifiedUtf7Charset.encode(name);
            byte[] b = new byte[bb.limit()];
            bb.get(b);
            return new String(b, ""US-ASCII"");
        }
        catch (UnsupportedEncodingException uee)
        {
            /*
             * The only thing that can throw this is getBytes(""US-ASCII"") and if US-ASCII doesn't
             * exist we're totally screwed.
             */
            throw new RuntimeException(""Unable to encode folder name: "" + name, uee);
        }
    }

    private String decodeFolderName(String name)
    {
        /*
         * Convert the encoded name to US-ASCII, then pass it through the modified UTF-7
         * decoder and return the Unicode String.
         */
        try
        {
            byte[] encoded = name.getBytes(""US-ASCII"");
            CharBuffer cb = mModifiedUtf7Charset.decode(ByteBuffer.wrap(encoded));
            return cb.toString();
        }
        catch (UnsupportedEncodingException uee)
        {
            /*
             * The only thing that can throw this is getBytes(""US-ASCII"") and if US-ASCII doesn't
             * exist we're totally screwed.
             */
            throw new RuntimeException(""Unable to decode folder name: "" + name, uee);
        }
    }

    @Override
    public boolean isMoveCapable()
    {
        return true;
    }

    @Override
    public boolean isCopyCapable()
    {
        return true;
    }
    @Override
    public boolean isPushCapable()
    {
        return true;
    }
    @Override
    public boolean isExpungeCapable()
    {
        return true;
    }


    class ImapFolder extends Folder
    {
        private String mName;
        protected int mMessageCount = -1;
        protected int uidNext = -1;
        protected ImapConnection mConnection;
        private OpenMode mMode;
        private boolean mExists;
        private ImapStore store = null;

        public ImapFolder(ImapStore nStore, String name)
        {
            super(nStore.getAccount());
            store = nStore;
            this.mName = name;
        }

        public String getPrefixedName()
        {
            String prefixedName = """";
            if (!K9.INBOX.equalsIgnoreCase(mName))
            {
                prefixedName = getCombinedPrefix();
            }

            prefixedName += mName;
            return prefixedName;
        }

        protected List<ImapResponse> executeSimpleCommand(String command) throws MessagingException, IOException
        {
            return handleUntaggedResponses(mConnection.executeSimpleCommand(command));
        }

        protected List<ImapResponse> executeSimpleCommand(String command, boolean sensitve, UntaggedHandler untaggedHandler) throws MessagingException, IOException
        {
            return handleUntaggedResponses(mConnection.executeSimpleCommand(command, sensitve, untaggedHandler));
        }

        public void open(OpenMode mode) throws MessagingException
        {
            internalOpen(mode);

            if (mMessageCount == -1)
            {
                throw new MessagingException(
                    ""Did not find message count during open"");
            }
        }

        public List<ImapResponse> internalOpen(OpenMode mode) throws MessagingException
        {
            if (isOpen() && mMode == mode)
            {
                // Make sure the connection is valid. If it's not we'll close it down and continue
                // on to get a new one.
                try
                {
                    List<ImapResponse> responses = executeSimpleCommand(""NOOP"");
                    return responses;
                }
                catch (IOException ioe)
                {
                    ioExceptionHandler(mConnection, ioe);
                }
            }
            releaseConnection(mConnection);
            synchronized (this)
            {
                mConnection = getConnection();
            }
            // * FLAGS (\Answered \Flagged \Deleted \Seen \Draft NonJunk
            // $MDNSent)
            // * OK [PERMANENTFLAGS (\Answered \Flagged \Deleted \Seen \Draft
            // NonJunk $MDNSent \*)] Flags permitted.
            // * 23 EXISTS
            // * 0 RECENT
            // * OK [UIDVALIDITY 1125022061] UIDs valid
            // * OK [UIDNEXT 57576] Predicted next UID
            // 2 OK [READ-WRITE] Select completed.
            try
            {
                String command = String.format((mode == OpenMode.READ_WRITE ? ""SELECT"" : ""EXAMINE"") + "" \""%s\"""",
                                               encodeFolderName(getPrefixedName()));

                List<ImapResponse> responses = executeSimpleCommand(command);

                /*
                 * If the command succeeds we expect the folder has been opened read-write
                 * unless we are notified otherwise in the responses.
                 */
                mMode = mode;

                for (ImapResponse response : responses)
                {
                    if (response.mTag != null && response.size() >= 2)
                    {
                        Object bracketedObj = response.get(1);
                        if (bracketedObj instanceof ImapList)
                        {
                            ImapList bracketed = (ImapList)bracketedObj;

                            if (bracketed.size() > 0)
                            {
                                Object keyObj = bracketed.get(0);
                                if (keyObj instanceof String)
                                {
                                    String key = (String)keyObj;

                                    if (""READ-ONLY"".equalsIgnoreCase(key))
                                    {
                                        mMode = OpenMode.READ_ONLY;
                                    }
                                    else if (""READ-WRITE"".equalsIgnoreCase(key))
                                    {
                                        mMode = OpenMode.READ_WRITE;
                                    }
                                }
                            }
                        }

                    }
                }

                mExists = true;
                return responses;
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
            catch (MessagingException me)
            {
                Log.e(K9.LOG_TAG, ""Unable to open connection for "" + getLogId(), me);
                throw me;
            }

        }

        public boolean isOpen()
        {
            return mConnection != null;
        }

        @Override
        public OpenMode getMode() throws MessagingException
        {
            return mMode;
        }

        public void close()
        {
            if (mMessageCount != -1)
            {
                mMessageCount = -1;
            }
            if (!isOpen())
            {
                return;
            }

            synchronized (this)
            {
                releaseConnection(mConnection);
                mConnection = null;
            }
        }

        public String getName()
        {
            return mName;
        }

        private boolean exists(String folderName) throws MessagingException
        {
            try
            {
                // Since we don't care about RECENT, we'll use that for the check, because we're checking
                // a folder other than ourself, and don't want any untagged responses to cause a change
                // in our own fields
                mConnection.executeSimpleCommand(String.format(""STATUS \""%s\"" (RECENT)"", folderName));
                return true;
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
            catch (MessagingException me)
            {
                return false;
            }
        }

        public boolean exists() throws MessagingException
        {
            if (mExists)
            {
                return true;
            }
            /*
             * This method needs to operate in the unselected mode as well as the selected mode
             * so we must get the connection ourselves if it's not there. We are specifically
             * not calling checkOpen() since we don't care if the folder is open.
             */
            ImapConnection connection = null;
            synchronized (this)
            {
                if (mConnection == null)
                {
                    connection = getConnection();
                }
                else
                {
                    connection = mConnection;
                }
            }
            try
            {
                connection.executeSimpleCommand(String.format(""STATUS \""%s\"" (UIDVALIDITY)"",
                                                encodeFolderName(getPrefixedName())));
                mExists = true;
                return true;
            }
            catch (MessagingException me)
            {
                return false;
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(connection, ioe);
            }
            finally
            {
                if (mConnection == null)
                {
                    releaseConnection(connection);
                }
            }
        }

        public boolean create(FolderType type) throws MessagingException
        {
            /*
             * This method needs to operate in the unselected mode as well as the selected mode
             * so we must get the connection ourselves if it's not there. We are specifically
             * not calling checkOpen() since we don't care if the folder is open.
             */
            ImapConnection connection = null;
            synchronized (this)
            {
                if (mConnection == null)
                {
                    connection = getConnection();
                }
                else
                {
                    connection = mConnection;
                }
            }
            try
            {
                connection.executeSimpleCommand(String.format(""CREATE \""%s\"""",
                                                encodeFolderName(getPrefixedName())));
                return true;
            }
            catch (MessagingException me)
            {
                return false;
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
            finally
            {
                if (mConnection == null)
                {
                    releaseConnection(connection);
                }
            }
        }

        @Override
        public void copyMessages(Message[] messages, Folder folder) throws MessagingException
        {
            if (folder instanceof ImapFolder == false)
            {
                throw new MessagingException(""ImapFolder.copyMessages passed non-ImapFolder"");
            }

            if (messages.length == 0)
                return;

            ImapFolder iFolder = (ImapFolder)folder;
            checkOpen();
            String[] uids = new String[messages.length];
            for (int i = 0, count = messages.length; i < count; i++)
            {
                uids[i] = messages[i].getUid();
            }
            try
            {
                String remoteDestName = encodeFolderName(iFolder.getPrefixedName());

                if (!exists(remoteDestName))
                {
                    /*
                     * If the remote trash folder doesn't exist we try to create it.
                     */
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""IMAPMessage.copyMessages: attempting to create remote '"" + remoteDestName + ""' folder for "" + getLogId());
                    iFolder.create(FolderType.HOLDS_MESSAGES);
                }

                if (exists(remoteDestName))
                {
                    executeSimpleCommand(String.format(""UID COPY %s \""%s\"""",
                                                       Utility.combine(uids, ','),
                                                       encodeFolderName(iFolder.getPrefixedName())));
                }
                else
                {
                    throw new MessagingException(""IMAPMessage.copyMessages: remote destination folder "" + folder.getName()
                                                 + "" does not exist and could not be created for "" + getLogId()
                                                 , true);
                }
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        @Override
        public void moveMessages(Message[] messages, Folder folder) throws MessagingException
        {
            if (messages.length == 0)
                return;
            copyMessages(messages, folder);
            setFlags(messages, new Flag[] { Flag.DELETED }, true);
        }

        public void delete(Message[] messages, String trashFolderName) throws MessagingException
        {
            if (messages.length == 0)
                return;

            if (trashFolderName == null || getName().equals(trashFolderName))
            {
                setFlags(messages, new Flag[] { Flag.DELETED }, true);
            }
            else
            {
                ImapFolder remoteTrashFolder = (ImapFolder)getStore().getFolder(trashFolderName);
                String remoteTrashName = encodeFolderName(remoteTrashFolder.getPrefixedName());

                if (!exists(remoteTrashName))
                {
                    /*
                     * If the remote trash folder doesn't exist we try to create it.
                     */
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""IMAPMessage.delete: attempting to create remote '"" + trashFolderName + ""' folder for "" + getLogId());
                    remoteTrashFolder.create(FolderType.HOLDS_MESSAGES);
                }

                if (exists(remoteTrashName))
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""IMAPMessage.delete: copying remote "" + messages.length + "" messages to '"" + trashFolderName + ""' for "" + getLogId());

                    moveMessages(messages, remoteTrashFolder);
                }
                else
                {
                    throw new MessagingException(""IMAPMessage.delete: remote Trash folder "" + trashFolderName + "" does not exist and could not be created for "" + getLogId()
                                                 , true);
                }
            }
        }


        @Override
        public int getMessageCount()
        {
            return mMessageCount;
        }

        @Override
        public int getUnreadMessageCount() throws MessagingException
        {
            checkOpen();
            try
            {
                int count = 0;
                int start = mMessageCount - 299;
                if (start < 1)
                {
                    start = 1;
                }
                List<ImapResponse> responses = executeSimpleCommand(String.format(""SEARCH %d:* UNSEEN NOT DELETED"", start));
                for (ImapResponse response : responses)
                {
                    if (response.get(0).equals(""SEARCH""))
                    {
                        count += response.size() - 1;
                    }
                }
                return count;
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        @Override
        public void delete(boolean recurse) throws MessagingException
        {
            throw new Error(""ImapStore.delete() not yet implemented"");
        }

        @Override
        public Message getMessage(String uid) throws MessagingException
        {
            return new ImapMessage(uid, this);
        }


        @Override
        public Message[] getMessages(int start, int end, MessageRetrievalListener listener)
        throws MessagingException
        {
            return getMessages(start, end, false, listener);
        }

        protected Message[] getMessages(final int start, final int end, final boolean includeDeleted, final MessageRetrievalListener listener)
        throws MessagingException
        {
            if (start < 1 || end < 1 || end < start)
            {
                throw new MessagingException(
                    String.format(""Invalid message set %d %d"",
                                  start, end));
            }
            ImapSearcher searcher = new ImapSearcher()
            {
                public List<ImapResponse> search() throws IOException, MessagingException
                {
                    return executeSimpleCommand(String.format(""UID SEARCH %d:%d"" + (includeDeleted ? """" : "" NOT DELETED""), start, end));
                }
            };
            return search(searcher, listener);

        }
        protected Message[] getMessages(final List<Integer> mesgSeqs, final boolean includeDeleted, final MessageRetrievalListener listener)
        throws MessagingException
        {
            ImapSearcher searcher = new ImapSearcher()
            {
                public List<ImapResponse> search() throws IOException, MessagingException
                {
                    return executeSimpleCommand(String.format(""UID SEARCH %s"" + (includeDeleted ? """" : "" NOT DELETED""), Utility.combine(mesgSeqs.toArray(), ',')));
                }
            };
            return search(searcher, listener);
        }
        
        private Message[] search(ImapSearcher searcher, MessageRetrievalListener listener) throws MessagingException
        {

            checkOpen();
            ArrayList<Message> messages = new ArrayList<Message>();
            try
            {
                ArrayList<Integer> uids = new ArrayList<Integer>();
                List<ImapResponse> responses = searcher.search(); //
                for (ImapResponse response : responses)
                {
                    if (response.mTag == null)
                    {
                        if (response.get(0).equals(""SEARCH""))
                        {
                            for (int i = 1, count = response.size(); i < count; i++)
                            {
                                uids.add(Integer.parseInt(response.getString(i)));
                            }
                        }
                    }
                }

                // Sort the uids in numerically ascending order
                Collections.sort(uids);
                for (int i = 0, count = uids.size(); i < count; i++)
                {
                    if (listener != null)
                    {
                        listener.messageStarted("""" + uids.get(i), i, count);
                    }
                    ImapMessage message = new ImapMessage("""" + uids.get(i), this);
                    messages.add(message);
                    if (listener != null)
                    {
                        listener.messageFinished(message, i, count);
                    }
                }
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
            return messages.toArray(new Message[] {});
        }


        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException
        {
            return getMessages(null, listener);
        }

        public Message[] getMessages(String[] uids, MessageRetrievalListener listener)
        throws MessagingException
        {
            checkOpen();
            ArrayList<Message> messages = new ArrayList<Message>();
            try
            {
                if (uids == null)
                {
                    List<ImapResponse> responses = executeSimpleCommand(""UID SEARCH 1:* NOT DELETED"");
                    ArrayList<String> tempUids = new ArrayList<String>();
                    for (ImapResponse response : responses)
                    {
                        if (response.get(0).equals(""SEARCH""))
                        {
                            for (int i = 1, count = response.size(); i < count; i++)
                            {
                                tempUids.add(response.getString(i));
                            }
                        }
                    }
                    uids = tempUids.toArray(new String[] {});
                }
                for (int i = 0, count = uids.length; i < count; i++)
                {
                    if (listener != null)
                    {
                        listener.messageStarted(uids[i], i, count);
                    }
                    ImapMessage message = new ImapMessage(uids[i], this);
                    messages.add(message);
                    if (listener != null)
                    {
                        listener.messageFinished(message, i, count);
                    }
                }
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
            return messages.toArray(new Message[] {});
        }

        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
        throws MessagingException
        {
            if (messages == null || messages.length == 0)
            {
                return;
            }
            checkOpen();
            String[] uids = new String[messages.length];
            HashMap<String, Message> messageMap = new HashMap<String, Message>();
            for (int i = 0, count = messages.length; i < count; i++)
            {
                uids[i] = messages[i].getUid();
                messageMap.put(uids[i], messages[i]);
            }

            /*
             * Figure out what command we are going to run:
             * Flags - UID FETCH (FLAGS)
             * Envelope - UID FETCH ([FLAGS] INTERNALDATE UID RFC822.SIZE FLAGS BODY.PEEK[HEADER.FIELDS (date subject from content-type to cc)])
             *
             */
            LinkedHashSet<String> fetchFields = new LinkedHashSet<String>();
            fetchFields.add(""UID"");
            if (fp.contains(FetchProfile.Item.FLAGS))
            {
                fetchFields.add(""FLAGS"");
            }
            if (fp.contains(FetchProfile.Item.ENVELOPE))
            {
                fetchFields.add(""INTERNALDATE"");
                fetchFields.add(""RFC822.SIZE"");
                fetchFields.add(""BODY.PEEK[HEADER.FIELDS (date subject from content-type to cc reply-to ""
                                + K9.K9MAIL_IDENTITY + "")]"");
            }
            if (fp.contains(FetchProfile.Item.STRUCTURE))
            {
                fetchFields.add(""BODYSTRUCTURE"");
            }
            if (fp.contains(FetchProfile.Item.BODY_SANE))
            {
                fetchFields.add(String.format(""BODY.PEEK[]<0.%d>"", FETCH_BODY_SANE_SUGGESTED_SIZE));
            }
            if (fp.contains(FetchProfile.Item.BODY))
            {
                fetchFields.add(""BODY.PEEK[]"");
            }
            for (Object o : fp)
            {
                if (o != null && o instanceof Part)
                {
                    Part part = (Part) o;
                    String partId = part.getHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA)[0];
                    if (""TEXT"".equals(partId))
                    {
                        fetchFields.add(String.format(""BODY.PEEK[TEXT]<0.%d>"", FETCH_BODY_SANE_SUGGESTED_SIZE));
                    }
                    else
                    {
                        fetchFields.add(""BODY.PEEK["" + partId + ""]"");
                    }
                }
            }

            try
            {
                mConnection.sendCommand(String.format(""UID FETCH %s (%s)"",
                                                      Utility.combine(uids, ','),
                                                      Utility.combine(fetchFields.toArray(new String[fetchFields.size()]), ' ')
                                                     ), false);
                ImapResponse response;
                int messageNumber = 0;
                do
                {
                    response = mConnection.readResponse();
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""response for fetch: "" + response + "" for "" + getLogId());

                    if (response.mTag == null && response.get(1).equals(""FETCH""))
                    {
                        ImapList fetchList = (ImapList)response.getKeyedValue(""FETCH"");
                        String uid = fetchList.getKeyedString(""UID"");

                        Message message = messageMap.get(uid);
                        if (message == null)
                        {
                            if (K9.DEBUG)
                                Log.d(K9.LOG_TAG, ""Do not have message in messageMap for UID "" + uid + "" for "" + getLogId());

                            handleUntaggedResponse(response);
                            continue;
                        }
                        if (listener != null)
                        {
                            listener.messageStarted(uid, messageNumber++, messageMap.size());
                        }

                        ImapMessage imapMessage = (ImapMessage) message;

                        if (fetchList.containsKey(""FLAGS""))
                        {
                            ImapList flags = fetchList.getKeyedList(""FLAGS"");
                            if (flags != null)
                            {
                                for (int i = 0, count = flags.size(); i < count; i++)
                                {
                                    String flag = flags.getString(i);
                                    if (flag.equals(""\\Deleted""))
                                    {
                                        imapMessage.setFlagInternal(Flag.DELETED, true);
                                    }
                                    else if (flag.equals(""\\Answered""))
                                    {
                                        imapMessage.setFlagInternal(Flag.ANSWERED, true);
                                    }
                                    else if (flag.equals(""\\Seen""))
                                    {
                                        imapMessage.setFlagInternal(Flag.SEEN, true);
                                    }
                                    else if (flag.equals(""\\Flagged""))
                                    {
                                        imapMessage.setFlagInternal(Flag.FLAGGED, true);
                                    }
                                }
                            }
                        }

                        if (fetchList.containsKey(""INTERNALDATE""))
                        {
                            Date internalDate = fetchList.getKeyedDate(""INTERNALDATE"");
                            message.setInternalDate(internalDate);
                        }
                        if (fetchList.containsKey(""RFC822.SIZE""))
                        {
                            int size = fetchList.getKeyedNumber(""RFC822.SIZE"");
                            imapMessage.setSize(size);
                        }
                        if (fetchList.containsKey(""BODYSTRUCTURE""))
                        {
                            ImapList bs = fetchList.getKeyedList(""BODYSTRUCTURE"");
                            if (bs != null)
                            {
                                try
                                {
                                    parseBodyStructure(bs, message, ""TEXT"");
                                }
                                catch (MessagingException e)
                                {
                                    if (K9.DEBUG)
                                        Log.d(K9.LOG_TAG, ""Error handling message for "" + getLogId(), e);
                                    message.setBody(null);
                                }
                            }
                        }

                        if (fetchList.containsKey(""BODY""))
                        {
                            Part part = null;
                            for (Object o : fp)
                            {
                                if (o instanceof Part)
                                {
                                    part = (Part) o;
                                    break;
                                }
                            }

                            int index = fetchList.getKeyIndex(""BODY"") + 2;
                            Object literal = fetchList.getObject(index);

                            // Check if there's an origin octet
                            if (literal instanceof String)
                            {
                                String originOctet = (String)literal;
                                if (originOctet.startsWith(""<""))
                                {
                                    literal = fetchList.getObject(index + 1);
                                }
                            }

                            InputStream bodyStream;
                            if (literal instanceof InputStream)
                            {
                                bodyStream = (InputStream)literal;
                            }
                            else if (literal instanceof String)
                            {
                                String bodyString = (String)literal;

                                if (K9.DEBUG)
                                    Log.v(K9.LOG_TAG, ""Part is a String: '"" + bodyString + ""' for "" + getLogId());

                                bodyStream = new ByteArrayInputStream(bodyString.getBytes());
                            }
                            else
                            {
                                // This shouldn't happen
                                throw new MessagingException(""Got FETCH response with bogus parameters"");
                            }

                            if (part != null)
                            {
                                String contentTransferEncoding = part.getHeader(
                                        MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING)[0];
                                part.setBody(MimeUtility.decodeBody(bodyStream, contentTransferEncoding));
                            }
                            else
                            {
                                imapMessage.parse(bodyStream);
                            }
                        }

                        if (listener != null)
                        {
                            listener.messageFinished(message, messageNumber, messageMap.size());
                        }
                    }
                    else
                    {
                        handleUntaggedResponse(response);
                    }

                    while (response.more());

                }
                while (response.mTag == null);
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        @Override
        public Flag[] getPermanentFlags() throws MessagingException
        {
            return PERMANENT_FLAGS;
        }

        /**
         * Handle any untagged responses that the caller doesn't care to handle themselves.
         * @param responses
         */
        protected List<ImapResponse> handleUntaggedResponses(List<ImapResponse> responses)
        {
            for (ImapResponse response : responses)
            {
                handleUntaggedResponse(response);
            }
            return responses;
        }

        protected void handlePossibleUidNext(ImapResponse response)
        {
            if (response.get(0).equals(""OK"") && response.size() > 1)
            {
                Object bracketedObj = response.get(1);
                if (bracketedObj instanceof ImapList)
                {
                    ImapList bracketed = (ImapList)bracketedObj;

                    if (bracketed.size() > 1)
                    {
                        Object keyObj = bracketed.get(0);
                        if (keyObj instanceof String)
                        {
                            String key = (String)keyObj;
                            if (""UIDNEXT"".equals(key))
                            {
                                uidNext = bracketed.getNumber(1);
                                if (K9.DEBUG)
                                    Log.d(K9.LOG_TAG, ""Got UidNext = "" + uidNext + "" for "" + getLogId());
                            }
                        }
                    }


                }
            }
        }

        /**
         * Handle an untagged response that the caller doesn't care to handle themselves.
         * @param response
         */
        protected void handleUntaggedResponse(ImapResponse response)
        {
            if (response.mTag == null && response.size() > 1)
            {
                if (response.get(1).equals(""EXISTS""))
                {
                    mMessageCount = response.getNumber(0);
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Got untagged EXISTS with value "" + mMessageCount + "" for "" + getLogId());
                }
                handlePossibleUidNext(response);

                if (response.get(1).equals(""EXPUNGE"") && mMessageCount > 0)
                {
                    mMessageCount--;
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Got untagged EXPUNGE with value "" + mMessageCount + "" for "" + getLogId());
                }
//            if (response.size() > 1) {
//                Object bracketedObj = response.get(1);
//                if (bracketedObj instanceof ImapList)
//                {
//                    ImapList bracketed = (ImapList)bracketedObj;
//
//                    if (bracketed.size() > 0)
//                    {
//                        Object keyObj = bracketed.get(0);
//                        if (keyObj instanceof String)
//                        {
//                            String key = (String)keyObj;
//                            if (""ALERT"".equals(key))
//                            {
//                                StringBuffer sb = new StringBuffer();
//                                for (int i = 2, count = response.size(); i < count; i++) {
//                                    sb.append(response.get(i).toString());
//                                    sb.append(' ');
//                                }
//
//                                Log.w(K9.LOG_TAG, ""ALERT: "" + sb.toString() + "" for "" + getLogId());
//                            }
//                        }
//                    }
//
//
//                }
//            }
            }
            //Log.i(K9.LOG_TAG, ""mMessageCount = "" + mMessageCount + "" for "" + getLogId());
        }

        private void parseBodyStructure(ImapList bs, Part part, String id)
        throws MessagingException
        {
            if (bs.get(0) instanceof ImapList)
            {
                /*
                 * This is a multipart/*
                 */
                MimeMultipart mp = new MimeMultipart();
                for (int i = 0, count = bs.size(); i < count; i++)
                {
                    if (bs.get(i) instanceof ImapList)
                    {
                        /*
                         * For each part in the message we're going to add a new BodyPart and parse
                         * into it.
                         */
                        ImapBodyPart bp = new ImapBodyPart();
                        if (id.equals(""TEXT""))
                        {
                            parseBodyStructure(bs.getList(i), bp, Integer.toString(i + 1));
                        }
                        else
                        {
                            parseBodyStructure(bs.getList(i), bp, id + ""."" + (i + 1));
                        }
                        mp.addBodyPart(bp);
                    }
                    else
                    {
                        /*
                         * We've got to the end of the children of the part, so now we can find out
                         * what type it is and bail out.
                         */
                        String subType = bs.getString(i);
                        mp.setSubType(subType.toLowerCase());
                        break;
                    }
                }
                part.setBody(mp);
            }
            else
            {
                /*
                 * This is a body. We need to add as much information as we can find out about
                 * it to the Part.
                 */

                /*
                 body type
                 body subtype
                 body parameter parenthesized list
                 body id
                 body description
                 body encoding
                 body size
                 */


                String type = bs.getString(0);
                String subType = bs.getString(1);
                String mimeType = (type + ""/"" + subType).toLowerCase();

                ImapList bodyParams = null;
                if (bs.get(2) instanceof ImapList)
                {
                    bodyParams = bs.getList(2);
                }
                String encoding = bs.getString(5);
                int size = bs.getNumber(6);

                if (MimeUtility.mimeTypeMatches(mimeType, ""message/rfc822""))
                {
//                  A body type of type MESSAGE and subtype RFC822
//                  contains, immediately after the basic fields, the
//                  envelope structure, body structure, and size in
//                  text lines of the encapsulated message.
//                    [MESSAGE, RFC822, [NAME, Fwd: [#HTR-517941]:  update plans at 1am Friday - Memory allocation - displayware.eml], NIL, NIL, 7BIT, 5974, NIL, [INLINE, [FILENAME*0, Fwd: [#HTR-517941]:  update plans at 1am Friday - Memory all, FILENAME*1, ocation - displayware.eml]], NIL]
                    /*
                     * This will be caught by fetch and handled appropriately.
                     */
                    throw new MessagingException(""BODYSTRUCTURE message/rfc822 not yet supported."");
                }

                /*
                 * Set the content type with as much information as we know right now.
                 */
                String contentType = String.format(""%s"", mimeType);

                if (bodyParams != null)
                {
                    /*
                     * If there are body params we might be able to get some more information out
                     * of them.
                     */
                    for (int i = 0, count = bodyParams.size(); i < count; i += 2)
                    {
                        contentType += String.format("";\n %s=\""%s\"""",
                                                     bodyParams.getString(i),
                                                     bodyParams.getString(i + 1));
                    }
                }

                part.setHeader(MimeHeader.HEADER_CONTENT_TYPE, contentType);

                // Extension items
                ImapList bodyDisposition = null;
                if ((""text"".equalsIgnoreCase(type))
                        && (bs.size() > 8)
                        && (bs.get(9) instanceof ImapList))
                {
                    bodyDisposition = bs.getList(9);
                }
                else if (!(""text"".equalsIgnoreCase(type))
                         && (bs.size() > 7)
                         && (bs.get(8) instanceof ImapList))
                {
                    bodyDisposition = bs.getList(8);
                }

                String contentDisposition = """";

                if (bodyDisposition != null && bodyDisposition.size() > 0)
                {
                    if (!""NIL"".equalsIgnoreCase(bodyDisposition.getString(0)))
                    {
                        contentDisposition = bodyDisposition.getString(0).toLowerCase();
                    }

                    if ((bodyDisposition.size() > 1)
                            && (bodyDisposition.get(1) instanceof ImapList))
                    {
                        ImapList bodyDispositionParams = bodyDisposition.getList(1);
                        /*
                         * If there is body disposition information we can pull some more information
                         * about the attachment out.
                         */
                        for (int i = 0, count = bodyDispositionParams.size(); i < count; i += 2)
                        {
                            contentDisposition += String.format("";\n %s=\""%s\"""",
                                                                bodyDispositionParams.getString(i).toLowerCase(),
                                                                bodyDispositionParams.getString(i + 1));
                        }
                    }
                }

                if (MimeUtility.getHeaderParameter(contentDisposition, ""size"") == null)
                {
                    contentDisposition += String.format("";\n size=%d"", size);
                }

                /*
                 * Set the content disposition containing at least the size. Attachment
                 * handling code will use this down the road.
                 */
                part.setHeader(MimeHeader.HEADER_CONTENT_DISPOSITION, contentDisposition);


                /*
                 * Set the Content-Transfer-Encoding header. Attachment code will use this
                 * to parse the body.
                 */
                part.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, encoding);

                if (part instanceof ImapMessage)
                {
                    ((ImapMessage) part).setSize(size);
                }
                else if (part instanceof ImapBodyPart)
                {
                    ((ImapBodyPart) part).setSize(size);
                }
                else
                {
                    throw new MessagingException(""Unknown part type "" + part.toString());
                }
                part.setHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA, id);
            }

        }

        /**
         * Appends the given messages to the selected folder. This implementation also determines
         * the new UID of the given message on the IMAP server and sets the Message's UID to the
         * new server UID.
         */
        public void appendMessages(Message[] messages) throws MessagingException
        {
            checkOpen();
            try
            {
                for (Message message : messages)
                {
                    CountingOutputStream out = new CountingOutputStream();
                    EOLConvertingOutputStream eolOut = new EOLConvertingOutputStream(out);
                    message.writeTo(eolOut);
                    eolOut.flush();

                    mConnection.sendCommand(
                        String.format(""APPEND \""%s\"" (%s) {%d}"",
                                      encodeFolderName(getPrefixedName()),
                                      combineFlags(message.getFlags()),
                                      out.getCount()), false);
                    ImapResponse response;
                    do
                    {
                        response = mConnection.readResponse();
                        handleUntaggedResponse(response);
                        if (response.mCommandContinuationRequested)
                        {
                            eolOut = new EOLConvertingOutputStream(mConnection.mOut);
                            message.writeTo(eolOut);
                            eolOut.write('\r');
                            eolOut.write('\n');
                            eolOut.flush();
                        }
                        while (response.more());
                    }
                    while (response.mTag == null);

                    String newUid = getUidFromMessageId(message);
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Got UID "" + newUid + "" for message for "" + getLogId());

                    if (newUid != null)
                    {
                        message.setUid(newUid);
                    }


                }
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        public String getUidFromMessageId(Message message) throws MessagingException
        {
            try
            {
                /*
                * Try to find the UID of the message we just appended using the
                * Message-ID header.
                */
                String[] messageIdHeader = message.getHeader(""Message-ID"");

                if (messageIdHeader == null || messageIdHeader.length == 0)
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Did not get a message-id in order to search for UID  for "" + getLogId());
                    return null;
                }
                String messageId = messageIdHeader[0];
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Looking for UID for message with message-id "" + messageId + "" for "" + getLogId());

                List<ImapResponse> responses =
                    executeSimpleCommand(
                        String.format(""UID SEARCH HEADER MESSAGE-ID %s"", messageId));
                for (ImapResponse response1 : responses)
                {
                    if (response1.mTag == null && response1.get(0).equals(""SEARCH"")
                            && response1.size() > 1)
                    {
                        return response1.getString(1);
                    }
                }
                return null;
            }
            catch (IOException ioe)
            {
                throw new MessagingException(""Could not find UID for message based on Message-ID"", ioe);
            }
        }


        public void expunge() throws MessagingException
        {
            checkOpen();
            try
            {
                executeSimpleCommand(""EXPUNGE"");
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        private String combineFlags(Flag[] flags)
        {
            ArrayList<String> flagNames = new ArrayList<String>();
            for (int i = 0, count = flags.length; i < count; i++)
            {
                Flag flag = flags[i];
                if (flag == Flag.SEEN)
                {
                    flagNames.add(""\\Seen"");
                }
                else if (flag == Flag.DELETED)
                {
                    flagNames.add(""\\Deleted"");
                }
                else if (flag == Flag.ANSWERED)
                {
                    flagNames.add(""\\Answered"");
                }
                else if (flag == Flag.FLAGGED)
                {
                    flagNames.add(""\\Flagged"");
                }

            }
            return Utility.combine(flagNames.toArray(new String[flagNames.size()]), ' ');
        }


        @Override
        public void setFlags(Flag[] flags, boolean value)
        throws MessagingException
        {
            checkOpen();


            try
            {
                executeSimpleCommand(String.format(""UID STORE 1:* %sFLAGS.SILENT (%s)"",
                                                   value ? ""+"" : ""-"", combineFlags(flags)));
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        public String getNewPushState(String oldPushStateS, Message message)
        {
            try
            {
                String messageUidS = message.getUid();
                int messageUid = Integer.parseInt(messageUidS);
                ImapPushState oldPushState = ImapPushState.parse(oldPushStateS);
                if (messageUid >= oldPushState.uidNext)
                {
                    int uidNext = messageUid + 1;
                    ImapPushState newPushState = new ImapPushState(uidNext);
                    return newPushState.toString();
                }
                else
                {
                    return null;
                }
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Exception while updated push state for "" + getLogId(), e);
                return null;
            }
        }


        public void setFlags(Message[] messages, Flag[] flags, boolean value)
        throws MessagingException
        {
            checkOpen();
            String[] uids = new String[messages.length];
            for (int i = 0, count = messages.length; i < count; i++)
            {
                uids[i] = messages[i].getUid();
            }
            ArrayList<String> flagNames = new ArrayList<String>();
            for (int i = 0, count = flags.length; i < count; i++)
            {
                Flag flag = flags[i];
                if (flag == Flag.SEEN)
                {
                    flagNames.add(""\\Seen"");
                }
                else if (flag == Flag.DELETED)
                {
                    flagNames.add(""\\Deleted"");
                }
                else if (flag == Flag.ANSWERED)
                {
                    flagNames.add(""\\Answered"");
                }
                else if (flag == Flag.FLAGGED)
                {
                    flagNames.add(""\\Flagged"");
                }
            }
            try
            {
                executeSimpleCommand(String.format(""UID STORE %s %sFLAGS.SILENT (%s)"",
                                                   Utility.combine(uids, ','),
                                                   value ? ""+"" : ""-"",
                                                   Utility.combine(flagNames.toArray(new String[flagNames.size()]), ' ')));
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        private void checkOpen() throws MessagingException
        {
            if (!isOpen())
            {
                throw new MessagingException(""Folder "" + getPrefixedName() + "" is not open."");
            }
        }

        private MessagingException ioExceptionHandler(ImapConnection connection, IOException ioe)
        throws MessagingException
        {
            Log.e(K9.LOG_TAG, ""IOException for "" + getLogId(), ioe);
            connection.close();
            close();
            return new MessagingException(""IO Error"", ioe);
        }

        @Override
        public boolean equals(Object o)
        {
            if (o instanceof ImapFolder)
            {
                return ((ImapFolder)o).getPrefixedName().equals(getPrefixedName());
            }
            return super.equals(o);
        }

        protected ImapStore getStore()
        {
            return store;
        }

        protected String getLogId()
        {
            String id = getName() + ""/"" + Thread.currentThread().getName();
            if (mConnection != null)
            {
                id += ""/"" + mConnection.getLogId();
            }
            return id;
        }
    }

    /**
     * A cacheable class that stores the details for a single IMAP connection.
     */
    class ImapConnection
    {
        private Socket mSocket;
        private PeekableInputStream mIn;
        private OutputStream mOut;
        private ImapResponseParser mParser;
        private int mNextCommandTag;
        protected Set<String> capabilities = new HashSet<String>();

        private String getLogId()
        {
            return ""conn"" + hashCode();
        }
        
        private List<ImapResponse> receiveCapabilities(List<ImapResponse> responses)
        {
            for (ImapResponse response : responses)
            {
                ImapList capabilityList = null;
                if (response.size() > 0 && response.get(0).equals(""OK""))
                {
                    for (Object thisPart : response)
                    {
                        if (thisPart instanceof ImapList)
                        {
                            ImapList thisList = (ImapList)thisPart;
                            if (thisList.get(0).equals(CAPABILITY_CAPABILITY))
                            {
                                capabilityList = thisList;
                                break;
                            }
                        }
                    }
                }
                else if (response.mTag == null)
                {
                    capabilityList = response;
                }
                
                if (capabilityList != null)
                {
                    if (capabilityList.size() > 0 && capabilityList.get(0).equals(CAPABILITY_CAPABILITY))
                    {
                        if (K9.DEBUG)
                        {
                            Log.d(K9.LOG_TAG, ""Saving "" + capabilityList.size() + "" capabilities for "" + getLogId());
                        }
                        for (Object capability : capabilityList)
                        {
                            if (capability instanceof String)
                            {
//                                if (K9.DEBUG)
//                                {
//                                    Log.v(K9.LOG_TAG, ""Saving capability '"" + capability + ""' for "" + getLogId());
//                                }
                                capabilities.add((String)capability);
                            }
                        }
    
                    }
                }
            }
            return responses;
        }


        public void open() throws IOException, MessagingException
        {
            if (isOpen())
            {
                return;
            }

            boolean authSuccess = false;

            mNextCommandTag = 1;
            try
            {
                Security.setProperty(""networkaddress.cache.ttl"", ""0"");
            }
            catch (Exception e)
            {
                Log.w(K9.LOG_TAG, ""Could not set DNS ttl to 0 for "" + getLogId(), e);
            }

            try
            {

                SocketAddress socketAddress = new InetSocketAddress(mHost, mPort);

                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Connection "" + getLogId() + "" connecting to "" + mHost + "" @ IP addr "" + socketAddress);

                if (mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
                        mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL)
                {
                    SSLContext sslContext = SSLContext.getInstance(""TLS"");
                    final boolean secure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
                    sslContext.init(null, new TrustManager[]
                                    {
                                        TrustManagerFactory.get(mHost, secure)
                                    }, new SecureRandom());
                    mSocket = sslContext.getSocketFactory().createSocket();
                    mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                }
                else
                {
                    mSocket = new Socket();
                    mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                }

                setReadTimeout(Store.SOCKET_READ_TIMEOUT);

                mIn = new PeekableInputStream(new BufferedInputStream(mSocket.getInputStream(),
                                              1024));
                mParser = new ImapResponseParser(mIn);
                mOut = mSocket.getOutputStream();

                capabilities.clear();
                ImapResponse nullResponse = mParser.readResponse();
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, getLogId() + ""<<<"" + nullResponse);

                List<ImapResponse> nullResponses = new LinkedList<ImapResponse>();
                nullResponses.add(nullResponse);
                receiveCapabilities(nullResponses);
                
                if (hasCapability(CAPABILITY_CAPABILITY) == false)
                {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Did not get capabilities in banner, requesting CAPABILITY for "" + getLogId());
                    List<ImapResponse> responses = receiveCapabilities(executeSimpleCommand(COMMAND_CAPABILITY));
                    if (responses.size() != 2)
                    {
                        throw new MessagingException(""Invalid CAPABILITY response received"");
                    }
                }
                
                if (mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL
                        || mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED)
                {

                    if (hasCapability(""STARTTLS""))
                    {
                        // STARTTLS
                        executeSimpleCommand(""STARTTLS"");

                        SSLContext sslContext = SSLContext.getInstance(""TLS"");
                        boolean secure = mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED;
                        sslContext.init(null, new TrustManager[]
                                        {
                                            TrustManagerFactory.get(mHost, secure)
                                        }, new SecureRandom());
                        mSocket = sslContext.getSocketFactory().createSocket(mSocket, mHost, mPort,
                                  true);
                        mSocket.setSoTimeout(Store.SOCKET_READ_TIMEOUT);
                        mIn = new PeekableInputStream(new BufferedInputStream(mSocket
                                                      .getInputStream(), 1024));
                        mParser = new ImapResponseParser(mIn);
                        mOut = mSocket.getOutputStream();
                    }
                    else if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED)
                    {
                        throw new MessagingException(""TLS not supported but required"");
                    }
                }

                mOut = new BufferedOutputStream(mOut, 1024);

                try
                {
                    if (mAuthType == AuthType.CRAM_MD5)
                    {
                        authCramMD5();
                        // The authCramMD5 method called on the previous line does not allow for handling updated capabilities
                        // sent by the server.  So, to make sure we update to the post-authentication capability list
                        // we fetch the capabilities here.
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Updating capabilities after CRAM-MD5 authentication for "" + getLogId());
                        List<ImapResponse> responses = receiveCapabilities(executeSimpleCommand(COMMAND_CAPABILITY));
                        if (responses.size() != 2)
                        {
                            throw new MessagingException(""Invalid CAPABILITY response received"");
                        }
                        
                    }
                    else if (mAuthType == AuthType.PLAIN)
                    {
                        receiveCapabilities(executeSimpleCommand(""LOGIN \"""" + escapeString(mUsername) + ""\"" \"""" + escapeString(mPassword) + ""\"""", true));
                    }
                    authSuccess = true;
                }
                catch (ImapException ie)
                {
                    throw new AuthenticationFailedException(ie.getAlertText(), ie);

                }
                catch (MessagingException me)
                {
                    throw new AuthenticationFailedException(null, me);
                }
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, CAPABILITY_COMPRESS_DEFLATE + "" = "" + hasCapability(CAPABILITY_COMPRESS_DEFLATE));
                }
                if (hasCapability(CAPABILITY_COMPRESS_DEFLATE))
                {
                    ConnectivityManager connectivityManager = (ConnectivityManager)K9.app.getSystemService(Context.CONNECTIVITY_SERVICE);
                    boolean useCompression = true;
                    
                    NetworkInfo netInfo = connectivityManager.getActiveNetworkInfo();
                    if (netInfo != null)
                    {
                        int type = netInfo.getType();
                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""On network type "" + type);
                        useCompression = mAccount.useCompression(type);
                        
                    }
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""useCompression "" + useCompression);
                    if (useCompression)
                    {
                        try
                        {
                            executeSimpleCommand(COMMAND_COMPRESS_DEFLATE);
                            ZInputStream zInputStream = new ZInputStream(mSocket.getInputStream(), true);
                            zInputStream.setFlushMode(JZlib.Z_PARTIAL_FLUSH);
                            mIn = new PeekableInputStream(new BufferedInputStream(zInputStream, 1024));
                            mParser = new ImapResponseParser(mIn);
                            ZOutputStream zOutputStream = new ZOutputStream(mSocket.getOutputStream(), JZlib.Z_BEST_SPEED, true);
                            mOut = new BufferedOutputStream(zOutputStream, 1024);
                            zOutputStream.setFlushMode(JZlib.Z_PARTIAL_FLUSH);
                            if (K9.DEBUG)
                            {
                                Log.i(K9.LOG_TAG, ""Compression enabled for "" + getLogId());
                            }
                        }
                        catch (Exception e)
                        {
                            Log.e(K9.LOG_TAG, ""Unable to negotiate compression"", e);
                        }
                    }
                }
                
                
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""NAMESPACE = "" + hasCapability(CAPABILITY_NAMESPACE)
                          + "", mPathPrefix = "" + mPathPrefix);

                if (mPathPrefix == null)
                {
                    if (hasCapability(CAPABILITY_NAMESPACE))
                    {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""mPathPrefix is unset and server has NAMESPACE capability"");
                        List<ImapResponse> namespaceResponses =
                            executeSimpleCommand(COMMAND_NAMESPACE);
                        for (ImapResponse response : namespaceResponses)
                        {
                            if (response.get(0).equals(COMMAND_NAMESPACE))
                            {
                                if (K9.DEBUG)
                                    Log.d(K9.LOG_TAG, ""Got NAMESPACE response "" + response + "" on "" + getLogId());

                                Object personalNamespaces = response.get(1);
                                if (personalNamespaces != null && personalNamespaces instanceof ImapList)
                                {
                                    if (K9.DEBUG)
                                        Log.d(K9.LOG_TAG, ""Got personal namespaces: "" + personalNamespaces);
                                    ImapList bracketed = (ImapList)personalNamespaces;
                                    Object firstNamespace = bracketed.get(0);
                                    if (firstNamespace != null && firstNamespace instanceof ImapList)
                                    {
                                        if (K9.DEBUG)
                                            Log.d(K9.LOG_TAG, ""Got first personal namespaces: "" + firstNamespace);
                                        bracketed = (ImapList)firstNamespace;
                                        mPathPrefix = bracketed.getString(0);
                                        mPathDelimeter = bracketed.getString(1);
                                        mCombinedPrefix = null;
                                        if (K9.DEBUG)
                                            Log.d(K9.LOG_TAG, ""Got path '"" + mPathPrefix + ""' and separator '"" + mPathDelimeter + ""'"");
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""mPathPrefix is unset but server does not have NAMESPACE capability"");
                        mPathPrefix = """";
                    }
                }
            }
            catch (SSLException e)
            {
                throw new CertificateValidationException(e.getMessage(), e);
            }
            catch (GeneralSecurityException gse)
            {
                throw new MessagingException(
                    ""Unable to open connection to IMAP server due to security error."", gse);
            }
            catch (ConnectException ce)
            {
                String ceMess = ce.getMessage();
                String[] tokens = ceMess.split(""-"");
                if (tokens != null && tokens.length > 1 && tokens[1] != null)
                {
                    Log.e(K9.LOG_TAG, ""Stripping host/port from ConnectionException for "" + getLogId(), ce);
                    throw new ConnectException(tokens[1].trim());
                }
                else
                {
                    throw ce;
                }
            }
            finally
            {
                if (authSuccess == false)
                {
                    Log.e(K9.LOG_TAG, ""Failed to login, closing connection for "" + getLogId());
                    close();
                }
            }
        }

        protected void authCramMD5() throws AuthenticationFailedException, MessagingException
        {
            try
            {
                String tag = sendCommand(""AUTHENTICATE CRAM-MD5"", false);
                byte[] buf = new byte[ 1024 ];
                int b64NonceLen = 0;
                for (int i = 0; i < buf.length; i++)
                {
                    buf[ i ] = (byte)mIn.read();
                    if (buf[i] == 0x0a)
                    {
                        b64NonceLen = i;
                        break;
                    }
                }
                if (b64NonceLen == 0)
                {
                    throw new AuthenticationFailedException(""Error negotiating CRAM-MD5: nonce too long."");
                }
                byte[] b64NonceTrim = new byte[ b64NonceLen - 2 ];
                System.arraycopy(buf, 1, b64NonceTrim, 0, b64NonceLen - 2);
                byte[] nonce = Base64.decodeBase64(b64NonceTrim);
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Got nonce: "" + new String(b64NonceTrim, ""US-ASCII""));
                    Log.d(K9.LOG_TAG, ""Plaintext nonce: "" + new String(nonce, ""US-ASCII""));
                }

                byte[] ipad = new byte[64];
                byte[] opad = new byte[64];
                byte[] secretBytes = mPassword.getBytes(""US-ASCII"");
                MessageDigest md = MessageDigest.getInstance(""MD5"");
                if (secretBytes.length > 64)
                {
                    secretBytes = md.digest(secretBytes);
                }
                System.arraycopy(secretBytes, 0, ipad, 0, secretBytes.length);
                System.arraycopy(secretBytes, 0, opad, 0, secretBytes.length);
                for (int i = 0; i < ipad.length; i++) ipad[i] ^= 0x36;
                for (int i = 0; i < opad.length; i++) opad[i] ^= 0x5c;
                md.update(ipad);
                byte[] firstPass = md.digest(nonce);
                md.update(opad);
                byte[] result = md.digest(firstPass);
                String plainCRAM = mUsername + "" "" + new String(Hex.encodeHex(result));
                byte[] b64CRAM = Base64.encodeBase64(plainCRAM.getBytes(""US-ASCII""));
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Username == "" + mUsername);
                    Log.d(K9.LOG_TAG, ""plainCRAM: "" + plainCRAM);
                    Log.d(K9.LOG_TAG, ""b64CRAM: "" + new String(b64CRAM, ""US-ASCII""));
                }

                mOut.write(b64CRAM);
                mOut.write(new byte[] { 0x0d, 0x0a });
                mOut.flush();
                int respLen = 0;
                for (int i = 0; i < buf.length; i++)
                {
                    buf[ i ] = (byte)mIn.read();
                    if (buf[i] == 0x0a)
                    {
                        respLen = i;
                        break;
                    }
                }
                String toMatch = tag + "" OK"";
                String respStr = new String(buf, 0, respLen);
                if (!respStr.startsWith(toMatch))
                {
                    throw new AuthenticationFailedException(""CRAM-MD5 error: "" + respStr);
                }
            }
            catch (IOException ioe)
            {
                throw new AuthenticationFailedException(""CRAM-MD5 Auth Failed."");
            }
            catch (NoSuchAlgorithmException nsae)
            {
                throw new AuthenticationFailedException(""MD5 Not Available."");
            }
        }

        protected void setReadTimeout(int millis) throws SocketException
        {
            mSocket.setSoTimeout(millis);
        }

        protected boolean isIdleCapable()
        {
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""Connection "" + getLogId() + "" has "" + capabilities.size() + "" capabilities"");

            return capabilities.contains(CAPABILITY_IDLE);
        }

        protected boolean hasCapability(String capability)
        {
            return capabilities.contains(capability);
        }

        private boolean isOpen()
        {
            return (mIn != null && mOut != null && mSocket != null && mSocket.isConnected() && !mSocket.isClosed());
        }

        private void close()
        {
//            if (isOpen()) {
//                try {
//                    executeSimpleCommand(""LOGOUT"");
//                } catch (Exception e) {
//
//                }
//            }
            try
            {
                mIn.close();
            }
            catch (Exception e)
            {

            }
            try
            {
                mOut.close();
            }
            catch (Exception e)
            {

            }
            try
            {
                mSocket.close();
            }
            catch (Exception e)
            {

            }
            mIn = null;
            mOut = null;
            mSocket = null;
        }

        private ImapResponse readResponse() throws IOException, MessagingException
        {
            try
            {
                ImapResponse response = mParser.readResponse();
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, getLogId() + ""<<<"" + response);

                return response;
            }
            catch (IOException ioe)
            {
                close();
                throw ioe;
            }
        }

        private String escapeString(String in)
        {
            if (in == null)
            {
                return null;
            }
            String out = in.replaceAll(""\\\\"", ""\\\\\\\\"");
            out = out.replaceAll(""\"""", ""\\\\\"""");
            return out;
        }

        private void sendContinuation(String continuation) throws IOException
        {
            mOut.write(continuation.getBytes());
            mOut.write('\r');
            mOut.write('\n');
            mOut.flush();

            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, getLogId() + "">>> "" + continuation);

        }

        public String sendCommand(String command, boolean sensitive)
        throws MessagingException, IOException
        {
            try
            {
                open();
                String tag = Integer.toString(mNextCommandTag++);
                String commandToSend = tag + "" "" + command;
                mOut.write(commandToSend.getBytes());
                mOut.write('\r');
                mOut.write('\n');
                mOut.flush();

                if (K9.DEBUG)
                {
                    if (sensitive && !K9.DEBUG_SENSITIVE)
                    {
                        Log.v(K9.LOG_TAG, getLogId() + "">>> ""
                              + ""[Command Hidden, Enable Sensitive Debug Logging To Show]"");
                    }
                    else
                    {
                        Log.v(K9.LOG_TAG, getLogId() + "">>> "" + commandToSend);
                    }
                }

                return tag;
            }
            catch (IOException ioe)
            {
                close();
                throw ioe;
            }
            catch (ImapException ie)
            {
                close();
                throw ie;
            }
            catch (MessagingException me)
            {
                close();
                throw me;
            }
        }

        public List<ImapResponse> executeSimpleCommand(String command) throws IOException,
                    ImapException, MessagingException
        {
            return executeSimpleCommand(command, false);
        }

        public List<ImapResponse> executeSimpleCommand(String command, boolean sensitive) throws IOException,
                    ImapException, MessagingException
        {
            return executeSimpleCommand(command, sensitive, null);
        }

        private List<ImapResponse> executeSimpleCommand(String command, boolean sensitive, UntaggedHandler untaggedHandler)
        throws IOException, ImapException, MessagingException
        {
            String commandToLog = command;
            if (sensitive && !K9.DEBUG_SENSITIVE)
            {
                commandToLog = ""*sensitive*"";
            }


            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""Sending IMAP command "" + commandToLog + "" on connection "" + getLogId());

            String tag = sendCommand(command, sensitive);
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""Sent IMAP command "" + commandToLog + "" with tag "" + tag + "" for "" + getLogId());

            ArrayList<ImapResponse> responses = new ArrayList<ImapResponse>();
            ImapResponse response;
            do
            {
                response = mParser.readResponse();
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, getLogId() + ""<<<"" + response);

                if (response.mTag != null && response.mTag.equals(tag) == false)
                {
                    Log.w(K9.LOG_TAG, ""After sending tag "" + tag + "", got tag response from previous command "" + response + "" for "" + getLogId());
                    Iterator<ImapResponse> iter = responses.iterator();
                    while (iter.hasNext())
                    {
                        ImapResponse delResponse = iter.next();
                        if (delResponse.mTag != null || delResponse.size() < 2
                                || (""EXISTS"".equals(delResponse.get(1)) == false && ""EXPUNGE"".equals(delResponse.get(1)) == false))
                        {
                            iter.remove();
                        }
                    }
                    response.mTag = null;
                    continue;
                }
                if (untaggedHandler != null)
                {
                    untaggedHandler.handleAsyncUntaggedResponse(response);
                }
                responses.add(response);
            }
            while (response.mTag == null);
            if (response.size() < 1 || !response.get(0).equals(""OK""))
            {
                throw new ImapException(""Command: "" + commandToLog + ""; response: "" + response.toString(), response.getAlertText());
            }
            return responses;
        }
    }

    class ImapMessage extends MimeMessage
    {
        ImapMessage(String uid, Folder folder) throws MessagingException
        {
            this.mUid = uid;
            this.mFolder = folder;
        }

        public void setSize(int size)
        {
            this.mSize = size;
        }

        public void parse(InputStream in) throws IOException, MessagingException
        {
            super.parse(in);
        }

        public void setFlagInternal(Flag flag, boolean set) throws MessagingException
        {
            super.setFlag(flag, set);
        }


        @Override
        public void setFlag(Flag flag, boolean set) throws MessagingException
        {
            super.setFlag(flag, set);
            mFolder.setFlags(new Message[] { this }, new Flag[] { flag }, set);
        }

        @Override
        public void delete(String trashFolderName) throws MessagingException
        {
            getFolder().delete(new Message[] { this }, trashFolderName);
        }
    }

    class ImapBodyPart extends MimeBodyPart
    {
        public ImapBodyPart() throws MessagingException
        {
            super();
        }

        public void setSize(int size)
        {
            this.mSize = size;
        }
    }

    class ImapException extends MessagingException
    {
        String mAlertText;

        public ImapException(String message, String alertText, Throwable throwable)
        {
            super(message, throwable);
            this.mAlertText = alertText;
        }

        public ImapException(String message, String alertText)
        {
            super(message);
            this.mAlertText = alertText;
        }

        public String getAlertText()
        {
            return mAlertText;
        }

        public void setAlertText(String alertText)
        {
            mAlertText = alertText;
        }
    }

    public static int MAX_DELAY_TIME = 50000;
    public static int NORMAL_DELAY_TIME = 2500;

    public class ImapFolderPusher extends ImapFolder implements UntaggedHandler
    {
        final PushReceiver receiver;
        Thread listeningThread = null;
        final AtomicBoolean stop = new AtomicBoolean(false);
        final AtomicBoolean idling = new AtomicBoolean(false);
        final AtomicBoolean doneSent = new AtomicBoolean(false);
        final AtomicInteger delayTime = new AtomicInteger(NORMAL_DELAY_TIME);
        List<ImapResponse> storedUntaggedResponses = new ArrayList<ImapResponse>();

        public ImapFolderPusher(ImapStore store, String name, PushReceiver nReceiver)
        {
            super(store, name);
            receiver = nReceiver;
        }
        public void refresh() throws IOException, MessagingException
        {
            if (idling.get())
            {
                receiver.acquireWakeLock();
                sendDone();
            }
        }

        private void sendDone() throws IOException, MessagingException
        {
            if (doneSent.compareAndSet(false, true) == true)
            {
                mConnection.setReadTimeout(Store.SOCKET_READ_TIMEOUT);
                sendContinuation(""DONE"");
            }
        }

        private void sendContinuation(String continuation)
        throws MessagingException, IOException
        {
            if (mConnection != null)
            {
                mConnection.sendContinuation(continuation);
            }
        }

        public void start()
        {
            Runnable runner = new Runnable()
            {
                public void run()
                {
                    receiver.acquireWakeLock();
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Pusher starting for "" + getLogId());

                    while (stop.get() != true)
                    {
                        try
                        {
                            int oldUidNext = -1;
                            try
                            {
                                String pushStateS = receiver.getPushState(getName());
                                ImapPushState pushState = ImapPushState.parse(pushStateS);
                                oldUidNext = pushState.uidNext;
                                if (K9.DEBUG)
                                    Log.i(K9.LOG_TAG, ""Got oldUidNext "" + oldUidNext + "" for "" + getLogId());
                            }
                            catch (Exception e)
                            {
                                Log.e(K9.LOG_TAG, ""Unable to get oldUidNext for "" + getLogId(), e);
                            }

                            List<ImapResponse> responses = internalOpen(OpenMode.READ_ONLY);
                            if (mConnection == null)
                            {
                                receiver.pushError(""Could not establish connection for IDLE"", null);
                                throw new MessagingException(""Could not establish connection for IDLE"");

                            }
                            if (mConnection.isIdleCapable() == false)
                            {
                                stop.set(true);
                                receiver.pushError(""IMAP server is not IDLE capable: "" + mConnection.toString(), null);
                                throw new MessagingException(""IMAP server is not IDLE capable:"" + mConnection.toString());
                            }

                            if (responses != null)
                            {
                                handleUntaggedResponses(responses);
                            }
                            int startUid = oldUidNext;
                            if (startUid < uidNext - 10)
                            {
                                startUid = uidNext - 10;
                            }
                            if (startUid < 1)
                            {
                                startUid = 1;
                            }
                            if (uidNext > startUid)
                            {

                                if (K9.DEBUG)
                                    Log.i(K9.LOG_TAG, ""Needs sync from uid "" + startUid  + "" to "" + uidNext + "" for "" + getLogId());
                                List<Message> messages = new ArrayList<Message>();
                                for (int uid = startUid; uid < uidNext; uid++)
                                {
                                    ImapMessage message = new ImapMessage("""" + uid, ImapFolderPusher.this);
                                    messages.add(message);
                                }
                                if (messages.size() > 0)
                                {
                                    pushMessages(messages, true);
                                }

                            }
                            else
                            {
                                if (stop.get() == false)
                                {
                                    List<ImapResponse> untaggedResponses = null;
                                    if (storedUntaggedResponses.size() > 0)
                                    {
                                        if (K9.DEBUG)
                                            Log.i(K9.LOG_TAG, ""Processing "" + storedUntaggedResponses.size() + "" from previous commands for "" + getLogId());
                                        untaggedResponses = new ArrayList<ImapResponse>(storedUntaggedResponses);
                                    }
                                    else
                                    {
                                        if (K9.DEBUG)
                                            Log.i(K9.LOG_TAG, ""About to IDLE for "" + getLogId());

                                        receiver.setPushActive(getName(), true);
                                        idling.set(true);
                                        doneSent.set(false);
                                        mConnection.setReadTimeout(IDLE_READ_TIMEOUT);
                                        untaggedResponses = executeSimpleCommand(COMMAND_IDLE, false, ImapFolderPusher.this);
                                        idling.set(false);

                                    }
                                    if (stop.get() == false)
                                    {
                                        storedUntaggedResponses.clear();
                                        processUntaggedResponses(untaggedResponses);
                                    }
                                    delayTime.set(NORMAL_DELAY_TIME);
                                }
                            }
                        }
                        catch (Exception e)
                        {
                            receiver.acquireWakeLock();
                            storedUntaggedResponses.clear();
                            idling.set(false);
                            receiver.setPushActive(getName(), false);
                            try
                            {
                                close();
                            }
                            catch (Exception me)
                            {
                                Log.e(K9.LOG_TAG, ""Got exception while closing for exception for "" + getLogId(), me);
                            }
                            if (stop.get() == true)
                            {
                                Log.i(K9.LOG_TAG, ""Got exception while idling, but stop is set for "" + getLogId());
                            }
                            else
                            {
                                receiver.pushError(""Push error: "" + e.getMessage(), null);
                                Log.e(K9.LOG_TAG, ""Got exception while idling for "" + getLogId(), e);
                                int delayTimeInt = delayTime.get();
                                receiver.sleep(delayTimeInt);
                                delayTimeInt *= 2;
                                if (delayTimeInt > MAX_DELAY_TIME)
                                {
                                    delayTimeInt = MAX_DELAY_TIME;
                                }
                                delayTime.set(delayTimeInt);

                            }
                        }
                    }
                    receiver.setPushActive(getName(), false);
                    try
                    {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Pusher for "" + getLogId() + "" is exiting"");
                        close();
                    }
                    catch (Exception me)
                    {
                        Log.e(K9.LOG_TAG, ""Got exception while closing for "" + getLogId(), me);
                    }
                    finally
                    {
                        receiver.releaseWakeLock();
                    }
                }
            };
            listeningThread = new Thread(runner);
            listeningThread.start();
        }

        @Override
        protected void handleUntaggedResponse(ImapResponse response)
        {
            if (response.mTag == null && response.size() > 1)
            {
                Object responseType = response.get(1);
                if (""FETCH"".equals(responseType)
                        || ""EXPUNGE"".equals(responseType)
                        || ""EXISTS"".equals(responseType))
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Storing response "" + response + "" for later processing"");

                    storedUntaggedResponses.add(response);
                }
                handlePossibleUidNext(response);
            }
        }

        protected void processUntaggedResponses(List<ImapResponse> responses)
        {
            boolean skipSync = false;
            int oldMessageCount = mMessageCount;
            if (oldMessageCount == -1)
            {
                skipSync = true;
            }
            List<Integer> flagSyncMsgSeqs = new ArrayList<Integer>();

            for (ImapResponse response : responses)
            {
                oldMessageCount += processUntaggedResponse(oldMessageCount, response, flagSyncMsgSeqs);
            }
            if (skipSync == false)
            {
                if (oldMessageCount < 0)
                {
                    oldMessageCount = 0;
                }
                if (mMessageCount > oldMessageCount)
                {
                    syncMessages(oldMessageCount + 1, mMessageCount, true);
                }
            }
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""There are "" + flagSyncMsgSeqs + "" messages needing flag sync for "" + getLogId());

            if (flagSyncMsgSeqs.size() > 0)
            {
                syncMessages(flagSyncMsgSeqs);
            }
        }

        private void syncMessages(int start, int end, boolean newArrivals)
        {
            try
            {
                Message[] messageArray = null;

                messageArray = getMessages(start, end, true, null);

                List<Message> messages = new ArrayList<Message>();
                for (Message message : messageArray)
                {
                    messages.add(message);
                }
                pushMessages(messages, newArrivals);

            }
            catch (Exception e)
            {
                receiver.pushError(""Exception while processing Push untagged responses"", e);
            }
        }

        private void syncMessages(List<Integer> flagSyncMsgSeqs)
        {
            try
            {
                Message[] messageArray = null;

                messageArray = getMessages(flagSyncMsgSeqs, true, null);

                List<Message> messages = new ArrayList<Message>();
                for (Message message : messageArray)
                {
                    messages.add(message);
                }
                pushMessages(messages, false);

            }
            catch (Exception e)
            {
                receiver.pushError(""Exception while processing Push untagged responses"", e);
            }
        }

        protected int processUntaggedResponse(int oldMessageCount, ImapResponse response, List<Integer> flagSyncMsgSeqs)
        {
            super.handleUntaggedResponse(response);
            int messageCountDelta = 0;
            if (response.mTag == null && response.size() > 1)
            {
                try
                {
                    Object responseType = response.get(1);
                    if (""FETCH"".equals(responseType))
                    {
                        int msgSeq = response.getNumber(0);
                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""Got untagged FETCH for msgseq "" + msgSeq + "" for "" + getLogId());

                        if (flagSyncMsgSeqs.contains(msgSeq) == false)
                        {
                            flagSyncMsgSeqs.add(msgSeq);
                        }
                    }
                    if (""EXPUNGE"".equals(responseType))
                    {
                        int msgSeq = response.getNumber(0);
                        if (msgSeq <= oldMessageCount)
                        {
                            messageCountDelta = -1;
                        }
                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""Got untagged EXPUNGE for msgseq "" + msgSeq + "" for "" + getLogId());

                        List<Integer> newSeqs = new ArrayList<Integer>();
                        Iterator<Integer> flagIter = flagSyncMsgSeqs.iterator();
                        while (flagIter.hasNext())
                        {
                            Integer flagMsg = flagIter.next();
                            if (flagMsg >= msgSeq)
                            {
                                flagIter.remove();
                                if (flagMsg > msgSeq)
                                {
                                    newSeqs.add(flagMsg--);
                                }
                            }
                        }
                        flagSyncMsgSeqs.addAll(newSeqs);
                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Could not handle untagged FETCH for "" + getLogId(), e);
                }
            }
            return messageCountDelta;
        }


        private void pushMessages(List<Message> messages, boolean newArrivals)
        {
            RuntimeException holdException = null;
            try
            {
                if (newArrivals)
                {
                    receiver.messagesArrived(this, messages);
                }
                else
                {
                    receiver.messagesFlagsChanged(this, messages);
                }
            }
            catch (RuntimeException e)
            {
                holdException = e;
            }

            if (holdException != null)
            {
                throw holdException;
            }
        }

        public void stop()
        {
            stop.set(true);
            if (listeningThread != null)
            {
                listeningThread.interrupt();
            }
            if (mConnection != null)
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""Closing mConnection to stop pushing for "" + getLogId());
                mConnection.close();
            }
            else
            {
                Log.w(K9.LOG_TAG, ""Attempt to interrupt null mConnection to stop pushing on folderPusher for "" + getLogId());
            }
        }

        public void handleAsyncUntaggedResponse(ImapResponse response)
        {
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""Got async response: "" + response);

            if (stop.get() == true)
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Got async untagged response: "" + response + "", but stop is set for "" + getLogId());

                try
                {
                    sendDone();
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Exception while sending DONE for "" + getLogId(), e);
                }
            }
            else
            {
                if (response.mTag == null)
                {
                    if (response.size() > 1)
                    {
                        boolean started = false;
                        Object responseType = response.get(1);
                        if (""EXISTS"".equals(responseType) || ""EXPUNGE"".equals(responseType) ||
                                ""FETCH"".equals(responseType))
                        {
                            if (started == false)
                            {
                                receiver.acquireWakeLock();
                                started = true;
                            }

                            if (K9.DEBUG)
                                Log.d(K9.LOG_TAG, ""Got useful async untagged response: "" + response + "" for "" + getLogId());

                            try
                            {
                                sendDone();
                            }
                            catch (Exception e)
                            {
                                Log.e(K9.LOG_TAG, ""Exception while sending DONE for "" + getLogId(), e);
                            }
                        }
                    }
                    else if (response.size() > 0)
                    {
                        if (""idling"".equals(response.get(0)))
                        {
                            if (K9.DEBUG)
                                Log.d(K9.LOG_TAG, ""Idling "" + getLogId());

                            receiver.releaseWakeLock();
                        }
                    }
                }
            }
        }
    }
    @Override
    public Pusher getPusher(PushReceiver receiver)
    {
        return new ImapPusher(this, receiver);
    }

    public class ImapPusher implements Pusher
    {
        final ImapStore mStore;
        final PushReceiver mReceiver;

        HashMap<String, ImapFolderPusher> folderPushers = new HashMap<String, ImapFolderPusher>();

        public ImapPusher(ImapStore store, PushReceiver receiver)
        {
            mStore = store;
            mReceiver = receiver;
        }

        public void start(List<String> folderNames)
        {
            stop();
            synchronized (folderPushers)
            {
                for (String folderName : folderNames)
                {
                    ImapFolderPusher pusher = folderPushers.get(folderName);
                    if (pusher == null)
                    {
                        pusher = new ImapFolderPusher(mStore, folderName, mReceiver);
                        folderPushers.put(folderName, pusher);
                        pusher.start();
                    }
                }
            }
        }

        public void refresh()
        {
            synchronized (folderPushers)
            {
                for (ImapFolderPusher folderPusher : folderPushers.values())
                {
                    try
                    {
                        folderPusher.refresh();
                    }
                    catch (Exception e)
                    {
                        Log.e(K9.LOG_TAG, ""Got exception while refreshing for "" + folderPusher.getName(), e);
                    }
                }
            }
        }

        public void stop()
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""Requested stop of IMAP pusher"");

            synchronized (folderPushers)
            {
                for (ImapFolderPusher folderPusher : folderPushers.values())
                {
                    try
                    {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Requesting stop of IMAP folderPusher "" + folderPusher.getName());
                        folderPusher.stop();
                    }
                    catch (Exception e)
                    {
                        Log.e(K9.LOG_TAG, ""Got exception while stopping "" + folderPusher.getName(), e);
                    }
                }
                folderPushers.clear();
            }
        }

        public int getRefreshInterval()
        {
            return IDLE_REFRESH_INTERVAL;
        }

    }
    private interface UntaggedHandler
    {
        void handleAsyncUntaggedResponse(ImapResponse respose);
    }

    protected static class ImapPushState
    {
        protected int uidNext;
        protected ImapPushState(int nUidNext)
        {
            uidNext = nUidNext;
        }
        protected static ImapPushState parse(String pushState)
        {
            int newUidNext = -1;
            if (pushState != null)
            {
                StringTokenizer tokenizer = new StringTokenizer(pushState, "";"");
                while (tokenizer.hasMoreTokens())
                {
                    StringTokenizer thisState = new StringTokenizer(tokenizer.nextToken(), ""="");
                    if (thisState.hasMoreTokens())
                    {
                        String key = thisState.nextToken();

                        if (""uidNext"".equals(key) && thisState.hasMoreTokens())
                        {
                            String value = thisState.nextToken();
                            try
                            {
                                newUidNext = Integer.parseInt(value);
                            }
                            catch (Exception e)
                            {
                                Log.e(K9.LOG_TAG, ""Unable to part uidNext value "" + value, e);
                            }

                        }
                    }
                }
            }
            return new ImapPushState(newUidNext);
        }
        public String toString()
        {
            return ""uidNext="" + uidNext;
        }

    }
    private interface ImapSearcher
    {
        List<ImapResponse> search() throws IOException, MessagingException;
    }
}
",True,189,0,0,6,43,1,30,L1
100,com.fsck.k9.preferences.Editor.java,"package com.fsck.k9.preferences;

import android.util.Log;
import com.fsck.k9.K9;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

public class Editor implements android.content.SharedPreferences.Editor
{
    private Storage storage;
    private HashMap<String, String> changes = new HashMap<String, String>();
    private ArrayList<String> removals = new ArrayList<String>();
    private boolean removeAll = false;

    Map<String, String> snapshot = new HashMap<String, String>();


    protected Editor(Storage storage)
    {
        this.storage = storage;
        snapshot.putAll(storage.getAll());
    }

    public void copy(android.content.SharedPreferences input)
    {
        Map<String, ?> oldVals = input.getAll();
        for (Entry<String, ?> entry : oldVals.entrySet())
        {
            String key = entry.getKey();
            Object value = entry.getValue();
            if (key != null && value != null)
            {
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Copying key '"" + key + ""', value '"" + value + ""'"");
                }
                changes.put(key, """" + value);
            }
            else
            {
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Skipping copying key '"" + key + ""', value '"" + value + ""'"");
                }
            }
        }
    }

    //@Override
    public android.content.SharedPreferences.Editor clear()
    {
        removeAll = true;
        return this;
    }

    /* This method is poorly defined.  It should throw an Exception on failure */
    //@Override
    public boolean commit()
    {
        try
        {
            commitChanges();
            return true;
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Failed to save preferences"", e);
            return false;
        }
    }

    public void commitChanges() throws Exception
    {
        long startTime = System.currentTimeMillis();
        Log.i(K9.LOG_TAG, ""Committing preference changes"");
        Runnable committer = new Runnable()
        {
            public void run()
            {
                if (removeAll)
                {
                    storage.removeAll();
                }
                for (String removeKey : removals)
                {
                    storage.remove(removeKey);
                }
                for (Entry<String, String> entry : changes.entrySet())
                {
                    String key = entry.getKey();
                    String newValue = entry.getValue();
                    String oldValue = snapshot.get(key);
                    if (removeAll || removals.contains(key) || newValue.equals(oldValue) != true)
                    {
                        storage.put(key, newValue);
                    }
                }
            }
        };
        storage.doInTransaction(committer);
        long endTime = System.currentTimeMillis();
        Log.i(K9.LOG_TAG, ""Preferences commit took "" + (endTime - startTime) + ""ms"");

    }

    //@Override
    public android.content.SharedPreferences.Editor putBoolean(String key,
            boolean value)
    {
        changes.put(key, """" + value);
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor putFloat(String key,
            float value)
    {
        changes.put(key, """" + value);
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor putInt(String key, int value)
    {
        changes.put(key, """" + value);
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor putLong(String key, long value)
    {
        changes.put(key, """" + value);
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor putString(String key,
            String value)
    {
        if (value == null)
        {
            remove(key);
        }
        else
        {
            changes.put(key, value);
        }
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor remove(String key)
    {
        removals.add(key);
        return this;
    }

}
",True,189,0,0,9,52,2,2,L1
101,com.fsck.k9.preferences.Storage.java,"package com.fsck.k9.preferences;

import android.content.ContentValues;
import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import com.fsck.k9.K9;
import com.fsck.k9.Utility;

import java.net.URI;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

public class Storage implements SharedPreferences
{
    private static ConcurrentHashMap<Context, Storage> storages =
        new ConcurrentHashMap<Context, Storage>();

    private volatile ConcurrentHashMap<String, String> storage = new ConcurrentHashMap<String, String>();

    private CopyOnWriteArrayList<OnSharedPreferenceChangeListener> listeners =
        new CopyOnWriteArrayList<OnSharedPreferenceChangeListener>();

    private int DB_VERSION = 2;
    private String DB_NAME = ""preferences_storage"";

    private ThreadLocal<ConcurrentHashMap<String, String>> workingStorage
    = new ThreadLocal<ConcurrentHashMap<String, String>>();
    private ThreadLocal<SQLiteDatabase> workingDB =
        new ThreadLocal<SQLiteDatabase>();
    private ThreadLocal<ArrayList<String>> workingChangedKeys = new ThreadLocal<ArrayList<String>>();


    private Context context = null;

    private SQLiteDatabase openDB()
    {
        SQLiteDatabase mDb = context.openOrCreateDatabase(DB_NAME, Context.MODE_PRIVATE, null);

        if (mDb.getVersion() == 1)
        {
            Log.i(K9.LOG_TAG, ""Updating preferences to urlencoded username/password"");

            String accountUuids = readValue(mDb, ""accountUuids"");
            if (accountUuids != null && accountUuids.length() != 0)
            {
                String[] uuids = accountUuids.split("","");
                for (int i = 0, length = uuids.length; i < length; i++)
                {
                    String uuid = uuids[i];
                    try
                    {
                        String storeUriStr = Utility.base64Decode(readValue(mDb, uuid + "".storeUri""));
                        String transportUriStr = Utility.base64Decode(readValue(mDb, uuid + "".transportUri""));

                        URI uri = new URI(transportUriStr);
                        String newUserInfo = null;
                        if (transportUriStr != null)
                        {
                            String[] userInfoParts = uri.getUserInfo().split("":"");

                            String usernameEnc = URLEncoder.encode(userInfoParts[0], ""UTF-8"");
                            String passwordEnc = """";
                            String authType = """";
                            if (userInfoParts.length > 1)
                            {
                                passwordEnc = "":"" + URLEncoder.encode(userInfoParts[1], ""UTF-8"");
                            }
                            if (userInfoParts.length > 2)
                            {
                                authType = "":"" + userInfoParts[2];
                            }

                            newUserInfo = usernameEnc + passwordEnc + authType;
                        }

                        if (newUserInfo != null)
                        {
                            URI newUri = new URI(uri.getScheme(), newUserInfo, uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());
                            String newTransportUriStr = Utility.base64Encode(newUri.toString());
                            writeValue(mDb, uuid + "".transportUri"", newTransportUriStr);
                        }

                        uri = new URI(storeUriStr);
                        newUserInfo = null;
                        if (storeUriStr.startsWith(""imap""))
                        {
                            String[] userInfoParts = uri.getUserInfo().split("":"");
                            if (userInfoParts.length == 2)
                            {
                                String usernameEnc = URLEncoder.encode(userInfoParts[0], ""UTF-8"");
                                String passwordEnc = URLEncoder.encode(userInfoParts[1], ""UTF-8"");

                                newUserInfo = usernameEnc + "":"" + passwordEnc;
                            }
                            else
                            {
                                String authType = userInfoParts[0];
                                String usernameEnc = URLEncoder.encode(userInfoParts[1], ""UTF-8"");
                                String passwordEnc = URLEncoder.encode(userInfoParts[2], ""UTF-8"");

                                newUserInfo = authType + "":"" + usernameEnc + "":"" + passwordEnc;
                            }
                        }
                        else if (storeUriStr.startsWith(""pop3""))
                        {
                            String[] userInfoParts = uri.getUserInfo().split("":"", 2);
                            String usernameEnc = URLEncoder.encode(userInfoParts[0], ""UTF-8"");

                            String passwordEnc = """";
                            if (userInfoParts.length > 1)
                            {
                                passwordEnc = "":"" + URLEncoder.encode(userInfoParts[1], ""UTF-8"");
                            }

                            newUserInfo = usernameEnc + passwordEnc;
                        }
                        else if (storeUriStr.startsWith(""webdav""))
                        {
                            String[] userInfoParts = uri.getUserInfo().split("":"", 2);
                            String usernameEnc = URLEncoder.encode(userInfoParts[0], ""UTF-8"");

                            String passwordEnc = """";
                            if (userInfoParts.length > 1)
                            {
                                passwordEnc = "":"" + URLEncoder.encode(userInfoParts[1], ""UTF-8"");
                            }

                            newUserInfo = usernameEnc + passwordEnc;
                        }

                        if (newUserInfo != null)
                        {
                            URI newUri = new URI(uri.getScheme(), newUserInfo, uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());
                            String newStoreUriStr = Utility.base64Encode(newUri.toString());
                            writeValue(mDb, uuid + "".storeUri"", newStoreUriStr);
                        }
                    }
                    catch (Exception e)
                    {
                        Log.e(K9.LOG_TAG, ""ooops"", e);
                    }
                }
            }

            mDb.setVersion(DB_VERSION);
        }

        if (mDb.getVersion() != DB_VERSION)
        {
            Log.i(K9.LOG_TAG, ""Creating Storage database"");
            mDb.execSQL(""DROP TABLE IF EXISTS preferences_storage"");
            mDb.execSQL(""CREATE TABLE preferences_storage "" +
                        ""(primkey TEXT PRIMARY KEY ON CONFLICT REPLACE, value TEXT)"");
            mDb.setVersion(DB_VERSION);
        }
        return mDb;
    }


    public static Storage getStorage(Context context)
    {
        Storage tmpStorage = storages.get(context);
        if (tmpStorage != null)
        {
            if (K9.DEBUG)
            {
                Log.d(K9.LOG_TAG, ""Returning already existing Storage"");
            }
            return tmpStorage;
        }
        else
        {
            if (K9.DEBUG)
            {
                Log.d(K9.LOG_TAG, ""Creating provisional storage"");
            }
            tmpStorage = new Storage(context);
            Storage oldStorage = storages.putIfAbsent(context, tmpStorage);
            if (oldStorage != null)
            {
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Another thread beat us to creating the Storage, returning that one"");
                }
                return oldStorage;
            }
            else
            {
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Returning the Storage we created"");
                }
                return tmpStorage;
            }
        }
    }

    private void loadValues()
    {
        long startTime = System.currentTimeMillis();
        Log.i(K9.LOG_TAG, ""Loading preferences from DB into Storage"");
        Cursor cursor = null;
        SQLiteDatabase mDb = null;
        try
        {
            mDb = openDB();

            cursor = mDb.rawQuery(""SELECT primkey, value FROM preferences_storage"", null);
            while (cursor.moveToNext())
            {
                String key = cursor.getString(0);
                String value = cursor.getString(1);
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Loading key '"" + key + ""', value = '"" + value + ""'"");
                }
                storage.put(key, value);
            }
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
            if (mDb != null)
            {
                mDb.close();
            }
            long endTime = System.currentTimeMillis();
            Log.i(K9.LOG_TAG, ""Preferences load took "" + (endTime - startTime) + ""ms"");
        }
    }

    private Storage(Context context)
    {
        this.context = context;
        loadValues();
    }

    private void keyChange(String key)
    {
        ArrayList<String> changedKeys = workingChangedKeys.get();
        if (changedKeys.contains(key) == false)
        {
            changedKeys.add(key);
        }
    }

    protected void put(String key, String value)
    {
        ContentValues cv = new ContentValues();
        cv.put(""primkey"", key);
        cv.put(""value"", value);
        workingDB.get().insert(""preferences_storage"", ""primkey"", cv);
        workingStorage.get().put(key, value);

        keyChange(key);
    }

    protected void remove(String key)
    {
        workingDB.get().delete(""preferences_storage"", ""primkey = ?"", new String[] { key });
        workingStorage.get().remove(key);

        keyChange(key);
    }

    protected void removeAll()
    {
        for (String key : workingStorage.get().keySet())
        {
            keyChange(key);
        }
        workingDB.get().execSQL(""DELETE FROM preferences_storage"");
        workingStorage.get().clear();
    }

    protected void doInTransaction(Runnable dbWork)
    {
        ConcurrentHashMap<String, String> newStorage = new ConcurrentHashMap<String, String>();
        newStorage.putAll(storage);
        workingStorage.set(newStorage);

        SQLiteDatabase mDb = openDB();
        workingDB.set(mDb);

        ArrayList<String> changedKeys = new ArrayList<String>();
        workingChangedKeys.set(changedKeys);

        mDb.beginTransaction();
        try
        {
            dbWork.run();
            mDb.setTransactionSuccessful();
            storage = newStorage;
            for (String changedKey : changedKeys)
            {
                for (OnSharedPreferenceChangeListener listener : listeners)
                {
                    listener.onSharedPreferenceChanged(this, changedKey);
                }
            }
        }
        finally
        {
            workingDB.remove();
            workingStorage.remove();
            workingChangedKeys.remove();
            mDb.endTransaction();
            if (mDb != null)
            {
                mDb.close();
            }
        }
    }

    public long size()
    {
        return storage.size();
    }

    //@Override
    public boolean contains(String key)
    {
        return storage.contains(key);
    }

    //@Override
    public com.fsck.k9.preferences.Editor edit()
    {
        return new com.fsck.k9.preferences.Editor(this);
    }

    //@Override
    public Map<String, String> getAll()
    {
        return storage;
    }

    //@Override
    public boolean getBoolean(String key, boolean defValue)
    {
        String val = storage.get(key);
        if (val == null)
        {
            return defValue;
        }
        return Boolean.parseBoolean(val);
    }

    //@Override
    public float getFloat(String key, float defValue)
    {
        String val = storage.get(key);
        if (val == null)
        {
            return defValue;
        }
        return Float.parseFloat(val);
    }

    //@Override
    public int getInt(String key, int defValue)
    {
        String val = storage.get(key);
        if (val == null)
        {
            return defValue;
        }
        return Integer.parseInt(val);
    }

    //@Override
    public long getLong(String key, long defValue)
    {
        String val = storage.get(key);
        if (val == null)
        {
            return defValue;
        }
        return Long.parseLong(val);
    }

    //@Override
    public String getString(String key, String defValue)
    {
        String val = storage.get(key);
        if (val == null)
        {
            return defValue;
        }
        return val;
    }

    //@Override
    public void registerOnSharedPreferenceChangeListener(
        OnSharedPreferenceChangeListener listener)
    {
        listeners.addIfAbsent(listener);
    }

    //@Override
    public void unregisterOnSharedPreferenceChangeListener(
        OnSharedPreferenceChangeListener listener)
    {
        listeners.remove(listener);
    }

    private String readValue(SQLiteDatabase mDb, String key)
    {
        Cursor cursor = null;
        String value = null;
        try
        {
            cursor = mDb.query(
                    ""preferences_storage"",
                    new String[] {""value""},
                    ""primkey = ?"",
                    new String[] {key},
                    null,
                    null,
                    null);

            if (cursor.moveToNext())
            {
                value = cursor.getString(0);
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Loading key '"" + key + ""', value = '"" + value + ""'"");
                }
            }
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
        }

        return value;
    }

    private void writeValue(SQLiteDatabase mDb, String key, String value)
    {
        ContentValues cv = new ContentValues();
        cv.put(""primkey"", key);
        cv.put(""value"", value);

        long result = mDb.insert(""preferences_storage"", ""primkey"", cv);

        if (result == -1)
        {
            Log.e(K9.LOG_TAG, ""Error writing key '"" + key + ""', value = '"" + value + ""'"");
        }
    }
}
",True,189,0,0,9,52,2,3,L1
