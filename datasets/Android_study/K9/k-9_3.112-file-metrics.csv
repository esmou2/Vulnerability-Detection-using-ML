,file_path,source_code,is_vulnerable, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,com.fsck.k9.Preferences.java,"
package com.fsck.k9;

import java.util.ArrayList;
import java.util.List;
import android.content.Context;
import android.content.SharedPreferences;
import android.util.Config;
import android.util.Log;
import com.fsck.k9.preferences.Editor;
import com.fsck.k9.preferences.Storage;

public class Preferences
{

    /**
     * Immutable empty {@link Account} array
     */
    private static final Account[] EMPTY_ACCOUNT_ARRAY = new Account[0];

    private static Preferences preferences;

    public static synchronized Preferences getPreferences(Context context)
    {
        if (preferences == null)
        {
            preferences = new Preferences(context);
        }
        return preferences;
    }


    private Storage mStorage;
    private List<Account> accounts;
    private Account newAccount;

    private Preferences(Context context)
    {
        mStorage = Storage.getStorage(context);
        if (mStorage.size() == 0)
        {
            Log.i(K9.LOG_TAG, ""Preferences storage is zero-size, importing from Android-style preferences"");
            Editor editor = mStorage.edit();
            editor.copy(context.getSharedPreferences(""AndroidMail.Main"", Context.MODE_PRIVATE));
            editor.commit();
        }
    }

    private synchronized void loadAccounts()
    {
        String accountUuids = getPreferences().getString(""accountUuids"", null);
        if ((accountUuids != null) && (accountUuids.length() != 0))
        {
            String[] uuids = accountUuids.split("","");
            accounts = new ArrayList<Account>(uuids.length);
            for (String uuid : uuids)
            {
                accounts.add(new Account(this, uuid));
            }
        }
        else
        {
            accounts = new ArrayList<Account>();
        }
    }

    /**
     * Returns an array of the accounts on the system. If no accounts are
     * registered the method returns an empty array.
     */
    public synchronized Account[] getAccounts()
    {
        if (accounts == null)
        {
            loadAccounts();
        }

        if ((newAccount != null) && newAccount.getAccountNumber() != -1)
        {
            accounts.add(newAccount);
            newAccount = null;
        }

        return accounts.toArray(EMPTY_ACCOUNT_ARRAY);
    }

    public synchronized Account getAccount(String uuid)
    {
        if (accounts == null)
        {
            loadAccounts();
        }

        for (Account account : accounts)
        {
            if (account.getUuid().equals(uuid))
            {
                return account;
            }
        }

        if ((newAccount != null) && newAccount.getUuid().equals(uuid))
        {
            return newAccount;
        }

        return null;
    }

    public synchronized Account newAccount()
    {
        newAccount = new Account(K9.app);

        return newAccount;
    }

    public synchronized void deleteAccount(Account account)
    {
        accounts.remove(account);
        account.delete(this);

        if (newAccount == account)
        {
            newAccount = null;
        }
    }

    /**
     * Returns the Account marked as default. If no account is marked as default
     * the first account in the list is marked as default and then returned. If
     * there are no accounts on the system the method returns null.
     */
    public Account getDefaultAccount()
    {
        String defaultAccountUuid = getPreferences().getString(""defaultAccountUuid"", null);
        Account defaultAccount = getAccount(defaultAccountUuid);

        if (defaultAccount == null)
        {
            Account[] accounts = getAccounts();
            if (accounts.length > 0)
            {
                defaultAccount = accounts[0];
                setDefaultAccount(defaultAccount);
            }
        }

        return defaultAccount;
    }

    public void setDefaultAccount(Account account)
    {
        getPreferences().edit().putString(""defaultAccountUuid"", account.getUuid()).commit();
    }

    public void dump()
    {
        if (Config.LOGV)
        {
            for (String key : getPreferences().getAll().keySet())
            {
                Log.v(K9.LOG_TAG, key + "" = "" + getPreferences().getAll().get(key));
            }
        }
    }

    public SharedPreferences getPreferences()
    {
        return mStorage;
    }
}
",True,220,1,4,8,52,35,4,L1
1,com.fsck.k9.Account.java,"
package com.fsck.k9;

import android.content.Context;
import android.content.SharedPreferences;
import android.net.ConnectivityManager;
import android.net.Uri;
import android.util.Log;

import com.fsck.k9.crypto.Apg;
import com.fsck.k9.crypto.CryptoProvider;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Account stores all of the settings for a single account defined by the user. It is able to save
 * and delete itself given a Preferences to work with. Each account is defined by a UUID.
 */
public class Account implements BaseAccount
{
    public static final String EXPUNGE_IMMEDIATELY = ""EXPUNGE_IMMEDIATELY"";
    public static final String EXPUNGE_MANUALLY = ""EXPUNGE_MANUALLY"";
    public static final String EXPUNGE_ON_POLL = ""EXPUNGE_ON_POLL"";

    public static final int DELETE_POLICY_NEVER = 0;
    public static final int DELETE_POLICY_7DAYS = 1;
    public static final int DELETE_POLICY_ON_DELETE = 2;
    public static final int DELETE_POLICY_MARK_AS_READ = 3;

    public static final String TYPE_WIFI = ""WIFI"";
    public static final String TYPE_MOBILE = ""MOBILE"";
    public static final String TYPE_OTHER = ""OTHER"";
    private static String[] networkTypes = { TYPE_WIFI, TYPE_MOBILE, TYPE_OTHER };

    private static final String DEFAULT_QUOTE_PREFIX = "">"";

    private static final boolean DEFAULT_REPLY_AFTER_QUOTE = false;

    /**
     * <pre>
     * 0 - Never (DELETE_POLICY_NEVER)
     * 1 - After 7 days (DELETE_POLICY_7DAYS)
     * 2 - When I delete from inbox (DELETE_POLICY_ON_DELETE)
     * 3 - Mark as read (DELETE_POLICY_MARK_AS_READ)
     * </pre>
     */
    private int mDeletePolicy;

    private String mUuid;
    private String mStoreUri;
    private String mLocalStoreUri;
    private String mTransportUri;
    private String mDescription;
    private String mAlwaysBcc;
    private int mAutomaticCheckIntervalMinutes;
    private int mDisplayCount;
    private int mChipColor;
    private long mLastAutomaticCheckTime;
    private boolean mNotifyNewMail;
    private boolean mNotifySelfNewMail;
    private String mDraftsFolderName;
    private String mSentFolderName;
    private String mTrashFolderName;
    private String mArchiveFolderName;
    private String mSpamFolderName;
    private String mOutboxFolderName;
    private String mAutoExpandFolderName;
    private FolderMode mFolderDisplayMode;
    private FolderMode mFolderSyncMode;
    private FolderMode mFolderPushMode;
    private FolderMode mFolderTargetMode;
    private int mAccountNumber;
    private boolean mSaveAllHeaders;
    private boolean mPushPollOnConnect;
    private boolean mNotifySync;
    private HideButtons mHideMessageViewButtons;
    private HideButtons mHideMessageViewMoveButtons;
    private ShowPictures mShowPictures;
    private boolean mEnableMoveButtons;
    private boolean mIsSignatureBeforeQuotedText;
    private String mExpungePolicy = EXPUNGE_IMMEDIATELY;
    private int mMaxPushFolders;
    private int mIdleRefreshMinutes;
    private boolean goToUnreadMessageSearch;
    private Map<String, Boolean> compressionMap = new ConcurrentHashMap<String, Boolean>();
    private Searchable searchableFolders;
    private boolean subscribedFoldersOnly;
    private int maximumPolledMessageAge;
    private int maximumAutoDownloadMessageSize;
    // Tracks if we have sent a notification for this account for
    // current set of fetched messages
    private boolean mRingNotified;
    private String mQuotePrefix;
    private boolean mReplyAfterQuote;
    private boolean mSyncRemoteDeletions;
    private String mCryptoApp;
    private boolean mCryptoAutoSignature;

    private CryptoProvider mCryptoProvider = null;

    /**
     * Name of the folder that was last selected for a copy or move operation.
     *
     * Note: For now this value isn't persisted. So it will be reset when
     *       K-9 Mail is restarted.
     */
    private String lastSelectedFolderName = null;

    private List<Identity> identities;

    private NotificationSetting mNotificationSetting = new NotificationSetting();

    public enum FolderMode
    {
        NONE, ALL, FIRST_CLASS, FIRST_AND_SECOND_CLASS, NOT_SECOND_CLASS;
    }

    public enum HideButtons
    {
        NEVER, ALWAYS, KEYBOARD_AVAILABLE;
    }

    public enum ShowPictures
    {
        NEVER, ALWAYS, ONLY_FROM_CONTACTS;
    }

    public enum Searchable
    {
        ALL, DISPLAYABLE, NONE
    }

    protected Account(Context context)
    {
        // TODO Change local store path to something readable / recognizable
        mUuid = UUID.randomUUID().toString();
        mLocalStoreUri = ""local://localhost/"" + context.getDatabasePath(mUuid + "".db"");
        mAutomaticCheckIntervalMinutes = -1;
        mIdleRefreshMinutes = 24;
        mSaveAllHeaders = false;
        mPushPollOnConnect = true;
        mDisplayCount = K9.DEFAULT_VISIBLE_LIMIT;
        mAccountNumber = -1;
        mNotifyNewMail = true;
        mNotifySync = true;
        mNotifySelfNewMail = true;
        mFolderDisplayMode = FolderMode.NOT_SECOND_CLASS;
        mFolderSyncMode = FolderMode.FIRST_CLASS;
        mFolderPushMode = FolderMode.FIRST_CLASS;
        mFolderTargetMode = FolderMode.NOT_SECOND_CLASS;
        mHideMessageViewButtons = HideButtons.NEVER;
        mHideMessageViewMoveButtons = HideButtons.NEVER;
        mShowPictures = ShowPictures.NEVER;
        mEnableMoveButtons = false;
        mIsSignatureBeforeQuotedText = false;
        mExpungePolicy = EXPUNGE_IMMEDIATELY;
        mAutoExpandFolderName = ""INBOX"";
        mMaxPushFolders = 10;
        mChipColor = (new Random()).nextInt(0xffffff) + 0xff000000;
        goToUnreadMessageSearch = false;
        subscribedFoldersOnly = false;
        maximumPolledMessageAge = -1;
        maximumAutoDownloadMessageSize = 32768;
        mQuotePrefix = DEFAULT_QUOTE_PREFIX;
        mReplyAfterQuote = DEFAULT_REPLY_AFTER_QUOTE;
        mSyncRemoteDeletions = true;
        mCryptoApp = Apg.NAME;
        mCryptoAutoSignature = false;

        searchableFolders = Searchable.ALL;

        identities = new ArrayList<Identity>();

        Identity identity = new Identity();
        identity.setSignatureUse(true);
        identity.setSignature(context.getString(R.string.default_signature));
        identity.setDescription(context.getString(R.string.default_identity_description));
        identities.add(identity);

        mNotificationSetting = new NotificationSetting();
        mNotificationSetting.setVibrate(false);
        mNotificationSetting.setVibratePattern(0);
        mNotificationSetting.setVibrateTimes(5);
        mNotificationSetting.setRing(true);
        mNotificationSetting.setRingtone(""content://settings/system/notification_sound"");
        mNotificationSetting.setLedColor(mChipColor);
    }

    protected Account(Preferences preferences, String uuid)
    {
        this.mUuid = uuid;
        loadAccount(preferences);
    }

    /**
     * Load stored settings for this account.
     */
    private synchronized void loadAccount(Preferences preferences)
    {

        SharedPreferences prefs = preferences.getPreferences();

        mStoreUri = Utility.base64Decode(prefs.getString(mUuid
                                         + "".storeUri"", null));
        mLocalStoreUri = prefs.getString(mUuid + "".localStoreUri"", null);
        mTransportUri = Utility.base64Decode(prefs.getString(mUuid
                                             + "".transportUri"", null));
        mDescription = prefs.getString(mUuid + "".description"", null);
        mAlwaysBcc = prefs.getString(mUuid + "".alwaysBcc"", mAlwaysBcc);
        mAutomaticCheckIntervalMinutes = prefs.getInt(mUuid
                                         + "".automaticCheckIntervalMinutes"", -1);
        mIdleRefreshMinutes = prefs.getInt(mUuid
                                           + "".idleRefreshMinutes"", 24);
        mSaveAllHeaders = prefs.getBoolean(mUuid
                                           + "".saveAllHeaders"", false);
        mPushPollOnConnect = prefs.getBoolean(mUuid
                                              + "".pushPollOnConnect"", true);
        mDisplayCount = prefs.getInt(mUuid + "".displayCount"", K9.DEFAULT_VISIBLE_LIMIT);
        if (mDisplayCount < 0)
        {
            mDisplayCount = K9.DEFAULT_VISIBLE_LIMIT;
        }
        mLastAutomaticCheckTime = prefs.getLong(mUuid
                                                + "".lastAutomaticCheckTime"", 0);
        mNotifyNewMail = prefs.getBoolean(mUuid + "".notifyNewMail"",
                                          false);
        mNotifySelfNewMail = prefs.getBoolean(mUuid + "".notifySelfNewMail"",
                                              true);
        mNotifySync = prefs.getBoolean(mUuid + "".notifyMailCheck"",
                                       false);
        mDeletePolicy = prefs.getInt(mUuid + "".deletePolicy"", 0);
        mDraftsFolderName = prefs.getString(mUuid  + "".draftsFolderName"",
                                            ""Drafts"");
        mSentFolderName = prefs.getString(mUuid  + "".sentFolderName"",
                                          ""Sent"");
        mTrashFolderName = prefs.getString(mUuid  + "".trashFolderName"",
                                           ""Trash"");
        mArchiveFolderName = prefs.getString(mUuid  + "".archiveFolderName"",
                                             ""Archive"");
        mSpamFolderName = prefs.getString(mUuid  + "".spamFolderName"",
                                          ""Spam"");
        mOutboxFolderName = prefs.getString(mUuid  + "".outboxFolderName"",
                                            ""Outbox"");
        mExpungePolicy = prefs.getString(mUuid  + "".expungePolicy"", EXPUNGE_IMMEDIATELY);
        mSyncRemoteDeletions = prefs.getBoolean(mUuid  + "".syncRemoteDeletions"", true);

        mMaxPushFolders = prefs.getInt(mUuid + "".maxPushFolders"", 10);
        goToUnreadMessageSearch = prefs.getBoolean(mUuid + "".goToUnreadMessageSearch"",
                                  false);
        subscribedFoldersOnly = prefs.getBoolean(mUuid + "".subscribedFoldersOnly"",
                                false);
        maximumPolledMessageAge = prefs.getInt(mUuid
                                               + "".maximumPolledMessageAge"", -1);
        maximumAutoDownloadMessageSize = prefs.getInt(mUuid
                                         + "".maximumAutoDownloadMessageSize"", 32768);
        mQuotePrefix = prefs.getString(mUuid + "".quotePrefix"", DEFAULT_QUOTE_PREFIX);
        mReplyAfterQuote = prefs.getBoolean(mUuid + "".replyAfterQuote"", DEFAULT_REPLY_AFTER_QUOTE);
        for (String type : networkTypes)
        {
            Boolean useCompression = prefs.getBoolean(mUuid + "".useCompression."" + type,
                                     true);
            compressionMap.put(type, useCompression);
        }

        mAutoExpandFolderName = prefs.getString(mUuid  + "".autoExpandFolderName"",
                                                ""INBOX"");

        mAccountNumber = prefs.getInt(mUuid + "".accountNumber"", 0);

        Random random = new Random((long)mAccountNumber+4);

        mChipColor = prefs.getInt(mUuid+"".chipColor"",
                                  (random.nextInt(0x70)) +
                                  (random.nextInt(0x70) * 0xff) +
                                  (random.nextInt(0x70) * 0xffff) +
                                  0xff000000);

        try
        {
            mHideMessageViewButtons = HideButtons.valueOf(prefs.getString(mUuid + "".hideButtonsEnum"",
                                      HideButtons.NEVER.name()));
        }
        catch (Exception e)
        {
            mHideMessageViewButtons = HideButtons.NEVER;
        }

        try
        {
            mHideMessageViewMoveButtons = HideButtons.valueOf(prefs.getString(mUuid + "".hideMoveButtonsEnum"",
                                          HideButtons.NEVER.name()));
        }
        catch (Exception e)
        {
            mHideMessageViewMoveButtons = HideButtons.NEVER;
        }

        try
        {
            mShowPictures = ShowPictures.valueOf(prefs.getString(mUuid + "".showPicturesEnum"",
                                                 ShowPictures.NEVER.name()));
        }
        catch (Exception e)
        {
            mShowPictures = ShowPictures.NEVER;
        }

        mEnableMoveButtons = prefs.getBoolean(mUuid + "".enableMoveButtons"", false);

        mNotificationSetting.setVibrate(prefs.getBoolean(mUuid + "".vibrate"", false));
        mNotificationSetting.setVibratePattern(prefs.getInt(mUuid + "".vibratePattern"", 0));
        mNotificationSetting.setVibrateTimes(prefs.getInt(mUuid + "".vibrateTimes"", 5));
        mNotificationSetting.setRing(prefs.getBoolean(mUuid + "".ring"", true));
        mNotificationSetting.setRingtone(prefs.getString(mUuid  + "".ringtone"",
                                       ""content://settings/system/notification_sound""));
        mNotificationSetting.setLed(prefs.getBoolean(mUuid + "".led"", true));
        mNotificationSetting.setLedColor(prefs.getInt(mUuid+"".ledColor"", mChipColor));

        try
        {
            mFolderDisplayMode = FolderMode.valueOf(prefs.getString(mUuid  + "".folderDisplayMode"",
                                                    FolderMode.NOT_SECOND_CLASS.name()));
        }
        catch (Exception e)
        {
            mFolderDisplayMode = FolderMode.NOT_SECOND_CLASS;
        }

        try
        {
            mFolderSyncMode = FolderMode.valueOf(prefs.getString(mUuid  + "".folderSyncMode"",
                                                 FolderMode.FIRST_CLASS.name()));
        }
        catch (Exception e)
        {
            mFolderSyncMode = FolderMode.FIRST_CLASS;
        }

        try
        {
            mFolderPushMode = FolderMode.valueOf(prefs.getString(mUuid  + "".folderPushMode"",
                                                 FolderMode.FIRST_CLASS.name()));
        }
        catch (Exception e)
        {
            mFolderPushMode = FolderMode.FIRST_CLASS;
        }

        try
        {
            mFolderTargetMode = FolderMode.valueOf(prefs.getString(mUuid  + "".folderTargetMode"",
                                                   FolderMode.NOT_SECOND_CLASS.name()));
        }
        catch (Exception e)
        {
            mFolderTargetMode = FolderMode.NOT_SECOND_CLASS;
        }

        try
        {
            searchableFolders = Searchable.valueOf(prefs.getString(mUuid  + "".searchableFolders"",
                                                   Searchable.ALL.name()));
        }
        catch (Exception e)
        {
            searchableFolders = Searchable.ALL;
        }

        mIsSignatureBeforeQuotedText = prefs.getBoolean(mUuid  + "".signatureBeforeQuotedText"", false);
        identities = loadIdentities(prefs);

        mCryptoApp = prefs.getString(mUuid + "".cryptoApp"", Apg.NAME);
        mCryptoAutoSignature = prefs.getBoolean(mUuid + "".cryptoAutoSignature"", false);
    }


    protected synchronized void delete(Preferences preferences)
    {
        String[] uuids = preferences.getPreferences().getString(""accountUuids"", """").split("","");
        StringBuffer sb = new StringBuffer();
        for (int i = 0, length = uuids.length; i < length; i++)
        {
            if (!uuids[i].equals(mUuid))
            {
                if (sb.length() > 0)
                {
                    sb.append(',');
                }
                sb.append(uuids[i]);
            }
        }
        String accountUuids = sb.toString();
        SharedPreferences.Editor editor = preferences.getPreferences().edit();
        editor.putString(""accountUuids"", accountUuids);

        editor.remove(mUuid + "".storeUri"");
        editor.remove(mUuid + "".localStoreUri"");
        editor.remove(mUuid + "".transportUri"");
        editor.remove(mUuid + "".description"");
        editor.remove(mUuid + "".name"");
        editor.remove(mUuid + "".email"");
        editor.remove(mUuid + "".alwaysBcc"");
        editor.remove(mUuid + "".automaticCheckIntervalMinutes"");
        editor.remove(mUuid + "".pushPollOnConnect"");
        editor.remove(mUuid + "".saveAllHeaders"");
        editor.remove(mUuid + "".idleRefreshMinutes"");
        editor.remove(mUuid + "".lastAutomaticCheckTime"");
        editor.remove(mUuid + "".notifyNewMail"");
        editor.remove(mUuid + "".notifySelfNewMail"");
        editor.remove(mUuid + "".deletePolicy"");
        editor.remove(mUuid + "".draftsFolderName"");
        editor.remove(mUuid + "".sentFolderName"");
        editor.remove(mUuid + "".trashFolderName"");
        editor.remove(mUuid + "".archiveFolderName"");
        editor.remove(mUuid + "".spamFolderName"");
        editor.remove(mUuid + "".outboxFolderName"");
        editor.remove(mUuid + "".autoExpandFolderName"");
        editor.remove(mUuid + "".accountNumber"");
        editor.remove(mUuid + "".vibrate"");
        editor.remove(mUuid + "".vibratePattern"");
        editor.remove(mUuid + "".vibrateTimes"");
        editor.remove(mUuid + "".ring"");
        editor.remove(mUuid + "".ringtone"");
        editor.remove(mUuid + "".lastFullSync"");
        editor.remove(mUuid + "".folderDisplayMode"");
        editor.remove(mUuid + "".folderSyncMode"");
        editor.remove(mUuid + "".folderPushMode"");
        editor.remove(mUuid + "".folderTargetMode"");
        editor.remove(mUuid + "".hideButtonsEnum"");
        editor.remove(mUuid + "".signatureBeforeQuotedText"");
        editor.remove(mUuid + "".expungePolicy"");
        editor.remove(mUuid + "".syncRemoteDeletions"");
        editor.remove(mUuid + "".maxPushFolders"");
        editor.remove(mUuid + "".searchableFolders"");
        editor.remove(mUuid + "".chipColor"");
        editor.remove(mUuid + "".led"");
        editor.remove(mUuid + "".ledColor"");
        editor.remove(mUuid + "".goToUnreadMessageSearch"");
        editor.remove(mUuid + "".subscribedFoldersOnly"");
        editor.remove(mUuid + "".maximumPolledMessageAge"");
        editor.remove(mUuid + "".maximumAutoDownloadMessageSize"");
        editor.remove(mUuid + "".quotePrefix"");
        editor.remove(mUuid + "".showPicturesEnum"");
        editor.remove(mUuid + "".replyAfterQuote"");
        editor.remove(mUuid + "".cryptoApp"");
        editor.remove(mUuid + "".cryptoAutoSignature"");
        editor.remove(mUuid + "".enableMoveButtons"");
        editor.remove(mUuid + "".hideMoveButtonsEnum"");
        for (String type : networkTypes)
        {
            editor.remove(mUuid + "".useCompression."" + type);
        }
        deleteIdentities(preferences.getPreferences(), editor);
        editor.commit();
    }

    public synchronized void save(Preferences preferences)
    {
        SharedPreferences.Editor editor = preferences.getPreferences().edit();

        if (!preferences.getPreferences().getString(""accountUuids"", """").contains(mUuid))
        {
            /*
             * When the account is first created we assign it a unique account number. The
             * account number will be unique to that account for the lifetime of the account.
             * So, we get all the existing account numbers, sort them ascending, loop through
             * the list and check if the number is greater than 1 + the previous number. If so
             * we use the previous number + 1 as the account number. This refills gaps.
             * mAccountNumber starts as -1 on a newly created account. It must be -1 for this
             * algorithm to work.
             *
             * I bet there is a much smarter way to do this. Anyone like to suggest it?
             */
            Account[] accounts = preferences.getAccounts();
            int[] accountNumbers = new int[accounts.length];
            for (int i = 0; i < accounts.length; i++)
            {
                accountNumbers[i] = accounts[i].getAccountNumber();
            }
            Arrays.sort(accountNumbers);
            for (int accountNumber : accountNumbers)
            {
                if (accountNumber > mAccountNumber + 1)
                {
                    break;
                }
                mAccountNumber = accountNumber;
            }
            mAccountNumber++;

            String accountUuids = preferences.getPreferences().getString(""accountUuids"", """");
            accountUuids += (accountUuids.length() != 0 ? "","" : """") + mUuid;
            editor.putString(""accountUuids"", accountUuids);
        }

        editor.putString(mUuid + "".storeUri"", Utility.base64Encode(mStoreUri));
        editor.putString(mUuid + "".localStoreUri"", mLocalStoreUri);
        editor.putString(mUuid + "".transportUri"", Utility.base64Encode(mTransportUri));
        editor.putString(mUuid + "".description"", mDescription);
        editor.putString(mUuid + "".alwaysBcc"", mAlwaysBcc);
        editor.putInt(mUuid + "".automaticCheckIntervalMinutes"", mAutomaticCheckIntervalMinutes);
        editor.putInt(mUuid + "".idleRefreshMinutes"", mIdleRefreshMinutes);
        editor.putBoolean(mUuid + "".saveAllHeaders"", mSaveAllHeaders);
        editor.putBoolean(mUuid + "".pushPollOnConnect"", mPushPollOnConnect);
        editor.putInt(mUuid + "".displayCount"", mDisplayCount);
        editor.putLong(mUuid + "".lastAutomaticCheckTime"", mLastAutomaticCheckTime);
        editor.putBoolean(mUuid + "".notifyNewMail"", mNotifyNewMail);
        editor.putBoolean(mUuid + "".notifySelfNewMail"", mNotifySelfNewMail);
        editor.putBoolean(mUuid + "".notifyMailCheck"", mNotifySync);
        editor.putInt(mUuid + "".deletePolicy"", mDeletePolicy);
        editor.putString(mUuid + "".draftsFolderName"", mDraftsFolderName);
        editor.putString(mUuid + "".sentFolderName"", mSentFolderName);
        editor.putString(mUuid + "".trashFolderName"", mTrashFolderName);
        editor.putString(mUuid + "".archiveFolderName"", mArchiveFolderName);
        editor.putString(mUuid + "".spamFolderName"", mSpamFolderName);
        editor.putString(mUuid + "".outboxFolderName"", mOutboxFolderName);
        editor.putString(mUuid + "".autoExpandFolderName"", mAutoExpandFolderName);
        editor.putInt(mUuid + "".accountNumber"", mAccountNumber);
        editor.putString(mUuid + "".hideButtonsEnum"", mHideMessageViewButtons.name());
        editor.putString(mUuid + "".hideMoveButtonsEnum"", mHideMessageViewMoveButtons.name());
        editor.putString(mUuid + "".showPicturesEnum"", mShowPictures.name());
        editor.putBoolean(mUuid + "".enableMoveButtons"", mEnableMoveButtons);
        editor.putString(mUuid + "".folderDisplayMode"", mFolderDisplayMode.name());
        editor.putString(mUuid + "".folderSyncMode"", mFolderSyncMode.name());
        editor.putString(mUuid + "".folderPushMode"", mFolderPushMode.name());
        editor.putString(mUuid + "".folderTargetMode"", mFolderTargetMode.name());
        editor.putBoolean(mUuid + "".signatureBeforeQuotedText"", this.mIsSignatureBeforeQuotedText);
        editor.putString(mUuid + "".expungePolicy"", mExpungePolicy);
        editor.putBoolean(mUuid + "".syncRemoteDeletions"", mSyncRemoteDeletions);
        editor.putInt(mUuid + "".maxPushFolders"", mMaxPushFolders);
        editor.putString(mUuid  + "".searchableFolders"", searchableFolders.name());
        editor.putInt(mUuid + "".chipColor"", mChipColor);
        editor.putBoolean(mUuid + "".goToUnreadMessageSearch"", goToUnreadMessageSearch);
        editor.putBoolean(mUuid + "".subscribedFoldersOnly"", subscribedFoldersOnly);
        editor.putInt(mUuid + "".maximumPolledMessageAge"", maximumPolledMessageAge);
        editor.putInt(mUuid + "".maximumAutoDownloadMessageSize"", maximumAutoDownloadMessageSize);
        editor.putString(mUuid + "".quotePrefix"", mQuotePrefix);
        editor.putString(mUuid + "".cryptoApp"", mCryptoApp);
        editor.putBoolean(mUuid + "".cryptoAutoSignature"", mCryptoAutoSignature);

        editor.putBoolean(mUuid + "".vibrate"", mNotificationSetting.isVibrate());
        editor.putInt(mUuid + "".vibratePattern"", mNotificationSetting.getVibratePattern());
        editor.putInt(mUuid + "".vibrateTimes"", mNotificationSetting.getVibrateTimes());
        editor.putBoolean(mUuid + "".ring"", mNotificationSetting.shouldRing());
        editor.putString(mUuid + "".ringtone"", mNotificationSetting.getRingtone());
        editor.putBoolean(mUuid + "".led"", mNotificationSetting.isLed());
        editor.putInt(mUuid + "".ledColor"", mNotificationSetting.getLedColor());

        for (String type : networkTypes)
        {
            Boolean useCompression = compressionMap.get(type);
            if (useCompression != null)
            {
                editor.putBoolean(mUuid + "".useCompression."" + type, useCompression);
            }
        }
        saveIdentities(preferences.getPreferences(), editor);

        editor.commit();

    }

    public AccountStats getStats(Context context) throws MessagingException
    {
        long startTime = System.currentTimeMillis();
        AccountStats stats = new AccountStats();
        int unreadMessageCount = 0;
        int flaggedMessageCount = 0;
        LocalStore localStore = getLocalStore();
        if (K9.measureAccounts())
        {
            stats.size = localStore.getSize();
        }
        Account.FolderMode aMode = getFolderDisplayMode();
        Preferences prefs = Preferences.getPreferences(context);
        long folderLoadStart = System.currentTimeMillis();
        List<? extends Folder> folders = localStore.getPersonalNamespaces(false);
        long folderLoadEnd = System.currentTimeMillis();
        long folderEvalStart = folderLoadEnd;
        for (Folder folder : folders)
        {
            LocalFolder localFolder = (LocalFolder)folder;
            //folder.refresh(prefs);
            Folder.FolderClass fMode = localFolder.getDisplayClass(prefs);

            // Always get stats about the INBOX (see issue 1817)
            if (folder.getName().equals(K9.INBOX) || (
                        !folder.getName().equals(getTrashFolderName()) &&
                        !folder.getName().equals(getDraftsFolderName()) &&
                        !folder.getName().equals(getArchiveFolderName()) &&
                        !folder.getName().equals(getSpamFolderName()) &&
                        !folder.getName().equals(getOutboxFolderName()) &&
                        !folder.getName().equals(getSentFolderName()) &&
                        !folder.getName().equals(getErrorFolderName())))
            {
                if (aMode == Account.FolderMode.NONE)
                {
                    continue;
                }
                if (aMode == Account.FolderMode.FIRST_CLASS &&
                        fMode != Folder.FolderClass.FIRST_CLASS)
                {
                    continue;
                }
                if (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
                        fMode != Folder.FolderClass.FIRST_CLASS &&
                        fMode != Folder.FolderClass.SECOND_CLASS)
                {
                    continue;
                }
                if (aMode == Account.FolderMode.NOT_SECOND_CLASS &&
                        fMode == Folder.FolderClass.SECOND_CLASS)
                {
                    continue;
                }
                unreadMessageCount += folder.getUnreadMessageCount();
                flaggedMessageCount += folder.getFlaggedMessageCount();

            }
        }
        long folderEvalEnd = System.currentTimeMillis();
        stats.unreadMessageCount = unreadMessageCount;
        stats.flaggedMessageCount = flaggedMessageCount;
        long endTime = System.currentTimeMillis();
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""Account.getStats() on "" + getDescription() + "" took "" + (endTime - startTime) + "" ms;""
                  + "" loading "" + folders.size() + "" took "" + (folderLoadEnd - folderLoadStart) + "" ms;""
                  + "" evaluating took "" + (folderEvalEnd - folderEvalStart) + "" ms"");
        return stats;
    }


    public synchronized void setChipColor(int color)
    {
        mChipColor = color;
    }

    public synchronized int getChipColor()
    {
        return mChipColor;
    }


    public String getUuid()
    {
        return mUuid;
    }

    public Uri getContentUri()
    {
        return Uri.parse(""content://accounts/"" + getUuid());
    }

    public synchronized String getStoreUri()
    {
        return mStoreUri;
    }

    public synchronized void setStoreUri(String storeUri)
    {
        this.mStoreUri = storeUri;
    }

    public synchronized String getTransportUri()
    {
        return mTransportUri;
    }

    public synchronized void setTransportUri(String transportUri)
    {
        this.mTransportUri = transportUri;
    }

    public synchronized String getDescription()
    {
        return mDescription;
    }

    public synchronized void setDescription(String description)
    {
        this.mDescription = description;
    }

    public synchronized String getName()
    {
        return identities.get(0).getName();
    }

    public synchronized void setName(String name)
    {
        identities.get(0).setName(name);
    }

    public synchronized boolean getSignatureUse()
    {
        return identities.get(0).getSignatureUse();
    }

    public synchronized void setSignatureUse(boolean signatureUse)
    {
        identities.get(0).setSignatureUse(signatureUse);
    }

    public synchronized String getSignature()
    {
        return identities.get(0).getSignature();
    }

    public synchronized void setSignature(String signature)
    {
        identities.get(0).setSignature(signature);
    }

    public synchronized String getEmail()
    {
        return identities.get(0).getEmail();
    }

    public synchronized void setEmail(String email)
    {
        identities.get(0).setEmail(email);
    }

    public synchronized String getAlwaysBcc()
    {
        return mAlwaysBcc;
    }

    public synchronized void setAlwaysBcc(String alwaysBcc)
    {
        this.mAlwaysBcc = alwaysBcc;
    }

    /* Have we sent a new mail notification on this account */
    public boolean isRingNotified()
    {
        return mRingNotified;
    }

    public void setRingNotified(boolean ringNotified)
    {
        mRingNotified = ringNotified;
    }

    public synchronized String getLocalStoreUri()
    {
        return mLocalStoreUri;
    }

    public synchronized void setLocalStoreUri(String localStoreUri)
    {
        this.mLocalStoreUri = localStoreUri;
    }

    /**
     * Returns -1 for never.
     */
    public synchronized int getAutomaticCheckIntervalMinutes()
    {
        return mAutomaticCheckIntervalMinutes;
    }

    /**
     * @param automaticCheckIntervalMinutes or -1 for never.
     */
    public synchronized boolean setAutomaticCheckIntervalMinutes(int automaticCheckIntervalMinutes)
    {
        int oldInterval = this.mAutomaticCheckIntervalMinutes;
        int newInterval = automaticCheckIntervalMinutes;
        this.mAutomaticCheckIntervalMinutes = automaticCheckIntervalMinutes;

        return (oldInterval != newInterval);
    }

    public synchronized int getDisplayCount()
    {
        return mDisplayCount;
    }

    public synchronized void setDisplayCount(int displayCount)
    {
        if (displayCount != -1)
        {
            this.mDisplayCount = displayCount;
        }
        else
        {
            this.mDisplayCount = K9.DEFAULT_VISIBLE_LIMIT;
        }
    }

    public synchronized long getLastAutomaticCheckTime()
    {
        return mLastAutomaticCheckTime;
    }

    public synchronized void setLastAutomaticCheckTime(long lastAutomaticCheckTime)
    {
        this.mLastAutomaticCheckTime = lastAutomaticCheckTime;
    }

    public synchronized boolean isNotifyNewMail()
    {
        return mNotifyNewMail;
    }

    public synchronized void setNotifyNewMail(boolean notifyNewMail)
    {
        this.mNotifyNewMail = notifyNewMail;
    }

    public synchronized int getDeletePolicy()
    {
        return mDeletePolicy;
    }

    public synchronized void setDeletePolicy(int deletePolicy)
    {
        this.mDeletePolicy = deletePolicy;
    }

    public synchronized String getDraftsFolderName()
    {
        return mDraftsFolderName;
    }

    public synchronized void setDraftsFolderName(String draftsFolderName)
    {
        mDraftsFolderName = draftsFolderName;
    }

    public synchronized String getSentFolderName()
    {
        return mSentFolderName;
    }

    public synchronized String getErrorFolderName()
    {
        return K9.ERROR_FOLDER_NAME;
    }

    public synchronized void setSentFolderName(String sentFolderName)
    {
        mSentFolderName = sentFolderName;
    }

    public synchronized String getTrashFolderName()
    {
        return mTrashFolderName;
    }

    public synchronized void setTrashFolderName(String trashFolderName)
    {
        mTrashFolderName = trashFolderName;
    }

    public synchronized String getArchiveFolderName()
    {
        return mArchiveFolderName;
    }

    public synchronized void setArchiveFolderName(String archiveFolderName)
    {
        mArchiveFolderName = archiveFolderName;
    }

    public synchronized String getSpamFolderName()
    {
        return mSpamFolderName;
    }

    public synchronized void setSpamFolderName(String spamFolderName)
    {
        mSpamFolderName = spamFolderName;
    }

    public synchronized String getOutboxFolderName()
    {
        return mOutboxFolderName;
    }

    public synchronized void setOutboxFolderName(String outboxFolderName)
    {
        mOutboxFolderName = outboxFolderName;
    }

    public synchronized String getAutoExpandFolderName()
    {
        return mAutoExpandFolderName;
    }

    public synchronized void setAutoExpandFolderName(String autoExpandFolderName)
    {
        mAutoExpandFolderName = autoExpandFolderName;
    }

    public synchronized int getAccountNumber()
    {
        return mAccountNumber;
    }

    public synchronized FolderMode getFolderDisplayMode()
    {
        return mFolderDisplayMode;
    }

    public synchronized boolean setFolderDisplayMode(FolderMode displayMode)
    {
        FolderMode oldDisplayMode = mFolderDisplayMode;
        mFolderDisplayMode = displayMode;
        return oldDisplayMode != displayMode;
    }

    public synchronized FolderMode getFolderSyncMode()
    {
        return mFolderSyncMode;
    }

    public synchronized boolean setFolderSyncMode(FolderMode syncMode)
    {
        FolderMode oldSyncMode = mFolderSyncMode;
        mFolderSyncMode = syncMode;

        if (syncMode == FolderMode.NONE && oldSyncMode != FolderMode.NONE)
        {
            return true;
        }
        if (syncMode != FolderMode.NONE && oldSyncMode == FolderMode.NONE)
        {
            return true;
        }
        return false;
    }

    public synchronized FolderMode getFolderPushMode()
    {
        return mFolderPushMode;
    }

    public synchronized boolean setFolderPushMode(FolderMode pushMode)
    {
        FolderMode oldPushMode = mFolderPushMode;

        mFolderPushMode = pushMode;
        return pushMode != oldPushMode;
    }

    public synchronized boolean isShowOngoing()
    {
        return mNotifySync;
    }

    public synchronized void setShowOngoing(boolean showOngoing)
    {
        this.mNotifySync = showOngoing;
    }

    public synchronized HideButtons getHideMessageViewButtons()
    {
        return mHideMessageViewButtons;
    }

    public synchronized void setHideMessageViewButtons(HideButtons hideMessageViewButtons)
    {
        mHideMessageViewButtons = hideMessageViewButtons;
    }

    public synchronized HideButtons getHideMessageViewMoveButtons()
    {
        return mHideMessageViewMoveButtons;
    }

    public synchronized void setHideMessageViewMoveButtons(HideButtons hideMessageViewButtons)
    {
        mHideMessageViewMoveButtons = hideMessageViewButtons;
    }

    public synchronized ShowPictures getShowPictures()
    {
        return mShowPictures;
    }

    public synchronized void setShowPictures(ShowPictures showPictures)
    {
        mShowPictures = showPictures;
    }

    public synchronized FolderMode getFolderTargetMode()
    {
        return mFolderTargetMode;
    }

    public synchronized void setFolderTargetMode(FolderMode folderTargetMode)
    {
        mFolderTargetMode = folderTargetMode;
    }

    public synchronized boolean isSignatureBeforeQuotedText()
    {
        return mIsSignatureBeforeQuotedText;
    }

    public synchronized void setSignatureBeforeQuotedText(boolean mIsSignatureBeforeQuotedText)
    {
        this.mIsSignatureBeforeQuotedText = mIsSignatureBeforeQuotedText;
    }

    public synchronized boolean isNotifySelfNewMail()
    {
        return mNotifySelfNewMail;
    }

    public synchronized void setNotifySelfNewMail(boolean notifySelfNewMail)
    {
        mNotifySelfNewMail = notifySelfNewMail;
    }

    public synchronized String getExpungePolicy()
    {
        return mExpungePolicy;
    }

    public synchronized void setExpungePolicy(String expungePolicy)
    {
        mExpungePolicy = expungePolicy;
    }

    public synchronized int getMaxPushFolders()
    {
        return mMaxPushFolders;
    }

    public synchronized boolean setMaxPushFolders(int maxPushFolders)
    {
        int oldMaxPushFolders = mMaxPushFolders;
        mMaxPushFolders = maxPushFolders;
        return oldMaxPushFolders != maxPushFolders;
    }

    public LocalStore getLocalStore() throws MessagingException
    {
        return Store.getLocalInstance(this, K9.app);
    }

    public Store getRemoteStore() throws MessagingException
    {
        return Store.getRemoteInstance(this);
    }

    @Override
    public synchronized String toString()
    {
        return mDescription;
    }

    public synchronized void setCompression(String networkType, boolean useCompression)
    {
        compressionMap.put(networkType, useCompression);
    }

    public synchronized boolean useCompression(String networkType)
    {
        Boolean useCompression = compressionMap.get(networkType);
        if (useCompression == null)
        {
            return true;
        }
        else
        {
            return useCompression;
        }
    }

    public boolean useCompression(int type)
    {
        String networkType = TYPE_OTHER;
        switch (type)
        {
            case ConnectivityManager.TYPE_MOBILE:
                networkType = TYPE_MOBILE;
                break;
            case ConnectivityManager.TYPE_WIFI:
                networkType = TYPE_WIFI;
                break;
        }
        return useCompression(networkType);
    }

    @Override
    public boolean equals(Object o)
    {
        if (o instanceof Account)
        {
            return ((Account)o).mUuid.equals(mUuid);
        }
        return super.equals(o);
    }

    @Override
    public int hashCode()
    {
        return mUuid.hashCode();
    }


    private synchronized List<Identity> loadIdentities(SharedPreferences prefs)
    {
        List<Identity> newIdentities = new ArrayList<Identity>();
        int ident = 0;
        boolean gotOne = false;
        do
        {
            gotOne = false;
            String name = prefs.getString(mUuid + "".name."" + ident, null);
            String email = prefs.getString(mUuid + "".email."" + ident, null);
            boolean signatureUse = prefs.getBoolean(mUuid  + "".signatureUse."" + ident, true);
            String signature = prefs.getString(mUuid + "".signature."" + ident, null);
            String description = prefs.getString(mUuid + "".description."" + ident, null);
            final String replyTo = prefs.getString(mUuid + "".replyTo."" + ident, null);
            if (email != null)
            {
                Identity identity = new Identity();
                identity.setName(name);
                identity.setEmail(email);
                identity.setSignatureUse(signatureUse);
                identity.setSignature(signature);
                identity.setDescription(description);
                identity.setReplyTo(replyTo);
                newIdentities.add(identity);
                gotOne = true;
            }
            ident++;
        }
        while (gotOne);

        if (newIdentities.size() == 0)
        {
            String name = prefs.getString(mUuid + "".name"", null);
            String email = prefs.getString(mUuid + "".email"", null);
            boolean signatureUse = prefs.getBoolean(mUuid  + "".signatureUse"", true);
            String signature = prefs.getString(mUuid + "".signature"", null);
            Identity identity = new Identity();
            identity.setName(name);
            identity.setEmail(email);
            identity.setSignatureUse(signatureUse);
            identity.setSignature(signature);
            identity.setDescription(email);
            newIdentities.add(identity);
        }

        return newIdentities;
    }

    private synchronized void deleteIdentities(SharedPreferences prefs, SharedPreferences.Editor editor)
    {
        int ident = 0;
        boolean gotOne = false;
        do
        {
            gotOne = false;
            String email = prefs.getString(mUuid + "".email."" + ident, null);
            if (email != null)
            {
                editor.remove(mUuid + "".name."" + ident);
                editor.remove(mUuid + "".email."" + ident);
                editor.remove(mUuid + "".signatureUse."" + ident);
                editor.remove(mUuid + "".signature."" + ident);
                editor.remove(mUuid + "".description."" + ident);
                editor.remove(mUuid + "".replyTo."" + ident);
                gotOne = true;
            }
            ident++;
        }
        while (gotOne);
    }

    private synchronized void saveIdentities(SharedPreferences prefs, SharedPreferences.Editor editor)
    {
        deleteIdentities(prefs, editor);
        int ident = 0;

        for (Identity identity : identities)
        {
            editor.putString(mUuid + "".name."" + ident, identity.getName());
            editor.putString(mUuid + "".email."" + ident, identity.getEmail());
            editor.putBoolean(mUuid + "".signatureUse."" + ident, identity.getSignatureUse());
            editor.putString(mUuid + "".signature."" + ident, identity.getSignature());
            editor.putString(mUuid + "".description."" + ident, identity.getDescription());
            editor.putString(mUuid + "".replyTo."" + ident, identity.getReplyTo());
            ident++;
        }
    }

    public synchronized List<Identity> getIdentities()
    {
        return identities;
    }

    public synchronized void setIdentities(List<Identity> newIdentities)
    {
        identities = new ArrayList<Identity>(newIdentities);
    }

    public synchronized Identity getIdentity(int i)
    {
        if (i < identities.size())
        {
            return identities.get(i);
        }
        return null;
    }

    public boolean isAnIdentity(Address[] addrs)
    {
        if (addrs == null)
        {
            return false;
        }
        for (Address addr : addrs)
        {
            if (findIdentity(addr) != null)
            {
                return true;
            }
        }

        return false;
    }

    public boolean isAnIdentity(Address addr)
    {
        return findIdentity(addr) != null;
    }

    public synchronized Identity findIdentity(Address addr)
    {
        for (Identity identity : identities)
        {
            String email = identity.getEmail();
            if (email != null && email.equalsIgnoreCase(addr.getAddress()))
            {
                return identity;
            }
        }
        return null;
    }

    public synchronized Searchable getSearchableFolders()
    {
        return searchableFolders;
    }

    public synchronized void setSearchableFolders(Searchable searchableFolders)
    {
        this.searchableFolders = searchableFolders;
    }

    public synchronized int getIdleRefreshMinutes()
    {
        return mIdleRefreshMinutes;
    }

    public synchronized void setIdleRefreshMinutes(int idleRefreshMinutes)
    {
        mIdleRefreshMinutes = idleRefreshMinutes;
    }

    public synchronized boolean isPushPollOnConnect()
    {
        return mPushPollOnConnect;
    }

    public synchronized void setPushPollOnConnect(boolean pushPollOnConnect)
    {
        mPushPollOnConnect = pushPollOnConnect;
    }

    public synchronized boolean isSaveAllHeaders()
    {
        return mSaveAllHeaders;
    }

    public synchronized void setSaveAllHeaders(boolean saveAllHeaders)
    {
        mSaveAllHeaders = saveAllHeaders;
    }

    public synchronized boolean goToUnreadMessageSearch()
    {
        return goToUnreadMessageSearch;
    }

    public synchronized void setGoToUnreadMessageSearch(boolean goToUnreadMessageSearch)
    {
        this.goToUnreadMessageSearch = goToUnreadMessageSearch;
    }

    public synchronized boolean subscribedFoldersOnly()
    {
        return subscribedFoldersOnly;
    }

    public synchronized void setSubscribedFoldersOnly(boolean subscribedFoldersOnly)
    {
        this.subscribedFoldersOnly = subscribedFoldersOnly;
    }

    public synchronized int getMaximumPolledMessageAge()
    {
        return maximumPolledMessageAge;
    }

    public synchronized void setMaximumPolledMessageAge(int maximumPolledMessageAge)
    {
        this.maximumPolledMessageAge = maximumPolledMessageAge;
    }

    public synchronized int getMaximumAutoDownloadMessageSize()
    {
        return maximumAutoDownloadMessageSize;
    }

    public synchronized void setMaximumAutoDownloadMessageSize(int maximumAutoDownloadMessageSize)
    {
        this.maximumAutoDownloadMessageSize = maximumAutoDownloadMessageSize;
    }

    public Date getEarliestPollDate()
    {
        int age = getMaximumPolledMessageAge();
        if (age >= 0)
        {
            Calendar now = Calendar.getInstance();
            now.set(Calendar.HOUR_OF_DAY, 0);
            now.set(Calendar.MINUTE, 0);
            now.set(Calendar.SECOND, 0);
            now.set(Calendar.MILLISECOND, 0);
            if (age < 28)
            {
                now.add(Calendar.DATE, age * -1);
            }
            else switch (age)
                {
                    case 28:
                        now.add(Calendar.MONTH, -1);
                        break;
                    case 56:
                        now.add(Calendar.MONTH, -2);
                        break;
                    case 84:
                        now.add(Calendar.MONTH, -3);
                        break;
                    case 168:
                        now.add(Calendar.MONTH, -6);
                        break;
                    case 365:
                        now.add(Calendar.YEAR, -1);
                        break;
                }

            return now.getTime();
        }
        else
        {
            return null;
        }
    }

    public synchronized String getQuotePrefix()
    {
        return mQuotePrefix;
    }

    public synchronized void setQuotePrefix(String quotePrefix)
    {
        mQuotePrefix = quotePrefix;
    }

    public synchronized boolean isReplyAfterQuote()
    {
        return mReplyAfterQuote;
    }

    public synchronized void setReplyAfterQuote(boolean replyAfterQuote)
    {
        mReplyAfterQuote = replyAfterQuote;
    }

    public boolean getEnableMoveButtons()
    {
        return mEnableMoveButtons;
    }

    public void setEnableMoveButtons(boolean enableMoveButtons)
    {
        mEnableMoveButtons = enableMoveButtons;
    }

    public String getCryptoApp()
    {
        return mCryptoApp;
    }

    public void setCryptoApp(String cryptoApp)
    {
        mCryptoApp = cryptoApp;
        // invalidate the provider
        mCryptoProvider = null;
    }

    public boolean getCryptoAutoSignature()
    {
        return mCryptoAutoSignature;
    }

    public void setCryptoAutoSignature(boolean cryptoAutoSignature)
    {
        mCryptoAutoSignature = cryptoAutoSignature;
    }
    public synchronized boolean syncRemoteDeletions()
    {
        return mSyncRemoteDeletions;
    }

    public synchronized void setSyncRemoteDeletions(boolean syncRemoteDeletions)
    {
        mSyncRemoteDeletions = syncRemoteDeletions;
    }

    public synchronized String getLastSelectedFolderName()
    {
        return lastSelectedFolderName;
    }

    public synchronized void setLastSelectedFolderName(String folderName)
    {
        lastSelectedFolderName = folderName;
    }

    public synchronized CryptoProvider getCryptoProvider()
    {
        if (mCryptoProvider == null)
        {
            mCryptoProvider = CryptoProvider.createInstance(getCryptoApp());
        }
        return mCryptoProvider;
    }

    public synchronized NotificationSetting getNotificationSetting()
    {
        return mNotificationSetting;
    }

}
",True,220,1,4,7,54,46,14,L1
2,com.fsck.k9.SearchSpecification.java,"
package com.fsck.k9;

import com.fsck.k9.mail.Flag;

public interface SearchSpecification
{

    public Flag[] getRequiredFlags();

    public Flag[] getForbiddenFlags();

    public boolean isIntegrate();

    public String getQuery();

    public String[] getAccountUuids();

    public String[] getFolderNames();
}",False,93,6,44,1,1,6,1,L1
3,com.fsck.k9.FontSizes.java,"package com.fsck.k9;

import android.content.SharedPreferences;
import android.webkit.WebSettings.TextSize;

/**
 * Manage font size of the information displayed in the account list, folder
 * list, message list and in the message view.
 */
public class FontSizes
{
    /*
     * Keys for the preference storage.
     */
    private static final String ACCOUNT_NAME = ""fontSizeAccountName"";
    private static final String ACCOUNT_DESCRIPTION = ""fontSizeAccountDescription"";
    private static final String FOLDER_NAME = ""fontSizeFolderName"";
    private static final String FOLDER_STATUS = ""fontSizeFolderStatus"";
    private static final String MESSAGE_LIST_SUBJECT = ""fontSizeMessageListSubject"";
    private static final String MESSAGE_LIST_SENDER = ""fontSizeMessageListSender"";
    private static final String MESSAGE_LIST_DATE = ""fontSizeMessageListDate"";
    private static final String MESSAGE_VIEW_SENDER = ""fontSizeMessageViewSender"";
    private static final String MESSAGE_VIEW_TO = ""fontSizeMessageViewTo"";
    private static final String MESSAGE_VIEW_CC = ""fontSizeMessageViewCC"";
    private static final String MESSAGE_VIEW_ADDITIONAL_HEADERS = ""fontSizeMessageViewAdditionalHeaders"";
    private static final String MESSAGE_VIEW_SUBJECT = ""fontSizeMessageViewSubject"";
    private static final String MESSAGE_VIEW_TIME = ""fontSizeMessageViewTime"";
    private static final String MESSAGE_VIEW_DATE = ""fontSizeMessageViewDate"";
    private static final String MESSAGE_VIEW_CONTENT = ""fontSizeMessageViewContent"";

    /*
     * Values for the font sizes in DIP (device independent pixel)
     */
    public static final int FONT_10DIP = 10;
    public static final int FONT_12DIP = 12;
    public static final int SMALL = 14;         // ?android:attr/textAppearanceSmall
    public static final int FONT_16DIP = 16;
    public static final int MEDIUM = 18;        // ?android:attr/textAppearanceMedium
    public static final int FONT_20DIP = 20;
    public static final int LARGE = 22;         // ?android:attr/textAppearanceLarge


    /**
     * Font size of account names in the account list activity.
     */
    private int accountName;

    /**
     * Font size of account descriptions in the account list activity.
     */
    private int accountDescription;

    /**
     * Font size of folder names in the folder list activity.
     */
    private int folderName;

    /**
     * Font size of the folder status in the folder list activity.
     */
    private int folderStatus;

    /**
     * Font size of message subjects in the message list activity.
     */
    private int messageListSubject;

    /**
     * Font size of message senders in the message list activity.
     */
    private int messageListSender;

    /**
     * Font size of message dates in the message list activity.
     */
    private int messageListDate;

    /**
     * Font size of the message sender in the message view activity.
     */
    private int messageViewSender;

    /**
     * Font size of the message receiver(s) (To) in the message view activity.
     */
    private int messageViewTo;

    /**
     * Font size of the message receiver(s) (CC) in the message view activity.
     */
    private int messageViewCC;

    /**
     * Font size of additional headers in the message view activity.
     */
    private int messageViewAdditionalHeaders;

    /**
     * Font size of the message subject in the message view activity.
     */
    private int messageViewSubject;

    /**
     * Font size of the message time in the message view activity.
     */
    private int messageViewTime;

    /**
     * Font size of the message date in the message view activity.
     */
    private int messageViewDate;

    /**
     * Font size of the message content in the message view activity.
     *
     * Note: The unit is WebSettings.TextSize
     */
    private TextSize messageViewContent = TextSize.NORMAL;

    /**
     * Create a <code>FontSizes</code> object with default values.
     */
    public FontSizes()
    {
        accountName = MEDIUM;
        accountDescription = SMALL;

        folderName = LARGE;
        folderStatus = SMALL;

        messageListSubject = SMALL;
        messageListSender = SMALL;
        messageListDate = SMALL;

        messageViewSender = SMALL;
        messageViewTo = FONT_12DIP;
        messageViewCC = FONT_12DIP;
        messageViewAdditionalHeaders = FONT_12DIP;
        messageViewSubject = FONT_12DIP;
        messageViewTime = FONT_10DIP;
        messageViewDate = FONT_10DIP;
    }

    /**
     * Permanently save the font size settings.
     *
     * @param editor Used to save the font size settings.
     */
    public void save(SharedPreferences.Editor editor)
    {
        editor.putInt(ACCOUNT_NAME, accountName);
        editor.putInt(ACCOUNT_DESCRIPTION, accountDescription);

        editor.putInt(FOLDER_NAME, folderName);
        editor.putInt(FOLDER_STATUS, folderStatus);

        editor.putInt(MESSAGE_LIST_SUBJECT, messageListSubject);
        editor.putInt(MESSAGE_LIST_SENDER, messageListSender);
        editor.putInt(MESSAGE_LIST_DATE, messageListDate);

        editor.putInt(MESSAGE_VIEW_SENDER, messageViewSender);
        editor.putInt(MESSAGE_VIEW_TO, messageViewTo);
        editor.putInt(MESSAGE_VIEW_CC, messageViewCC);
        editor.putInt(MESSAGE_VIEW_ADDITIONAL_HEADERS, messageViewAdditionalHeaders);
        editor.putInt(MESSAGE_VIEW_SUBJECT, messageViewSubject);
        editor.putInt(MESSAGE_VIEW_TIME, messageViewTime);
        editor.putInt(MESSAGE_VIEW_DATE, messageViewDate);
        editor.putInt(MESSAGE_VIEW_CONTENT, getMessageViewContentAsInt());
    }

    /**
     * Load the font size settings from permanent storage.
     *
     * @param prefs Used to load the font size settings.
     */
    public void load(SharedPreferences prefs)
    {
        accountName = prefs.getInt(ACCOUNT_NAME, accountName);
        accountDescription = prefs.getInt(ACCOUNT_DESCRIPTION, accountDescription);

        folderName = prefs.getInt(FOLDER_NAME, folderName);
        folderStatus = prefs.getInt(FOLDER_STATUS, folderStatus);

        messageListSubject = prefs.getInt(MESSAGE_LIST_SUBJECT, messageListSubject);
        messageListSender = prefs.getInt(MESSAGE_LIST_SENDER, messageListSender);
        messageListDate = prefs.getInt(MESSAGE_LIST_DATE, messageListDate);

        messageViewSender = prefs.getInt(MESSAGE_VIEW_SENDER, messageViewSender);
        messageViewTo = prefs.getInt(MESSAGE_VIEW_TO, messageViewTo);
        messageViewCC = prefs.getInt(MESSAGE_VIEW_CC, messageViewCC);
        messageViewAdditionalHeaders = prefs.getInt(MESSAGE_VIEW_ADDITIONAL_HEADERS, messageViewAdditionalHeaders);
        messageViewSubject = prefs.getInt(MESSAGE_VIEW_SUBJECT, messageViewSubject);
        messageViewTime = prefs.getInt(MESSAGE_VIEW_TIME, messageViewTime);
        messageViewDate = prefs.getInt(MESSAGE_VIEW_DATE, messageViewDate);
        setMessageViewContent(prefs.getInt(MESSAGE_VIEW_CONTENT, 3));
    }

    public int getAccountName()
    {
        return accountName;
    }

    public void setAccountName(int accountName)
    {
        this.accountName = accountName;
    }

    public int getAccountDescription()
    {
        return accountDescription;
    }

    public void setAccountDescription(int accountDescription)
    {
        this.accountDescription = accountDescription;
    }

    public int getFolderName()
    {
        return folderName;
    }

    public void setFolderName(int folderName)
    {
        this.folderName = folderName;
    }

    public int getFolderStatus()
    {
        return folderStatus;
    }

    public void setFolderStatus(int folderStatus)
    {
        this.folderStatus = folderStatus;
    }

    public int getMessageListSubject()
    {
        return messageListSubject;
    }

    public void setMessageListSubject(int messageListSubject)
    {
        this.messageListSubject = messageListSubject;
    }

    public int getMessageListSender()
    {
        return messageListSender;
    }

    public void setMessageListSender(int messageListSender)
    {
        this.messageListSender = messageListSender;
    }

    public int getMessageListDate()
    {
        return messageListDate;
    }

    public void setMessageListDate(int messageListDate)
    {
        this.messageListDate = messageListDate;
    }

    public int getMessageViewSender()
    {
        return messageViewSender;
    }

    public void setMessageViewSender(int messageViewSender)
    {
        this.messageViewSender = messageViewSender;
    }

    public int getMessageViewTo()
    {
        return messageViewTo;
    }

    public void setMessageViewTo(int messageViewTo)
    {
        this.messageViewTo = messageViewTo;
    }

    public int getMessageViewCC()
    {
        return messageViewCC;
    }

    public void setMessageViewCC(int messageViewCC)
    {
        this.messageViewCC = messageViewCC;
    }

    public int getMessageViewAdditionalHeaders()
    {
        return messageViewAdditionalHeaders;
    }

    public void setMessageViewAdditionalHeaders(int messageViewAdditionalHeaders)
    {
        this.messageViewAdditionalHeaders = messageViewAdditionalHeaders;
    }

    public int getMessageViewSubject()
    {
        return messageViewSubject;
    }

    public void setMessageViewSubject(int messageViewSubject)
    {
        this.messageViewSubject = messageViewSubject;
    }

    public int getMessageViewTime()
    {
        return messageViewTime;
    }

    public void setMessageViewTime(int messageViewTime)
    {
        this.messageViewTime = messageViewTime;
    }

    public int getMessageViewDate()
    {
        return messageViewDate;
    }

    public void setMessageViewDate(int messageViewDate)
    {
        this.messageViewDate = messageViewDate;
    }

    public TextSize getMessageViewContent()
    {
        return messageViewContent;
    }

    public int getMessageViewContentAsInt()
    {
        switch (messageViewContent)
        {
            case SMALLEST:
                return 1;
            case SMALLER:
                return 2;
            default:
            case NORMAL:
                return 3;
            case LARGER:
                return 4;
            case LARGEST:
                return 5;
        }
    }

    public void setMessageViewContent(int size)
    {
        switch (size)
        {
            case 1:
                messageViewContent = TextSize.SMALLEST;
                break;
            case 2:
                messageViewContent = TextSize.SMALLER;
                break;
            case 3:
                messageViewContent = TextSize.NORMAL;
                break;
            case 4:
                messageViewContent = TextSize.LARGER;
                break;
            case 5:
                messageViewContent = TextSize.LARGEST;
                break;
        }
    }
}
",False,92,5,55,0,0,9,0,L1
4,com.fsck.k9.EmailAddressAdapter.java,"/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9;

import com.fsck.k9.helper.Contacts;
import com.fsck.k9.mail.Address;
import android.content.Context;
import android.database.Cursor;
import android.view.View;
import android.widget.ResourceCursorAdapter;
import android.widget.TextView;

public class EmailAddressAdapter extends ResourceCursorAdapter
{
    private static EmailAddressAdapter sInstance;

    public static EmailAddressAdapter getInstance(Context context)
    {
        if (sInstance == null)
        {
            sInstance = new EmailAddressAdapter(context);
        }

        return sInstance;
    }


    private Contacts mContacts;

    private EmailAddressAdapter(Context context)
    {
        super(context, R.layout.recipient_dropdown_item, null);
        mContacts = Contacts.getInstance(context);
    }

    @Override
    public final String convertToString(final Cursor cursor)
    {
        final String name = mContacts.getName(cursor);
        final String address = mContacts.getEmail(cursor);;

        return new Address(address, name).toString();
    }

    @Override
    public final void bindView(final View view, final Context context, final Cursor cursor)
    {
        final TextView text1 = (TextView) view.findViewById(R.id.text1);
        final TextView text2 = (TextView) view.findViewById(R.id.text2);
        text1.setText(mContacts.getName(cursor));
        text2.setText(mContacts.getEmail(cursor));
    }

    @Override
    public Cursor runQueryOnBackgroundThread(CharSequence constraint)
    {
        return mContacts.searchContacts(constraint);
    }
}
",False,216,0,0,10,66,1,2,L1
5,com.fsck.k9.K9.java,"
package com.fsck.k9;

import java.io.File;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

import android.app.Application;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.net.Uri;
import android.util.Log;
import android.webkit.WebSettings;

import com.fsck.k9.activity.MessageCompose;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.internet.BinaryTempFileBody;
import com.fsck.k9.service.BootReceiver;
import com.fsck.k9.service.MailService;

public class K9 extends Application
{
    /**
     * Components that are interested in knowing when the K9 instance is
     * available and ready (Android invokes Application.onCreate() after other
     * components') should implement this interface and register using
     * {@link K9#registerApplicationAware(ApplicationAware)}.
     */
    public static interface ApplicationAware
    {
        /**
         * Called when the Application instance is available and ready.
         * 
         * @param application
         *            The application instance. Never <code>null</code>.
         * @throws Exception
         */
        void initializeComponent(K9 application) throws Exception;
    }

    public static Application app = null;
    public static File tempDirectory;
    public static final String LOG_TAG = ""k9"";

    /**
     * Components that are interested in knowing when the K9 instance is
     * available and ready.
     * 
     * @see ApplicationAware
     */
    private static List<ApplicationAware> observers = new ArrayList<ApplicationAware>();


    public enum BACKGROUND_OPS
    {
        WHEN_CHECKED, ALWAYS, NEVER, WHEN_CHECKED_AUTO_SYNC
    }

    private static String language = """";
    private static int theme = android.R.style.Theme_Light;

    private static final FontSizes fontSizes = new FontSizes();

    private static BACKGROUND_OPS backgroundOps = BACKGROUND_OPS.WHEN_CHECKED;
    /**
     * Some log messages can be sent to a file, so that the logs
     * can be read using unprivileged access (eg. Terminal Emulator)
     * on the phone, without adb.  Set to null to disable
     */
    public static final String logFile = null;
    //public static final String logFile = Environment.getExternalStorageDirectory() + ""/k9mail/debug.log"";

    /**
     * If this is enabled there will be additional logging information sent to
     * Log.d, including protocol dumps.
     * Controlled by Preferences at run-time
     */
    public static boolean DEBUG = false;

    /**
     * Should K-9 log the conversation it has over the wire with
     * SMTP servers?
     */

    public static boolean DEBUG_PROTOCOL_SMTP = true;

    /**
     * Should K-9 log the conversation it has over the wire with
     * IMAP servers?
     */

    public static boolean DEBUG_PROTOCOL_IMAP = true;


    /**
     * Should K-9 log the conversation it has over the wire with
     * POP3 servers?
     */

    public static boolean DEBUG_PROTOCOL_POP3 = true;

    /**
     * Should K-9 log the conversation it has over the wire with
     * WebDAV servers?
     */

    public static boolean DEBUG_PROTOCOL_WEBDAV = true;



    /**
     * If this is enabled than logging that normally hides sensitive information
     * like passwords will show that information.
     */
    public static boolean DEBUG_SENSITIVE = false;

    /**
     * Can create messages containing stack traces that can be forwarded
     * to the development team.
     */
    public static boolean ENABLE_ERROR_FOLDER = true;
    public static String ERROR_FOLDER_NAME = ""K9mail-errors"";


    private static boolean mAnimations = true;

    private static boolean mConfirmDelete = false;
    private static boolean mKeyguardPrivacy = false;

    private static boolean mMessageListStars = true;
    private static boolean mMessageListCheckboxes = false;
    private static boolean mMessageListTouchable = false;

    private static boolean mChangeRegisteredNameColor = false;
    private static int mRegisteredNameColor = 0xff00008f;
    private static boolean mMessageViewFixedWidthFont = false;
    private static boolean mMessageViewReturnToList = false;

    private static boolean mGesturesEnabled = true;
    private static boolean mUseVolumeKeysForNavigation = false;
    private static boolean mUseVolumeKeysForListNavigation = false;
    private static boolean mManageBack = false;
    private static boolean mStartIntegratedInbox = false;
    private static boolean mMeasureAccounts = true;
    private static boolean mCountSearchMessages = true;

    private static boolean useGalleryBugWorkaround = false;
    private static boolean galleryBuggy;

    /**
     * We use WebSettings.getBlockNetworkLoads() to prevent the WebView that displays email
     * bodies from loading external resources over the network. Unfortunately this method
     * isn't exposed via the official Android API. That's why we use reflection to be able
     * to call the method.
     */
    private static final Method mGetBlockNetworkLoads = getMethod(WebSettings.class, ""setBlockNetworkLoads"");


    /**
     * The MIME type(s) of attachments we're willing to send. At the moment it is not possible
     * to open a chooser with a list of filter types, so the chooser is only opened with the first
     * item in the list. The entire list will be used to filter down attachments that are added
     * with Intent.ACTION_SEND.
     */
    public static final String[] ACCEPTABLE_ATTACHMENT_SEND_TYPES = new String[]
    {
        ""*/*""
    };

    /**
     * The MIME type(s) of attachments we're willing to view.
     */
    public static final String[] ACCEPTABLE_ATTACHMENT_VIEW_TYPES = new String[]
    {
        ""*/*"",
    };

    /**
     * The MIME type(s) of attachments we're not willing to view.
     */
    public static final String[] UNACCEPTABLE_ATTACHMENT_VIEW_TYPES = new String[]
    {
    };

    /**
     * The MIME type(s) of attachments we're willing to download to SD.
     */
    public static final String[] ACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES = new String[]
    {
        ""*/*"",
    };

    /**
     * The MIME type(s) of attachments we're not willing to download to SD.
     */
    public static final String[] UNACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES = new String[]
    {
    };

    /**
     * The special name ""INBOX"" is used throughout the application to mean ""Whatever folder
     * the server refers to as the user's Inbox. Placed here to ease use.
     */
    public static final String INBOX = ""INBOX"";

    /**
     * For use when displaying that no folder is selected
     */
    public static final String FOLDER_NONE = ""-NONE-"";

    public static final String LOCAL_UID_PREFIX = ""K9LOCAL:"";

    public static final String REMOTE_UID_PREFIX = ""K9REMOTE:"";

    public static final String K9MAIL_IDENTITY = ""X-K9mail-Identity"";

    /**
     * Specifies how many messages will be shown in a folder by default. This number is set
     * on each new folder and can be incremented with ""Load more messages..."" by the
     * VISIBLE_LIMIT_INCREMENT
     */
    public static int DEFAULT_VISIBLE_LIMIT = 25;

    /**
     * Number of additioanl messages to load when a user selectes ""Load more messages...""
     */
    public static int VISIBLE_LIMIT_INCREMENT = 25;

    public static int MAX_SEND_ATTEMPTS = 5;

    /**
     * The maximum size of an attachment we're willing to download (either View or Save)
     * Attachments that are base64 encoded (most) will be about 1.375x their actual size
     * so we should probably factor that in. A 5MB attachment will generally be around
     * 6.8MB downloaded but only 5MB saved.
     */
    public static final int MAX_ATTACHMENT_DOWNLOAD_SIZE = (128 * 1024 * 1024);

    /**
     * Max time (in millis) the wake lock will be held for when background sync is happening
     */
    public static final int WAKE_LOCK_TIMEOUT = 600000;

    public static final int MANUAL_WAKE_LOCK_TIMEOUT = 120000;

    public static final int PUSH_WAKE_LOCK_TIMEOUT = 60000;

    public static final int MAIL_SERVICE_WAKE_LOCK_TIMEOUT = 30000;

    public static final int BOOT_RECEIVER_WAKE_LOCK_TIMEOUT = 60000;

    /**
     * Time the LED is on when blinking on new email notification
     */
    public static final int NOTIFICATION_LED_ON_TIME = 500;

    /**
     * Time the LED is off when blicking on new email notification
     */
    public static final int NOTIFICATION_LED_OFF_TIME = 2000;

    public static final boolean NOTIFICATION_LED_WHILE_SYNCING = false;
    public static final int NOTIFICATION_LED_FAST_ON_TIME = 100;
    public static final int NOTIFICATION_LED_FAST_OFF_TIME = 100;

    public static final int NOTIFICATION_LED_SENDING_FAILURE_COLOR = 0xffff0000;

    // Must not conflict with an account number
    public static final int FETCHING_EMAIL_NOTIFICATION      = -5000;
    public static final int CONNECTIVITY_ID = -3;


    public class Intents
    {

        public class EmailReceived
        {
            public static final String ACTION_EMAIL_RECEIVED    = ""com.fsck.k9.intent.action.EMAIL_RECEIVED"";
            public static final String ACTION_EMAIL_DELETED     = ""com.fsck.k9.intent.action.EMAIL_DELETED"";
            public static final String ACTION_REFRESH_OBSERVER  = ""com.fsck.k9.intent.action.REFRESH_OBSERVER"";
            public static final String EXTRA_ACCOUNT            = ""com.fsck.k9.intent.extra.ACCOUNT"";
            public static final String EXTRA_FOLDER             = ""com.fsck.k9.intent.extra.FOLDER"";
            public static final String EXTRA_SENT_DATE          = ""com.fsck.k9.intent.extra.SENT_DATE"";
            public static final String EXTRA_FROM               = ""com.fsck.k9.intent.extra.FROM"";
            public static final String EXTRA_TO                 = ""com.fsck.k9.intent.extra.TO"";
            public static final String EXTRA_CC                 = ""com.fsck.k9.intent.extra.CC"";
            public static final String EXTRA_BCC                = ""com.fsck.k9.intent.extra.BCC"";
            public static final String EXTRA_SUBJECT            = ""com.fsck.k9.intent.extra.SUBJECT"";
            public static final String EXTRA_FROM_SELF          = ""com.fsck.k9.intent.extra.FROM_SELF"";
        }

    }

    /**
     * Called throughout the application when the number of accounts has changed. This method
     * enables or disables the Compose activity, the boot receiver and the service based on
     * whether any accounts are configured.
     */
    public static void setServicesEnabled(Context context)
    {
        int acctLength = Preferences.getPreferences(context).getAccounts().length;

        setServicesEnabled(context, acctLength > 0, null);

    }

    public static void setServicesEnabled(Context context, Integer wakeLockId)
    {
        setServicesEnabled(context, Preferences.getPreferences(context).getAccounts().length > 0, wakeLockId);
    }

    public static void setServicesEnabled(Context context, boolean enabled, Integer wakeLockId)
    {

        PackageManager pm = context.getPackageManager();

        if (!enabled && pm.getComponentEnabledSetting(new ComponentName(context, MailService.class)) ==
                PackageManager.COMPONENT_ENABLED_STATE_ENABLED)
        {
            /*
             * If no accounts now exist but the service is still enabled we're about to disable it
             * so we'll reschedule to kill off any existing alarms.
             */
            MailService.actionReset(context, wakeLockId);
        }
        Class<?>[] classes = { MessageCompose.class, BootReceiver.class, MailService.class };

        for (Class<?> clazz : classes)
        {

            boolean alreadyEnabled = pm.getComponentEnabledSetting(new ComponentName(context, clazz)) ==
                                     PackageManager.COMPONENT_ENABLED_STATE_ENABLED;

            if (enabled != alreadyEnabled)
            {
                pm.setComponentEnabledSetting(
                    new ComponentName(context, clazz),
                    enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED :
                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                    PackageManager.DONT_KILL_APP);
            }
        }

        if (enabled && pm.getComponentEnabledSetting(new ComponentName(context, MailService.class)) ==
                PackageManager.COMPONENT_ENABLED_STATE_ENABLED)
        {
            /*
             * And now if accounts do exist then we've just enabled the service and we want to
             * schedule alarms for the new accounts.
             */
            MailService.actionReset(context, wakeLockId);
        }

    }

    public static void save(SharedPreferences.Editor editor)
    {
        editor.putBoolean(""enableDebugLogging"", K9.DEBUG);
        editor.putBoolean(""enableSensitiveLogging"", K9.DEBUG_SENSITIVE);
        editor.putString(""backgroundOperations"", K9.backgroundOps.toString());
        editor.putBoolean(""animations"", mAnimations);
        editor.putBoolean(""gesturesEnabled"", mGesturesEnabled);
        editor.putBoolean(""useVolumeKeysForNavigation"", mUseVolumeKeysForNavigation);
        editor.putBoolean(""useVolumeKeysForListNavigation"", mUseVolumeKeysForListNavigation);
        editor.putBoolean(""manageBack"", mManageBack);
        editor.putBoolean(""startIntegratedInbox"", mStartIntegratedInbox);
        editor.putBoolean(""measureAccounts"", mMeasureAccounts);
        editor.putBoolean(""countSearchMessages"", mCountSearchMessages);
        editor.putBoolean(""messageListStars"",mMessageListStars);
        editor.putBoolean(""messageListCheckboxes"",mMessageListCheckboxes);
        editor.putBoolean(""messageListTouchable"",mMessageListTouchable);


        editor.putBoolean(""changeRegisteredNameColor"",mChangeRegisteredNameColor);
        editor.putInt(""registeredNameColor"",mRegisteredNameColor);
        editor.putBoolean(""messageViewFixedWidthFont"",mMessageViewFixedWidthFont);
        editor.putBoolean(""messageViewReturnToList"", mMessageViewReturnToList);

        editor.putString(""language"", language);
        editor.putInt(""theme"", theme);
        editor.putBoolean(""useGalleryBugWorkaround"", useGalleryBugWorkaround);

        editor.putBoolean(""confirmDelete"", mConfirmDelete);

        editor.putBoolean(""keyguardPrivacy"", mKeyguardPrivacy);

        fontSizes.save(editor);
    }

    @Override
    public void onCreate()
    {
        super.onCreate();
        app = this;

        galleryBuggy = checkForBuggyGallery();

        Preferences prefs = Preferences.getPreferences(this);
        SharedPreferences sprefs = prefs.getPreferences();
        DEBUG = sprefs.getBoolean(""enableDebugLogging"", false);
        DEBUG_SENSITIVE = sprefs.getBoolean(""enableSensitiveLogging"", false);
        mAnimations = sprefs.getBoolean(""animations"", true);
        mGesturesEnabled = sprefs.getBoolean(""gesturesEnabled"", true);
        mUseVolumeKeysForNavigation = sprefs.getBoolean(""useVolumeKeysForNavigation"", false);
        mUseVolumeKeysForListNavigation = sprefs.getBoolean(""useVolumeKeysForListNavigation"", false);
        mManageBack = sprefs.getBoolean(""manageBack"", false);
        mStartIntegratedInbox = sprefs.getBoolean(""startIntegratedInbox"", false);
        mMeasureAccounts = sprefs.getBoolean(""measureAccounts"", true);
        mCountSearchMessages = sprefs.getBoolean(""countSearchMessages"", true);
        mMessageListStars = sprefs.getBoolean(""messageListStars"",true);
        mMessageListCheckboxes = sprefs.getBoolean(""messageListCheckboxes"",false);
        mMessageListTouchable = sprefs.getBoolean(""messageListTouchable"",false);

        mChangeRegisteredNameColor = sprefs.getBoolean(""changeRegisteredNameColor"", false);
        mRegisteredNameColor = sprefs.getInt(""registeredNameColor"", 0xff00008f);
        mMessageViewFixedWidthFont = sprefs.getBoolean(""messageViewFixedWidthFont"", false);
        mMessageViewReturnToList = sprefs.getBoolean(""messageViewReturnToList"", false);

        useGalleryBugWorkaround = sprefs.getBoolean(""useGalleryBugWorkaround"", K9.isGalleryBuggy());

        mConfirmDelete = sprefs.getBoolean(""confirmDelete"", false);

        mKeyguardPrivacy = sprefs.getBoolean(""keyguardPrivacy"", false);

        fontSizes.load(sprefs);

        try
        {
            setBackgroundOps(BACKGROUND_OPS.valueOf(sprefs.getString(""backgroundOperations"", ""WHEN_CHECKED"")));
        }
        catch (Exception e)
        {
            setBackgroundOps(BACKGROUND_OPS.WHEN_CHECKED);
        }

        K9.setK9Language(sprefs.getString(""language"", """"));
        K9.setK9Theme(sprefs.getInt(""theme"", android.R.style.Theme_Light));
        MessagingController.getInstance(this).resetVisibleLimits(prefs.getAccounts());

        /*
         * We have to give MimeMessage a temp directory because File.createTempFile(String, String)
         * doesn't work in Android and MimeMessage does not have access to a Context.
         */
        BinaryTempFileBody.setTempDirectory(getCacheDir());

        /*
         * Enable background sync of messages
         */

        setServicesEnabled(this);

        MessagingController.getInstance(this).addListener(new MessagingListener()
        {
            private void broadcastIntent(String action, Account account, String folder, Message message)
            {
                try
                {
                    Uri uri = Uri.parse(""email://messages/"" + account.getAccountNumber() + ""/"" + Uri.encode(folder) + ""/"" + Uri.encode(message.getUid()));
                    Intent intent = new Intent(action, uri);
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_ACCOUNT, account.getDescription());
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_FOLDER, folder);
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_SENT_DATE, message.getSentDate());
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_FROM, Address.toString(message.getFrom()));
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_TO, Address.toString(message.getRecipients(Message.RecipientType.TO)));
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_CC, Address.toString(message.getRecipients(Message.RecipientType.CC)));
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_BCC, Address.toString(message.getRecipients(Message.RecipientType.BCC)));
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_SUBJECT, message.getSubject());
                    intent.putExtra(K9.Intents.EmailReceived.EXTRA_FROM_SELF, account.isAnIdentity(message.getFrom()));
                    K9.this.sendBroadcast(intent);
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Broadcasted: action="" + action
                              + "" account="" + account.getDescription()
                              + "" folder="" + folder
                              + "" message uid="" + message.getUid()
                             );

                }
                catch (MessagingException e)
                {
                    Log.w(K9.LOG_TAG, ""Error: action="" + action
                          + "" account="" + account.getDescription()
                          + "" folder="" + folder
                          + "" message uid="" + message.getUid()
                         );
                }
            }

            @Override
            public void synchronizeMailboxRemovedMessage(Account account, String folder, Message message)
            {
                broadcastIntent(K9.Intents.EmailReceived.ACTION_EMAIL_DELETED, account, folder, message);
            }

            @Override
            public void messageDeleted(Account account, String folder, Message message)
            {
                broadcastIntent(K9.Intents.EmailReceived.ACTION_EMAIL_DELETED, account, folder, message);
            }

            @Override
            public void synchronizeMailboxNewMessage(Account account, String folder, Message message)
            {
                broadcastIntent(K9.Intents.EmailReceived.ACTION_EMAIL_RECEIVED, account, folder, message);
            }

            @Override
            public void searchStats(final AccountStats stats)
            {
                // let observers know a fetch occured
                K9.this.sendBroadcast(new Intent(K9.Intents.EmailReceived.ACTION_REFRESH_OBSERVER, null));
            }

        });

        notifyObservers();
    }

    /**
     * since Android invokes Application.onCreate() only after invoking all
     * other components' onCreate(), here is a way to notify interested
     * component that the application is available and ready
     */
    protected void notifyObservers()
    {
        for (final ApplicationAware aware : observers)
        {
            try
            {
                aware.initializeComponent(this);
            }
            catch (Exception e)
            {
                Log.w(K9.LOG_TAG, ""Failure when notifying "" + aware, e);
            }
        }
    }

    /**
     * Register a component to be notified when the {@link K9} instance is ready.
     * 
     * @param component
     *            Never <code>null</code>.
     */
    public static void registerApplicationAware(final ApplicationAware component)
    {
        if (!observers.contains(component))
        {
            observers.add(component);
        }
    }

    public static String getK9Language()
    {
        return language;
    }

    public static void setK9Language(String nlanguage)
    {
        language = nlanguage;
    }

    public static int getK9Theme()
    {
        return theme;
    }

    public static void setK9Theme(int ntheme)
    {
        theme = ntheme;
    }

    public static BACKGROUND_OPS getBackgroundOps()
    {
        return backgroundOps;
    }

    public static boolean setBackgroundOps(BACKGROUND_OPS backgroundOps)
    {
        BACKGROUND_OPS oldBackgroundOps = K9.backgroundOps;
        K9.backgroundOps = backgroundOps;
        return backgroundOps != oldBackgroundOps;
    }

    public static boolean setBackgroundOps(String nbackgroundOps)
    {
        return setBackgroundOps(BACKGROUND_OPS.valueOf(nbackgroundOps));
    }

    public static boolean gesturesEnabled()
    {
        return mGesturesEnabled;
    }

    public static void setGesturesEnabled(boolean gestures)
    {
        mGesturesEnabled = gestures;
    }

    public static boolean useVolumeKeysForNavigationEnabled()
    {
        return mUseVolumeKeysForNavigation;
    }

    public static void setUseVolumeKeysForNavigation(boolean volume)
    {
        mUseVolumeKeysForNavigation = volume;
    }

    public static boolean useVolumeKeysForListNavigationEnabled()
    {
        return mUseVolumeKeysForListNavigation;
    }

    public static void setUseVolumeKeysForListNavigation(boolean enabled)
    {
        mUseVolumeKeysForListNavigation = enabled;
    }

    public static boolean manageBack()
    {
        return mManageBack;
    }

    public static void setManageBack(boolean manageBack)
    {
        mManageBack = manageBack;
    }

    public static boolean startIntegratedInbox()
    {
        return mStartIntegratedInbox;
    }

    public static void setStartIntegratedInbox(boolean startIntegratedInbox)
    {
        mStartIntegratedInbox = startIntegratedInbox;
    }

    public static boolean showAnimations()
    {
        return mAnimations;
    }

    public static void setAnimations(boolean animations)
    {
        mAnimations = animations;
    }

    public static boolean messageListTouchable()
    {
        return mMessageListTouchable;
    }

    public static void setMessageListTouchable(boolean touchy)
    {
        mMessageListTouchable = touchy;
    }

    public static boolean messageListStars()
    {
        return mMessageListStars;
    }

    public static void setMessageListStars(boolean stars)
    {
        mMessageListStars = stars;
    }
    public static boolean messageListCheckboxes()
    {
        return mMessageListCheckboxes;
    }

    public static void setMessageListCheckboxes(boolean checkboxes)
    {
        mMessageListCheckboxes = checkboxes;
    }

    public static boolean changeRegisteredNameColor()
    {
        return mChangeRegisteredNameColor;
    }

    public static void setChangeRegisteredNameColor(boolean checkboxes)
    {
        mChangeRegisteredNameColor = checkboxes;
    }

    public static int getRegisteredNameColor() {
        return mRegisteredNameColor;
    }

    public static void setRegisteredNameColor(int registeredNameColor) {
        mRegisteredNameColor = registeredNameColor;
    }

    public static boolean messageViewFixedWidthFont()
    {
        return mMessageViewFixedWidthFont;
    }

    public static void setMessageViewFixedWidthFont(boolean fixed)
    {
        mMessageViewFixedWidthFont = fixed;
    }

    public static boolean messageViewReturnToList()
    {
        return mMessageViewReturnToList;
    }

    public static void setMessageViewReturnToList(boolean messageViewReturnToList)
    {
        mMessageViewReturnToList = messageViewReturnToList;
    }

    private static Method getMethod(Class<?> classObject, String methodName)
    {
        try
        {
            Method method = classObject.getMethod(methodName, boolean.class);
            return method;
        }
        catch (NoSuchMethodException e)
        {
            Log.i(K9.LOG_TAG, ""Can't get method "" +
                  classObject.toString() + ""."" + methodName);
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Error while using reflection to get method "" +
                  classObject.toString() + ""."" + methodName, e);
        }
        return null;
    }

    public static void setBlockNetworkLoads(WebSettings webSettings, boolean state)
    {
        if (mGetBlockNetworkLoads != null)
        {
            try
            {
                mGetBlockNetworkLoads.invoke(webSettings, state);
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Error on invoking WebSettings.setBlockNetworkLoads()"", e);
            }
        }
    }

    public static FontSizes getFontSizes()
    {
        return fontSizes;
    }

    public static boolean measureAccounts()
    {
        return mMeasureAccounts;
    }

    public static void setMeasureAccounts(boolean measureAccounts)
    {
        mMeasureAccounts = measureAccounts;
    }

    public static boolean countSearchMessages()
    {
        return mCountSearchMessages;
    }

    public static void setCountSearchMessages(boolean countSearchMessages)
    {
        mCountSearchMessages = countSearchMessages;
    }

    public static boolean useGalleryBugWorkaround()
    {
        return useGalleryBugWorkaround;
    }

    public static void setUseGalleryBugWorkaround(boolean useGalleryBugWorkaround)
    {
        K9.useGalleryBugWorkaround = useGalleryBugWorkaround;
    }

    public static boolean isGalleryBuggy()
    {
        return galleryBuggy;
    }

    public static boolean confirmDelete()
    {
        return mConfirmDelete;
    }

    public static void setConfirmDelete(final boolean confirm)
    {
        mConfirmDelete = confirm;
    }

    /**
     * @return Whether privacy rules should be applied when system is locked
     */
    public static boolean keyguardPrivacy()
    {
        return mKeyguardPrivacy;
    }

    public static void setKeyguardPrivacy(final boolean state)
    {
        mKeyguardPrivacy = state;
    }

    /**
     * Check if this system contains a buggy Gallery 3D package.
     *
     * We have to work around the fact that those Gallery versions won't show
     * any images or videos when the pick intent is used with a MIME type other
     * than image/* or video/*. See issue 1186.
     *
     * @return true, if a buggy Gallery 3D package was found. False, otherwise.
     */
    private boolean checkForBuggyGallery()
    {
        try
        {
            PackageInfo pi = getPackageManager().getPackageInfo(""com.cooliris.media"", 0);

            return (pi.versionCode == 30682);
        }
        catch (NameNotFoundException e)
        {
            return false;
        }
    }

}
",True,222,1,6,8,59,60,13,L1
6,com.fsck.k9.AccountStats.java,"/**
 *
 */
package com.fsck.k9;

import java.io.Serializable;

public class AccountStats implements Serializable
{
    public long size = -1;
    public int unreadMessageCount = 0;
    public int flaggedMessageCount = 0;
}",False,92,5,65,0,0,9,0,L1
7,com.fsck.k9.Identity.java,"package com.fsck.k9;

import java.io.Serializable;

public class Identity implements Serializable
{
    private String mDescription;
    private String mName;
    private String mEmail;
    private String mSignature;
    private boolean mSignatureUse;
    private String replyTo;

    public synchronized String getName()
    {
        return mName;
    }

    public synchronized void setName(String name)
    {
        mName = name;
    }

    public synchronized String getEmail()
    {
        return mEmail;
    }

    public synchronized void setEmail(String email)
    {
        mEmail = email;
    }

    public synchronized boolean getSignatureUse()
    {
        return mSignatureUse;
    }

    public synchronized void setSignatureUse(boolean signatureUse)
    {
        mSignatureUse = signatureUse;
    }

    public synchronized String getSignature()
    {
        return mSignature;
    }

    public synchronized void setSignature(String signature)
    {
        mSignature = signature;
    }

    public synchronized String getDescription()
    {
        return mDescription;
    }

    public synchronized void setDescription(String description)
    {
        mDescription = description;
    }

    public synchronized String getReplyTo()
    {
        return replyTo;
    }

    public synchronized void setReplyTo(String replyTo)
    {
        this.replyTo = replyTo;
    }

    @Override
    public synchronized String toString()
    {
        return ""Account.Identity(description="" + mDescription + "", name="" + mName + "", email="" + mEmail + "", replyTo="" + replyTo + "", signature="" + mSignature;
    }
}
",False,92,6,41,0,0,6,0,L1
8,com.fsck.k9.EmailReceivedIntent.java,"package com.fsck.k9;

public class EmailReceivedIntent
{

    public static final String ACTION_EMAIL_RECEIVED = ""com.fsck.k9.intent.action.EMAIL_RECEIVED"";
    public static final String EXTRA_ACCOUNT    = ""com.fsck.k9.intent.extra.ACCOUNT"";
    public static final String EXTRA_FOLDER     = ""com.fsck.k9.intent.extra.FOLDER"";
    public static final String EXTRA_SENT_DATE  = ""com.fsck.k9.intent.extra.SENT_DATE"";
    public static final String EXTRA_FROM       = ""com.fsck.k9.intent.extra.FROM"";
    public static final String EXTRA_TO         = ""com.fsck.k9.intent.extra.TO"";
    public static final String EXTRA_CC         = ""com.fsck.k9.intent.extra.CC"";
    public static final String EXTRA_BCC        = ""com.fsck.k9.intent.extra.BCC"";
    public static final String EXTRA_SUBJECT    = ""com.fsck.k9.intent.extra.SUBJECT"";
}
",False,1,0,0,0,0,0,0,I0
9,com.fsck.k9.BaseAccount.java,"package com.fsck.k9;

public interface BaseAccount
{
    public String getEmail();
    public void setEmail(String email);
    public String getDescription();
    public void setDescription(String description);
    public String getUuid();
}
",False,92,6,43,0,0,6,0,L1
10,com.fsck.k9.SearchAccount.java,"/**
 *
 */
package com.fsck.k9;

import java.io.Serializable;
import java.util.UUID;

import android.content.Context;

import com.fsck.k9.mail.Flag;

public class SearchAccount implements BaseAccount, SearchSpecification, Serializable
{
    private Flag[] mRequiredFlags = null;
    private Flag[] mForbiddenFlags = null;
    private String email = null;
    private String description = null;
    private String query = """";
    private boolean integrate = false;
    private String mUuid = UUID.randomUUID().toString();
    private boolean builtin = false;
    private String[] accountUuids = null;
    private String[] folderNames = null;

    public SearchAccount(Preferences preferences)
    {

    }
    protected synchronized void delete(Preferences preferences)
    {

    }

    public synchronized void save(Preferences preferences)
    {

    }


    public SearchAccount(Context context, boolean nintegrate, Flag[] requiredFlags, Flag[] forbiddenFlags)
    {
        mRequiredFlags = requiredFlags;
        mForbiddenFlags = forbiddenFlags;
        integrate = nintegrate;
    }

    @Override
    public synchronized String getEmail()
    {
        return email;
    }

    @Override
    public synchronized void setEmail(String email)
    {
        this.email = email;
    }

    public Flag[] getRequiredFlags()
    {
        return mRequiredFlags;
    }

    public Flag[] getForbiddenFlags()
    {
        return mForbiddenFlags;
    }

    public boolean isIntegrate()
    {
        return integrate;
    }

    public String getDescription()
    {
        return description;
    }

    public void setDescription(String description)
    {
        this.description = description;
    }

    public String getQuery()
    {
        return query;
    }

    public void setQuery(String query)
    {
        this.query = query;
    }
    public String getUuid()
    {
        return mUuid;
    }
    public void setUuid(String nUuid)
    {
        mUuid = nUuid;
    }

    public void setIntegrate(boolean integrate)
    {
        this.integrate = integrate;
    }

    public boolean isBuiltin()
    {
        return builtin;
    }

    public void setBuiltin(boolean builtin)
    {
        this.builtin = builtin;
    }
    public String[] getAccountUuids()
    {
        return accountUuids;
    }
    public void setAccountUuids(String[] accountUuids)
    {
        this.accountUuids = accountUuids;
    }
    @Override
    public String[] getFolderNames()
    {
        return folderNames;
    }
    public void setFolderNames(String[] folderNames)
    {
        this.folderNames = folderNames;
    }
}",False,217,1,1,9,50,2,4,L1
11,com.fsck.k9.EmailAddressValidator.java,"
package com.fsck.k9;

import android.text.util.Rfc822Tokenizer;
import android.widget.AutoCompleteTextView.Validator;

public class EmailAddressValidator implements Validator
{
    public CharSequence fixText(CharSequence invalidText)
    {
        return """";
    }

    public boolean isValid(CharSequence text)
    {
        return Rfc822Tokenizer.tokenize(text).length > 0;
    }

    public boolean isValidAddressOnly(CharSequence text)
    {
        return com.fsck.k9.helper.Regex.EMAIL_ADDRESS_PATTERN.matcher(text).matches();
    }
}
",False,93,6,56,1,1,2,1,L1
12,com.fsck.k9.NotificationSetting.java,"package com.fsck.k9;

/**
 * Describes how a notification should behave.
 */
public class NotificationSetting
{

    /**
     * Ring notification kill switch. Allow disabling ringtones without losing
     * ringtone selection.
     */
    private boolean mRing;

    private String mRingtoneUri;

    /**
     * LED kill switch.
     */
    private boolean mLed;

    private int mLedColor;

    /**
     * Vibration kill switch.
     */
    private boolean mVibrate;

    private int mVibratePattern;

    private int mVibrateTimes;

    /**
     * Set the ringtone kill switch. Allow to disable ringtone without losing
     * ringtone selection.
     * 
     * @param ring
     *            <code>true</code> to allow ringtones, <code>false</code>
     *            otherwise.
     */
    public synchronized void setRing(boolean ring)
    {
        mRing = ring;
    }

    /**
     * @return <code>true</code> if ringtone is allowed to play,
     *         <code>false</code> otherwise.
     */
    public synchronized boolean shouldRing()
    {
        return mRing;
    }

    public synchronized String getRingtone()
    {
        return mRingtoneUri;
    }

    public synchronized void setRingtone(String ringtoneUri)
    {
        mRingtoneUri = ringtoneUri;
    }

    public synchronized boolean isLed()
    {
        return mLed;
    }

    public synchronized void setLed(final boolean led)
    {
        mLed = led;
    }

    public synchronized int getLedColor()
    {
        return mLedColor;
    }

    public synchronized void setLedColor(int color)
    {
        mLedColor = color;
    }

    public synchronized boolean isVibrate()
    {
        return mVibrate;
    }

    public synchronized void setVibrate(boolean vibrate)
    {
        mVibrate = vibrate;
    }

    public synchronized int getVibratePattern()
    {
        return mVibratePattern;
    }

    public synchronized int getVibrateTimes()
    {
        return mVibrateTimes;
    }

    public synchronized void setVibratePattern(int pattern)
    {
        mVibratePattern = pattern;
    }

    public synchronized void setVibrateTimes(int times)
    {
        mVibrateTimes = times;
    }

}
",False,92,6,43,0,0,4,0,L1
13,com.fsck.k9.crypto.None.java,"package com.fsck.k9.crypto;

import android.app.Activity;
import android.content.Context;

import com.fsck.k9.Account;
import com.fsck.k9.mail.Message;

/**
 * Dummy CryptoProvider for when cryptography is disabled. It is never ""available"" and doesn't
 * do anything.
 */
public class None extends CryptoProvider
{
    static final long serialVersionUID = 0x21071230;
    public static final String NAME = """";

    public static None createInstance()
    {
        return new None();
    }

    @Override
    public boolean isAvailable(Context context)
    {
        return false;
    }

    @Override
    public boolean selectSecretKey(Activity activity, PgpData pgpData)
    {
        return false;
    }

    @Override
    public boolean selectEncryptionKeys(Activity activity, String emails, PgpData pgpData)
    {
        return false;
    }

    @Override
    public long[] getSecretKeyIdsFromEmail(Context context, String email)
    {
        return null;
    }

    @Override
    public String getUserId(Context context, long keyId)
    {
        return null;
    }

    @Override
    public boolean onActivityResult(Activity activity, int requestCode, int resultCode,
                                    android.content.Intent data, PgpData pgpData)
    {
        return false;
    }

    @Override
    public boolean encrypt(Activity activity, String data, PgpData pgpData)
    {
        return false;
    }

    @Override
    public boolean decrypt(Activity activity, String data, PgpData pgpData)
    {
        return false;
    }

    @Override
    public boolean isEncrypted(Message message)
    {
        return false;
    }

    @Override
    public boolean isSigned(Message message)
    {
        return false;
    }

    @Override
    public String getName()
    {
        return NAME;
    }

    @Override
    public boolean test(Context context)
    {
        return true;
    }
}
",False,216,0,0,8,54,1,4,L1
14,com.fsck.k9.crypto.CryptoProvider.java,"package com.fsck.k9.crypto;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;

import com.fsck.k9.mail.Message;

/**
 * A CryptoProvider provides functionalities such as encryption, decryption, digital signatures.
 * It currently also stores the results of such encryption or decryption.
 * TODO: separate the storage from the provider
 */
abstract public class CryptoProvider
{
    static final long serialVersionUID = 0x21071234;

    abstract public boolean isAvailable(Context context);
    abstract public boolean isEncrypted(Message message);
    abstract public boolean isSigned(Message message);
    abstract public boolean onActivityResult(Activity activity, int requestCode, int resultCode,
            Intent data, PgpData pgpData);
    abstract public boolean selectSecretKey(Activity activity, PgpData pgpData);
    abstract public boolean selectEncryptionKeys(Activity activity, String emails, PgpData pgpData);
    abstract public boolean encrypt(Activity activity, String data, PgpData pgpData);
    abstract public boolean decrypt(Activity activity, String data, PgpData pgpData);
    abstract public long[] getSecretKeyIdsFromEmail(Context context, String email);
    abstract public String getUserId(Context context, long keyId);
    abstract public String getName();
    abstract public boolean test(Context context);

    public static CryptoProvider createInstance(String name)
    {
        if (Apg.NAME.equals(name))
        {
            return Apg.createInstance();
        }

        return None.createInstance();
    }
}
",False,216,0,0,9,62,6,4,L1
15,com.fsck.k9.crypto.PgpData.java,"package com.fsck.k9.crypto;

import java.io.Serializable;

public class PgpData implements Serializable
{
    protected long mEncryptionKeyIds[] = null;
    protected long mSignatureKeyId = 0;
    protected String mSignatureUserId = null;
    protected boolean mSignatureSuccess = false;
    protected boolean mSignatureUnknown = false;
    protected String mDecryptedData = null;
    protected String mEncryptedData = null;

    public void setSignatureKeyId(long keyId)
    {
        mSignatureKeyId = keyId;
    }

    public long getSignatureKeyId()
    {
        return mSignatureKeyId;
    }

    public void setEncryptionKeys(long keyIds[])
    {
        mEncryptionKeyIds = keyIds;
    }

    public long[] getEncryptionKeys()
    {
        return mEncryptionKeyIds;
    }

    public boolean hasSignatureKey()
    {
        return mSignatureKeyId != 0;
    }

    public boolean hasEncryptionKeys()
    {
        return (mEncryptionKeyIds != null) && (mEncryptionKeyIds.length > 0);
    }

    public String getEncryptedData()
    {
        return mEncryptedData;
    }

    public void setEncryptedData(String data)
    {
        mEncryptedData = data;
    }

    public String getDecryptedData()
    {
        return mDecryptedData;
    }

    public void setDecryptedData(String data)
    {
        mDecryptedData = data;
    }

    public void setSignatureUserId(String userId)
    {
        mSignatureUserId = userId;
    }

    public String getSignatureUserId()
    {
        return mSignatureUserId;
    }

    public boolean getSignatureSuccess()
    {
        return mSignatureSuccess;
    }

    public void setSignatureSuccess(boolean success)
    {
        mSignatureSuccess = success;
    }

    public boolean getSignatureUnknown()
    {
        return mSignatureUnknown;
    }

    public void setSignatureUnknown(boolean unknown)
    {
        mSignatureUnknown = unknown;
    }
}
",False,92,6,63,0,0,5,0,L1
16,com.fsck.k9.crypto.Apg.java,"package com.fsck.k9.crypto;

import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ContentUris;
import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.database.Cursor;
import android.net.Uri;
import android.widget.Toast;

import com.fsck.k9.Account;
import com.fsck.k9.R;
import com.fsck.k9.activity.MessageCompose;
import com.fsck.k9.activity.MessageView;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Part;
import com.fsck.k9.mail.internet.MimeUtility;

/**
 * APG integration.
 */
public class Apg extends CryptoProvider
{
    static final long serialVersionUID = 0x21071235;
    public static final String NAME = ""apg"";

    private static final String mApgPackageName = ""org.thialfihar.android.apg"";
    private static final int mMinRequiredVersion = 16;

    public static final String AUTHORITY = ""org.thialfihar.android.apg.provider"";
    public static final Uri CONTENT_URI_SECRET_KEY_RING_BY_KEY_ID =
        Uri.parse(""content://"" + AUTHORITY + ""/key_rings/secret/key_id/"");
    public static final Uri CONTENT_URI_SECRET_KEY_RING_BY_EMAILS =
        Uri.parse(""content://"" + AUTHORITY + ""/key_rings/secret/emails/"");

    public static final Uri CONTENT_URI_PUBLIC_KEY_RING_BY_KEY_ID =
        Uri.parse(""content://"" + AUTHORITY + ""/key_rings/public/key_id/"");
    public static final Uri CONTENT_URI_PUBLIC_KEY_RING_BY_EMAILS =
        Uri.parse(""content://"" + AUTHORITY + ""/key_rings/public/emails/"");

    public static class Intent
    {
        public static final String DECRYPT = ""org.thialfihar.android.apg.intent.DECRYPT"";
        public static final String ENCRYPT = ""org.thialfihar.android.apg.intent.ENCRYPT"";
        public static final String DECRYPT_FILE = ""org.thialfihar.android.apg.intent.DECRYPT_FILE"";
        public static final String ENCRYPT_FILE = ""org.thialfihar.android.apg.intent.ENCRYPT_FILE"";
        public static final String DECRYPT_AND_RETURN = ""org.thialfihar.android.apg.intent.DECRYPT_AND_RETURN"";
        public static final String ENCRYPT_AND_RETURN = ""org.thialfihar.android.apg.intent.ENCRYPT_AND_RETURN"";
        public static final String SELECT_PUBLIC_KEYS = ""org.thialfihar.android.apg.intent.SELECT_PUBLIC_KEYS"";
        public static final String SELECT_SECRET_KEY = ""org.thialfihar.android.apg.intent.SELECT_SECRET_KEY"";
    }

    public static final String EXTRA_TEXT = ""text"";
    public static final String EXTRA_DATA = ""data"";
    public static final String EXTRA_ERROR = ""error"";
    public static final String EXTRA_DECRYPTED_MESSAGE = ""decryptedMessage"";
    public static final String EXTRA_ENCRYPTED_MESSAGE = ""encryptedMessage"";
    public static final String EXTRA_SIGNATURE = ""signature"";
    public static final String EXTRA_SIGNATURE_KEY_ID = ""signatureKeyId"";
    public static final String EXTRA_SIGNATURE_USER_ID = ""signatureUserId"";
    public static final String EXTRA_SIGNATURE_SUCCESS = ""signatureSuccess"";
    public static final String EXTRA_SIGNATURE_UNKNOWN = ""signatureUnknown"";
    public static final String EXTRA_USER_ID = ""userId"";
    public static final String EXTRA_KEY_ID = ""keyId"";
    public static final String EXTRA_ENCRYPTION_KEY_IDS = ""encryptionKeyIds"";
    public static final String EXTRA_SELECTION = ""selection"";
    public static final String EXTRA_MESSAGE = ""message"";
    public static final String EXTRA_INTENT_VERSION = ""intentVersion"";

    public static final String INTENT_VERSION = ""1"";

    public static final int DECRYPT_MESSAGE = 0x21070001;
    public static final int ENCRYPT_MESSAGE = 0x21070002;
    public static final int SELECT_PUBLIC_KEYS = 0x21070003;
    public static final int SELECT_SECRET_KEY = 0x21070004;

    public static Pattern PGP_MESSAGE =
        Pattern.compile("".*?(-----BEGIN PGP MESSAGE-----.*?-----END PGP MESSAGE-----).*"",
                        Pattern.DOTALL);

    public static Pattern PGP_SIGNED_MESSAGE =
        Pattern.compile("".*?(-----BEGIN PGP SIGNED MESSAGE-----.*?-----BEGIN PGP SIGNATURE-----.*?-----END PGP SIGNATURE-----).*"",
                        Pattern.DOTALL);

    public static Apg createInstance()
    {
        return new Apg();
    }

    /**
     * Check whether APG is installed and at a high enough version.
     *
     * @param context
     * @return whether a suitable version of APG was found
     */
    @Override
    public boolean isAvailable(Context context)
    {
        try
        {
            PackageInfo pi = context.getPackageManager().getPackageInfo(mApgPackageName, 0);
            if (pi.versionCode >= mMinRequiredVersion)
            {
                return true;
            }
            else
            {
                Toast.makeText(context,
                               R.string.error_apg_version_not_supported, Toast.LENGTH_SHORT).show();
            }
        }
        catch (NameNotFoundException e)
        {
            // not found
        }

        return false;
    }

    /**
     * Select the signature key.
     *
     * @param activity
     * @param pgpData
     * @return success or failure
     */
    @Override
    public boolean selectSecretKey(Activity activity, PgpData pgpData)
    {
        android.content.Intent intent = new android.content.Intent(Intent.SELECT_SECRET_KEY);
        intent.putExtra(EXTRA_INTENT_VERSION, INTENT_VERSION);
        try
        {
            activity.startActivityForResult(intent, Apg.SELECT_SECRET_KEY);
            return true;
        }
        catch (ActivityNotFoundException e)
        {
            Toast.makeText(activity,
                           R.string.error_activity_not_found,
                           Toast.LENGTH_SHORT).show();
            return false;
        }
    }

    /**
     * Select encryption keys.
     *
     * @param activity
     * @param emails The emails that should be used for preselection.
     * @param pgpData
     * @return success or failure
     */
    @Override
    public boolean selectEncryptionKeys(Activity activity, String emails, PgpData pgpData)
    {
        android.content.Intent intent = new android.content.Intent(Apg.Intent.SELECT_PUBLIC_KEYS);
        intent.putExtra(EXTRA_INTENT_VERSION, INTENT_VERSION);
        long[] initialKeyIds = null;
        if (!pgpData.hasEncryptionKeys())
        {
            Vector<Long> keyIds = new Vector<Long>();
            if (pgpData.hasSignatureKey())
            {
                keyIds.add(pgpData.getSignatureKeyId());
            }

            try
            {
                Uri contentUri = Uri.withAppendedPath(
                                     Apg.CONTENT_URI_PUBLIC_KEY_RING_BY_EMAILS,
                                     emails);
                Cursor c = activity.getContentResolver().query(contentUri,
                           new String[] { ""master_key_id"" },
                           null, null, null);
                if (c != null)
                {
                    while (c.moveToNext())
                    {
                        keyIds.add(c.getLong(0));
                    }
                }

                if (c != null)
                {
                    c.close();
                }
            }
            catch (SecurityException e)
            {
                Toast.makeText(activity,
                               activity.getResources().getString(R.string.insufficient_apg_permissions),
                               Toast.LENGTH_LONG).show();
            }
            if (keyIds.size() > 0)
            {
                initialKeyIds = new long[keyIds.size()];
                for (int i = 0, size = keyIds.size(); i < size; ++i)
                {
                    initialKeyIds[i] = keyIds.get(i);
                }
            }
        }
        else
        {
            initialKeyIds = pgpData.getEncryptionKeys();
        }
        intent.putExtra(Apg.EXTRA_SELECTION, initialKeyIds);
        try
        {
            activity.startActivityForResult(intent, Apg.SELECT_PUBLIC_KEYS);
            return true;
        }
        catch (ActivityNotFoundException e)
        {
            Toast.makeText(activity,
                           R.string.error_activity_not_found,
                           Toast.LENGTH_SHORT).show();
            return false;
        }
    }

    /**
     * Get secret key ids based on a given email.
     *
     * @param context
     * @param email The email in question.
     * @return key ids
     */
    @Override
    public long[] getSecretKeyIdsFromEmail(Context context, String email)
    {
        long ids[] = null;
        try
        {
            Uri contentUri = Uri.withAppendedPath(Apg.CONTENT_URI_SECRET_KEY_RING_BY_EMAILS,
                                                  email);
            Cursor c = context.getContentResolver().query(contentUri,
                       new String[] { ""master_key_id"" },
                       null, null, null);
            if (c != null && c.getCount() > 0)
            {
                ids = new long[c.getCount()];
                while (c.moveToNext())
                {
                    ids[c.getPosition()] = c.getLong(0);
                }
            }

            if (c != null)
            {
                c.close();
            }
        }
        catch (SecurityException e)
        {
            Toast.makeText(context,
                           context.getResources().getString(R.string.insufficient_apg_permissions),
                           Toast.LENGTH_LONG).show();
        }

        return ids;
    }

    /**
     * Get the user id based on the key id.
     *
     * @param context
     * @param keyId
     * @return user id
     */
    @Override
    public String getUserId(Context context, long keyId)
    {
        String userId = null;
        try
        {
            Uri contentUri = ContentUris.withAppendedId(
                                 Apg.CONTENT_URI_SECRET_KEY_RING_BY_KEY_ID,
                                 keyId);
            Cursor c = context.getContentResolver().query(contentUri,
                       new String[] { ""user_id"" },
                       null, null, null);
            if (c != null && c.moveToFirst())
            {
                userId = c.getString(0);
            }

            if (c != null)
            {
                c.close();
            }
        }
        catch (SecurityException e)
        {
            Toast.makeText(context,
                           context.getResources().getString(R.string.insufficient_apg_permissions),
                           Toast.LENGTH_LONG).show();
        }

        if (userId == null)
        {
            userId = context.getString(R.string.unknown_crypto_signature_user_id);
        }
        return userId;
    }

    /**
     * Handle the activity results that concern us.
     *
     * @param activity
     * @param requestCode
     * @param resultCode
     * @param data
     * @return handled or not
     */
    @Override
    public boolean onActivityResult(Activity activity, int requestCode, int resultCode,
                                    android.content.Intent data, PgpData pgpData)
    {
        switch (requestCode)
        {
            case Apg.SELECT_SECRET_KEY:
                if (resultCode != Activity.RESULT_OK || data == null)
                {
                    break;
                }
                pgpData.setSignatureKeyId(data.getLongExtra(Apg.EXTRA_KEY_ID, 0));
                pgpData.setSignatureUserId(data.getStringExtra(Apg.EXTRA_USER_ID));
                ((MessageCompose) activity).updateEncryptLayout();
                break;

            case Apg.SELECT_PUBLIC_KEYS:
                if (resultCode != Activity.RESULT_OK || data == null)
                {
                    pgpData.setEncryptionKeys(null);
                    ((MessageCompose) activity).onEncryptionKeySelectionDone();
                    break;
                }
                pgpData.setEncryptionKeys(data.getLongArrayExtra(Apg.EXTRA_SELECTION));
                ((MessageCompose) activity).onEncryptionKeySelectionDone();
                break;

            case Apg.ENCRYPT_MESSAGE:
                if (resultCode != Activity.RESULT_OK || data == null)
                {
                    pgpData.setEncryptionKeys(null);
                    ((MessageCompose) activity).onEncryptDone();
                    break;
                }
                pgpData.setEncryptedData(data.getStringExtra(Apg.EXTRA_ENCRYPTED_MESSAGE));
                // this was a stupid bug in an earlier version, just gonna leave this in for an APG
                // version or two
                if (pgpData.getEncryptedData() == null)
                {
                    pgpData.setEncryptedData(data.getStringExtra(Apg.EXTRA_DECRYPTED_MESSAGE));
                }
                if (pgpData.getEncryptedData() != null)
                {
                    ((MessageCompose) activity).onEncryptDone();
                }
                break;

            case Apg.DECRYPT_MESSAGE:
                if (resultCode != Activity.RESULT_OK || data == null)
                {
                    break;
                }

                pgpData.setSignatureUserId(data.getStringExtra(Apg.EXTRA_SIGNATURE_USER_ID));
                pgpData.setSignatureKeyId(data.getLongExtra(Apg.EXTRA_SIGNATURE_KEY_ID, 0));
                pgpData.setSignatureSuccess(data.getBooleanExtra(Apg.EXTRA_SIGNATURE_SUCCESS, false));
                pgpData.setSignatureUnknown(data.getBooleanExtra(Apg.EXTRA_SIGNATURE_UNKNOWN, false));

                pgpData.setDecryptedData(data.getStringExtra(Apg.EXTRA_DECRYPTED_MESSAGE));
                ((MessageView) activity).onDecryptDone();

                break;

            default:
                return false;
        }

        return true;
    }

    /**
     * Start the encrypt activity.
     *
     * @param activity
     * @param data
     * @param pgpData
     * @return success or failure
     */
    @Override
    public boolean encrypt(Activity activity, String data, PgpData pgpData)
    {
        android.content.Intent intent = new android.content.Intent(Intent.ENCRYPT_AND_RETURN);
        intent.putExtra(EXTRA_INTENT_VERSION, INTENT_VERSION);
        intent.setType(""text/plain"");
        intent.putExtra(Apg.EXTRA_TEXT, data);
        intent.putExtra(Apg.EXTRA_ENCRYPTION_KEY_IDS, pgpData.getEncryptionKeys());
        intent.putExtra(Apg.EXTRA_SIGNATURE_KEY_ID, pgpData.getSignatureKeyId());
        try
        {
            activity.startActivityForResult(intent, Apg.ENCRYPT_MESSAGE);
            return true;
        }
        catch (ActivityNotFoundException e)
        {
            Toast.makeText(activity,
                           R.string.error_activity_not_found,
                           Toast.LENGTH_SHORT).show();
            return false;
        }
    }

    /**
     * Start the decrypt activity.
     *
     * @param activity
     * @param data
     * @param pgpData
     * @return success or failure
     */
    @Override
    public boolean decrypt(Activity activity, String data, PgpData pgpData)
    {
        android.content.Intent intent = new android.content.Intent(Apg.Intent.DECRYPT_AND_RETURN);
        intent.putExtra(EXTRA_INTENT_VERSION, INTENT_VERSION);
        intent.setType(""text/plain"");
        if (data == null)
        {
            return false;
        }
        try
        {
            intent.putExtra(EXTRA_TEXT, data);
            activity.startActivityForResult(intent, Apg.DECRYPT_MESSAGE);
            return true;
        }
        catch (ActivityNotFoundException e)
        {
            Toast.makeText(activity,
                           R.string.error_activity_not_found,
                           Toast.LENGTH_SHORT).show();
            return false;
        }
    }

    @Override
    public boolean isEncrypted(Message message)
    {
        String data = null;
        try
        {
            Part part = MimeUtility.findFirstPartByMimeType(message, ""text/plain"");
            if (part == null)
            {
                part = MimeUtility.findFirstPartByMimeType(message, ""text/html"");
            }
            if (part != null)
            {
                data = MimeUtility.getTextFromPart(part);
            }
        }
        catch (MessagingException e)
        {
            // guess not...
            // TODO: maybe log this?
        }

        if (data == null)
        {
            return false;
        }

        Matcher matcher = PGP_MESSAGE.matcher(data);
        return matcher.matches();
    }

    @Override
    public boolean isSigned(Message message)
    {
        String data = null;
        try
        {
            Part part = MimeUtility.findFirstPartByMimeType(message, ""text/plain"");
            if (part == null)
            {
                part = MimeUtility.findFirstPartByMimeType(message, ""text/html"");
            }
            if (part != null)
            {
                data = MimeUtility.getTextFromPart(part);
            }
        }
        catch (MessagingException e)
        {
            // guess not...
            // TODO: maybe log this?
        }

        if (data == null)
        {
            return false;
        }

        Matcher matcher = PGP_SIGNED_MESSAGE.matcher(data);
        return matcher.matches();
    }

    /**
     * Get the name of the provider.
     *
     * @return provider name
     */
    @Override
    public String getName()
    {
        return NAME;
    }

    /**
     * Test the APG installation.
     *
     * @return success or failure
     */
    @Override
    public boolean test(Context context)
    {
        if (!isAvailable(context))
        {
            return false;
        }

        try
        {
            // try out one content provider to check permissions
            Uri contentUri = ContentUris.withAppendedId(
                                 Apg.CONTENT_URI_SECRET_KEY_RING_BY_KEY_ID,
                                 12345);
            Cursor c = context.getContentResolver().query(contentUri,
                       new String[] { ""user_id"" },
                       null, null, null);
            if (c != null)
            {
                c.close();
            }
        }
        catch (SecurityException e)
        {
            // if there was a problem, then let the user know, this will not stop K9/APG from
            // working, but some features won't be available, so we can still return ""true""
            Toast.makeText(context,
                           context.getResources().getString(R.string.insufficient_apg_permissions),
                           Toast.LENGTH_LONG).show();
        }

        return true;
    }
}
",True,216,0,0,8,48,3,9,L1
17,com.fsck.k9.helper.Utility.java,"
package com.fsck.k9.helper;

import android.text.Editable;
import android.widget.EditText;
import android.widget.TextView;
import com.fsck.k9.mail.filter.Base64;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Utility
{

    // \u00A0 (non-breaking space) happens to be used by French MUA

    // Note: no longer using the ^ beginning character combined with (...)+
    // repetition matching as we might want to strip ML tags. Ex:
    // Re: [foo] Re: RE : [foo] blah blah blah
    private static final Pattern RESPONSE_PATTERN = Pattern.compile(
            ""((Re|Fw|Fwd|Aw|R\\u00E9f\\.)(\\[\\d+\\])?[\\u00A0 ]?: *)+"", Pattern.CASE_INSENSITIVE);

    /**
     * Mailing-list tag pattern to match strings like ""[foobar] ""
     */
    private static final Pattern TAG_PATTERN = Pattern.compile(""\\[[-_a-z0-9]+\\] "",
            Pattern.CASE_INSENSITIVE);

    public final static String readInputStream(InputStream in, String encoding) throws IOException
    {
        InputStreamReader reader = new InputStreamReader(in, encoding);
        StringBuffer sb = new StringBuffer();
        int count;
        char[] buf = new char[512];
        while ((count = reader.read(buf)) != -1)
        {
            sb.append(buf, 0, count);
        }
        return sb.toString();
    }

    public final static boolean arrayContains(Object[] a, Object o)
    {
        for (Object element : a)
        {
            if (element.equals(o))
            {
                return true;
            }
        }
        return false;
    }

    /**
     * Combines the given array of Objects into a single string using the
     * seperator character and each Object's toString() method. between each
     * part.
     *
     * @param parts
     * @param seperator
     * @return
     */
    public static String combine(Object[] parts, char seperator)
    {
        if (parts == null)
        {
            return null;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < parts.length; i++)
        {
            sb.append(parts[i].toString());
            if (i < parts.length - 1)
            {
                sb.append(seperator);
            }
        }
        return sb.toString();
    }

    public static String base64Decode(String encoded)
    {
        if (encoded == null)
        {
            return null;
        }
        byte[] decoded = new Base64().decode(encoded.getBytes());
        return new String(decoded);
    }

    public static String base64Encode(String s)
    {
        if (s == null)
        {
            return s;
        }
        byte[] encoded = new Base64().encode(s.getBytes());
        return new String(encoded);
    }

    public static boolean requiredFieldValid(TextView view)
    {
        return view.getText() != null && view.getText().length() > 0;
    }


    public static boolean requiredFieldValid(Editable s)
    {
        return s != null && s.length() > 0;
    }

    public static boolean domainFieldValid(EditText view)
    {
        if (view.getText() != null)
        {
            String s = view.getText().toString();
            if (s.matches(""^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}$""))
            {
                return true;
            }
            if (s.matches(""^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$""))
            {
                return true;
            }
            if ((s.equalsIgnoreCase(""localhost""))||(s.equalsIgnoreCase(""localhost.localdomain"")))
            {
                return true;
            }
        }
        return false;
    }

    /**
     * Ensures that the given string starts and ends with the double quote character. The string is not modified in any way except to add the
     * double quote character to start and end if it's not already there.
     * sample -> ""sample""
     * ""sample"" -> ""sample""
     * """"sample"""" -> ""sample""
     * ""sample"""" -> ""sample""
     * sa""mp""le -> ""sa""mp""le""
     * ""sa""mp""le"" -> ""sa""mp""le""
     * (empty string) -> """"
     * "" -> """"
     * @param s
     * @return
     */
    public static String quoteString(String s)
    {
        if (s == null)
        {
            return null;
        }
        if (!s.matches(""^\"".*\""$""))
        {
            return ""\"""" + s + ""\"""";
        }
        else
        {
            return s;
        }
    }

    /**
     * A fast version of  URLDecoder.decode() that works only with UTF-8 and does only two
     * allocations. This version is around 3x as fast as the standard one and I'm using it
     * hundreds of times in places that slow down the UI, so it helps.
     */
    public static String fastUrlDecode(String s)
    {
        try
        {
            byte[] bytes = s.getBytes(""UTF-8"");
            byte ch;
            int length = 0;
            for (int i = 0, count = bytes.length; i < count; i++)
            {
                ch = bytes[i];
                if (ch == '%')
                {
                    int h = (bytes[i + 1] - '0');
                    int l = (bytes[i + 2] - '0');
                    if (h > 9)
                    {
                        h -= 7;
                    }
                    if (l > 9)
                    {
                        l -= 7;
                    }
                    bytes[length] = (byte)((h << 4) | l);
                    i += 2;
                }
                else if (ch == '+')
                {
                    bytes[length] = ' ';
                }
                else
                {
                    bytes[length] = bytes[i];
                }
                length++;
            }
            return new String(bytes, 0, length, ""UTF-8"");
        }
        catch (UnsupportedEncodingException uee)
        {
            return null;
        }
    }

    /**
     * Returns true if the specified date is within 18 hours of ""now"". Returns false otherwise.
     * @param date
     * @return
     */
    public static boolean isDateToday(Date date)
    {
        Date now = new Date();
        if (now.getTime() - 64800000 > date.getTime() || now.getTime() + 64800000 < date.getTime())
        {
            return false;
        }
        else
        {
            return true;
        }
    }

    /*
     * TODO disabled this method globally. It is used in all the settings screens but I just
     * noticed that an unrelated icon was dimmed. Android must share drawables internally.
     */
    public static void setCompoundDrawablesAlpha(TextView view, int alpha)
    {
//        Drawable[] drawables = view.getCompoundDrawables();
//        for (Drawable drawable : drawables) {
//            if (drawable != null) {
//                drawable.setAlpha(alpha);
//            }
//        }
    }

    /**
     * <p>Wraps a multiline string of text, identifying words by <code>' '</code>.</p>
     *
     * <p>New lines will be separated by the system property line separator.
     * Very long words, such as URLs will <i>not</i> be wrapped.</p>
     *
     * <p>Leading spaces on a new line are stripped.
     * Trailing spaces are not stripped.</p>
     *
     * <pre>
     * WordUtils.wrap(null, *) = null
     * WordUtils.wrap("""", *) = """"
     * </pre>
     *
     * Adapted from the Apache Commons Lang library.
     * http://svn.apache.org/viewvc/commons/proper/lang
     *   /trunk/src/main/java/org/apache/commons/lang3/text/WordUtils.java
     * SVN Revision 925967, Mon Mar 22 06:16:49 2010 UTC
     *
     * Licensed to the Apache Software Foundation (ASF) under one or more
     * contributor license agreements.  See the NOTICE file distributed with
     * this work for additional information regarding copyright ownership.
     * The ASF licenses this file to You under the Apache License, Version 2.0
     * (the ""License""); you may not use this file except in compliance with
     * the License.  You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an ""AS IS"" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * @param str  the String to be word wrapped, may be null
     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1
     * @return a line with newlines inserted, <code>null</code> if null input
     */
    private static final String NEWLINE_REGEX = ""(?:\\r?\\n)"";
    public static String wrap(String str, int wrapLength)
    {
        StringBuilder result = new StringBuilder();
        for (String piece : str.split(NEWLINE_REGEX))
        {
            result.append(wrap(piece, wrapLength, null, false));
            result.append(""\n"");
        }
        return result.toString();
    }

    /**
     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>
     *
     * <p>Leading spaces on a new line are stripped.
     * Trailing spaces are not stripped.</p>
     *
     * <pre>
     * WordUtils.wrap(null, *, *, *) = null
     * WordUtils.wrap("""", *, *, *) = """"
     * </pre>
     *
     * This is from the Apache Commons Lang library.
     * http://svn.apache.org/viewvc/commons/proper/lang
     *   /trunk/src/main/java/org/apache/commons/lang3/text/WordUtils.java
     * SVN Revision 925967, Mon Mar 22 06:16:49 2010 UTC
     *
     * Licensed to the Apache Software Foundation (ASF) under one or more
     * contributor license agreements.  See the NOTICE file distributed with
     * this work for additional information regarding copyright ownership.
     * The ASF licenses this file to You under the Apache License, Version 2.0
     * (the ""License""); you may not use this file except in compliance with
     * the License.  You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an ""AS IS"" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * @param str  the String to be word wrapped, may be null
     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1
     * @param newLineStr  the string to insert for a new line,
     *  <code>null</code> uses the system property line separator
     * @param wrapLongWords  true if long words (such as URLs) should be wrapped
     * @return a line with newlines inserted, <code>null</code> if null input
     */
    public static String wrap(String str, int wrapLength, String newLineStr, boolean wrapLongWords)
    {
        if (str == null)
        {
            return null;
        }
        if (newLineStr == null)
        {
            newLineStr = ""\n"";
        }
        if (wrapLength < 1)
        {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);

        while ((inputLineLength - offset) > wrapLength)
        {
            if (str.charAt(offset) == ' ')
            {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);

            if (spaceToWrapAt >= offset)
            {
                // normal case
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            }
            else
            {
                // really long word or URL
                if (wrapLongWords)
                {
                    // wrap really long word one line at a time
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                }
                else
                {
                    // do not wrap really long word, just extend beyond limit
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0)
                    {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    }
                    else
                    {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }

        // Whatever is left in line is short enough to just pass through
        wrappedLine.append(str.substring(offset));

        return wrappedLine.toString();
    }

    /**
     * Extract the 'original' subject value, by ignoring leading
     * response/forward marker and '[XX]' formatted tags (as many mailing-list
     * softwares do).
     * 
     * <p>
     * Result is also trimmed.
     * </p>
     * 
     * @param subject
     *            Never <code>null</code>.
     * @return Never <code>null</code>.
     */
    public static String stripSubject(final String subject)
    {
        int lastPrefix = 0;

        final Matcher tagMatcher = TAG_PATTERN.matcher(subject);
        String tag = null;
        // whether tag stripping logic should be active
        boolean tagPresent = false;
        // whether the last action stripped a tag
        boolean tagStripped = false;
        if (tagMatcher.find(0))
        {
            tagPresent = true;
            if (tagMatcher.start() == 0)
            {
                // found at beginning of subject, considering it an actual tag
                tag = tagMatcher.group();

                // now need to find response marker after that tag
                lastPrefix = tagMatcher.end();
                tagStripped = true;
            }
        }

        final Matcher matcher = RESPONSE_PATTERN.matcher(subject);

        // while:
        // - lastPrefix is within the bounds
        // - response marker found at lastPrefix position
        // (to make sure we don't catch response markers that are part of
        // the actual subject)

        while (lastPrefix < subject.length() - 1
                && matcher.find(lastPrefix)
                && matcher.start() == lastPrefix
                && (!tagPresent || tag == null || subject.regionMatches(matcher.end(), tag, 0,
                        tag.length())))
        {
            lastPrefix = matcher.end();

            if (tagPresent)
            {
                tagStripped = false;
                if (tag == null)
                {
                    // attempt to find tag
                    if (tagMatcher.start() == lastPrefix)
                    {
                        tag = tagMatcher.group();
                        lastPrefix += tag.length();
                        tagStripped = true;
                    }
                }
                else if (lastPrefix < subject.length() - 1 && subject.startsWith(tag, lastPrefix))
                {
                    // Re: [foo] Re: [foo] blah blah blah
                    //               ^     ^
                    //               ^     ^
                    //               ^    new position
                    //               ^
                    //              initial position
                    lastPrefix += tag.length();
                    tagStripped = true;
                }
            }
        }
        if (tagStripped)
        {
            // restore the last tag
            lastPrefix -= tag.length();
        }
        if (lastPrefix > -1 && lastPrefix < subject.length() - 1)
        {
            return subject.substring(lastPrefix).trim();
        }
        else
        {
            return subject.trim();
        }
    }

}
",True,93,4,44,1,1,17,1,L1
18,com.fsck.k9.helper.DomainNameChecker.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.helper;

import org.bouncycastle.asn1.x509.X509Name;
import android.util.Log;
import com.fsck.k9.K9;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.security.cert.X509Certificate;
import java.security.cert.CertificateParsingException;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import java.util.Vector;

/**
 * Implements basic domain-name validation as specified by RFC2818.
 */
public class DomainNameChecker
{
    private static Pattern QUICK_IP_PATTERN;
    static
    {
        try
        {
            QUICK_IP_PATTERN = Pattern.compile(""^[a-f0-9\\.:]+$"");
        }
        catch (PatternSyntaxException e)
        {
        }
    }

    private static final int ALT_DNS_NAME = 2;
    private static final int ALT_IPA_NAME = 7;

    /**
     * Checks the site certificate against the domain name of the site being
     * visited
     *
     * @param certificate
     *            The certificate to check
     * @param thisDomain
     *            The domain name of the site being visited
     * @return True iff if there is a domain match as specified by RFC2818
     */
    public static boolean match(X509Certificate certificate, String thisDomain)
    {
        if ((certificate == null) || (thisDomain == null)
                || (thisDomain.length() == 0))
        {
            return false;
        }

        thisDomain = thisDomain.toLowerCase();
        if (!isIpAddress(thisDomain))
        {
            return matchDns(certificate, thisDomain);
        }
        else
        {
            return matchIpAddress(certificate, thisDomain);
        }
    }

    /**
     * @return True iff the domain name is specified as an IP address
     */
    private static boolean isIpAddress(String domain)
    {
        boolean rval = ((domain != null) && (domain.length() != 0));
        if (rval)
        {
            try
            {
                // do a quick-dirty IP match first to avoid DNS lookup
                rval = QUICK_IP_PATTERN.matcher(domain).matches();
                if (rval)
                {
                    rval = domain.equals(InetAddress.getByName(domain)
                                         .getHostAddress());
                }
            }
            catch (UnknownHostException e)
            {
                String errorMessage = e.getMessage();
                if (errorMessage == null)
                {
                    errorMessage = ""unknown host exception"";
                }

                if (K9.DEBUG)
                {
                    Log.v(K9.LOG_TAG, ""DomainNameChecker.isIpAddress(): ""
                          + errorMessage);
                }

                rval = false;
            }
        }

        return rval;
    }

    /**
     * Checks the site certificate against the IP domain name of the site being
     * visited
     *
     * @param certificate
     *            The certificate to check
     * @param thisDomain
     *            The DNS domain name of the site being visited
     * @return True iff if there is a domain match as specified by RFC2818
     */
    private static boolean matchIpAddress(X509Certificate certificate, String thisDomain)
    {
        if (K9.DEBUG)
        {
            Log.v(K9.LOG_TAG, ""DomainNameChecker.matchIpAddress(): this domain: "" + thisDomain);
        }

        try
        {
            Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
            if (subjectAltNames != null)
            {
                Iterator<?> i = subjectAltNames.iterator();
                while (i.hasNext())
                {
                    List<?> altNameEntry = (List<?>)(i.next());
                    if ((altNameEntry != null) && (2 <= altNameEntry.size()))
                    {
                        Integer altNameType = (Integer)(altNameEntry.get(0));
                        if (altNameType != null)
                        {
                            if (altNameType.intValue() == ALT_IPA_NAME)
                            {
                                String altName = (String)(altNameEntry.get(1));
                                if (altName != null)
                                {
                                    if (K9.DEBUG)
                                    {
                                        Log.v(K9.LOG_TAG, ""alternative IP: "" + altName);
                                    }
                                    if (thisDomain.equalsIgnoreCase(altName))
                                    {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        catch (CertificateParsingException e)
        {
        }

        return false;
    }

    /**
     * Checks the site certificate against the DNS domain name of the site being
     * visited
     *
     * @param certificate
     *            The certificate to check
     * @param thisDomain
     *            The DNS domain name of the site being visited
     * @return True iff if there is a domain match as specified by RFC2818
     */
    private static boolean matchDns(X509Certificate certificate, String thisDomain)
    {
        boolean hasDns = false;
        try
        {
            Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
            if (subjectAltNames != null)
            {
                Iterator<?> i = subjectAltNames.iterator();
                while (i.hasNext())
                {
                    List<?> altNameEntry = (List<?>)(i.next());
                    if ((altNameEntry != null) && (2 <= altNameEntry.size()))
                    {
                        Integer altNameType = (Integer)(altNameEntry.get(0));
                        if (altNameType != null)
                        {
                            if (altNameType.intValue() == ALT_DNS_NAME)
                            {
                                hasDns = true;
                                String altName = (String)(altNameEntry.get(1));
                                if (altName != null)
                                {
                                    if (matchDns(thisDomain, altName))
                                    {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        catch (CertificateParsingException e)
        {
            // one way we can get here is if an alternative name starts with
            // '*' character, which is contrary to one interpretation of the
            // spec (a valid DNS name must start with a letter); there is no
            // good way around this, and in order to be compatible we proceed
            // to check the common name (ie, ignore alternative names)
            if (K9.DEBUG)
            {
                String errorMessage = e.getMessage();
                if (errorMessage == null)
                {
                    errorMessage = ""failed to parse certificate"";
                }

                Log.v(K9.LOG_TAG, ""DomainNameChecker.matchDns(): ""
                      + errorMessage);
            }
        }

        if (!hasDns)
        {
            X509Name xName = new X509Name(certificate.getSubjectDN().getName());
            Vector<?> val = xName.getValues();
            Vector<?> oid = xName.getOIDs();
            for (int i = 0; i < oid.size(); i++)
            {
                if (oid.elementAt(i).equals(X509Name.CN))
                {
                    return matchDns(thisDomain, (String)(val.elementAt(i)));
                }
            }
        }

        return false;
    }

    /**
     * @param thisDomain
     *            The domain name of the site being visited
     * @param thatDomain
     *            The domain name from the certificate
     * @return True iff thisDomain matches thatDomain as specified by RFC2818
     */
    private static boolean matchDns(String thisDomain, String thatDomain)
    {
        if (K9.DEBUG)
        {
            Log.v(K9.LOG_TAG, ""DomainNameChecker.matchDns():""
                  + "" this domain: "" + thisDomain + "" that domain: ""
                  + thatDomain);
        }

        if ((thisDomain == null) || (thisDomain.length() == 0)
                || (thatDomain == null) || (thatDomain.length() == 0))
        {
            return false;
        }

        thatDomain = thatDomain.toLowerCase();

        // (a) domain name strings are equal, ignoring case: X matches X
        boolean rval = thisDomain.equals(thatDomain);
        if (!rval)
        {
            String[] thisDomainTokens = thisDomain.split(""\\."");
            String[] thatDomainTokens = thatDomain.split(""\\."");

            int thisDomainTokensNum = thisDomainTokens.length;
            int thatDomainTokensNum = thatDomainTokens.length;

            // (b) OR thatHost is a '.'-suffix of thisHost: Z.Y.X matches X
            if (thisDomainTokensNum >= thatDomainTokensNum)
            {
                for (int i = thatDomainTokensNum - 1; i >= 0; --i)
                {
                    rval = thisDomainTokens[i].equals(thatDomainTokens[i]);
                    if (!rval)
                    {
                        // (c) OR we have a special *-match:
                        // Z.Y.X matches *.Y.X but does not match *.X
                        rval = ((i == 0) && (thisDomainTokensNum == thatDomainTokensNum));
                        if (rval)
                        {
                            rval = thatDomainTokens[0].equals(""*"");
                            if (!rval)
                            {
                                // (d) OR we have a *-component match:
                                // f*.com matches foo.com but not bar.com
                                rval = domainTokenMatch(thisDomainTokens[0],
                                                        thatDomainTokens[0]);
                            }
                        }

                        break;
                    }
                }
            }
        }

        return rval;
    }

    /**
     * @param thisDomainToken
     *            The domain token from the current domain name
     * @param thatDomainToken
     *            The domain token from the certificate
     * @return True iff thisDomainToken matches thatDomainToken, using the
     *         wildcard match as specified by RFC2818-3.1. For example, f*.com
     *         must match foo.com but not bar.com
     */
    private static boolean domainTokenMatch(String thisDomainToken, String thatDomainToken)
    {
        if ((thisDomainToken != null) && (thatDomainToken != null))
        {
            int starIndex = thatDomainToken.indexOf('*');
            if (starIndex >= 0)
            {
                if (thatDomainToken.length() - 1 <= thisDomainToken.length())
                {
                    String prefix = thatDomainToken.substring(0, starIndex);
                    String suffix = thatDomainToken.substring(starIndex + 1);

                    return thisDomainToken.startsWith(prefix)
                           && thisDomainToken.endsWith(suffix);
                }
            }
        }

        return false;
    }
}
",True,216,0,0,9,59,1,1,L1
19,com.fsck.k9.helper.MessageHelper.java,"package com.fsck.k9.helper;

import java.text.DateFormat;
import java.util.Date;

import android.content.Context;
import android.text.SpannableStringBuilder;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.R;
import com.fsck.k9.activity.DateFormatter;
import com.fsck.k9.activity.FolderInfoHolder;
import com.fsck.k9.activity.MessageInfoHolder;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.store.LocalStore.LocalMessage;

public class MessageHelper
{

    private static MessageHelper sInstance;

    public synchronized static MessageHelper getInstance(final Context context)
    {
        if (sInstance == null)
        {
            sInstance = new MessageHelper(context);
        }
        return sInstance;
    }

    private Context mContext;

    private DateFormat mTodayDateFormat;

    private DateFormat mDateFormat;

    private DateFormat mTimeFormat;

    private MessageHelper(final Context context)
    {
        mContext = context;
        mDateFormat = DateFormatter.getDateFormat(mContext);
        mTimeFormat = android.text.format.DateFormat.getTimeFormat(mContext);
        mTodayDateFormat = android.text.format.DateFormat.getTimeFormat(mContext);
    }

    public void populate(final MessageInfoHolder target, final Message m,
            final FolderInfoHolder folder, final Account account)
    {
        final Contacts contactHelper = Contacts.getInstance(mContext);
        try
        {
            LocalMessage message = (LocalMessage) m;
            Date date = message.getSentDate();
            target.compareDate = message.getSentDate();
            if (target.compareDate == null)
            {
                target.compareDate = message.getInternalDate();
            }

            target.folder = folder;

            if (Utility.isDateToday(date))
            {
                target.date = mTodayDateFormat.format(date);
            }
            else
            {
                target.date = mDateFormat.format(date);
            }

            target.hasAttachments = message.getAttachmentCount() > 0;

            target.read = message.isSet(Flag.SEEN);
            target.answered = message.isSet(Flag.ANSWERED);
            target.flagged = message.isSet(Flag.FLAGGED);
            target.downloaded = message.isSet(Flag.X_DOWNLOADED_FULL);
            target.partially_downloaded = message.isSet(Flag.X_DOWNLOADED_PARTIAL);

            Address[] addrs = message.getFrom();

            if (addrs.length > 0 &&  account.isAnIdentity(addrs[0]))
            {
                CharSequence to = Address.toFriendly(message .getRecipients(RecipientType.TO), contactHelper);
                target.compareCounterparty = to.toString();
                target.sender = new SpannableStringBuilder(mContext.getString(R.string.message_list_to_fmt)).append(to);
            }
            else
            {
                target.sender = Address.toFriendly(addrs, contactHelper);
                target.compareCounterparty = target.sender.toString();
            }

            if (addrs.length > 0)
            {
                target.senderAddress = addrs[0].getAddress();
            }
            else
            {
                // a reasonable fallback ""whomever we were corresponding with
                target.senderAddress = target.compareCounterparty;
            }

            target.subject = message.getSubject();

            target.uid = message.getUid();
            target.message = m;
            target.preview = message.getPreview();

            target.fullDate = mDateFormat.format(date) + "" "" + mTimeFormat.format(date);
            target.account = account.getDescription();
            target.uri = ""email://messages/"" + account.getAccountNumber() + ""/"" + m.getFolder().getName() + ""/"" + m.getUid();

        }
        catch (MessagingException me)
        {
            Log.w(K9.LOG_TAG, ""Unable to load message info"", me);
        }
    }
}
",True,217,1,1,8,64,2,14,L1
20,com.fsck.k9.helper.ContactsSdk5.java,"package com.fsck.k9.helper;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.provider.ContactsContract.Contacts;
import android.provider.ContactsContract.Intents;
import android.provider.ContactsContract.CommonDataKinds.Email;
import com.fsck.k9.mail.Address;

/**
 * Access the contacts on the device using the API introduced with SDK 5.
 *
 * @see android.provider.ContactsContract
 */
public class ContactsSdk5 extends com.fsck.k9.helper.Contacts
{
    /**
     * The order in which the search results are returned by
     * {@link #searchContacts(CharSequence)}.
     */
    private static final String SORT_ORDER =
        Contacts.TIMES_CONTACTED + "" DESC, "" +
        Contacts.DISPLAY_NAME;

    /**
     * Array of columns to load from the database.
     *
     * Important: The _ID field is needed by
     * {@link com.fsck.k9.EmailAddressAdapter} or more specificly by
     * {@link android.widget.ResourceCursorAdapter}.
     */
    private static final String PROJECTION[] =
    {
        Contacts._ID,
        Contacts.DISPLAY_NAME,
        Email.DATA
    };

    /**
     * Index of the name field in the projection. This must match the order in
     * {@link #PROJECTION}.
     */
    private static final int NAME_INDEX = 1;

    /**
     * Index of the email address field in the projection. This must match the
     * order in {@link #PROJECTION}.
     */
    private static final int EMAIL_INDEX = 2;


    public ContactsSdk5(final Context context)
    {
        super(context);
    }

    @Override
    public void createContact(final Activity activity, final Address email)
    {
        final Uri contactUri = Uri.fromParts(""mailto"", email.getAddress(), null);

        final Intent contactIntent = new Intent(Intents.SHOW_OR_CREATE_CONTACT);
        contactIntent.setData(contactUri);

        // Pass along full E-mail string for possible create dialog
        contactIntent.putExtra(Intents.EXTRA_CREATE_DESCRIPTION,
                               email.toString());

        // Only provide personal name hint if we have one
        final String senderPersonal = email.getPersonal();
        if (senderPersonal != null)
        {
            contactIntent.putExtra(Intents.Insert.NAME, senderPersonal);
        }

        activity.startActivity(contactIntent);
    }

    @Override
    public String getOwnerName()
    {
        String name = null;

        // Get the name of the first account that has one.
        Account[] accounts = AccountManager.get(mContext).getAccounts();
        for (final Account account : accounts)
        {
            if (account.name != null)
            {
                name = account.name;
                break;
            }
        }

        return name;
    }

    @Override
    public boolean isInContacts(final String emailAddress)
    {
        boolean result = false;


        final Uri uri = Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(emailAddress));
        final Cursor c = mContentResolver.query(uri, PROJECTION, null, null, null);

        if (c != null)
        {
            if (c.getCount() > 0)
            {
                result = true;
            }
            c.close();
        }

        return result;
    }

    @Override
    public Cursor searchContacts(final CharSequence constraint)
    {
        final String filter = (constraint == null) ? """" : constraint.toString();
        final Uri uri = Uri.withAppendedPath(Email.CONTENT_FILTER_URI, Uri.encode(filter));
        final Cursor c = mContentResolver.query(
                             uri,
                             PROJECTION,
                             null,
                             null,
                             SORT_ORDER);

        if (c != null)
        {
            /*
             * To prevent expensive execution in the UI thread:
             * Cursors get lazily executed, so if you don't call anything on
             * the cursor before returning it from the background thread you'll
             * have a complied program for the cursor, but it won't have been
             * executed to generate the data yet. Often the execution is more
             * expensive than the compilation...
             */
            c.getCount();
        }

        return c;
    }

    @Override
    public Cursor searchByAddress(String address)
    {
        final String filter = (address == null) ? """" : address;
        final Uri uri = Uri.withAppendedPath(Email.CONTENT_FILTER_URI, Uri.encode(filter));
        final Cursor c = mContentResolver.query(
                             uri,
                             PROJECTION,
                             null,
                             null,
                             SORT_ORDER);

        if (c != null)
        {
            /*
             * To prevent expensive execution in the UI thread:
             * Cursors get lazily executed, so if you don't call anything on
             * the cursor before returning it from the background thread you'll
             * have a complied program for the cursor, but it won't have been
             * executed to generate the data yet. Often the execution is more
             * expensive than the compilation...
             */
            c.getCount();
        }

        return c;
    }

    @Override
    public String getName(Cursor c)
    {
        return c.getString(NAME_INDEX);
    }

    @Override
    public String getEmail(Cursor c)
    {
        return c.getString(EMAIL_INDEX);
    }
}
",True,217,0,0,10,67,0,2,L4
21,com.fsck.k9.helper.ContactsSdk3_4.java,"package com.fsck.k9.helper;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.provider.Contacts;
import com.fsck.k9.mail.Address;

/**
 * Access the contacts on the device using the old API (introduced in SDK 1).
 *
 * @see android.provider.Contacts
 */
@SuppressWarnings(""deprecation"")
public class ContactsSdk3_4 extends com.fsck.k9.helper.Contacts
{
    /**
     * The order in which the search results are returned by
     * {@link #searchContacts(CharSequence)}.
     */
    private static final String SORT_ORDER =
        Contacts.People.TIMES_CONTACTED + "" DESC, "" +
        Contacts.People.NAME;

    /**
     * Array of columns to load from the database.
     *
     * Important: The _ID field is needed by
     * {@link com.fsck.k9.EmailAddressAdapter} or more specificly by
     * {@link android.widget.ResourceCursorAdapter}.
     */
    private static final String PROJECTION[] =
    {
        Contacts.People.ContactMethods._ID,
        Contacts.People.ContactMethods.NAME,
        Contacts.People.ContactMethods.DATA
    };

    /**
     * Index of the name field in the projection. This must match the order in
     * {@link #PROJECTION}.
     */
    private static final int NAME_INDEX = 1;

    /**
     * Index of the email address field in the projection. This must match the
     * order in {@link #PROJECTION}.
     */
    private static final int EMAIL_INDEX = 2;


    public ContactsSdk3_4(final Context context)
    {
        super(context);
    }

    @Override
    public void createContact(final Activity activity, final Address email)
    {
        final Uri contactUri = Uri.fromParts(""mailto"", email.getAddress(), null);

        final Intent contactIntent = new Intent(Contacts.Intents.SHOW_OR_CREATE_CONTACT);
        contactIntent.setData(contactUri);

        // Pass along full E-mail string for possible create dialog
        contactIntent.putExtra(Contacts.Intents.EXTRA_CREATE_DESCRIPTION,
                               email.toString());

        // Only provide personal name hint if we have one
        final String senderPersonal = email.getPersonal();
        if (senderPersonal != null)
        {
            contactIntent.putExtra(Contacts.Intents.Insert.NAME, senderPersonal);
        }

        activity.startActivity(contactIntent);
    }

    @Override
    public String getOwnerName()
    {
        String name = null;
        final Cursor c = mContentResolver.query(
                             Uri.withAppendedPath(Contacts.People.CONTENT_URI, ""owner""),
                             PROJECTION,
                             null,
                             null,
                             null);

        if (c != null)
        {
            if (c.getCount() > 0)
            {
                c.moveToFirst();
                name = c.getString(NAME_INDEX);
            }
            c.close();
        }

        return name;
    }

    @Override
    public boolean isInContacts(final String emailAddress)
    {
        boolean result = false;

        final String where = Contacts.ContactMethods.DATA + ""=?"";
        final String[] args = new String[] {emailAddress};

        final Cursor c = mContentResolver.query(
                             Contacts.ContactMethods.CONTENT_EMAIL_URI,
                             PROJECTION,
                             where,
                             args,
                             null);

        if (c != null)
        {
            if (c.getCount() > 0)
            {
                result = true;
            }
            c.close();
        }

        return result;
    }

    @Override
    public Cursor searchContacts(final CharSequence constraint)
    {
        final String where;
        final String[] args;
        if (constraint == null)
        {
            where = null;
            args = null;
        }
        else
        {
            where = ""("" +
                    Contacts.People.NAME + "" LIKE ?"" +
                    "") OR ("" +
                    Contacts.ContactMethods.DATA + "" LIKE ?"" +
                    "")"";
            final String filter = constraint.toString() + ""%"";
            args = new String[] {filter, filter};
        }

        final Cursor c = mContentResolver.query(
                             Contacts.ContactMethods.CONTENT_EMAIL_URI,
                             PROJECTION,
                             where,
                             args,
                             SORT_ORDER);

        if (c != null)
        {
            /*
             * To prevent expensive execution in the UI thread:
             * Cursors get lazily executed, so if you don't call anything on
             * the cursor before returning it from the background thread you'll
             * have a complied program for the cursor, but it won't have been
             * executed to generate the data yet. Often the execution is more
             * expensive than the compilation...
             */
            c.getCount();
        }

        return c;
    }

    @Override
    public Cursor searchByAddress(String address)
    {
        final String where;
        final String[] args;
        if (address == null)
        {
            where = null;
            args = null;
        }
        else
        {
            where = Contacts.ContactMethods.DATA + "" = ?"";
            args = new String[] {address};
        }

        final Cursor c = mContentResolver.query(
                             Contacts.ContactMethods.CONTENT_EMAIL_URI,
                             PROJECTION,
                             where,
                             args,
                             SORT_ORDER);

        if (c != null)
        {
            /*
             * To prevent expensive execution in the UI thread:
             * Cursors get lazily executed, so if you don't call anything on
             * the cursor before returning it from the background thread you'll
             * have a complied program for the cursor, but it won't have been
             * executed to generate the data yet. Often the execution is more
             * expensive than the compilation...
             */
            c.getCount();
        }

        return c;
    }

    @Override
    public String getName(Cursor c)
    {
        return c.getString(NAME_INDEX);
    }

    @Override
    public String getEmail(Cursor c)
    {
        return c.getString(EMAIL_INDEX);
    }
}
",True,217,0,0,10,67,0,2,L4
22,com.fsck.k9.helper.AutoSyncSdk5.java,"package com.fsck.k9.helper;

import android.content.ContentResolver;
import android.content.Context;

public class AutoSyncSdk5 implements IAutoSync
{
    public void initialize(Context context) throws NoSuchMethodException
    {
        // Nothing to do here
    }

    public boolean getMasterSyncAutomatically()
    {
        /*
         * SDK 2.0/API 5 introduced an official method to query the auto-sync
         * state.
         */
        return ContentResolver.getMasterSyncAutomatically();
    }
}
",False,2,0,0,1,1,0,1,L4
23,com.fsck.k9.helper.AutoSyncSdk3.java,"package com.fsck.k9.helper;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import android.content.ContentResolver;
import android.content.Context;
import android.os.Handler;

public class AutoSyncSdk3 implements IAutoSync
{
    private Method mGetListenForNetworkTickles;
    private Object mQueryMap;

    public void initialize(Context context) throws NoSuchMethodException
    {
        /*
         * There's no documented/official way to query the state of the
         * auto-sync setting for a normal application in SDK 1.5/API 3.
         *
         * We use reflection to get an Sync.Settings.QueryMap"" object, so we
         * can call its getListenForNetworkTickles() method. This will return
         * the current auto-sync state.
         */
        try
        {
            Class<?> clazz = Class.forName(""android.provider.Sync$Settings$QueryMap"");
            Constructor<?> c = clazz.getConstructor(ContentResolver.class, boolean.class, Handler.class);
            mQueryMap = c.newInstance(context.getContentResolver(), true, null);
            mGetListenForNetworkTickles = mQueryMap.getClass().getMethod(""getListenForNetworkTickles"");
        }
        catch (Exception e)
        {
            throw new NoSuchMethodException();
        }
    }

    public boolean getMasterSyncAutomatically()
    {
        try
        {
            return (Boolean) mGetListenForNetworkTickles.invoke(mQueryMap);
        }
        catch (Exception e)
        {
            return false;
        }
    }
}
",True,2,0,0,1,1,0,1,L4
24,com.fsck.k9.helper.Regex.java,"/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.helper;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Regex
{
    /**
     *  Regular expression pattern to match all IANA top-level domains.
     *  List accurate as of 2007/06/15.  List taken from:
     *  http://data.iana.org/TLD/tlds-alpha-by-domain.txt
     *  This pattern is auto-generated by //device/tools/make-iana-tld-pattern.py
     */
    public static final Pattern TOP_LEVEL_DOMAIN_PATTERN
    = Pattern.compile(
          ""((aero|arpa|asia|a[cdefgilmnoqrstuwxz])""
          + ""|(biz|b[abdefghijmnorstvwyz])""
          + ""|(cat|com|coop|c[acdfghiklmnoruvxyz])""
          + ""|d[ejkmoz]""
          + ""|(edu|e[cegrstu])""
          + ""|f[ijkmor]""
          + ""|(gov|g[abdefghilmnpqrstuwy])""
          + ""|h[kmnrtu]""
          + ""|(info|int|i[delmnoqrst])""
          + ""|(jobs|j[emop])""
          + ""|k[eghimnrwyz]""
          + ""|l[abcikrstuvy]""
          + ""|(mil|mobi|museum|m[acdghklmnopqrstuvwxyz])""
          + ""|(name|net|n[acefgilopruz])""
          + ""|(org|om)""
          + ""|(pro|p[aefghklmnrstwy])""
          + ""|qa""
          + ""|r[eouw]""
          + ""|s[abcdeghijklmnortuvyz]""
          + ""|(tel|travel|t[cdfghjklmnoprtvwz])""
          + ""|u[agkmsyz]""
          + ""|v[aceginu]""
          + ""|w[fs]""
          + ""|y[etu]""
          + ""|z[amw])"");

    /**
     *  Regular expression pattern to match RFC 1738 URLs
     *  List accurate as of 2007/06/15.  List taken from:
     *  http://data.iana.org/TLD/tlds-alpha-by-domain.txt
     *  This pattern is auto-generated by //device/tools/make-iana-tld-pattern.py
     */
    public static final Pattern WEB_URL_PATTERN
    = Pattern.compile(
          ""((?:(http|https|Http|Https):\\/\\/(?:(?:[a-zA-Z0-9\\$\\-\\_\\.\\+\\!\\*\\'\\(\\)""
          + ""\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,64}(?:\\:(?:[a-zA-Z0-9\\$\\-\\_""
          + ""\\.\\+\\!\\*\\'\\(\\)\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,25})?\\@)?)?""
          + ""((?:(?:[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}\\.)+""   // named host
          + ""(?:""   // plus top level domain
          + ""(?:aero|arpa|asia|a[cdefgilmnoqrstuwxz])""
          + ""|(?:biz|b[abdefghijmnorstvwyz])""
          + ""|(?:cat|com|coop|c[acdfghiklmnoruvxyz])""
          + ""|d[ejkmoz]""
          + ""|(?:edu|e[cegrstu])""
          + ""|f[ijkmor]""
          + ""|(?:gov|g[abdefghilmnpqrstuwy])""
          + ""|h[kmnrtu]""
          + ""|(?:info|int|i[delmnoqrst])""
          + ""|(?:jobs|j[emop])""
          + ""|k[eghimnrwyz]""
          + ""|l[abcikrstuvy]""
          + ""|(?:mil|mobi|museum|m[acdghklmnopqrstuvwxyz])""
          + ""|(?:name|net|n[acefgilopruz])""
          + ""|(?:org|om)""
          + ""|(?:pro|p[aefghklmnrstwy])""
          + ""|qa""
          + ""|r[eouw]""
          + ""|s[abcdeghijklmnortuvyz]""
          + ""|(?:tel|travel|t[cdfghjklmnoprtvwz])""
          + ""|u[agkmsyz]""
          + ""|v[aceginu]""
          + ""|w[fs]""
          + ""|y[etu]""
          + ""|z[amw]))""
          + ""|(?:(?:25[0-5]|2[0-4]"" // or ip address
          + ""[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(?:25[0-5]|2[0-4][0-9]""
          + ""|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1]""
          + ""[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}""
          + ""|[1-9][0-9]|[0-9])))""
          + ""(?:\\:\\d{1,5})?)"" // plus option port number
          + ""(\\/(?:(?:[a-zA-Z0-9\\;\\/\\?\\:\\@\\&\\=\\#\\~""  // plus option query params
          + ""\\-\\.\\+\\!\\*\\'\\(\\)\\,\\_])|(?:\\%[a-fA-F0-9]{2}))*)?""
          + ""(?:\\b|$)""); // and finally, a word boundary or end of
    // input.  This is to stop foo.sure from
    // matching as foo.su

    public static final Pattern IP_ADDRESS_PATTERN
    = Pattern.compile(
          ""((25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(25[0-5]|2[0-4]""
          + ""[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]""
          + ""[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}""
          + ""|[1-9][0-9]|[0-9]))"");

    public static final Pattern DOMAIN_NAME_PATTERN
    = Pattern.compile(
          ""(((([a-zA-Z0-9][a-zA-Z0-9\\-]*)*[a-zA-Z0-9]\\.)+""
          + TOP_LEVEL_DOMAIN_PATTERN + "")|""
          + IP_ADDRESS_PATTERN + "")"");

    public static final Pattern EMAIL_ADDRESS_PATTERN
    = Pattern.compile(
          ""[a-zA-Z0-9\\+\\.\\_\\%\\-]{1,256}"" +
          ""\\@"" +
          ""[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}"" +
          ""("" +
          ""\\."" +
          ""[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25}"" +
          "")+""
      );

    /**
     * This pattern is intended for searching for things that look like they
     * might be phone numbers in arbitrary text, not for validating whether
     * something is in fact a phone number.  It will miss many things that
     * are legitimate phone numbers.
     *
     * <p> The pattern matches the following:
     * <ul>
     * <li>Optionally, a + sign followed immediately by one or more digits. Spaces, dots, or dashes
     * may follow.
     * <li>Optionally, sets of digits in parentheses, separated by spaces, dots, or dashes.
     * <li>A string starting and ending with a digit, containing digits, spaces, dots, and/or dashes.
     * </ul>
     */
    public static final Pattern PHONE_PATTERN
    = Pattern.compile(                                  // sdd = space, dot, or dash
          ""(\\+[0-9]+[\\- \\.]*)?""                    // +<digits><sdd>*
          + ""(\\([0-9]+\\)[\\- \\.]*)?""               // (<digits>)<sdd>*
          + ""([0-9][0-9\\- \\.][0-9\\- \\.]+[0-9])""); // <digit><digit|sdd>+<digit>

    /**
     *  Convenience method to take all of the non-null matching groups in a
     *  regex Matcher and return them as a concatenated string.
     *
     *  @param matcher      The Matcher object from which grouped text will
     *                      be extracted
     *
     *  @return             A String comprising all of the non-null matched
     *                      groups concatenated together
     */
    public static final String concatGroups(Matcher matcher)
    {
        StringBuilder b = new StringBuilder();
        final int numGroups = matcher.groupCount();

        for (int i = 1; i <= numGroups; i++)
        {
            String s = matcher.group(i);

            System.err.println(""Group("" + i + "") : "" + s);

            if (s != null)
            {
                b.append(s);
            }
        }

        return b.toString();
    }

    /**
     * Convenience method to return only the digits and plus signs
     * in the matching string.
     *
     * @param matcher      The Matcher object from which digits and plus will
     *                     be extracted
     *
     * @return             A String comprising all of the digits and plus in
     *                     the match
     */
    public static final String digitsAndPlusOnly(Matcher matcher)
    {
        StringBuilder buffer = new StringBuilder();
        String matchingRegion = matcher.group();

        for (int i = 0, size = matchingRegion.length(); i < size; i++)
        {
            char character = matchingRegion.charAt(i);

            if (character == '+' || Character.isDigit(character))
            {
                buffer.append(character);
            }
        }
        return buffer.toString();
    }
}
",True,93,7,35,0,0,2,0,L1
25,com.fsck.k9.helper.AutoSyncHelper.java,"package com.fsck.k9.helper;

import com.fsck.k9.K9;
import android.os.Build;
import android.util.Log;

/**
 * Helper class to get the current state of the auto-sync setting.
 */
public class AutoSyncHelper
{
    /**
     * False, if we never tried to load the class for this SDK version.
     * True, otherwise.
     *
     * Note: if sAutoSync is null and sChecked is true, then an error occured
     * while loading the class for the SDK version we're running on.
     */
    private static boolean sChecked = false;

    /**
     * Instance of the SDK specific class that implements the IAutoSync
     * interface.
     */
    private static IAutoSync sAutoSync = null;

    /**
     * String for the auto-sync changed Intent.  This isn't currently exposed by the API
     */
    public static String SYNC_CONN_STATUS_CHANGE = ""com.android.sync.SYNC_CONN_STATUS_CHANGED"";
    /**
     * Try loading the class that implements IAutoSync for this SDK version.
     *
     * @return the IAutoSync object for this SDK version, or null if something
     *         went wrong.
     */
    private static IAutoSync loadAutoSync()
    {
        /*
         * We're trying to load the class for this SDK version. If anything
         * goes wrong after this point, we don't want to try again.
         */
        sChecked = true;

        /*
         * Check the version of the SDK we are running on. Choose an
         * implementation class designed for that version of the SDK.
         */
        int sdkVersion = Integer.parseInt(Build.VERSION.SDK);

        String className = null;
        if (sdkVersion == Build.VERSION_CODES.CUPCAKE)
        {
            className = ""com.fsck.k9.helper.AutoSyncSdk3"";
        }
        else if (sdkVersion == Build.VERSION_CODES.DONUT)
        {
            className = ""com.fsck.k9.helper.AutoSyncSdk4"";
        }
        else if (sdkVersion >= Build.VERSION_CODES.ECLAIR)
        {
            className = ""com.fsck.k9.helper.AutoSyncSdk5"";
        }

        /*
         * Find the required class by name and instantiate it.
         */
        try
        {
            Class<? extends IAutoSync> clazz =
                Class.forName(className).asSubclass(IAutoSync.class);

            IAutoSync autoSync = clazz.newInstance();
            autoSync.initialize(K9.app);

            return autoSync;
        }
        catch (ClassNotFoundException e)
        {
            Log.e(K9.LOG_TAG, ""Couldn't find class: "" + className, e);
        }
        catch (InstantiationException e)
        {
            Log.e(K9.LOG_TAG, ""Couldn't instantiate class: "" + className, e);
        }
        catch (IllegalAccessException e)
        {
            Log.e(K9.LOG_TAG, ""Couldn't access class: "" + className, e);
        }
        catch (NoSuchMethodException e)
        {
            if (K9.DEBUG)
            {
                Log.d(K9.LOG_TAG, ""Couldn't load method to get auto-sync state"", e);
            }
        }
        return null;
    }

    /**
     * Checks whether we can query the auto-sync state using
     * getMasterSyncAutomatically() or not.
     *
     * @return true, if calls to getMasterSyncAutomatically() will return the
     *         state of the auto-sync setting. false, otherwise.
     */
    public static boolean isAvailable()
    {
        if (!sChecked)
        {
            sAutoSync = loadAutoSync();
        }
        return (sAutoSync != null);
    }

    /**
     * Query the state of the auto-sync setting.
     *
     * @return the state of the auto-sync setting.
     * @see IAutoSync
     */
    public static boolean getMasterSyncAutomatically()
    {
        if (!sChecked)
        {
            sAutoSync = loadAutoSync();
        }

        if (sAutoSync == null)
        {
            throw new RuntimeException(
                ""Called getMasterSyncAutomatically() before checking if it's available."");
        }

        return sAutoSync.getMasterSyncAutomatically();
    }
}
",True,216,0,0,9,59,2,2,L1
26,com.fsck.k9.helper.Contacts.java,"package com.fsck.k9.helper;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import android.app.Activity;
import android.content.ContentResolver;
import android.content.Context;
import android.database.Cursor;
import android.os.Build;
import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.mail.Address;

/**
 * Helper class to access the contacts stored on the device. This is needed
 * because the original contacts API introduced with SDK 1 was deprecated with
 * SDK 5 and will eventually be removed in newer SDK versions.
 * A class that uses the latest contacts API available on the device will be
 * loaded at runtime.
 *
 * @see ContactsSdk3_4
 * @see ContactsSdk5
 */
public abstract class Contacts
{
    /**
     * Instance of the SDK specific class that interfaces with the contacts
     * API.
     */
    private static Contacts sInstance = null;

    /**
     * Get SDK specific instance of the Contacts class.
     *
     * @param context A {@link Context} instance.
     * @return Appropriate {@link Contacts} instance for this device.
     */
    public static Contacts getInstance(Context context)
    {
        if (sInstance == null)
        {
            /*
             * Check the version of the SDK we are running on. Choose an
             * implementation class designed for that version of the SDK.
             */
            int sdkVersion = Integer.parseInt(Build.VERSION.SDK);

            String className = null;
            if (sdkVersion <= Build.VERSION_CODES.DONUT)
            {
                className = ""com.fsck.k9.helper.ContactsSdk3_4"";
            }
            else if (sdkVersion >= Build.VERSION_CODES.ECLAIR)
            {
                className = ""com.fsck.k9.helper.ContactsSdk5"";
            }

            /*
             * Find the required class by name and instantiate it.
             */
            try
            {
                Class<? extends Contacts> clazz =
                    Class.forName(className).asSubclass(Contacts.class);

                Constructor<? extends Contacts> constructor = clazz.getConstructor(Context.class);
                sInstance = constructor.newInstance(context);
            }
            catch (ClassNotFoundException e)
            {
                Log.e(K9.LOG_TAG, ""Couldn't find class: "" + className, e);
            }
            catch (InstantiationException e)
            {
                Log.e(K9.LOG_TAG, ""Couldn't instantiate class: "" + className, e);
            }
            catch (IllegalAccessException e)
            {
                Log.e(K9.LOG_TAG, ""Couldn't access class: "" + className, e);
            }
            catch (NoSuchMethodException e)
            {
                Log.e(K9.LOG_TAG, ""Couldn't find constructor of class: "" + className, e);
            }
            catch (IllegalArgumentException e)
            {
                Log.e(K9.LOG_TAG, ""Wrong arguments for constructor of class: "" + className, e);
            }
            catch (InvocationTargetException e)
            {
                Log.e(K9.LOG_TAG, ""Couldn't invoke constructor of class: "" + className, e);
            }
        }

        return sInstance;
    }


    protected Context mContext;
    protected ContentResolver mContentResolver;

    /**
     * Constructor
     *
     * @param context A {@link Context} instance.
     */
    protected Contacts(Context context)
    {
        mContext = context;
        mContentResolver = context.getContentResolver();
    }

    /**
     * Get the name of the device's owner.
     *
     * @return The name of the owner if available. <tt>null</tt>, otherwise.
     */
    public abstract String getOwnerName();

    /**
     * Start the activity to add information to an existing contact or add a
     * new one.
     *
     * @param activity Object of the currently active activity.
     * @param email An {@link Address} instance containing the email address
     *              of the entity you want to add to the contacts. Optionally
     *              the instance also contains the (display) name of that
     *              entity.
     */
    public abstract void createContact(Activity activity, Address email);

    /**
     * Check whether the provided email address belongs to one of the contacts.
     *
     * @param emailAddress The email address to look for.
     * @return <tt>true</tt>, if the email address belongs to a contact.
     *         <tt>false</tt>, otherwise.
     */
    public abstract boolean isInContacts(String emailAddress);

    /**
     * Filter the contacts matching the given search term.
     *
     * @param filter The search term to filter the contacts.
     * @return A {@link Cursor} instance that can be used to get the
     *         matching contacts.
     */
    public abstract Cursor searchContacts(CharSequence filter);

    public abstract Cursor searchByAddress(String address);

    /**
     * Extract the name from a {@link Cursor} instance returned by
     * {@link #searchContacts(CharSequence)}.
     *
     * @param cursor The {@link Cursor} instance.
     * @return The name of the contact in the {@link Cursor}'s current row.
     */
    public abstract String getName(Cursor cursor);

    /**
     * Extract the email address from a {@link Cursor} instance returned by
     * {@link #searchContacts(CharSequence)}.
     *
     * @param cursor The {@link Cursor} instance.
     * @return The email address of the contact in the {@link Cursor}'s current
     *         row.
     */
    public abstract String getEmail(Cursor cursor);
}
",True,218,1,2,9,59,7,2,L1
27,com.fsck.k9.helper.IAutoSync.java,"package com.fsck.k9.helper;

import android.content.Context;

/**
 * Classes that implement this interface know how to query the system for the
 * current state of the auto-sync setting. This method differs from SDK 3 to
 * SDK 5, so there are specialized implementations for each SDK version.
 */
public interface IAutoSync
{
    /**
     * Do the necessary reflection magic to get the necessary objects and/or
     * methods to later query the state of the auto-sync setting.
     *
     * @param context The application context object.
     * @throws NoSuchMethodException if something went wrong.
     */
    public void initialize(Context context) throws NoSuchMethodException;

    /**
     * Query the state of the auto-sync setting.
     *
     * @return the state of the auto-sync setting.
     */
    public boolean getMasterSyncAutomatically();
}
",False,94,7,48,0,0,4,0,L0
28,com.fsck.k9.helper.AutoSyncSdk4.java,"package com.fsck.k9.helper;

import java.lang.reflect.Method;

import com.fsck.k9.K9;

import android.content.ContentResolver;
import android.content.Context;
import android.util.Log;

public class AutoSyncSdk4 implements IAutoSync
{
    private Method mGetListenForNetworkTickles;
    private Object mContentService;

    public void initialize(Context context) throws NoSuchMethodException
    {
        /*
         * There's no documented/official way to query the state of the
         * auto-sync setting for a normal application in SDK 1.6/API 4.
         *
         * We use reflection to get an ContentService object, so we can call its
         * getListenForNetworkTickles() method. This will return the current
         * auto-sync state.
         */
        try
        {
            Method getContentService = ContentResolver.class.getMethod(""getContentService"");
            mContentService = getContentService.invoke(null);
            mGetListenForNetworkTickles = mContentService.getClass().getMethod(""getListenForNetworkTickles"");
        }
        catch (Exception e)
        {
            throw new NoSuchMethodException();
        }
    }

    public boolean getMasterSyncAutomatically()
    {
        try
        {
            return (Boolean) mGetListenForNetworkTickles.invoke(mContentService);
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Could not query for network tickle"", e);
            return true;
        }
    }
}
",True,217,0,0,9,59,0,2,L4
29,com.fsck.k9.helper.power.TracingPowerManager.java,"package com.fsck.k9.helper.power;

import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.atomic.AtomicInteger;

import com.fsck.k9.K9;
import android.content.Context;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Log;

public class TracingPowerManager
{
    private final static boolean TRACE = false;
    public static AtomicInteger wakeLockId = new AtomicInteger(0);
    PowerManager pm = null;
    private static TracingPowerManager tracingPowerManager;
    private Timer timer = null;

    public static synchronized TracingPowerManager getPowerManager(Context context)
    {
        if (tracingPowerManager == null)
        {
            if (K9.DEBUG)
            {
                Log.v(K9.LOG_TAG, ""Creating TracingPowerManager"");
            }
            tracingPowerManager = new TracingPowerManager(context);
        }
        return tracingPowerManager;
    }


    private TracingPowerManager(Context context)
    {
        pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
        if (TRACE)
        {
            timer = new Timer();
        }
    }

    public TracingWakeLock newWakeLock(int flags, String tag)
    {
        return new TracingWakeLock(flags, tag);
    }
    public class TracingWakeLock
    {
        final WakeLock wakeLock;
        final int id;
        final String tag;
        volatile TimerTask timerTask;
        volatile Long startTime = null;
        volatile Long timeout = null;
        public TracingWakeLock(int flags, String ntag)
        {
            tag = ntag;
            wakeLock = pm.newWakeLock(flags, tag);
            id = wakeLockId.getAndIncrement();
            if (K9.DEBUG)
            {
                Log.v(K9.LOG_TAG, ""Creating TracingWakeLock for tag "" + tag + "" with id "" + id);
            }
        }
        public void acquire(long timeout)
        {
            synchronized (wakeLock)
            {
                wakeLock.acquire(timeout);
            }
            if (K9.DEBUG)
            {
                Log.v(K9.LOG_TAG, ""Acquired TracingWakeLock for tag "" + tag + "" and id "" + id
                      + "" for "" + timeout + "" ms"");
            }
            raiseNotification();
            if (startTime == null)
            {
                startTime = System.currentTimeMillis();
            }
            this.timeout = timeout;
        }
        public void acquire()
        {
            synchronized (wakeLock)
            {
                wakeLock.acquire();
            }
            raiseNotification();
            if (K9.DEBUG)
            {
                Log.w(K9.LOG_TAG, ""Acquired TracingWakeLock for tag "" + tag + "" and id "" + id
                      + "" with no timeout.  K-9 Mail should not do this"");
            }
            if (startTime == null)
            {
                startTime = System.currentTimeMillis();
            }
            timeout = null;
        }
        public void setReferenceCounted(boolean counted)
        {
            synchronized (wakeLock)
            {
                wakeLock.setReferenceCounted(counted);
            }
        }
        public void release()
        {
            if (startTime != null)
            {
                Long endTime = System.currentTimeMillis();
                if (K9.DEBUG)
                {
                    Log.v(K9.LOG_TAG, ""Releasing TracingWakeLock for tag "" + tag + "" and id "" + id + "" after ""
                          + (endTime - startTime) + "" ms, timeout = "" + timeout + "" ms"");
                }
            }
            else
            {
                if (K9.DEBUG)
                {
                    Log.v(K9.LOG_TAG, ""Releasing TracingWakeLock for tag "" + tag + "" and id "" + id + "", timeout = "" + timeout + "" ms"");
                }
            }
            cancelNotification();
            synchronized (wakeLock)
            {
                wakeLock.release();
            }
            startTime = null;
        }
        private void cancelNotification()
        {
            if (timer != null)
            {
                synchronized (timer)
                {
                    if (timerTask != null)
                    {
                        timerTask.cancel();
                    }
                }
            }
        }
        private void raiseNotification()
        {
            if (timer != null)
            {
                synchronized (timer)
                {
                    if (timerTask != null)
                    {
                        timerTask.cancel();
                        timerTask = null;
                    }
                    timerTask = new TimerTask()
                    {
                        @Override
                        public void run()
                        {
                            if (startTime != null)
                            {
                                Long endTime = System.currentTimeMillis();
                                Log.i(K9.LOG_TAG, ""TracingWakeLock for tag "" + tag + "" and id "" + id + "" has been active for ""
                                      + (endTime - startTime) + "" ms, timeout = "" + timeout + "" ms"");

                            }
                            else
                            {
                                Log.i(K9.LOG_TAG, ""TracingWakeLock for tag "" + tag + "" and id "" + id + "" still active, timeout = "" + timeout + "" ms"");
                            }
                        }

                    };
                    timer.schedule(timerTask, 1000, 1000);
                }
            }
        }

    }
}
",True,216,0,0,9,59,9,1,L1
30,com.fsck.k9.activity.K9Activity.java,"package com.fsck.k9.activity;


import java.util.Locale;

import android.app.Activity;
import android.content.Context;
import android.content.res.Configuration;
import android.os.Bundle;
import android.view.GestureDetector;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.MotionEvent;
import android.view.View;
import android.widget.ScrollView;

import com.fsck.k9.K9;


public class K9Activity extends Activity
{
    private GestureDetector gestureDetector;

    protected ScrollView mTopView;

    @Override
    public void onCreate(Bundle icicle)
    {
        onCreate(icicle, true);
    }

    public void onCreate(Bundle icicle, boolean useTheme)
    {
        setLanguage(this, K9.getK9Language());
        if (useTheme)
        {
            setTheme(K9.getK9Theme());
        }
        super.onCreate(icicle);
        setupFormats();

        // Gesture detection
        gestureDetector = new GestureDetector(new MyGestureDetector());

    }

    public static void setLanguage(Context context, String language)
    {
        Locale locale;
        if (language == null || language.equals(""""))
        {
            locale = Locale.getDefault();
        }
        else if (language.length() == 5 && language.charAt(2) == '_')
        {
            // language is in the form: en_US
            locale = new Locale(language.substring(0, 2), language.substring(3));
        }
        else
        {
            locale = new Locale(language);
        }
        Configuration config = new Configuration();
        config.locale = locale;
        context.getResources().updateConfiguration(config,
                context.getResources().getDisplayMetrics());
    }

    @Override
    public boolean dispatchTouchEvent(MotionEvent ev)
    {
        super.dispatchTouchEvent(ev);
        return gestureDetector.onTouchEvent(ev);
    }

    @Override
    public void onResume()
    {
        super.onResume();
        setupFormats();
    }

    private java.text.DateFormat mDateFormat;
    private java.text.DateFormat mTimeFormat;

    private void setupFormats()
    {

        mDateFormat = DateFormatter.getDateFormat(this);
        mTimeFormat = android.text.format.DateFormat.getTimeFormat(this);   // 12/24 date format
    }

    public java.text.DateFormat getTimeFormat()
    {
        return mTimeFormat;
    }

    public java.text.DateFormat getDateFormat()
    {
        return mDateFormat;
    }
    protected void onNext(boolean animate)
    {

    }
    protected void onPrevious(boolean animate)
    {
    }

    class MyGestureDetector extends SimpleOnGestureListener
    {

        private static final float SWIPE_MIN_DISTANCE_DIP = 130.0f;
        private static final float SWIPE_MAX_OFF_PATH_DIP = 250f;
        private static final float SWIPE_THRESHOLD_VELOCITY_DIP = 325f;

        @Override
        public boolean onDoubleTap(MotionEvent ev)
        {
            super.onDoubleTap(ev);
            if (mTopView != null)
            {
                int height = getResources().getDisplayMetrics().heightPixels;
                if (ev.getRawY() < (height/4))
                {
                    mTopView.fullScroll(View.FOCUS_UP);

                }
                else if (ev.getRawY() > (height - height/4))
                {
                    mTopView.fullScroll(View.FOCUS_DOWN);

                }
            }
            return false;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)
        {
            if (K9.gesturesEnabled())
            {
                // Convert the dips to pixels
                final float mGestureScale = getResources().getDisplayMetrics().density;
                int min_distance = (int)(SWIPE_MIN_DISTANCE_DIP * mGestureScale + 0.5f);
                int min_velocity = (int)(SWIPE_THRESHOLD_VELOCITY_DIP * mGestureScale + 0.5f);
                int max_off_path = (int)(SWIPE_MAX_OFF_PATH_DIP * mGestureScale + 0.5f);


                try
                {
                    if (Math.abs(e1.getY() - e2.getY()) > max_off_path)
                        return false;
                    // right to left swipe
                    if (e1.getX() - e2.getX() > min_distance && Math.abs(velocityX) > min_velocity)
                    {
                        onNext(true);
                    }
                    else if (e2.getX() - e1.getX() > min_distance && Math.abs(velocityX) > min_velocity)
                    {
                        onPrevious(true);
                    }
                }
                catch (Exception e)
                {
                    // nothing
                }
            }
            return false;
        }
    }

}
",True,216,0,0,9,59,14,2,L1
31,com.fsck.k9.activity.SizeFormatter.java,"package com.fsck.k9.activity;

import android.content.Context;
import com.fsck.k9.R;

public class SizeFormatter
{
    public static String formatSize(Context context, long size)
    {
        if (size > 1024000000)
        {
            return ((float)(size / 102400000) / 10) + context.getString(R.string.abbrev_gigabytes);
        }
        if (size > 1024000)
        {
            return ((float)(size / 102400) / 10) + context.getString(R.string.abbrev_megabytes);
        }
        if (size > 1024)
        {
            return ((float)(size / 102) / 10) + context.getString(R.string.abbrev_kilobytes);
        }
        return size + context.getString(R.string.abbrev_bytes);
    }

}
",False,92,7,46,0,0,2,0,L1
32,com.fsck.k9.activity.ChooseFolder.java,"
package com.fsck.k9.activity;

import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Filter;
import android.widget.ListView;
import android.widget.TextView;
import com.fsck.k9.*;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.MessagingException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class ChooseFolder extends K9ListActivity
{
    String mFolder;
    String mSelectFolder;
    Account mAccount;
    MessageReference mMessageReference;
    ArrayAdapter<String> mAdapter;
    private ChooseFolderHandler mHandler = new ChooseFolderHandler();
    String heldInbox = null;
    boolean hideCurrentFolder = true;
    boolean showOptionNone = false;
    boolean showDisplayableOnly = false;

    /**
     * What folders to display.<br/>
     * Initialized to whatever is configured
     * but can be overridden via {@link #onOptionsItemSelected(MenuItem)}
     * while this activity is showing.
     */
    private Account.FolderMode mMode;
    /**
     * Current filter used by our ArrayAdapter.<br/>
     * Created on the fly and invalidated if a new
     * set of folders is chosen via {@link #onOptionsItemSelected(MenuItem)}
     */
    private FolderListFilter<String> myFilter = null;

    public static final String EXTRA_ACCOUNT = ""com.fsck.k9.ChooseFolder_account"";
    public static final String EXTRA_CUR_FOLDER = ""com.fsck.k9.ChooseFolder_curfolder"";
    public static final String EXTRA_SEL_FOLDER = ""com.fsck.k9.ChooseFolder_selfolder"";
    public static final String EXTRA_NEW_FOLDER = ""com.fsck.k9.ChooseFolder_newfolder"";
    public static final String EXTRA_MESSAGE = ""com.fsck.k9.ChooseFolder_message"";
    public static final String EXTRA_SHOW_CURRENT = ""com.fsck.k9.ChooseFolder_showcurrent"";
    public static final String EXTRA_SHOW_FOLDER_NONE = ""com.fsck.k9.ChooseFolder_showOptionNone"";
    public static final String EXTRA_SHOW_DISPLAYABLE_ONLY = ""com.fsck.k9.ChooseFolder_showDisplayableOnly"";

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        getListView().setFastScrollEnabled(true);
        getListView().setItemsCanFocus(false);
        getListView().setChoiceMode(ListView.CHOICE_MODE_NONE);
        Intent intent = getIntent();
        String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mMessageReference = (MessageReference)intent.getSerializableExtra(EXTRA_MESSAGE);
        mFolder = intent.getStringExtra(EXTRA_CUR_FOLDER);
        mSelectFolder = intent.getStringExtra(EXTRA_SEL_FOLDER);
        if (intent.getStringExtra(EXTRA_SHOW_CURRENT) != null)
        {
            hideCurrentFolder = false;
        }
        if (intent.getStringExtra(EXTRA_SHOW_FOLDER_NONE) != null)
        {
            showOptionNone = true;
        }
        if (intent.getStringExtra(EXTRA_SHOW_DISPLAYABLE_ONLY) != null)
        {
            showDisplayableOnly = true;
        }
        if (mFolder == null)
            mFolder = """";

        mAdapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1)
        {
            private Filter myFilter = null;

            @Override
            public Filter getFilter()
            {
                if (myFilter == null)
                {
                    myFilter = new FolderListFilter<String>(this);
                }
                return myFilter;
            }
        };

        setListAdapter(mAdapter);


        MessagingController.getInstance(getApplication()).listFolders(mAccount, false, mListener);


        this.getListView().setOnItemClickListener(new AdapterView.OnItemClickListener()
        {
            public void onItemClick(AdapterView<?> parent, View view, int position, long id)
            {
                Intent intent = new Intent();
                intent.putExtra(EXTRA_ACCOUNT, mAccount.getUuid());
                intent.putExtra(EXTRA_CUR_FOLDER, mFolder);
                String destFolderName = (String)((TextView)view).getText();
                if (heldInbox != null && getString(R.string.special_mailbox_name_inbox).equals(destFolderName))
                {
                    destFolderName = heldInbox;
                }
                intent.putExtra(EXTRA_NEW_FOLDER, destFolderName);
                intent.putExtra(EXTRA_MESSAGE, mMessageReference);
                setResult(RESULT_OK, intent);
                finish();
            }
        });

    }

    class ChooseFolderHandler extends Handler
    {

        private static final int MSG_PROGRESS = 2;

        private static final int MSG_DATA_CHANGED = 3;
        private static final int MSG_SET_SELECTED_FOLDER = 4;

        @Override
        public void handleMessage(android.os.Message msg)
        {
            switch (msg.what)
            {
                case MSG_PROGRESS:
                    setProgressBarIndeterminateVisibility(msg.arg1 != 0);
                    break;
                case MSG_DATA_CHANGED:
                    mAdapter.notifyDataSetChanged();

                    /*
                     * Only enable the text filter after the list has been
                     * populated to avoid possible race conditions because our
                     * FolderListFilter isn't really thread-safe.
                     */
                    getListView().setTextFilterEnabled(true);
                    break;
                case MSG_SET_SELECTED_FOLDER:
                    getListView().setSelection(msg.arg1);
                    break;
            }
        }

        public void progress(boolean progress)
        {
            android.os.Message msg = new android.os.Message();
            msg.what = MSG_PROGRESS;
            msg.arg1 = progress ? 1 : 0;
            sendMessage(msg);
        }

        public void setSelectedFolder(int position)
        {
            android.os.Message msg = new android.os.Message();
            msg.what = MSG_SET_SELECTED_FOLDER;
            msg.arg1 = position;
            sendMessage(msg);
        }

        public void dataChanged()
        {
            sendEmptyMessage(MSG_DATA_CHANGED);
        }
    }

    @Override public boolean onCreateOptionsMenu(Menu menu)
    {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.folder_select_option, menu);
        return true;
    }

    @Override public boolean onOptionsItemSelected(MenuItem item)
    {
        switch (item.getItemId())
        {


            case R.id.display_1st_class:
            {
                setDisplayMode(FolderMode.FIRST_CLASS);
                return true;
            }
            case R.id.display_1st_and_2nd_class:
            {
                setDisplayMode(FolderMode.FIRST_AND_SECOND_CLASS);
                return true;
            }
            case R.id.display_not_second_class:
            {
                setDisplayMode(FolderMode.NOT_SECOND_CLASS);
                return true;
            }
            case R.id.display_all:
            {
                setDisplayMode(FolderMode.ALL);
                return true;
            }
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    private void setDisplayMode(FolderMode aMode)
    {
        mMode = aMode;
        // invalidate the current filter as it is working on an inval
        if (myFilter != null)
        {
            myFilter.invalidate();
        }
        //re-populate the list
        MessagingController.getInstance(getApplication()).listFolders(mAccount,
                false, mListener);
    }

    private MessagingListener mListener = new MessagingListener()
    {
        @Override
        public void listFoldersStarted(Account account)
        {
            if (!account.equals(mAccount))
            {
                return;
            }
            mHandler.progress(true);
        }

        @Override
        public void listFoldersFailed(Account account, String message)
        {
            if (!account.equals(mAccount))
            {
                return;
            }
            mHandler.progress(false);
        }

        @Override
        public void listFoldersFinished(Account account)
        {
            if (!account.equals(mAccount))
            {
                return;
            }
            mHandler.progress(false);
        }
        @Override
        public void listFolders(Account account, Folder[] folders)
        {
            if (!account.equals(mAccount))
            {
                return;
            }
            Account.FolderMode aMode = mMode;
            Preferences prefs = Preferences.getPreferences(getApplication().getApplicationContext());
            ArrayList<String> localFolders = new ArrayList<String>();

            for (Folder folder : folders)
            {
                String name = folder.getName();

                // Inbox needs to be compared case-insensitively
                if (hideCurrentFolder && (name.equals(mFolder) || (K9.INBOX.equalsIgnoreCase(mFolder) && K9.INBOX.equalsIgnoreCase(name))))
                {
                    continue;
                }
                try
                {
                    folder.refresh(prefs);
                    Folder.FolderClass fMode = folder.getDisplayClass();

                    if ((aMode == Account.FolderMode.FIRST_CLASS && fMode != Folder.FolderClass.FIRST_CLASS)
                            || (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
                                fMode != Folder.FolderClass.FIRST_CLASS &&
                                fMode != Folder.FolderClass.SECOND_CLASS)
                            || (aMode == Account.FolderMode.NOT_SECOND_CLASS && fMode == Folder.FolderClass.SECOND_CLASS))
                    {
                        continue;
                    }
                }
                catch (MessagingException me)
                {
                    Log.e(K9.LOG_TAG, ""Couldn't get prefs to check for displayability of folder "" + folder.getName(), me);
                }

                localFolders.add(folder.getName());

            }

            if (showOptionNone)
            {
                localFolders.add(K9.FOLDER_NONE);
            }

            Collections.sort(localFolders, new Comparator<String>()
            {
                public int compare(String aName, String bName)
                {
                    if (K9.FOLDER_NONE.equalsIgnoreCase(aName))
                    {
                        return -1;
                    }
                    if (K9.FOLDER_NONE.equalsIgnoreCase(bName))
                    {
                        return 1;
                    }
                    if (K9.INBOX.equalsIgnoreCase(aName))
                    {
                        return -1;
                    }
                    if (K9.INBOX.equalsIgnoreCase(bName))
                    {
                        return 1;
                    }

                    return aName.compareToIgnoreCase(bName);
                }
            });
            mAdapter.setNotifyOnChange(false);
            mAdapter.clear();
            int selectedFolder = -1;
            int position = 0;
            for (String name : localFolders)
            {
                if (K9.INBOX.equalsIgnoreCase(name))
                {
                    mAdapter.add(getString(R.string.special_mailbox_name_inbox));
                    heldInbox = name;
                }
                else if (!K9.ERROR_FOLDER_NAME.equals(name))
                {
                    mAdapter.add(name);
                }

                if (mSelectFolder != null)
                {
                    /*
                     * Never select EXTRA_CUR_FOLDER (mFolder) if EXTRA_SEL_FOLDER
                     * (mSelectedFolder) was provided.
                     */

                    if (name.equals(mSelectFolder))
                    {
                        selectedFolder = position;
                    }
                }
                else if (name.equals(mFolder) ||
                         (K9.INBOX.equalsIgnoreCase(mFolder) && K9.INBOX.equalsIgnoreCase(name)))
                {
                    selectedFolder = position;
                }
                position++;
            }

            mHandler.dataChanged();

            if (selectedFolder != -1)
            {
                mHandler.setSelectedFolder(selectedFolder);
            }
        }
    };
}
",True,216,0,0,8,57,4,10,L1
33,com.fsck.k9.activity.ProgressListener.java,"
package com.fsck.k9.activity;

import android.content.Context;

/**
 * A listener that the user can register for global, persistent progress events.
 */
public interface ProgressListener
{
    /**
     * @param context
     * @param title
     * @param message
     * @param currentProgress
     * @param maxProgress
     * @param indeterminate
     */
    void showProgress(Context context, String title, String message, long currentProgress,
                      long maxProgress, boolean indeterminate);

    /**
     * @param context
     * @param title
     * @param message
     * @param currentProgress
     * @param maxProgress
     * @param indeterminate
     */
    void updateProgress(Context context, String title, String message, long currentProgress,
                        long maxProgress, boolean indeterminate);

    /**
     * @param context
     */
    void hideProgress(Context context);
}
",False,1,0,0,0,0,0,0,I0
34,com.fsck.k9.activity.K9ExpandableListActivity.java,"package com.fsck.k9.activity;

import android.app.ExpandableListActivity;
import android.os.Bundle;

import com.fsck.k9.K9;

/**
 * @see ExpandableListActivity
 */
public class K9ExpandableListActivity extends ExpandableListActivity
{

    @Override
    protected void onCreate(Bundle savedInstanceState)
    {
        setTheme(K9.getK9Theme());
        super.onCreate(savedInstanceState);
    }
}
",False,216,0,0,9,59,1,1,L1
35,com.fsck.k9.activity.K9ListActivity.java,"package com.fsck.k9.activity;

import android.app.ListActivity;
import android.util.Log;
import android.view.KeyEvent;
import android.widget.AdapterView;
import android.widget.ListView;
import android.os.Bundle;
import com.fsck.k9.K9;


public class K9ListActivity extends ListActivity
{
    @Override
    public void onCreate(Bundle icicle)
    {
        K9Activity.setLanguage(this, K9.getK9Language());
        setTheme(K9.getK9Theme());
        super.onCreate(icicle);
        setupFormats();
    }

    @Override
    public void onResume()
    {
        super.onResume();
        setupFormats();
    }

    private java.text.DateFormat mDateFormat;
    private java.text.DateFormat mTimeFormat;

    private void setupFormats()
    {
        mDateFormat = DateFormatter.getDateFormat(this);
        mTimeFormat = android.text.format.DateFormat.getTimeFormat(this);   // 12/24 date format
    }

    public java.text.DateFormat getTimeFormat()
    {
        return mTimeFormat;
    }

    public java.text.DateFormat getDateFormat()
    {
        return mDateFormat;
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        // Shortcuts that work no matter what is selected
        switch (keyCode)
        {
            case KeyEvent.KEYCODE_VOLUME_UP:
            {
                final ListView listView = getListView();
                if (K9.useVolumeKeysForListNavigationEnabled())
                {
                    int currentPosition = listView.getSelectedItemPosition();
                    if (currentPosition == AdapterView.INVALID_POSITION || listView.isInTouchMode())
                    {
                        currentPosition = listView.getFirstVisiblePosition();
                    }
                    if (currentPosition > 0)
                    {
                        listView.setSelection(currentPosition - 1);
                    }
                    return true;
                }
            }
            case KeyEvent.KEYCODE_VOLUME_DOWN:
            {
                final ListView listView = getListView();
                if (K9.useVolumeKeysForListNavigationEnabled())
                {
                    int currentPosition = listView.getSelectedItemPosition();
                    if (currentPosition == AdapterView.INVALID_POSITION || listView.isInTouchMode())
                    {
                        currentPosition = listView.getFirstVisiblePosition();
                    }
                    
                    if (currentPosition < listView.getCount())
                    {
                        listView.setSelection(currentPosition + 1);
                    }
                    return true;
                }
            }
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event)
    {
        // Swallow these events too to avoid the audible notification of a volume change
        if (K9.useVolumeKeysForListNavigationEnabled())
        {
            if ((keyCode == KeyEvent.KEYCODE_VOLUME_UP) || (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN))
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""Swallowed key up."");
                return true;
            }
        }
        return super.onKeyUp(keyCode,event);
    }
}
",False,217,1,1,9,59,6,3,L1
36,com.fsck.k9.activity.SearchModifier.java,"/**
 *
 */
package com.fsck.k9.activity;

import com.fsck.k9.R;
import com.fsck.k9.mail.Flag;

enum SearchModifier
{
    FLAGGED(R.string.flagged_modifier, new Flag[] { Flag.FLAGGED}, null), UNREAD(R.string.unread_modifier, null, new Flag[] { Flag.SEEN});

    final int resId;
    final Flag[] requiredFlags;
    final Flag[] forbiddenFlags;

    SearchModifier(int nResId, Flag[] nRequiredFlags, Flag[] nForbiddenFlags)
    {
        resId = nResId;
        requiredFlags = nRequiredFlags;
        forbiddenFlags = nForbiddenFlags;
    }

}",False,93,7,46,1,1,2,1,L1
37,com.fsck.k9.activity.FolderList.java,"package com.fsck.k9.activity;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.PowerManager;
import android.util.Config;
import android.util.Log;
import android.util.TypedValue;
import android.view.*;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.View.OnClickListener;
import android.widget.*;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.AdapterView.OnItemClickListener;
import com.fsck.k9.*;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.activity.FolderInfoHolder;
import com.fsck.k9.activity.setup.Prefs;
import com.fsck.k9.activity.setup.AccountSettings;
import com.fsck.k9.activity.setup.FolderSettings;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.helper.power.TracingPowerManager;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.service.MailService;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;

/**
 * FolderList is the primary user interface for the program. This
 * Activity shows list of the Account's folders
 */

public class FolderList extends K9ListActivity
{

    private static final int DIALOG_MARK_ALL_AS_READ = 1;

    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_INITIAL_FOLDER = ""initialFolder"";
    private static final String EXTRA_FROM_NOTIFICATION = ""fromNotification"";
    private static final String EXTRA_FROM_SHORTCUT = ""fromShortcut"";

    private static final boolean REFRESH_REMOTE = true;

    private ListView mListView;

    private FolderListAdapter mAdapter;

    private LayoutInflater mInflater;

    private Account mAccount;

    private FolderListHandler mHandler = new FolderListHandler();

    private int mUnreadMessageCount;

    private FontSizes mFontSizes = K9.getFontSizes();
    private Context context;

    class FolderListHandler extends Handler
    {

        public void refreshTitle()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    String dispString = mAdapter.mListener.formatHeader(FolderList.this,
                                        getString(R.string.folder_list_title, mAccount.getDescription()), mUnreadMessageCount, getTimeFormat());


                    setTitle(dispString);
                }
            });
        }


        public void newFolders(final List<FolderInfoHolder> newFolders)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    mAdapter.mFolders.clear();
                    mAdapter.mFolders.addAll(newFolders);
                    mHandler.dataChanged();
                }
            });
        }

        public void workingAccount(final int res)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    String toastText = getString(res, mAccount.getDescription());
                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_SHORT);
                    toast.show();
                }
            });
        }

        public void accountSizeChanged(final long oldSize, final long newSize)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    String toastText = getString(R.string.account_size_changed, mAccount.getDescription(), SizeFormatter.formatSize(getApplication(), oldSize), SizeFormatter.formatSize(getApplication(), newSize));

                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
                    toast.show();
                }
            });
        }

        public void folderLoading(final String folder, final boolean loading)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    FolderInfoHolder folderHolder = mAdapter.getFolder(folder);


                    if (folderHolder != null)
                    {
                        folderHolder.loading = loading;
                    }

                }
            });
        }

        public void progress(final boolean progress)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    setProgressBarIndeterminateVisibility(progress);
                }
            });

        }

        public void dataChanged()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    mAdapter.notifyDataSetChanged();
                }
            });
        }
    }

    /**
    * This class is responsible for reloading the list of local messages for a
    * given folder, notifying the adapter that the message have been loaded and
    * queueing up a remote update of the folder.
     */

    private void checkMail(FolderInfoHolder folder)
    {
        TracingPowerManager pm = TracingPowerManager.getPowerManager(this);
        final TracingWakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""FolderList checkMail"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(K9.WAKE_LOCK_TIMEOUT);
        MessagingListener listener = new MessagingListener()
        {
            @Override
            public void synchronizeMailboxFinished(Account account, String folder, int totalMessagesInMailbox, int numNewMessages)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }
                wakeLock.release();
            }

            @Override
            public void synchronizeMailboxFailed(Account account, String folder,
                                                 String message)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }
                wakeLock.release();
            }
        };
        MessagingController.getInstance(getApplication()).synchronizeMailbox(mAccount, folder.name, listener, null);
        sendMail(mAccount);
    }

    public static Intent actionHandleAccountIntent(Context context, Account account)
    {
        return actionHandleAccountIntent(context, account, null, false);
    }

    public static Intent actionHandleAccountIntent(Context context, Account account, String initialFolder)
    {
        return actionHandleAccountIntent(context, account, initialFolder, false);
    }

    public static Intent actionHandleAccountIntent(Context context, Account account, String initialFolder, boolean fromShortcut)
    {
        Intent intent = new Intent(context, FolderList.class);
        intent.putExtra(EXTRA_ACCOUNT, account.getUuid());

        if (initialFolder != null)
        {
            intent.putExtra(EXTRA_INITIAL_FOLDER, initialFolder);
        }

        if (fromShortcut)
        {
            intent.putExtra(EXTRA_FROM_SHORTCUT, true);
        }

        return intent;
    }

    private static void actionHandleAccount(Context context, Account account, String initialFolder)
    {
        Intent intent = actionHandleAccountIntent(context, account, initialFolder);
        context.startActivity(intent);
    }

    public static void actionHandleAccount(Context context, Account account)
    {
        actionHandleAccount(context, account, null);
    }

    public static Intent actionHandleNotification(Context context, Account account, String initialFolder)
    {
        Intent intent = new Intent(
            Intent.ACTION_VIEW,
            Uri.parse(""email://accounts/"" + account.getAccountNumber()),
            context,
            FolderList.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.putExtra(EXTRA_ACCOUNT, account.getUuid());
        intent.putExtra(EXTRA_FROM_NOTIFICATION, true);

        if (initialFolder != null)
        {
            intent.putExtra(EXTRA_INITIAL_FOLDER, initialFolder);
        }
        return intent;
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);

        setContentView(R.layout.folder_list);
        mListView = getListView();
        mListView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_INSET);
        mListView.setLongClickable(true);
        mListView.setFastScrollEnabled(true);
        mListView.setScrollingCacheEnabled(true);
        mListView.setOnItemClickListener(new OnItemClickListener()
        {
            public void onItemClick(AdapterView<?> parent, View view, int position, long id)
            {
                onOpenFolder(((FolderInfoHolder)mAdapter.getItem(id)).name);
            }
        });
        registerForContextMenu(mListView);

        mListView.setSaveEnabled(true);

        mInflater = getLayoutInflater();

        onNewIntent(getIntent());

        context = this;
    }

    @Override
    public void onNewIntent(Intent intent)
    {
        setIntent(intent); // onNewIntent doesn't autoset our ""internal"" intent

        String initialFolder;

        mUnreadMessageCount = 0;
        String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        if (mAccount == null)
        {
            // This shouldn't normally happen. But apparently it does. See issue 2261.
            finish();
            return;
        }

        initialFolder = intent.getStringExtra(EXTRA_INITIAL_FOLDER);
        boolean fromNotification = intent.getBooleanExtra(EXTRA_FROM_NOTIFICATION, false);
        if (fromNotification && mAccount.goToUnreadMessageSearch())
        {
            MessagingController.getInstance(getApplication()).notifyAccountCancel(this, mAccount);
            openUnreadSearch(this, mAccount);
            finish();
        }
        else if (initialFolder != null && !K9.FOLDER_NONE.equals(initialFolder))
        {
            onOpenFolder(initialFolder);
            finish();
        }
        else if (intent.getBooleanExtra(EXTRA_FROM_SHORTCUT, false) &&
                 !K9.FOLDER_NONE.equals(mAccount.getAutoExpandFolderName()))
        {
            onOpenFolder(mAccount.getAutoExpandFolderName());
            finish();
        }
        else
        {

            initializeActivityView();
        }
    }

    private void initializeActivityView()
    {
        mAdapter = new FolderListAdapter();

        final Object previousData = getLastNonConfigurationInstance();

        if (previousData != null)
        {
            //noinspection unchecked
            mAdapter.mFolders = (ArrayList<FolderInfoHolder>) previousData;
        }

        setListAdapter(mAdapter);

        setTitle(mAccount.getDescription());

    }


    @Override public Object onRetainNonConfigurationInstance()
    {
        return (mAdapter == null) ? null : mAdapter.mFolders;
    }

    @Override public void onPause()
    {
        super.onPause();
        MessagingController.getInstance(getApplication()).removeListener(mAdapter.mListener);
    }

    /**
    * On resume we refresh the folder list (in the background) and we refresh the
    * messages for any folder that is currently open. This guarantees that things
    * like unread message count and read status are updated.
     */
    @Override public void onResume()
    {
        super.onResume();

        if (mAdapter == null)
            initializeActivityView();

        MessagingController.getInstance(getApplication()).addListener(mAdapter.mListener);
        //mAccount.refresh(Preferences.getPreferences(this));
        MessagingController.getInstance(getApplication()).getAccountStats(this, mAccount, mAdapter.mListener);

        onRefresh(!REFRESH_REMOTE);

        MessagingController.getInstance(getApplication()).notifyAccountCancel(this, mAccount);
    }


    @Override
    public void onBackPressed()
    {
        // This will be called either automatically for you on 2.0
        // or later, or by the code above on earlier versions of the
        // platform.
        if (K9.manageBack())
        {
            onAccounts();
        }
        else
        {
            // TODO - when we move to android 2.0, uncomment this instead.
            // super.onBackPressed()
            finish();
        }
    }

    @Override public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        //Shortcuts that work no matter what is selected

        if (
            // TODO - when we move to android 2.0, uncomment this.
            // android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.ECLAIR &&

            keyCode == KeyEvent.KEYCODE_BACK
            && event.getRepeatCount() == 0
            && K9.manageBack())
        {
            // Take care of calling this method on earlier versions of
            // the platform where it doesn't exist.
            onBackPressed();
            return true;
        }


        switch (keyCode)
        {
            case KeyEvent.KEYCODE_Q:
                //case KeyEvent.KEYCODE_BACK:
            {
                onAccounts();
                return true;
            }

            case KeyEvent.KEYCODE_S:
            {
                onEditAccount();
                return true;
            }

            case KeyEvent.KEYCODE_H:
            {
                Toast toast = Toast.makeText(this, R.string.folder_list_help_key, Toast.LENGTH_LONG);
                toast.show();
                return true;
            }

            case KeyEvent.KEYCODE_1:
            {
                setDisplayMode(FolderMode.FIRST_CLASS);
                return true;
            }
            case KeyEvent.KEYCODE_2:
            {
                setDisplayMode(FolderMode.FIRST_AND_SECOND_CLASS);
                return true;
            }
            case KeyEvent.KEYCODE_3:
            {
                setDisplayMode(FolderMode.NOT_SECOND_CLASS);
                return true;
            }
            case KeyEvent.KEYCODE_4:
            {
                setDisplayMode(FolderMode.ALL);
                return true;
            }
        }//switch


        return super.onKeyDown(keyCode, event);
    }//onKeyDown

    private void setDisplayMode(FolderMode newMode)
    {
        mAccount.setFolderDisplayMode(newMode);
        mAccount.save(Preferences.getPreferences(this));
        if (mAccount.getFolderPushMode() != FolderMode.NONE)
        {
            MailService.actionRestartPushers(this, null);
        }
        onRefresh(false);
    }


    private void onRefresh(final boolean forceRemote)
    {

        MessagingController.getInstance(getApplication()).listFolders(mAccount, forceRemote, mAdapter.mListener);

    }

    private void onEditPrefs()
    {
        Prefs.actionPrefs(this);
    }
    private void onEditAccount()
    {
        AccountSettings.actionSettings(this, mAccount);
    }

    private void onEditFolder(Account account, String folderName)
    {
        FolderSettings.actionSettings(this, account, folderName);
    }

    private void onAccounts()
    {
        Accounts.listAccounts(this);
        finish();
    }

    private void onEmptyTrash(final Account account)
    {
        mHandler.dataChanged();

        MessagingController.getInstance(getApplication()).emptyTrash(account, null);
    }

    private void onExpunge(final Account account, String folderName)
    {
        MessagingController.getInstance(getApplication()).expunge(account, folderName, null);
    }

    private void checkMail(final Account account)
    {
        MessagingController.getInstance(getApplication()).checkMail(this, account, true, true, mAdapter.mListener);
    }

    private void sendMail(Account account)
    {
        MessagingController.getInstance(getApplication()).sendPendingMessages(account, mAdapter.mListener);
    }

    @Override public boolean onOptionsItemSelected(MenuItem item)
    {
        switch (item.getItemId())
        {
            case R.id.compose:
                MessageCompose.actionCompose(this, mAccount);

                return true;

            case R.id.check_mail:
                checkMail(mAccount);

                return true;

            case R.id.send_messages:
                MessagingController.getInstance(getApplication()).sendPendingMessages(mAccount, null);
                return true;
            case R.id.accounts:
                onAccounts();

                return true;

            case R.id.list_folders:
                onRefresh(REFRESH_REMOTE);

                return true;

            case R.id.account_settings:
                onEditAccount();

                return true;

            case R.id.app_settings:
                onEditPrefs();

                return true;

            case R.id.empty_trash:
                onEmptyTrash(mAccount);

                return true;

            case R.id.compact:
                onCompact(mAccount);

                return true;

            case R.id.display_1st_class:
            {
                setDisplayMode(FolderMode.FIRST_CLASS);
                return true;
            }
            case R.id.display_1st_and_2nd_class:
            {
                setDisplayMode(FolderMode.FIRST_AND_SECOND_CLASS);
                return true;
            }
            case R.id.display_not_second_class:
            {
                setDisplayMode(FolderMode.NOT_SECOND_CLASS);
                return true;
            }
            case R.id.display_all:
            {
                setDisplayMode(FolderMode.ALL);
                return true;
            }
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    private void onOpenFolder(String folder)
    {
        MessageList.actionHandleFolder(this, mAccount, folder);
        if (K9.manageBack())
        {
            finish();
        }
    }

    private void onCompact(Account account)
    {
        mHandler.workingAccount(R.string.compacting_account);
        MessagingController.getInstance(getApplication()).compact(account, null);
    }

    @Override public boolean onCreateOptionsMenu(Menu menu)
    {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.folder_list_option, menu);
        return true;
    }

    @Override public boolean onContextItemSelected(MenuItem item)
    {
        AdapterContextMenuInfo info = (AdapterContextMenuInfo) item .getMenuInfo();
        FolderInfoHolder folder = (FolderInfoHolder) mAdapter.getItem(info.position);

        switch (item.getItemId())
        {
            case R.id.open_folder:
                onOpenFolder(folder.name);
                break;

            case R.id.mark_all_as_read:
                onMarkAllAsRead(mAccount, folder.name);
                break;

            case R.id.send_messages:
                sendMail(mAccount);

                break;

            case R.id.check_mail:
                checkMail(folder);

                break;

            case R.id.folder_settings:
                onEditFolder(mAccount, folder.name);

                break;

            case R.id.empty_trash:
                onEmptyTrash(mAccount);

                break;
            case R.id.expunge:
                onExpunge(mAccount, folder.name);

                break;
        }

        return super.onContextItemSelected(item);
    }

    private FolderInfoHolder mSelectedContextFolder = null;


    private void onMarkAllAsRead(final Account account, final String folder)
    {
        mSelectedContextFolder = mAdapter.getFolder(folder);
        showDialog(DIALOG_MARK_ALL_AS_READ);
    }


    @Override
    public Dialog onCreateDialog(int id)
    {
        switch (id)
        {
            case DIALOG_MARK_ALL_AS_READ:
                return createMarkAllAsReadDialog();
        }

        return super.onCreateDialog(id);
    }

    @Override
    public void onPrepareDialog(int id, Dialog dialog)
    {
        switch (id)
        {
            case DIALOG_MARK_ALL_AS_READ:
                ((AlertDialog)dialog).setMessage(getString(R.string.mark_all_as_read_dlg_instructions_fmt,
                                                 mSelectedContextFolder.displayName));

                break;

            default:
                super.onPrepareDialog(id, dialog);
        }
    }

    private Dialog createMarkAllAsReadDialog()
    {
        return new AlertDialog.Builder(this)
               .setTitle(R.string.mark_all_as_read_dlg_title)
               .setMessage(getString(R.string.mark_all_as_read_dlg_instructions_fmt,
                                     mSelectedContextFolder.displayName))
               .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_MARK_ALL_AS_READ);

                try
                {

                    MessagingController.getInstance(getApplication()).markAllMessagesRead(mAccount, mSelectedContextFolder.name);

                    mSelectedContextFolder.unreadMessageCount = 0;

                    mHandler.dataChanged();


                }
                catch (Exception e)
                {
                    // Ignore
                }
            }
        })

               .setNegativeButton(R.string.cancel_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_MARK_ALL_AS_READ);
            }
        })

               .create();
    }


    @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)
    {
        super.onCreateContextMenu(menu, v, menuInfo);
        AdapterContextMenuInfo info = (AdapterContextMenuInfo) menuInfo;
        getMenuInflater().inflate(R.menu.folder_context, menu);

        FolderInfoHolder folder = (FolderInfoHolder) mAdapter.getItem(info.position);

        menu.setHeaderTitle((CharSequence) folder.displayName);

        if (!folder.name.equals(mAccount.getTrashFolderName()))
            menu.findItem(R.id.empty_trash).setVisible(false);

        if (folder.outbox)
        {
            menu.findItem(R.id.check_mail).setVisible(false);
        }
        else
        {
            menu.findItem(R.id.send_messages).setVisible(false);
        }
        if (K9.ERROR_FOLDER_NAME.equals(folder.name))
        {
            menu.findItem(R.id.expunge).setVisible(false);
        }

        menu.setHeaderTitle(folder.displayName);
    }

    class FolderListAdapter extends BaseAdapter
    {
        private ArrayList<FolderInfoHolder> mFolders = new ArrayList<FolderInfoHolder>();

        public Object getItem(long position)
        {
            return getItem((int)position);
        }

        public Object getItem(int position)
        {
            return mFolders.get(position);
        }


        public long getItemId(int position)
        {
            return position ;
        }

        public int getCount()
        {
            return mFolders.size();
        }

        @Override
        public boolean isEnabled(int item)
        {
            return true;
        }

        @Override
        public boolean areAllItemsEnabled()
        {
            return true;
        }

        private ActivityListener mListener = new ActivityListener()
        {
            @Override
            public void accountStatusChanged(BaseAccount account, AccountStats stats)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }
                mUnreadMessageCount = stats.unreadMessageCount;
                mHandler.refreshTitle();
            }

            @Override
            public void listFoldersStarted(Account account)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }

                mHandler.progress(true);
            }

            @Override
            public void listFoldersFailed(Account account, String message)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }

                mHandler.progress(false);

                if (Config.LOGV)
                {
                    Log.v(K9.LOG_TAG, ""listFoldersFailed "" + message);
                }
            }

            @Override
            public void listFoldersFinished(Account account)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }

                mHandler.progress(false);
                MessagingController.getInstance(getApplication()).refreshListener(mAdapter.mListener);
                mHandler.dataChanged();

            }

            @Override
            public void listFolders(Account account, Folder[] folders)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }

                List<FolderInfoHolder> newFolders = new LinkedList<FolderInfoHolder>();
                List<FolderInfoHolder> topFolders = new LinkedList<FolderInfoHolder>();

                Account.FolderMode aMode = account.getFolderDisplayMode();
                Preferences prefs = Preferences.getPreferences(getApplication().getApplicationContext());
                for (Folder folder : folders)
                {
                    try
                    {
                        folder.refresh(prefs);

                        Folder.FolderClass fMode = folder.getDisplayClass();

                        if ((aMode == Account.FolderMode.FIRST_CLASS && fMode != Folder.FolderClass.FIRST_CLASS)
                                || (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
                                    fMode != Folder.FolderClass.FIRST_CLASS &&
                                    fMode != Folder.FolderClass.SECOND_CLASS)
                                || (aMode == Account.FolderMode.NOT_SECOND_CLASS && fMode == Folder.FolderClass.SECOND_CLASS))
                        {
                            continue;
                        }
                    }
                    catch (MessagingException me)
                    {
                        Log.e(K9.LOG_TAG, ""Couldn't get prefs to check for displayability of folder "" + folder.getName(), me);
                    }

                    FolderInfoHolder holder = null;

                    int folderIndex = getFolderIndex(folder.getName());
                    if (folderIndex >= 0)
                    {
                        holder = (FolderInfoHolder) getItem(folderIndex);
                    }
                    int unreadMessageCount = 0;
                    try
                    {
                        unreadMessageCount  = folder.getUnreadMessageCount();
                    }
                    catch (Exception e)
                    {
                        Log.e(K9.LOG_TAG, ""Unable to get unreadMessageCount for "" + mAccount.getDescription() + "":""
                              + folder.getName());
                    }

                    if (holder == null)
                    {
                        holder = new FolderInfoHolder(context, folder, mAccount, unreadMessageCount);
                    }
                    else
                    {
                        holder.populate(context, folder, mAccount, unreadMessageCount);

                    }
                    if (folder.isInTopGroup())
                    {
                        topFolders.add(holder);
                    }
                    else
                    {
                        newFolders.add(holder);
                    }
                }
                Collections.sort(newFolders);
                Collections.sort(topFolders);
                topFolders.addAll(newFolders);
                mHandler.newFolders(topFolders);
                mHandler.refreshTitle();

            }

            @Override
            public void synchronizeMailboxStarted(Account account, String folder)
            {
                super.synchronizeMailboxStarted(account, folder);
                mHandler.refreshTitle();
                if (!account.equals(mAccount))
                {
                    return;
                }

                mHandler.progress(true);
                mHandler.folderLoading(folder, true);
                mHandler.dataChanged();

            }

            @Override
            public void synchronizeMailboxHeadersStarted(Account account, String folder)
            {

                super.synchronizeMailboxHeadersStarted(account, folder);
                mHandler.refreshTitle();
            }


            @Override
            public void synchronizeMailboxHeadersProgress(Account account, String folder, int completed, int total)
            {
                super.synchronizeMailboxHeadersProgress(account,folder,completed, total);
                mHandler.refreshTitle();
            }

            @Override
            public void synchronizeMailboxHeadersFinished(Account account, String folder,
                    int total, int completed)
            {
                super.synchronizeMailboxHeadersFinished(account,folder, total, completed);
                mHandler.refreshTitle();
            }





            @Override
            public void synchronizeMailboxProgress(Account account, String folder, int completed, int total)
            {
                super.synchronizeMailboxProgress(account, folder, completed, total);
                mHandler.refreshTitle();
            }

            @Override
            public void synchronizeMailboxFinished(Account account, String folder, int totalMessagesInMailbox, int numNewMessages)
            {
                super.synchronizeMailboxFinished(account, folder, totalMessagesInMailbox, numNewMessages);
                mHandler.refreshTitle();
                if (!account.equals(mAccount))
                {
                    return;
                }
                mHandler.progress(false);
                mHandler.folderLoading(folder, false);

                refreshFolder(account, folder);


            }

            private void refreshFolder(Account account, String folderName)
            {
                // There has to be a cheaper way to get at the localFolder object than this
                Folder localFolder = null;
                try
                {
                    if (account != null && folderName != null)
                    {
                        localFolder = account.getLocalStore().getFolder(folderName);
                        int unreadMessageCount = localFolder.getUnreadMessageCount();
                        if (localFolder != null)
                        {
                            FolderInfoHolder folderHolder = getFolder(folderName);
                            if (folderHolder != null)
                            {
                                folderHolder.populate(context, localFolder, mAccount, unreadMessageCount);
                                mHandler.dataChanged();
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Exception while populating folder"", e);
                }
                finally
                {
                    if (localFolder != null)
                    {
                        localFolder.close();
                    }
                }

            }

            @Override
            public void synchronizeMailboxFailed(Account account, String folder,
                                                 String message)
            {
                super.synchronizeMailboxFailed(account, folder, message);
                mHandler.refreshTitle();
                if (!account.equals(mAccount))
                {
                    return;
                }


                mHandler.progress(false);

                mHandler.folderLoading(folder, false);

                //   String mess = truncateStatus(message);

                //   mHandler.folderStatus(folder, mess);
                FolderInfoHolder holder = getFolder(folder);

                if (holder != null)
                {
                    holder.lastChecked = 0;
                }

                mHandler.dataChanged();

            }

            @Override
            public void setPushActive(Account account, String folderName, boolean enabled)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }
                FolderInfoHolder holder = getFolder(folderName);

                if (holder != null)
                {
                    holder.pushActive = enabled;

                    mHandler.dataChanged();
                }
            }


            @Override
            public void messageDeleted(Account account,
                                       String folder, Message message)
            {
                synchronizeMailboxRemovedMessage(account,
                                                 folder, message);
            }

            @Override
            public void emptyTrashCompleted(Account account)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }
                refreshFolder(account, mAccount.getTrashFolderName());
            }

            @Override
            public void folderStatusChanged(Account account, String folderName, int unreadMessageCount)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }
                refreshFolder(account, folderName);
            }

            @Override
            public void sendPendingMessagesCompleted(Account account)
            {
                super.sendPendingMessagesCompleted(account);
                mHandler.refreshTitle();
                if (!account.equals(mAccount))
                {
                    return;
                }

                refreshFolder(account, mAccount.getOutboxFolderName());


            }

            @Override
            public void sendPendingMessagesStarted(Account account)
            {
                super.sendPendingMessagesStarted(account);
                mHandler.refreshTitle();

                if (!account.equals(mAccount))
                {
                    return;
                }

                mHandler.dataChanged();

            }

            @Override
            public void sendPendingMessagesFailed(Account account)
            {
                super.sendPendingMessagesFailed(account);
                mHandler.refreshTitle();
                if (!account.equals(mAccount))
                {
                    return;
                }

                refreshFolder(account, mAccount.getOutboxFolderName());

            }

            @Override
            public void accountSizeChanged(Account account, long oldSize, long newSize)
            {
                if (!account.equals(mAccount))
                {
                    return;
                }

                mHandler.accountSizeChanged(oldSize, newSize);

            }

            @Override
            public void pendingCommandsProcessing(Account account)
            {
                super.pendingCommandsProcessing(account);
                mHandler.refreshTitle();
            }

            @Override
            public void pendingCommandsFinished(Account account)
            {
                super.pendingCommandsFinished(account);
                mHandler.refreshTitle();
            }

            @Override
            public void pendingCommandStarted(Account account, String commandTitle)
            {
                super.pendingCommandStarted(account, commandTitle);
                mHandler.refreshTitle();
            }

            @Override
            public void pendingCommandCompleted(Account account, String commandTitle)
            {
                super.pendingCommandCompleted(account, commandTitle);
                mHandler.refreshTitle();
            }

        };


        public int getFolderIndex(String folder)
        {
            FolderInfoHolder searchHolder = new FolderInfoHolder();
            searchHolder.name = folder;
            return   mFolders.indexOf((Object) searchHolder);
        }

        public FolderInfoHolder getFolder(String folder)
        {
            FolderInfoHolder holder = null;

            int index = getFolderIndex(folder);
            if (index >= 0)
            {
                holder = (FolderInfoHolder) getItem(index);
                if (holder != null)
                {
                    return holder;
                }
            }
            return null;
        }

        public View getView(int position, View convertView, ViewGroup parent)
        {
            if (position <= getCount())
            {
                return  getItemView(position, convertView, parent);
            }
            else
            {
                // XXX TODO - should catch an exception here
                return null;
            }
        }

        public View getItemView(int itemPosition, View convertView, ViewGroup parent)
        {
            FolderInfoHolder folder = (FolderInfoHolder) getItem(itemPosition);
            View view;
            if ((convertView != null) && (convertView.getId() == R.layout.folder_list_item))
            {
                view = convertView;
            }
            else
            {
                view = mInflater.inflate(R.layout.folder_list_item, parent, false);
                view.setId(R.layout.folder_list_item);
            }


            FolderViewHolder holder = (FolderViewHolder) view.getTag();

            if (holder == null)
            {
                holder = new FolderViewHolder();
                holder.folderName = (TextView) view.findViewById(R.id.folder_name);
                holder.newMessageCount = (TextView) view.findViewById(R.id.folder_unread_message_count);
                holder.flaggedMessageCount = (TextView) view.findViewById(R.id.folder_flagged_message_count);
                holder.folderStatus = (TextView) view.findViewById(R.id.folder_status);
                holder.activeIcons = (RelativeLayout) view.findViewById(R.id.active_icons);
                holder.chip = view.findViewById(R.id.chip);
                holder.rawFolderName = folder.name;

                view.setTag(holder);
            }

            if (folder == null)
            {
                return view;
            }

            holder.folderName.setText(folder.displayName);
            String statusText = """";

            if (folder.loading)
            {
                statusText = getString(R.string.status_loading);
            }
            else if (folder.status != null)
            {
                statusText = folder.status;
            }
            else if (folder.lastChecked != 0)
            {
                Date lastCheckedDate = new Date(folder.lastChecked);

                statusText = getTimeFormat().format(lastCheckedDate) + "" ""+
                             getDateFormat().format(lastCheckedDate);
            }

            if (folder.pushActive)
            {
                statusText = getString(R.string.folder_push_active_symbol) + "" ""+ statusText;
            }

            if (statusText != null)
            {
                holder.folderStatus.setText(statusText);
                holder.folderStatus.setVisibility(View.VISIBLE);
            }
            else
            {
                holder.folderStatus.setText(null);
                holder.folderStatus.setVisibility(View.GONE);
            }

            if (folder.unreadMessageCount != 0)
            {
                holder.newMessageCount.setText(Integer
                                               .toString(folder.unreadMessageCount));
                holder.newMessageCount.setOnClickListener(new FolderClickListener(mAccount, folder.name, folder.displayName, SearchModifier.UNREAD));
                holder.newMessageCount.setVisibility(View.VISIBLE);
            }
            else
            {
                holder.newMessageCount.setVisibility(View.GONE);
            }

            if (K9.messageListStars() && folder.flaggedMessageCount > 0)
            {
                holder.flaggedMessageCount.setText(Integer
                                                   .toString(folder.flaggedMessageCount));
                holder.flaggedMessageCount.setOnClickListener(new FolderClickListener(mAccount, folder.name, folder.displayName, SearchModifier.FLAGGED));
                holder.flaggedMessageCount.setVisibility(View.VISIBLE);
            }
            else
            {
                holder.flaggedMessageCount.setVisibility(View.GONE);
            }
            holder.activeIcons.setOnClickListener(new OnClickListener()
            {
                public void onClick(View v)
                {
                    Toast toast = Toast.makeText(getApplication(), getString(R.string.tap_hint), Toast.LENGTH_SHORT);
                    toast.show();
                }
            }
                                                 );

            holder.chip.setBackgroundColor(mAccount.getChipColor());
            holder.chip.getBackground().setAlpha(folder.unreadMessageCount == 0 ? 127 : 255);

            holder.folderName.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getFolderName());
            holder.folderStatus.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getFolderStatus());


            return view;
        }

        @Override
        public boolean hasStableIds()
        {
            return false;
        }

        public boolean isItemSelectable(int position)
        {
            return true;
        }

    }

    class FolderViewHolder
    {
        public TextView folderName;

        public TextView folderStatus;

        public TextView newMessageCount;
        public TextView flaggedMessageCount;

        public RelativeLayout activeIcons;
        public String rawFolderName;
        public View chip;
    }

    private class FolderClickListener implements OnClickListener
    {

        final BaseAccount account;
        final String folderName;
        final String displayName;
        final SearchModifier searchModifier;
        FolderClickListener(BaseAccount nAccount, String folderName, String displayName, SearchModifier nSearchModifier)
        {
            account = nAccount;
            this.folderName = folderName;
            searchModifier = nSearchModifier;
            this.displayName = displayName;
        }
        @Override
        public void onClick(View v)
        {
            String description = getString(R.string.search_title,
                                           getString(R.string.message_list_title, account.getDescription(), displayName),
                                           getString(searchModifier.resId));

            SearchSpecification searchSpec = new SearchSpecification()
            {
                @Override
                public String[] getAccountUuids()
                {
                    return new String[] { account.getUuid() };
                }

                @Override
                public Flag[] getForbiddenFlags()
                {
                    return searchModifier.forbiddenFlags;
                }

                @Override
                public String getQuery()
                {
                    return """";
                }

                @Override
                public Flag[] getRequiredFlags()
                {
                    return searchModifier.requiredFlags;
                }

                @Override
                public boolean isIntegrate()
                {
                    return false;
                }

                @Override
                public String[] getFolderNames()
                {
                    return new String[] { folderName };
                }

            };
            MessageList.actionHandle(FolderList.this, description, searchSpec);

        }

    }

    private static Flag[] UNREAD_FLAG_ARRAY = { Flag.SEEN };

    private void openUnreadSearch(Context context, final Account account)
    {
        String description = getString(R.string.search_title, mAccount.getDescription(), getString(R.string.unread_modifier));

        SearchSpecification searchSpec = new SearchSpecification()
        {
            //interface has no override            @Override
            public String[] getAccountUuids()
            {
                return new String[] { account.getUuid() };
            }

            //interface has no override            @Override
            public Flag[] getForbiddenFlags()
            {
                return UNREAD_FLAG_ARRAY;
            }

            //interface has no override            @Override
            public String getQuery()
            {
                return """";
            }

            @Override
            public Flag[] getRequiredFlags()
            {
                return null;
            }

            @Override
            public boolean isIntegrate()
            {
                return false;
            }

            @Override
            public String[] getFolderNames()
            {
                return null;
            }

        };
        MessageList.actionHandle(context, description, searchSpec);
    }

}
",True,217,1,1,8,59,4,27,L1
38,com.fsck.k9.activity.ToggleScrollView.java,"package com.fsck.k9.activity;

import android.content.Context;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.widget.ScrollView;

public class ToggleScrollView extends ScrollView
{
    private boolean mScrolling = true;

    public ToggleScrollView(Context context, AttributeSet attrs)
    {
        super(context, attrs);
    }

    public void setScrolling(boolean enable)
    {
        mScrolling = enable;
    }

    @Override
    public boolean onTouchEvent(MotionEvent ev)
    {
        return (mScrolling) ? super.onTouchEvent(ev) : true;
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev)
    {
        return (mScrolling) ? super.onInterceptTouchEvent(ev) : false;
    }
}
",False,92,8,39,0,0,1,0,L1
39,com.fsck.k9.activity.Accounts.java,"
package com.fsck.k9.activity;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.util.TypedValue;
import android.view.*;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.View.OnClickListener;
import android.webkit.WebView;
import android.widget.*;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.AdapterView.OnItemClickListener;
import com.fsck.k9.*;
import com.fsck.k9.activity.setup.AccountSettings;
import com.fsck.k9.activity.setup.AccountSetupBasics;
import com.fsck.k9.activity.setup.Prefs;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.mail.Flag;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

public class Accounts extends K9ListActivity implements OnItemClickListener, OnClickListener
{

    /**
     * Immutable empty {@link BaseAccount} array
     */
    private static final BaseAccount[] EMPTY_BASE_ACCOUNT_ARRAY = new BaseAccount[0];

    /**
     * Immutable empty {@link Flag} array
     */
    private static final Flag[] EMPTY_FLAG_ARRAY = new Flag[0];

    private static final int DIALOG_REMOVE_ACCOUNT = 1;
    private static final int DIALOG_CLEAR_ACCOUNT = 2;
    private static final int DIALOG_RECREATE_ACCOUNT = 3;
    private ConcurrentHashMap<String, AccountStats> accountStats = new ConcurrentHashMap<String, AccountStats>();

    private ConcurrentHashMap<BaseAccount, String> pendingWork = new ConcurrentHashMap<BaseAccount, String>();

    private BaseAccount mSelectedContextAccount;
    private int mUnreadMessageCount = 0;

    private AccountsHandler mHandler = new AccountsHandler();
    private AccountsAdapter mAdapter;
    private SearchAccount unreadAccount = null;
    private SearchAccount integratedInboxAccount = null;
    private FontSizes mFontSizes = K9.getFontSizes();

    class AccountsHandler extends Handler
    {
        private void setViewTitle()
        {
            String dispString = mListener.formatHeader(Accounts.this, getString(R.string.accounts_title), mUnreadMessageCount, getTimeFormat());

            setTitle(dispString);
        }
        public void refreshTitle()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    setViewTitle();
                }
            });
        }

        public void dataChanged()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    if (mAdapter != null)
                    {
                        mAdapter.notifyDataSetChanged();
                    }
                }
            });
        }

        public void workingAccount(final Account account, final int res)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    String toastText = getString(res, account.getDescription());

                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_SHORT);
                    toast.show();
                }
            });
        }

        public void accountSizeChanged(final Account account, final long oldSize, final long newSize)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    AccountStats stats = accountStats.get(account.getUuid());
                    if (newSize != -1 && stats != null && K9.measureAccounts())
                    {
                        stats.size = newSize;
                    }
                    String toastText = getString(R.string.account_size_changed, account.getDescription(),
                                                 SizeFormatter.formatSize(getApplication(), oldSize), SizeFormatter.formatSize(getApplication(), newSize));;

                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
                    toast.show();
                    if (mAdapter != null)
                    {
                        mAdapter.notifyDataSetChanged();
                    }
                }
            });
        }

        public void progress(final boolean progress)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    setProgressBarIndeterminateVisibility(progress);
                }
            });
        }
        public void progress(final int progress)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    getWindow().setFeatureInt(Window.FEATURE_PROGRESS, progress);
                }
            });
        }
    }

    ActivityListener mListener = new ActivityListener()
    {
        @Override
        public void folderStatusChanged(Account account, String folderName, int unreadMessageCount)
        {
            try
            {
                AccountStats stats = account.getStats(Accounts.this);
                accountStatusChanged(account, stats);
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to get account stats"", e);
            }
        }
        @Override
        public void accountStatusChanged(BaseAccount account, AccountStats stats)
        {
            AccountStats oldStats = accountStats.get(account.getUuid());
            int oldUnreadMessageCount = 0;
            if (oldStats != null)
            {
                oldUnreadMessageCount = oldStats.unreadMessageCount;
            }
            accountStats.put(account.getUuid(), stats);
            if (account instanceof Account)
            {
                mUnreadMessageCount += stats.unreadMessageCount - oldUnreadMessageCount;
            }
            mHandler.dataChanged();
            pendingWork.remove(account);

            if (pendingWork.isEmpty())
            {
                mHandler.progress(Window.PROGRESS_END);
                mHandler.refreshTitle();
            }
            else
            {
                int level = (Window.PROGRESS_END / mAdapter.getCount()) * (mAdapter.getCount() - pendingWork.size()) ;
                mHandler.progress(level);
            }
        }

        @Override
        public void accountSizeChanged(Account account, long oldSize, long newSize)
        {
            mHandler.accountSizeChanged(account, oldSize, newSize);
        }

        @Override
        public void synchronizeMailboxFinished(
            Account account,
            String folder,
            int totalMessagesInMailbox,
            int numNewMessages)
        {
            super.synchronizeMailboxFinished(account, folder, totalMessagesInMailbox, numNewMessages);
            MessagingController.getInstance(getApplication()).getAccountStats(Accounts.this, account, mListener);

            mHandler.progress(false);

            mHandler.refreshTitle();
        }

        @Override
        public void synchronizeMailboxStarted(Account account, String folder)
        {
            super.synchronizeMailboxStarted(account, folder);
            mHandler.progress(true);
            mHandler.refreshTitle();
        }

        @Override
        public void synchronizeMailboxProgress(Account account, String folder, int completed, int total)
        {
            super.synchronizeMailboxProgress(account, folder, completed, total);
            mHandler.refreshTitle();
        }

        @Override
        public void synchronizeMailboxFailed(Account account, String folder,
                                             String message)
        {
            super.synchronizeMailboxFailed(account, folder, message);
            mHandler.progress(false);
            mHandler.refreshTitle();

        }

        @Override
        public void sendPendingMessagesStarted(Account account)
        {
            super.sendPendingMessagesStarted(account);
            mHandler.refreshTitle();
        }

        @Override
        public void sendPendingMessagesCompleted(Account account)
        {
            super.sendPendingMessagesCompleted(account);
            mHandler.refreshTitle();
        }


        @Override
        public void sendPendingMessagesFailed(Account account)
        {
            super.sendPendingMessagesFailed(account);
            mHandler.refreshTitle();
        }

        @Override
        public void pendingCommandsProcessing(Account account)
        {
            super.pendingCommandsProcessing(account);
            mHandler.refreshTitle();
        }

        @Override
        public void pendingCommandsFinished(Account account)
        {
            super.pendingCommandsFinished(account);
            mHandler.refreshTitle();
        }

        @Override
        public void pendingCommandStarted(Account account, String commandTitle)
        {
            super.pendingCommandStarted(account, commandTitle);
            mHandler.refreshTitle();
        }

        @Override
        public void pendingCommandCompleted(Account account, String commandTitle)
        {
            super.pendingCommandCompleted(account, commandTitle);
            mHandler.refreshTitle();
        }


    };

    private static String ACCOUNT_STATS = ""accountStats"";
    private static String SELECTED_CONTEXT_ACCOUNT = ""selectedContextAccount"";

    public static final String EXTRA_STARTUP = ""startup"";


    public static void actionLaunch(Context context)
    {
        Intent intent = new Intent(context, Accounts.class);
        intent.putExtra(EXTRA_STARTUP, true);
        context.startActivity(intent);
    }

    public static void listAccounts(Context context)
    {
        Intent intent = new Intent(context, Accounts.class);
        intent.putExtra(EXTRA_STARTUP, false);
        context.startActivity(intent);
    }


    @Override
    public void onCreate(Bundle icicle)
    {
        super.onCreate(icicle);

        unreadAccount = new SearchAccount(this, false, null, null);
        unreadAccount.setDescription(getString(R.string.search_all_messages_title));
        unreadAccount.setEmail(getString(R.string.search_all_messages_detail));

        integratedInboxAccount = new SearchAccount(this, true, null,  null);
        integratedInboxAccount.setDescription(getString(R.string.integrated_inbox_title));
        integratedInboxAccount.setEmail(getString(R.string.integrated_inbox_detail));

        Account[] accounts = Preferences.getPreferences(this).getAccounts();
        Intent intent = getIntent();
        boolean startup = (boolean)intent.getBooleanExtra(EXTRA_STARTUP, true);
        if (startup && K9.startIntegratedInbox())
        {
            onOpenAccount(integratedInboxAccount);
            finish();
        }
        else if (startup && accounts.length == 1)
        {
            onOpenAccount(accounts[0]);
            finish();
        }
        else
        {
            requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
            requestWindowFeature(Window.FEATURE_PROGRESS);

            setContentView(R.layout.accounts);
            ListView listView = getListView();
            listView.setOnItemClickListener(this);
            listView.setItemsCanFocus(false);
            listView.setEmptyView(findViewById(R.id.empty));
            findViewById(R.id.next).setOnClickListener(this);
            registerForContextMenu(listView);

            if (icicle != null && icicle.containsKey(SELECTED_CONTEXT_ACCOUNT))
            {
                String accountUuid = icicle.getString(""selectedContextAccount"");
                mSelectedContextAccount = Preferences.getPreferences(this).getAccount(accountUuid);
            }

            if (icicle != null)
            {
                Map<String, AccountStats> oldStats = (Map<String, AccountStats>)icicle.get(ACCOUNT_STATS);
                if (oldStats != null)
                {
                    accountStats.putAll(oldStats);
                }
            }
        }
    }

    @Override
    public void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        if (mSelectedContextAccount != null)
        {
            outState.putString(SELECTED_CONTEXT_ACCOUNT, mSelectedContextAccount.getUuid());
        }
        outState.putSerializable(ACCOUNT_STATS, accountStats);
    }

    @Override
    public void onResume()
    {
        super.onResume();

        refresh();
        MessagingController.getInstance(getApplication()).addListener(mListener);
    }

    @Override
    public void onPause()
    {
        super.onPause();
        MessagingController.getInstance(getApplication()).removeListener(mListener);
    }

    private void refresh()
    {
        BaseAccount[] accounts = Preferences.getPreferences(this).getAccounts();

        List<BaseAccount> newAccounts = new ArrayList<BaseAccount>(accounts.length + 4);
        if (accounts.length > 0)
        {
            newAccounts.add(integratedInboxAccount);
            newAccounts.add(unreadAccount);
        }

        for (BaseAccount account : accounts)
        {
            newAccounts.add(account);
        }

        mAdapter = new AccountsAdapter(newAccounts.toArray(EMPTY_BASE_ACCOUNT_ARRAY));
        getListView().setAdapter(mAdapter);
        if (newAccounts.size() > 0)
        {
            mHandler.progress(Window.PROGRESS_START);
        }
        pendingWork.clear();

        for (BaseAccount account : newAccounts)
        {

            if (account instanceof Account)
            {
                pendingWork.put(account, ""true"");
                Account realAccount = (Account)account;
                MessagingController.getInstance(getApplication()).getAccountStats(Accounts.this, realAccount, mListener);
            }
            else if (K9.countSearchMessages() && account instanceof SearchAccount)
            {
                pendingWork.put(account, ""true"");
                final SearchAccount searchAccount = (SearchAccount)account;

                MessagingController.getInstance(getApplication()).searchLocalMessages(searchAccount, null, new MessagingListener()
                {
                    @Override
                    public void searchStats(AccountStats stats)
                    {
                        mListener.accountStatusChanged(searchAccount, stats);
                    }
                });
            }
        }

    }

    private void onAddNewAccount()
    {
        AccountSetupBasics.actionNewAccount(this);
    }

    private void onEditAccount(Account account)
    {
        AccountSettings.actionSettings(this, account);
    }

    private void onEditPrefs()
    {
        Prefs.actionPrefs(this);
    }


    /*
     * This method is called with 'null' for the argument 'account' if
     * all accounts are to be checked. This is handled accordingly in
     * MessagingController.checkMail().
     */
    private void onCheckMail(Account account)
    {
        MessagingController.getInstance(getApplication()).checkMail(this, account, true, true, null);
    }

    private void onClearCommands(Account account)
    {
        MessagingController.getInstance(getApplication()).clearAllPending(account);
    }

    private void onEmptyTrash(Account account)
    {
        MessagingController.getInstance(getApplication()).emptyTrash(account, null);
    }


    private void onCompose()
    {
        Account defaultAccount = Preferences.getPreferences(this).getDefaultAccount();
        if (defaultAccount != null)
        {
            MessageCompose.actionCompose(this, defaultAccount);
        }
        else
        {
            onAddNewAccount();
        }
    }

    private void onOpenAccount(BaseAccount account)
    {
        if (account instanceof SearchAccount)
        {
            SearchAccount searchAccount = (SearchAccount)account;
            MessageList.actionHandle(this, searchAccount.getDescription(), searchAccount);
        }
        else
        {
            Account realAccount = (Account)account;
            if (K9.FOLDER_NONE.equals(realAccount.getAutoExpandFolderName()))
            {
                FolderList.actionHandleAccount(this, realAccount);
            }
            else
            {
                MessageList.actionHandleFolder(this, realAccount, realAccount.getAutoExpandFolderName());
            }
        }
    }

    public void onClick(View view)
    {
        if (view.getId() == R.id.next)
        {
            onAddNewAccount();
        }
    }

    private void onDeleteAccount(Account account)
    {
        mSelectedContextAccount = account;
        showDialog(DIALOG_REMOVE_ACCOUNT);
    }

    @Override
    public Dialog onCreateDialog(int id)
    {
        switch (id)
        {
            case DIALOG_REMOVE_ACCOUNT:
                return createRemoveAccountDialog();
            case DIALOG_CLEAR_ACCOUNT:
                return createClearAccountDialog();
            case DIALOG_RECREATE_ACCOUNT:
                return createRecreateAccountDialog();
        }
        return super.onCreateDialog(id);
    }

    @Override
    public void onPrepareDialog(int id, Dialog d)
    {

        AlertDialog alert = (AlertDialog) d;
        switch (id)
        {
            case DIALOG_REMOVE_ACCOUNT:
                alert.setMessage(getString(R.string.account_delete_dlg_instructions_fmt,
                                           mSelectedContextAccount.getDescription()));
                break;
            case DIALOG_CLEAR_ACCOUNT:
                alert.setMessage(getString(R.string.account_clear_dlg_instructions_fmt,
                                           mSelectedContextAccount.getDescription()));
                break;
            case DIALOG_RECREATE_ACCOUNT:
                alert.setMessage(getString(R.string.account_recreate_dlg_instructions_fmt,
                                           mSelectedContextAccount.getDescription()));
                break;
        }

        super.onPrepareDialog(id, d);
    }


    private Dialog createRemoveAccountDialog()
    {
        return new AlertDialog.Builder(this)
               .setTitle(R.string.account_delete_dlg_title)
               .setMessage(getString(R.string.account_delete_dlg_instructions_fmt, mSelectedContextAccount.getDescription()))
               .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_REMOVE_ACCOUNT);

                if (mSelectedContextAccount instanceof Account)
                {
                    Account realAccount = (Account)mSelectedContextAccount;
                    try
                    {
                        realAccount.getLocalStore().delete();
                    }
                    catch (Exception e)
                    {
                        // Ignore
                    }
                    MessagingController.getInstance(getApplication()).notifyAccountCancel(Accounts.this, realAccount);
                    Preferences.getPreferences(Accounts.this).deleteAccount(realAccount);
                    K9.setServicesEnabled(Accounts.this);
                    refresh();
                }
            }
        })
               .setNegativeButton(R.string.cancel_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_REMOVE_ACCOUNT);
            }
        })
               .create();
    }

    private Dialog createClearAccountDialog()
    {
        return new AlertDialog.Builder(this)
               .setTitle(R.string.account_clear_dlg_title)
               .setMessage(getString(R.string.account_clear_dlg_instructions_fmt, mSelectedContextAccount.getDescription()))
               .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_CLEAR_ACCOUNT);

                if (mSelectedContextAccount instanceof Account)
                {
                    Account realAccount = (Account)mSelectedContextAccount;
                    mHandler.workingAccount(realAccount, R.string.clearing_account);
                    MessagingController.getInstance(getApplication()).clear(realAccount, null);
                }
            }
        })
               .setNegativeButton(R.string.cancel_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_CLEAR_ACCOUNT);
            }
        })
               .create();
    }

    private Dialog createRecreateAccountDialog()
    {
        return new AlertDialog.Builder(this)
               .setTitle(R.string.account_recreate_dlg_title)
               .setMessage(getString(R.string.account_recreate_dlg_instructions_fmt, mSelectedContextAccount.getDescription()))
               .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_RECREATE_ACCOUNT);

                if (mSelectedContextAccount instanceof Account)
                {
                    Account realAccount = (Account)mSelectedContextAccount;
                    mHandler.workingAccount(realAccount, R.string.recreating_account);
                    MessagingController.getInstance(getApplication()).recreate(realAccount, null);
                }
            }
        })
               .setNegativeButton(R.string.cancel_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_RECREATE_ACCOUNT);
            }
        })
               .create();
    }

    @Override
    public boolean onContextItemSelected(MenuItem item)
    {
        AdapterContextMenuInfo menuInfo = (AdapterContextMenuInfo)item.getMenuInfo();
        // submenus don't actually set the menuInfo, so the ""advanced""
        // submenu wouldn't work.
        if (menuInfo != null)
        {
            mSelectedContextAccount = (BaseAccount)getListView().getItemAtPosition(menuInfo.position);
        }
        Account realAccount = null;
        if (mSelectedContextAccount instanceof Account)
        {
            realAccount = (Account)mSelectedContextAccount;
        }
        switch (item.getItemId())
        {
            case R.id.delete_account:
                onDeleteAccount(realAccount);
                break;
            case R.id.edit_account:
                onEditAccount(realAccount);
                break;
            case R.id.open:
                onOpenAccount(mSelectedContextAccount);
                break;
            case R.id.check_mail:
                onCheckMail(realAccount);
                break;
            case R.id.clear_pending:
                onClearCommands(realAccount);
                break;
            case R.id.empty_trash:
                onEmptyTrash(realAccount);
                break;
            case R.id.compact:
                onCompact(realAccount);
                break;
            case R.id.clear:
                onClear(realAccount);
                break;
            case R.id.recreate:
                onRecreate(realAccount);
                break;
        }
        return true;
    }



    private void onCompact(Account account)
    {
        mHandler.workingAccount(account, R.string.compacting_account);
        MessagingController.getInstance(getApplication()).compact(account, null);
    }

    private void onClear(Account account)
    {
        showDialog(DIALOG_CLEAR_ACCOUNT);

    }
    private void onRecreate(Account account)
    {
        showDialog(DIALOG_RECREATE_ACCOUNT);
    }


    public void onItemClick(AdapterView<?> parent, View view, int position, long id)
    {
        BaseAccount account = (BaseAccount)parent.getItemAtPosition(position);
        onOpenAccount(account);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item)
    {
        switch (item.getItemId())
        {
            case R.id.add_new_account:
                onAddNewAccount();
                break;
            case R.id.edit_prefs:
                onEditPrefs();
                break;
            case R.id.check_mail:
                onCheckMail(null);
                break;
            case R.id.compose:
                onCompose();
                break;
            case R.id.about:
                onAbout();
                break;
            case R.id.search:
                onSearchRequested();
                break;
            default:
                return super.onOptionsItemSelected(item);
        }
        return true;
    }

    private void onAbout()
    {
        String appName = getString(R.string.app_name);
        WebView wv = new WebView(this);
        String html = ""<meta http-equiv=\""content-type\"" content=\""text/html; charset=utf-8\"" />"" +
                      ""<h1>"" + String.format(getString(R.string.about_title_fmt),
                                             ""<a href=\"""" + getString(R.string.app_webpage_url) + ""\"">"" + appName + ""</a>"") + ""</h1>"" +
                      ""<p>"" + appName + "" "" +
                      String.format(getString(R.string.debug_version_fmt),
                                    getVersionNumber()) + ""</p>"" +
                      ""<p>"" + String.format(getString(R.string.app_authors_fmt),
                                            getString(R.string.app_authors)) + ""</p>"" +
                      ""<p>"" + String.format(getString(R.string.app_revision_fmt),
                                            ""<a href=\"""" + getString(R.string.app_revision_url) + ""\"">"" +
                                            getString(R.string.app_revision_url) + ""</a></p>"");
        wv.loadData(html, ""text/html"", ""utf-8"");
        new AlertDialog.Builder(this)
        .setView(wv)
        .setCancelable(true)
        .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface d, int c)
            {
                d.dismiss();
            }
        })
        .show();
    }

    /**
     * Get current version number.
     *
     * @return String version
     */
    private String getVersionNumber()
    {
        String version = ""?"";
        try
        {
            PackageInfo pi = getPackageManager().getPackageInfo(getPackageName(), 0);
            version = pi.versionName;
        }
        catch (PackageManager.NameNotFoundException e)
        {
            //Log.e(TAG, ""Package name not found"", e);
        };
        return version;
    }

    public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id)
    {
        return true;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu)
    {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.accounts_option, menu);
        return true;
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)
    {
        super.onCreateContextMenu(menu, v, menuInfo);
        menu.setHeaderTitle(R.string.accounts_context_menu_title);
        getMenuInflater().inflate(R.menu.accounts_context, menu);

        AdapterContextMenuInfo info = (AdapterContextMenuInfo) menuInfo;
        BaseAccount account =  mAdapter.getItem(info.position);
        if (account instanceof SearchAccount)
        {
            for (int i = 0; i < menu.size(); i++)
            {
                MenuItem item = menu.getItem(i);
                if (item.getItemId() != R.id.open)
                {
                    item.setVisible(false);
                }
            }
        }
    }

    class AccountsAdapter extends ArrayAdapter<BaseAccount>
    {
        public AccountsAdapter(BaseAccount[] accounts)
        {
            super(Accounts.this, 0, accounts);
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent)
        {
            final BaseAccount account = getItem(position);
            View view;
            if (convertView != null)
            {
                view = convertView;
            }
            else
            {
                view = getLayoutInflater().inflate(R.layout.accounts_item, parent, false);
            }
            AccountViewHolder holder = (AccountViewHolder) view.getTag();
            if (holder == null)
            {
                holder = new AccountViewHolder();
                holder.description = (TextView) view.findViewById(R.id.description);
                holder.email = (TextView) view.findViewById(R.id.email);
                holder.newMessageCount = (TextView) view.findViewById(R.id.new_message_count);
                holder.flaggedMessageCount = (TextView) view.findViewById(R.id.flagged_message_count);
                holder.activeIcons = (RelativeLayout) view.findViewById(R.id.active_icons);

                holder.chip = view.findViewById(R.id.chip);
                holder.folders = (ImageButton) view.findViewById(R.id.folders);

                view.setTag(holder);
            }
            AccountStats stats = accountStats.get(account.getUuid());

            if (stats != null && account instanceof Account && stats.size >= 0)
            {
                holder.email.setText(SizeFormatter.formatSize(Accounts.this, stats.size));
                holder.email.setVisibility(View.VISIBLE);
            }
            else
            {
                if (account.getEmail().equals(account.getDescription()))
                {
                    holder.email.setVisibility(View.GONE);
                }
                else
                {
                    holder.email.setVisibility(View.VISIBLE);
                    holder.email.setText(account.getEmail());
                }
            }

            String description = account.getDescription();
            if (description == null || description.length() == 0)
            {
                description = account.getEmail();
            }

            holder.description.setText(description);

            Integer unreadMessageCount = null;
            if (stats != null)
            {
                unreadMessageCount = stats.unreadMessageCount;
                holder.newMessageCount.setText(Integer.toString(unreadMessageCount));
                holder.newMessageCount.setVisibility(unreadMessageCount > 0 ? View.VISIBLE : View.GONE);

                holder.flaggedMessageCount.setText(Integer.toString(stats.flaggedMessageCount));
                holder.flaggedMessageCount.setVisibility(K9.messageListStars() && stats.flaggedMessageCount > 0 ? View.VISIBLE : View.GONE);

                holder.flaggedMessageCount.setOnClickListener(new AccountClickListener(account, SearchModifier.FLAGGED));
                holder.newMessageCount.setOnClickListener(new AccountClickListener(account, SearchModifier.UNREAD));

                holder.activeIcons.setOnClickListener(new OnClickListener()
                {
                    public void onClick(View v)
                    {
                        Toast toast = Toast.makeText(getApplication(), getString(R.string.tap_hint), Toast.LENGTH_SHORT);
                        toast.show();
                    }
                }
                                                     );

            }
            else
            {
                holder.newMessageCount.setVisibility(View.GONE);
                holder.flaggedMessageCount.setVisibility(View.GONE);
            }
            if (account instanceof Account)
            {
                Account realAccount = (Account)account;

                holder.chip.setBackgroundColor(realAccount.getChipColor());
                if (unreadMessageCount == null)
                {
                    holder.chip.getBackground().setAlpha(0);
                }
                else if (unreadMessageCount == 0)
                {
                    holder.chip.getBackground().setAlpha(127);
                }
                else
                {
                    holder.chip.getBackground().setAlpha(255);
                }

            }
            else
            {
                holder.chip.setBackgroundColor(0x00000000);
            }


            holder.description.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getAccountName());
            holder.email.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getAccountDescription());


            if (account instanceof SearchAccount)
            {

                holder.folders.setVisibility(View.GONE);
            }
            else
            {
                holder.folders.setVisibility(View.VISIBLE);
                holder.folders.setOnClickListener(new OnClickListener()
                {
                    public void onClick(View v)
                    {
                        FolderList.actionHandleAccount(Accounts.this, (Account)account);

                    }
                });
            }

            return view;
        }

        class AccountViewHolder
        {
            public TextView description;
            public TextView email;
            public TextView newMessageCount;
            public TextView flaggedMessageCount;
            public RelativeLayout activeIcons;
            public View chip;
            public ImageButton folders;
        }
    }
    private Flag[] combine(Flag[] set1, Flag[] set2)
    {
        if (set1 == null)
        {
            return set2;
        }
        if (set2 == null)
        {
            return set1;
        }
        Set<Flag> flags = new HashSet<Flag>();
        for (Flag flag : set1)
        {
            flags.add(flag);
        }
        for (Flag flag : set2)
        {
            flags.add(flag);
        }
        return flags.toArray(EMPTY_FLAG_ARRAY);
    }

    private class AccountClickListener implements OnClickListener
    {

        final BaseAccount account;
        final SearchModifier searchModifier;
        AccountClickListener(BaseAccount nAccount, SearchModifier nSearchModifier)
        {
            account = nAccount;
            searchModifier = nSearchModifier;
        }
        @Override
        public void onClick(View v)
        {
            String description = getString(R.string.search_title, account.getDescription(), getString(searchModifier.resId));
            if (account instanceof SearchAccount)
            {
                SearchAccount searchAccount = (SearchAccount)account;

                MessageList.actionHandle(Accounts.this,
                                         description, """", searchAccount.isIntegrate(),
                                         combine(searchAccount.getRequiredFlags(), searchModifier.requiredFlags),
                                         combine(searchAccount.getForbiddenFlags(), searchModifier.forbiddenFlags));
            }
            else
            {
                SearchSpecification searchSpec = new SearchSpecification()
                {
                    @Override
                    public String[] getAccountUuids()
                    {
                        return new String[] { account.getUuid() };
                    }

                    @Override
                    public Flag[] getForbiddenFlags()
                    {
                        return searchModifier.forbiddenFlags;
                    }

                    @Override
                    public String getQuery()
                    {
                        return """";
                    }

                    @Override
                    public Flag[] getRequiredFlags()
                    {
                        return searchModifier.requiredFlags;
                    }

                    @Override
                    public boolean isIntegrate()
                    {
                        return false;
                    }

                    @Override
                    public String[] getFolderNames()
                    {
                        return null;
                    }

                };
                MessageList.actionHandle(Accounts.this, description, searchSpec);
            }
        }

    }

}
",True,216,0,0,8,64,3,22,L1
40,com.fsck.k9.activity.MessageInfoHolder.java,"package com.fsck.k9.activity;
import java.util.Date;

import com.fsck.k9.mail.Message;

public class MessageInfoHolder
{
    public String subject;
    public String date;
    public String fullDate;
    public Date compareDate;
    public String compareSubject;
    public CharSequence sender;
    public String senderAddress;
    public String compareCounterparty;
    public String preview;
    public String[] recipients;
    public boolean hasAttachments;
    public String uid;
    public boolean read;
    public boolean answered;
    public boolean flagged;
    public boolean downloaded;
    public boolean partially_downloaded;
    public Message message;
    public FolderInfoHolder folder;
    public boolean selected;
    public String account;
    public String uri;

    // Empty constructor for comparison
    public MessageInfoHolder()
    {
        this.selected = false;
    }

    @Override
    public boolean equals(Object o)
    {
        if (o instanceof MessageInfoHolder == false)
        {
            return false;
        }
        MessageInfoHolder other = (MessageInfoHolder)o;
        return message.equals(other.message);
    }

    @Override
    public int hashCode()
    {
        return uid.hashCode();
    }

}
",False,217,1,1,9,55,3,2,L1
41,com.fsck.k9.activity.Search.java,"package com.fsck.k9.activity;
import com.fsck.k9.activity.MessageList;


public class Search extends MessageList
{

};
",False,217,0,0,9,60,0,1,L4
42,com.fsck.k9.activity.ChooseIdentity.java,"
package com.fsck.k9.activity;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.Toast;
import com.fsck.k9.Account;
import com.fsck.k9.Identity;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import java.util.List;

public class ChooseIdentity extends K9ListActivity
{
    Account mAccount;
    String mUID;
    ArrayAdapter<String> adapter;

    public static final String EXTRA_ACCOUNT = ""com.fsck.k9.ChooseIdentity_account"";
    public static final String EXTRA_IDENTITY = ""com.fsck.k9.ChooseIdentity_identity"";

    protected List<Identity> identities = null;

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);

        getListView().setTextFilterEnabled(true);
        getListView().setItemsCanFocus(false);
        getListView().setChoiceMode(ListView.CHOICE_MODE_NONE);
        Intent intent = getIntent();
        String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1);

        setListAdapter(adapter);
        setupClickListeners();
    }


    @Override
    public void onResume()
    {
        super.onResume();
        refreshView();
    }


    protected void refreshView()
    {
        adapter.setNotifyOnChange(false);
        adapter.clear();

        identities = mAccount.getIdentities();
        for (Identity identity : identities)
        {
            String description = identity.getDescription();
            if (description == null || description.trim().length() == 0)
            {
                description = getString(R.string.message_view_from_format, identity.getName(), identity.getEmail());
            }
            adapter.add(description);
        }

        adapter.notifyDataSetChanged();
    }

    protected void setupClickListeners()
    {
        this.getListView().setOnItemClickListener(new AdapterView.OnItemClickListener()
        {
            public void onItemClick(AdapterView<?> parent, View view, int position, long id)
            {
                Identity identity = mAccount.getIdentity(position);
                String email = identity.getEmail();
                if (email != null && !email.trim().equals(""""))
                {
                    Intent intent = new Intent();

                    intent.putExtra(EXTRA_IDENTITY, mAccount.getIdentity(position));
                    setResult(RESULT_OK, intent);
                    finish();
                }
                else
                {
                    Toast.makeText(ChooseIdentity.this, getString(R.string.identity_has_no_email),
                                   Toast.LENGTH_LONG).show();
                }
            }
        });

    }
}
",False,216,0,0,8,52,3,4,L1
43,com.fsck.k9.activity.DateFormatter.java,"package com.fsck.k9.activity;

import android.content.Context;
import android.content.SharedPreferences.Editor;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Map;

public class DateFormatter
{
    private DateFormatter()
    {
    }
    private final static Calendar SAMPLE_DATE = Calendar.getInstance();
    static
    {
        SAMPLE_DATE.set(SAMPLE_DATE.get(Calendar.YEAR), SAMPLE_DATE.getActualMaximum(Calendar.MONTH), SAMPLE_DATE.getActualMaximum(Calendar.DAY_OF_MONTH));
    }

    public static final String SHORT_FORMAT = ""SHORT"";
    public static final String MEDIUM_FORMAT = ""MEDIUM"";
    public static final String DEFAULT_FORMAT = SHORT_FORMAT;

    public static final String PREF_KEY = ""dateFormat"";

    private static volatile String sChosenFormat = null;

    public static String getSampleDate(Context context, String formatString)
    {
        java.text.DateFormat formatter = getDateFormat(context, formatString);
        return formatter.format(SAMPLE_DATE.getTime());
    }

    public static String[] getFormats(Context context)
    {
        return context.getResources().getStringArray(R.array.date_formats);
    }

    private static ThreadLocal<Map<String, DateFormat>> storedFormats = new ThreadLocal<Map<String, DateFormat>>()
    {
        @Override
        public synchronized Map<String, DateFormat> initialValue()
        {
            return new HashMap<String, DateFormat>();
        }
    };

    public static DateFormat getDateFormat(Context context, String formatString)
    {
        java.text.DateFormat dateFormat;

        if (SHORT_FORMAT.equals(formatString))
        {
            dateFormat = android.text.format.DateFormat.getDateFormat(context);
        }
        else if (MEDIUM_FORMAT.equals(formatString))
        {
            dateFormat = android.text.format.DateFormat.getMediumDateFormat(context);
        }
        else
        {
            Map<String, DateFormat> formatMap = storedFormats.get();
            dateFormat = formatMap.get(formatString);

            if (dateFormat == null)
            {
                dateFormat = new SimpleDateFormat(formatString);
                formatMap.put(formatString, dateFormat);
            }
        }
        return dateFormat;
    }

    public static void setDateFormat(Editor editor, String formatString)
    {
        sChosenFormat = formatString;
        editor.putString(PREF_KEY, formatString);
    }

    public static String getFormat(Context context)
    {
        if (sChosenFormat == null)
        {
            Preferences prefs = Preferences.getPreferences(context);
            String chosenFormat = prefs.getPreferences().getString(PREF_KEY, DEFAULT_FORMAT);

            sChosenFormat = chosenFormat;
        }
        return sChosenFormat;
    }

    public static DateFormat getDateFormat(Context context)
    {
        String formatString = getFormat(context);
        return getDateFormat(context, formatString);
    }
}
",True,216,0,0,9,52,4,1,L1
44,com.fsck.k9.activity.ManageIdentities.java,"package com.fsck.k9.activity;

import android.content.Intent;
import android.view.*;
import android.view.ContextMenu.ContextMenuInfo;
import android.widget.AdapterView;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.ListView;
import android.widget.Toast;
import com.fsck.k9.Identity;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;

public class ManageIdentities extends ChooseIdentity
{
    private boolean mIdentitiesChanged = false;
    public static final String EXTRA_IDENTITIES = ""com.fsck.k9.EditIdentity_identities"";

    private static final int ACTIVITY_EDIT_IDENTITY = 1;

    @Override
    protected void setupClickListeners()
    {
        this.getListView().setOnItemClickListener(new AdapterView.OnItemClickListener()
        {
            public void onItemClick(AdapterView<?> parent, View view, int position, long id)
            {
                editItem(position);
            }
        });

        ListView listView = getListView();
        registerForContextMenu(listView);
    }

    private void editItem(int i)
    {
        Intent intent = new Intent(ManageIdentities.this, EditIdentity.class);
        intent.putExtra(EditIdentity.EXTRA_ACCOUNT, mAccount.getUuid());
        intent.putExtra(EditIdentity.EXTRA_IDENTITY, mAccount.getIdentity(i));
        intent.putExtra(EditIdentity.EXTRA_IDENTITY_INDEX, i);
        startActivityForResult(intent, ACTIVITY_EDIT_IDENTITY);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu)
    {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.manage_identities_option, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item)
    {
        switch (item.getItemId())
        {
            case R.id.new_identity:
                Intent intent = new Intent(ManageIdentities.this, EditIdentity.class);
                intent.putExtra(EditIdentity.EXTRA_ACCOUNT, mAccount.getUuid());
                startActivityForResult(intent, ACTIVITY_EDIT_IDENTITY);
                break;
            default:
                return super.onOptionsItemSelected(item);
        }
        return true;
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)
    {
        super.onCreateContextMenu(menu, v, menuInfo);
        menu.setHeaderTitle(R.string.manage_identities_context_menu_title);
        getMenuInflater().inflate(R.menu.manage_identities_context, menu);
    }

    @Override
    public boolean onContextItemSelected(MenuItem item)
    {
        AdapterContextMenuInfo menuInfo = (AdapterContextMenuInfo)item.getMenuInfo();
        switch (item.getItemId())
        {
            case R.id.edit:
                editItem(menuInfo.position);
                break;
            case R.id.up:
                if (menuInfo.position > 0)
                {
                    Identity identity = identities.remove(menuInfo.position);
                    identities.add(menuInfo.position - 1, identity);
                    mIdentitiesChanged = true;
                    refreshView();
                }

                break;
            case R.id.down:
                if (menuInfo.position < identities.size() - 1)
                {
                    Identity identity = identities.remove(menuInfo.position);
                    identities.add(menuInfo.position + 1, identity);
                    mIdentitiesChanged = true;
                    refreshView();
                }
                break;
            case R.id.top:
                Identity identity = identities.remove(menuInfo.position);
                identities.add(0, identity);
                mIdentitiesChanged = true;
                refreshView();
                break;
            case R.id.remove:
                if (identities.size() > 1)
                {
                    identities.remove(menuInfo.position);
                    mIdentitiesChanged = true;
                    refreshView();
                }
                else
                {
                    Toast.makeText(this, getString(R.string.no_removable_identity),
                                   Toast.LENGTH_LONG).show();
                }
                break;
        }
        return true;
    }


    @Override
    public void onResume()
    {
        super.onResume();
        //mAccount.refresh(Preferences.getPreferences(getApplication().getApplicationContext()));
        refreshView();
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (keyCode == KeyEvent.KEYCODE_BACK)
        {
            saveIdentities();
        }
        return super.onKeyDown(keyCode, event);
    }

    private void saveIdentities()
    {
        if (mIdentitiesChanged)
        {
            mAccount.setIdentities(identities);
            mAccount.save(Preferences.getPreferences(getApplication().getApplicationContext()));
        }
        finish();
    }
}
",False,216,0,0,8,52,1,6,L1
45,com.fsck.k9.activity.EditIdentity.java,"package com.fsck.k9.activity;

import android.os.Bundle;
import android.view.KeyEvent;
import android.view.View;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.EditText;
import android.widget.LinearLayout;
import com.fsck.k9.Account;
import com.fsck.k9.Identity;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import java.util.List;

public class EditIdentity extends K9Activity
{

    public static final String EXTRA_IDENTITY = ""com.fsck.k9.EditIdentity_identity"";
    public static final String EXTRA_IDENTITY_INDEX = ""com.fsck.k9.EditIdentity_identity_index"";
    public static final String EXTRA_ACCOUNT = ""com.fsck.k9.EditIdentity_account"";

    private Account mAccount;
    private Identity mIdentity;
    private int mIdentityIndex;
    private EditText mDescriptionView;
    private CheckBox mSignatureUse;
    private EditText mSignatureView;
    private LinearLayout mSignatureLayout;
    private EditText mEmailView;
//  private EditText mAlwaysBccView;
    private EditText mNameView;
    private EditText mReplyTo;

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        mIdentity = (Identity)getIntent().getSerializableExtra(EXTRA_IDENTITY);
        mIdentityIndex = getIntent().getIntExtra(EXTRA_IDENTITY_INDEX, -1);
        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        if (mIdentityIndex == -1)
        {
            mIdentity = new Identity();
        }

        setContentView(R.layout.edit_identity);

        /*
         * If we're being reloaded we override the original account with the one
         * we saved
         */
        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_IDENTITY))
        {
            mIdentity = (Identity)savedInstanceState.getSerializable(EXTRA_IDENTITY);
        }

        mDescriptionView = (EditText)findViewById(R.id.description);
        mDescriptionView.setText(mIdentity.getDescription());

        mNameView = (EditText)findViewById(R.id.name);
        mNameView.setText(mIdentity.getName());

        mEmailView = (EditText)findViewById(R.id.email);
        mEmailView.setText(mIdentity.getEmail());

        mReplyTo = (EditText) findViewById(R.id.reply_to);
        mReplyTo.setText(mIdentity.getReplyTo());

//      mAccountAlwaysBcc = (EditText)findViewById(R.id.bcc);
//      mAccountAlwaysBcc.setText(mIdentity.getAlwaysBcc());

        mSignatureLayout = (LinearLayout)findViewById(R.id.signature_layout);
        mSignatureUse = (CheckBox)findViewById(R.id.signature_use);
        mSignatureView = (EditText)findViewById(R.id.signature);
        mSignatureUse.setChecked(mIdentity.getSignatureUse());
        mSignatureUse.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener()
        {
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
            {
                if (isChecked)
                {
                    mSignatureLayout.setVisibility(View.VISIBLE);
                    mSignatureView.setText(mIdentity.getSignature());
                }
                else
                {
                    mSignatureLayout.setVisibility(View.GONE);
                }
            }
        });

        if (mSignatureUse.isChecked())
        {
            mSignatureView.setText(mIdentity.getSignature());
        }
        else
        {
            mSignatureLayout.setVisibility(View.GONE);
        }
    }

    @Override
    public void onResume()
    {
        super.onResume();
    }

    private void saveIdentity()
    {

        mIdentity.setDescription(mDescriptionView.getText().toString());
        mIdentity.setEmail(mEmailView.getText().toString());
        //      mIdentity.setAlwaysBcc(mAccountAlwaysBcc.getText().toString());
        mIdentity.setName(mNameView.getText().toString());
        mIdentity.setSignatureUse(mSignatureUse.isChecked());
        mIdentity.setSignature(mSignatureView.getText().toString());

        if (mReplyTo.getText().length() == 0)
        {
            mIdentity.setReplyTo(null);
        }
        else
        {
            mIdentity.setReplyTo(mReplyTo.getText().toString());
        }

        List<Identity> identities = mAccount.getIdentities();
        if (mIdentityIndex == -1)
        {
            identities.add(mIdentity);
        }
        else
        {
            identities.remove(mIdentityIndex);
            identities.add(mIdentityIndex, mIdentity);
        }

        mAccount.save(Preferences.getPreferences(getApplication().getApplicationContext()));

        finish();
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (keyCode == KeyEvent.KEYCODE_BACK)
        {
            saveIdentity();
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        outState.putSerializable(EXTRA_IDENTITY, mIdentity);
    }
}
",False,216,0,0,8,53,1,4,L1
46,com.fsck.k9.activity.LauncherShortcuts.java,"
package com.fsck.k9.activity;

import android.content.Intent;
import android.os.Bundle;
import android.os.Parcelable;
import android.util.TypedValue;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.ImageButton;
import android.widget.ListView;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.fsck.k9.Account;
import com.fsck.k9.BaseAccount;
import com.fsck.k9.FontSizes;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;

public class LauncherShortcuts extends K9ListActivity implements OnItemClickListener
{
    private AccountsAdapter mAdapter;
    private FontSizes mFontSizes = K9.getFontSizes();

    @Override
    public void onCreate(Bundle icicle)
    {
        super.onCreate(icicle);

        // finish() immediately if we aren't supposed to be here
        if (!Intent.ACTION_CREATE_SHORTCUT.equals(getIntent().getAction()))
        {
            finish();
            return;
        }

        setContentView(R.layout.launcher_shortcuts);
        ListView listView = getListView();
        listView.setOnItemClickListener(this);
        listView.setItemsCanFocus(false);

        refresh();
    }

    private void refresh()
    {
        Account[] accounts = Preferences.getPreferences(this).getAccounts();

        mAdapter = new AccountsAdapter(accounts);
        getListView().setAdapter(mAdapter);
    }

    private void setupShortcut(Account account)
    {
        final Intent shortcutIntent = FolderList.actionHandleAccountIntent(this, account, null, true);

        Intent intent = new Intent();
        intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
        String description = account.getDescription();
        if (description == null || description.length() == 0)
        {
            description = account.getEmail();
        }
        intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, description);
        Parcelable iconResource = Intent.ShortcutIconResource.fromContext(this, R.drawable.icon);
        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, iconResource);

        setResult(RESULT_OK, intent);
        finish();
    }

    public void onItemClick(AdapterView<?> parent, View view, int position, long id)
    {
        Account account = (Account) parent.getItemAtPosition(position);
        setupShortcut(account);
    }

    class AccountsAdapter extends ArrayAdapter<Account>
    {
        public AccountsAdapter(Account[] accounts)
        {
            super(LauncherShortcuts.this, 0, accounts);
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent)
        {
            final BaseAccount account = getItem(position);
            View view;
            if (convertView != null)
            {
                view = convertView;
            }
            else
            {
                view = getLayoutInflater().inflate(R.layout.accounts_item, parent, false);
            }
            AccountViewHolder holder = (AccountViewHolder) view.getTag();
            if (holder == null)
            {
                holder = new AccountViewHolder();
                holder.description = (TextView) view.findViewById(R.id.description);
                holder.email = (TextView) view.findViewById(R.id.email);
                holder.newMessageCount = (TextView) view.findViewById(R.id.new_message_count);
                holder.flaggedMessageCount = (TextView) view.findViewById(R.id.flagged_message_count);
                holder.activeIcons = (RelativeLayout) view.findViewById(R.id.active_icons);

                holder.chip = view.findViewById(R.id.chip);
                holder.folders = (ImageButton) view.findViewById(R.id.folders);

                view.setTag(holder);
            }

            if (account.getEmail().equals(account.getDescription()))
            {
                holder.email.setVisibility(View.GONE);
            }
            else
            {
                holder.email.setVisibility(View.VISIBLE);
                holder.email.setText(account.getEmail());
            }

            String description = account.getDescription();
            if (description == null || description.length() == 0)
            {
                description = account.getEmail();
            }

            holder.description.setText(description);

            holder.newMessageCount.setVisibility(View.GONE);
            holder.flaggedMessageCount.setVisibility(View.GONE);
            if (account instanceof Account)
            {
                Account realAccount = (Account)account;

                holder.chip.setBackgroundColor(realAccount.getChipColor());
                holder.chip.getBackground().setAlpha(255);
            }
            else
            {
                holder.chip.setBackgroundColor(0x00000000);
            }

            holder.description.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getAccountName());
            holder.email.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getAccountDescription());


            holder.folders.setVisibility(View.VISIBLE);
            holder.folders.setOnClickListener(new OnClickListener()
            {
                public void onClick(View v)
                {
                    FolderList.actionHandleAccount(LauncherShortcuts.this, (Account)account);

                }
            });

            return view;
        }

        class AccountViewHolder
        {
            public TextView description;
            public TextView email;
            public TextView newMessageCount;
            public TextView flaggedMessageCount;
            public RelativeLayout activeIcons;
            public View chip;
            public ImageButton folders;
        }
    }
}
",False,217,0,0,8,59,0,7,L4
47,com.fsck.k9.activity.MessageCompose.java,"
package com.fsck.k9.activity;

import java.io.File;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.StringTokenizer;
import java.util.regex.Pattern;

import org.apache.james.mime4j.codec.EncoderUtil;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.ContentResolver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Parcelable;
import android.provider.OpenableColumns;
import android.text.TextWatcher;
import android.text.util.Rfc822Tokenizer;
import android.util.Log;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnFocusChangeListener;
import android.view.Window;
import android.widget.AutoCompleteTextView.Validator;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.MultiAutoCompleteTextView;
import android.widget.TextView;
import android.widget.Toast;

import com.fsck.k9.Account;
import com.fsck.k9.EmailAddressAdapter;
import com.fsck.k9.EmailAddressValidator;
import com.fsck.k9.Identity;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.crypto.CryptoProvider;
import com.fsck.k9.crypto.PgpData;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.Body;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Multipart;
import com.fsck.k9.mail.Part;
import com.fsck.k9.mail.internet.MimeBodyPart;
import com.fsck.k9.mail.internet.MimeHeader;
import com.fsck.k9.mail.internet.MimeMessage;
import com.fsck.k9.mail.internet.MimeMultipart;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.internet.TextBody;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalAttachmentBody;

public class MessageCompose extends K9Activity implements OnClickListener, OnFocusChangeListener
{
    private static final int DIALOG_SAVE_OR_DISCARD_DRAFT_MESSAGE = 1;
    private static final int REPLY_WRAP_LINE_WIDTH = 72;

    private static final String ACTION_REPLY = ""com.fsck.k9.intent.action.REPLY"";
    private static final String ACTION_REPLY_ALL = ""com.fsck.k9.intent.action.REPLY_ALL"";
    private static final String ACTION_FORWARD = ""com.fsck.k9.intent.action.FORWARD"";
    private static final String ACTION_EDIT_DRAFT = ""com.fsck.k9.intent.action.EDIT_DRAFT"";

    private static final String EXTRA_ACCOUNT = ""account"";
    private static final String EXTRA_MESSAGE_BODY  = ""messageBody"";
    private static final String EXTRA_MESSAGE_REFERENCE = ""message_reference"";

    private static final String STATE_KEY_ATTACHMENTS =
        ""com.fsck.k9.activity.MessageCompose.attachments"";
    private static final String STATE_KEY_CC_SHOWN =
        ""com.fsck.k9.activity.MessageCompose.ccShown"";
    private static final String STATE_KEY_BCC_SHOWN =
        ""com.fsck.k9.activity.MessageCompose.bccShown"";
    private static final String STATE_KEY_QUOTED_TEXT_SHOWN =
        ""com.fsck.k9.activity.MessageCompose.quotedTextShown"";
    private static final String STATE_KEY_SOURCE_MESSAGE_PROCED =
        ""com.fsck.k9.activity.MessageCompose.stateKeySourceMessageProced"";
    private static final String STATE_KEY_DRAFT_UID =
        ""com.fsck.k9.activity.MessageCompose.draftUid"";
    private static final String STATE_IDENTITY_CHANGED =
        ""com.fsck.k9.activity.MessageCompose.identityChanged"";
    private static final String STATE_IDENTITY =
        ""com.fsck.k9.activity.MessageCompose.identity"";
    private static final String STATE_PGP_DATA = ""pgpData"";
    private static final String STATE_IN_REPLY_TO = ""com.fsck.k9.activity.MessageCompose.inReplyTo"";
    private static final String STATE_REFERENCES = ""com.fsck.k9.activity.MessageCompose.references"";

    private static final int MSG_PROGRESS_ON = 1;
    private static final int MSG_PROGRESS_OFF = 2;
    private static final int MSG_UPDATE_TITLE = 3;
    private static final int MSG_SKIPPED_ATTACHMENTS = 4;
    private static final int MSG_SAVED_DRAFT = 5;
    private static final int MSG_DISCARDED_DRAFT = 6;

    private static final int ACTIVITY_REQUEST_PICK_ATTACHMENT = 1;
    private static final int ACTIVITY_CHOOSE_IDENTITY = 2;
    private static final int ACTIVITY_CHOOSE_ACCOUNT = 3;

    /**
     * Regular expression to remove the first localized ""Re:"" prefix in subjects.
     *
     * Currently:
     * - ""Aw:"" (german: abbreviation for ""Antwort"")
     */
    private static final Pattern prefix = Pattern.compile(""^AW[:\\s]\\s*"", Pattern.CASE_INSENSITIVE);

    /**
     * The account used for message composition.
     */
    private Account mAccount;

    /**
     * This identity's settings are used for message composition.
     * Note: This has to be an identity of the account {@link #mAccount}.
     */
    private Identity mIdentity;

    private boolean mIdentityChanged = false;
    private boolean mSignatureChanged = false;

    /**
     * Reference to the source message (in case of reply, forward, or edit
     * draft actions).
     */
    private MessageReference mMessageReference;

    private Message mSourceMessage;
    private String mSourceMessageBody;

    /**
     * Indicates that the source message has been processed at least once and should not
     * be processed on any subsequent loads. This protects us from adding attachments that
     * have already been added from the restore of the view state.
     */
    private boolean mSourceMessageProcessed = false;


    private TextView mFromView;
    private MultiAutoCompleteTextView mToView;
    private MultiAutoCompleteTextView mCcView;
    private MultiAutoCompleteTextView mBccView;
    private EditText mSubjectView;
    private EditText mSignatureView;
    private EditText mMessageContentView;
    private LinearLayout mAttachments;
    private View mQuotedTextBar;
    private ImageButton mQuotedTextDelete;
    private EditText mQuotedText;
    private View mEncryptLayout;
    private CheckBox mCryptoSignatureCheckbox;
    private CheckBox mEncryptCheckbox;
    private TextView mCryptoSignatureUserId;
    private TextView mCryptoSignatureUserIdRest;

    private PgpData mPgpData = null;

    private String mReferences;
    private String mInReplyTo;

    private boolean mDraftNeedsSaving = false;
    private boolean mPreventDraftSaving = false;

    /**
     * The draft uid of this message. This is used when saving drafts so that the same draft is
     * overwritten instead of being created anew. This property is null until the first save.
     */
    private String mDraftUid;

    private Handler mHandler = new Handler()
    {
        @Override
        public void handleMessage(android.os.Message msg)
        {
            switch (msg.what)
            {
                case MSG_PROGRESS_ON:
                    setProgressBarIndeterminateVisibility(true);
                    break;
                case MSG_PROGRESS_OFF:
                    setProgressBarIndeterminateVisibility(false);
                    break;
                case MSG_UPDATE_TITLE:
                    updateTitle();
                    break;
                case MSG_SKIPPED_ATTACHMENTS:
                    Toast.makeText(
                        MessageCompose.this,
                        getString(R.string.message_compose_attachments_skipped_toast),
                        Toast.LENGTH_LONG).show();
                    break;
                case MSG_SAVED_DRAFT:
                    Toast.makeText(
                        MessageCompose.this,
                        getString(R.string.message_saved_toast),
                        Toast.LENGTH_LONG).show();
                    break;
                case MSG_DISCARDED_DRAFT:
                    Toast.makeText(
                        MessageCompose.this,
                        getString(R.string.message_discarded_toast),
                        Toast.LENGTH_LONG).show();
                    break;
                default:
                    super.handleMessage(msg);
                    break;
            }
        }
    };

    private Listener mListener = new Listener();
    private EmailAddressAdapter mAddressAdapter;
    private Validator mAddressValidator;


    class Attachment implements Serializable
    {
        public String name;
        public String contentType;
        public long size;
        public Uri uri;
    }

    /**
     * Compose a new message using the given account. If account is null the default account
     * will be used.
     * @param context
     * @param account
     */
    public static void actionCompose(Context context, Account account)
    {
        if (account == null)
        {
            account = Preferences.getPreferences(context).getDefaultAccount();
        }
        Intent i = new Intent(context, MessageCompose.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    /**
     * Compose a new message as a reply to the given message. If replyAll is true the function
     * is reply all instead of simply reply.
     * @param context
     * @param account
     * @param message
     * @param replyAll
     * @param messageBody optional, for decrypted messages, null if it should be grabbed from the given message
     */
    public static void actionReply(
        Context context,
        Account account,
        Message message,
        boolean replyAll,
        String messageBody)
    {
        Intent i = new Intent(context, MessageCompose.class);
        i.putExtra(EXTRA_MESSAGE_BODY, messageBody);
        i.putExtra(EXTRA_MESSAGE_REFERENCE, message.makeMessageReference());
        if (replyAll)
        {
            i.setAction(ACTION_REPLY_ALL);
        }
        else
        {
            i.setAction(ACTION_REPLY);
        }
        context.startActivity(i);
    }

    /**
     * Compose a new message as a forward of the given message.
     * @param context
     * @param account
     * @param message
     * @param messageBody optional, for decrypted messages, null if it should be grabbed from the given message
     */
    public static void actionForward(
        Context context,
        Account account,
        Message message,
        String messageBody)
    {
        Intent i = new Intent(context, MessageCompose.class);
        i.putExtra(EXTRA_MESSAGE_BODY, messageBody);
        i.putExtra(EXTRA_MESSAGE_REFERENCE, message.makeMessageReference());
        i.setAction(ACTION_FORWARD);
        context.startActivity(i);
    }

    /**
     * Continue composition of the given message. This action modifies the way this Activity
     * handles certain actions.
     * Save will attempt to replace the message in the given folder with the updated version.
     * Discard will delete the message from the given folder.
     * @param context
     * @param account
     * @param folder
     * @param message
     */
    public static void actionEditDraft(Context context, Account account, Message message)
    {
        Intent i = new Intent(context, MessageCompose.class);
        i.putExtra(EXTRA_MESSAGE_REFERENCE, message.makeMessageReference());
        i.setAction(ACTION_EDIT_DRAFT);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        setContentView(R.layout.message_compose);

        final Intent intent = getIntent();

        mMessageReference = (MessageReference) intent.getSerializableExtra(EXTRA_MESSAGE_REFERENCE);
        mSourceMessageBody = (String) intent.getStringExtra(EXTRA_MESSAGE_BODY);

        final String accountUuid = (mMessageReference != null) ?
                                   mMessageReference.accountUuid :
                                   intent.getStringExtra(EXTRA_ACCOUNT);

        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        if (mAccount == null)
        {
            mAccount = Preferences.getPreferences(this).getDefaultAccount();
        }

        if (mAccount == null)
        {
            /*
             * There are no accounts set up. This should not have happened. Prompt the
             * user to set up an account as an acceptable bailout.
             */
            startActivity(new Intent(this, Accounts.class));
            mDraftNeedsSaving = false;
            finish();
            return;
        }

        mAddressAdapter = EmailAddressAdapter.getInstance(this);
        mAddressValidator = new EmailAddressValidator();

        mFromView = (TextView)findViewById(R.id.from);
        mToView = (MultiAutoCompleteTextView)findViewById(R.id.to);
        mCcView = (MultiAutoCompleteTextView)findViewById(R.id.cc);
        mBccView = (MultiAutoCompleteTextView)findViewById(R.id.bcc);
        mSubjectView = (EditText)findViewById(R.id.subject);

        EditText upperSignature = (EditText)findViewById(R.id.upper_signature);
        EditText lowerSignature = (EditText)findViewById(R.id.lower_signature);

        mMessageContentView = (EditText)findViewById(R.id.message_content);
        mAttachments = (LinearLayout)findViewById(R.id.attachments);
        mQuotedTextBar = findViewById(R.id.quoted_text_bar);
        mQuotedTextDelete = (ImageButton)findViewById(R.id.quoted_text_delete);
        mQuotedText = (EditText)findViewById(R.id.quoted_text);

        TextWatcher watcher = new TextWatcher()
        {
            public void beforeTextChanged(CharSequence s, int start,
            int before, int after) { }

            public void onTextChanged(CharSequence s, int start,
                                      int before, int count)
            {
                mDraftNeedsSaving = true;
            }

            public void afterTextChanged(android.text.Editable s) { }
        };

        TextWatcher sigwatcher = new TextWatcher()
        {
            public void beforeTextChanged(CharSequence s, int start,
            int before, int after) { }

            public void onTextChanged(CharSequence s, int start,
                                      int before, int count)
            {
                mDraftNeedsSaving = true;
                mSignatureChanged = true;
            }

            public void afterTextChanged(android.text.Editable s) { }
        };

        mToView.addTextChangedListener(watcher);
        mCcView.addTextChangedListener(watcher);
        mBccView.addTextChangedListener(watcher);
        mSubjectView.addTextChangedListener(watcher);

        mMessageContentView.addTextChangedListener(watcher);
        mQuotedText.addTextChangedListener(watcher);

        /*
         * We set this to invisible by default. Other methods will turn it back on if it's
         * needed.
         */
        mQuotedTextBar.setVisibility(View.GONE);
        mQuotedText.setVisibility(View.GONE);

        mQuotedTextDelete.setOnClickListener(this);

        mFromView.setVisibility(View.GONE);

        mToView.setAdapter(mAddressAdapter);
        mToView.setTokenizer(new Rfc822Tokenizer());
        mToView.setValidator(mAddressValidator);

        mCcView.setAdapter(mAddressAdapter);
        mCcView.setTokenizer(new Rfc822Tokenizer());
        mCcView.setValidator(mAddressValidator);

        mBccView.setAdapter(mAddressAdapter);
        mBccView.setTokenizer(new Rfc822Tokenizer());
        mBccView.setValidator(mAddressValidator);


        mSubjectView.setOnFocusChangeListener(this);

        if (savedInstanceState != null)
        {
            /*
             * This data gets used in onCreate, so grab it here instead of onRestoreIntstanceState
             */
            mSourceMessageProcessed = savedInstanceState.getBoolean(STATE_KEY_SOURCE_MESSAGE_PROCED, false);
        }


        String action = intent.getAction();

        if (Intent.ACTION_VIEW.equals(action))
        {
            /*
             * Someone has clicked a mailto: link. The address is in the URI.
             */
            if (intent.getData() != null)
            {
                Uri uri = intent.getData();
                if (""mailto"".equals(uri.getScheme()))
                {
                    initializeFromMailTo(uri.toString());
                }
                else
                {
                    String toText = uri.getSchemeSpecificPart();
                    if (toText != null)
                    {
                        mToView.setText(toText);
                    }
                }
            }
        }
        else if (Intent.ACTION_SENDTO.equals(action))
        {
            final Uri uri = intent.getData();

            // look for recipient address
            if (uri != null && ""mailto"".equals(uri.getScheme()))
            {
                initializeFromMailTo(uri.toString());
            }
        }
        //TODO: Use constant Intent.ACTION_SEND_MULTIPLE once we drop Android 1.5 support
        else if (Intent.ACTION_SEND.equals(action)
                 || ""android.intent.action.SEND_MULTIPLE"".equals(action))
        {
            /*
             * Someone is trying to compose an email with an attachment, probably Pictures.
             * The Intent should contain an EXTRA_STREAM with the data to attach.
             */

            String text = intent.getStringExtra(Intent.EXTRA_TEXT);
            if (text != null)
            {
                mMessageContentView.setText(text);
            }
            String subject = intent.getStringExtra(Intent.EXTRA_SUBJECT);
            if (subject != null)
            {
                mSubjectView.setText(subject);
            }

            String type = intent.getType();
            //TODO: Use constant Intent.ACTION_SEND_MULTIPLE once we drop Android 1.5 support
            if (""android.intent.action.SEND_MULTIPLE"".equals(action))
            {
                ArrayList<Parcelable> list = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
                if (list != null)
                {
                    for (Parcelable parcelable : list)
                    {
                        Uri stream = (Uri) parcelable;
                        if (stream != null && type != null)
                        {
                            if (MimeUtility.mimeTypeMatches(type, K9.ACCEPTABLE_ATTACHMENT_SEND_TYPES))
                            {
                                addAttachment(stream);
                            }
                        }
                    }
                }
            }
            else
            {
                Uri stream = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);
                if (stream != null && type != null)
                {
                    if (MimeUtility.mimeTypeMatches(type, K9.ACCEPTABLE_ATTACHMENT_SEND_TYPES))
                    {
                        addAttachment(stream);
                    }
                }
            }

            /*
             * There might be an EXTRA_SUBJECT, EXTRA_TEXT, EXTRA_EMAIL, EXTRA_BCC or EXTRA_CC
             */

            String extraSubject = intent.getStringExtra(Intent.EXTRA_SUBJECT);
            String extraText = intent.getStringExtra(Intent.EXTRA_TEXT);

            mSubjectView.setText(extraSubject);
            mMessageContentView.setText(extraText);

            String[] extraEmail = intent.getStringArrayExtra(Intent.EXTRA_EMAIL);
            String[] extraCc = intent.getStringArrayExtra(Intent.EXTRA_CC);
            String[] extraBcc = intent.getStringArrayExtra(Intent.EXTRA_BCC);

            String addressList;
            // Cache array size, as per Google's recommendations.
            int arraySize;
            int i;

            addressList = """";
            if (extraEmail != null)
            {
                arraySize = extraEmail.length;
                for (i=0; i < arraySize; i++)
                {
                    addressList += extraEmail[i]+"", "";
                }
            }
            mToView.setText(addressList);

            addressList = """";
            if (extraCc != null)
            {
                arraySize = extraCc.length;
                for (i=0; i < arraySize; i++)
                {
                    addressList += extraCc[i]+"", "";
                }
            }
            mCcView.setText(addressList);

            addressList = """";
            if (extraBcc != null)
            {
                arraySize = extraBcc.length;
                for (i=0; i < arraySize; i++)
                {
                    addressList += extraBcc[i]+"", "";
                }
            }
            mBccView.setText(addressList);

        }

        if (mIdentity == null)
        {
            mIdentity = mAccount.getIdentity(0);
        }

        if (mAccount.isSignatureBeforeQuotedText())
        {
            mSignatureView = upperSignature;
            lowerSignature.setVisibility(View.GONE);
        }
        else
        {
            mSignatureView = lowerSignature;
            upperSignature.setVisibility(View.GONE);
        }
        mSignatureView.addTextChangedListener(sigwatcher);

        if (!mIdentity.getSignatureUse())
        {
            mSignatureView.setVisibility(View.GONE);
        }

        if (!mSourceMessageProcessed)
        {
            updateFrom();
            updateSignature();

            if (ACTION_REPLY.equals(action) ||
                    ACTION_REPLY_ALL.equals(action) ||
                    ACTION_FORWARD.equals(action) ||
                    ACTION_EDIT_DRAFT.equals(action))
            {
                /*
                 * If we need to load the message we add ourself as a message listener here
                 * so we can kick it off. Normally we add in onResume but we don't
                 * want to reload the message every time the activity is resumed.
                 * There is no harm in adding twice.
                 */
                MessagingController.getInstance(getApplication()).addListener(mListener);

                final Account account = Preferences.getPreferences(this).getAccount(mMessageReference.accountUuid);
                final String folderName = mMessageReference.folderName;
                final String sourceMessageUid = mMessageReference.uid;
                MessagingController.getInstance(getApplication()).loadMessageForView(account, folderName, sourceMessageUid, null);
            }

            if (!ACTION_EDIT_DRAFT.equals(action))
            {
                String bccAddress = mAccount.getAlwaysBcc();
                if ((bccAddress != null) && !("""".equals(bccAddress)))
                {
                    addAddress(mBccView, new Address(bccAddress, """"));
                }
            }

            /*
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""action = "" + action + "", account = "" + mMessageReference.accountUuid + "", folder = "" + mMessageReference.folderName + "", sourceMessageUid = "" + mMessageReference.uid);
            */

            if (ACTION_REPLY.equals(action) ||
                    ACTION_REPLY_ALL.equals(action))
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Setting message ANSWERED flag to true"");

                // TODO: Really, we should wait until we send the message, but that would require saving the original
                // message info along with a Draft copy, in case it is left in Drafts for a while before being sent

                final Account account = Preferences.getPreferences(this).getAccount(mMessageReference.accountUuid);
                final String folderName = mMessageReference.folderName;
                final String sourceMessageUid = mMessageReference.uid;
                MessagingController.getInstance(getApplication()).setFlag(account, folderName, new String[] { sourceMessageUid }, Flag.ANSWERED, true);
            }

            updateTitle();
        }

        if (ACTION_REPLY.equals(action) ||
                ACTION_REPLY_ALL.equals(action) ||
                ACTION_EDIT_DRAFT.equals(action))
        {
            //change focus to message body.
            mMessageContentView.requestFocus();
        }

        mEncryptLayout = (View)findViewById(R.id.layout_encrypt);
        mCryptoSignatureCheckbox = (CheckBox)findViewById(R.id.cb_crypto_signature);
        mCryptoSignatureUserId = (TextView)findViewById(R.id.userId);
        mCryptoSignatureUserIdRest = (TextView)findViewById(R.id.userIdRest);
        mEncryptCheckbox = (CheckBox)findViewById(R.id.cb_encrypt);

        initializeCrypto();
        final CryptoProvider crypto = mAccount.getCryptoProvider();
        if (crypto.isAvailable(this))
        {
            mEncryptLayout.setVisibility(View.VISIBLE);
            mCryptoSignatureCheckbox.setOnClickListener(new OnClickListener()
            {
                @Override
                public void onClick(View v)
                {
                    CheckBox checkBox = (CheckBox) v;
                    if (checkBox.isChecked())
                    {
                        mPreventDraftSaving = true;
                        if (!crypto.selectSecretKey(MessageCompose.this, mPgpData))
                        {
                            mPreventDraftSaving = false;
                        }
                        checkBox.setChecked(false);
                    }
                    else
                    {
                        mPgpData.setSignatureKeyId(0);
                        updateEncryptLayout();
                    }
                }
            });

            if (mAccount.getCryptoAutoSignature())
            {
                long ids[] = crypto.getSecretKeyIdsFromEmail(this, mIdentity.getEmail());
                if (ids != null && ids.length > 0)
                {
                    mPgpData.setSignatureKeyId(ids[0]);
                    mPgpData.setSignatureUserId(crypto.getUserId(this, ids[0]));
                }
                else
                {
                    mPgpData.setSignatureKeyId(0);
                    mPgpData.setSignatureUserId(null);
                }
            }
            updateEncryptLayout();
        }
        else
        {
            mEncryptLayout.setVisibility(View.GONE);
        }

        mDraftNeedsSaving = false;
    }

    private void initializeCrypto()
    {
        if (mPgpData != null)
        {
            return;
        }
        mPgpData = new PgpData();
    }

    /**
     * Fill the encrypt layout with the latest data about signature key and encryption keys.
     */
    public void updateEncryptLayout()
    {
        if (!mPgpData.hasSignatureKey())
        {
            mCryptoSignatureCheckbox.setText(R.string.btn_crypto_sign);
            mCryptoSignatureCheckbox.setChecked(false);
            mCryptoSignatureUserId.setVisibility(View.INVISIBLE);
            mCryptoSignatureUserIdRest.setVisibility(View.INVISIBLE);
        }
        else
        {
            // if a signature key is selected, then the checkbox itself has no text
            mCryptoSignatureCheckbox.setText("""");
            mCryptoSignatureCheckbox.setChecked(true);
            mCryptoSignatureUserId.setVisibility(View.VISIBLE);
            mCryptoSignatureUserIdRest.setVisibility(View.VISIBLE);
            mCryptoSignatureUserId.setText(R.string.unknown_crypto_signature_user_id);
            mCryptoSignatureUserIdRest.setText("""");

            String userId = mPgpData.getSignatureUserId();
            if (userId == null)
            {
                userId = mAccount.getCryptoProvider().getUserId(this, mPgpData.getSignatureKeyId());
                mPgpData.setSignatureUserId(userId);
            }

            if (userId != null)
            {
                String chunks[] = mPgpData.getSignatureUserId().split("" <"", 2);
                mCryptoSignatureUserId.setText(chunks[0]);
                if (chunks.length > 1)
                {
                    mCryptoSignatureUserIdRest.setText(""<"" + chunks[1]);
                }
            }
        }
    }

    @Override
    public void onResume()
    {
        super.onResume();
        MessagingController.getInstance(getApplication()).addListener(mListener);
    }

    @Override
    public void onPause()
    {
        super.onPause();
        saveIfNeeded();
        MessagingController.getInstance(getApplication()).removeListener(mListener);
    }

    /**
     * The framework handles most of the fields, but we need to handle stuff that we
     * dynamically show and hide:
     * Attachment list,
     * Cc field,
     * Bcc field,
     * Quoted text,
     */
    @Override
    protected void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        saveIfNeeded();
        ArrayList<Uri> attachments = new ArrayList<Uri>();
        for (int i = 0, count = mAttachments.getChildCount(); i < count; i++)
        {
            View view = mAttachments.getChildAt(i);
            Attachment attachment = (Attachment) view.getTag();
            attachments.add(attachment.uri);
        }
        outState.putParcelableArrayList(STATE_KEY_ATTACHMENTS, attachments);
        outState.putBoolean(STATE_KEY_CC_SHOWN, mCcView.getVisibility() == View.VISIBLE);
        outState.putBoolean(STATE_KEY_BCC_SHOWN, mBccView.getVisibility() == View.VISIBLE);
        outState.putBoolean(STATE_KEY_QUOTED_TEXT_SHOWN, mQuotedTextBar.getVisibility() == View.VISIBLE);
        outState.putBoolean(STATE_KEY_SOURCE_MESSAGE_PROCED, mSourceMessageProcessed);
        outState.putString(STATE_KEY_DRAFT_UID, mDraftUid);
        outState.putSerializable(STATE_IDENTITY, mIdentity);
        outState.putBoolean(STATE_IDENTITY_CHANGED, mIdentityChanged);
        outState.putSerializable(STATE_PGP_DATA, mPgpData);
        outState.putString(STATE_IN_REPLY_TO, mInReplyTo);
        outState.putString(STATE_REFERENCES, mReferences);
    }

    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState)
    {
        super.onRestoreInstanceState(savedInstanceState);
        ArrayList<Parcelable> attachments = (ArrayList<Parcelable>) savedInstanceState.getParcelableArrayList(STATE_KEY_ATTACHMENTS);
        mAttachments.removeAllViews();
        for (Parcelable p : attachments)
        {
            Uri uri = (Uri) p;
            addAttachment(uri);
        }

        mCcView.setVisibility(savedInstanceState.getBoolean(STATE_KEY_CC_SHOWN) ?  View.VISIBLE : View.GONE);
        mBccView.setVisibility(savedInstanceState.getBoolean(STATE_KEY_BCC_SHOWN) ?  View.VISIBLE : View.GONE);
        mQuotedTextBar.setVisibility(savedInstanceState.getBoolean(STATE_KEY_QUOTED_TEXT_SHOWN) ?  View.VISIBLE : View.GONE);
        mQuotedText.setVisibility(savedInstanceState.getBoolean(STATE_KEY_QUOTED_TEXT_SHOWN) ?  View.VISIBLE : View.GONE);
        mDraftUid = savedInstanceState.getString(STATE_KEY_DRAFT_UID);
        mIdentity = (Identity)savedInstanceState.getSerializable(STATE_IDENTITY);
        mIdentityChanged = savedInstanceState.getBoolean(STATE_IDENTITY_CHANGED);
        mPgpData = (PgpData) savedInstanceState.getSerializable(STATE_PGP_DATA);
        mInReplyTo = savedInstanceState.getString(STATE_IN_REPLY_TO);
        mReferences = savedInstanceState.getString(STATE_REFERENCES);

        initializeCrypto();
        updateFrom();
        updateSignature();
        updateEncryptLayout();

        mDraftNeedsSaving = false;
    }

    private void updateTitle()
    {
        if (mSubjectView.getText().length() == 0)
        {
            setTitle(R.string.compose_title);
        }
        else
        {
            setTitle(mSubjectView.getText().toString());
        }
    }

    public void onFocusChange(View view, boolean focused)
    {
        if (!focused)
        {
            updateTitle();
        }
    }

    private void addAddresses(MultiAutoCompleteTextView view, Address[] addresses)
    {
        if (addresses == null)
        {
            return;
        }
        for (Address address : addresses)
        {
            addAddress(view, address);
        }
    }

    private void addAddress(MultiAutoCompleteTextView view, Address address)
    {
        view.append(address + "", "");
    }

    private Address[] getAddresses(MultiAutoCompleteTextView view)
    {
        Address[] addresses = Address.parseUnencoded(view.getText().toString().trim());
        return addresses;
    }

    /*
     * Build the Body that will contain the text of the message. We'll decide where to
     * include it later.
     *
     * @param appendSig If true, append the user's signature to the message.
     */
    private String buildText(boolean appendSig)
    {
        boolean replyAfterQuote = false;
        String action = getIntent().getAction();
        if (mAccount.isReplyAfterQuote() &&
                (ACTION_REPLY.equals(action) || ACTION_REPLY_ALL.equals(action)))
        {
            replyAfterQuote = true;
        }

        String text = mMessageContentView.getText().toString();
        // Placing the signature before the quoted text does not make sense if replyAfterQuote is true.
        if (!replyAfterQuote && appendSig && mAccount.isSignatureBeforeQuotedText())
        {
            text = appendSignature(text);
        }

        if (mQuotedTextBar.getVisibility() == View.VISIBLE)
        {
            if (replyAfterQuote)
            {
                text = mQuotedText.getText().toString() + ""\n"" + text;
            }
            else
            {
                text += ""\n\n"" + mQuotedText.getText().toString();
            }
        }

        // Note: If user has selected reply after quote AND signature before quote, ignore the
        // latter setting and append the signature at the end.
        if (appendSig && (!mAccount.isSignatureBeforeQuotedText() || replyAfterQuote))
        {
            text = appendSignature(text);
        }

        return text;
    }

    private MimeMessage createMessage(boolean appendSig) throws MessagingException
    {
        MimeMessage message = new MimeMessage();
        message.addSentDate(new Date());
        Address from = new Address(mIdentity.getEmail(), mIdentity.getName());
        message.setFrom(from);
        message.setRecipients(RecipientType.TO, getAddresses(mToView));
        message.setRecipients(RecipientType.CC, getAddresses(mCcView));
        message.setRecipients(RecipientType.BCC, getAddresses(mBccView));
        message.setSubject(mSubjectView.getText().toString());
        message.setHeader(""X-User-Agent"", getString(R.string.message_header_mua));

        final String replyTo = mIdentity.getReplyTo();
        if (replyTo != null)
        {
            message.setReplyTo(new Address[] { new Address(replyTo) });
        }

        if (mInReplyTo != null)
        {
            message.setInReplyTo(mInReplyTo);
        }

        if (mReferences != null)
        {
            message.setReferences(mReferences);
        }

        String text = null;
        if (mPgpData.getEncryptedData() != null)
        {
            text = mPgpData.getEncryptedData();
        }
        else
        {
            text = buildText(appendSig);
        }

        TextBody body = new TextBody(text);

        if (mAttachments.getChildCount() > 0)
        {
            /*
             * The message has attachments that need to be included. First we add the part
             * containing the text that will be sent and then we include each attachment.
             */

            MimeMultipart mp;

            mp = new MimeMultipart();
            mp.addBodyPart(new MimeBodyPart(body, ""text/plain""));

            for (int i = 0, count = mAttachments.getChildCount(); i < count; i++)
            {
                Attachment attachment = (Attachment) mAttachments.getChildAt(i).getTag();

                MimeBodyPart bp = new MimeBodyPart(
                    new LocalStore.LocalAttachmentBody(attachment.uri, getApplication()));

                /*
                 * Correctly encode the filename here. Otherwise the whole
                 * header value (all parameters at once) will be encoded by
                 * MimeHeader.writeTo().
                 */
                bp.addHeader(MimeHeader.HEADER_CONTENT_TYPE, String.format(""%s;\n name=\""%s\"""",
                             attachment.contentType,
                             EncoderUtil.encodeIfNecessary(attachment.name,
                                                           EncoderUtil.Usage.WORD_ENTITY, 7)));

                bp.addHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, ""base64"");

                /*
                 * TODO: Oh the joys of MIME...
                 *
                 * From RFC 2183 (The Content-Disposition Header Field):
                 * ""Parameter values longer than 78 characters, or which
                 *  contain non-ASCII characters, MUST be encoded as specified
                 *  in [RFC 2184].""
                 *
                 * Example:
                 *
                 * Content-Type: application/x-stuff
                 *  title*1*=us-ascii'en'This%20is%20even%20more%20
                 *  title*2*=%2A%2A%2Afun%2A%2A%2A%20
                 *  title*3=""isn't it!""
                 */
                bp.addHeader(MimeHeader.HEADER_CONTENT_DISPOSITION, String.format(
                                 ""attachment;\n filename=\""%s\"";\n size=%d"",
                                 attachment.name, attachment.size));

                mp.addBodyPart(bp);
            }

            message.setBody(mp);
        }
        else
        {
            /*
             * No attachments to include, just stick the text body in the message and call
             * it good.
             */
            message.setBody(body);
        }

        return message;
    }

    private String appendSignature(String text)
    {
        if (mIdentity.getSignatureUse())
        {
            String signature = mSignatureView.getText().toString();

            if (signature != null && !signature.contentEquals(""""))
            {
                text += ""\n"" + signature;
            }
        }

        return text;
    }


    private void sendMessage()
    {
        new SendMessageTask().execute();
    }
    private void saveMessage()
    {
        new SaveMessageTask().execute();
    }

    private void saveIfNeeded()
    {
        if (!mDraftNeedsSaving || mPreventDraftSaving || mPgpData.hasEncryptionKeys())
        {
            return;
        }

        mDraftNeedsSaving = false;
        saveMessage();
    }

    public void onEncryptionKeySelectionDone()
    {
        if (mPgpData.hasEncryptionKeys())
        {
            onSend();
        }
        else
        {
            Toast.makeText(this, R.string.send_aborted, Toast.LENGTH_SHORT).show();
        }
    }

    public void onEncryptDone()
    {
        if (mPgpData.getEncryptedData() != null)
        {
            onSend();
        }
        else
        {
            Toast.makeText(this, R.string.send_aborted, Toast.LENGTH_SHORT).show();
        }
    }

    private void onSend()
    {
        if (getAddresses(mToView).length == 0 && getAddresses(mCcView).length == 0 && getAddresses(mBccView).length == 0)
        {
            mToView.setError(getString(R.string.message_compose_error_no_recipients));
            Toast.makeText(this, getString(R.string.message_compose_error_no_recipients), Toast.LENGTH_LONG).show();
            return;
        }
        if (mEncryptCheckbox.isChecked() && !mPgpData.hasEncryptionKeys())
        {
            // key selection before encryption
            String emails = """";
            Address[][] addresses = new Address[][] { getAddresses(mToView),
                    getAddresses(mCcView),
                    getAddresses(mBccView)
                                                    };
            for (Address[] addressArray : addresses)
            {
                for (Address address : addressArray)
                {
                    if (emails.length() != 0)
                    {
                        emails += "","";
                    }
                    emails += address.getAddress();
                }
            }
            if (emails.length() != 0)
            {
                emails += "","";
            }
            emails += mIdentity.getEmail();

            mPreventDraftSaving = true;
            if (!mAccount.getCryptoProvider().selectEncryptionKeys(MessageCompose.this, emails, mPgpData))
            {
                mPreventDraftSaving = false;
            }
            return;
        }
        if (mPgpData.hasEncryptionKeys() || mPgpData.hasSignatureKey())
        {
            if (mPgpData.getEncryptedData() == null)
            {
                String text = buildText(true);
                mPreventDraftSaving = true;
                if (!mAccount.getCryptoProvider().encrypt(this, text, mPgpData))
                {
                    mPreventDraftSaving = false;
                }
                return;
            }
        }
        sendMessage();
        mDraftNeedsSaving = false;
        finish();
    }

    private void onDiscard()
    {
        if (mDraftUid != null)
        {
            MessagingController.getInstance(getApplication()).deleteDraft(mAccount, mDraftUid);
            mDraftUid = null;
        }
        mHandler.sendEmptyMessage(MSG_DISCARDED_DRAFT);
        mDraftNeedsSaving = false;
        finish();
    }

    private void onSave()
    {
        mDraftNeedsSaving = true;
        saveIfNeeded();
        finish();
    }

    private void onAddCcBcc()
    {
        mCcView.setVisibility(View.VISIBLE);
        mBccView.setVisibility(View.VISIBLE);
    }

    /**
     * Kick off a picker for whatever kind of MIME types we'll accept and let Android take over.
     */
    private void onAddAttachment()
    {
        if (K9.isGalleryBuggy())
        {
            if (K9.useGalleryBugWorkaround())
            {
                Toast.makeText(MessageCompose.this,
                               getString(R.string.message_compose_use_workaround),
                               Toast.LENGTH_LONG).show();
            }
            else
            {
                Toast.makeText(MessageCompose.this,
                               getString(R.string.message_compose_buggy_gallery),
                               Toast.LENGTH_LONG).show();
            }
        }

        onAddAttachment2(K9.ACCEPTABLE_ATTACHMENT_SEND_TYPES[0]);
    }

    /**
     * Kick off a picker for the specified MIME type and let Android take over.
     */
    private void onAddAttachment2(final String mime_type)
    {
        if (mAccount.getCryptoProvider().isAvailable(this))
        {
            Toast.makeText(this, R.string.attachment_encryption_unsupported, Toast.LENGTH_LONG).show();
        }
        Intent i = new Intent(Intent.ACTION_GET_CONTENT);
        i.addCategory(Intent.CATEGORY_OPENABLE);
        i.setType(mime_type);
        startActivityForResult(Intent.createChooser(i, null), ACTIVITY_REQUEST_PICK_ATTACHMENT);
    }

    private void addAttachment(Uri uri)
    {
        addAttachment(uri, -1, null);
    }

    private void addAttachment(Uri uri, int size, String name)
    {
        ContentResolver contentResolver = getContentResolver();

        Attachment attachment = new Attachment();
        attachment.name = name;
        attachment.size = size;
        attachment.uri = uri;

        if (attachment.size == -1 || attachment.name == null)
        {
            Cursor metadataCursor = contentResolver.query(uri, new String[] { OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE }, null, null, null);
            if (metadataCursor != null)
            {
                try
                {
                    if (metadataCursor.moveToFirst())
                    {
                        if (attachment.name == null)
                        {
                            attachment.name = metadataCursor.getString(0);
                        }
                        if (attachment.size == -1)
                        {
                            attachment.size = metadataCursor.getInt(1);
                            Log.v(K9.LOG_TAG, ""size: "" + attachment.size);
                        }
                    }
                }
                finally
                {
                    metadataCursor.close();
                }
            }
        }

        if (attachment.name == null)
        {
            attachment.name = uri.getLastPathSegment();
        }

        String contentType = contentResolver.getType(uri);

        if (contentType == null)
        {
            contentType = MimeUtility.getMimeTypeByExtension(attachment.name);
        }

        attachment.contentType = contentType;

        if (attachment.size<=0)
        {
            String uriString = uri.toString();
            if (uriString.startsWith(""file://""))
            {
                Log.v(K9.LOG_TAG, uriString.substring(""file://"".length()));
                File f = new File(uriString.substring(""file://"".length()));
                attachment.size = f.length();
            }
            else
            {
                Log.v(K9.LOG_TAG, ""Not a file: "" + uriString);
            }
        }
        else
        {
            Log.v(K9.LOG_TAG, ""old attachment.size: "" + attachment.size);
        }
        Log.v(K9.LOG_TAG, ""new attachment.size: "" + attachment.size);

        View view = getLayoutInflater().inflate(R.layout.message_compose_attachment, mAttachments, false);
        TextView nameView = (TextView)view.findViewById(R.id.attachment_name);
        ImageButton delete = (ImageButton)view.findViewById(R.id.attachment_delete);
        nameView.setText(attachment.name);
        delete.setOnClickListener(this);
        delete.setTag(view);
        view.setTag(attachment);
        mAttachments.addView(view);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        // if a CryptoSystem activity is returning, then mPreventDraftSaving was set to true
        mPreventDraftSaving = false;

        if (mAccount.getCryptoProvider().onActivityResult(this, requestCode, resultCode, data, mPgpData))
        {
            return;
        }

        if (resultCode != RESULT_OK)
            return;
        if (data == null)
        {
            return;
        }
        switch (requestCode)
        {
            case ACTIVITY_REQUEST_PICK_ATTACHMENT:
                addAttachment(data.getData());
                mDraftNeedsSaving = true;
                break;
            case ACTIVITY_CHOOSE_IDENTITY:
                onIdentityChosen(data);
                break;
            case ACTIVITY_CHOOSE_ACCOUNT:
                onAccountChosen(data);
                break;
        }
    }

    private void onAccountChosen(final Intent intent)
    {
        final Bundle extras = intent.getExtras();
        final String uuid = extras.getString(ChooseAccount.EXTRA_ACCOUNT);
        final Identity identity = (Identity) extras.getSerializable(ChooseAccount.EXTRA_IDENTITY);

        final Account account = Preferences.getPreferences(this).getAccount(uuid);

        if (!mAccount.equals(account))
        {
            if (K9.DEBUG)
            {
                Log.v(K9.LOG_TAG, ""Switching account from "" + mAccount + "" to "" + account);
            }

            // on draft edit, make sure we don't keep previous message UID
            if (ACTION_EDIT_DRAFT.equals(getIntent().getAction()))
            {
                mMessageReference = null;
            }

            // test whether there is something to save
            if (mDraftNeedsSaving || (mDraftUid != null))
            {
                final String previousDraftUid = mDraftUid;
                final Account previousAccount = mAccount;

                // make current message appear as new
                mDraftUid = null;

                // actual account switch
                mAccount = account;

                if (K9.DEBUG)
                {
                    Log.v(K9.LOG_TAG, ""Account switch, saving new draft in new account"");
                }
                saveMessage();

                if (previousDraftUid != null)
                {
                    if (K9.DEBUG)
                    {
                        Log.v(K9.LOG_TAG, ""Account switch, deleting draft from previous account: ""
                              + previousDraftUid);
                    }
                    MessagingController.getInstance(getApplication()).deleteDraft(previousAccount,
                            previousDraftUid);
                }
            }
            else
            {
                mAccount = account;
            }
            // not sure how to handle mFolder, mSourceMessage?
        }

        switchToIdentity(identity);
    }

    private void onIdentityChosen(Intent intent)
    {
        Bundle bundle = intent.getExtras();;
        switchToIdentity((Identity)bundle.getSerializable(ChooseIdentity.EXTRA_IDENTITY));
    }

    private void switchToIdentity(Identity identity)
    {
        mIdentity = identity;
        mIdentityChanged = true;
        mDraftNeedsSaving = true;
        updateFrom();
        updateSignature();
    }

    private void updateFrom()
    {
        if (mIdentityChanged)
        {
            mFromView.setVisibility(View.VISIBLE);
        }
        mFromView.setText(getString(R.string.message_view_from_format, mIdentity.getName(), mIdentity.getEmail()));
    }

    private void updateSignature()
    {
        if (mIdentity.getSignatureUse())
        {
            mSignatureView.setText(mIdentity.getSignature());
            mSignatureView.setVisibility(View.VISIBLE);
        }
        else
        {
            mSignatureView.setVisibility(View.GONE);
        }
    }

    public void onClick(View view)
    {
        switch (view.getId())
        {
            case R.id.attachment_delete:
                /*
                 * The view is the delete button, and we have previously set the tag of
                 * the delete button to the view that owns it. We don't use parent because the
                 * view is very complex and could change in the future.
                 */
                mAttachments.removeView((View) view.getTag());
                mDraftNeedsSaving = true;
                break;
            case R.id.quoted_text_delete:
                mQuotedTextBar.setVisibility(View.GONE);
                mQuotedText.setVisibility(View.GONE);
                mDraftNeedsSaving = true;
                break;
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item)
    {
        switch (item.getItemId())
        {
            case R.id.send:
                mPgpData.setEncryptionKeys(null);
                onSend();
                break;
            case R.id.save:
                onSave();
                break;
            case R.id.discard:
                onDiscard();
                break;
            case R.id.add_cc_bcc:
                onAddCcBcc();
                break;
            case R.id.add_attachment:
                onAddAttachment();
                break;
            case R.id.add_attachment_image:
                onAddAttachment2(""image/*"");
                break;
            case R.id.add_attachment_video:
                onAddAttachment2(""video/*"");
                break;
            case R.id.choose_identity:
                onChooseIdentity();
                break;
            default:
                return super.onOptionsItemSelected(item);
        }
        return true;
    }

    private void onChooseIdentity()
    {
        // keep things simple: trigger account choice only if there are more
        // than 1 account
        if (Preferences.getPreferences(this).getAccounts().length > 1)
        {
            final Intent intent = new Intent(this, ChooseAccount.class);
            intent.putExtra(ChooseAccount.EXTRA_ACCOUNT, mAccount.getUuid());
            intent.putExtra(ChooseAccount.EXTRA_IDENTITY, mIdentity);
            startActivityForResult(intent, ACTIVITY_CHOOSE_ACCOUNT);
        }
        else if (mAccount.getIdentities().size() > 1)
        {
            Intent intent = new Intent(this, ChooseIdentity.class);
            intent.putExtra(ChooseIdentity.EXTRA_ACCOUNT, mAccount.getUuid());
            startActivityForResult(intent, ACTIVITY_CHOOSE_IDENTITY);
        }
        else
        {
            Toast.makeText(this, getString(R.string.no_identities),
                           Toast.LENGTH_LONG).show();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu)
    {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.message_compose_option, menu);

        /*
         * Show the menu items ""Add attachment (Image)"" and ""Add attachment (Video)""
         * if the work-around for the Gallery bug is enabled (see Issue 1186).
         */
        int found = 0;
        for (int i = menu.size() - 1; i >= 0; i--)
        {
            MenuItem item = menu.getItem(i);
            int id = item.getItemId();
            if ((id == R.id.add_attachment_image) ||
                    (id == R.id.add_attachment_video))
            {
                item.setVisible(K9.useGalleryBugWorkaround());
                found++;
            }

            // We found all the menu items we were looking for. So stop here.
            if (found == 2) break;
        }

        return true;
    }

    @Override
    public void onBackPressed()
    {
        // This will be called either automatically for you on 2.0
        // or later, or by the code above on earlier versions of the
        // platform.
        if (mDraftNeedsSaving)
        {
            showDialog(DIALOG_SAVE_OR_DISCARD_DRAFT_MESSAGE);
        }
        else
        {
            finish();
        }
    }

    @Override
    public Dialog onCreateDialog(int id)
    {
        switch (id)
        {
            case DIALOG_SAVE_OR_DISCARD_DRAFT_MESSAGE:
                return new AlertDialog.Builder(this)
                       .setTitle(R.string.save_or_discard_draft_message_dlg_title)
                       .setMessage(R.string.save_or_discard_draft_message_instructions_fmt)
                       .setPositiveButton(R.string.save_draft_action, new DialogInterface.OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int whichButton)
                    {
                        dismissDialog(1);
                        onSave();
                    }
                })
                       .setNegativeButton(R.string.discard_action, new DialogInterface.OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int whichButton)
                    {
                        dismissDialog(1);
                        onDiscard();
                    }
                })
                       .create();
        }
        return super.onCreateDialog(id);
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (
            // TODO - when we move to android 2.0, uncomment this.
            // android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.ECLAIR &&

            keyCode == KeyEvent.KEYCODE_BACK
            && event.getRepeatCount() == 0
            && K9.manageBack())
        {
            // Take care of calling this method on earlier versions of
            // the platform where it doesn't exist.
            onBackPressed();
            return true;
        }

        return super.onKeyDown(keyCode, event);
    }

    /**
     * Returns true if all attachments were able to be attached, otherwise returns false.
     */
    private boolean loadAttachments(Part part, int depth) throws MessagingException
    {
        if (part.getBody() instanceof Multipart)
        {
            Multipart mp = (Multipart) part.getBody();
            boolean ret = true;
            for (int i = 0, count = mp.getCount(); i < count; i++)
            {
                if (!loadAttachments(mp.getBodyPart(i), depth + 1))
                {
                    ret = false;
                }
            }
            return ret;
        }
        else
        {
            String contentType = MimeUtility.unfoldAndDecode(part.getContentType());
            String name = MimeUtility.getHeaderParameter(contentType, ""name"");
            if (name != null)
            {
                Body body = part.getBody();
                if (body != null && body instanceof LocalAttachmentBody)
                {
                    final Uri uri = ((LocalAttachmentBody) body).getContentUri();
                    mHandler.post(new Runnable()
                    {
                        public void run()
                        {
                            addAttachment(uri);
                        }
                    });
                }
                else
                {
                    return false;
                }
            }
            return true;
        }
    }

    /**
     * Pull out the parts of the now loaded source message and apply them to the new message
     * depending on the type of message being composed.
     * @param message
     */
    private void processSourceMessage(Message message)
    {
        String action = getIntent().getAction();
        if (ACTION_REPLY.equals(action) || ACTION_REPLY_ALL.equals(action))
        {
            try
            {
                if (message.getSubject() != null)
                {
                    final String subject = prefix.matcher(message.getSubject()).replaceFirst("""");

                    if (!subject.toLowerCase().startsWith(""re:""))
                    {
                        mSubjectView.setText(""Re: "" + subject);
                    }
                    else
                    {
                        mSubjectView.setText(subject);
                    }
                }
                else
                {
                    mSubjectView.setText("""");
                }

                /*
                 * If a reply-to was included with the message use that, otherwise use the from
                 * or sender address.
                 */
                Address[] replyToAddresses;
                if (message.getReplyTo().length > 0)
                {
                    addAddresses(mToView, replyToAddresses = message.getReplyTo());
                }
                else
                {
                    addAddresses(mToView, replyToAddresses = message.getFrom());
                }

                if (message.getMessageId() != null && message.getMessageId().length() > 0)
                {
                    String messageId = message.getMessageId();
                    mInReplyTo = messageId;

                    if (message.getReferences() != null && message.getReferences().length > 0)
                    {
                        StringBuffer buffy = new StringBuffer();
                        for (int i=0; i < message.getReferences().length; i++)
                            buffy.append(message.getReferences()[i]);

                        mReferences = buffy.toString() + "" "" + mInReplyTo;
                    }
                    else
                    {
                        mReferences = mInReplyTo;
                    }

                }
                else
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""could not get Message-ID."");
                }

                Part part = MimeUtility.findFirstPartByMimeType(mSourceMessage,
                            ""text/plain"");
                if (part != null || mSourceMessageBody != null)
                {
                    String quotedText = String.format(
                                            getString(R.string.message_compose_reply_header_fmt),
                                            Address.toString(mSourceMessage.getFrom()));

                    final String prefix = mAccount.getQuotePrefix();
                    // ""$"" and ""\"" in the quote prefix have to be escaped for
                    // the replaceAll() invocation.
                    final String escapedPrefix = prefix.replaceAll(""(\\\\|\\$)"", ""\\\\$1"");

                    final String text = (mSourceMessageBody != null) ?
                                        mSourceMessageBody :
                                        MimeUtility.getTextFromPart(part);

                    final String wrappedText = Utility.wrap(text, REPLY_WRAP_LINE_WIDTH - prefix.length());

                    quotedText += wrappedText.replaceAll(""(?m)^"", escapedPrefix);

                    quotedText = quotedText.replaceAll(""\\\r"", """");
                    mQuotedText.setText(quotedText);

                    mQuotedTextBar.setVisibility(View.VISIBLE);
                    mQuotedText.setVisibility(View.VISIBLE);
                }

                if (ACTION_REPLY_ALL.equals(action) || ACTION_REPLY.equals(action))
                {
                    Identity useIdentity = null;
                    for (Address address : message.getRecipients(RecipientType.TO))
                    {
                        Identity identity = mAccount.findIdentity(address);
                        if (identity != null)
                        {
                            useIdentity = identity;
                            break;
                        }
                    }
                    if (useIdentity == null)
                    {
                        if (message.getRecipients(RecipientType.CC).length > 0)
                        {
                            for (Address address : message.getRecipients(RecipientType.CC))
                            {
                                Identity identity = mAccount.findIdentity(address);
                                if (identity != null)
                                {
                                    useIdentity = identity;
                                    break;
                                }
                            }
                        }
                    }
                    if (useIdentity != null)
                    {
                        Identity defaultIdentity = mAccount.getIdentity(0);
                        if (useIdentity != defaultIdentity)
                        {
                            switchToIdentity(useIdentity);
                        }
                    }
                }

                if (ACTION_REPLY_ALL.equals(action))
                {
                    for (Address address : message.getRecipients(RecipientType.TO))
                    {
                        if (!mAccount.isAnIdentity(address))
                        {
                            addAddress(mToView, address);
                        }

                    }
                    if (message.getRecipients(RecipientType.CC).length > 0)
                    {
                        for (Address address : message.getRecipients(RecipientType.CC))
                        {
                            if (!mAccount.isAnIdentity(address) && !Utility.arrayContains(replyToAddresses, address))
                            {
                                addAddress(mCcView, address);
                            }

                        }
                        mCcView.setVisibility(View.VISIBLE);
                    }
                }
            }
            catch (MessagingException me)
            {
                /*
                 * This really should not happen at this point but if it does it's okay.
                 * The user can continue composing their message.
                 */
            }
        }
        else if (ACTION_FORWARD.equals(action))
        {
            try
            {
                if (message.getSubject() != null && !message.getSubject().toLowerCase().startsWith(""fwd:""))
                {
                    mSubjectView.setText(""Fwd: "" + message.getSubject());
                }
                else
                {
                    mSubjectView.setText(message.getSubject());
                }
                Part part = MimeUtility.findFirstPartByMimeType(message, ""text/plain"");
                if (part == null)
                {
                    part = MimeUtility.findFirstPartByMimeType(message, ""text/html"");
                }
                if (part != null || mSourceMessageBody != null)
                {
                    String quotedText = mSourceMessageBody;
                    if (quotedText == null)
                    {
                        quotedText = MimeUtility.getTextFromPart(part);
                    }
                    if (quotedText != null)
                    {
                        String text = String.format(
                                          getString(R.string.message_compose_fwd_header_fmt),
                                          mSourceMessage.getSubject(),
                                          Address.toString(mSourceMessage.getFrom()),
                                          Address.toString(
                                              mSourceMessage.getRecipients(RecipientType.TO)),
                                          Address.toString(
                                              mSourceMessage.getRecipients(RecipientType.CC)));
                        quotedText = quotedText.replaceAll(""\\\r"", """");
                        text += quotedText;
                        mQuotedText.setText(text);
                        mQuotedTextBar.setVisibility(View.VISIBLE);
                        mQuotedText.setVisibility(View.VISIBLE);
                    }
                }
                if (!mSourceMessageProcessed)
                {
                    if (!loadAttachments(message, 0))
                    {
                        mHandler.sendEmptyMessage(MSG_SKIPPED_ATTACHMENTS);
                    }
                }
            }
            catch (MessagingException me)
            {
                /*
                 * This really should not happen at this point but if it does it's okay.
                 * The user can continue composing their message.
                 */
            }
        }
        else if (ACTION_EDIT_DRAFT.equals(action))
        {
            try
            {
                mDraftUid = message.getUid();
                mSubjectView.setText(message.getSubject());
                addAddresses(mToView, message.getRecipients(RecipientType.TO));
                if (message.getRecipients(RecipientType.CC).length > 0)
                {
                    addAddresses(mCcView, message.getRecipients(RecipientType.CC));
                    mCcView.setVisibility(View.VISIBLE);
                }
                if (message.getRecipients(RecipientType.BCC).length > 0)
                {
                    addAddresses(mBccView, message.getRecipients(RecipientType.BCC));
                    mBccView.setVisibility(View.VISIBLE);
                }

                // Read In-Reply-To header from draft
                final String[] inReplyTo = message.getHeader(""In-Reply-To"");
                if ((inReplyTo != null) && (inReplyTo.length >= 1))
                {
                    mInReplyTo = inReplyTo[0];
                }

                // Read References header from draft
                final String[] references = message.getHeader(""References"");
                if ((references != null) && (references.length >= 1))
                {
                    mReferences = references[0];
                }

                if (!mSourceMessageProcessed)
                {
                    loadAttachments(message, 0);
                }
                Integer bodyLength = null;
                String[] k9identities = message.getHeader(K9.K9MAIL_IDENTITY);
                if (k9identities != null && k9identities.length > 0)
                {
                    String k9identity = k9identities[0];

                    if (k9identity != null)
                    {
                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""Got a saved identity: "" + k9identity);
                        StringTokenizer tokens = new StringTokenizer(k9identity, "":"", false);

                        String bodyLengthS = null;
                        String name = null;
                        String email = null;
                        String signature = null;
                        boolean signatureUse = message.getFolder().getAccount().getSignatureUse();
                        if (tokens.hasMoreTokens())
                        {
                            bodyLengthS = Utility.base64Decode(tokens.nextToken());
                            try
                            {
                                bodyLength = Integer.parseInt(bodyLengthS);
                            }
                            catch (Exception e)
                            {
                                Log.e(K9.LOG_TAG, ""Unable to parse bodyLength '"" + bodyLengthS + ""'"");
                            }
                        }
                        if (tokens.hasMoreTokens())
                        {
                            signatureUse = true;
                            signature = Utility.base64Decode(tokens.nextToken());
                        }
                        if (tokens.hasMoreTokens())
                        {
                            name = Utility.base64Decode(tokens.nextToken());
                        }
                        if (tokens.hasMoreTokens())
                        {
                            email = Utility.base64Decode(tokens.nextToken());
                        }

                        Identity newIdentity = new Identity();
                        newIdentity.setSignatureUse(signatureUse);
                        if (signature != null)
                        {
                            newIdentity.setSignature(signature);
                            mSignatureChanged = true;
                        }
                        else
                        {
                            newIdentity.setSignature(mIdentity.getSignature());
                        }

                        if (name != null)
                        {
                            newIdentity.setName(name);
                            mIdentityChanged = true;
                        }
                        else
                        {
                            newIdentity.setName(mIdentity.getName());
                        }

                        if (email != null)
                        {
                            newIdentity.setEmail(email);
                            mIdentityChanged = true;
                        }
                        else
                        {
                            newIdentity.setEmail(mIdentity.getEmail());
                        }

                        mIdentity = newIdentity;

                        updateSignature();
                        updateFrom();

                    }
                }
                Part part = MimeUtility.findFirstPartByMimeType(message, ""text/plain"");
                if (part != null)
                {
                    String text = MimeUtility.getTextFromPart(part);
                    if (bodyLength != null && bodyLength + 1 < text.length())   // + 1 to get rid of the newline we added when saving the draft
                    {
                        String bodyText = text.substring(0, bodyLength);
                        String quotedText = text.substring(bodyLength + 1, text.length());

                        mMessageContentView.setText(bodyText);
                        mQuotedText.setText(quotedText);

                        mQuotedTextBar.setVisibility(View.VISIBLE);
                        mQuotedText.setVisibility(View.VISIBLE);
                    }
                    else
                    {
                        mMessageContentView.setText(text);
                    }
                }
            }
            catch (MessagingException me)
            {
                // TODO
            }
        }
        mSourceMessageProcessed = true;
        mDraftNeedsSaving = false;
    }

    class Listener extends MessagingListener
    {
        @Override
        public void loadMessageForViewStarted(Account account, String folder, String uid)
        {
            if ((mMessageReference == null) || !mMessageReference.uid.equals(uid))
            {
                return;
            }

            mHandler.sendEmptyMessage(MSG_PROGRESS_ON);
        }

        @Override
        public void loadMessageForViewFinished(Account account, String folder, String uid, Message message)
        {
            if ((mMessageReference == null) || !mMessageReference.uid.equals(uid))
            {
                return;
            }

            mHandler.sendEmptyMessage(MSG_PROGRESS_OFF);
        }

        @Override
        public void loadMessageForViewBodyAvailable(Account account, String folder, String uid, final Message message)
        {
            if ((mMessageReference == null) || !mMessageReference.uid.equals(uid))
            {
                return;
            }

            mSourceMessage = message;
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    processSourceMessage(message);
                }
            });
        }

        @Override
        public void loadMessageForViewFailed(Account account, String folder, String uid, Throwable t)
        {
            if ((mMessageReference == null) || !mMessageReference.uid.equals(uid))
            {
                return;
            }
            mHandler.sendEmptyMessage(MSG_PROGRESS_OFF);
            // TODO show network error
        }

        @Override
        public void messageUidChanged(Account account, String folder, String oldUid, String newUid)
        {
            //TODO: is this really necessary here? mDraftUid is update after the call to MessagingController.saveDraft()
            // Track UID changes of the draft message
            if (account.equals(mAccount) &&
                    folder.equals(mAccount.getDraftsFolderName()) &&
                    oldUid.equals(mDraftUid))
            {
                mDraftUid = newUid;
            }

            // Track UID changes of the source message
            if (mMessageReference != null)
            {
                final Account sourceAccount = Preferences.getPreferences(MessageCompose.this).getAccount(mMessageReference.accountUuid);
                final String sourceFolder = mMessageReference.folderName;
                final String sourceMessageUid = mMessageReference.uid;

                if (account.equals(sourceAccount) && (folder.equals(sourceFolder)))
                {
                    if (oldUid.equals(sourceMessageUid))
                    {
                        mMessageReference.uid = newUid;
                    }
                    if ((mSourceMessage != null) && (oldUid.equals(mSourceMessage.getUid())))
                    {
                        mSourceMessage.setUid(newUid);
                    }
                }
            }
        }
    }

    private String decode(String s)
    throws UnsupportedEncodingException
    {
        return URLDecoder.decode(s, ""UTF-8"");
    }

    /**
     * When we are launched with an intent that includes a mailto: URI, we can actually
     * gather quite a few of our message fields from it.
     *
     * @mailToString the href (which must start with ""mailto:"").
     */
    private void initializeFromMailTo(String mailToString)
    {

        // Chop up everything between mailto: and ? to find recipients
        int index = mailToString.indexOf(""?"");
        int length = ""mailto"".length() + 1;
        String to;
        try
        {
            // Extract the recipient after mailto:
            if (index == -1)
            {
                to = decode(mailToString.substring(length));
            }
            else
            {
                to = decode(mailToString.substring(length, index));
            }
            mToView.setText(to);
        }
        catch (UnsupportedEncodingException e)
        {
            Log.e(K9.LOG_TAG, e.getMessage() + "" while decoding '"" + mailToString + ""'"");
        }

        // Extract the other parameters

        // We need to disguise this string as a URI in order to parse it
        Uri uri = Uri.parse(""foo://"" + mailToString);

        String addressList;

        addressList = """";
        List<String> cc = uri.getQueryParameters(""cc"");
        for (String address : cc)
        {
            addressList += address + "","";
        }
        mCcView.setText(addressList);

        addressList = """";
        List<String> bcc = uri.getQueryParameters(""bcc"");
        for (String address : bcc)
        {
            addressList += address + "","";
        }
        mBccView.setText(addressList);

        List<String> subject = uri.getQueryParameters(""subject"");
        if (subject.size() > 0)
        {
            mSubjectView.setText(subject.get(0));
        }

        List<String> body = uri.getQueryParameters(""body"");
        if (body.size() > 0)
        {
            mMessageContentView.setText(body.get(0));
        }
    }

    private class SendMessageTask extends AsyncTask<Void, Void, Void>
    {
        @Override
        protected Void doInBackground(Void... params)
        {
            /*
             * Create the message from all the data the user has entered.
             */
            MimeMessage message;
            try
            {
                message = createMessage(true);  // Only append sig on save
            }
            catch (MessagingException me)
            {
                Log.e(K9.LOG_TAG, ""Failed to create new message for send or save."", me);
                throw new RuntimeException(""Failed to create a new message for send or save."", me);
            }

            MessagingController.getInstance(getApplication()).sendMessage(mAccount, message, null);
            if (mDraftUid != null)
            {
                MessagingController.getInstance(getApplication()).deleteDraft(mAccount, mDraftUid);
                mDraftUid = null;
            }

            return null;
        }
    }

    private class SaveMessageTask extends AsyncTask<Void, Void, Void>
    {
        @Override
        protected Void doInBackground(Void... params)
        {

            /*
             * Create the message from all the data the user has entered.
             */
            MimeMessage message;
            try
            {
                message = createMessage(false);  // Only append sig on save
            }
            catch (MessagingException me)
            {
                Log.e(K9.LOG_TAG, ""Failed to create new message for send or save."", me);
                throw new RuntimeException(""Failed to create a new message for send or save."", me);
            }

            /*
             * Save a draft
             */
            if (mDraftUid != null)
            {
                message.setUid(mDraftUid);
            }
            else if (ACTION_EDIT_DRAFT.equals(getIntent().getAction()))
            {
                /*
                 * We're saving a previously saved draft, so update the new message's uid
                 * to the old message's uid.
                 */
                message.setUid(mMessageReference.uid);
            }

            String k9identity = Utility.base64Encode("""" + mMessageContentView.getText().toString().length());

            if (mIdentityChanged || mSignatureChanged)
            {
                String signature  = mSignatureView.getText().toString();
                k9identity += "":"" + Utility.base64Encode(signature);
                if (mIdentityChanged)
                {

                    String name = mIdentity.getName();
                    String email = mIdentity.getEmail();

                    k9identity +=  "":"" + Utility.base64Encode(name) + "":"" + Utility.base64Encode(email);
                }
            }

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Saving identity: "" + k9identity);
            message.addHeader(K9.K9MAIL_IDENTITY, k9identity);

            Message draftMessage = MessagingController.getInstance(getApplication()).saveDraft(mAccount, message);
            mDraftUid = draftMessage.getUid();

            // Don't display the toast if the user is just changing the orientation
            if ((getChangingConfigurations() & ActivityInfo.CONFIG_ORIENTATION) == 0)
            {
                mHandler.sendEmptyMessage(MSG_SAVED_DRAFT);
            }
            return null;
        }
    }

}
",True,216,0,0,8,60,6,30,L1
48,com.fsck.k9.activity.ColorPickerDialog.java,"/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.activity;

import com.fsck.k9.R;
import android.os.Bundle;
import android.app.Dialog;

import android.content.Context;
import android.graphics.*;
import android.view.MotionEvent;
import android.view.View;


public class ColorPickerDialog extends Dialog
{

    public interface OnColorChangedListener
    {
        void colorChanged(int color);
    }

    private OnColorChangedListener mListener;
    private int mInitialColor;

    private static class ColorPickerView extends View
    {
        private Paint mPaint;
        private Paint mCenterPaint;
        private final int[] mColors;
        private OnColorChangedListener mListener;

        ColorPickerView(Context c, OnColorChangedListener l, int color)
        {
            super(c);
            mListener = l;
            mColors = new int[]
            {
                0xFF800000, 0xFF800080, 0xFF000080, 0xFF008080, 0xFF008000,
                0xFF808000, 0xFF800000
            };
            Shader s = new SweepGradient(0, 0, mColors, null);

            mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
            mPaint.setShader(s);
            mPaint.setStyle(Paint.Style.STROKE);
            mPaint.setStrokeWidth(32);

            mCenterPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
            mCenterPaint.setColor(color);
            mCenterPaint.setStrokeWidth(5);
        }

        private boolean mTrackingCenter;
        private boolean mHighlightCenter;

        @Override
        protected void onDraw(Canvas canvas)
        {
            float r = CENTER_X - mPaint.getStrokeWidth()*0.5f;

            canvas.translate(CENTER_X, CENTER_X);

            canvas.drawOval(new RectF(-r, -r, r, r), mPaint);
            canvas.drawCircle(0, 0, CENTER_RADIUS, mCenterPaint);

            if (mTrackingCenter)
            {
                int c = mCenterPaint.getColor();
                mCenterPaint.setStyle(Paint.Style.STROKE);

                if (mHighlightCenter)
                {
                    mCenterPaint.setAlpha(0xFF);
                }
                else
                {
                    mCenterPaint.setAlpha(0x80);
                }
                canvas.drawCircle(0, 0,
                                  CENTER_RADIUS + mCenterPaint.getStrokeWidth(),
                                  mCenterPaint);

                mCenterPaint.setStyle(Paint.Style.FILL);
                mCenterPaint.setColor(c);
            }
        }

        @Override
        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
        {
            setMeasuredDimension(CENTER_X*2, CENTER_Y*2);
        }

        private static final int CENTER_X = 100;
        private static final int CENTER_Y = 100;
        private static final int CENTER_RADIUS = 32;

        private int floatToByte(float x)
        {
            int n = java.lang.Math.round(x);
            return n;
        }
        private int pinToByte(int n)
        {
            if (n < 0)
            {
                n = 0;
            }
            else if (n > 255)
            {
                n = 255;
            }
            return n;
        }

        private int ave(int s, int d, float p)
        {
            return s + java.lang.Math.round(p *(d - s));
        }

        private int interpColor(int colors[], float unit)
        {
            if (unit <= 0)
            {
                return colors[0];
            }
            if (unit >= 1)
            {
                return colors[colors.length - 1];
            }

            float p = unit * (colors.length - 1);
            int i = (int)p;
            p -= i;

            // now p is just the fractional part [0...1) and i is the index
            int c0 = colors[i];
            int c1 = colors[i+1];
            int a = ave(Color.alpha(c0), Color.alpha(c1), p);
            int r = ave(Color.red(c0), Color.red(c1), p);
            int g = ave(Color.green(c0), Color.green(c1), p);
            int b = ave(Color.blue(c0), Color.blue(c1), p);

            return Color.argb(a, r, g, b);
        }

        private int rotateColor(int color, float rad)
        {
            float deg = rad * 180 / 3.1415927f;
            int r = Color.red(color);
            int g = Color.green(color);
            int b = Color.blue(color);

            ColorMatrix cm = new ColorMatrix();
            ColorMatrix tmp = new ColorMatrix();

            cm.setRGB2YUV();
            tmp.setRotate(0, deg);
            cm.postConcat(tmp);
            tmp.setYUV2RGB();
            cm.postConcat(tmp);

            final float[] a = cm.getArray();

            int ir = floatToByte(a[0] * r +  a[1] * g +  a[2] * b);
            int ig = floatToByte(a[5] * r +  a[6] * g +  a[7] * b);
            int ib = floatToByte(a[10] * r + a[11] * g + a[12] * b);

            return Color.argb(Color.alpha(color), pinToByte(ir),
                              pinToByte(ig), pinToByte(ib));
        }

        private static final float PI = 3.1415926f;

        @Override
        public boolean onTouchEvent(MotionEvent event)
        {
            float x = event.getX() - CENTER_X;
            float y = event.getY() - CENTER_Y;
            boolean inCenter = java.lang.Math.sqrt(x*x + y*y) <= CENTER_RADIUS;

            switch (event.getAction())
            {
                case MotionEvent.ACTION_DOWN:
                    mTrackingCenter = inCenter;
                    if (inCenter)
                    {
                        mHighlightCenter = true;
                        invalidate();
                        break;
                    }
                case MotionEvent.ACTION_MOVE:
                    if (mTrackingCenter)
                    {
                        if (mHighlightCenter != inCenter)
                        {
                            mHighlightCenter = inCenter;
                            invalidate();
                        }
                    }
                    else
                    {
                        float angle = (float)java.lang.Math.atan2(y, x);
                        // need to turn angle [-PI ... PI] into unit [0....1]
                        float unit = angle/(2*PI);
                        if (unit < 0)
                        {
                            unit += 1;
                        }
                        mCenterPaint.setColor(interpColor(mColors, unit));
                        invalidate();
                    }
                    break;
                case MotionEvent.ACTION_UP:
                    if (mTrackingCenter)
                    {
                        if (inCenter)
                        {
                            mListener.colorChanged(mCenterPaint.getColor());
                        }
                        mTrackingCenter = false;    // so we draw w/o halo
                        invalidate();
                    }
                    // Hack to _Always change the center color for now
                    mListener.colorChanged(mCenterPaint.getColor());
                    break;
            }
            return true;
        }
    }

    public ColorPickerDialog(Context context,
                             OnColorChangedListener listener,
                             int initialColor)
    {
        super(context);

        mListener = listener;
        mInitialColor = initialColor;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        OnColorChangedListener l = new OnColorChangedListener()
        {
            public void colorChanged(int color)
            {
                mListener.colorChanged(color);
                dismiss();
            }
        };

        setContentView(new ColorPickerView(getContext(), l, mInitialColor));
        setTitle(getContext().getString(R.string.choose_color_title));
    }
}
",True,92,8,44,0,0,2,0,L1
49,com.fsck.k9.activity.K9PreferenceActivity.java,"package com.fsck.k9.activity;

import com.fsck.k9.K9;
import android.os.Bundle;
import android.preference.PreferenceActivity;



public class K9PreferenceActivity extends PreferenceActivity
{
    @Override
    public void onCreate(Bundle icicle)
    {
        K9Activity.setLanguage(this, K9.getK9Language());
        setTheme(K9.getK9Theme());
        super.onCreate(icicle);
    }


}
",False,216,0,0,9,58,4,2,L1
50,com.fsck.k9.activity.MessageList.java,"package com.fsck.k9.activity;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Color;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.text.Spannable;
import android.text.SpannableStringBuilder;
import android.text.style.ForegroundColorSpan;
import android.text.style.StyleSpan;
import android.util.Log;
import android.util.TypedValue;
import android.view.ContextMenu;
import android.view.GestureDetector;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.View.OnClickListener;
import android.widget.AdapterView;
import android.widget.BaseAdapter;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.ImageButton;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.CompoundButton.OnCheckedChangeListener;

import com.fsck.k9.Account;
import com.fsck.k9.AccountStats;
import com.fsck.k9.FontSizes;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.SearchSpecification;
import com.fsck.k9.activity.setup.AccountSettings;
import com.fsck.k9.activity.setup.FolderSettings;
import com.fsck.k9.activity.setup.Prefs;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.controller.MessagingController.SORT_TYPE;
import com.fsck.k9.helper.MessageHelper;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;

/**
 * MessageList is the primary user interface for the program. This Activity
 * shows a list of messages.
 * From this Activity the user can perform all standard message operations.
 */
public class MessageList
        extends K9Activity
        implements OnClickListener, AdapterView.OnItemClickListener
{

    /**
     * Reverses the result of a {@link Comparator}.
     * 
     * @param <T>
     */
    public static class ReverseComparator<T> implements Comparator<T>
    {
        private Comparator<T> mDelegate;

        /**
         * @param delegate
         *            Never <code>null</code>.
         */
        public ReverseComparator(final Comparator<T> delegate)
        {
            mDelegate = delegate;
        }

        @Override
        public int compare(final T object1, final T object2)
        {
            // arg1 & 2 are mixed up, this is done on purpose
            return mDelegate.compare(object2, object1);
        }

    }

    /**
     * Chains comparator to find a non-0 result.
     * 
     * @param <T>
     */
    public static class ComparatorChain<T> implements Comparator<T>
    {

        private List<Comparator<T>> mChain;

        /**
         * @param chain
         *            Comparator chain. Never <code>null</code>.
         */
        public ComparatorChain(final List<Comparator<T>> chain)
        {
            mChain = chain;
        }

        @Override
        public int compare(T object1, T object2)
        {
            int result = 0;
            for (final Comparator<T> comparator : mChain)
            {
                result = comparator.compare(object1, object2);
                if (result != 0)
                {
                    break;
                }
            }
            return result;
        }
        
    }

    public static class AttachmentComparator implements Comparator<MessageInfoHolder>
    {

        @Override
        public int compare(MessageInfoHolder object1, MessageInfoHolder object2)
        {
            return (object1.hasAttachments ? 0 : 1) - (object2.hasAttachments ? 0 : 1);
        }

    }

    public static class FlaggedComparator implements Comparator<MessageInfoHolder>
    {

        @Override
        public int compare(MessageInfoHolder object1, MessageInfoHolder object2)
        {
            return (object1.flagged ? 0 : 1) - (object2.flagged ? 0 : 1);
        }

    }

    public static class UnreadComparator implements Comparator<MessageInfoHolder>
    {

        @Override
        public int compare(MessageInfoHolder object1, MessageInfoHolder object2)
        {
            return (object1.read ? 1 : 0) - (object2.read ? 1 : 0);
        }

    }

    public static class SenderComparator implements Comparator<MessageInfoHolder>
    {

        @Override
        public int compare(MessageInfoHolder object1, MessageInfoHolder object2)
        {
            return object1.compareCounterparty.toLowerCase().compareTo(object2.compareCounterparty.toLowerCase());
        }

    }

    public static class DateComparator implements Comparator<MessageInfoHolder>
    {

        @Override
        public int compare(MessageInfoHolder object1, MessageInfoHolder object2)
        {
            return object1.compareDate.compareTo(object2.compareDate);
        }

    }

    public static class SubjectComparator implements Comparator<MessageInfoHolder>
    {

        @Override
        public int compare(MessageInfoHolder arg0, MessageInfoHolder arg1)
        {
            // XXX doesn't respect the Comparator contract since it alters the compared object
            if (arg0.compareSubject == null)
            {
                arg0.compareSubject = Utility.stripSubject(arg0.subject);
            }
            if (arg1.compareSubject == null)
            {
                arg1.compareSubject = Utility.stripSubject(arg1.subject);
            }
            return arg0.compareSubject.compareToIgnoreCase(arg1.compareSubject);
        }

    }

    /**
     * Immutable empty {@link Message} array
     */
    private static final Message[] EMPTY_MESSAGE_ARRAY = new Message[0];

    private static final int DIALOG_MARK_ALL_AS_READ = 1;

    private static final int ACTIVITY_CHOOSE_FOLDER_MOVE = 1;
    private static final int ACTIVITY_CHOOSE_FOLDER_COPY = 2;
    private static final int ACTIVITY_CHOOSE_FOLDER_MOVE_BATCH = 3;
    private static final int ACTIVITY_CHOOSE_FOLDER_COPY_BATCH = 4;

    private static final String EXTRA_ACCOUNT = ""account"";
    private static final String EXTRA_FOLDER  = ""folder"";
    private static final String EXTRA_QUERY = ""query"";
    private static final String EXTRA_QUERY_FLAGS = ""queryFlags"";
    private static final String EXTRA_FORBIDDEN_FLAGS = ""forbiddenFlags"";
    private static final String EXTRA_INTEGRATE = ""integrate"";
    private static final String EXTRA_ACCOUNT_UUIDS = ""accountUuids"";
    private static final String EXTRA_FOLDER_NAMES = ""folderNames"";
    private static final String EXTRA_TITLE = ""title"";
    private static final String EXTRA_LIST_POSITION = ""listPosition"";

    /**
     * Maps a {@link SORT_TYPE} to a {@link Comparator} implementation.
     */
    private static final Map<SORT_TYPE, Comparator<MessageInfoHolder>> SORT_COMPARATORS;

    static
    {
        // fill the mapping at class time loading

        final Map<SORT_TYPE, Comparator<MessageInfoHolder>> map = new EnumMap<SORT_TYPE, Comparator<MessageInfoHolder>>(SORT_TYPE.class);
        map.put(SORT_TYPE.SORT_ATTACHMENT, new AttachmentComparator());
        map.put(SORT_TYPE.SORT_DATE, new DateComparator());
        map.put(SORT_TYPE.SORT_FLAGGED, new FlaggedComparator());
        map.put(SORT_TYPE.SORT_SENDER, new SenderComparator());
        map.put(SORT_TYPE.SORT_SUBJECT, new SubjectComparator());
        map.put(SORT_TYPE.SORT_UNREAD, new UnreadComparator());

        // make it immutable to prevent accidental alteration (content is immutable already)
        SORT_COMPARATORS = Collections.unmodifiableMap(map);
    }

    private ListView mListView;

    private boolean mTouchView = true;

    private MessageListAdapter mAdapter;

    private FolderInfoHolder mCurrentFolder;

    private LayoutInflater mInflater;

    private MessagingController mController;

    private Account mAccount;
    private int mUnreadMessageCount = 0;

    private GestureDetector gestureDetector;
    private View.OnTouchListener gestureListener;
    /**
     * Stores the name of the folder that we want to open as soon as possible
     * after load.
     */
    private String mFolderName;

    /**
     * If we're doing a search, this contains the query string.
     */
    private String mQueryString;
    private Flag[] mQueryFlags = null;
    private Flag[] mForbiddenFlags = null;
    private boolean mIntegrate = false;
    private String[] mAccountUuids = null;
    private String[] mFolderNames = null;
    private String mTitle;

    private MessageListHandler mHandler = new MessageListHandler();

    private SORT_TYPE sortType = SORT_TYPE.SORT_DATE;

    private boolean sortAscending = true;
    private boolean sortDateAscending = false;

    private boolean mStars = true;
    private boolean mCheckboxes = true;
    private int mSelectedCount = 0;

    private View mBatchButtonArea;
    private ImageButton mBatchReadButton;
    private ImageButton mBatchDeleteButton;
    private ImageButton mBatchFlagButton;
    private ImageButton mBatchDoneButton;

    private FontSizes mFontSizes = K9.getFontSizes();

    private Bundle mState = null;
    private MessageInfoHolder mSelectedMessage = null;

    private Context context = null;

    /* package visibility for faster inner class access */ MessageHelper mMessageHelper = MessageHelper.getInstance(this);

    class MessageListHandler
    {
        public void removeMessage(final List<MessageInfoHolder> messages)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    for (MessageInfoHolder message : messages)
                    {
                        if (message != null)
                        {
                            if (mFolderName == null || (message.folder != null && message.folder.name.equals(mFolderName)))
                            {
                                if (message.selected && mSelectedCount > 0)
                                {
                                    mSelectedCount--;
                                }
                                mAdapter.messages.remove(message);
                            }
                        }
                    }
                    resetUnreadCountOnThread();

                    mAdapter.notifyDataSetChanged();
                    toggleBatchButtons();
                }
            });
        }

        public void addMessages(final List<MessageInfoHolder> messages)
        {
            final boolean wasEmpty = mAdapter.messages.isEmpty();
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    for (final MessageInfoHolder message : messages)
                    {
                        if (mFolderName == null || (message.folder != null && message.folder.name.equals(mFolderName)))
                        {
                            int index;
                            synchronized (mAdapter.messages)
                            {
                                index = Collections.binarySearch(mAdapter.messages, message, getComparator());
                            }

                            if (index < 0)
                            {
                                index = (index * -1) - 1;
                            }

                            mAdapter.messages.add(index, message);
                        }
                    }

                    if (wasEmpty)
                    {
                        mListView.setSelection(0);
                    }
                    resetUnreadCountOnThread();

                    mAdapter.notifyDataSetChanged();
                }
            });
        }

        private void resetUnreadCount()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    resetUnreadCountOnThread();
                }
            });
        }

        private void resetUnreadCountOnThread()
        {
            if (mQueryString != null)
            {
                int unreadCount = 0;
                synchronized (mAdapter.messages)
                {
                    for (MessageInfoHolder holder : mAdapter.messages)
                    {
                        unreadCount += holder.read ? 0 : 1;
                    }
                }
                mUnreadMessageCount = unreadCount;
                refreshTitleOnThread();
            }
        }

        private void sortMessages()
        {
            final Comparator<MessageInfoHolder> chainComparator = getComparator();

            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    synchronized (mAdapter.messages)
                    {
                        Collections.sort(mAdapter.messages, chainComparator);
                    }
                    mAdapter.notifyDataSetChanged();
                }
            });
        }

        /**
         * @return The comparator to use to display messages in an ordered
         *         fashion. Never <code>null</code>.
         */
        protected Comparator<MessageInfoHolder> getComparator()
        {
            final List<Comparator<MessageInfoHolder>> chain = new ArrayList<Comparator<MessageInfoHolder>>(2 /* we add 2 comparators at most */ );

            {
                // add the specified comparator
                final Comparator<MessageInfoHolder> comparator = SORT_COMPARATORS.get(sortType);
                if (sortAscending)
                {
                    chain.add(comparator);
                }
                else
                {
                    chain.add(new ReverseComparator<MessageInfoHolder>(comparator));
                }
            }

            {
                // add the date comparator if not already specified
                if (sortType != SORT_TYPE.SORT_DATE)
                {
                    final Comparator<MessageInfoHolder> comparator = SORT_COMPARATORS.get(SORT_TYPE.SORT_DATE);
                    if (sortDateAscending)
                    {
                        chain.add(comparator);
                    }
                    else
                    {
                        chain.add(new ReverseComparator<MessageInfoHolder>(comparator));
                    }
                }
            }

            // build the comparator chain
            final Comparator<MessageInfoHolder> chainComparator = new ComparatorChain<MessageInfoHolder>(chain);

            return chainComparator;
        }

        public void folderLoading(String folder, boolean loading)
        {
            if (mCurrentFolder != null && mCurrentFolder.name.equals(folder))
            {
                mCurrentFolder.loading = loading;
            }
        }

        private void refreshTitle()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    refreshTitleOnThread();
                }
            });
        }

        private void refreshTitleOnThread()
        {
            setWindowTitle();
            setWindowProgress();
        }

        private void setWindowProgress()
        {
            int level = Window.PROGRESS_END;

            if (mCurrentFolder != null && mCurrentFolder.loading && mAdapter.mListener.getFolderTotal() > 0)
            {
                int divisor = mAdapter.mListener.getFolderTotal();
                if (divisor != 0)
                {
                    level = (Window.PROGRESS_END / divisor) * (mAdapter.mListener.getFolderCompleted()) ;
                    if (level > Window.PROGRESS_END)
                    {
                        level = Window.PROGRESS_END;
                    }
                }
            }

            getWindow().setFeatureInt(Window.FEATURE_PROGRESS, level);
        }

        private void setWindowTitle()
        {
            String displayName;

            if (mFolderName != null)
            {
                displayName  = mFolderName;

                if (K9.INBOX.equalsIgnoreCase(displayName))
                {
                    displayName = getString(R.string.special_mailbox_name_inbox);
                }

                String dispString = mAdapter.mListener.formatHeader(MessageList.this, getString(R.string.message_list_title, mAccount.getDescription(), displayName), mUnreadMessageCount, getTimeFormat());
                setTitle(dispString);
            }
            else if (mQueryString != null)
            {
                if (mTitle != null)
                {
                    String dispString = mAdapter.mListener.formatHeader(MessageList.this, mTitle, mUnreadMessageCount, getTimeFormat());
                    setTitle(dispString);
                }
                else
                {
                    setTitle(getString(R.string.search_results) + "": ""+ mQueryString);
                }
            }
        }

        public void progress(final boolean progress)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    showProgressIndicator(progress);
                }
            });
        }
    }

    public static void actionHandleFolder(Context context, Account account, String folder)
    {
        Intent intent = actionHandleFolderIntent(context,account,folder);
        context.startActivity(intent);
    }

    public static Intent actionHandleFolderIntent(Context context, Account account, String folder)
    {
        Intent intent = new Intent(context, MessageList.class);
        intent.putExtra(EXTRA_ACCOUNT, account.getUuid());

        if (folder != null)
        {
            intent.putExtra(EXTRA_FOLDER, folder);
        }
        return intent;
    }

    public static void actionHandle(Context context, String title, String queryString, boolean integrate, Flag[] flags, Flag[] forbiddenFlags)
    {
        Intent intent = new Intent(context, MessageList.class);
        intent.putExtra(EXTRA_QUERY, queryString);
        if (flags != null)
        {
            intent.putExtra(EXTRA_QUERY_FLAGS, Utility.combine(flags, ','));
        }
        if (forbiddenFlags != null)
        {
            intent.putExtra(EXTRA_FORBIDDEN_FLAGS, Utility.combine(forbiddenFlags, ','));
        }
        intent.putExtra(EXTRA_INTEGRATE, integrate);
        intent.putExtra(EXTRA_TITLE, title);
        context.startActivity(intent);
    }

    public static void actionHandle(Context context, String title, SearchSpecification searchSpecification)
    {
        Intent intent = new Intent(context, MessageList.class);
        intent.putExtra(EXTRA_QUERY, searchSpecification.getQuery());
        if (searchSpecification.getRequiredFlags() != null)
        {
            intent.putExtra(EXTRA_QUERY_FLAGS, Utility.combine(searchSpecification.getRequiredFlags(), ','));
        }
        if (searchSpecification.getForbiddenFlags() != null)
        {
            intent.putExtra(EXTRA_FORBIDDEN_FLAGS, Utility.combine(searchSpecification.getForbiddenFlags(), ','));
        }
        intent.putExtra(EXTRA_INTEGRATE, searchSpecification.isIntegrate());
        intent.putExtra(EXTRA_ACCOUNT_UUIDS, searchSpecification.getAccountUuids());
        intent.putExtra(EXTRA_FOLDER_NAMES, searchSpecification.getFolderNames());
        intent.putExtra(EXTRA_TITLE, title);
        context.startActivity(intent);
    }

    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position, long id)
    {
        if (mCurrentFolder != null && ((position+1) == mAdapter.getCount()))
        {
            mController.loadMoreMessages(mAccount, mFolderName, mAdapter.mListener);
            return;
        }

        MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(position);
        if (mSelectedCount > 0)
        {
            // In multiselect mode make sure that clicking on the item results
            // in toggling the 'selected' checkbox.
            setSelected(message, !message.selected);
        }
        else
        {
            onOpenMessage(message);
        }
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        context=this;
        super.onCreate(savedInstanceState);

        mInflater = getLayoutInflater();
        initializeLayout();
        onNewIntent(getIntent());
    }

    @Override
    public void onNewIntent(Intent intent)
    {
        setIntent(intent); // onNewIntent doesn't autoset our ""internal"" intent

        // Only set ""touchable"" when we're first starting up the activity.
        // Otherwise we get force closes when the user toggles it midstream.
        mTouchView = K9.messageListTouchable();

        String accountUuid = intent.getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mFolderName = intent.getStringExtra(EXTRA_FOLDER);
        mQueryString = intent.getStringExtra(EXTRA_QUERY);

        String queryFlags = intent.getStringExtra(EXTRA_QUERY_FLAGS);
        if (queryFlags != null)
        {
            String[] flagStrings = queryFlags.split("","");
            mQueryFlags = new Flag[flagStrings.length];
            for (int i = 0; i < flagStrings.length; i++)
            {
                mQueryFlags[i] = Flag.valueOf(flagStrings[i]);
            }
        }
        String forbiddenFlags = intent.getStringExtra(EXTRA_FORBIDDEN_FLAGS);
        if (forbiddenFlags != null)
        {
            String[] flagStrings = forbiddenFlags.split("","");
            mForbiddenFlags = new Flag[flagStrings.length];
            for (int i = 0; i < flagStrings.length; i++)
            {
                mForbiddenFlags[i] = Flag.valueOf(flagStrings[i]);
            }
        }
        mIntegrate = intent.getBooleanExtra(EXTRA_INTEGRATE, false);
        mAccountUuids = intent.getStringArrayExtra(EXTRA_ACCOUNT_UUIDS);
        mFolderNames = intent.getStringArrayExtra(EXTRA_FOLDER_NAMES);
        mTitle = intent.getStringExtra(EXTRA_TITLE);

        // Take the initial folder into account only if we are *not* restoring
        // the activity already.
        if (mFolderName == null && mQueryString == null)
        {
            mFolderName = mAccount.getAutoExpandFolderName();
        }

        mAdapter = new MessageListAdapter();
        final Object previousData = getLastNonConfigurationInstance();

        if (previousData != null)
        {
            //noinspection unchecked
            mAdapter.messages.addAll((List<MessageInfoHolder>) previousData);
        }

        if (mFolderName != null)
        {
            mCurrentFolder = mAdapter.getFolder(mFolderName, mAccount);
        }

        mController = MessagingController.getInstance(getApplication());
        mListView.setAdapter(mAdapter);
    }

    @Override
    public void onPause()
    {
        super.onPause();
        mController.removeListener(mAdapter.mListener);
        saveListState();
    }

    public void saveListState()
    {
        mState = new Bundle();
        mState.putInt(EXTRA_LIST_POSITION, mListView.getSelectedItemPosition());
    }

    public void restoreListState()
    {
        if (mState == null)
        {
            return;
        }

        int pos = mState.getInt(EXTRA_LIST_POSITION, ListView.INVALID_POSITION);

        if (pos >= mListView.getCount())
        {
            pos = mListView.getCount() - 1;
        }

        if (pos == ListView.INVALID_POSITION)
        {
            mListView.setSelected(false);
        }
        else
        {
            mListView.setSelection(pos);
        }
    }

    /**
     * On resume we refresh messages for the folder that is currently open.
     * This guarantees that things like unread message count and read status
     * are updated.
     */
    @Override
    public void onResume()
    {
        super.onResume();

        mStars = K9.messageListStars();
        mCheckboxes = K9.messageListCheckboxes();

        sortType = mController.getSortType();
        sortAscending = mController.isSortAscending(sortType);
        sortDateAscending = mController.isSortAscending(SORT_TYPE.SORT_DATE);

        mController.addListener(mAdapter.mListener);
        mAdapter.messages.clear();
        mAdapter.notifyDataSetChanged();

        if (mFolderName != null)
        {
            mController.listLocalMessages(mAccount, mFolderName,  mAdapter.mListener);
            mController.notifyAccountCancel(this, mAccount);

            MessagingController.getInstance(getApplication()).notifyAccountCancel(this, mAccount);

            mController.getFolderUnreadMessageCount(mAccount, mFolderName, mAdapter.mListener);
        }
        else if (mQueryString != null)
        {
            mController.searchLocalMessages(mAccountUuids, mFolderNames, null, mQueryString, mIntegrate, mQueryFlags, mForbiddenFlags, mAdapter.mListener);
        }

        mHandler.refreshTitle();

        restoreListState();
    }

    private void initializeLayout()
    {
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        requestWindowFeature(Window.FEATURE_PROGRESS);
        setContentView(R.layout.message_list);

        mListView = (ListView) findViewById(R.id.message_list);
        mListView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_INSET);
        mListView.setLongClickable(true);
        mListView.setFastScrollEnabled(true);
        mListView.setScrollingCacheEnabled(true);
        mListView.setOnItemClickListener(this);

        registerForContextMenu(mListView);

        mBatchButtonArea = findViewById(R.id.batch_button_area);
        mBatchReadButton = (ImageButton) findViewById(R.id.batch_read_button);
        mBatchReadButton.setOnClickListener(this);
        mBatchDeleteButton = (ImageButton) findViewById(R.id.batch_delete_button);
        mBatchDeleteButton.setOnClickListener(this);
        mBatchFlagButton = (ImageButton) findViewById(R.id.batch_flag_button);
        mBatchFlagButton.setOnClickListener(this);
        mBatchDoneButton = (ImageButton) findViewById(R.id.batch_done_button);

        mBatchDoneButton.setOnClickListener(this);

        // Gesture detection
        gestureDetector = new GestureDetector(new MyGestureDetector());
        gestureListener = new View.OnTouchListener()
        {
            public boolean onTouch(View v, MotionEvent event)
            {
                if (gestureDetector.onTouchEvent(event))
                {
                    return true;
                }
                return false;
            }
        };

        mListView.setOnTouchListener(gestureListener);
    }

    @Override
    public Object onRetainNonConfigurationInstance()
    {
        return mAdapter.messages;
    }

    @Override
    public void onBackPressed()
    {
        // This will be called either automatically for you on 2.0
        // or later, or by the code above on earlier versions of the
        // platform.
        if (K9.manageBack())
        {
            if (mQueryString == null)
            {
                onShowFolderList();
            }
            else
            {
                onAccounts();
            }
        }
        else
        {
            finish();
        }
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (
            // XXX TODO - when we go to android 2.0, uncomment this
            // android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.ECLAIR &&
            keyCode == KeyEvent.KEYCODE_BACK
            && event.getRepeatCount() == 0
        )
        {
            // Take care of calling this method on earlier versions of
            // the platform where it doesn't exist.
            onBackPressed();
            return true;
        }

        // Shortcuts that work no matter what is selected
        switch (keyCode)
        {

                // messagelist is actually a K9Activity, not a K9ListActivity
                // This saddens me greatly, but to support volume key navigation
                // in MessageView, we implement this bit of wrapper code
            case KeyEvent.KEYCODE_VOLUME_UP:
            {
                if (K9.useVolumeKeysForListNavigationEnabled())
                {
                    int currentPosition = mListView.getSelectedItemPosition();
                    if (currentPosition == AdapterView.INVALID_POSITION || mListView.isInTouchMode())
                    {
                        currentPosition = mListView.getFirstVisiblePosition();
                    }
                    if (currentPosition > 0)
                    {
                        mListView.setSelection(currentPosition - 1);
                    }
                    return true;
                }
                return false;
            }
            case KeyEvent.KEYCODE_VOLUME_DOWN:
            {
                if (K9.useVolumeKeysForListNavigationEnabled())
                {
                    int currentPosition = mListView.getSelectedItemPosition();
                    if (currentPosition == AdapterView.INVALID_POSITION || mListView.isInTouchMode())
                    {
                        currentPosition = mListView.getFirstVisiblePosition();
                    }
                    
                    if (currentPosition < mListView.getCount())
                    {
                        mListView.setSelection(currentPosition + 1);
                    }
                    return true;
                }
                return false;
            }
            case KeyEvent.KEYCODE_DPAD_LEFT:
            {
                if (mBatchButtonArea.hasFocus())
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            {
                if (mBatchButtonArea.hasFocus())
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }
            case KeyEvent.KEYCODE_C:
            {
                onCompose();
                return true;
            }
            case KeyEvent.KEYCODE_Q:
            {
                onShowFolderList();
                return true;
            }
            case KeyEvent.KEYCODE_O:
            {
                onCycleSort();
                return true;
            }
            case KeyEvent.KEYCODE_I:
            {
                onToggleSortAscending();
                return true;
            }
            case KeyEvent.KEYCODE_H:
            {
                Toast toast = Toast.makeText(this, R.string.message_list_help_key, Toast.LENGTH_LONG);
                toast.show();
                return true;
            }
        }

        int position = mListView.getSelectedItemPosition();
        try
        {
            if (position >= 0)
            {
                MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(position);

                if (message != null)
                {
                    switch (keyCode)
                    {
                        case KeyEvent.KEYCODE_DEL:
                        {
                            onDelete(message, position);
                            return true;
                        }
                        case KeyEvent.KEYCODE_S:
                        {
                            setSelected(message, !message.selected);
                            return true;
                        }
                        case KeyEvent.KEYCODE_D:
                        {
                            onDelete(message, position);
                            return true;
                        }
                        case KeyEvent.KEYCODE_F:
                        {
                            onForward(message);
                            return true;
                        }
                        case KeyEvent.KEYCODE_A:
                        {
                            onReplyAll(message);
                            return true;
                        }
                        case KeyEvent.KEYCODE_R:
                        {
                            onReply(message);
                            return true;
                        }
                        case KeyEvent.KEYCODE_G:
                        {
                            onToggleFlag(message);
                            return true;
                        }
                        case KeyEvent.KEYCODE_M:
                        {
                            onMove(message);
                            return true;
                        }
                        case KeyEvent.KEYCODE_V:
                        {
                            onArchive(message);
                            return true;
                        }
                        case KeyEvent.KEYCODE_Y:
                        {
                            onCopy(message);
                            return true;
                        }
                        case KeyEvent.KEYCODE_Z:
                        {
                            onToggleRead(message);
                            return true;
                        }
                    }
                }
            }
        }
        finally
        {
            return super.onKeyDown(keyCode, event);
        }

    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event)
    {
        // Swallow these events too to avoid the audible notification of a volume change
        if (K9.useVolumeKeysForListNavigationEnabled())
        {
            if ((keyCode == KeyEvent.KEYCODE_VOLUME_UP) || (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN))
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""Swallowed key up."");
                return true;
            }
        }
        return super.onKeyUp(keyCode,event);
    }


    private void onOpenMessage(MessageInfoHolder message)
    {
        if (message.folder.name.equals(message.message.getFolder().getAccount().getDraftsFolderName()))
        {
            MessageCompose.actionEditDraft(this, message.message.getFolder().getAccount(), message.message);
        }
        else
        {
            // Need to get the list before the sort starts
            ArrayList<MessageReference> messageRefs = new ArrayList<MessageReference>();

            synchronized (mAdapter.messages)
            {
                for (MessageInfoHolder holder : mAdapter.messages)
                {
                    MessageReference ref = holder.message.makeMessageReference();
                    messageRefs.add(ref);
                }
            }
            MessageReference ref = message.message.makeMessageReference();
            Log.i(K9.LOG_TAG, ""MessageList sending message "" + ref);

            MessageView.actionView(this, ref, messageRefs);
        }

        /*
         * We set read=true here for UI performance reasons. The actual value
         * will get picked up on the refresh when the Activity is resumed but
         * that may take a second or so and we don't want this to show and
         * then go away. I've gone back and forth on this, and this gives a
         * better UI experience, so I am putting it back in.
         */
        if (!message.read)
        {
            message.read = true;
        }
    }

    private void onAccounts()
    {
        Accounts.listAccounts(this);
        finish();
    }

    private void onShowFolderList()
    {
        FolderList.actionHandleAccount(this, mAccount);
        finish();
    }

    private void onCompose()
    {
        if (mQueryString != null)
        {
            /*
             * If we have a query string, we don't have an account to let
             * compose start the default action.
             */
            MessageCompose.actionCompose(this, null);
        }
        else
        {
            MessageCompose.actionCompose(this, mAccount);
        }
    }

    private void onEditPrefs()
    {
        Prefs.actionPrefs(this);
    }

    private void onEditAccount()
    {
        AccountSettings.actionSettings(this, mAccount);
    }

    private void changeSort(SORT_TYPE newSortType)
    {
        if (sortType == newSortType)
        {
            onToggleSortAscending();
        }
        else
        {
            sortType = newSortType;
            mController.setSortType(sortType);
            sortAscending = mController.isSortAscending(sortType);
            sortDateAscending = mController.isSortAscending(SORT_TYPE.SORT_DATE);
            reSort();
        }
    }

    private void reSort()
    {
        int toastString = sortType.getToast(sortAscending);

        Toast toast = Toast.makeText(this, toastString, Toast.LENGTH_SHORT);
        toast.show();

        mHandler.sortMessages();
    }

    private void onCycleSort()
    {
        SORT_TYPE[] sorts = SORT_TYPE.values();
        int curIndex = 0;

        for (int i = 0; i < sorts.length; i++)
        {
            if (sorts[i] == sortType)
            {
                curIndex = i;
                break;
            }
        }

        curIndex++;

        if (curIndex == sorts.length)
        {
            curIndex = 0;
        }

        changeSort(sorts[curIndex]);
    }

    private void onToggleSortAscending()
    {
        mController.setSortAscending(sortType, !sortAscending);

        sortAscending = mController.isSortAscending(sortType);
        sortDateAscending = mController.isSortAscending(SORT_TYPE.SORT_DATE);

        reSort();
    }

    private void onDelete(MessageInfoHolder holder, int position)
    {
        mAdapter.removeMessage(holder);
        mController.deleteMessages(new Message[] { holder.message }, null);
    }

    private void onMove(MessageInfoHolder holder)
    {
        if (!mController.isMoveCapable(holder.message.getFolder().getAccount()))
        {
            return;
        }

        if (!mController.isMoveCapable(holder.message))
        {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }

        final Account account = holder.message.getFolder().getAccount();

        Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, account.getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, holder.folder.name);
        intent.putExtra(ChooseFolder.EXTRA_SEL_FOLDER, account.getLastSelectedFolderName());
        intent.putExtra(ChooseFolder.EXTRA_MESSAGE, holder.message.makeMessageReference());
        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_MOVE);
    }

    private void onArchive(MessageInfoHolder holder)
    {
        if (!mController.isMoveCapable(holder.message.getFolder().getAccount()))
        {
            return;
        }

        if (!mController.isMoveCapable(holder.message))
        {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }

        onMoveChosen(holder, holder.message.getFolder().getAccount().getArchiveFolderName());
    }

    private void onSpam(MessageInfoHolder holder)
    {
        if (!mController.isMoveCapable(holder.message.getFolder().getAccount()))
        {
            return;
        }

        if (!mController.isMoveCapable(holder.message))
        {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }

        onMoveChosen(holder, holder.message.getFolder().getAccount().getSpamFolderName());
    }

    private void onCopy(MessageInfoHolder holder)
    {
        if (!mController.isCopyCapable(holder.message.getFolder().getAccount()))
        {
            return;
        }

        if (!mController.isCopyCapable(holder.message))
        {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }

        final Account account = holder.message.getFolder().getAccount();

        Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, account.getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, holder.folder.name);
        intent.putExtra(ChooseFolder.EXTRA_SEL_FOLDER, account.getLastSelectedFolderName());
        intent.putExtra(ChooseFolder.EXTRA_MESSAGE, holder.message.makeMessageReference());
        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_COPY);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        if (resultCode != RESULT_OK)
            return;

        switch (requestCode)
        {
            case ACTIVITY_CHOOSE_FOLDER_MOVE:
            case ACTIVITY_CHOOSE_FOLDER_COPY:
            {
                if (data == null)
                    return;

                final String destFolderName = data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER);
                final MessageReference ref = (MessageReference)data.getSerializableExtra(ChooseFolder.EXTRA_MESSAGE);
                final MessageInfoHolder m = mAdapter.getMessage(ref);

                if ((destFolderName != null) && (m != null))
                {
                    final Account account = m.message.getFolder().getAccount();

                    account.setLastSelectedFolderName(destFolderName);

                    switch (requestCode)
                    {
                        case ACTIVITY_CHOOSE_FOLDER_MOVE:
                            onMoveChosen(m, destFolderName);
                            break;

                        case ACTIVITY_CHOOSE_FOLDER_COPY:
                            onCopyChosen(m, destFolderName);
                            break;
                    }
                }
                break;
            }
            case ACTIVITY_CHOOSE_FOLDER_MOVE_BATCH:
            case ACTIVITY_CHOOSE_FOLDER_COPY_BATCH:
            {
                final String destFolderName = data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER);
                final String accountUuid = data.getStringExtra(ChooseFolder.EXTRA_ACCOUNT);
                final Account account = Preferences.getPreferences(this).getAccount(accountUuid);

                account.setLastSelectedFolderName(destFolderName);

                switch (requestCode)
                {
                    case ACTIVITY_CHOOSE_FOLDER_MOVE_BATCH:
                        onMoveChosenBatch(destFolderName);
                        break;

                    case ACTIVITY_CHOOSE_FOLDER_COPY_BATCH:
                        onCopyChosenBatch(destFolderName);
                        break;
                }
            }
        }
    }

    private void onMoveChosen(MessageInfoHolder holder, String folderName)
    {
        if (mController.isMoveCapable(holder.message.getFolder().getAccount()) && folderName != null)
        {
            if (K9.FOLDER_NONE.equalsIgnoreCase(folderName))
            {
                return;
            }
            mAdapter.removeMessage(holder);
            mController.moveMessage(holder.message.getFolder().getAccount(), holder.message.getFolder().getName(), holder.message, folderName, null);
        }
    }

    private void onCopyChosen(MessageInfoHolder holder, String folderName)
    {
        if (mController.isCopyCapable(holder.message.getFolder().getAccount()) && folderName != null)
        {
            mController.copyMessage(holder.message.getFolder().getAccount(),
                                    holder.message.getFolder().getName(), holder.message, folderName, null);
        }
    }

    private void onReply(MessageInfoHolder holder)
    {
        MessageCompose.actionReply(this, holder.message.getFolder().getAccount(), holder.message, false, null);
    }

    private void onReplyAll(MessageInfoHolder holder)
    {
        MessageCompose.actionReply(this, holder.message.getFolder().getAccount(), holder.message, true, null);
    }

    private void onForward(MessageInfoHolder holder)
    {
        MessageCompose.actionForward(this, holder.message.getFolder().getAccount(), holder.message, null);
    }

    private void onMarkAllAsRead(final Account account, final String folder)
    {
        showDialog(DIALOG_MARK_ALL_AS_READ);
    }

    private void onExpunge(final Account account, String folderName)
    {
        mController.expunge(account, folderName, null);
    }

    @Override
    public Dialog onCreateDialog(int id)
    {
        switch (id)
        {
            case DIALOG_MARK_ALL_AS_READ:
                return createMarkAllAsReadDialog();
        }

        return super.onCreateDialog(id);
    }

    @Override
    public void onPrepareDialog(int id, Dialog dialog)
    {
        switch (id)
        {
            case DIALOG_MARK_ALL_AS_READ:
            {
                if (mCurrentFolder != null)
                {
                    ((AlertDialog)dialog).setMessage(getString(R.string.mark_all_as_read_dlg_instructions_fmt,
                                                     mCurrentFolder.displayName));
                }
                break;
            }
            default:
            {
                super.onPrepareDialog(id, dialog);
            }
        }
    }

    private Dialog createMarkAllAsReadDialog()
    {
        return new AlertDialog.Builder(this)
               .setTitle(R.string.mark_all_as_read_dlg_title)
               .setMessage(getString(R.string.mark_all_as_read_dlg_instructions_fmt,
                                     mCurrentFolder.displayName))
               .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_MARK_ALL_AS_READ);

                try
                {
                    mController.markAllMessagesRead(mAccount, mCurrentFolder.name);

                    synchronized (mAdapter.messages)
                    {
                        for (MessageInfoHolder holder : mAdapter.messages)
                        {
                            holder.read = true;
                        }
                    }
                    mHandler.sortMessages();
                }
                catch (Exception e)
                {
                    // Ignore
                }
            }
        })
               .setNegativeButton(R.string.cancel_action, new DialogInterface.OnClickListener()
        {
            public void onClick(DialogInterface dialog, int whichButton)
            {
                dismissDialog(DIALOG_MARK_ALL_AS_READ);
            }
        })
               .create();
    }

    private void onToggleRead(MessageInfoHolder holder)
    {
        mController.setFlag(holder.message.getFolder().getAccount(), holder.message.getFolder().getName(), new String[] { holder.uid }, Flag.SEEN, !holder.read);
        holder.read = !holder.read;
        mHandler.sortMessages();
    }

    private void onToggleFlag(MessageInfoHolder holder)
    {
        mController.setFlag(holder.message.getFolder().getAccount(), holder.message.getFolder().getName(), new String[] { holder.uid }, Flag.FLAGGED, !holder.flagged);
        holder.flagged = !holder.flagged;
        mHandler.sortMessages();
    }

    private void checkMail(Account account, String folderName)
    {
        mController.synchronizeMailbox(account, folderName, mAdapter.mListener, null);
        sendMail(account);
    }

    private void sendMail(Account account)
    {
        mController.sendPendingMessages(account, mAdapter.mListener);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item)
    {
        int itemId = item.getItemId();
        switch (itemId)
        {
            case R.id.compose:
            {
                onCompose();
                return true;
            }
            case R.id.accounts:
            {
                onAccounts();
                return true;
            }
            case R.id.set_sort_date:
            {
                changeSort(SORT_TYPE.SORT_DATE);
                return true;
            }
            case R.id.set_sort_subject:
            {
                changeSort(SORT_TYPE.SORT_SUBJECT);
                return true;
            }
            case R.id.set_sort_sender:
            {
                changeSort(SORT_TYPE.SORT_SENDER);
                return true;
            }
            case R.id.set_sort_flag:
            {
                changeSort(SORT_TYPE.SORT_FLAGGED);
                return true;
            }
            case R.id.set_sort_unread:
            {
                changeSort(SORT_TYPE.SORT_UNREAD);
                return true;
            }
            case R.id.set_sort_attach:
            {
                changeSort(SORT_TYPE.SORT_ATTACHMENT);
                return true;
            }
            case R.id.select_all:
            case R.id.batch_select_all:
            {
                setAllSelected(true);
                toggleBatchButtons();
                return true;
            }
            case R.id.batch_deselect_all:
            {
                setAllSelected(false);
                toggleBatchButtons();
                return true;
            }
            case R.id.batch_delete_op:
            {
                deleteSelected();
                return true;
            }
            case R.id.batch_mark_read_op:
            {
                flagSelected(Flag.SEEN, true);
                return true;
            }
            case R.id.batch_mark_unread_op:
            {
                flagSelected(Flag.SEEN, false);
                return true;
            }
            case R.id.batch_flag_op:
            {
                flagSelected(Flag.FLAGGED, true);
                return true;
            }
            case R.id.batch_unflag_op:
            {
                flagSelected(Flag.FLAGGED, false);
                return true;
            }
            case R.id.settings:
            {
                if (mQueryString == null)
                {
                    break;
                }

                /*
                 * Fall-through in search results view. Otherwise a sub-menu
                 * with only one option would be opened.
                 */
            }
            case R.id.app_settings:
            {
                onEditPrefs();
                return true;
            }
        }

        if (mQueryString != null)
        {
            // None of the options after this point are ""safe"" for search results
            //TODO: This is not true for ""unread"" and ""starred"" searches in regular folders
            return false;
        }

        switch (itemId)
        {
            case R.id.check_mail:
            {
                if (mFolderName != null)
                {
                    checkMail(mAccount, mFolderName);
                }
                return true;
            }
            case R.id.send_messages:
            {
                sendMail(mAccount);
                return true;
            }
            case R.id.list_folders:
            {
                onShowFolderList();
                return true;
            }
            case R.id.mark_all_as_read:
            {
                if (mFolderName != null)
                {
                    onMarkAllAsRead(mAccount, mFolderName);
                }
                return true;
            }
            case R.id.folder_settings:
            {
                if (mFolderName != null)
                {
                    FolderSettings.actionSettings(this, mAccount, mFolderName);
                }
                return true;
            }
            case R.id.account_settings:
            {
                onEditAccount();
                return true;
            }
            case R.id.batch_copy_op:
            {
                onCopyBatch();
                return true;
            }
            case R.id.batch_archive_op:
            {
                onArchiveBatch();
                return true;
            }
            case R.id.batch_spam_op:
            {
                onSpamBatch();
                return true;
            }
            case R.id.batch_move_op:
            {
                onMoveBatch();
                return true;
            }
            case R.id.expunge:
            {
                if (mCurrentFolder != null)
                {
                    onExpunge(mAccount, mCurrentFolder.name);
                }
                return true;
            }
            default:
            {
                return super.onOptionsItemSelected(item);
            }
        }
    }

    private final int[] batch_ops = { R.id.batch_copy_op, R.id.batch_delete_op, R.id.batch_flag_op,
                                      R.id.batch_unflag_op, R.id.batch_mark_read_op, R.id.batch_mark_unread_op,
                                      R.id.batch_archive_op, R.id.batch_spam_op, R.id.batch_move_op,
                                      R.id.batch_select_all, R.id.batch_deselect_all
                                    };

    private void setOpsState(Menu menu, boolean state, boolean enabled)
    {
        for (int id : batch_ops)
        {
            menu.findItem(id).setVisible(state);
            menu.findItem(id).setEnabled(enabled);
        }
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu)
    {
        boolean anySelected = anySelected();

        menu.findItem(R.id.select_all).setVisible(! anySelected);
        menu.findItem(R.id.batch_ops).setVisible(anySelected);

        setOpsState(menu, true, anySelected);

        if (mQueryString != null)
        {
            menu.findItem(R.id.mark_all_as_read).setVisible(false);
            menu.findItem(R.id.list_folders).setVisible(false);
            menu.findItem(R.id.expunge).setVisible(false);
            menu.findItem(R.id.batch_archive_op).setVisible(false);
            menu.findItem(R.id.batch_spam_op).setVisible(false);
            menu.findItem(R.id.batch_move_op).setVisible(false);
            menu.findItem(R.id.batch_copy_op).setVisible(false);
            menu.findItem(R.id.check_mail).setVisible(false);
            menu.findItem(R.id.send_messages).setVisible(false);
        }
        else
        {
            if (mCurrentFolder != null && mCurrentFolder.outbox)
            {
                menu.findItem(R.id.check_mail).setVisible(false);
            }
            else
            {
                menu.findItem(R.id.send_messages).setVisible(false);
            }

            if (mCurrentFolder != null && K9.ERROR_FOLDER_NAME.equals(mCurrentFolder.name))
            {
                menu.findItem(R.id.expunge).setVisible(false);
            }
            if (K9.FOLDER_NONE.equalsIgnoreCase(mAccount.getArchiveFolderName()))
            {
                menu.findItem(R.id.batch_archive_op).setVisible(false);
            }
            if (K9.FOLDER_NONE.equalsIgnoreCase(mAccount.getSpamFolderName()))
            {
                menu.findItem(R.id.batch_spam_op).setVisible(false);
            }
        }

        boolean newFlagState = computeBatchDirection(true);
        boolean newReadState = computeBatchDirection(false);
        menu.findItem(R.id.batch_flag_op).setVisible(newFlagState);
        menu.findItem(R.id.batch_unflag_op).setVisible(!newFlagState);
        menu.findItem(R.id.batch_mark_read_op).setVisible(newReadState);
        menu.findItem(R.id.batch_mark_unread_op).setVisible(!newReadState);
        menu.findItem(R.id.batch_deselect_all).setVisible(anySelected);
        menu.findItem(R.id.batch_select_all).setEnabled(true);

        return true;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu)
    {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.message_list_option, menu);

        return true;
    }

    @Override
    public boolean onContextItemSelected(MenuItem item)
    {
        AdapterContextMenuInfo info = (AdapterContextMenuInfo) item.getMenuInfo();
        MessageInfoHolder holder = mSelectedMessage;
        // don't need this anymore
        mSelectedMessage = null;
        if (holder == null)
        {
            holder = (MessageInfoHolder) mAdapter.getItem(info.position);
        }

        switch (item.getItemId())
        {
            case R.id.open:
            {
                onOpenMessage(holder);
                break;
            }
            case R.id.select:
            {
                setSelected(holder, true);
                break;
            }
            case R.id.deselect:
            {
                setSelected(holder, false);
                break;
            }
            case R.id.delete:
            {
                onDelete(holder, info.position);
                break;
            }
            case R.id.reply:
            {
                onReply(holder);
                break;
            }
            case R.id.reply_all:
            {
                onReplyAll(holder);
                break;
            }
            case R.id.forward:
            {
                onForward(holder);
                break;
            }
            case R.id.mark_as_read:
            {
                onToggleRead(holder);
                break;
            }
            case R.id.flag:
            {
                onToggleFlag(holder);
                break;
            }
            case R.id.archive:
            {
                onArchive(holder);
                break;
            }
            case R.id.spam:
            {
                onSpam(holder);
                break;
            }
            case R.id.move:
            {
                onMove(holder);
                break;
            }
            case R.id.copy:
            {
                onCopy(holder);
                break;
            }
            case R.id.send_alternate:
            {
                onSendAlternate(mAccount, holder);
                break;
            }
            case R.id.same_sender:
            {
                MessageList.actionHandle(MessageList.this,
                                         ""From ""+holder.sender, holder.senderAddress, true,
                                         null, null);
                break;
            }
        }
        return super.onContextItemSelected(item);
    }

    public void onSendAlternate(Account account, MessageInfoHolder holder)
    {
        mController.sendAlternate(this, account, holder.message);
    }

    public void showProgressIndicator(boolean status)
    {
        setProgressBarIndeterminateVisibility(status);
        ProgressBar bar = (ProgressBar)mListView.findViewById(R.id.message_list_progress);
        if (bar == null)
        {
            return;
        }

        bar.setIndeterminate(true);
        if (status)
        {
            bar.setVisibility(ProgressBar.VISIBLE);
        }
        else
        {
            bar.setVisibility(ProgressBar.INVISIBLE);
        }
    }

    class MyGestureDetector extends SimpleOnGestureListener
    {
        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)
        {
            if (e2 == null || e1 == null)
                return true;

            float deltaX = e2.getX() - e1.getX(),
                           deltaY = e2.getY() - e1.getY();

            boolean movedAcross = (Math.abs(deltaX) > Math.abs(deltaY * 4));
            boolean steadyHand = (Math.abs(deltaX / deltaY) > 2);

            if (movedAcross && steadyHand)
            {
                boolean selected = (deltaX > 0);
                int position = mListView.pointToPosition((int)e1.getX(), (int)e1.getY());

                if (position != AdapterView.INVALID_POSITION)
                {
                    MessageInfoHolder msgInfoHolder = (MessageInfoHolder) mAdapter.getItem(position);

                    if (msgInfoHolder != null && msgInfoHolder.selected != selected)
                    {
                        msgInfoHolder.selected = selected;
                        mSelectedCount += (selected ? 1 : -1);
                        mAdapter.notifyDataSetChanged();
                        toggleBatchButtons();
                    }
                }
            }

            return false;
        }
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)
    {
        super.onCreateContextMenu(menu, v, menuInfo);

        AdapterContextMenuInfo info = (AdapterContextMenuInfo) menuInfo;
        MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(info.position);
        // remember which message was originally selected, in case the list changes while the
        // dialog is up
        mSelectedMessage = message;

        if (message == null)
        {
            return;
        }

        getMenuInflater().inflate(R.menu.message_list_context, menu);

        menu.setHeaderTitle((CharSequence) message.subject);

        if (message.read)
        {
            menu.findItem(R.id.mark_as_read).setTitle(R.string.mark_as_unread_action);
        }

        if (message.flagged)
        {
            menu.findItem(R.id.flag).setTitle(R.string.unflag_action);
        }

        Account account = message.message.getFolder().getAccount();
        if (!mController.isCopyCapable(account))
        {
            menu.findItem(R.id.copy).setVisible(false);
        }

        if (!mController.isMoveCapable(account))
        {
            menu.findItem(R.id.move).setVisible(false);
            menu.findItem(R.id.archive).setVisible(false);
            menu.findItem(R.id.spam).setVisible(false);
        }

        if (K9.FOLDER_NONE.equalsIgnoreCase(account.getArchiveFolderName()))
        {
            menu.findItem(R.id.archive).setVisible(false);
        }
        if (K9.FOLDER_NONE.equalsIgnoreCase(account.getSpamFolderName()))
        {
            menu.findItem(R.id.spam).setVisible(false);
        }

        if (message.selected)
        {
            menu.findItem(R.id.select).setVisible(false);
            menu.findItem(R.id.deselect).setVisible(true);
        }
        else
        {
            menu.findItem(R.id.select).setVisible(true);
            menu.findItem(R.id.deselect).setVisible(false);
        }
    }

    class MessageListAdapter extends BaseAdapter
    {
        private final List<MessageInfoHolder> messages = java.util.Collections.synchronizedList(new ArrayList<MessageInfoHolder>());

        private final ActivityListener mListener = new ActivityListener()
        {
            @Override
            public void synchronizeMailboxStarted(Account account, String folder)
            {
                super.synchronizeMailboxStarted(account, folder);

                if (updateForMe(account, folder))
                {
                    mHandler.progress(true);
                    mHandler.folderLoading(folder, true);
                }
                mHandler.refreshTitle();
            }
            @Override
            public void synchronizeMailboxHeadersProgress(Account account, String folder, int completed, int total)
            {
                super.synchronizeMailboxHeadersProgress(account,folder,completed, total);
                mHandler.refreshTitle();
            }

            @Override
            public void synchronizeMailboxHeadersFinished(Account account, String folder,
                    int total, int completed)
            {
                super.synchronizeMailboxHeadersFinished(account,folder, total, completed);
                mHandler.refreshTitle();
            }




            @Override
            public void synchronizeMailboxFinished(Account account, String folder,
                                                   int totalMessagesInMailbox, int numNewMessages)
            {
                super.synchronizeMailboxFinished(account, folder, totalMessagesInMailbox, numNewMessages);

                if (updateForMe(account, folder))
                {
                    mHandler.progress(false);
                    mHandler.folderLoading(folder, false);
                    mHandler.sortMessages();
                }
                mHandler.refreshTitle();
            }

            @Override
            public void synchronizeMailboxFailed(Account account, String folder, String message)
            {
                super.synchronizeMailboxFailed(account, folder, message);

                if (updateForMe(account, folder))
                {
                    mHandler.progress(false);
                    mHandler.folderLoading(folder, false);
                    mHandler.sortMessages();
                }
                mHandler.refreshTitle();
            }

            @Override
            public void sendPendingMessagesStarted(Account account)
            {
                super.sendPendingMessagesStarted(account);
                mHandler.refreshTitle();
            }

            @Override
            public void sendPendingMessagesCompleted(Account account)
            {
                super.sendPendingMessagesCompleted(account);
                mHandler.refreshTitle();
            }

            @Override
            public void sendPendingMessagesFailed(Account account)
            {
                super.sendPendingMessagesFailed(account);
                mHandler.refreshTitle();
            }

            @Override
            public void synchronizeMailboxProgress(Account account, String folder, int completed, int total)
            {
                super.synchronizeMailboxProgress(account, folder, completed, total);
                mHandler.refreshTitle();
            }

            @Override
            public void synchronizeMailboxAddOrUpdateMessage(Account account, String folder, Message message)
            {
                addOrUpdateMessage(account, folder, message, true);
            }

            @Override
            public void synchronizeMailboxRemovedMessage(Account account, String folder,Message message)
            {
                MessageInfoHolder holder = getMessage(message);
                if (holder == null)
                {
                    Log.w(K9.LOG_TAG, ""Got callback to remove non-existent message with UID "" + message.getUid());
                }
                else
                {
                    removeMessage(holder);
                }
            }

            @Override
            public void listLocalMessagesStarted(Account account, String folder)
            {
                if ((mQueryString != null && folder == null) ||
                        (account != null && account.equals(mAccount))
                   )
                {
                    mHandler.progress(true);
                    if (folder != null)
                    {
                        mHandler.folderLoading(folder, true);
                    }
                }
            }

            @Override
            public void listLocalMessagesFailed(Account account, String folder, String message)
            {
                if ((mQueryString != null && folder == null) ||
                        (account != null && account.equals(mAccount)))
                {
                    mHandler.sortMessages();
                    mHandler.progress(false);
                    if (folder != null)
                    {
                        mHandler.folderLoading(folder, false);
                    }
                }
            }

            @Override
            public void listLocalMessagesFinished(Account account, String folder)
            {
                if ((mQueryString != null && folder == null) ||
                        (account != null && account.equals(mAccount)))
                {
                    mHandler.sortMessages();
                    mHandler.progress(false);
                    if (folder != null)
                    {
                        mHandler.folderLoading(folder, false);
                    }
                }
            }

            @Override
            public void listLocalMessagesRemoveMessage(Account account, String folder,Message message)
            {
                MessageInfoHolder holder = getMessage(message);
                if (holder != null)
                {
                    removeMessage(holder);
                }
            }

            @Override
            public void listLocalMessagesAddMessages(Account account, String folder, List<Message> messages)
            {
                addOrUpdateMessages(account, folder, messages, false);
            }

            @Override
            public void listLocalMessagesUpdateMessage(Account account, String folder, Message message)
            {
                addOrUpdateMessage(account, folder, message, false);
            }

            @Override
            public void searchStats(AccountStats stats)
            {
                mUnreadMessageCount = stats.unreadMessageCount;
                mHandler.refreshTitle();
            }

            @Override
            public void folderStatusChanged(Account account, String folder, int unreadMessageCount)
            {
                super.folderStatusChanged(account, folder, unreadMessageCount);
                if (updateForMe(account, folder))
                {
                    mUnreadMessageCount = unreadMessageCount;
                    mHandler.refreshTitle();
                }
            }

            @Override
            public void pendingCommandsProcessing(Account account)
            {
                super.pendingCommandsProcessing(account);
                mHandler.refreshTitle();
            }

            @Override
            public void pendingCommandsFinished(Account account)
            {
                super.pendingCommandsFinished(account);
                mHandler.refreshTitle();
            }

            @Override
            public void pendingCommandStarted(Account account, String commandTitle)
            {
                super.pendingCommandStarted(account, commandTitle);
                mHandler.refreshTitle();
            }

            @Override
            public void pendingCommandCompleted(Account account, String commandTitle)
            {
                super.pendingCommandCompleted(account, commandTitle);
                mHandler.refreshTitle();
            }

            @Override
            public void messageUidChanged(Account account, String folder, String oldUid, String newUid)
            {
                MessageReference ref = new MessageReference();
                ref.accountUuid = account.getUuid();
                ref.folderName = folder;
                ref.uid = oldUid;

                MessageInfoHolder holder = getMessage(ref);
                if (holder != null)
                {
                    holder.uid = newUid;
                    holder.message.setUid(newUid);
                }
            }
        };

        private boolean updateForMe(Account account, String folder)
        {
            if ((account.equals(mAccount) && mFolderName != null && folder.equals(mFolderName)))
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        private Drawable mAttachmentIcon;
        private Drawable mAnsweredIcon;
        private View footerView = null;

        MessageListAdapter()
        {
            mAttachmentIcon = getResources().getDrawable(R.drawable.ic_mms_attachment_small);
            mAnsweredIcon = getResources().getDrawable(R.drawable.ic_mms_answered_small);
        }

        public void removeMessages(List<MessageInfoHolder> holders)
        {
            if (holders != null)
            {
                mHandler.removeMessage(holders);
            }
        }

        public void removeMessage(MessageInfoHolder holder)
        {
            List<MessageInfoHolder> messages = new ArrayList<MessageInfoHolder>();
            messages.add(holder);
            removeMessages(messages);
        }

        private void addOrUpdateMessage(Account account, String folderName, Message message, boolean verifyAgainstSearch)
        {
            List<Message> messages = new ArrayList<Message>();
            messages.add(message);
            addOrUpdateMessages(account, folderName, messages, verifyAgainstSearch);
        }

        private void addOrUpdateMessages(final Account account, final String folderName, final List<Message> providedMessages, final boolean verifyAgainstSearch)
        {
            // we copy the message list because the callback doesn't expect
            // the callbacks to mutate it.
            final List<Message> messages = new ArrayList<Message>(providedMessages);

            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    boolean needsSort = false;
                    final List<MessageInfoHolder> messagesToAdd = new ArrayList<MessageInfoHolder>();
                    List<MessageInfoHolder> messagesToRemove = new ArrayList<MessageInfoHolder>();
                    List<Message> messagesToSearch = new ArrayList<Message>();

                    // cache field into local variable for faster access for JVM without JIT
                    final MessageHelper messageHelper = mMessageHelper;

                    for (Message message : messages)
                    {
                        MessageInfoHolder m = getMessage(message);
                        if (message.isSet(Flag.DELETED))
                        {
                            if (m != null)
                            {
                                messagesToRemove.add(m);
                            }
                        }
                        else
                        {
                            final Folder messageFolder = message.getFolder();
                            final Account messageAccount = messageFolder.getAccount();
                            if (m == null)
                            {
                                if (updateForMe(account, folderName))
                                {
                                    m = new MessageInfoHolder();
                                    messageHelper.populate(m, message, new FolderInfoHolder(MessageList.this, messageFolder, messageAccount), messageAccount);
                                    messagesToAdd.add(m);
                                }
                                else
                                {
                                    if (mQueryString != null)
                                    {
                                        if (verifyAgainstSearch)
                                        {
                                            messagesToSearch.add(message);
                                        }
                                        else
                                        {
                                            m = new MessageInfoHolder();
                                            messageHelper.populate(m, message, new FolderInfoHolder(MessageList.this, messageFolder, messageAccount), messageAccount);
                                            messagesToAdd.add(m);
                                        }
                                    }
                                }
                            }
                            else
                            {
                                messageHelper.populate(m, message, new FolderInfoHolder(MessageList.this, messageFolder, account), account);
                                needsSort = true;
                            }
                        }
                    }

                    if (messagesToSearch.size() > 0)
                    {
                        mController.searchLocalMessages(mAccountUuids, mFolderNames, messagesToSearch.toArray(EMPTY_MESSAGE_ARRAY), mQueryString, mIntegrate, mQueryFlags, mForbiddenFlags,
                                                        new MessagingListener()
                        {
                            @Override
                            public void listLocalMessagesAddMessages(Account account, String folder, List<Message> messages)
                            {
                                addOrUpdateMessages(account, folder, messages, false);
                            }
                        });
                    }

                    if (messagesToRemove.size() > 0)
                    {
                        removeMessages(messagesToRemove);
                    }

                    if (messagesToAdd.size() > 0)
                    {
                        mHandler.addMessages(messagesToAdd);
                    }

                    if (needsSort)
                    {
                        mHandler.sortMessages();
                        mHandler.resetUnreadCount();
                    }
                }
            });
        }
        public MessageInfoHolder getMessage(Message message)
        {
            return getMessage(message.makeMessageReference());
        }

        // XXX TODO - make this not use a for loop
        public MessageInfoHolder getMessage(MessageReference messageReference)
        {
            synchronized (mAdapter.messages)
            {
                for (MessageInfoHolder holder : mAdapter.messages)
                {
                    /*
                     * 2010-06-21 - cketti
                     * Added null pointer check. Not sure what's causing 'holder'
                     * to be null. See log provided in issue 1749, comment #15.
                     *
                     * Please remove this comment once the cause was found and the
                     * bug(?) fixed.
                     */
                    if ((holder != null) && holder.message.equalsReference(messageReference))
                    {
                        return holder;
                    }
                }
            }
            return null;
        }

        public FolderInfoHolder getFolder(String folder, Account account)
        {
            LocalFolder local_folder = null;
            try
            {
                LocalStore localStore = account.getLocalStore();
                local_folder = localStore.getFolder(folder);
                return new FolderInfoHolder(context, (Folder)local_folder, account);
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""getFolder("" + folder + "") goes boom: "",e);
                return null;
            }
            finally
            {
                if (local_folder != null)
                {
                    local_folder.close();
                }
            }
        }

        private static final int NON_MESSAGE_ITEMS = 1;

        private final OnClickListener flagClickListener = new OnClickListener()
        {
            public void onClick(View v)
            {
                // Perform action on clicks
                MessageInfoHolder message = (MessageInfoHolder) getItem((Integer)v.getTag());
                onToggleFlag(message);
            }
        };

        @Override
        public int getCount()
        {
            return messages.size() + NON_MESSAGE_ITEMS;
        }

        @Override
        public long getItemId(int position)
        {
            try
            {
                MessageInfoHolder messageHolder =(MessageInfoHolder) getItem(position);
                if (messageHolder != null)
                {
                    return ((LocalStore.LocalMessage)  messageHolder.message).getId();
                }
            }
            catch (Exception e)
            {
                Log.i(K9.LOG_TAG,""getItemId(""+position+"") "",e);
            }
            return -1;
        }

        public Object getItem(long position)
        {
            return getItem((int)position);
        }

        @Override
        public Object getItem(int position)
        {
            try
            {
                synchronized (mAdapter.messages)
                {
                    if (position < mAdapter.messages.size())
                    {
                        return mAdapter.messages.get(position);
                    }
                }
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""getItem("" + position + ""), but folder.messages.size() = "" + mAdapter.messages.size(), e);
            }
            return null;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent)
        {

            if (position == mAdapter.messages.size())
            {
                return getFooterView(position, convertView, parent);
            }
            else
            {
                return  getItemView(position, convertView, parent);
            }
        }

        public View getItemView(int position, View convertView, ViewGroup parent)
        {
            MessageInfoHolder message = (MessageInfoHolder) getItem(position);
            View view;

            if ((convertView != null) && (convertView.getId() == R.layout.message_list_item))
            {
                view = convertView;
            }
            else
            {
                if (mTouchView)
                {
                    view = mInflater.inflate(R.layout.message_list_item_touchable, parent, false);
                    view.setId(R.layout.message_list_item);
                }
                else
                {
                    view = mInflater.inflate(R.layout.message_list_item, parent, false);
                    view.setId(R.layout.message_list_item);
                }
            }

            MessageViewHolder holder = (MessageViewHolder) view.getTag();

            if (holder == null)
            {
                holder = new MessageViewHolder();
                holder.subject = (TextView) view.findViewById(R.id.subject);
                holder.from = (TextView) view.findViewById(R.id.from);
                holder.date = (TextView) view.findViewById(R.id.date);
                holder.chip = view.findViewById(R.id.chip);
                holder.preview = (TextView) view.findViewById(R.id.preview);
                holder.selected = (CheckBox) view.findViewById(R.id.selected_checkbox);
                holder.flagged = (CheckBox) view.findViewById(R.id.flagged);

                holder.flagged.setOnClickListener(flagClickListener);

                if (!mStars)
                {
                    holder.flagged.setVisibility(View.GONE);
                }

                if (mCheckboxes)
                {
                    holder.selected.setVisibility(View.VISIBLE);
                }

                if (holder.selected != null)
                {
                    holder.selected.setOnCheckedChangeListener(holder);
                }

                view.setTag(holder);
            }

            if (message != null)
            {
                bindView(position, view, holder, message);
            }
            else
            {
                // TODO is this branch ever reached/executed?

                holder.chip.getBackground().setAlpha(0);
                holder.subject.setText(""No subject"");
                holder.subject.setTypeface(null, Typeface.NORMAL);
                if (holder.preview != null)
                {
                    holder.preview.setText(""No sender"");
                    holder.preview.setTypeface(null, Typeface.NORMAL);
                    holder.preview.setCompoundDrawablesWithIntrinsicBounds(null, null, null, null);
                }
                else
                {
                    holder.from.setText(""No sender"");
                    holder.from.setTypeface(null, Typeface.NORMAL);
                    holder.from.setCompoundDrawablesWithIntrinsicBounds(null, null, null, null);
                }

                holder.date.setText(""No date"");

                //WARNING: Order of the next 2 lines matter
                holder.position = -1;
                holder.selected.setChecked(false);

                if (!mCheckboxes)
                {
                    holder.selected.setVisibility(View.GONE);
                }
                holder.flagged.setChecked(false);
            }

            holder.subject.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageListSubject());
            holder.date.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageListDate());

            if (mTouchView)
            {
                holder.preview.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageListSender());
            }
            else
            {
                holder.from.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageListSender());
            }

            return view;
        }

        /**
         * Associate model data to view object.
         *
         * @param position
         *            The position of the item within the adapter's data set of
         *            the item whose view we want.
         * @param view
         *            Main view component to alter. Never <code>null</code>.
         * @param holder
         *            Convenience view holder - eases access to <tt>view</tt>
         *            child views. Never <code>null</code>.
         * @param message
         *            Never <code>null</code>.
         */
        private void bindView(final int position, final View view, final MessageViewHolder holder,
                              final MessageInfoHolder message)
        {
            holder.subject.setTypeface(null, message.read ? Typeface.NORMAL : Typeface.BOLD);

            // XXX TODO there has to be some way to walk our view hierarchy and get this
            holder.flagged.setTag((Integer)position);
            holder.flagged.setChecked(message.flagged);

            // So that the mSelectedCount is only incremented/decremented
            // when a user checks the checkbox (vs code)
            holder.position = -1;
            holder.selected.setChecked(message.selected);

            if (!mCheckboxes)
            {
                holder.selected.setVisibility(message.selected ? View.VISIBLE : View.GONE);
            }

            holder.chip.setBackgroundColor(message.message.getFolder().getAccount().getChipColor());
            holder.chip.getBackground().setAlpha(message.read ? 127 : 255);
            view.getBackground().setAlpha(message.downloaded ? 0 : 127);

            if ((message.subject == null) || message.subject.equals(""""))
            {
                holder.subject.setText(getText(R.string.general_no_subject));
            }
            else
            {
                holder.subject.setText(message.subject);
            }

            if (holder.preview != null)
            {
                /*
                 * In the touchable UI, we have previews. Otherwise, we
                 * have just a ""from"" line.
                 * Because text views can't wrap around each other(?) we
                 * compose a custom view containing the preview and the
                 * from.
                 */
                holder.preview.setText(new SpannableStringBuilder(message.sender).append("" "").append(message.preview),
                                       TextView.BufferType.SPANNABLE);
                Spannable str = (Spannable)holder.preview.getText();

                // Create our span sections, and assign a format to each.
                str.setSpan(new StyleSpan(Typeface.BOLD),
                            0,
                            message.sender.length(),
                            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                           );
                str.setSpan(new ForegroundColorSpan(Color.rgb(128,128,128)), // TODO: How do I can specify the android.R.attr.textColorTertiary
                            message.sender.length(),
                            str.length(),
                            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                           );
            }
            else
            {
                holder.from.setText(message.sender);
                holder.from.setTypeface(null, message.read ? Typeface.NORMAL : Typeface.BOLD);
            }

            holder.date.setText(message.date);
            holder.subject.setCompoundDrawablesWithIntrinsicBounds(
                message.answered ? mAnsweredIcon : null, // left
                null, // top
                message.hasAttachments ? mAttachmentIcon : null, // right
                null); // bottom
            holder.position = position;
        }

        public View getFooterView(int position, View convertView, ViewGroup parent)
        {
            if (footerView == null)
            {
                footerView = mInflater.inflate(R.layout.message_list_item_footer, parent, false);
                if (mQueryString != null)
                {
                    footerView.setVisibility(View.GONE);
                }
                footerView.setId(R.layout.message_list_item_footer);
                FooterViewHolder holder = new FooterViewHolder();
                holder.progress = (ProgressBar)footerView.findViewById(R.id.message_list_progress);
                holder.progress.setIndeterminate(true);
                holder.main = (TextView)footerView.findViewById(R.id.main_text);
                footerView.setTag(holder);
            }

            FooterViewHolder holder = (FooterViewHolder)footerView.getTag();

            if (mCurrentFolder != null && mAccount != null)
            {
                if (mCurrentFolder.loading)
                {
                    holder.main.setText(getString(R.string.status_loading_more));
                    holder.progress.setVisibility(ProgressBar.VISIBLE);
                }
                else
                {
                    if (!mCurrentFolder.lastCheckFailed)
                    {
                        holder.main.setText(String.format(getString(R.string.load_more_messages_fmt), mAccount.getDisplayCount()));
                    }
                    else
                    {
                        holder.main.setText(getString(R.string.status_loading_more_failed));
                    }
                    holder.progress.setVisibility(ProgressBar.INVISIBLE);
                }
            }
            else
            {
                holder.progress.setVisibility(ProgressBar.INVISIBLE);
            }

            return footerView;
        }

        @Override
        public boolean hasStableIds()
        {
            return true;
        }

        public boolean isItemSelectable(int position)
        {
            if (position < mAdapter.messages.size())
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }

    class MessageViewHolder
            implements OnCheckedChangeListener
    {
        public TextView subject;
        public TextView preview;
        public TextView from;
        public TextView time;
        public TextView date;
        public CheckBox flagged;
        public View chip;
        public CheckBox selected;
        public int position = -1;

        @Override
        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
        {
            if (position!=-1)
            {
                MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(position);
                if (message.selected!=isChecked)
                {
                    if (isChecked)
                    {
                        mSelectedCount++;
                    }
                    else if (mSelectedCount > 0)
                    {
                        mSelectedCount--;
                    }

                    // We must set the flag before showing the buttons as the
                    // buttons text depends on what is selected.
                    message.selected = isChecked;
                    if (!mCheckboxes)
                    {
                        if (isChecked)
                        {
                            selected.setVisibility(View.VISIBLE);
                        }
                        else
                        {
                            selected.setVisibility(View.GONE);
                        }
                    }
                    toggleBatchButtons();
                }
            }
        }
    }

    private void hideBatchButtons()
    {
        //TODO: Fade out animation
        mBatchButtonArea.setVisibility(View.GONE);
    }

    private void showBatchButtons()
    {
        //TODO: Fade in animation
        mBatchButtonArea.setVisibility(View.VISIBLE);
    }

    private void toggleBatchButtons()
    {
        if (mSelectedCount < 0)
        {
            mSelectedCount = 0;
        }

        int readButtonIconId;
        int flagButtonIconId;

        if (mSelectedCount==0)
        {
            readButtonIconId = R.drawable.ic_button_mark_read;
            flagButtonIconId = R.drawable.ic_button_flag;
            hideBatchButtons();
        }
        else
        {
            boolean newReadState = computeBatchDirection(false);
            if (newReadState)
            {
                readButtonIconId = R.drawable.ic_button_mark_read;
            }
            else
            {
                readButtonIconId = R.drawable.ic_button_mark_unread;
            }
            boolean newFlagState = computeBatchDirection(true);
            if (newFlagState)
            {
                flagButtonIconId = R.drawable.ic_button_flag;
            }
            else
            {
                flagButtonIconId = R.drawable.ic_button_unflag;
            }
            showBatchButtons();
        }

        mBatchReadButton.setImageResource(readButtonIconId);
        mBatchFlagButton.setImageResource(flagButtonIconId);
    }

    class FooterViewHolder
    {
        public ProgressBar progress;
        public TextView main;
    }


    private boolean computeBatchDirection(boolean flagged)
    {
        boolean newState = false;

        synchronized (mAdapter.messages)
        {
            for (MessageInfoHolder holder : mAdapter.messages)
            {
                if (holder.selected)
                {
                    if (flagged)
                    {
                        if (!holder.flagged)
                        {
                            newState = true;
                            break;
                        }
                    }
                    else
                    {
                        if (!holder.read)
                        {
                            newState = true;
                            break;
                        }
                    }
                }
            }
        }
        return newState;
    }

    private boolean anySelected()
    {
        synchronized (mAdapter.messages)
        {
            for (MessageInfoHolder holder : mAdapter.messages)
            {
                if (holder.selected)
                {
                    return true;
                }
            }
        }
        return false;
    }

    @Override
    public void onClick(View v)
    {
        boolean newState = false;
        List<Message> messageList = new ArrayList<Message>();
        List<MessageInfoHolder> removeHolderList = new ArrayList<MessageInfoHolder>();

        if (v == mBatchDoneButton)
        {
            setAllSelected(false);
            return;
        }

        if (v == mBatchFlagButton)
        {
            newState = computeBatchDirection(true);
        }
        else
        {
            newState = computeBatchDirection(false);
        }

        synchronized (mAdapter.messages)
        {
            for (MessageInfoHolder holder : mAdapter.messages)
            {
                if (holder.selected)
                {
                    if (v == mBatchDeleteButton)
                    {
                        removeHolderList.add(holder);
                    }
                    else if (v == mBatchFlagButton)
                    {
                        holder.flagged = newState;
                    }
                    else if (v == mBatchReadButton)
                    {
                        holder.read = newState;
                    }
                    messageList.add(holder.message);
                }
            }
        }
        mAdapter.removeMessages(removeHolderList);

        if (!messageList.isEmpty())
        {
            if (v == mBatchDeleteButton)
            {
                mController.deleteMessages(messageList.toArray(EMPTY_MESSAGE_ARRAY), null);
                mSelectedCount = 0;
                toggleBatchButtons();
            }
            else
            {
                mController.setFlag(messageList.toArray(EMPTY_MESSAGE_ARRAY), (v == mBatchReadButton ? Flag.SEEN : Flag.FLAGGED), newState);
            }
        }
        else
        {
            // Should not happen
            Toast.makeText(this, R.string.no_message_seletected_toast, Toast.LENGTH_SHORT).show();
        }
        mHandler.sortMessages();
    }

    private void setAllSelected(boolean isSelected)
    {
        mSelectedCount = 0;
        synchronized (mAdapter.messages)
        {
            for (MessageInfoHolder holder : mAdapter.messages)
            {
                holder.selected = isSelected;
                mSelectedCount += (isSelected ? 1 : 0);
            }
        }
        mAdapter.notifyDataSetChanged();
        toggleBatchButtons();
    }

    private void setSelected(MessageInfoHolder holder, boolean newState)
    {
        if (holder.selected != newState)
        {
            holder.selected = newState;
            mSelectedCount += (newState ? 1 : -1);
        }
        mAdapter.notifyDataSetChanged();
        toggleBatchButtons();
    }

    private void flagSelected(Flag flag, boolean newState)
    {
        List<Message> messageList = new ArrayList<Message>();
        synchronized (mAdapter.messages)
        {
            for (MessageInfoHolder holder : mAdapter.messages)
            {
                if (holder.selected)
                {
                    messageList.add(holder.message);
                    if (flag == Flag.SEEN)
                    {
                        holder.read = newState;
                    }
                    else if (flag == Flag.FLAGGED)
                    {
                        holder.flagged = newState;
                    }
                }
            }
        }
        mController.setFlag(messageList.toArray(EMPTY_MESSAGE_ARRAY), flag, newState);
        mHandler.sortMessages();
    }

    private void deleteSelected()
    {
        List<Message> messageList = new ArrayList<Message>();
        List<MessageInfoHolder> removeHolderList = new ArrayList<MessageInfoHolder>();
        synchronized (mAdapter.messages)
        {
            for (MessageInfoHolder holder : mAdapter.messages)
            {
                if (holder.selected)
                {
                    removeHolderList.add(holder);
                    messageList.add(holder.message);
                }
            }
        }
        mAdapter.removeMessages(removeHolderList);

        mController.deleteMessages(messageList.toArray(EMPTY_MESSAGE_ARRAY), null);
        mSelectedCount = 0;
        toggleBatchButtons();
    }

    private void onMoveBatch()
    {
        if (!mController.isMoveCapable(mAccount))
        {
            return;
        }

        synchronized (mAdapter.messages)
        {
            for (MessageInfoHolder holder : mAdapter.messages)
            {
                if (holder.selected)
                {
                    Message message = holder.message;
                    if (!mController.isMoveCapable(message))
                    {
                        Toast toast = Toast.makeText(this,
                                                     R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
                        toast.show();
                        return;
                    }
                }
            }
        }

        final Folder folder = mCurrentFolder.folder;
        final Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, folder.getName());
        intent.putExtra(ChooseFolder.EXTRA_SEL_FOLDER, folder.getAccount().getLastSelectedFolderName());
        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_MOVE_BATCH);
    }

    private void onMoveChosenBatch(String folderName)
    {
        if (!mController.isMoveCapable(mAccount))
        {
            return;
        }
        List<Message> messageList = new ArrayList<Message>();

        List<MessageInfoHolder> removeHolderList = new ArrayList<MessageInfoHolder>();
        synchronized (mAdapter.messages)
        {
            for (MessageInfoHolder holder : mAdapter.messages)
            {
                if (holder.selected)
                {
                    Message message = holder.message;
                    if (!mController.isMoveCapable(message))
                    {
                        Toast toast = Toast.makeText(this,
                                                     R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
                        toast.show();
                        return;
                    }
                    messageList.add(holder.message);
                    removeHolderList.add(holder);
                }
            }
        }
        mAdapter.removeMessages(removeHolderList);

        mController.moveMessages(mAccount, mCurrentFolder.name, messageList.toArray(EMPTY_MESSAGE_ARRAY), folderName, null);
        mSelectedCount = 0;
        toggleBatchButtons();
    }

    private void onArchiveBatch()
    {
        if (!mController.isMoveCapable(mAccount))
        {
            return;
        }

        synchronized (mAdapter.messages)
        {
            for (MessageInfoHolder holder : mAdapter.messages)
            {
                if (holder.selected)
                {
                    Message message = holder.message;
                    if (!mController.isMoveCapable(message))
                    {
                        Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
                        toast.show();
                        return;
                    }
                }
            }
        }

        String folderName = mAccount.getArchiveFolderName();
        if (K9.FOLDER_NONE.equalsIgnoreCase(folderName))
        {
            return;
        }
        onMoveChosenBatch(folderName);
    }

    private void onSpamBatch()
    {
        if (!mController.isMoveCapable(mAccount))
        {
            return;
        }

        synchronized (mAdapter.messages)
        {
            for (MessageInfoHolder holder : mAdapter.messages)
            {
                if (holder.selected)
                {
                    Message message = holder.message;
                    if (!mController.isMoveCapable(message))
                    {
                        Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
                        toast.show();
                        return;
                    }
                }
            }
        }

        String folderName = mAccount.getSpamFolderName();
        if (K9.FOLDER_NONE.equalsIgnoreCase(folderName))
        {
            return;
        }
        onMoveChosenBatch(folderName);
    }

    private void onCopyBatch()
    {
        if (!mController.isCopyCapable(mAccount))
        {
            return;
        }

        synchronized (mAdapter.messages)
        {
            for (MessageInfoHolder holder : mAdapter.messages)
            {
                if (holder.selected)
                {
                    Message message = holder.message;
                    if (!mController.isCopyCapable(message))
                    {
                        Toast toast = Toast.makeText(this,
                                                     R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
                        toast.show();
                        return;
                    }
                }
            }
        }

        final Folder folder = mCurrentFolder.folder;
        final Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, folder.getName());
        intent.putExtra(ChooseFolder.EXTRA_SEL_FOLDER, folder.getAccount().getLastSelectedFolderName());
        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_COPY_BATCH);
    }

    private void onCopyChosenBatch(String folderName)
    {
        if (!mController.isCopyCapable(mAccount))
        {
            return;
        }

        List<Message> messageList = new ArrayList<Message>();
        synchronized (mAdapter.messages)
        {
            for (MessageInfoHolder holder : mAdapter.messages)
            {
                if (holder.selected)
                {
                    Message message = holder.message;
                    if (!mController.isCopyCapable(message))
                    {
                        Toast toast = Toast.makeText(this,
                                                     R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
                        toast.show();
                        return;
                    }
                    messageList.add(holder.message);
                }
            }
        }
        mController.copyMessages(mAccount, mCurrentFolder.name, messageList.toArray(EMPTY_MESSAGE_ARRAY), folderName, null);
    }
}
",True,218,1,2,8,60,5,27,L1
51,com.fsck.k9.activity.MessageView.java,"package com.fsck.k9.activity;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.io.IOUtils;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.ContentResolver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.ResolveInfo;
import android.content.res.Configuration;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.media.MediaScannerConnection;
import android.media.MediaScannerConnection.MediaScannerConnectionClient;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.text.SpannableString;
import android.text.SpannableStringBuilder;
import android.text.style.StyleSpan;
import android.util.Config;
import android.util.Log;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.TranslateAnimation;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.fsck.k9.Account;
import com.fsck.k9.FontSizes;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.crypto.CryptoProvider;
import com.fsck.k9.crypto.PgpData;
import com.fsck.k9.helper.Contacts;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Multipart;
import com.fsck.k9.mail.Part;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.store.LocalStore.LocalAttachmentBodyPart;
import com.fsck.k9.mail.store.LocalStore.LocalMessage;
import com.fsck.k9.mail.store.LocalStore.LocalTextBody;
import com.fsck.k9.provider.AttachmentProvider;
import com.fsck.k9.web.AccessibleWebView;

public class MessageView extends K9Activity implements OnClickListener
{
    private static final String EXTRA_MESSAGE_REFERENCE = ""com.fsck.k9.MessageView_messageReference"";
    private static final String EXTRA_MESSAGE_REFERENCES = ""com.fsck.k9.MessageView_messageReferences"";
    private static final String EXTRA_NEXT = ""com.fsck.k9.MessageView_next"";

    private static final String SHOW_PICTURES = ""showPictures"";
    private static final String STATE_PGP_DATA = ""pgpData"";

    private static final int ACTIVITY_CHOOSE_FOLDER_MOVE = 1;
    private static final int ACTIVITY_CHOOSE_FOLDER_COPY = 2;

    private TextView mFromView;
    private TextView mDateView;
    private TextView mTimeView;
    private TextView mToView;
    private TextView mCcView;
    private TextView mSubjectView;
    public View chip;
    private CheckBox mFlagged;
    private int defaultSubjectColor;
    private View mDecryptLayout;
    private Button mDecryptButton;
    private LinearLayout mCryptoSignatureLayout = null;
    private ImageView mCryptoSignatureStatusImage = null;
    private TextView mCryptoSignatureUserId = null;
    private TextView mCryptoSignatureUserIdRest = null;
    private WebView mMessageContentView;

    private boolean mScreenReaderEnabled;

    private AccessibleWebView mAccessibleMessageContentView;

    private LinearLayout mHeaderContainer;
    private LinearLayout mAttachments;
    private LinearLayout mToContainerView;
    private LinearLayout mCcContainerView;
    private TextView mAdditionalHeadersView;
    private View mAttachmentIcon;
    private View mShowPicturesSection;
    private boolean mShowPictures;

    private Button mDownloadRemainder;


    View next;
    View next_scrolling;
    View previous;
    View previous_scrolling;

    private View mDelete;
    private View mArchive;
    private View mMove;
    private View mSpam;
    private View mArchiveScrolling;
    private View mMoveScrolling;
    private View mSpamScrolling;
    private ToggleScrollView mToggleScrollView;

    private Account mAccount;
    private MessageReference mMessageReference;
    private ArrayList<MessageReference> mMessageReferences;

    private Message mMessage;
    private PgpData mPgpData = null;

    private static final int PREVIOUS = 1;
    private static final int NEXT = 2;

    private int mLastDirection = PREVIOUS;

    private MessageReference mNextMessage = null;
    private MessageReference mPreviousMessage = null;

    private Menu optionsMenu = null;

    private Listener mListener = new Listener();
    private MessageViewHandler mHandler = new MessageViewHandler();

    private FontSizes mFontSizes = K9.getFontSizes();

    private Contacts mContacts;

    /**
     * Pair class is only available since API Level 5, so we need
     * this helper class unfortunately
     */
    private class HeaderEntry
    {
        public String label;
        public String value;

        public HeaderEntry(String label, String value)
        {
            this.label = label;
            this.value = value;
        }
    }

    @Override
    public boolean dispatchTouchEvent(MotionEvent ev)
    {
        if (ev.getAction() == MotionEvent.ACTION_UP)
        {
            // Text selection is finished. Allow scrolling again.
            mToggleScrollView.setScrolling(true);
        }

        return super.dispatchTouchEvent(ev);
    }

    @Override
    public boolean dispatchKeyEvent(KeyEvent event)
    {
        boolean ret = false;

        if (KeyEvent.ACTION_DOWN == event.getAction())
        {
            ret = onKeyDown(event.getKeyCode(), event);
        }
        if (!ret)
        {
            ret = super.dispatchKeyEvent(event);
        }
        return ret;
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        switch (keyCode)
        {
            case KeyEvent.KEYCODE_VOLUME_UP:
            {
                if (K9.useVolumeKeysForNavigationEnabled())
                {
                    onNext(true);
                    return true;
                }
            }
            case KeyEvent.KEYCODE_VOLUME_DOWN:
            {
                if (K9.useVolumeKeysForNavigationEnabled())
                {
                    onPrevious(true);
                    return true;
                }
            }
            case KeyEvent.KEYCODE_SHIFT_LEFT:
            case KeyEvent.KEYCODE_SHIFT_RIGHT:
            {
                /*
                 * Selecting text started via shift key. Disable scrolling as
                 * this causes problems when selecting text.
                 */
                mToggleScrollView.setScrolling(false);
                break;
            }
            case KeyEvent.KEYCODE_DEL:
            {
                onDelete();
                return true;
            }
            case KeyEvent.KEYCODE_D:
            {
                onDelete();
                return true;
            }
            case KeyEvent.KEYCODE_F:
            {
                onForward();
                return true;
            }
            case KeyEvent.KEYCODE_A:
            {
                onReplyAll();
                return true;
            }
            case KeyEvent.KEYCODE_R:
            {
                onReply();
                return true;
            }
            case KeyEvent.KEYCODE_G:
            {
                onFlag();
                return true;
            }

            case KeyEvent.KEYCODE_M:
            {
                onMove();
                return true;
            }
            case KeyEvent.KEYCODE_S:
            {
                onSpam();
                return true;
            }
            case KeyEvent.KEYCODE_V:
            {
                onArchive();
                return true;
            }
            case KeyEvent.KEYCODE_Y:
            {
                onCopy();
                return true;
            }
            case KeyEvent.KEYCODE_J:
            case KeyEvent.KEYCODE_P:
            {
                onPrevious(K9.showAnimations());
                return true;
            }
            case KeyEvent.KEYCODE_N:
            case KeyEvent.KEYCODE_K:
            {
                onNext(K9.showAnimations());
                return true;
            }
            case KeyEvent.KEYCODE_Z:
            {
                if (event.isShiftPressed())
                {
                    mHandler.post(new Runnable()
                    {
                        public void run()
                        {
                            if (mScreenReaderEnabled)
                            {
                                mAccessibleMessageContentView.zoomIn();
                            }
                            else
                            {
                                mMessageContentView.zoomIn();
                            }
                        }
                    });
                }
                else
                {
                    mHandler.post(new Runnable()
                    {
                        public void run()
                        {
                            if (mScreenReaderEnabled)
                            {
                                mAccessibleMessageContentView.zoomIn();
                            }
                            else
                            {
                                mMessageContentView.zoomOut();
                            }
                        }
                    });
                }
                return true;
            }
            case KeyEvent.KEYCODE_H:
            {
                Toast toast = Toast.makeText(this, R.string.message_help_key, Toast.LENGTH_LONG);
                toast.show();
                return true;
            }
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event)
    {
        // Swallow these events too to avoid the audible notification of a volume change
        if (K9.useVolumeKeysForNavigationEnabled())
        {
            if ((keyCode == KeyEvent.KEYCODE_VOLUME_UP) || (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN))
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""Swallowed key up."");
                return true;
            }
        }
        return super.onKeyUp(keyCode,event);
    }

    class MessageViewHandler extends Handler
    {
        public void progress(final boolean progress)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    setProgressBarIndeterminateVisibility(progress);

                }
            });
        }

        public void addAttachment(final View attachmentView)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    mAttachments.addView(attachmentView);
                    mAttachments.setVisibility(View.VISIBLE);

                }
            });
        }

        public void removeAllAttachments()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    for (int i = 0, count = mAttachments.getChildCount(); i < count; i++)
                    {
                        mAttachments.removeView(mAttachments.getChildAt(i));
                    }
                }

            });
        }


        public void setAttachmentsEnabled(final boolean enabled)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    for (int i = 0, count = mAttachments.getChildCount(); i < count; i++)
                    {
                        Attachment attachment = (Attachment) mAttachments.getChildAt(i).getTag();
                        attachment.viewButton.setEnabled(enabled);
                        attachment.downloadButton.setEnabled(enabled);
                    }

                }
            });
        }

        public void setHeaders(
            final   String subject,
            final   CharSequence from,
            final   String date,
            final   String time,
            final   CharSequence to,
            final   CharSequence cc,
            final   int accountColor,
            final   boolean unread,
            final   boolean hasAttachments,
            final   boolean flagged,
            final   boolean answered)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    setTitle(subject);
                    if (subject == null || subject.equals(""""))
                    {
                        mSubjectView.setText(getText(R.string.general_no_subject));
                    }
                    else
                    {
                        mSubjectView.setText(subject);
                    }
                    mFromView.setText(from);
                    if (date != null)
                    {
                        mDateView.setText(date);
                        mDateView.setVisibility(View.VISIBLE);
                    }
                    else
                    {
                        mDateView.setVisibility(View.GONE);
                    }
                    mTimeView.setText(time);
                    mToContainerView.setVisibility((to != null && to.length() > 0)? View.VISIBLE : View.GONE);
                    mToView.setText(to);

                    mCcContainerView.setVisibility((cc != null && cc.length() > 0)? View.VISIBLE : View.GONE);

                    mCcView.setText(cc);
                    mAttachmentIcon.setVisibility(hasAttachments ? View.VISIBLE : View.GONE);
                    if (flagged)
                    {
                        mFlagged.setChecked(true);
                    }
                    else
                    {
                        mFlagged.setChecked(false);
                    }
                    mSubjectView.setTextColor(0xff000000 | defaultSubjectColor);

                    chip.setBackgroundColor(accountColor);
                    chip.getBackground().setAlpha(unread ? 255 : 127);

                    if (answered)
                    {
                        Drawable answeredIcon = getResources().getDrawable(
                                                    R.drawable.ic_mms_answered_small);
                        mSubjectView.setCompoundDrawablesWithIntrinsicBounds(
                            answeredIcon, // left
                            null, // top
                            null, // right
                            null); // bottom
                    }
                    else
                    {
                        mSubjectView.setCompoundDrawablesWithIntrinsicBounds(
                            null, // left
                            null, // top
                            null, // right
                            null); // bottom
                    }

                    if (mMessage.isSet(Flag.X_DOWNLOADED_FULL))
                    {
                        mDownloadRemainder.setVisibility(View.GONE);
                    }
                    else
                    {
                        mDownloadRemainder.setEnabled(true);
                        mDownloadRemainder.setVisibility(View.VISIBLE);

                    }

                }
            });
        }



        public void networkError()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    Toast.makeText(MessageView.this,
                                   R.string.status_network_error, Toast.LENGTH_LONG).show();

                }
            });
        }

        public void invalidIdError()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    Toast.makeText(MessageView.this,
                                   R.string.status_invalid_id_error, Toast.LENGTH_LONG).show();

                }
            });
        }

        public void attachmentSaved(final String filename)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    Toast.makeText(MessageView.this, String.format(
                                       getString(R.string.message_view_status_attachment_saved), filename),
                                   Toast.LENGTH_LONG).show();


                }
            });
        }

        public void attachmentNotSaved()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {

                    Toast.makeText(MessageView.this,
                                   getString(R.string.message_view_status_attachment_not_saved),
                                   Toast.LENGTH_LONG).show();

                }
            });
        }

        public void fetchingAttachment()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    Toast.makeText(MessageView.this,
                                   getString(R.string.message_view_fetching_attachment_toast),
                                   Toast.LENGTH_SHORT).show();
                }
            });
        }

        public void showShowPictures(final boolean show)
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    mShowPicturesSection.setVisibility(show ? View.VISIBLE : View.GONE);
                }
            });

        }



        private void showHeaderContainer()
        {
            {
                runOnUiThread(new Runnable()
                {
                    public void run()
                    {
                        mHeaderContainer.setVisibility(View.VISIBLE);
                    }
                });
            }
        }

        private void hideHeaderContainer()
        {
            {
                runOnUiThread(new Runnable()
                {
                    public void run()
                    {
                        mHeaderContainer.setVisibility(View.GONE);
                    }
                });
            }
        }




        /**
         * Clear the text field for the additional headers display if they are
         * not shown, to save UI resources.
         */
        public void hideAdditionalHeaders()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    mAdditionalHeadersView.setVisibility(View.GONE);
                    mAdditionalHeadersView.setText("""");
                    mTopView.scrollTo(0, 0);
                }
            });
        }

        /**
         * Set up and then show the additional headers view. Called by
         * {@link #onShowAdditionalHeaders()} and
         * {@link #setHeaders(Account, String, String, Message)}
         * (when switching between messages).
         */
        public void showAdditionalHeaders()
        {
            runOnUiThread(new Runnable()
            {
                public void run()
                {
                    Integer messageToShow = null;
                    try
                    {
                        // Retrieve additional headers
                        boolean allHeadersDownloaded = mMessage.isSet(Flag.X_GOT_ALL_HEADERS);
                        List<HeaderEntry> additionalHeaders = getAdditionalHeaders(mMessage);

                        if (!additionalHeaders.isEmpty())
                        {
                            // Show the additional headers that we have got.
                            setupAdditionalHeadersView(additionalHeaders);
                            mAdditionalHeadersView.setVisibility(View.VISIBLE);
                        }

                        if (!allHeadersDownloaded)
                        {
                            /*
                             * Tell the user about the ""save all headers"" setting
                             *
                             * NOTE: This is only a temporary solution... in fact,
                             * the system should download headers on-demand when they
                             * have not been saved in their entirety initially.
                             */
                            messageToShow = R.string.message_additional_headers_not_downloaded;
                        }
                        else if (additionalHeaders.isEmpty())
                        {
                            // All headers have been downloaded, but there are no additional headers.
                            messageToShow = R.string.message_no_additional_headers_available;
                        }
                    }
                    catch (MessagingException e)
                    {
                        messageToShow = R.string.message_additional_headers_retrieval_failed;
                    }

                    // Show a message to the user, if any
                    if (messageToShow != null)
                    {
                        Toast toast = Toast.makeText(MessageView.this, messageToShow, Toast.LENGTH_LONG);
                        toast.setGravity(Gravity.CENTER_VERTICAL | Gravity.CENTER_HORIZONTAL, 0, 0);
                        toast.show();
                    }
                }
            });
        }

        /**
         * Set up the additional headers text view with the supplied header data.
         *
         * @param additionalHeaders
         *          List of header entries. Each entry consists of a header
         *          name and a header value. Header names may appear multiple
         *          times.
         *
         * This method is always called from within the UI thread by
         * {@link #showAdditionalHeaders()}.
         */
        private void setupAdditionalHeadersView(final List<HeaderEntry> additionalHeaders)
        {
            SpannableStringBuilder sb = new SpannableStringBuilder();
            boolean first = true;
            for (HeaderEntry additionalHeader : additionalHeaders)
            {
                if (!first)
                {
                    sb.append(""\n"");
                }
                else
                {
                    first = false;
                }

                StyleSpan boldSpan = new StyleSpan(Typeface.BOLD);
                SpannableString label = new SpannableString(additionalHeader.label + "": "");
                label.setSpan(boldSpan, 0, label.length(), 0);

                sb.append(label);
                sb.append(MimeUtility.unfoldAndDecode(additionalHeader.value));
            }

            mAdditionalHeadersView.setText(sb);
        }
    }

    class Attachment
    {
        public String name;
        public String contentType;
        public long size;
        public LocalAttachmentBodyPart part;
        public Button viewButton;
        public Button downloadButton;
        public ImageView iconView;
    }

    public static void actionView(Context context, MessageReference messRef, List<MessageReference> messReferences)
    {
        actionView(context, messRef, messReferences, null);
    }

    public static void actionView(Context context, MessageReference messRef, List<MessageReference> messReferences, Bundle extras)
    {
        Intent i = new Intent(context, MessageView.class);
        i.putExtra(EXTRA_MESSAGE_REFERENCE, messRef);
        i.putExtra(EXTRA_MESSAGE_REFERENCES, (Serializable)messReferences);
        if (extras != null)
        {
            i.putExtras(extras);
        }
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle icicle)
    {
        super.onCreate(icicle, false);

        mContacts = Contacts.getInstance(this);

        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        requestWindowFeature(Window.FEATURE_NO_TITLE);

        setContentView(R.layout.message_view);

        mHeaderContainer = (LinearLayout)findViewById(R.id.header_container);

        mFromView = (TextView)findViewById(R.id.from);
        mToView = (TextView)findViewById(R.id.to);
        mCcView = (TextView)findViewById(R.id.cc);
        mToContainerView = (LinearLayout)findViewById(R.id.to_container);
        mCcContainerView = (LinearLayout)findViewById(R.id.cc_container);
        mSubjectView = (TextView)findViewById(R.id.subject);
        defaultSubjectColor = mSubjectView.getCurrentTextColor();

        mAdditionalHeadersView = (TextView)findViewById(R.id.additional_headers_view);

        chip = findViewById(R.id.chip);

        mDateView = (TextView)findViewById(R.id.date);
        mTimeView = (TextView)findViewById(R.id.time);
        mTopView = mToggleScrollView = (ToggleScrollView)findViewById(R.id.top_view);
        mMessageContentView = (WebView)findViewById(R.id.message_content);
        mAccessibleMessageContentView = (AccessibleWebView) findViewById(R.id.accessible_message_content);

        mScreenReaderEnabled = isScreenReaderActive();

        if (mScreenReaderEnabled)
        {
            mAccessibleMessageContentView.setVisibility(View.VISIBLE);
            mMessageContentView.setVisibility(View.GONE);
        }
        else
        {
            mAccessibleMessageContentView.setVisibility(View.GONE);
            mMessageContentView.setVisibility(View.VISIBLE);
        }

        mDecryptLayout = (View)findViewById(R.id.layout_decrypt);
        mDecryptButton = (Button)findViewById(R.id.btn_decrypt);
        mDecryptButton.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View v)
            {
                try
                {
                    String data = null;
                    Part part = MimeUtility.findFirstPartByMimeType(mMessage, ""text/plain"");
                    if (part == null)
                    {
                        part = MimeUtility.findFirstPartByMimeType(mMessage, ""text/html"");
                    }
                    if (part != null)
                    {
                        data = MimeUtility.getTextFromPart(part);
                    }
                    mAccount.getCryptoProvider().decrypt(MessageView.this, data, mPgpData);
                }
                catch (MessagingException me)
                {
                    Log.e(K9.LOG_TAG, ""Unable to decrypt email."", me);
                }
            }
        });
        mCryptoSignatureLayout = (LinearLayout) findViewById(R.id.crypto_signature);
        mCryptoSignatureStatusImage = (ImageView) findViewById(R.id.ic_crypto_signature_status);
        mCryptoSignatureUserId = (TextView) findViewById(R.id.userId);
        mCryptoSignatureUserIdRest = (TextView) findViewById(R.id.userIdRest);
        mCryptoSignatureLayout.setVisibility(View.INVISIBLE);

        mAttachments = (LinearLayout)findViewById(R.id.attachments);
        mAttachmentIcon = findViewById(R.id.attachment);
        mShowPicturesSection = findViewById(R.id.show_pictures_section);
        mShowPictures = false;

        mDownloadRemainder = (Button)findViewById(R.id.download_remainder);

        mFlagged = (CheckBox)findViewById(R.id.flagged);
        mFlagged.setOnClickListener(new OnClickListener()
        {
            public void onClick(View v)
            {
                onFlag();
            }
        });

        mMessageContentView.setVerticalScrollBarEnabled(true);
        mMessageContentView.setVerticalScrollbarOverlay(true);
        mMessageContentView.setScrollBarStyle(View.SCROLLBARS_INSIDE_OVERLAY);

        final WebSettings webSettings = mMessageContentView.getSettings();

        webSettings.setSupportZoom(true);
        webSettings.setLoadsImagesAutomatically(true);
        //webSettings.setBuiltInZoomControls(true);
        webSettings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.NARROW_COLUMNS);

        webSettings.setTextSize(mFontSizes.getMessageViewContent());

        mFromView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewSender());
        mToView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewTo());
        ((TextView)findViewById(R.id.to_label)).setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewTo());
        mCcView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewCC());
        ((TextView)findViewById(R.id.cc_label)).setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewCC());
        mSubjectView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewSubject());
        mTimeView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewTime());
        mDateView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewDate());
        mAdditionalHeadersView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageViewAdditionalHeaders());
        mAdditionalHeadersView.setVisibility(View.GONE);
        mAttachments.setVisibility(View.GONE);
        mAttachmentIcon.setVisibility(View.GONE);

        setOnClickListener(R.id.from);
        setOnClickListener(R.id.reply);
        setOnClickListener(R.id.reply_all);
        setOnClickListener(R.id.delete);
        setOnClickListener(R.id.forward);
        setOnClickListener(R.id.next);
        setOnClickListener(R.id.previous);
        setOnClickListener(R.id.archive);
        setOnClickListener(R.id.move);
        setOnClickListener(R.id.spam);

        // To show full header
        setOnClickListener(R.id.header_container);

        setOnClickListener(R.id.reply_scrolling);
//       setOnClickListener(R.id.reply_all_scrolling);
        setOnClickListener(R.id.delete_scrolling);
        setOnClickListener(R.id.forward_scrolling);
        setOnClickListener(R.id.next_scrolling);
        setOnClickListener(R.id.previous_scrolling);
        setOnClickListener(R.id.archive_scrolling);
        setOnClickListener(R.id.move_scrolling);
        setOnClickListener(R.id.spam_scrolling);

        setOnClickListener(R.id.show_pictures);

        setOnClickListener(R.id.download_remainder);

        setTitle("""");

        Intent intent = getIntent();
        Uri uri = intent.getData();

        if (icicle != null)
        {
            mMessageReference = (MessageReference)icicle.getSerializable(EXTRA_MESSAGE_REFERENCE);
            mMessageReferences = (ArrayList<MessageReference>)icicle.getSerializable(EXTRA_MESSAGE_REFERENCES);

            mPgpData = (PgpData) icicle.getSerializable(STATE_PGP_DATA);
            updateDecryptLayout();
        }
        else
        {
            if (uri == null)
            {
                mMessageReference = (MessageReference)intent.getSerializableExtra(EXTRA_MESSAGE_REFERENCE);
                mMessageReferences = (ArrayList<MessageReference>)intent.getSerializableExtra(EXTRA_MESSAGE_REFERENCES);
            }
            else
            {
                List<String> segmentList = uri.getPathSegments();
                if (segmentList.size() == 3)
                {
                    String accountId = segmentList.get(0);
                    Account[] accounts = Preferences.getPreferences(this).getAccounts();
                    boolean found = false;
                    for (Account account : accounts)
                    {
                        if (String.valueOf(account.getAccountNumber()).equals(accountId))
                        {
                            mAccount = account;
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                    {
                        //TODO: Use ressource to externalize message
                        Toast.makeText(this, ""Invalid account id: "" + accountId, Toast.LENGTH_LONG).show();
                        return;
                    }

                    mMessageReference = new MessageReference();
                    mMessageReference.accountUuid = mAccount.getUuid();
                    mMessageReference.folderName = segmentList.get(1);
                    mMessageReference.uid = segmentList.get(2);

                    mMessageReferences = new ArrayList<MessageReference>();
                }
                else
                {
                    //TODO: Use ressource to externalize message
                    Toast.makeText(this, ""Invalid intent uri: "" + uri.toString(), Toast.LENGTH_LONG).show();
                    return;
                }
            }
        }

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""MessageView got message "" + mMessageReference);

        next = findViewById(R.id.next);
        previous = findViewById(R.id.previous);

        next_scrolling = findViewById(R.id.next_scrolling);
        previous_scrolling = findViewById(R.id.previous_scrolling);

        mDelete = findViewById(R.id.delete);

        mArchive = findViewById(R.id.archive);
        mMove = findViewById(R.id.move);
        mSpam = findViewById(R.id.spam);

        mArchiveScrolling = findViewById(R.id.archive_scrolling);
        mMoveScrolling = findViewById(R.id.move_scrolling);
        mSpamScrolling = findViewById(R.id.spam_scrolling);

        boolean goNext = intent.getBooleanExtra(EXTRA_NEXT, false);
        if (goNext)
        {
            next.requestFocus();
        }
        // Perhaps the hideButtons should be global, instead of account-specific
        mAccount = Preferences.getPreferences(this).getAccount(mMessageReference.accountUuid);
        Account.HideButtons hideButtons = mAccount.getHideMessageViewButtons();

        //MessagingController.getInstance(getApplication()).addListener(mListener);
        if (Account.HideButtons.ALWAYS == hideButtons)
        {
            hideButtons();
        }
        else if (Account.HideButtons.NEVER == hideButtons)
        {
            showButtons();
        }
        else   // Account.HideButtons.KEYBOARD_AVAIL
        {
            final Configuration config = this.getResources().getConfiguration();
            if (config.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO)
            {
                hideButtons();
            }
            else
            {
                showButtons();
            }
        }

        Account.HideButtons hideMoveButtons = mAccount.getHideMessageViewMoveButtons();
        if (Account.HideButtons.ALWAYS == hideMoveButtons)
        {
            hideMoveButtons();
        }
        else if (Account.HideButtons.NEVER == hideMoveButtons)
        {
            showMoveButtons();
        }
        else   // Account.HideButtons.KEYBOARD_AVAIL
        {
            final Configuration config = this.getResources().getConfiguration();
            if (config.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO)
            {
                hideMoveButtons();
            }
            else
            {
                showMoveButtons();
            }
        }

        if (!mAccount.getEnableMoveButtons())
        {
            View buttons = findViewById(R.id.move_buttons);
            if (buttons != null)
            {
                buttons.setVisibility(View.GONE);
            }
            buttons = findViewById(R.id.scrolling_move_buttons);
            if (buttons != null)
            {
                buttons.setVisibility(View.GONE);
            }
        }

        displayMessage(mMessageReference);
    }

    private boolean isScreenReaderActive()
    {
        final String SCREENREADER_INTENT_ACTION = ""android.accessibilityservice.AccessibilityService"";
        final String SCREENREADER_INTENT_CATEGORY = ""android.accessibilityservice.category.FEEDBACK_SPOKEN"";
        // Restrict the set of intents to only accessibility services that have
        // the category FEEDBACK_SPOKEN (aka, screen readers).
        Intent screenReaderIntent = new Intent(SCREENREADER_INTENT_ACTION);
        screenReaderIntent.addCategory(SCREENREADER_INTENT_CATEGORY);
        List<ResolveInfo> screenReaders = getPackageManager().queryIntentServices(
                                              screenReaderIntent, 0);
        ContentResolver cr = getContentResolver();
        Cursor cursor = null;
        int status = 0;
        for (ResolveInfo screenReader : screenReaders)
        {
            // All screen readers are expected to implement a content provider
            // that responds to
            // content://<nameofpackage>.providers.StatusProvider
            cursor = cr.query(Uri.parse(""content://"" + screenReader.serviceInfo.packageName
                                        + "".providers.StatusProvider""), null, null, null, null);
            if (cursor != null)
            {
                cursor.moveToFirst();
                // These content providers use a special cursor that only has
                // one element,
                // an integer that is 1 if the screen reader is running.
                status = cursor.getInt(0);
                cursor.close();
                if (status == 1)
                {
                    return true;
                }
            }
        }
        return false;
    }

    @Override
    protected void onSaveInstanceState(Bundle outState)
    {
        outState.putSerializable(EXTRA_MESSAGE_REFERENCE, mMessageReference);
        outState.putSerializable(EXTRA_MESSAGE_REFERENCES, mMessageReferences);
        outState.putSerializable(STATE_PGP_DATA, mPgpData);
        outState.putBoolean(SHOW_PICTURES, mShowPictures);
    }

    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState)
    {
        super.onRestoreInstanceState(savedInstanceState);

        mShowPictures = savedInstanceState.getBoolean(SHOW_PICTURES);
        setLoadPictures(mShowPictures);

        mPgpData = (PgpData) savedInstanceState.getSerializable(STATE_PGP_DATA);
        initializeCrypto();

        updateDecryptLayout();
    }

    private void displayMessage(MessageReference ref)
    {
        mMessageReference = ref;
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""MessageView displaying message "" + mMessageReference);

        mAccount = Preferences.getPreferences(this).getAccount(mMessageReference.accountUuid);
        mTopView.setVisibility(View.GONE);
        mTopView.scrollTo(0, 0);
        mMessageContentView.scrollTo(0, 0);

        mHandler.hideHeaderContainer();
        mMessageContentView.clearView();
        setLoadPictures(false);
        mAttachments.removeAllViews();
        findSurroundingMessagesUid();

        // start with fresh, empty PGP data
        mPgpData = null;
        initializeCrypto();

        mTopView.setVisibility(View.VISIBLE);
        MessagingController.getInstance(getApplication()).loadMessageForView(
            mAccount,
            mMessageReference.folderName,
            mMessageReference.uid,
            mListener);
        setupDisplayMessageButtons();
    }

    private void setupDisplayMessageButtons()
    {

        boolean enableNext = (mNextMessage != null);
        boolean enablePrev = (mPreviousMessage != null);

        mDelete.setEnabled(true);

        if (next.isEnabled() != enableNext)
            next.setEnabled(enableNext);
        if (previous.isEnabled() != enablePrev)
            previous.setEnabled(enablePrev);

        if (next_scrolling != null && (next_scrolling.isEnabled() != enableNext))
            next_scrolling.setEnabled(enableNext);
        if (previous_scrolling != null && (previous_scrolling.isEnabled() != enablePrev))
            previous_scrolling.setEnabled(enablePrev);

        // If moving isn't support at all, then all of them must be disabled anyway.
        if (MessagingController.getInstance(getApplication()).isMoveCapable(mAccount))

        {
            // Only enable the button if the Archive folder is not the current folder and not NONE.
            boolean enableArchive = !mMessageReference.folderName.equals(mAccount.getArchiveFolderName()) &&
                                    !K9.FOLDER_NONE.equalsIgnoreCase(mAccount.getArchiveFolderName());
            boolean enableMove = true;
            // Only enable the button if the Spam folder is not the current folder and not NONE.
            boolean enableSpam = !mMessageReference.folderName.equals(mAccount.getSpamFolderName()) &&
                                 !K9.FOLDER_NONE.equalsIgnoreCase(mAccount.getSpamFolderName());
            mArchive.setEnabled(enableArchive);
            mMove.setEnabled(enableMove);
            mSpam.setEnabled(enableSpam);
            mArchiveScrolling.setEnabled(enableArchive);
            mMoveScrolling.setEnabled(enableMove);
            mSpamScrolling.setEnabled(enableSpam);
        }
        else
        {
            disableMoveButtons();
        }


    }

    private void showButtons()
    {
        View buttons = findViewById(R.id.scrolling_buttons);
        if (buttons != null)
        {
            buttons.setVisibility(View.GONE);
        }
    }

    private void hideButtons()
    {
        View buttons = findViewById(R.id.bottom_buttons);
        if (buttons != null)
        {
            buttons.setVisibility(View.GONE);
        }
    }

    private void showMoveButtons()
    {
        View buttons = findViewById(R.id.scrolling_move_buttons);
        if (buttons != null)
        {
            buttons.setVisibility(View.GONE);
        }
    }

    private void hideMoveButtons()
    {
        View buttons = findViewById(R.id.move_buttons);
        if (buttons != null)
        {
            buttons.setVisibility(View.GONE);
        }
    }

    private void disableButtons()
    {
        setLoadPictures(false);
        disableMoveButtons();
        next.setEnabled(false);
        next_scrolling.setEnabled(false);
        previous.setEnabled(false);
        previous_scrolling.setEnabled(false);
        mDelete.setEnabled(false);
    }

    private void disableMoveButtons()
    {
        mArchive.setEnabled(false);
        mMove.setEnabled(false);
        mSpam.setEnabled(false);
        mArchiveScrolling.setEnabled(false);
        mMoveScrolling.setEnabled(false);
        mSpamScrolling.setEnabled(false);
    }


    private void setOnClickListener(int viewCode)
    {
        View thisView = findViewById(viewCode);
        if (thisView != null)
        {
            thisView.setOnClickListener(this);
        }
    }

    private void findSurroundingMessagesUid()
    {
        mNextMessage = mPreviousMessage = null;
        int i = mMessageReferences.indexOf(mMessageReference);
        if (i < 0)
            return;
        if (i != 0)
            mNextMessage = mMessageReferences.get(i - 1);
        if (i != (mMessageReferences.size() - 1))
            mPreviousMessage = mMessageReferences.get(i + 1);
    }

    @Override
    public void onResume()
    {
        super.onResume();
    }

    /**
     * Called from UI thread when user select Delete
     */
    private void onDelete()
    {
        if (K9.confirmDelete())
        {
            showDialog(R.id.dialog_confirm_delete);
        }
        else
        {
            delete();
        }
    }

    /**
     * @param id
     * @return Never <code>null</code>
     */
    protected Dialog createConfirmDeleteDialog(final int id)
    {
        final AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle(R.string.dialog_confirm_delete_title);
        builder.setMessage(R.string.dialog_confirm_delete_message);
        builder.setPositiveButton(R.string.dialog_confirm_delete_confirm_button,
                new DialogInterface.OnClickListener()
                {
                    @Override
                    public void onClick(DialogInterface dialog, int which)
                    {
                        dismissDialog(id);
                        delete();
                    }
                });
        builder.setNegativeButton(R.string.dialog_confirm_delete_cancel_button,
                new DialogInterface.OnClickListener()
                {
                    @Override
                    public void onClick(DialogInterface dialog, int which)
                    {
                        dismissDialog(id);
                    }
                });
        final AlertDialog dialog = builder.create();
        return dialog;
    }

    private void delete()
    {
        if (mMessage != null)
        {
            // Disable the delete button after it's tapped (to try to prevent
            // accidental clicks)
            disableButtons();
            Message messageToDelete = mMessage;

            showNextMessageOrReturn();

            MessagingController.getInstance(getApplication()).deleteMessages(
                new Message[] { messageToDelete },
                null);
        }
    }

    private void onArchive()
    {
        if (!MessagingController.getInstance(getApplication()).isMoveCapable(mAccount))
        {
            return;
        }
        if (!MessagingController.getInstance(getApplication()).isMoveCapable(mMessage))
        {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }

        String srcFolder = mMessageReference.folderName;
        String dstFolder = mAccount.getArchiveFolderName();
        Message messageToMove = mMessage;
        if (K9.FOLDER_NONE.equalsIgnoreCase(dstFolder))
        {
            return;
        }
        showNextMessageOrReturn();
        MessagingController.getInstance(getApplication())
        .moveMessage(mAccount, srcFolder, messageToMove, dstFolder, null);
    }

    private void onSpam()
    {
        if (!MessagingController.getInstance(getApplication()).isMoveCapable(mAccount))
        {
            return;
        }
        if (!MessagingController.getInstance(getApplication()).isMoveCapable(mMessage))
        {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }

        String srcFolder = mMessageReference.folderName;
        String dstFolder = mAccount.getSpamFolderName();
        Message messageToMove = mMessage;
        if (K9.FOLDER_NONE.equalsIgnoreCase(dstFolder))
        {
            return;
        }
        showNextMessageOrReturn();
        MessagingController.getInstance(getApplication())
        .moveMessage(mAccount, srcFolder, messageToMove, dstFolder, null);
    }

    private void showNextMessageOrReturn()
    {
        if (K9.messageViewReturnToList())
        {
            finish();
        }
        else
        {
            showNextMessage();
        }
    }

    private void showNextMessage()
    {
        findSurroundingMessagesUid();
        mMessageReferences.remove(mMessageReference);

        if (mLastDirection == NEXT && mNextMessage != null)
        {
            onNext(K9.showAnimations());
        }
        else if (mLastDirection == PREVIOUS && mPreviousMessage != null)
        {
            onPrevious(K9.showAnimations());
        }
        else if (mNextMessage != null)
        {
            onNext(K9.showAnimations());
        }
        else if (mPreviousMessage != null)
        {
            onPrevious(K9.showAnimations());
        }
        else
        {
            finish();
        }
    }

    private void onClickSender()
    {
        if (mMessage != null)
        {
            try
            {
                final Address senderEmail = mMessage.getFrom()[0];
                mContacts.createContact(this, senderEmail);

                Address.clearContactsNameCache();
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Couldn't create contact"", e);
            }
        }
    }

    private void onReply()
    {
        if (mMessage != null)
        {
            MessageCompose.actionReply(this, mAccount, mMessage, false, mPgpData.getDecryptedData());
            finish();
        }
    }

    private void onReplyAll()
    {
        if (mMessage != null)
        {
            MessageCompose.actionReply(this, mAccount, mMessage, true, mPgpData.getDecryptedData());
            finish();
        }
    }

    private void onForward()
    {
        if (mMessage != null)
        {
            MessageCompose.actionForward(this, mAccount, mMessage, mPgpData.getDecryptedData());
            finish();
        }
    }

    private void onFlag()
    {
        if (mMessage != null)
        {
            MessagingController.getInstance(getApplication()).setFlag(mAccount,
                    mMessage.getFolder().getName(), new String[] { mMessage.getUid() }, Flag.FLAGGED, !mMessage.isSet(Flag.FLAGGED));
            try
            {
                mMessage.setFlag(Flag.FLAGGED, !mMessage.isSet(Flag.FLAGGED));
                setHeaders(mAccount, mMessage.getFolder().getName(), mMessage.getUid(), mMessage);
                prepareMenuItems();
            }
            catch (MessagingException me)
            {
                Log.e(K9.LOG_TAG, ""Could not set flag on local message"", me);
            }
        }
    }

    private void onMove()
    {
        if ((!MessagingController.getInstance(getApplication()).isMoveCapable(mAccount))
                || (mMessage == null))
        {
            return;
        }
        if (!MessagingController.getInstance(getApplication()).isMoveCapable(mMessage))
        {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }
        Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, mMessageReference.folderName);
        intent.putExtra(ChooseFolder.EXTRA_SEL_FOLDER, mAccount.getLastSelectedFolderName());
        intent.putExtra(ChooseFolder.EXTRA_MESSAGE, mMessageReference);
        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_MOVE);
    }

    private void onCopy()
    {
        if ((!MessagingController.getInstance(getApplication()).isCopyCapable(mAccount))
                || (mMessage == null))
        {
            return;
        }
        if (!MessagingController.getInstance(getApplication()).isCopyCapable(mMessage))
        {
            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
            toast.show();
            return;
        }
        Intent intent = new Intent(this, ChooseFolder.class);
        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());
        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, mMessageReference.folderName);
        intent.putExtra(ChooseFolder.EXTRA_SEL_FOLDER, mAccount.getLastSelectedFolderName());
        intent.putExtra(ChooseFolder.EXTRA_MESSAGE, mMessageReference);
        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_COPY);
    }

    private void onShowAdditionalHeaders()
    {
        int currentVisibility = mAdditionalHeadersView.getVisibility();

        if (currentVisibility == View.VISIBLE)
        {
            mHandler.hideAdditionalHeaders();
        }
        else
        {
            mHandler.showAdditionalHeaders();
        }
    }

    private List<HeaderEntry> getAdditionalHeaders(final Message message)
    throws MessagingException
    {
        List<HeaderEntry> additionalHeaders = new LinkedList<HeaderEntry>();

        /*
         * Remove ""Subject"" header as it is already shown in the standard
         * message view header. But do show ""From"", ""To"", and ""Cc"" again.
         * This time including the email addresses. See issue 1805.
         */
        Set<String> headerNames = new HashSet<String>(message.getHeaderNames());
        headerNames.remove(""Subject"");

        for (String headerName : headerNames)
        {
            String[] headerValues = message.getHeader(headerName);
            for (String headerValue : headerValues)
            {
                additionalHeaders.add(new HeaderEntry(headerName, headerValue));
            }
        }
        return additionalHeaders;
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        if (mAccount.getCryptoProvider().onActivityResult(this, requestCode, resultCode, data, mPgpData))
        {
            return;
        }

        if (resultCode != RESULT_OK)
            return;

        switch (requestCode)
        {
            case ACTIVITY_CHOOSE_FOLDER_MOVE:
            case ACTIVITY_CHOOSE_FOLDER_COPY:
                if (data == null)
                    return;
                String destFolderName = data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER);
                String srcFolderName = data.getStringExtra(ChooseFolder.EXTRA_CUR_FOLDER);
                MessageReference ref = (MessageReference)data.getSerializableExtra(ChooseFolder.EXTRA_MESSAGE);

                if (mMessageReference.equals(ref))
                {
                    mAccount.setLastSelectedFolderName(destFolderName);

                    switch (requestCode)
                    {
                        case ACTIVITY_CHOOSE_FOLDER_MOVE:
                            Message messageToMove = mMessage;

                            showNextMessageOrReturn();

                            MessagingController.getInstance(getApplication()).moveMessage(mAccount,
                                    srcFolderName, messageToMove, destFolderName, null);
                            break;
                        case ACTIVITY_CHOOSE_FOLDER_COPY:
                            MessagingController.getInstance(getApplication()).copyMessage(mAccount,
                                    srcFolderName, mMessage, destFolderName, null);
                            break;
                    }
                }
                break;


        }
    }


    private void onSendAlternate()
    {
        if (mMessage != null)
        {
            MessagingController.getInstance(getApplication()).sendAlternate(this, mAccount, mMessage);

        }
    }

    @Override
    protected void onNext(boolean animate)
    {
        if (mNextMessage == null)
        {
            Toast.makeText(this, getString(R.string.end_of_folder), Toast.LENGTH_SHORT).show();
            return;
        }
        mLastDirection = NEXT;

        disableButtons();

        if (animate)
        {
            mTopView.startAnimation(outToLeftAnimation());
        }


        displayMessage(mNextMessage);
        next.requestFocus();
    }

    @Override
    protected void onPrevious(boolean animate)
    {
        if (mPreviousMessage == null)
        {
            Toast.makeText(this, getString(R.string.end_of_folder), Toast.LENGTH_SHORT).show();
            return;
        }

        mLastDirection = PREVIOUS;

        disableButtons();

        if (animate)
        {
            mTopView.startAnimation(inFromRightAnimation());
        }
        displayMessage(mPreviousMessage);
        previous.requestFocus();
    }

    private void onMarkAsUnread()
    {
        if (mMessage != null)
        {
            MessagingController.getInstance(getApplication()).setFlag(
                mAccount,
                mMessageReference.folderName,
                new String[] { mMessage.getUid() },
                Flag.SEEN,
                false);
            try
            {
                mMessage.setFlag(Flag.SEEN, false);
                setHeaders(mAccount, mMessage.getFolder().getName(), mMessage.getUid(), mMessage);
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to unset SEEN flag on message"", e);
            }
        }
    }

    /**
     * Creates a unique file in the given directory by appending a hyphen
     * and a number to the given filename.
     * @param directory
     * @param filename
     * @return
     */
    private File createUniqueFile(File directory, String filename)
    {
        File file = new File(directory, filename);
        if (!file.exists())
        {
            return file;
        }
        // Get the extension of the file, if any.
        int index = filename.lastIndexOf('.');
        String format;
        if (index != -1)
        {
            String name = filename.substring(0, index);
            String extension = filename.substring(index);
            format = name + ""-%d"" + extension;
        }
        else
        {
            format = filename + ""-%d"";
        }
        for (int i = 2; i < Integer.MAX_VALUE; i++)
        {
            file = new File(directory, String.format(format, i));
            if (!file.exists())
            {
                return file;
            }
        }
        return null;
    }

    private void onDownloadRemainder()
    {
        if (mMessage.isSet(Flag.X_DOWNLOADED_FULL))
        {
            return;
        }



        mDownloadRemainder.setEnabled(false);
        MessagingController.getInstance(getApplication()).loadMessageForViewRemote(
            mAccount,
            mMessageReference.folderName,
            mMessageReference.uid,
            mListener);

    }

    private void onDownloadAttachment(Attachment attachment)
    {
        if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))
        {
            /*
             * Abort early if there's no place to save the attachment. We don't want to spend
             * the time downloading it and then abort.
             */
            Toast.makeText(this,
                           getString(R.string.message_view_status_attachment_not_saved),
                           Toast.LENGTH_SHORT).show();
            return;
        }
        if (mMessage != null)
        {
            MessagingController.getInstance(getApplication()).loadAttachment(
                mAccount,
                mMessage,
                attachment.part,
                new Object[] { true, attachment },
                mListener);
        }
    }

    private void onViewAttachment(Attachment attachment)
    {
        if (mMessage != null)
        {
            MessagingController.getInstance(getApplication()).loadAttachment(
                mAccount,
                mMessage,
                attachment.part,
                new Object[] { false, attachment },
                mListener);
        }
    }

    private void onShowPictures()
    {
        // TODO: Download attachments that are used as inline image

        setLoadPictures(true);
    }

    /**
     * Enable/disable image loading of the WebView. But always hide the
     * ""Show pictures"" button!
     *
     * @param enable true, if (network) images should be loaded.
     *               false, otherwise.
     */
    private void setLoadPictures(boolean enable)
    {
        K9.setBlockNetworkLoads(mMessageContentView.getSettings(), !enable);
        mMessageContentView.getSettings().setBlockNetworkImage(!enable);
        mShowPictures = enable;
        mHandler.showShowPictures(false);
    }

    public void onClick(View view)
    {
        switch (view.getId())
        {
            case R.id.from:
                onClickSender();
                break;
            case R.id.reply:
            case R.id.reply_scrolling:
                onReply();
                break;
            case R.id.reply_all:
                onReplyAll();
                break;
            case R.id.delete:
            case R.id.delete_scrolling:
                onDelete();
                break;
            case R.id.forward:
            case R.id.forward_scrolling:
                onForward();
                break;
            case R.id.archive:
            case R.id.archive_scrolling:
                onArchive();
                break;
            case R.id.spam:
            case R.id.spam_scrolling:
                onSpam();
                break;
            case R.id.move:
            case R.id.move_scrolling:
                onMove();
                break;
            case R.id.next:
            case R.id.next_scrolling:
                onNext(K9.showAnimations());
                break;
            case R.id.previous:
            case R.id.previous_scrolling:
                onPrevious(K9.showAnimations());
                break;
            case R.id.download:
                onDownloadAttachment((Attachment) view.getTag());
                break;
            case R.id.view:
                onViewAttachment((Attachment) view.getTag());
                break;
            case R.id.show_pictures:
                onShowPictures();
                break;
            case R.id.header_container:
                onShowAdditionalHeaders();
                break;
            case R.id.download_remainder:
                onDownloadRemainder();
                break;
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item)
    {
        switch (item.getItemId())
        {
            case R.id.delete:
                onDelete();
                break;
            case R.id.reply:
                onReply();
                break;
            case R.id.reply_all:
                onReplyAll();
                break;
            case R.id.forward:
                onForward();
                break;
            case R.id.send_alternate:
                onSendAlternate();
                break;
            case R.id.mark_as_unread:
                onMarkAsUnread();
                break;
            case R.id.flag:
                onFlag();
                break;
            case R.id.archive:
                onArchive();
                break;
            case R.id.spam:
                onSpam();
                break;
            case R.id.move:
                onMove();
                break;
            case R.id.copy:
                onCopy();
                break;
            case R.id.show_full_header:
                onShowAdditionalHeaders();
                break;
            case R.id.select_text:
                emulateShiftHeld(mMessageContentView);
                break;
            default:
                return super.onOptionsItemSelected(item);
        }
        return true;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu)
    {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.message_view_option, menu);
        optionsMenu = menu;
        prepareMenuItems();
        if (!MessagingController.getInstance(getApplication()).isCopyCapable(mAccount))
        {
            menu.findItem(R.id.copy).setVisible(false);
        }
        if (!MessagingController.getInstance(getApplication()).isMoveCapable(mAccount))
        {
            menu.findItem(R.id.move).setVisible(false);
            menu.findItem(R.id.archive).setVisible(false);
            menu.findItem(R.id.spam).setVisible(false);
        }
        if (K9.FOLDER_NONE.equalsIgnoreCase(mAccount.getArchiveFolderName()))
        {
            menu.findItem(R.id.archive).setVisible(false);
        }
        if (K9.FOLDER_NONE.equalsIgnoreCase(mAccount.getSpamFolderName()))
        {
            menu.findItem(R.id.spam).setVisible(false);
        }
        return true;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu)
    {
        prepareMenuItems();
        return super.onPrepareOptionsMenu(menu);
    }

    // XXX when switching to API version 8, override onCreateDialog(int, Bundle)
    /**
     * @param id
     *            The id of the dialog.
     * @return The dialog. If you return null, the dialog will not be created.
     * @see android.app.Activity#onCreateDialog(int, Bundle)
     */
    @Override
    protected Dialog onCreateDialog(final int id)
    {
        switch (id)
        {
            case R.id.dialog_confirm_delete:
            {
                final Dialog dialog = createConfirmDeleteDialog(id);
                return dialog;
            }
        }
        return super.onCreateDialog(id);
    }

    private void prepareMenuItems()
    {
        Menu menu = optionsMenu;
        if (menu != null)
        {
            MenuItem flagItem = menu.findItem(R.id.flag);
            if (flagItem != null && mMessage != null)
            {
                flagItem.setTitle((mMessage.isSet(Flag.FLAGGED) ? R.string.unflag_action : R.string.flag_action));
            }

            MenuItem additionalHeadersItem = menu.findItem(R.id.show_full_header);
            if (additionalHeadersItem != null)
            {
                additionalHeadersItem.setTitle((mAdditionalHeadersView.getVisibility() == View.VISIBLE) ?
                                               R.string.hide_full_header_action : R.string.show_full_header_action);
            }
        }
    }

    private Bitmap getPreviewIcon(Attachment attachment) throws MessagingException
    {
        try
        {
            return BitmapFactory.decodeStream(
                       getContentResolver().openInputStream(
                           AttachmentProvider.getAttachmentThumbnailUri(mAccount,
                                   attachment.part.getAttachmentId(),
                                   62,
                                   62)));
        }
        catch (Exception e)
        {
            /*
             * We don't care what happened, we just return null for the preview icon.
             */
            return null;
        }
    }

    /*
     * Formats the given size as a String in bytes, kB, MB or GB with a single digit
     * of precision. Ex: 12,315,000 = 12.3 MB
     */
    public static String formatSize(float size)
    {
        long kb = 1024;
        long mb = (kb * 1024);
        long gb  = (mb * 1024);
        if (size < kb)
        {
            return String.format(""%d bytes"", (int) size);
        }
        else if (size < mb)
        {
            return String.format(""%.1f kB"", size / kb);
        }
        else if (size < gb)
        {
            return String.format(""%.1f MB"", size / mb);
        }
        else
        {
            return String.format(""%.1f GB"", size / gb);
        }
    }

    private void renderAttachments(Part part, int depth) throws MessagingException
    {
        String contentType = MimeUtility.unfoldAndDecode(part.getContentType());
        String contentDisposition = MimeUtility.unfoldAndDecode(part.getDisposition());
        String name = MimeUtility.getHeaderParameter(contentType, ""name"");


        // Inline parts with a content-id are almost certainly components of an HTML message
        // not attachments. Don't show attachment download buttons for them.

        if (contentDisposition != null &&
                MimeUtility.getHeaderParameter(contentDisposition, null).matches(""^(?i:inline)"")
                && part.getHeader(""Content-ID"") != null)
        {
            return;
        }

        if (name == null)
        {
            name = MimeUtility.getHeaderParameter(contentDisposition, ""filename"");
        }
        if (name != null)
        {
            /*
             * We're guaranteed size because LocalStore.fetch puts it there.
             */
            int size = Integer.parseInt(MimeUtility.getHeaderParameter(contentDisposition, ""size""));

            Attachment attachment = new Attachment();
            attachment.size = size;
            String mimeType = part.getMimeType();
            if (MimeUtility.DEFAULT_ATTACHMENT_MIME_TYPE.equals(mimeType))
            {
                mimeType = MimeUtility.getMimeTypeByExtension(name);
            }
            attachment.contentType = mimeType;
            attachment.name = name;
            attachment.part = (LocalAttachmentBodyPart) part;

            LayoutInflater inflater = getLayoutInflater();
            View view = inflater.inflate(R.layout.message_view_attachment, null);

            TextView attachmentName = (TextView)view.findViewById(R.id.attachment_name);
            TextView attachmentInfo = (TextView)view.findViewById(R.id.attachment_info);
            ImageView attachmentIcon = (ImageView)view.findViewById(R.id.attachment_icon);
            Button attachmentView = (Button)view.findViewById(R.id.view);
            Button attachmentDownload = (Button)view.findViewById(R.id.download);

            if ((!MimeUtility.mimeTypeMatches(attachment.contentType,
                                              K9.ACCEPTABLE_ATTACHMENT_VIEW_TYPES))
                    || (MimeUtility.mimeTypeMatches(attachment.contentType,
                                                    K9.UNACCEPTABLE_ATTACHMENT_VIEW_TYPES)))
            {
                attachmentView.setVisibility(View.GONE);
            }
            if ((!MimeUtility.mimeTypeMatches(attachment.contentType,
                                              K9.ACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES))
                    || (MimeUtility.mimeTypeMatches(attachment.contentType,
                                                    K9.UNACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES)))
            {
                attachmentDownload.setVisibility(View.GONE);
            }

            if (attachment.size > K9.MAX_ATTACHMENT_DOWNLOAD_SIZE)
            {
                attachmentView.setVisibility(View.GONE);
                attachmentDownload.setVisibility(View.GONE);
            }

            attachment.viewButton = attachmentView;
            attachment.downloadButton = attachmentDownload;
            attachment.iconView = attachmentIcon;

            view.setTag(attachment);
            attachmentView.setOnClickListener(this);
            attachmentView.setTag(attachment);
            attachmentDownload.setOnClickListener(this);
            attachmentDownload.setTag(attachment);

            attachmentName.setText(name);
            attachmentInfo.setText(formatSize(size));

            Bitmap previewIcon = getPreviewIcon(attachment);
            if (previewIcon != null)
            {
                attachmentIcon.setImageBitmap(previewIcon);
            }
            else
            {
                attachmentIcon.setImageResource(R.drawable.attached_image_placeholder);
            }

            mHandler.addAttachment(view);
        }

        if (part.getBody() instanceof Multipart)
        {
            Multipart mp = (Multipart)part.getBody();
            for (int i = 0; i < mp.getCount(); i++)
            {
                renderAttachments(mp.getBodyPart(i), depth + 1);
            }
        }
    }

    private void setHeaders(Account account, String folder, String uid,
                            final Message message) throws MessagingException
    {
        String subjectText = message.getSubject();
        CharSequence fromText = Address.toFriendly(message.getFrom(), mContacts);
        String dateText = getDateFormat().format(message.getSentDate());
        String timeText = getTimeFormat().format(message.getSentDate());
        CharSequence toText = Address.toFriendly(message.getRecipients(RecipientType.TO), mContacts);
        CharSequence ccText = Address.toFriendly(message.getRecipients(RecipientType.CC), mContacts);

        int color = mAccount.getChipColor();
        boolean hasAttachments = ((LocalMessage) message).getAttachmentCount() > 0;
        boolean unread = !message.isSet(Flag.SEEN);

        mHandler.setHeaders(subjectText,
                            fromText,
                            dateText,
                            timeText,
                            toText,
                            ccText,
                            color,
                            unread,
                            hasAttachments,
                            message.isSet(Flag.FLAGGED),
                            message.isSet(Flag.ANSWERED));

        // Update additional headers display, if visible
        if (mAdditionalHeadersView.getVisibility() == View.VISIBLE)
        {
            mHandler.showAdditionalHeaders();
        }
    }

    class Listener extends MessagingListener
    {

        @Override
        public void loadMessageForViewHeadersAvailable(Account account, String folder, String uid,
                final Message message)
        {
            if (!mMessageReference.uid.equals(uid) || !mMessageReference.folderName.equals(folder)
                    || !mMessageReference.accountUuid.equals(account.getUuid()))
            {
                return;
            }

            MessageView.this.mMessage = message;


            if (!message.isSet(Flag.X_DOWNLOADED_FULL)
                    && !message.isSet(Flag.X_DOWNLOADED_PARTIAL))
            {
                mHandler.post(new Runnable()
                {
                    public void run()
                    {
                        mMessageContentView.loadUrl(""file:///android_asset/downloading.html"");
                        updateDecryptLayout();
                    }
                });
            }
            try
            {
                setHeaders(account, folder, uid, message);
                mHandler.showHeaderContainer();
            }
            catch (MessagingException me)
            {
                Log.e(K9.LOG_TAG, ""loadMessageForViewHeadersAvailable"", me);
            }
        }

        @Override
        public void loadMessageForViewBodyAvailable(Account account, String folder, String uid,
                Message message)
        {
            if (!mMessageReference.uid.equals(uid) || !mMessageReference.folderName.equals(folder)
                    || !mMessageReference.accountUuid.equals(account.getUuid()))
            {
                return;
            }

            try
            {
                if (MessageView.this.mMessage!=null
                        && MessageView.this.mMessage.isSet(Flag.X_DOWNLOADED_PARTIAL)
                        && message.isSet(Flag.X_DOWNLOADED_FULL))
                {

                    setHeaders(account, folder, uid, message);
                    mHandler.showHeaderContainer();
                }

                MessageView.this.mMessage = message;


                mHandler.removeAllAttachments();

                String text;
                String type = ""text/html"";
                if (mPgpData.getDecryptedData() != null)
                {
                    text = mPgpData.getDecryptedData();
                    type = ""text/plain"";
                }
                else
                {
                    Part part = MimeUtility.findFirstPartByMimeType(mMessage, ""text/html"");
                    if (part == null)
                    {
                        part = MimeUtility.findFirstPartByMimeType(mMessage, ""text/plain"");
                        if (part == null)
                        {
                            text = null;
                        }
                        else
                        {
                            LocalTextBody body = (LocalTextBody)part.getBody();
                            if (body == null)
                            {
                                text = null;
                            }
                            else
                            {
                                text = body.getBodyForDisplay();
                            }
                        }
                    }
                    else
                    {
                        text = MimeUtility.getTextFromPart(part);
                    }
                }

                if (text != null)
                {
                    final String emailText = text;
                    final String mimeType = type;
                    mHandler.post(new Runnable()
                    {
                        public void run()
                        {
                            mTopView.scrollTo(0, 0);
                            if (mScreenReaderEnabled)
                            {
                                mAccessibleMessageContentView.loadDataWithBaseURL(""http://"",
                                        emailText, ""text/html"", ""utf-8"", null);
                            }
                            else
                            {
                                mMessageContentView.loadDataWithBaseURL(""http://"", emailText,
                                                                        ""text/html"", ""utf-8"", null);
                                mMessageContentView.scrollTo(0, 0);
                            }
                            updateDecryptLayout();
                        }
                    });

                    // If the message contains external pictures and the ""Show pictures""
                    // button wasn't already pressed, see if the user's preferences has us
                    // showing them anyway.
                    if (hasExternalImages(text) && !mShowPictures)
                    {
                        if ((account.getShowPictures() == Account.ShowPictures.ALWAYS) ||
                                ((account.getShowPictures() == Account.ShowPictures.ONLY_FROM_CONTACTS) &&
                                 mContacts.isInContacts(message.getFrom()[0].getAddress())))
                        {
                            onShowPictures();
                        }
                        else
                        {
                            mHandler.showShowPictures(true);
                        }
                    }
                }
                else
                {
                    mHandler.post(new Runnable()
                    {
                        public void run()
                        {
                            mMessageContentView.loadUrl(""file:///android_asset/empty.html"");
                            updateDecryptLayout();
                        }
                    });
                }

                renderAttachments(mMessage, 0);
            }
            catch (Exception e)
            {
                if (Config.LOGV)
                {
                    Log.v(K9.LOG_TAG, ""loadMessageForViewBodyAvailable"", e);
                }
            }
        }//loadMessageForViewBodyAvailable

        private static final String IMG_SRC_REGEX = ""(?is:<img[^>]+src\\s*=\\s*['\""]?([a-z]+)\\:)"";
        private final Pattern mImgPattern = Pattern.compile(IMG_SRC_REGEX);
        private boolean hasExternalImages(final String message)
        {
            Matcher imgMatches = mImgPattern.matcher(message);
            while (imgMatches.find())
            {
                if (!imgMatches.group(1).equals(""content""))
                {
                    if (K9.DEBUG)
                    {
                        Log.d(K9.LOG_TAG, ""External images found"");
                    }
                    return true;
                }
            }
            if (K9.DEBUG)
            {
                Log.d(K9.LOG_TAG, ""No external images."");
            }
            return false;
        }

        @Override
        public void loadMessageForViewFailed(Account account, String folder, String uid,
                                             final Throwable t)
        {
            if (!mMessageReference.uid.equals(uid) || !mMessageReference.folderName.equals(folder)
                    || !mMessageReference.accountUuid.equals(account.getUuid()))
            {
                return;
            }

            mHandler.post(new Runnable()
            {
                public void run()
                {
                    setProgressBarIndeterminateVisibility(false);
                    if (t instanceof IllegalArgumentException)
                    {
                        mHandler.invalidIdError();
                    }
                    else
                    {
                        mHandler.networkError();
                    }
                    if ((MessageView.this.mMessage == null) ||
                            !MessageView.this.mMessage.isSet(Flag.X_DOWNLOADED_PARTIAL))
                    {
                        mMessageContentView.loadUrl(""file:///android_asset/empty.html"");
                        updateDecryptLayout();
                    }
                }
            });
        }

        @Override
        public void loadMessageForViewFinished(Account account, String folder, String uid,
                                               Message message)
        {
            if (!mMessageReference.uid.equals(uid) || !mMessageReference.folderName.equals(folder)
                    || !mMessageReference.accountUuid.equals(account.getUuid()))
            {
                return;
            }

            mHandler.post(new Runnable()
            {
                public void run()
                {
                    setProgressBarIndeterminateVisibility(false);
                }
            });
        }

        @Override
        public void loadMessageForViewStarted(Account account, String folder, String uid)
        {
            if (!mMessageReference.uid.equals(uid) || !mMessageReference.folderName.equals(folder)
                    || !mMessageReference.accountUuid.equals(account.getUuid()))
            {
                return;
            }

            mHandler.post(new Runnable()
            {
                public void run()
                {
                    updateDecryptLayout();
                    setProgressBarIndeterminateVisibility(true);
                }
            });
        }

        @Override
        public void loadAttachmentStarted(Account account, Message message,
                                          Part part, Object tag, boolean requiresDownload)
        {
            if (mMessage!=message)
            {
                return;
            }

            mHandler.setAttachmentsEnabled(false);
            mHandler.progress(true);
            if (requiresDownload)
            {
                mHandler.fetchingAttachment();
            }
        }

        @Override
        public void loadAttachmentFinished(Account account, Message message,
                                           Part part, Object tag)
        {
            if (mMessage!=message)
            {
                return;
            }

            mHandler.setAttachmentsEnabled(true);
            mHandler.progress(false);

            Object[] params = (Object[]) tag;
            boolean download = (Boolean) params[0];
            Attachment attachment = (Attachment) params[1];

            if (download)
            {
                try
                {
                    File file = createUniqueFile(Environment.getExternalStorageDirectory(),
                                                 attachment.name);
                    Uri uri = AttachmentProvider.getAttachmentUri(
                                  mAccount,
                                  attachment.part.getAttachmentId());
                    InputStream in = getContentResolver().openInputStream(uri);
                    OutputStream out = new FileOutputStream(file);
                    IOUtils.copy(in, out);
                    out.flush();
                    out.close();
                    in.close();
                    mHandler.attachmentSaved(file.getName());
                    new MediaScannerNotifier(MessageView.this, file);
                }
                catch (IOException ioe)
                {
                    mHandler.attachmentNotSaved();
                }
            }
            else
            {
                Uri uri = AttachmentProvider.getAttachmentUri(
                              mAccount,
                              attachment.part.getAttachmentId());
                Intent intent = new Intent(Intent.ACTION_VIEW);
                intent.setData(uri);
                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
                try
                {
                    startActivity(intent);
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Could not display attachment of type "" + attachment.contentType, e);
                    Toast toast = Toast.makeText(MessageView.this, getString(R.string.message_view_no_viewer, attachment.contentType), Toast.LENGTH_LONG);
                    toast.show();
                }
            }
        }

        @Override
        public void loadAttachmentFailed(Account account, Message message, Part part,
                                         Object tag, String reason)
        {
            if (mMessage!=message)
            {
                return;
            }

            mHandler.setAttachmentsEnabled(true);
            mHandler.progress(false);
            mHandler.networkError();
        }
    }

    class MediaScannerNotifier implements MediaScannerConnectionClient
    {
        private MediaScannerConnection mConnection;
        private File mFile;

        public MediaScannerNotifier(Context context, File file)
        {
            mFile = file;
            mConnection = new MediaScannerConnection(context, this);
            mConnection.connect();
        }

        public void onMediaScannerConnected()
        {
            mConnection.scanFile(mFile.getAbsolutePath(), null);
        }

        public void onScanCompleted(String path, Uri uri)
        {
            try
            {
                if (uri != null)
                {
                    Intent intent = new Intent(Intent.ACTION_VIEW);
                    intent.setData(uri);
                    startActivity(intent);
                }
            }
            finally
            {
                mConnection.disconnect();
            }
        }
    }


    private Animation inFromRightAnimation()
    {
        return slideAnimation(0.0f, +1.0f);
    }

    private Animation outToLeftAnimation()
    {
        return slideAnimation(0.0f, -1.0f);
    }

    private Animation slideAnimation(float right, float left)
    {

        Animation slide = new TranslateAnimation(
            Animation.RELATIVE_TO_PARENT,  right, Animation.RELATIVE_TO_PARENT,  left,
            Animation.RELATIVE_TO_PARENT,  0.0f, Animation.RELATIVE_TO_PARENT,   0.0f
        );
        slide.setDuration(125);
        slide.setFillBefore(true);
        slide.setInterpolator(new AccelerateInterpolator());
        return slide;
    }

    private void initializeCrypto()
    {
        if (mPgpData != null)
        {
            return;
        }
        if (mAccount == null)
        {
            mAccount = Preferences.getPreferences(this).getAccount(mMessageReference.accountUuid);
        }
        mPgpData = new PgpData();
    }

    /**
     * Fill the decrypt layout with signature data, if known, make controls visible, if
     * they should be visible.
     */
    public void updateDecryptLayout()
    {
        if (mPgpData.getSignatureKeyId() != 0)
        {
            mCryptoSignatureUserIdRest.setText(
                getString(R.string.key_id, Long.toHexString(mPgpData.getSignatureKeyId() & 0xffffffffL)));
            String userId = mPgpData.getSignatureUserId();
            if (userId == null)
            {
                userId = getString(R.string.unknown_crypto_signature_user_id);
            }
            String chunks[] = userId.split("" <"", 2);
            String name = chunks[0];
            if (chunks.length > 1)
            {
                mCryptoSignatureUserIdRest.setText(""<"" + chunks[1]);
            }
            mCryptoSignatureUserId.setText(name);

            if (mPgpData.getSignatureSuccess())
            {
                mCryptoSignatureStatusImage.setImageResource(R.drawable.overlay_ok);
            }
            else if (mPgpData.getSignatureUnknown())
            {
                mCryptoSignatureStatusImage.setImageResource(R.drawable.overlay_error);
            }
            else
            {
                mCryptoSignatureStatusImage.setImageResource(R.drawable.overlay_error);
            }
            mCryptoSignatureLayout.setVisibility(View.VISIBLE);
            mDecryptLayout.setVisibility(View.VISIBLE);
        }
        else
        {
            mCryptoSignatureLayout.setVisibility(View.INVISIBLE);
        }

        if (false || ((mMessage == null) && (mPgpData.getDecryptedData() == null)))
        {
            mDecryptLayout.setVisibility(View.GONE);
            return;
        }

        if (mPgpData.getDecryptedData() != null)
        {
            if (mPgpData.getSignatureKeyId() == 0)
            {
                mDecryptLayout.setVisibility(View.GONE);
            }
            else
            {
                // no need to show this after decryption/verification
                mDecryptButton.setVisibility(View.GONE);
            }
            return;
        }

        mDecryptButton.setVisibility(View.VISIBLE);

        CryptoProvider crypto = mAccount.getCryptoProvider();
        if (crypto.isEncrypted(mMessage))
        {
            mDecryptButton.setText(R.string.btn_decrypt);
            mDecryptLayout.setVisibility(View.VISIBLE);
        }
        else if (crypto.isSigned(mMessage))
        {
            mDecryptButton.setText(R.string.btn_verify);
            mDecryptLayout.setVisibility(View.VISIBLE);
        }
        else
        {
            mDecryptLayout.setVisibility(View.GONE);
            try
            {
                // check for PGP/MIME encryption
                Part pgp = MimeUtility.findFirstPartByMimeType(mMessage, ""application/pgp-encrypted"");
                if (pgp != null)
                {
                    Toast.makeText(this, R.string.pgp_mime_unsupported, Toast.LENGTH_LONG).show();
                }
            }
            catch (MessagingException e)
            {
                // nothing to do...
            }
        }
    }

    public void onDecryptDone()
    {
        // TODO: this might not be enough if the orientation was changed while in APG,
        // sometimes shows the original encrypted content
        mMessageContentView.loadDataWithBaseURL(""email://"", mPgpData.getDecryptedData(), ""text/plain"", ""utf-8"", null);
        updateDecryptLayout();
    }

    /*
     * Emulate the shift key being pressed to trigger the text selection mode
     * of a WebView.
     */
    private void emulateShiftHeld(WebView view)
    {
        try
        {
            mToggleScrollView.setScrolling(false);

            KeyEvent shiftPressEvent = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN,
                                                    KeyEvent.KEYCODE_SHIFT_LEFT, 0, 0);
            shiftPressEvent.dispatch(view);
            Toast.makeText(this, R.string.select_text_now, Toast.LENGTH_SHORT).show();
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Exception in emulateShiftHeld()"", e);
        }
    }
}
",True,216,0,0,8,57,2,26,L1
52,com.fsck.k9.activity.FolderListFilter.java,"package com.fsck.k9.activity;

import java.util.ArrayList;
import java.util.List;

import android.util.Log;
import android.widget.ArrayAdapter;
import android.widget.Filter;

import com.fsck.k9.K9;

/**
 * Filter to search for occurences of the search-expression in any place of the
 * folder-name instead of doing jsut a prefix-search.
 *
 * @author Marcus@Wolschon.biz
 */
public class FolderListFilter<T> extends Filter
{
    /**
     * ArrayAdapter that contains the list of folders displayed in the
     * ListView.
     * This object is modified by {@link #publishResults} to reflect the
     * changes due to the filtering performed by {@link #performFiltering}.
     * This in turn will change the folders displayed in the ListView.
     */
    private ArrayAdapter<T> mFolders;

    /**
     * All folders.
     */
    private ArrayList<T> mOriginalValues = null;

    /**
     * Create a filter for a list of folders.
     *
     * @param folderNames
     */
    public FolderListFilter(final ArrayAdapter<T> folderNames)
    {
        this.mFolders = folderNames;
    }

    /**
     * Do the actual search.
     * {@inheritDoc}
     *
     * @see #publishResults(CharSequence, FilterResults)
     */
    @Override
    protected FilterResults performFiltering(CharSequence searchTerm)
    {
        FilterResults results = new FilterResults();

        // Copy the values from mFolders to mOriginalValues if this is the
        // first time this method is called.
        if (mOriginalValues == null)
        {
            int count = mFolders.getCount();
            mOriginalValues = new ArrayList<T>(count);
            for (int i = 0; i < count; i++)
            {
                mOriginalValues.add(mFolders.getItem(i));
            }
        }

        if ((searchTerm == null) || (searchTerm.length() == 0))
        {
            ArrayList<T> list = new ArrayList<T>(mOriginalValues);
            results.values = list;
            results.count = list.size();
        }
        else
        {
            final String searchTermString = searchTerm.toString().toLowerCase();
            final String[] words = searchTermString.split("" "");
            final int wordCount = words.length;

            final ArrayList<T> values = mOriginalValues;
            final int count = values.size();

            final ArrayList<T> newValues = new ArrayList<T>();

            for (int i = 0; i < count; i++)
            {
                final T value = values.get(i);
                final String valueText = value.toString().toLowerCase();

                for (int k = 0; k < wordCount; k++)
                {
                    if (valueText.contains(words[k]))
                    {
                        newValues.add(value);
                        break;
                    }
                }
            }

            results.values = newValues;
            results.count = newValues.size();
        }

        return results;
    }

    /**
     * Publish the results to the user-interface.
     * {@inheritDoc}
     */
    @SuppressWarnings(""unchecked"")
    @Override
    protected void publishResults(CharSequence constraint, FilterResults results)
    {
        // Don't notify for every change
        mFolders.setNotifyOnChange(false);

        //noinspection unchecked
        final List<T> folders = (List<T>) results.values;
        mFolders.clear();
        if (folders != null)
        {
            for (T folder : folders)
            {
                if (folder != null)
                {
                    mFolders.add(folder);
                }
            }
        }
        else
        {
            Log.w(K9.LOG_TAG, ""FolderListFilter.publishResults - null search-result "");
        }

        // Send notification that the data set changed now
        mFolders.notifyDataSetChanged();
    }

    public void invalidate()
    {
        mOriginalValues = null;
    }
}
",False,216,0,0,9,58,1,1,L1
53,com.fsck.k9.activity.ActivityListener.java,"package com.fsck.k9.activity;

import java.text.DateFormat;

import android.content.Context;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.R;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.service.MailService;

public class ActivityListener extends MessagingListener
{
    private String mLoadingFolderName = null;
    private String mLoadingHeaderFolderName = null;
    private String mLoadingAccountDescription = null;
    private String mSendingAccountDescription = null;
    private int mFolderCompleted = 0;
    private int mFolderTotal = 0;
    private String mProcessingAccountDescription = null;
    private String mProcessingCommandTitle = null;


    public String formatHeader(Context context, String activityPrefix, int unreadMessageCount, DateFormat timeFormat)
    {
        String operation = null;
        String progress = null;
        if (mLoadingAccountDescription  != null
                || mSendingAccountDescription != null
                || mLoadingHeaderFolderName != null
                || mProcessingAccountDescription != null)
        {
            progress = (mFolderTotal > 0 ?
                        context.getString(R.string.folder_progress, mFolderCompleted, mFolderTotal) : """");

            if (mLoadingFolderName != null || mLoadingHeaderFolderName != null)
            {
                String displayName = mLoadingFolderName;
                if (K9.INBOX.equalsIgnoreCase(displayName))
                {
                    displayName = context.getString(R.string.special_mailbox_name_inbox);
                }

                if (mLoadingHeaderFolderName != null)
                {

                    operation = context.getString(R.string.status_loading_account_folder_headers, mLoadingAccountDescription, displayName, progress);
                }
                else
                {
                    operation = context.getString(R.string.status_loading_account_folder, mLoadingAccountDescription, displayName, progress);
                }
            }

            else if (mSendingAccountDescription != null)
            {
                operation = context.getString(R.string.status_sending_account, mSendingAccountDescription, progress);
            }
            else if (mProcessingAccountDescription != null)
            {
                operation = context.getString(R.string.status_processing_account, mProcessingAccountDescription,
                                              mProcessingCommandTitle != null ? mProcessingCommandTitle : """",
                                              progress);
            }
        }
        else
        {
            long nextPollTime = MailService.getNextPollTime();
            if (nextPollTime != -1)
            {
                operation = context.getString(R.string.status_next_poll, timeFormat.format(nextPollTime));
            }
            else
            {
                operation = context.getString(R.string.status_polling_off);
            }
        }

        return context.getString(R.string.activity_header_format, activityPrefix,
                                 (unreadMessageCount > 0 ? context.getString(R.string.activity_unread_count, unreadMessageCount) : """"),
                                 operation);


    }

    @Override
    public void synchronizeMailboxFinished(
        Account account,
        String folder,
        int totalMessagesInMailbox,
        int numNewMessages)
    {
        mLoadingAccountDescription = null;
        mLoadingFolderName = null;
    }

    @Override
    public void synchronizeMailboxStarted(Account account, String folder)
    {
        mLoadingAccountDescription = account.getDescription();
        mLoadingFolderName = folder;
        mFolderCompleted = 0;
        mFolderTotal = 0;
    }


    @Override
    public void synchronizeMailboxHeadersStarted(Account account, String folder)
    {
        mLoadingHeaderFolderName = folder;
    }


    @Override
    public void synchronizeMailboxHeadersProgress(Account account, String folder, int completed, int total)
    {
        mFolderCompleted = completed;
        mFolderTotal = total;
    }

    @Override
    public void synchronizeMailboxHeadersFinished(Account account, String folder,
            int total, int completed)
    {
        mLoadingHeaderFolderName = null;
        mFolderCompleted = 0;
        mFolderTotal = 0;
    }


    @Override
    public void synchronizeMailboxProgress(Account account, String folder, int completed, int total)
    {
        mFolderCompleted = completed;
        mFolderTotal = total;
    }

    @Override
    public void synchronizeMailboxFailed(Account account, String folder,
                                         String message)
    {
        mLoadingAccountDescription = null;
        mLoadingFolderName = null;

    }

    @Override
    public void sendPendingMessagesStarted(Account account)
    {
        mSendingAccountDescription = account.getDescription();
    }

    @Override
    public void sendPendingMessagesCompleted(Account account)
    {
        mSendingAccountDescription = null;
    }

    @Override
    public void sendPendingMessagesFailed(Account account)
    {
        mSendingAccountDescription = null;
    }

    @Override
    public void pendingCommandsProcessing(Account account)
    {
        mProcessingAccountDescription = account.getDescription();
        mFolderCompleted = 0;
        mFolderTotal = 0;
    }

    @Override
    public void pendingCommandsFinished(Account account)
    {
        mProcessingAccountDescription = null;
    }

    @Override
    public void pendingCommandStarted(Account account, String commandTitle)
    {
        mProcessingCommandTitle = commandTitle;
    }

    @Override
    public void pendingCommandCompleted(Account account, String commandTitle)
    {
        mProcessingCommandTitle = null;
    }

    public int getFolderCompleted()
    {
        return mFolderCompleted;
    }

    public int getFolderTotal()
    {
        return mFolderTotal;
    }

}
",False,216,0,0,8,49,3,4,L1
54,com.fsck.k9.activity.FolderInfoHolder.java,"package com.fsck.k9.activity;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.os.Handler;
import android.text.Spannable;
import android.text.style.TextAppearanceSpan;
import android.util.Config;
import android.util.Log;
import android.util.TypedValue;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.GestureDetector;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.BaseAdapter;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageButton;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;
import android.text.format.DateFormat;

import com.fsck.k9.Account;
import com.fsck.k9.AccountStats;
import com.fsck.k9.FontSizes;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.SearchSpecification;
import com.fsck.k9.activity.setup.AccountSettings;
import com.fsck.k9.activity.setup.FolderSettings;
import com.fsck.k9.activity.setup.Prefs;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingController.SORT_TYPE;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import com.fsck.k9.mail.store.LocalStore.LocalMessage;

public class FolderInfoHolder implements Comparable<FolderInfoHolder>
{
    public String name;
    public String displayName;
    public long lastChecked;
    public int unreadMessageCount;
    public int flaggedMessageCount;
    public boolean loading;
    public String status;
    public boolean lastCheckFailed;
    public Folder folder;
    public boolean pushActive;

    /**
     * Outbox is handled differently from any other folder.
     */
    public boolean outbox;

    @Override
    public boolean equals(Object o)
    {
        return this.name.equals(((FolderInfoHolder)o).name);
    }

    @Override
    public int hashCode()
    {
        return name.hashCode();
    }

    public int compareTo(FolderInfoHolder o)
    {
        String s1 = this.name;
        String s2 = o.name;

        int ret = s1.compareToIgnoreCase(s2);
        if (ret != 0)
        {
            return ret;
        }
        else
        {
            return s1.compareTo(s2);
        }

    }

    private String truncateStatus(String mess)
    {
        if (mess != null && mess.length() > 27)
        {
            mess = mess.substring(0, 27);
        }
        return mess;
    }

    // constructor for an empty object for comparisons
    public FolderInfoHolder()
    {
    }

    public FolderInfoHolder(Context context, Folder folder, Account account)
    {
        populate(context, folder, account);
    }

    public FolderInfoHolder(Context context, Folder folder, Account mAccount, int unreadCount)
    {
        populate(context, folder, mAccount, unreadCount);
    }

    public void populate(Context context, Folder folder, Account mAccount, int unreadCount)
    {

        try
        {
            folder.open(Folder.OpenMode.READ_WRITE);
            //  unreadCount = folder.getUnreadMessageCount();
        }
        catch (MessagingException me)
        {
            Log.e(K9.LOG_TAG, ""Folder.getUnreadMessageCount() failed"", me);
        }

        this.name = folder.getName();

        if (this.name.equalsIgnoreCase(K9.INBOX))
        {
            this.displayName = context.getString(R.string.special_mailbox_name_inbox);
        }
        else
        {
            this.displayName = folder.getName();
        }

        if (this.name.equals(mAccount.getOutboxFolderName()))
        {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_outbox_fmt), this.name);
            this.outbox = true;
        }

        if (this.name.equals(mAccount.getDraftsFolderName()))
        {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_drafts_fmt), this.name);
        }

        if (this.name.equals(mAccount.getTrashFolderName()))
        {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_trash_fmt), this.name);
        }

        if (this.name.equals(mAccount.getSentFolderName()))
        {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_sent_fmt), this.name);
        }

        if (this.name.equals(mAccount.getArchiveFolderName()))
        {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_archive_fmt), this.name);
        }

        if (this.name.equals(mAccount.getSpamFolderName()))
        {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_spam_fmt), this.name);
        }

        this.lastChecked = folder.getLastUpdate();

        String mess = truncateStatus(folder.getStatus());

        this.status = mess;

        this.unreadMessageCount = unreadCount;

        try
        {
            this.flaggedMessageCount = folder.getFlaggedMessageCount();
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Unable to get flaggedMessageCount"", e);
        }

        folder.close();

    }


    public void populate(Context context, Folder folder, Account account)
    {
        this.folder = folder;
        this.name = folder.getName();

        if (this.name.equalsIgnoreCase(K9.INBOX))
        {
            this.displayName = context.getString(R.string.special_mailbox_name_inbox);
        }
        else
        {
            this.displayName = this.name;
        }

        if (this.name.equals(account.getOutboxFolderName()))
        {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_outbox_fmt), this.name);
            this.outbox = true;
        }

        if (this.name.equals(account.getDraftsFolderName()))
        {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_drafts_fmt), this.name);
        }

        if (this.name.equals(account.getTrashFolderName()))
        {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_trash_fmt), this.name);
        }

        if (this.name.equals(account.getSentFolderName()))
        {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_sent_fmt), this.name);
        }

        if (this.name.equals(account.getArchiveFolderName()))
        {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_archive_fmt), this.name);
        }

        if (this.name.equals(account.getSpamFolderName()))
        {
            this.displayName = String.format(context.getString(R.string.special_mailbox_name_spam_fmt), this.name);
        }
    }
}
",True,217,1,1,8,58,5,18,L1
55,com.fsck.k9.activity.MessageReference.java,"package com.fsck.k9.activity;

import java.io.Serializable;

public class MessageReference implements Serializable
{
    public String accountUuid;
    public String folderName;
    public String uid;

    @Override
    public boolean equals(Object o)
    {
        if (o instanceof MessageReference == false)
        {
            return false;
        }
        MessageReference other = (MessageReference)o;
        if ((accountUuid == other.accountUuid || (accountUuid != null && accountUuid.equals(other.accountUuid)))
                && (folderName == other.folderName || (folderName != null && folderName.equals(other.folderName)))
                && (uid == other.uid || (uid != null && uid.equals(other.uid))))
        {
            return true;
        }
        return false;
    }

    @Override
    public int hashCode()
    {
        final int MULTIPLIER = 31;

        int result = 1;
        result = MULTIPLIER * result + ((accountUuid == null) ? 0 : accountUuid.hashCode());
        result = MULTIPLIER * result + ((folderName == null) ? 0 : folderName.hashCode());
        result = MULTIPLIER * result + ((uid == null) ? 0 : uid.hashCode());
        return result;
    }

    @Override
    public String toString()
    {
        return ""MessageReference{accountUuid = '"" +
               accountUuid
               + ""', folderName = '"" + folderName
               + ""', uid = '"" + uid
               + ""'}"";
    }
}
",True,92,5,42,0,0,5,0,L1
56,com.fsck.k9.activity.ChooseAccount.java,"package com.fsck.k9.activity;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.widget.BaseExpandableListAdapter;
import android.widget.ExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.TextView;

import com.fsck.k9.Account;
import com.fsck.k9.Identity;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;

import java.util.List;

/**
 * Activity displaying list of accounts/identity for user choice
 *
 * @see K9ExpandableListActivity
 */
public class ChooseAccount extends K9ExpandableListActivity
{

    /**
     * {@link Intent} extended data name for storing {@link Account#getUuid()
     * account UUID}
     */
    public static final String EXTRA_ACCOUNT = ChooseAccount.class.getName() + ""_account"";

    /**
     * {@link Intent} extended data name for storing serialized {@link Identity}
     */
    public static final String EXTRA_IDENTITY = ChooseAccount.class.getName() + ""_identity"";

    @Override
    protected void onCreate(final Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        setContentView(R.layout.choose_account);

        final ExpandableListView expandableListView = getExpandableListView();
        expandableListView.setItemsCanFocus(false);

        final ExpandableListAdapter adapter = createAdapter();
        setListAdapter(adapter);

        expandableListView.setOnChildClickListener(new ExpandableListView.OnChildClickListener()
        {
            @Override
            public boolean onChildClick(ExpandableListView parent, View v, int groupPosition,
                                        int childPosition, long id)
            {
                final Identity identity = (Identity) adapter.getChild(groupPosition, childPosition);
                final Account account = (Account) adapter.getGroup(groupPosition);

                final Intent intent = new Intent();
                intent.putExtra(EXTRA_ACCOUNT, account.getUuid());
                intent.putExtra(EXTRA_IDENTITY, identity);
                setResult(RESULT_OK, intent);

                finish();
                return true;
            }
        });

        final Bundle extras = getIntent().getExtras();
        final String uuid = extras.getString(EXTRA_ACCOUNT);
        if (uuid != null)
        {
            final Account[] accounts = Preferences.getPreferences(this).getAccounts();
            final int length = accounts.length;
            for (int i = 0; i < length; i++)
            {
                final Account account = accounts[i];
                if (uuid.equals(account.getUuid()))
                {
                    // setSelectedChild() doesn't seem to obey the
                    // shouldExpandGroup parameter (2.1), manually expanding
                    // group
                    expandableListView.expandGroup(i);

                    final List<Identity> identities = account.getIdentities();
                    final Identity identity = (Identity) extras.getSerializable(EXTRA_IDENTITY);
                    if (identity == null)
                    {
                        expandableListView.setSelectedChild(i, 0, true);
                        break;
                    }
                    for (int j = 0; j < identities.size(); j++)
                    {
                        final Identity loopIdentity = identities.get(j);
                        if (identity.equals(loopIdentity))
                        {
                            expandableListView.setSelectedChild(i, j, true);
                            break;
                        }
                    }
                    break;
                }
            }
        }
    }

    private ExpandableListAdapter createAdapter()
    {
        return new IdentitiesAdapter(this, getLayoutInflater());
    }

    /**
     * Dynamically provides accounts/identities data for
     * {@link ExpandableListView#setAdapter(ExpandableListAdapter)}:
     *
     * <ul>
     * <li>Groups represent {@link Account accounts}</li>
     * <li>Children represent {@link Identity identities} of the parent account</li>
     * </ul>
     */
    public static class IdentitiesAdapter extends BaseExpandableListAdapter
    {

        private Context mContext;
        private LayoutInflater mLayoutInflater;

        public IdentitiesAdapter(final Context context, final LayoutInflater layoutInflater)
        {
            mContext = context;
            mLayoutInflater = layoutInflater;
        }

        @Override
        public Object getChild(int groupPosition, int childPosition)
        {
            return getAccounts()[groupPosition].getIdentity(childPosition);
        }

        @Override
        public long getChildId(int groupPosition, int childPosition)
        {
            return Integer.valueOf(childPosition).longValue();
        }

        @Override
        public int getChildrenCount(int groupPosition)
        {
            return getAccounts()[groupPosition].getIdentities().size();
        }

        @Override
        public Object getGroup(int groupPosition)
        {
            return getAccounts()[groupPosition];
        }

        @Override
        public int getGroupCount()
        {
            return getAccounts().length;
        }

        @Override
        public long getGroupId(int groupPosition)
        {
            return Integer.valueOf(groupPosition).longValue();
        }

        @Override
        public View getGroupView(int groupPosition, boolean isExpanded, View convertView,
                                 ViewGroup parent)
        {
            final View v;
            if (convertView == null)
            {
                // is it okay to reuse?
                v = mLayoutInflater.inflate(R.layout.choose_account_item, parent, false);
            }
            else
            {
                v = convertView;
            }

            final TextView description = (TextView) v.findViewById(R.id.description);
            final Account account = getAccounts()[groupPosition];
            description.setText(account.getDescription());
            description.setTextSize(TypedValue.COMPLEX_UNIT_DIP, K9.getFontSizes().getAccountName());

            v.findViewById(R.id.chip).setBackgroundColor(account.getChipColor());

            return v;
        }

        @Override
        public View getChildView(int groupPosition, int childPosition, boolean isLastChild,
                                 View convertView, ViewGroup parent)
        {
            final Account account = getAccounts()[groupPosition];
            final Identity identity = account.getIdentity(childPosition);

            final View v;
            if (convertView == null)
            {
                v = mLayoutInflater.inflate(R.layout.choose_identity_item, parent, false);
            }
            else
            {
                v = convertView;
            }

            final TextView name = (TextView) v.findViewById(R.id.name);
            final TextView description = (TextView) v.findViewById(R.id.description);
            name.setTextSize(TypedValue.COMPLEX_UNIT_DIP, K9.getFontSizes().getAccountName());
            description.setTextSize(TypedValue.COMPLEX_UNIT_DIP, K9.getFontSizes().getAccountDescription());

            name.setText(identity.getDescription());
            description.setText(String.format(""%s <%s>"", identity.getName(), identity.getEmail()));

            v.findViewById(R.id.chip).setBackgroundColor(account.getChipColor());

            return v;
        }

        @Override
        public boolean hasStableIds()
        {
            // returning false since accounts/identities are mutable
            return false;
        }

        @Override
        public boolean isChildSelectable(int groupPosition, int childPosition)
        {
            return true;
        }

        private Account[] getAccounts()
        {
            return Preferences.getPreferences(mContext).getAccounts();
        }
    }
}
",True,216,0,0,8,51,1,6,L1
57,com.fsck.k9.activity.setup.FolderSettings.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.util.Log;
import android.view.KeyEvent;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9PreferenceActivity;
import com.fsck.k9.mail.Folder.FolderClass;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import com.fsck.k9.service.MailService;

public class FolderSettings extends K9PreferenceActivity
{

    private static final String EXTRA_FOLDER_NAME = ""com.fsck.k9.folderName"";
    private static final String EXTRA_ACCOUNT = ""com.fsck.k9.account"";

    private static final String PREFERENCE_TOP_CATERGORY = ""folder_settings"";
    private static final String PREFERENCE_DISPLAY_CLASS = ""folder_settings_folder_display_mode"";
    private static final String PREFERENCE_SYNC_CLASS = ""folder_settings_folder_sync_mode"";
    private static final String PREFERENCE_PUSH_CLASS = ""folder_settings_folder_push_mode"";
    private static final String PREFERENCE_IN_TOP_GROUP = ""folder_settings_in_top_group"";
    private static final String PREFERENCE_INTEGRATE = ""folder_settings_include_in_integrated_inbox"";

    private LocalFolder mFolder;

    private CheckBoxPreference mInTopGroup;
    private CheckBoxPreference mIntegrate;
    private ListPreference mDisplayClass;
    private ListPreference mSyncClass;
    private ListPreference mPushClass;

    public static void actionSettings(Context context, Account account, String folderName)
    {
        Intent i = new Intent(context, FolderSettings.class);
        i.putExtra(EXTRA_FOLDER_NAME, folderName);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        String folderName = (String)getIntent().getSerializableExtra(EXTRA_FOLDER_NAME);
        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        Account mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        try
        {
            LocalStore localStore = mAccount.getLocalStore();
            mFolder = localStore.getFolder(folderName);
            mFolder.refresh(Preferences.getPreferences(this));
        }
        catch (MessagingException me)
        {
            Log.e(K9.LOG_TAG, ""Unable to edit folder "" + folderName + "" preferences"", me);
            return;
        }

        boolean isPushCapable = false;
        Store store = null;
        try
        {
            store = mAccount.getRemoteStore();
            isPushCapable = store.isPushCapable();
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Could not get remote store"", e);
        }

        addPreferencesFromResource(R.xml.folder_settings_preferences);

        Preference category = findPreference(PREFERENCE_TOP_CATERGORY);
        category.setTitle(folderName);


        mInTopGroup = (CheckBoxPreference)findPreference(PREFERENCE_IN_TOP_GROUP);
        mInTopGroup.setChecked(mFolder.isInTopGroup());
        mIntegrate = (CheckBoxPreference)findPreference(PREFERENCE_INTEGRATE);
        mIntegrate.setChecked(mFolder.isIntegrate());

        mDisplayClass = (ListPreference) findPreference(PREFERENCE_DISPLAY_CLASS);
        mDisplayClass.setValue(mFolder.getDisplayClass().name());
        mDisplayClass.setSummary(mDisplayClass.getEntry());
        mDisplayClass.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mDisplayClass.findIndexOfValue(summary);
                mDisplayClass.setSummary(mDisplayClass.getEntries()[index]);
                mDisplayClass.setValue(summary);
                return false;
            }
        });

        mSyncClass = (ListPreference) findPreference(PREFERENCE_SYNC_CLASS);
        mSyncClass.setValue(mFolder.getRawSyncClass().name());
        mSyncClass.setSummary(mSyncClass.getEntry());
        mSyncClass.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mSyncClass.findIndexOfValue(summary);
                mSyncClass.setSummary(mSyncClass.getEntries()[index]);
                mSyncClass.setValue(summary);
                return false;
            }
        });

        mPushClass = (ListPreference) findPreference(PREFERENCE_PUSH_CLASS);
        mPushClass.setEnabled(isPushCapable);
        mPushClass.setValue(mFolder.getRawPushClass().name());
        mPushClass.setSummary(mPushClass.getEntry());
        mPushClass.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mPushClass.findIndexOfValue(summary);
                mPushClass.setSummary(mPushClass.getEntries()[index]);
                mPushClass.setValue(summary);
                return false;
            }
        });
    }

    @Override
    public void onResume()
    {
        super.onResume();
        try
        {
            mFolder.refresh(Preferences.getPreferences(this));
        }
        catch (MessagingException me)
        {
            Log.e(K9.LOG_TAG, ""Could not refresh folder preferences for folder "" + mFolder.getName(), me);
        }
    }

    private void saveSettings()
    {
        mFolder.setInTopGroup(mInTopGroup.isChecked());
        mFolder.setIntegrate(mIntegrate.isChecked());
        // We call getPushClass() because display class changes can affect push class when push class is set to inherit
        FolderClass oldPushClass = mFolder.getPushClass();
        FolderClass oldDisplayClass = mFolder.getDisplayClass();
        mFolder.setDisplayClass(FolderClass.valueOf(mDisplayClass.getValue()));
        mFolder.setSyncClass(FolderClass.valueOf(mSyncClass.getValue()));
        mFolder.setPushClass(FolderClass.valueOf(mPushClass.getValue()));

        FolderClass newPushClass = mFolder.getPushClass();
        FolderClass newDisplayClass = mFolder.getDisplayClass();

        try
        {
            mFolder.save(Preferences.getPreferences(this));
            if (oldPushClass != newPushClass
                    || (newPushClass != FolderClass.NO_CLASS && oldDisplayClass != newDisplayClass))
            {
                MailService.actionRestartPushers(getApplication(), null);
            }
        }
        catch (MessagingException me)
        {
            Log.e(K9.LOG_TAG, ""Could not refresh folder preferences for folder "" + mFolder.getName(), me);
        }
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (keyCode == KeyEvent.KEYCODE_BACK)
        {
            saveSettings();
        }
        return super.onKeyDown(keyCode, event);
    }


}
",True,216,0,0,7,51,3,9,L1
58,com.fsck.k9.activity.setup.AccountSetupOptions.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.Spinner;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9Activity;
import com.fsck.k9.mail.Store;

public class AccountSetupOptions extends K9Activity implements OnClickListener
{
    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_MAKE_DEFAULT = ""makeDefault"";

    private Spinner mCheckFrequencyView;

    private Spinner mDisplayCountView;


    private CheckBox mNotifyView;
    private CheckBox mNotifySyncView;
    private CheckBox mPushEnable;

    private Account mAccount;

    public static void actionOptions(Context context, Account account, boolean makeDefault)
    {
        Intent i = new Intent(context, AccountSetupOptions.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_options);

        mCheckFrequencyView = (Spinner)findViewById(R.id.account_check_frequency);
        mDisplayCountView = (Spinner)findViewById(R.id.account_display_count);
        mNotifyView = (CheckBox)findViewById(R.id.account_notify);
        mNotifySyncView = (CheckBox)findViewById(R.id.account_notify_sync);
        mPushEnable = (CheckBox)findViewById(R.id.account_enable_push);

        findViewById(R.id.next).setOnClickListener(this);

        SpinnerOption checkFrequencies[] =
        {
            new SpinnerOption(-1,
            getString(R.string.account_setup_options_mail_check_frequency_never)),
            new SpinnerOption(1,
            getString(R.string.account_setup_options_mail_check_frequency_1min)),
            new SpinnerOption(5,
            getString(R.string.account_setup_options_mail_check_frequency_5min)),
            new SpinnerOption(10,
            getString(R.string.account_setup_options_mail_check_frequency_10min)),
            new SpinnerOption(15,
            getString(R.string.account_setup_options_mail_check_frequency_15min)),
            new SpinnerOption(30,
            getString(R.string.account_setup_options_mail_check_frequency_30min)),
            new SpinnerOption(60,
            getString(R.string.account_setup_options_mail_check_frequency_1hour)),
            new SpinnerOption(120,
            getString(R.string.account_setup_options_mail_check_frequency_2hour)),
            new SpinnerOption(180,
            getString(R.string.account_setup_options_mail_check_frequency_3hour)),
            new SpinnerOption(360,
            getString(R.string.account_setup_options_mail_check_frequency_6hour)),
            new SpinnerOption(720,
            getString(R.string.account_setup_options_mail_check_frequency_12hour)),
            new SpinnerOption(1440,
            getString(R.string.account_setup_options_mail_check_frequency_24hour)),

        };

        ArrayAdapter<SpinnerOption> checkFrequenciesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, checkFrequencies);
        checkFrequenciesAdapter
        .setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mCheckFrequencyView.setAdapter(checkFrequenciesAdapter);

        SpinnerOption displayCounts[] =
        {
            new SpinnerOption(10, getString(R.string.account_setup_options_mail_display_count_10)),
            new SpinnerOption(25, getString(R.string.account_setup_options_mail_display_count_25)),
            new SpinnerOption(50, getString(R.string.account_setup_options_mail_display_count_50)),
            new SpinnerOption(100, getString(R.string.account_setup_options_mail_display_count_100)),
            new SpinnerOption(250, getString(R.string.account_setup_options_mail_display_count_250)),
            new SpinnerOption(500, getString(R.string.account_setup_options_mail_display_count_500)),
            new SpinnerOption(1000, getString(R.string.account_setup_options_mail_display_count_1000)),
        };

        ArrayAdapter<SpinnerOption> displayCountsAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, displayCounts);
        displayCountsAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mDisplayCountView.setAdapter(displayCountsAdapter);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        mNotifyView.setChecked(mAccount.isNotifyNewMail());
        mNotifySyncView.setChecked(mAccount.isShowOngoing());
        SpinnerOption.setSpinnerOptionValue(mCheckFrequencyView, mAccount
                                            .getAutomaticCheckIntervalMinutes());
        SpinnerOption.setSpinnerOptionValue(mDisplayCountView, mAccount
                                            .getDisplayCount());


        boolean isPushCapable = false;
        try
        {
            Store store = mAccount.getRemoteStore();
            isPushCapable = store.isPushCapable();
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Could not get remote store"", e);
        }


        if (!isPushCapable)
        {
            mPushEnable.setVisibility(View.GONE);
        }
        else
        {
            mPushEnable.setChecked(true);
        }


    }

    private void onDone()
    {
        mAccount.setDescription(mAccount.getEmail());
        mAccount.setNotifyNewMail(mNotifyView.isChecked());
        mAccount.setShowOngoing(mNotifySyncView.isChecked());
        mAccount.setAutomaticCheckIntervalMinutes((Integer)((SpinnerOption)mCheckFrequencyView
                .getSelectedItem()).value);
        mAccount.setDisplayCount((Integer)((SpinnerOption)mDisplayCountView
                                           .getSelectedItem()).value);

        if (mPushEnable.isChecked())
        {
            mAccount.setFolderPushMode(Account.FolderMode.FIRST_CLASS);
        }
        else
        {
            mAccount.setFolderPushMode(Account.FolderMode.NONE);
        }

        mAccount.save(Preferences.getPreferences(this));
        if (mAccount.equals(Preferences.getPreferences(this).getDefaultAccount()) ||
                getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false))
        {
            Preferences.getPreferences(this).setDefaultAccount(mAccount);
        }
        K9.setServicesEnabled(this);
        AccountSetupNames.actionSetNames(this, mAccount);
        finish();
    }

    public void onClick(View v)
    {
        switch (v.getId())
        {
            case R.id.next:
                onDone();
                break;
        }
    }
}
",True,216,0,0,8,59,1,7,L1
59,com.fsck.k9.activity.setup.Prefs.java,"package com.fsck.k9.activity.setup;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Vector;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.view.KeyEvent;
import android.widget.Toast;

import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.activity.Accounts;
import com.fsck.k9.activity.ColorPickerDialog;
import com.fsck.k9.activity.DateFormatter;
import com.fsck.k9.activity.K9PreferenceActivity;
import com.fsck.k9.preferences.CheckBoxListPreference;
import com.fsck.k9.service.MailService;

public class Prefs extends K9PreferenceActivity
{

    /**
     * Immutable empty {@link CharSequence} array
     */
    private static final CharSequence[] EMPTY_CHAR_SEQUENCE_ARRAY = new CharSequence[0];

    private static final String PREFERENCE_LANGUAGE = ""language"";
    private static final String PREFERENCE_THEME = ""theme"";
    private static final String PREFERENCE_FONT_SIZE = ""font_size"";
    private static final String PREFERENCE_DATE_FORMAT = ""dateFormat"";
    private static final String PREFERENCE_BACKGROUND_OPS = ""background_ops"";
    private static final String PREFERENCE_DEBUG_LOGGING = ""debug_logging"";
    private static final String PREFERENCE_SENSITIVE_LOGGING = ""sensitive_logging"";

    private static final String PREFERENCE_ANIMATIONS = ""animations"";
    private static final String PREFERENCE_GESTURES = ""gestures"";
    private static final String PREFERENCE_VOLUME_NAVIGATION = ""volumeNavigation"";
    private static final String PREFERENCE_MANAGE_BACK = ""manage_back"";
    private static final String PREFERENCE_START_INTEGRATED_INBOX = ""start_integrated_inbox"";
    private static final String PREFERENCE_MESSAGELIST_STARS = ""messagelist_stars"";
    private static final String PREFERENCE_MESSAGELIST_CHECKBOXES = ""messagelist_checkboxes"";
    private static final String PREFERENCE_MESSAGELIST_TOUCHABLE = ""messagelist_touchable"";

    private static final String PREFERENCE_CHANGE_REGISTERED_NAME_COLOR = ""change_registered_name_color"";
    private static final String PREFERENCE_MESSAGEVIEW_FIXEDWIDTH = ""messageview_fixedwidth_font"";
    private static final String PREFERENCE_MESSAGEVIEW_RETURN_TO_LIST = ""messageview_return_to_list"";

    private static final String PREFERENCE_MEASURE_ACCOUNTS = ""measure_accounts"";
    private static final String PREFERENCE_COUNT_SEARCH = ""count_search"";
    private static final String PREFERENCE_GALLERY_BUG_WORKAROUND = ""use_gallery_bug_workaround"";

    private static final String PREFERENCE_CONFIRM_ACTIONS = ""confirm_actions"";

    private static final String PREFERENCE_PRIVACY_MODE = ""privacy_mode"";

    private ListPreference mLanguage;
    private ListPreference mTheme;
    private ListPreference mDateFormat;
    private ListPreference mBackgroundOps;
    private CheckBoxPreference mDebugLogging;
    private CheckBoxPreference mSensitiveLogging;
    private CheckBoxPreference mGestures;
    private CheckBoxListPreference mVolumeNavigation;
    private CheckBoxPreference mManageBack;
    private CheckBoxPreference mStartIntegratedInbox;
    private CheckBoxPreference mAnimations;
    private CheckBoxPreference mStars;
    private CheckBoxPreference mCheckboxes;
    private CheckBoxPreference mTouchable;

    private CheckBoxPreference mChangeRegisteredNameColor;
    private CheckBoxPreference mFixedWidth;
    private CheckBoxPreference mReturnToList;

    private CheckBoxPreference mMeasureAccounts;
    private CheckBoxPreference mCountSearch;
    private CheckBoxPreference mUseGalleryBugWorkaround;

    private CheckBoxListPreference mConfirmActions;

    private CheckBoxPreference mPrivacyMode;

    private String initBackgroundOps;


    public static void actionPrefs(Context context)
    {
        Intent i = new Intent(context, Prefs.class);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);


        addPreferencesFromResource(R.xml.global_preferences);

        mLanguage = (ListPreference) findPreference(PREFERENCE_LANGUAGE);
        Vector<CharSequence> entryVector = new Vector<CharSequence>(Arrays.asList(mLanguage.getEntries()));
        Vector<CharSequence> entryValueVector = new Vector<CharSequence>(Arrays.asList(mLanguage.getEntryValues()));
        String supportedLanguages[] = getResources().getStringArray(R.array.supported_languages);
        HashSet<String> supportedLanguageSet = new HashSet<String>(Arrays.asList(supportedLanguages));
        for (int i = entryVector.size() - 1; i > -1; --i)
        {
            if (!supportedLanguageSet.contains(entryValueVector.get(i)))
            {
                entryVector.remove(i);
                entryValueVector.remove(i);
            }
        }
        mLanguage.setEntries(entryVector.toArray(EMPTY_CHAR_SEQUENCE_ARRAY));
        mLanguage.setEntryValues(entryValueVector.toArray(EMPTY_CHAR_SEQUENCE_ARRAY));
        mLanguage.setValue(K9.getK9Language());
        mLanguage.setSummary(mLanguage.getEntry());
        mLanguage.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mLanguage.findIndexOfValue(summary);
                mLanguage.setSummary(mLanguage.getEntries()[index]);
                mLanguage.setValue(summary);
                return false;
            }
        });

        mTheme = (ListPreference) findPreference(PREFERENCE_THEME);
        mTheme.setValue(String.valueOf(K9.getK9Theme() == android.R.style.Theme ? ""dark"" : ""light""));
        mTheme.setSummary(mTheme.getEntry());
        mTheme.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mTheme.findIndexOfValue(summary);
                mTheme.setSummary(mTheme.getEntries()[index]);
                mTheme.setValue(summary);
                return false;
            }
        });

        findPreference(PREFERENCE_FONT_SIZE).setOnPreferenceClickListener(
            new Preference.OnPreferenceClickListener()
        {
            public boolean onPreferenceClick(Preference preference)
            {
                onFontSizeSettings();
                return true;
            }
        });

        mDateFormat = (ListPreference) findPreference(PREFERENCE_DATE_FORMAT);
        String[] formats = DateFormatter.getFormats(this);
        CharSequence[] entries = new CharSequence[formats.length];
        CharSequence[] values = new CharSequence[formats.length];
        for (int i = 0 ; i < formats.length; i++)
        {
            String format = formats[i];
            entries[i] = DateFormatter.getSampleDate(this, format);;
            values[i] = format;
        }
        mDateFormat.setEntries(entries);
        mDateFormat.setEntryValues(values);

        mDateFormat.setValue(DateFormatter.getFormat(this));
        mDateFormat.setSummary(mDateFormat.getEntry());
        mDateFormat.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mDateFormat.findIndexOfValue(summary);
                mDateFormat.setSummary(mDateFormat.getEntries()[index]);
                mDateFormat.setValue(summary);
                return false;
            }
        });

        mBackgroundOps = (ListPreference) findPreference(PREFERENCE_BACKGROUND_OPS);
        initBackgroundOps = K9.getBackgroundOps().toString();
        mBackgroundOps.setValue(initBackgroundOps);
        mBackgroundOps.setSummary(mBackgroundOps.getEntry());
        mBackgroundOps.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mBackgroundOps.findIndexOfValue(summary);
                mBackgroundOps.setSummary(mBackgroundOps.getEntries()[index]);
                mBackgroundOps.setValue(summary);
                return false;
            }
        });

        mDebugLogging = (CheckBoxPreference)findPreference(PREFERENCE_DEBUG_LOGGING);
        mSensitiveLogging = (CheckBoxPreference)findPreference(PREFERENCE_SENSITIVE_LOGGING);

        mDebugLogging.setChecked(K9.DEBUG);
        mSensitiveLogging.setChecked(K9.DEBUG_SENSITIVE);

        mAnimations = (CheckBoxPreference)findPreference(PREFERENCE_ANIMATIONS);
        mAnimations.setChecked(K9.showAnimations());
        mGestures = (CheckBoxPreference)findPreference(PREFERENCE_GESTURES);
        mGestures.setChecked(K9.gesturesEnabled());
        mVolumeNavigation = (CheckBoxListPreference)findPreference(PREFERENCE_VOLUME_NAVIGATION);
        mVolumeNavigation.setItems(new CharSequence[] {getString(R.string.volume_navigation_message), getString(R.string.volume_navigation_list)});
        mVolumeNavigation.setCheckedItems(new boolean[] {K9.useVolumeKeysForNavigationEnabled(), K9.useVolumeKeysForListNavigationEnabled()});

        mManageBack = (CheckBoxPreference)findPreference(PREFERENCE_MANAGE_BACK);
        mManageBack.setChecked(K9.manageBack());

        mStartIntegratedInbox = (CheckBoxPreference)findPreference(PREFERENCE_START_INTEGRATED_INBOX);
        mStartIntegratedInbox.setChecked(K9.startIntegratedInbox());


        mStars = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGELIST_STARS);
        mStars.setChecked(K9.messageListStars());

        mCheckboxes = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGELIST_CHECKBOXES);
        mCheckboxes.setChecked(K9.messageListCheckboxes());

        mTouchable = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGELIST_TOUCHABLE);
        mTouchable.setChecked(K9.messageListTouchable());

        mChangeRegisteredNameColor = (CheckBoxPreference)findPreference(PREFERENCE_CHANGE_REGISTERED_NAME_COLOR);
        mChangeRegisteredNameColor.setChecked(K9.changeRegisteredNameColor());
        if (K9.changeRegisteredNameColor())
            mChangeRegisteredNameColor.setSummary(R.string.global_settings_registered_name_color_changed);
        else
            mChangeRegisteredNameColor.setSummary(R.string.global_settings_registered_name_color_default);
        mChangeRegisteredNameColor.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                if ((boolean)(Boolean)newValue == true) {
                    onChooseRegisteredNameColor();
                    mChangeRegisteredNameColor.setSummary(R.string.global_settings_registered_name_color_changed);
                }
                else {
                    mChangeRegisteredNameColor.setSummary(R.string.global_settings_registered_name_color_default);
                }
                mChangeRegisteredNameColor.setChecked((Boolean)newValue);
                return false;
            }
        });

        mFixedWidth = (CheckBoxPreference)findPreference(PREFERENCE_MESSAGEVIEW_FIXEDWIDTH);
        mFixedWidth.setChecked(K9.messageViewFixedWidthFont());

        mReturnToList = (CheckBoxPreference) findPreference(PREFERENCE_MESSAGEVIEW_RETURN_TO_LIST);
        mReturnToList.setChecked(K9.messageViewReturnToList());

        mMeasureAccounts = (CheckBoxPreference)findPreference(PREFERENCE_MEASURE_ACCOUNTS);
        mMeasureAccounts.setChecked(K9.measureAccounts());

        mCountSearch = (CheckBoxPreference)findPreference(PREFERENCE_COUNT_SEARCH);
        mCountSearch.setChecked(K9.countSearchMessages());

        mUseGalleryBugWorkaround = (CheckBoxPreference)findPreference(PREFERENCE_GALLERY_BUG_WORKAROUND);
        mUseGalleryBugWorkaround.setChecked(K9.useGalleryBugWorkaround());

        mConfirmActions = (CheckBoxListPreference) findPreference(PREFERENCE_CONFIRM_ACTIONS);
        mConfirmActions.setItems(new CharSequence[] {getString(R.string.global_settings_confirm_action_delete)});
        mConfirmActions.setCheckedItems(new boolean[] {K9.confirmDelete()});

        mPrivacyMode = (CheckBoxPreference) findPreference(PREFERENCE_PRIVACY_MODE);
        mPrivacyMode.setChecked(K9.keyguardPrivacy());
    }

    @Override
    public void onResume()
    {
        super.onResume();
    }

    private void saveSettings()
    {
        SharedPreferences preferences = Preferences.getPreferences(this).getPreferences();
        K9.setK9Language(mLanguage.getValue());
        K9.setK9Theme(mTheme.getValue().equals(""dark"") ? android.R.style.Theme : android.R.style.Theme_Light);

        if (!K9.DEBUG && mDebugLogging.isChecked())
        {
            Toast.makeText(this, R.string.debug_logging_enabled, Toast.LENGTH_LONG).show();
        }
        K9.DEBUG = mDebugLogging.isChecked();
        K9.DEBUG_SENSITIVE = mSensitiveLogging.isChecked();
        boolean needsRefresh = K9.setBackgroundOps(mBackgroundOps.getValue());

        K9.setAnimations(mAnimations.isChecked());
        K9.setGesturesEnabled(mGestures.isChecked());
        K9.setUseVolumeKeysForNavigation(mVolumeNavigation.getCheckedItems()[0]);
        K9.setUseVolumeKeysForListNavigation(mVolumeNavigation.getCheckedItems()[1]);
        K9.setManageBack(mManageBack.isChecked());
        K9.setStartIntegratedInbox(mStartIntegratedInbox.isChecked());
        K9.setMessageListStars(mStars.isChecked());
        K9.setMessageListCheckboxes(mCheckboxes.isChecked());
        K9.setMessageListTouchable(mTouchable.isChecked());

        K9.setChangeRegisteredNameColor(mChangeRegisteredNameColor.isChecked());
        K9.setMessageViewFixedWidthFont(mFixedWidth.isChecked());
        K9.setMessageViewReturnToList(mReturnToList.isChecked());

        K9.setMeasureAccounts(mMeasureAccounts.isChecked());
        K9.setCountSearchMessages(mCountSearch.isChecked());

        K9.setUseGalleryBugWorkaround(mUseGalleryBugWorkaround.isChecked());

        K9.setConfirmDelete(mConfirmActions.getCheckedItems()[0]);

        K9.setKeyguardPrivacy(mPrivacyMode.isChecked());

        Editor editor = preferences.edit();
        K9.save(editor);
        DateFormatter.setDateFormat(editor, mDateFormat.getValue());
        editor.commit();
        if (needsRefresh)
        {
            MailService.actionReset(this, null);
        }
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (keyCode == KeyEvent.KEYCODE_BACK)
        {
            saveSettings();
            if (K9.manageBack())
            {
                Accounts.listAccounts(this);
                finish();
                return true;
            }
        }
        return super.onKeyDown(keyCode, event);
    }

    private void onFontSizeSettings()
    {
        FontSizeSettings.actionEditSettings(this);
    }

    public void onChooseRegisteredNameColor()
    {
        new ColorPickerDialog(this, new ColorPickerDialog.OnColorChangedListener()
        {
            public void colorChanged(int color)
            {
                K9.setRegisteredNameColor(color);
            }
        },
        K9.getRegisteredNameColor()).show();
    }
}
",False,216,0,0,9,57,4,9,L1
60,com.fsck.k9.activity.setup.FontSizeSettings.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Bundle;
import android.preference.*;
import android.view.KeyEvent;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9PreferenceActivity;

/**
 * Activity to configure the font size of the information displayed in the
 * account list, folder list, message list and in the message view.
 *
 * @see FontSizes
 */
public class FontSizeSettings extends K9PreferenceActivity
{
    /*
     * Keys of the preferences defined in res/xml/font_preferences.xml
     */
    private static final String PREFERENCE_ACCOUNT_NAME_FONT = ""account_name_font"";
    private static final String PREFERENCE_ACCOUNT_DESCRIPTION_FONT = ""account_description_font"";
    private static final String PREFERENCE_FOLDER_NAME_FONT = ""folder_name_font"";
    private static final String PREFERENCE_FOLDER_STATUS_FONT = ""folder_status_font"";
    private static final String PREFERENCE_MESSAGE_LIST_SUBJECT_FONT = ""message_list_subject_font"";
    private static final String PREFERENCE_MESSAGE_LIST_SENDER_FONT = ""message_list_sender_font"";
    private static final String PREFERENCE_MESSAGE_LIST_DATE_FONT = ""message_list_date_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_SENDER_FONT = ""message_view_sender_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_TO_FONT = ""message_view_to_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_CC_FONT = ""message_view_cc_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_ADDITIONAL_HEADERS_FONT = ""message_view_additional_headers_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_SUBJECT_FONT = ""message_view_subject_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_TIME_FONT = ""message_view_time_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_DATE_FONT = ""message_view_date_font"";
    private static final String PREFERENCE_MESSAGE_VIEW_CONTENT_FONT = ""message_view_content_font"";

    private ListPreference mAccountName;
    private ListPreference mAccountDescription;
    private ListPreference mFolderName;
    private ListPreference mFolderStatus;
    private ListPreference mMessageListSubject;
    private ListPreference mMessageListSender;
    private ListPreference mMessageListDate;
    private ListPreference mMessageViewSender;
    private ListPreference mMessageViewTo;
    private ListPreference mMessageViewCC;
    private ListPreference mMessageViewAdditionalHeaders;
    private ListPreference mMessageViewSubject;
    private ListPreference mMessageViewTime;
    private ListPreference mMessageViewDate;
    private ListPreference mMessageViewContent;


    /**
     * Start the FontSizeSettings activity.
     *
     * @param context The application context.
     */
    public static void actionEditSettings(Context context)
    {
        Intent i = new Intent(context, FontSizeSettings.class);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        FontSizes fontSizes = K9.getFontSizes();
        addPreferencesFromResource(R.xml.font_preferences);

        mAccountName = initializeListPreference(PREFERENCE_ACCOUNT_NAME_FONT, fontSizes.getAccountName());
        mAccountDescription = initializeListPreference(PREFERENCE_ACCOUNT_DESCRIPTION_FONT, fontSizes.getAccountDescription());

        mFolderName = initializeListPreference(PREFERENCE_FOLDER_NAME_FONT, fontSizes.getFolderName());
        mFolderStatus = initializeListPreference(PREFERENCE_FOLDER_STATUS_FONT, fontSizes.getFolderStatus());

        mMessageListSubject = initializeListPreference(PREFERENCE_MESSAGE_LIST_SUBJECT_FONT, fontSizes.getMessageListSubject());
        mMessageListSender = initializeListPreference(PREFERENCE_MESSAGE_LIST_SENDER_FONT, fontSizes.getMessageListSender());
        mMessageListDate = initializeListPreference(PREFERENCE_MESSAGE_LIST_DATE_FONT, fontSizes.getMessageListDate());

        mMessageViewSender = initializeListPreference(PREFERENCE_MESSAGE_VIEW_SENDER_FONT, fontSizes.getMessageViewSender());
        mMessageViewTo = initializeListPreference(PREFERENCE_MESSAGE_VIEW_TO_FONT, fontSizes.getMessageViewTo());
        mMessageViewCC = initializeListPreference(PREFERENCE_MESSAGE_VIEW_CC_FONT, fontSizes.getMessageViewCC());
        mMessageViewAdditionalHeaders = initializeListPreference(PREFERENCE_MESSAGE_VIEW_ADDITIONAL_HEADERS_FONT, fontSizes.getMessageViewAdditionalHeaders());
        mMessageViewSubject = initializeListPreference(PREFERENCE_MESSAGE_VIEW_SUBJECT_FONT, fontSizes.getMessageViewSubject());
        mMessageViewTime = initializeListPreference(PREFERENCE_MESSAGE_VIEW_TIME_FONT, fontSizes.getMessageViewTime());
        mMessageViewDate = initializeListPreference(PREFERENCE_MESSAGE_VIEW_DATE_FONT, fontSizes.getMessageViewDate());
        mMessageViewContent = initializeListPreference(PREFERENCE_MESSAGE_VIEW_CONTENT_FONT, fontSizes.getMessageViewContentAsInt());
    }

    /**
     * Update the global FontSize object and permanently store the (possibly
     * changed) font size settings.
     */
    private void saveSettings()
    {
        FontSizes fontSizes = K9.getFontSizes();

        fontSizes.setAccountName(Integer.parseInt(mAccountName.getValue()));
        fontSizes.setAccountDescription(Integer.parseInt(mAccountDescription.getValue()));

        fontSizes.setFolderName(Integer.parseInt(mFolderName.getValue()));
        fontSizes.setFolderStatus(Integer.parseInt(mFolderStatus.getValue()));

        fontSizes.setMessageListSubject(Integer.parseInt(mMessageListSubject.getValue()));
        fontSizes.setMessageListSender(Integer.parseInt(mMessageListSender.getValue()));
        fontSizes.setMessageListDate(Integer.parseInt(mMessageListDate.getValue()));

        fontSizes.setMessageViewSender(Integer.parseInt(mMessageViewSender.getValue()));
        fontSizes.setMessageViewTo(Integer.parseInt(mMessageViewTo.getValue()));
        fontSizes.setMessageViewCC(Integer.parseInt(mMessageViewCC.getValue()));
        fontSizes.setMessageViewAdditionalHeaders(Integer.parseInt(mMessageViewAdditionalHeaders.getValue()));
        fontSizes.setMessageViewSubject(Integer.parseInt(mMessageViewSubject.getValue()));
        fontSizes.setMessageViewTime(Integer.parseInt(mMessageViewTime.getValue()));
        fontSizes.setMessageViewDate(Integer.parseInt(mMessageViewDate.getValue()));
        fontSizes.setMessageViewContent(Integer.parseInt(mMessageViewContent.getValue()));

        SharedPreferences preferences = Preferences.getPreferences(this).getPreferences();
        Editor editor = preferences.edit();
        fontSizes.save(editor);
        editor.commit();
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (keyCode == KeyEvent.KEYCODE_BACK)
        {
            saveSettings();
        }
        return super.onKeyDown(keyCode, event);
    }

    /**
     * Set up the ListPreference instance identified by <code>key</code>.
     *
     * @param key The key of the ListPreference object.
     * @param value Initial value for the ListPreference object.
     * @return The ListPreference instance identified by <code>key</code>.
     */
    private ListPreference initializeListPreference(String key, int value)
    {
        ListPreference prefView = (ListPreference) findPreference(key);
        prefView.setValue(Integer.toString(value));
        prefView.setSummary(prefView.getEntry());
        prefView.setOnPreferenceChangeListener(new PreferenceChangeListener(prefView));
        return prefView;
    }

    /**
     * This class handles value changes of the ListPreference objects.
     */
    private class PreferenceChangeListener implements Preference.OnPreferenceChangeListener
    {
        private ListPreference mPrefView;

        private PreferenceChangeListener(ListPreference prefView)
        {
            this.mPrefView = prefView;
        }

        /**
         * Show the preference value in the preference summary field.
         */
        @Override
        public boolean onPreferenceChange(Preference preference, Object newValue)
        {
            final String summary = newValue.toString();
            int index = mPrefView.findIndexOfValue(summary);
            mPrefView.setSummary(mPrefView.getEntries()[index]);
            mPrefView.setValue(summary);
            return false;
        }
    }
}
",False,216,0,0,9,57,1,4,L1
61,com.fsck.k9.activity.setup.AccountSetupNames.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.text.method.TextKeyListener;
import android.text.method.TextKeyListener.Capitalize;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9Activity;
import com.fsck.k9.helper.Utility;

public class AccountSetupNames extends K9Activity implements OnClickListener
{
    private static final String EXTRA_ACCOUNT = ""account"";

    private EditText mDescription;

    private EditText mName;

    private Account mAccount;

    private Button mDoneButton;

    public static void actionSetNames(Context context, Account account)
    {
        Intent i = new Intent(context, AccountSetupNames.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_names);
        mDescription = (EditText)findViewById(R.id.account_description);
        mName = (EditText)findViewById(R.id.account_name);
        mDoneButton = (Button)findViewById(R.id.done);
        mDoneButton.setOnClickListener(this);

        TextWatcher validationTextWatcher = new TextWatcher()
        {
            public void afterTextChanged(Editable s)
            {
                validateFields();
            }

            public void beforeTextChanged(CharSequence s, int start, int count, int after)
            {
            }

            public void onTextChanged(CharSequence s, int start, int before, int count)
            {
            }
        };
        mName.addTextChangedListener(validationTextWatcher);

        mName.setKeyListener(TextKeyListener.getInstance(false, Capitalize.WORDS));

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        /*
         * Since this field is considered optional, we don't set this here. If
         * the user fills in a value we'll reset the current value, otherwise we
         * just leave the saved value alone.
         */
        // mDescription.setText(mAccount.getDescription());
        if (mAccount.getName() != null)
        {
            mName.setText(mAccount.getName());
        }
        if (!Utility.requiredFieldValid(mName))
        {
            mDoneButton.setEnabled(false);
        }
    }

    private void validateFields()
    {
        mDoneButton.setEnabled(Utility.requiredFieldValid(mName));
        Utility.setCompoundDrawablesAlpha(mDoneButton, mDoneButton.isEnabled() ? 255 : 128);
    }

    private void onNext()
    {
        if (Utility.requiredFieldValid(mDescription))
        {
            mAccount.setDescription(mDescription.getText().toString());
        }
        mAccount.setName(mName.getText().toString());
        mAccount.save(Preferences.getPreferences(this));
        finish();
    }

    public void onClick(View v)
    {
        switch (v.getId())
        {
            case R.id.done:
                onNext();
                break;
        }
    }
}
",False,216,0,0,8,53,2,4,L1
62,com.fsck.k9.activity.setup.SpinnerOption.java,"/**
 *
 */

package com.fsck.k9.activity.setup;

import android.widget.Spinner;

public class SpinnerOption
{
    public Object value;

    public String label;

    public static void setSpinnerOptionValue(Spinner spinner, Object value)
    {
        for (int i = 0, count = spinner.getCount(); i < count; i++)
        {
            SpinnerOption so = (SpinnerOption)spinner.getItemAtPosition(i);
            if (so.value.equals(value))
            {
                spinner.setSelection(i, true);
                return;
            }
        }
    }

    public SpinnerOption(Object value, String label)
    {
        this.value = value;
        this.label = label;
    }

    @Override
    public String toString()
    {
        return label;
    }
}
",True,92,9,39,0,0,3,0,L1
63,com.fsck.k9.activity.setup.AccountSettings.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.os.Vibrator;
import android.preference.CheckBoxPreference;
import android.preference.EditTextPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.preference.RingtonePreference;
import android.util.Log;
import android.view.KeyEvent;

import com.fsck.k9.Account;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.activity.ChooseFolder;
import com.fsck.k9.activity.ChooseIdentity;
import com.fsck.k9.activity.ColorPickerDialog;
import com.fsck.k9.activity.K9PreferenceActivity;
import com.fsck.k9.activity.ManageIdentities;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.crypto.Apg;
import com.fsck.k9.mail.Store;
import com.fsck.k9.service.MailService;

public class AccountSettings extends K9PreferenceActivity
{
    private static final String EXTRA_ACCOUNT = ""account"";

    private static final int SELECT_AUTO_EXPAND_FOLDER = 1;

    private static final int ACTIVITY_MANAGE_IDENTITIES = 2;

    private static final String PREFERENCE_TOP_CATERGORY = ""account_settings"";
    private static final String PREFERENCE_DESCRIPTION = ""account_description"";
    private static final String PREFERENCE_COMPOSITION = ""composition"";
    private static final String PREFERENCE_MANAGE_IDENTITIES = ""manage_identities"";
    private static final String PREFERENCE_FREQUENCY = ""account_check_frequency"";
    private static final String PREFERENCE_DISPLAY_COUNT = ""account_display_count"";
    private static final String PREFERENCE_DEFAULT = ""account_default"";
    private static final String PREFERENCE_HIDE_BUTTONS = ""hide_buttons_enum"";
    private static final String PREFERENCE_HIDE_MOVE_BUTTONS = ""hide_move_buttons_enum"";
    private static final String PREFERENCE_SHOW_PICTURES = ""show_pictures_enum"";
    private static final String PREFERENCE_ENABLE_MOVE_BUTTONS = ""enable_move_buttons"";
    private static final String PREFERENCE_NOTIFY = ""account_notify"";
    private static final String PREFERENCE_NOTIFY_SELF = ""account_notify_self"";
    private static final String PREFERENCE_NOTIFY_SYNC = ""account_notify_sync"";
    private static final String PREFERENCE_VIBRATE = ""account_vibrate"";
    private static final String PREFERENCE_VIBRATE_PATTERN = ""account_vibrate_pattern"";
    private static final String PREFERENCE_VIBRATE_TIMES = ""account_vibrate_times"";
    private static final String PREFERENCE_RINGTONE = ""account_ringtone"";
    private static final String PREFERENCE_NOTIFICATION_LED = ""account_led"";
    private static final String PREFERENCE_INCOMING = ""incoming"";
    private static final String PREFERENCE_OUTGOING = ""outgoing"";
    private static final String PREFERENCE_DISPLAY_MODE = ""folder_display_mode"";
    private static final String PREFERENCE_SYNC_MODE = ""folder_sync_mode"";
    private static final String PREFERENCE_PUSH_MODE = ""folder_push_mode"";
    private static final String PREFERENCE_TARGET_MODE = ""folder_target_mode"";
    private static final String PREFERENCE_DELETE_POLICY = ""delete_policy"";
    private static final String PREFERENCE_EXPUNGE_POLICY = ""expunge_policy"";
    private static final String PREFERENCE_AUTO_EXPAND_FOLDER = ""account_setup_auto_expand_folder"";
    private static final String PREFERENCE_SEARCHABLE_FOLDERS = ""searchable_folders"";
    private static final String PREFERENCE_CHIP_COLOR = ""chip_color"";
    private static final String PREFERENCE_LED_COLOR = ""led_color"";
    private static final String PREFERENCE_NOTIFICATION_OPENS_UNREAD = ""notification_opens_unread"";
    private static final String PREFERENCE_MESSAGE_AGE = ""account_message_age"";
    private static final String PREFERENCE_MESSAGE_SIZE = ""account_autodownload_size"";
    private static final String PREFERENCE_QUOTE_PREFIX = ""account_quote_prefix"";
    private static final String PREFERENCE_REPLY_AFTER_QUOTE = ""reply_after_quote"";
    private static final String PREFERENCE_SYNC_REMOTE_DELETIONS = ""account_sync_remote_deletetions"";
    private static final String PREFERENCE_CRYPTO_APP = ""crypto_app"";
    private static final String PREFERENCE_CRYPTO_AUTO_SIGNATURE = ""crypto_auto_signature"";

    private Account mAccount;

    private EditTextPreference mAccountDescription;
    private ListPreference mCheckFrequency;
    private ListPreference mDisplayCount;
    private ListPreference mMessageAge;
    private ListPreference mMessageSize;
    private CheckBoxPreference mAccountDefault;
    private CheckBoxPreference mAccountNotify;
    private CheckBoxPreference mAccountNotifySelf;
    private ListPreference mAccountHideButtons;
    private ListPreference mAccountHideMoveButtons;
    private ListPreference mAccountShowPictures;
    private CheckBoxPreference mAccountEnableMoveButtons;
    private CheckBoxPreference mAccountNotifySync;
    private CheckBoxPreference mAccountVibrate;
    private CheckBoxPreference mAccountLed;
    private ListPreference mAccountVibratePattern;
    private ListPreference mAccountVibrateTimes;
    private RingtonePreference mAccountRingtone;
    private ListPreference mDisplayMode;
    private ListPreference mSyncMode;
    private ListPreference mPushMode;
    private ListPreference mTargetMode;
    private ListPreference mDeletePolicy;
    private ListPreference mExpungePolicy;
    private ListPreference mSearchableFolders;
    private Preference mAutoExpandFolder;
    private Preference mChipColor;
    private Preference mLedColor;
    private boolean mIncomingChanged = false;
    private CheckBoxPreference mNotificationOpensUnread;
    private EditTextPreference mAccountQuotePrefix;
    private CheckBoxPreference mReplyAfterQuote;
    private CheckBoxPreference mSyncRemoteDeletions;
    private ListPreference mCryptoApp;
    private CheckBoxPreference mCryptoAutoSignature;

    public static void actionSettings(Context context, Account account)
    {
        Intent i = new Intent(context, AccountSettings.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        boolean isPushCapable = false;
        boolean isExpungeCapable = false;
        try
        {
            final Store store = mAccount.getRemoteStore();
            isPushCapable = store.isPushCapable();
            isExpungeCapable = store.isExpungeCapable();
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Could not get remote store"", e);
        }

        addPreferencesFromResource(R.xml.account_settings_preferences);

        Preference category = findPreference(PREFERENCE_TOP_CATERGORY);
        category.setTitle(getString(R.string.account_settings_title_fmt));

        mAccountDescription = (EditTextPreference) findPreference(PREFERENCE_DESCRIPTION);
        mAccountDescription.setSummary(mAccount.getDescription());
        mAccountDescription.setText(mAccount.getDescription());
        mAccountDescription.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                mAccountDescription.setSummary(summary);
                mAccountDescription.setText(summary);
                return false;
            }
        });

        mAccountQuotePrefix = (EditTextPreference) findPreference(PREFERENCE_QUOTE_PREFIX);
        mAccountQuotePrefix.setSummary(mAccount.getQuotePrefix());
        mAccountQuotePrefix.setText(mAccount.getQuotePrefix());
        mAccountQuotePrefix.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String value = newValue.toString();
                mAccountQuotePrefix.setSummary(value);
                mAccountQuotePrefix.setText(value);
                return false;
            }
        });

        mReplyAfterQuote = (CheckBoxPreference) findPreference(PREFERENCE_REPLY_AFTER_QUOTE);
        mReplyAfterQuote.setChecked(mAccount.isReplyAfterQuote());

        mCheckFrequency = (ListPreference) findPreference(PREFERENCE_FREQUENCY);
        mCheckFrequency.setValue(String.valueOf(mAccount.getAutomaticCheckIntervalMinutes()));
        mCheckFrequency.setSummary(mCheckFrequency.getEntry());
        mCheckFrequency.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mCheckFrequency.findIndexOfValue(summary);
                mCheckFrequency.setSummary(mCheckFrequency.getEntries()[index]);
                mCheckFrequency.setValue(summary);
                return false;
            }
        });

        mDisplayMode = (ListPreference) findPreference(PREFERENCE_DISPLAY_MODE);
        mDisplayMode.setValue(mAccount.getFolderDisplayMode().name());
        mDisplayMode.setSummary(mDisplayMode.getEntry());
        mDisplayMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mDisplayMode.findIndexOfValue(summary);
                mDisplayMode.setSummary(mDisplayMode.getEntries()[index]);
                mDisplayMode.setValue(summary);
                return false;
            }
        });

        mSyncMode = (ListPreference) findPreference(PREFERENCE_SYNC_MODE);
        mSyncMode.setValue(mAccount.getFolderSyncMode().name());
        mSyncMode.setSummary(mSyncMode.getEntry());
        mSyncMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mSyncMode.findIndexOfValue(summary);
                mSyncMode.setSummary(mSyncMode.getEntries()[index]);
                mSyncMode.setValue(summary);
                return false;
            }
        });

        mPushMode = (ListPreference) findPreference(PREFERENCE_PUSH_MODE);
        mPushMode.setEnabled(isPushCapable);
        mPushMode.setValue(mAccount.getFolderPushMode().name());
        mPushMode.setSummary(mPushMode.getEntry());
        mPushMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mPushMode.findIndexOfValue(summary);
                mPushMode.setSummary(mPushMode.getEntries()[index]);
                mPushMode.setValue(summary);
                return false;
            }
        });

        mTargetMode = (ListPreference) findPreference(PREFERENCE_TARGET_MODE);
        mTargetMode.setValue(mAccount.getFolderTargetMode().name());
        mTargetMode.setSummary(mTargetMode.getEntry());
        mTargetMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mTargetMode.findIndexOfValue(summary);
                mTargetMode.setSummary(mTargetMode.getEntries()[index]);
                mTargetMode.setValue(summary);
                return false;
            }
        });

        mDeletePolicy = (ListPreference) findPreference(PREFERENCE_DELETE_POLICY);
        mDeletePolicy.setValue("""" + mAccount.getDeletePolicy());
        mDeletePolicy.setSummary(mDeletePolicy.getEntry());
        mDeletePolicy.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mDeletePolicy.findIndexOfValue(summary);
                mDeletePolicy.setSummary(mDeletePolicy.getEntries()[index]);
                mDeletePolicy.setValue(summary);
                return false;
            }
        });


        mExpungePolicy = (ListPreference) findPreference(PREFERENCE_EXPUNGE_POLICY);
        mExpungePolicy.setEnabled(isExpungeCapable);
        mExpungePolicy.setValue(mAccount.getExpungePolicy());
        mExpungePolicy.setSummary(mExpungePolicy.getEntry());
        mExpungePolicy.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mExpungePolicy.findIndexOfValue(summary);
                mExpungePolicy.setSummary(mExpungePolicy.getEntries()[index]);
                mExpungePolicy.setValue(summary);
                return false;
            }
        });

        mSyncRemoteDeletions = (CheckBoxPreference) findPreference(PREFERENCE_SYNC_REMOTE_DELETIONS);
        mSyncRemoteDeletions.setChecked(mAccount.syncRemoteDeletions());

        mSearchableFolders = (ListPreference) findPreference(PREFERENCE_SEARCHABLE_FOLDERS);
        mSearchableFolders.setValue(mAccount.getSearchableFolders().name());
        mSearchableFolders.setSummary(mSearchableFolders.getEntry());
        mSearchableFolders.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mSearchableFolders.findIndexOfValue(summary);
                mSearchableFolders.setSummary(mSearchableFolders.getEntries()[index]);
                mSearchableFolders.setValue(summary);
                return false;
            }
        });

        mDisplayCount = (ListPreference) findPreference(PREFERENCE_DISPLAY_COUNT);
        mDisplayCount.setValue(String.valueOf(mAccount.getDisplayCount()));
        mDisplayCount.setSummary(mDisplayCount.getEntry());
        mDisplayCount.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mDisplayCount.findIndexOfValue(summary);
                mDisplayCount.setSummary(mDisplayCount.getEntries()[index]);
                mDisplayCount.setValue(summary);
                return false;
            }
        });

        mMessageAge = (ListPreference) findPreference(PREFERENCE_MESSAGE_AGE);
        mMessageAge.setValue(String.valueOf(mAccount.getMaximumPolledMessageAge()));
        mMessageAge.setSummary(mMessageAge.getEntry());
        mMessageAge.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mMessageAge.findIndexOfValue(summary);
                mMessageAge.setSummary(mMessageAge.getEntries()[index]);
                mMessageAge.setValue(summary);
                return false;
            }
        });



        mMessageSize = (ListPreference) findPreference(PREFERENCE_MESSAGE_SIZE);
        mMessageSize.setValue(String.valueOf(mAccount.getMaximumAutoDownloadMessageSize()));
        mMessageSize.setSummary(mMessageSize.getEntry());
        mMessageSize.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mMessageSize.findIndexOfValue(summary);
                mMessageSize.setSummary(mMessageSize.getEntries()[index]);
                mMessageSize.setValue(summary);
                return false;
            }
        });



        mAccountDefault = (CheckBoxPreference) findPreference(PREFERENCE_DEFAULT);
        mAccountDefault.setChecked(
            mAccount.equals(Preferences.getPreferences(this).getDefaultAccount()));


        mAccountHideButtons = (ListPreference) findPreference(PREFERENCE_HIDE_BUTTONS);
        mAccountHideButtons.setValue("""" + mAccount.getHideMessageViewButtons());
        mAccountHideButtons.setSummary(mAccountHideButtons.getEntry());
        mAccountHideButtons.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mAccountHideButtons.findIndexOfValue(summary);
                mAccountHideButtons.setSummary(mAccountHideButtons.getEntries()[index]);
                mAccountHideButtons.setValue(summary);
                return false;
            }
        });

        mAccountEnableMoveButtons = (CheckBoxPreference) findPreference(PREFERENCE_ENABLE_MOVE_BUTTONS);
        mAccountEnableMoveButtons.setChecked(mAccount.getEnableMoveButtons());

        mAccountHideMoveButtons = (ListPreference) findPreference(PREFERENCE_HIDE_MOVE_BUTTONS);
        mAccountHideMoveButtons.setValue("""" + mAccount.getHideMessageViewMoveButtons());
        mAccountHideMoveButtons.setSummary(mAccountHideMoveButtons.getEntry());
        mAccountHideMoveButtons.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mAccountHideMoveButtons.findIndexOfValue(summary);
                mAccountHideMoveButtons.setSummary(mAccountHideMoveButtons.getEntries()[index]);
                mAccountHideMoveButtons.setValue(summary);
                return false;
            }
        });

        mAccountShowPictures = (ListPreference) findPreference(PREFERENCE_SHOW_PICTURES);
        mAccountShowPictures.setValue("""" + mAccount.getShowPictures());
        mAccountShowPictures.setSummary(mAccountShowPictures.getEntry());
        mAccountShowPictures.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mAccountShowPictures.findIndexOfValue(summary);
                mAccountShowPictures.setSummary(mAccountShowPictures.getEntries()[index]);
                mAccountShowPictures.setValue(summary);
                return false;
            }
        });

        mAccountNotify = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFY);
        mAccountNotify.setChecked(mAccount.isNotifyNewMail());

        mAccountNotifySelf = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFY_SELF);
        mAccountNotifySelf.setChecked(mAccount.isNotifySelfNewMail());

        mAccountNotifySync = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFY_SYNC);
        mAccountNotifySync.setChecked(mAccount.isShowOngoing());

        mAccountRingtone = (RingtonePreference) findPreference(PREFERENCE_RINGTONE);

        // XXX: The following two lines act as a workaround for the RingtonePreference
        //      which does not let us set/get the value programmatically
        SharedPreferences prefs = mAccountRingtone.getPreferenceManager().getSharedPreferences();
        String currentRingtone = (!mAccount.getNotificationSetting().shouldRing() ? null : mAccount.getNotificationSetting().getRingtone());
        prefs.edit().putString(PREFERENCE_RINGTONE, currentRingtone).commit();

        mAccountVibrate = (CheckBoxPreference) findPreference(PREFERENCE_VIBRATE);
        mAccountVibrate.setChecked(mAccount.getNotificationSetting().isVibrate());

        mAccountVibratePattern = (ListPreference) findPreference(PREFERENCE_VIBRATE_PATTERN);
        mAccountVibratePattern.setValue(String.valueOf(mAccount.getNotificationSetting().getVibratePattern()));
        mAccountVibratePattern.setSummary(mAccountVibratePattern.getEntry());
        mAccountVibratePattern.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String summary = newValue.toString();
                int index = mAccountVibratePattern.findIndexOfValue(summary);
                mAccountVibratePattern.setSummary(mAccountVibratePattern.getEntries()[index]);
                mAccountVibratePattern.setValue(summary);
                doVibrateTest(preference);
                return false;
            }
        });

        mAccountVibrateTimes = (ListPreference) findPreference(PREFERENCE_VIBRATE_TIMES);
        mAccountVibrateTimes.setValue(String.valueOf(mAccount.getNotificationSetting().getVibrateTimes()));
        mAccountVibrateTimes.setSummary(String.valueOf(mAccount.getNotificationSetting().getVibrateTimes()));
        mAccountVibrateTimes.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                final String value = newValue.toString();
                mAccountVibrateTimes.setSummary(value);
                mAccountVibrateTimes.setValue(value);
                doVibrateTest(preference);
                return false;
            }
        });

        mAccountLed = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFICATION_LED);
        mAccountLed.setChecked(mAccount.getNotificationSetting().isLed());

        mNotificationOpensUnread = (CheckBoxPreference)findPreference(PREFERENCE_NOTIFICATION_OPENS_UNREAD);
        mNotificationOpensUnread.setChecked(mAccount.goToUnreadMessageSearch());


        mAutoExpandFolder = (Preference)findPreference(PREFERENCE_AUTO_EXPAND_FOLDER);

        mAutoExpandFolder.setSummary(translateFolder(mAccount.getAutoExpandFolderName()));

        mAutoExpandFolder.setOnPreferenceClickListener(
            new Preference.OnPreferenceClickListener()
        {
            public boolean onPreferenceClick(Preference preference)
            {
                onChooseAutoExpandFolder();
                return false;
            }
        }
        );


        mChipColor = (Preference)findPreference(PREFERENCE_CHIP_COLOR);

        mChipColor.setOnPreferenceClickListener(
            new Preference.OnPreferenceClickListener()
        {
            public boolean onPreferenceClick(Preference preference)
            {
                onChooseChipColor();
                return false;
            }
        }
        );

        mLedColor = (Preference)findPreference(PREFERENCE_LED_COLOR);

        mLedColor.setOnPreferenceClickListener(
            new Preference.OnPreferenceClickListener()
        {
            public boolean onPreferenceClick(Preference preference)
            {
                onChooseLedColor();
                return false;
            }
        }
        );



        findPreference(PREFERENCE_COMPOSITION).setOnPreferenceClickListener(
            new Preference.OnPreferenceClickListener()
        {
            public boolean onPreferenceClick(Preference preference)
            {
                onCompositionSettings();
                return true;
            }
        });

        findPreference(PREFERENCE_MANAGE_IDENTITIES).setOnPreferenceClickListener(
            new Preference.OnPreferenceClickListener()
        {
            public boolean onPreferenceClick(Preference preference)
            {
                onManageIdentities();
                return true;
            }
        });

        findPreference(PREFERENCE_INCOMING).setOnPreferenceClickListener(
            new Preference.OnPreferenceClickListener()
        {
            public boolean onPreferenceClick(Preference preference)
            {
                mIncomingChanged = true;
                onIncomingSettings();
                return true;
            }
        });

        findPreference(PREFERENCE_OUTGOING).setOnPreferenceClickListener(
            new Preference.OnPreferenceClickListener()
        {
            public boolean onPreferenceClick(Preference preference)
            {
                onOutgoingSettings();
                return true;
            }
        });

        mCryptoApp = (ListPreference) findPreference(PREFERENCE_CRYPTO_APP);
        CharSequence cryptoAppEntries[] = mCryptoApp.getEntries();
        if (!new Apg().isAvailable(this))
        {
            int apgIndex = mCryptoApp.findIndexOfValue(Apg.NAME);
            if (apgIndex >= 0)
            {
                cryptoAppEntries[apgIndex] = ""APG ("" + getResources().getString(R.string.account_settings_crypto_app_not_available) + "")"";
                mCryptoApp.setEntries(cryptoAppEntries);
            }
        }
        mCryptoApp.setValue(String.valueOf(mAccount.getCryptoApp()));
        mCryptoApp.setSummary(mCryptoApp.getEntry());
        mCryptoApp.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()
        {
            public boolean onPreferenceChange(Preference preference, Object newValue)
            {
                String value = newValue.toString();
                int index = mCryptoApp.findIndexOfValue(value);
                mCryptoApp.setSummary(mCryptoApp.getEntries()[index]);
                mCryptoApp.setValue(value);
                handleCryptoAppDependencies();
                if (Apg.NAME.equals(value))
                {
                    Apg.createInstance(null).test(AccountSettings.this);
                }
                return false;
            }
        });

        mCryptoAutoSignature = (CheckBoxPreference) findPreference(PREFERENCE_CRYPTO_AUTO_SIGNATURE);
        mCryptoAutoSignature.setChecked(mAccount.getCryptoAutoSignature());

        handleCryptoAppDependencies();
    }

    private void handleCryptoAppDependencies()
    {
        if ("""".equals(mCryptoApp.getValue()))
        {
            mCryptoAutoSignature.setEnabled(false);
        }
        else
        {
            mCryptoAutoSignature.setEnabled(true);
        }
    }

    @Override
    public void onResume()
    {
        super.onResume();
        //mAccount.refresh(Preferences.getPreferences(this));
    }

    private void saveSettings()
    {
        if (mAccountDefault.isChecked())
        {
            Preferences.getPreferences(this).setDefaultAccount(mAccount);
        }

        mAccount.setDescription(mAccountDescription.getText());
        mAccount.setNotifyNewMail(mAccountNotify.isChecked());
        mAccount.setNotifySelfNewMail(mAccountNotifySelf.isChecked());
        mAccount.setShowOngoing(mAccountNotifySync.isChecked());
        mAccount.setDisplayCount(Integer.parseInt(mDisplayCount.getValue()));
        mAccount.setMaximumPolledMessageAge(Integer.parseInt(mMessageAge.getValue()));
        mAccount.setMaximumAutoDownloadMessageSize(Integer.parseInt(mMessageSize.getValue()));
        mAccount.getNotificationSetting().setVibrate(mAccountVibrate.isChecked());
        mAccount.getNotificationSetting().setVibratePattern(Integer.parseInt(mAccountVibratePattern.getValue()));
        mAccount.getNotificationSetting().setVibrateTimes(Integer.parseInt(mAccountVibrateTimes.getValue()));
        mAccount.getNotificationSetting().setLed(mAccountLed.isChecked());
        mAccount.setGoToUnreadMessageSearch(mNotificationOpensUnread.isChecked());
        mAccount.setFolderTargetMode(Account.FolderMode.valueOf(mTargetMode.getValue()));
        mAccount.setDeletePolicy(Integer.parseInt(mDeletePolicy.getValue()));
        mAccount.setExpungePolicy(mExpungePolicy.getValue());
        mAccount.setSyncRemoteDeletions(mSyncRemoteDeletions.isChecked());
        mAccount.setSearchableFolders(Account.Searchable.valueOf(mSearchableFolders.getValue()));
        mAccount.setQuotePrefix(mAccountQuotePrefix.getText());
        mAccount.setReplyAfterQuote(mReplyAfterQuote.isChecked());
        mAccount.setCryptoApp(mCryptoApp.getValue());
        mAccount.setCryptoAutoSignature(mCryptoAutoSignature.isChecked());

        boolean needsRefresh = mAccount.setAutomaticCheckIntervalMinutes(Integer.parseInt(mCheckFrequency.getValue()));
        needsRefresh |= mAccount.setFolderSyncMode(Account.FolderMode.valueOf(mSyncMode.getValue()));

        boolean needsPushRestart = mAccount.setFolderPushMode(Account.FolderMode.valueOf(mPushMode.getValue()));
        boolean displayModeChanged = mAccount.setFolderDisplayMode(Account.FolderMode.valueOf(mDisplayMode.getValue()));

        if (mAccount.getFolderPushMode() != FolderMode.NONE)
        {
            needsPushRestart |= displayModeChanged;
            needsPushRestart |= mIncomingChanged;
        }

        SharedPreferences prefs = mAccountRingtone.getPreferenceManager().getSharedPreferences();
        String newRingtone = prefs.getString(PREFERENCE_RINGTONE, null);
        if (newRingtone != null)
        {
            mAccount.getNotificationSetting().setRing(true);
            mAccount.getNotificationSetting().setRingtone(newRingtone);
        }
        else
        {
            if (mAccount.getNotificationSetting().shouldRing())
            {
                mAccount.getNotificationSetting().setRingtone(null);
            }
        }

        mAccount.setHideMessageViewButtons(Account.HideButtons.valueOf(mAccountHideButtons.getValue()));
        mAccount.setHideMessageViewMoveButtons(Account.HideButtons.valueOf(mAccountHideMoveButtons.getValue()));
        mAccount.setShowPictures(Account.ShowPictures.valueOf(mAccountShowPictures.getValue()));
        mAccount.setEnableMoveButtons(mAccountEnableMoveButtons.isChecked());
        mAccount.setAutoExpandFolderName(reverseTranslateFolder(mAutoExpandFolder.getSummary().toString()));
        mAccount.save(Preferences.getPreferences(this));
        if (needsRefresh && needsPushRestart)
        {
            MailService.actionReset(this, null);
        }
        else if (needsRefresh)
        {
            MailService.actionReschedulePoll(this, null);
        }
        else if (needsPushRestart)
        {
            MailService.actionRestartPushers(this, null);
        }
        // TODO: refresh folder list here
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        if (resultCode == RESULT_OK)
        {
            switch (requestCode)
            {
                case SELECT_AUTO_EXPAND_FOLDER:
                    mAutoExpandFolder.setSummary(translateFolder(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER)));
                    break;
            }
        }
        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (keyCode == KeyEvent.KEYCODE_BACK)
        {
            saveSettings();
        }
        return super.onKeyDown(keyCode, event);
    }

    private void onCompositionSettings()
    {
        AccountSetupComposition.actionEditCompositionSettings(this, mAccount);
    }

    private void onManageIdentities()
    {
        Intent intent = new Intent(this, ManageIdentities.class);
        intent.putExtra(ChooseIdentity.EXTRA_ACCOUNT, mAccount.getUuid());
        startActivityForResult(intent, ACTIVITY_MANAGE_IDENTITIES);
    }

    private void onIncomingSettings()
    {
        AccountSetupIncoming.actionEditIncomingSettings(this, mAccount);
    }

    private void onOutgoingSettings()
    {
        AccountSetupOutgoing.actionEditOutgoingSettings(this, mAccount);
    }

    public void onChooseChipColor()
    {
        new ColorPickerDialog(this, new ColorPickerDialog.OnColorChangedListener()
        {
            public void colorChanged(int color)
            {
                mAccount.setChipColor(color);
            }
        },
        mAccount.getChipColor()).show();
    }

    public void onChooseLedColor()
    {
        new ColorPickerDialog(this, new ColorPickerDialog.OnColorChangedListener()
        {
            public void colorChanged(int color)
            {
                mAccount.getNotificationSetting().setLedColor(color);
            }
        },
        mAccount.getNotificationSetting().getLedColor()).show();
    }

    public void onChooseAutoExpandFolder()
    {
        Intent selectIntent = new Intent(this, ChooseFolder.class);
        selectIntent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());

        selectIntent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, mAutoExpandFolder.getSummary());
        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_CURRENT, ""yes"");
        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_FOLDER_NONE, ""yes"");
        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_DISPLAYABLE_ONLY, ""yes"");
        startActivityForResult(selectIntent, SELECT_AUTO_EXPAND_FOLDER);

    }

    private String translateFolder(String in)
    {

        if (K9.INBOX.equalsIgnoreCase(in))
        {
            return getString(R.string.special_mailbox_name_inbox);
        }
        else
        {
            return in;
        }
    }

    private String reverseTranslateFolder(String in)
    {

        if (getString(R.string.special_mailbox_name_inbox).equals(in))
        {
            return K9.INBOX;
        }
        else
        {
            return in;
        }
    }

    private void doVibrateTest(Preference preference)
    {
        // Do the vibration to show the user what it's like.
        Vibrator vibrate = (Vibrator)preference.getContext().getSystemService(Context.VIBRATOR_SERVICE);
        long[] pattern = MessagingController.getVibratePattern(
                             Integer.parseInt(mAccountVibratePattern.getValue()),
                             Integer.parseInt(mAccountVibrateTimes.getValue()));
        vibrate.vibrate(pattern, -1);
    }
}
",True,216,0,0,7,63,4,17,L1
64,com.fsck.k9.activity.setup.AccountSetupIncoming.java,"
package com.fsck.k9.activity.setup;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.text.method.DigitsKeyListener;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.*;

import com.fsck.k9.*;
import com.fsck.k9.activity.ChooseFolder;
import com.fsck.k9.activity.K9Activity;
import com.fsck.k9.helper.Utility;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public class AccountSetupIncoming extends K9Activity implements OnClickListener
{
    private static final String EXTRA_ACCOUNT = ""account"";
    private static final String EXTRA_MAKE_DEFAULT = ""makeDefault"";

    private static final int SELECT_DRAFT_FOLDER = 100;
    private static final int SELECT_SENT_FOLDER = 101;
    private static final int SELECT_TRASH_FOLDER = 102;
    private static final int SELECT_ARCHIVE_FOLDER = 103;
    private static final int SELECT_SPAM_FOLDER = 104;

    private static final int popPorts[] =
    {
        110, 995, 995, 110, 110
    };
    private static final String popSchemes[] =
    {
        ""pop3"", ""pop3+ssl"", ""pop3+ssl+"", ""pop3+tls"", ""pop3+tls+""
    };
    private static final int imapPorts[] =
    {
        143, 993, 993, 143, 143
    };
    private static final String imapSchemes[] =
    {
        ""imap"", ""imap+ssl"", ""imap+ssl+"", ""imap+tls"", ""imap+tls+""
    };
    private static final int webdavPorts[] =
    {
        80, 443, 443, 443, 443
    };
    private static final String webdavSchemes[] =
    {
        ""webdav"", ""webdav+ssl"", ""webdav+ssl+"", ""webdav+tls"", ""webdav+tls+""
    };

    private static final String authTypes[] =
    {
        ""PLAIN"", ""CRAM_MD5""
    };


    private int mAccountPorts[];
    private String mAccountSchemes[];
    private EditText mUsernameView;
    private EditText mPasswordView;
    private EditText mServerView;
    private EditText mPortView;
    private Spinner mSecurityTypeView;
    private Spinner mAuthTypeView;
    private EditText mImapPathPrefixView;
    private Button mImapFolderDrafts;
    private Button mImapFolderSent;
    private Button mImapFolderTrash;
    private Button mImapFolderArchive;
    private Button mImapFolderSpam;
    private EditText mImapFolderOutbox;
    private EditText mWebdavPathPrefixView;
    private EditText mWebdavAuthPathView;
    private EditText mWebdavMailboxPathView;
    private Button mNextButton;
    private Account mAccount;
    private boolean mMakeDefault;
    private CheckBox compressionMobile;
    private CheckBox compressionWifi;
    private CheckBox compressionOther;
    private CheckBox saveAllHeaders;
    private CheckBox pushPollOnConnect;
    private Spinner idleRefreshPeriod;
    private Spinner folderPushLimit;
    private CheckBox subscribedFoldersOnly;

    public static void actionIncomingSettings(Activity context, Account account, boolean makeDefault)
    {
        Intent i = new Intent(context, AccountSetupIncoming.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
        context.startActivity(i);
    }

    public static void actionEditIncomingSettings(Activity context, Account account)
    {
        Intent i = new Intent(context, AccountSetupIncoming.class);
        i.setAction(Intent.ACTION_EDIT);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_incoming);

        mUsernameView = (EditText)findViewById(R.id.account_username);
        mPasswordView = (EditText)findViewById(R.id.account_password);
        TextView serverLabelView = (TextView) findViewById(R.id.account_server_label);
        mServerView = (EditText)findViewById(R.id.account_server);
        mPortView = (EditText)findViewById(R.id.account_port);
        mSecurityTypeView = (Spinner)findViewById(R.id.account_security_type);
        mAuthTypeView = (Spinner)findViewById(R.id.account_auth_type);
        mImapPathPrefixView = (EditText)findViewById(R.id.imap_path_prefix);
        mImapFolderDrafts = (Button)findViewById(R.id.account_imap_folder_drafts);
        mImapFolderSent = (Button)findViewById(R.id.account_imap_folder_sent);
        mImapFolderTrash = (Button)findViewById(R.id.account_imap_folder_trash);
        mImapFolderArchive = (Button)findViewById(R.id.account_imap_folder_archive);
        mImapFolderSpam = (Button)findViewById(R.id.account_imap_folder_spam);
        mImapFolderOutbox = (EditText)findViewById(R.id.account_imap_folder_outbox);
        mWebdavPathPrefixView = (EditText)findViewById(R.id.webdav_path_prefix);
        mWebdavAuthPathView = (EditText)findViewById(R.id.webdav_auth_path);
        mWebdavMailboxPathView = (EditText)findViewById(R.id.webdav_mailbox_path);
        mNextButton = (Button)findViewById(R.id.next);
        compressionMobile = (CheckBox)findViewById(R.id.compression_mobile);
        compressionWifi = (CheckBox)findViewById(R.id.compression_wifi);
        compressionOther = (CheckBox)findViewById(R.id.compression_other);
        saveAllHeaders = (CheckBox)findViewById(R.id.save_all_headers);
        pushPollOnConnect = (CheckBox)findViewById(R.id.push_poll_on_connect);

        subscribedFoldersOnly = (CheckBox)findViewById(R.id.subscribed_folders_only);
        idleRefreshPeriod = (Spinner)findViewById(R.id.idle_refresh_period);

        folderPushLimit = (Spinner)findViewById(R.id.folder_push_limit);

        mImapFolderDrafts.setOnClickListener(this);
        mImapFolderSent.setOnClickListener(this);
        mImapFolderTrash.setOnClickListener(this);
        mImapFolderArchive.setOnClickListener(this);
        mImapFolderSpam.setOnClickListener(this);
        mNextButton.setOnClickListener(this);

        SpinnerOption securityTypes[] =
        {
            new SpinnerOption(0, getString(R.string.account_setup_incoming_security_none_label)),
            new SpinnerOption(1,
            getString(R.string.account_setup_incoming_security_ssl_optional_label)),
            new SpinnerOption(2, getString(R.string.account_setup_incoming_security_ssl_label)),
            new SpinnerOption(3,
            getString(R.string.account_setup_incoming_security_tls_optional_label)),
            new SpinnerOption(4, getString(R.string.account_setup_incoming_security_tls_label)),
        };

        // This needs to be kept in sync with the list at the top of the file.
        // that makes me somewhat unhappy
        SpinnerOption authTypeSpinnerOptions[] =
        {
            new SpinnerOption(0, ""PLAIN""),
            new SpinnerOption(1, ""CRAM_MD5"")
        };

        ArrayAdapter<SpinnerOption> securityTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, securityTypes);
        securityTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mSecurityTypeView.setAdapter(securityTypesAdapter);

        ArrayAdapter<SpinnerOption> authTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, authTypeSpinnerOptions);
        authTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mAuthTypeView.setAdapter(authTypesAdapter);

        /*
         * Updates the port when the user changes the security type. This allows
         * us to show a reasonable default which the user can change.
         */
        mSecurityTypeView.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener()
        {
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id)
            {
                updatePortFromSecurityType();
            }

            public void onNothingSelected(AdapterView<?> parent)
            {
            }
        });

        /*
         * Calls validateFields() which enables or disables the Next button
         * based on the fields' validity.
         */
        TextWatcher validationTextWatcher = new TextWatcher()
        {
            public void afterTextChanged(Editable s)
            {
                validateFields();
            }

            public void beforeTextChanged(CharSequence s, int start, int count, int after)
            {
            }

            public void onTextChanged(CharSequence s, int start, int before, int count)
            {
            }
        };
        mUsernameView.addTextChangedListener(validationTextWatcher);
        mPasswordView.addTextChangedListener(validationTextWatcher);
        mServerView.addTextChangedListener(validationTextWatcher);
        mPortView.addTextChangedListener(validationTextWatcher);

        /*
         * Only allow digits in the port field.
         */
        mPortView.setKeyListener(DigitsKeyListener.getInstance(""0123456789""));

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mMakeDefault = (boolean)getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false);

        /*
         * If we're being reloaded we override the original account with the one
         * we saved
         */
        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT))
        {
            accountUuid = savedInstanceState.getString(EXTRA_ACCOUNT);
            mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        }

        try
        {
            URI uri = new URI(mAccount.getStoreUri());
            String username = null;
            String password = null;
            String authType = null;

            if (uri.getUserInfo() != null)
            {
                String[] userInfoParts = uri.getUserInfo().split("":"");
                if (userInfoParts.length == 3)
                {
                    authType = userInfoParts[0];
                    username = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                    password = URLDecoder.decode(userInfoParts[2], ""UTF-8"");
                }
                else if (userInfoParts.length == 2)
                {
                    username = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                    password = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
                else if (userInfoParts.length == 1)
                {
                    username = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                }
            }



            if (username != null)
            {
                mUsernameView.setText(username);
            }

            if (password != null)
            {
                mPasswordView.setText(password);
            }

            if (authType != null)
            {
                for (int i = 0; i < authTypes.length; i++)
                {
                    if (authTypes[i].equals(authType))
                    {
                        SpinnerOption.setSpinnerOptionValue(mAuthTypeView, i);
                    }
                }
            }


            mImapFolderDrafts.setText(mAccount.getDraftsFolderName());
            mImapFolderSent.setText(mAccount.getSentFolderName());
            mImapFolderTrash.setText(mAccount.getTrashFolderName());
            mImapFolderArchive.setText(mAccount.getArchiveFolderName());
            mImapFolderSpam.setText(mAccount.getSpamFolderName());
            mImapFolderOutbox.setText(mAccount.getOutboxFolderName());

            if (uri.getScheme().startsWith(""pop3""))
            {
                serverLabelView.setText(R.string.account_setup_incoming_pop_server_label);
                mAccountPorts = popPorts;
                mAccountSchemes = popSchemes;

                findViewById(R.id.imap_path_prefix_section).setVisibility(View.GONE);
                findViewById(R.id.imap_folder_setup_section).setVisibility(View.GONE);
                findViewById(R.id.webdav_path_prefix_section).setVisibility(View.GONE);
                findViewById(R.id.webdav_path_debug_section).setVisibility(View.GONE);
                findViewById(R.id.account_auth_type_label).setVisibility(View.GONE);
                findViewById(R.id.account_auth_type).setVisibility(View.GONE);
                findViewById(R.id.compression_section).setVisibility(View.GONE);
                findViewById(R.id.compression_label).setVisibility(View.GONE);
                findViewById(R.id.push_poll_on_connect_section).setVisibility(View.GONE);
                findViewById(R.id.idle_refresh_period_label).setVisibility(View.GONE);
                findViewById(R.id.idle_refresh_period).setVisibility(View.GONE);
                findViewById(R.id.account_setup_push_limit_label).setVisibility(View.GONE);
                findViewById(R.id.folder_push_limit).setVisibility(View.GONE);
                mAccount.setDeletePolicy(Account.DELETE_POLICY_NEVER);


            }
            else if (uri.getScheme().startsWith(""imap""))
            {
                serverLabelView.setText(R.string.account_setup_incoming_imap_server_label);
                mAccountPorts = imapPorts;
                mAccountSchemes = imapSchemes;

                if (uri.getPath() != null && uri.getPath().length() > 0)
                {
                    mImapPathPrefixView.setText(uri.getPath().substring(1));
                }
                findViewById(R.id.webdav_path_prefix_section).setVisibility(View.GONE);
                findViewById(R.id.webdav_path_debug_section).setVisibility(View.GONE);
                mAccount.setDeletePolicy(Account.DELETE_POLICY_ON_DELETE);

                if (! Intent.ACTION_EDIT.equals(getIntent().getAction()))
                {
                    findViewById(R.id.imap_folder_setup_section).setVisibility(View.GONE);
                }

            }
            else if (uri.getScheme().startsWith(""webdav""))
            {
                serverLabelView.setText(R.string.account_setup_incoming_webdav_server_label);
                mAccountPorts = webdavPorts;
                mAccountSchemes = webdavSchemes;

                /** Hide the unnecessary fields */
                findViewById(R.id.imap_path_prefix_section).setVisibility(View.GONE);
                findViewById(R.id.account_auth_type_label).setVisibility(View.GONE);
                findViewById(R.id.account_auth_type).setVisibility(View.GONE);
                findViewById(R.id.compression_section).setVisibility(View.GONE);
                findViewById(R.id.compression_label).setVisibility(View.GONE);
                findViewById(R.id.push_poll_on_connect_section).setVisibility(View.GONE);
                findViewById(R.id.idle_refresh_period_label).setVisibility(View.GONE);
                findViewById(R.id.idle_refresh_period).setVisibility(View.GONE);
                findViewById(R.id.account_setup_push_limit_label).setVisibility(View.GONE);
                findViewById(R.id.folder_push_limit).setVisibility(View.GONE);
                subscribedFoldersOnly.setVisibility(View.GONE);
                if (uri.getPath() != null && uri.getPath().length() > 0)
                {
                    String[] pathParts = uri.getPath().split(""\\|"");

                    for (int i = 0, count = pathParts.length; i < count; i++)
                    {
                        if (i == 0)
                        {
                            if (pathParts[0] != null &&
                                    pathParts[0].length() > 1)
                            {
                                mWebdavPathPrefixView.setText(pathParts[0].substring(1));
                            }
                        }
                        else if (i == 1)
                        {
                            if (pathParts[1] != null &&
                                    pathParts[1].length() > 1)
                            {
                                mWebdavAuthPathView.setText(pathParts[1]);
                            }
                        }
                        else if (i == 2)
                        {
                            if (pathParts[2] != null &&
                                    pathParts[2].length() > 1)
                            {
                                mWebdavMailboxPathView.setText(pathParts[2]);
                            }
                        }
                    }
                }
                mAccount.setDeletePolicy(Account.DELETE_POLICY_ON_DELETE);
            }
            else
            {
                throw new Exception(""Unknown account type: "" + mAccount.getStoreUri());
            }

            for (int i = 0; i < mAccountSchemes.length; i++)
            {
                if (mAccountSchemes[i].equals(uri.getScheme()))
                {
                    SpinnerOption.setSpinnerOptionValue(mSecurityTypeView, i);
                }
            }
            compressionMobile.setChecked(mAccount.useCompression(Account.TYPE_MOBILE));
            compressionWifi.setChecked(mAccount.useCompression(Account.TYPE_WIFI));
            compressionOther.setChecked(mAccount.useCompression(Account.TYPE_OTHER));

            if (uri.getHost() != null)
            {
                mServerView.setText(uri.getHost());
            }

            if (uri.getPort() != -1)
            {
                mPortView.setText(Integer.toString(uri.getPort()));
            }
            else
            {
                updatePortFromSecurityType();
            }

            saveAllHeaders.setChecked(mAccount.isSaveAllHeaders());
            pushPollOnConnect.setChecked(mAccount.isPushPollOnConnect());
            subscribedFoldersOnly.setChecked(mAccount.subscribedFoldersOnly());
            SpinnerHelper.initSpinner(this, idleRefreshPeriod, R.array.idle_refresh_period_entries,
                                      R.array.idle_refresh_period_values, String.valueOf(mAccount.getIdleRefreshMinutes()));

            SpinnerHelper.initSpinner(this, folderPushLimit, R.array.account_settings_push_limit_entries,
                                      R.array.account_settings_push_limit_values, String.valueOf(mAccount.getMaxPushFolders()));

            validateFields();
        }
        catch (Exception e)
        {
            failure(e);
        }

    }

    @Override
    public void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        outState.putString(EXTRA_ACCOUNT, mAccount.getUuid());
    }

    private void validateFields()
    {
        mNextButton
        .setEnabled(Utility.requiredFieldValid(mUsernameView)
                    && Utility.requiredFieldValid(mPasswordView)
                    && Utility.domainFieldValid(mServerView)
                    && Utility.requiredFieldValid(mPortView));
        Utility.setCompoundDrawablesAlpha(mNextButton, mNextButton.isEnabled() ? 255 : 128);
    }

    private void updatePortFromSecurityType()
    {
        if (mAccountPorts != null)
        {
            int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
            mPortView.setText(Integer.toString(mAccountPorts[securityType]));
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        if (resultCode == RESULT_OK)
        {
            switch (requestCode)
            {
                case SELECT_DRAFT_FOLDER:
                    mImapFolderDrafts.setText(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER));
                    return;
                case SELECT_SENT_FOLDER:
                    mImapFolderSent.setText(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER));
                    return;
                case SELECT_TRASH_FOLDER:
                    mImapFolderTrash.setText(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER));
                    return;
                case SELECT_ARCHIVE_FOLDER:
                    mImapFolderArchive.setText(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER));
                    return;
                case SELECT_SPAM_FOLDER:
                    mImapFolderSpam.setText(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER));
                    return;
            }
            if (Intent.ACTION_EDIT.equals(getIntent().getAction()))
            {
                mAccount.save(Preferences.getPreferences(this));
                finish();
            }
            else
            {
                /*
                 * Set the username and password for the outgoing settings to the username and
                 * password the user just set for incoming.
                 */
                try
                {
                    String usernameEnc = URLEncoder.encode(mUsernameView.getText().toString(), ""UTF-8"");
                    String passwordEnc = URLEncoder.encode(mPasswordView.getText().toString(), ""UTF-8"");
                    URI oldUri = new URI(mAccount.getTransportUri());
                    URI uri = new URI(
                        oldUri.getScheme(),
                        usernameEnc + "":"" + passwordEnc,
                        oldUri.getHost(),
                        oldUri.getPort(),
                        null,
                        null,
                        null);
                    mAccount.setTransportUri(uri.toString());
                }
                catch (UnsupportedEncodingException enc)
                {
                    // This really shouldn't happen since the encoding is hardcoded to UTF-8
                    Log.e(K9.LOG_TAG, ""Couldn't urlencode username or password."", enc);
                }
                catch (URISyntaxException use)
                {
                    /*
                     * If we can't set up the URL we just continue. It's only for
                     * convenience.
                     */
                }


                AccountSetupOutgoing.actionOutgoingSettings(this, mAccount, mMakeDefault);
                finish();
            }
        }
    }

    private void onNext()
    {
        try
        {
            int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
            String path = null;
            if (mAccountSchemes[securityType].startsWith(""imap""))
            {
                path = ""/"" + mImapPathPrefixView.getText();
            }
            else if (mAccountSchemes[securityType].startsWith(""webdav""))
            {
                path = ""/"" + mWebdavPathPrefixView.getText();
                path = path + ""|"" + mWebdavAuthPathView.getText();
                path = path + ""|"" + mWebdavMailboxPathView.getText();
            }

            final String userInfo;
            String user = mUsernameView.getText().toString();
            String password = mPasswordView.getText().toString();
            String userEnc = URLEncoder.encode(user, ""UTF-8"");
            String passwordEnc = URLEncoder.encode(password, ""UTF-8"");

            if (mAccountSchemes[securityType].startsWith(""imap""))
            {
                String authType = ((SpinnerOption)mAuthTypeView.getSelectedItem()).label;
                userInfo = authType + "":"" + userEnc + "":"" + passwordEnc;
            }
            else
            {
                userInfo = userEnc + "":"" + passwordEnc;
            }
            URI uri = new URI(
                mAccountSchemes[securityType],
                userInfo,
                mServerView.getText().toString(),
                Integer.parseInt(mPortView.getText().toString()),
                path, // path
                null, // query
                null);
            mAccount.setStoreUri(uri.toString());


            mAccount.setDraftsFolderName(mImapFolderDrafts.getText().toString());
            mAccount.setSentFolderName(mImapFolderSent.getText().toString());
            mAccount.setTrashFolderName(mImapFolderTrash.getText().toString());
            mAccount.setArchiveFolderName(mImapFolderArchive.getText().toString());
            mAccount.setSpamFolderName(mImapFolderSpam.getText().toString());
            mAccount.setOutboxFolderName(mImapFolderOutbox.getText().toString());
            mAccount.setCompression(Account.TYPE_MOBILE, compressionMobile.isChecked());
            mAccount.setCompression(Account.TYPE_WIFI, compressionWifi.isChecked());
            mAccount.setCompression(Account.TYPE_OTHER, compressionOther.isChecked());
            mAccount.setSaveAllHeaders(saveAllHeaders.isChecked());
            mAccount.setPushPollOnConnect(pushPollOnConnect.isChecked());
            mAccount.setSubscribedFoldersOnly(subscribedFoldersOnly.isChecked());
            String idleRefreshPeriodValue = SpinnerHelper.getSpinnerValue(idleRefreshPeriod);
            try
            {
                mAccount.setIdleRefreshMinutes(Integer.parseInt(idleRefreshPeriodValue));
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to parse idle refresh period value '"" + idleRefreshPeriodValue + ""'"", e);
                mAccount.setIdleRefreshMinutes(24);
            }
            String maxPushFoldersValue = SpinnerHelper.getSpinnerValue(folderPushLimit);
            try
            {
                mAccount.setMaxPushFolders(Integer.parseInt(maxPushFoldersValue));
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to parse max push folders value '"" + maxPushFoldersValue + ""'"", e);
                mAccount.setMaxPushFolders(10);
            }

            AccountSetupCheckSettings.actionCheckSettings(this, mAccount, true, false);
        }
        catch (Exception e)
        {
            failure(e);
        }

    }

    public void onClick(View v)
    {
        try
        {
            switch (v.getId())
            {
                case R.id.next:
                    onNext();
                    break;
                case R.id.account_imap_folder_drafts:
                    selectImapFolder(SELECT_DRAFT_FOLDER);
                    break;
                case R.id.account_imap_folder_sent:
                    selectImapFolder(SELECT_SENT_FOLDER);
                    break;
                case R.id.account_imap_folder_trash:
                    selectImapFolder(SELECT_TRASH_FOLDER);
                    break;
                case R.id.account_imap_folder_archive:
                    selectImapFolder(SELECT_ARCHIVE_FOLDER);
                    break;
                case R.id.account_imap_folder_spam:
                    selectImapFolder(SELECT_SPAM_FOLDER);
                    break;
            }
        }
        catch (Exception e)
        {
            failure(e);
        }
    }

    private void selectImapFolder(int activityCode)
    {
        String curFolder = null;
        boolean showFolderNone = false;
        switch (activityCode)
        {
            case SELECT_DRAFT_FOLDER:
                curFolder = mImapFolderDrafts.getText().toString();
                break;
            case SELECT_SENT_FOLDER:
                curFolder = mImapFolderSent.getText().toString();
                showFolderNone = true;
                break;
            case SELECT_TRASH_FOLDER:
                curFolder = mImapFolderTrash.getText().toString();
                showFolderNone = true;
                break;
            case SELECT_ARCHIVE_FOLDER:
                curFolder = mImapFolderArchive.getText().toString();
                showFolderNone = true;
                break;
            case SELECT_SPAM_FOLDER:
                curFolder = mImapFolderSpam.getText().toString();
                showFolderNone = true;
                break;
            default:
                throw new IllegalArgumentException(
                    ""Cannot select folder for: "" + activityCode);
        }

        Intent selectIntent = new Intent(this, ChooseFolder.class);
        String uri = mAccount.getStoreUri();
        if (showFolderNone && uri.startsWith(""imap""))
        {
            selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_FOLDER_NONE, ""yes"");
        }
        selectIntent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount.getUuid());
        selectIntent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, curFolder);
        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_CURRENT, ""yes"");
        startActivityForResult(selectIntent, activityCode);
    }

    private void failure(Exception use)
    {
        Log.e(K9.LOG_TAG, ""Failure"", use);
        String toastText = getString(R.string.account_setup_bad_uri, use.getMessage());

        Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
        toast.show();
    }
}
",True,216,0,0,8,52,2,10,L1
65,com.fsck.k9.activity.setup.AccountSetupOutgoing.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.text.method.DigitsKeyListener;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.*;
import android.widget.CompoundButton.OnCheckedChangeListener;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9Activity;
import com.fsck.k9.helper.Utility;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public class AccountSetupOutgoing extends K9Activity implements OnClickListener,
        OnCheckedChangeListener
{
    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_MAKE_DEFAULT = ""makeDefault"";

    private static final int smtpPorts[] =
    {
        25, 465, 465, 25, 25
    };

    private static final String smtpSchemes[] =
    {
        ""smtp"", ""smtp+ssl"", ""smtp+ssl+"", ""smtp+tls"", ""smtp+tls+""
    };
    /*
    private static final int webdavPorts[] =
    {
        80, 443, 443, 443, 443
    };
    private static final String webdavSchemes[] =
    {
        ""webdav"", ""webdav+ssl"", ""webdav+ssl+"", ""webdav+tls"", ""webdav+tls+""
    };
    */

    private static final String authTypes[] =
    {
        ""PLAIN"", ""CRAM_MD5""
    };
    private EditText mUsernameView;
    private EditText mPasswordView;
    private EditText mServerView;
    private EditText mPortView;
    private CheckBox mRequireLoginView;
    private ViewGroup mRequireLoginSettingsView;
    private Spinner mSecurityTypeView;
    private Spinner mAuthTypeView;
    private Button mNextButton;
    private Account mAccount;
    private boolean mMakeDefault;

    public static void actionOutgoingSettings(Context context, Account account, boolean makeDefault)
    {
        Intent i = new Intent(context, AccountSetupOutgoing.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
        context.startActivity(i);
    }

    public static void actionEditOutgoingSettings(Context context, Account account)
    {
        Intent i = new Intent(context, AccountSetupOutgoing.class);
        i.setAction(Intent.ACTION_EDIT);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_outgoing);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        try
        {
            if (new URI(mAccount.getStoreUri()).getScheme().startsWith(""webdav""))
            {
                mAccount.setTransportUri(mAccount.getStoreUri());
                AccountSetupCheckSettings.actionCheckSettings(this, mAccount, false, true);
            }
        }
        catch (URISyntaxException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }


        mUsernameView = (EditText)findViewById(R.id.account_username);
        mPasswordView = (EditText)findViewById(R.id.account_password);
        mServerView = (EditText)findViewById(R.id.account_server);
        mPortView = (EditText)findViewById(R.id.account_port);
        mRequireLoginView = (CheckBox)findViewById(R.id.account_require_login);
        mRequireLoginSettingsView = (ViewGroup)findViewById(R.id.account_require_login_settings);
        mSecurityTypeView = (Spinner)findViewById(R.id.account_security_type);
        mAuthTypeView = (Spinner)findViewById(R.id.account_auth_type);
        mNextButton = (Button)findViewById(R.id.next);

        mNextButton.setOnClickListener(this);
        mRequireLoginView.setOnCheckedChangeListener(this);

        SpinnerOption securityTypes[] =
        {
            new SpinnerOption(0, getString(R.string.account_setup_incoming_security_none_label)),
            new SpinnerOption(1,
            getString(R.string.account_setup_incoming_security_ssl_optional_label)),
            new SpinnerOption(2, getString(R.string.account_setup_incoming_security_ssl_label)),
            new SpinnerOption(3,
            getString(R.string.account_setup_incoming_security_tls_optional_label)),
            new SpinnerOption(4, getString(R.string.account_setup_incoming_security_tls_label)),
        };

        // This needs to be kept in sync with the list at the top of the file.
        // that makes me somewhat unhappy
        SpinnerOption authTypeSpinnerOptions[] =
        {
            new SpinnerOption(0, ""PLAIN""),
            new SpinnerOption(1, ""CRAM_MD5"")
        };



        ArrayAdapter<SpinnerOption> securityTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, securityTypes);
        securityTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mSecurityTypeView.setAdapter(securityTypesAdapter);

        ArrayAdapter<SpinnerOption> authTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, authTypeSpinnerOptions);
        authTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mAuthTypeView.setAdapter(authTypesAdapter);

        /*
         * Updates the port when the user changes the security type. This allows
         * us to show a reasonable default which the user can change.
         */
        mSecurityTypeView.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener()
        {
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id)
            {
                updatePortFromSecurityType();
            }

            public void onNothingSelected(AdapterView<?> parent)
            {
            }
        });

        /*
         * Calls validateFields() which enables or disables the Next button
         * based on the fields' validity.
         */
        TextWatcher validationTextWatcher = new TextWatcher()
        {
            public void afterTextChanged(Editable s)
            {
                validateFields();
            }

            public void beforeTextChanged(CharSequence s, int start, int count, int after)
            {
            }

            public void onTextChanged(CharSequence s, int start, int before, int count)
            {
            }
        };
        mUsernameView.addTextChangedListener(validationTextWatcher);
        mPasswordView.addTextChangedListener(validationTextWatcher);
        mServerView.addTextChangedListener(validationTextWatcher);
        mPortView.addTextChangedListener(validationTextWatcher);

        /*
         * Only allow digits in the port field.
         */
        mPortView.setKeyListener(DigitsKeyListener.getInstance(""0123456789""));

        //FIXME: get Account object again?
        accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mMakeDefault = (boolean)getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false);

        /*
         * If we're being reloaded we override the original account with the one
         * we saved
         */
        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT))
        {
            accountUuid = savedInstanceState.getString(EXTRA_ACCOUNT);
            mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        }

        try
        {
            URI uri = new URI(mAccount.getTransportUri());
            String username = null;
            String password = null;
            String authType = null;
            if (uri.getUserInfo() != null)
            {
                String[] userInfoParts = uri.getUserInfo().split("":"");

                username = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                if (userInfoParts.length > 1)
                {
                    password = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
                if (userInfoParts.length > 2)
                {
                    authType = userInfoParts[2];
                }
            }

            if (username != null)
            {
                mUsernameView.setText(username);
                mRequireLoginView.setChecked(true);
            }

            if (password != null)
            {
                mPasswordView.setText(password);
            }

            if (authType != null)
            {
                for (int i = 0; i < authTypes.length; i++)
                {
                    if (authTypes[i].equals(authType))
                    {
                        SpinnerOption.setSpinnerOptionValue(mAuthTypeView, i);
                    }
                }
            }


            for (int i = 0; i < smtpSchemes.length; i++)
            {
                if (smtpSchemes[i].equals(uri.getScheme()))
                {
                    SpinnerOption.setSpinnerOptionValue(mSecurityTypeView, i);
                }
            }

            if (uri.getHost() != null)
            {
                mServerView.setText(uri.getHost());
            }

            if (uri.getPort() != -1)
            {
                mPortView.setText(Integer.toString(uri.getPort()));
            }
            else
            {
                updatePortFromSecurityType();
            }

            validateFields();
        }
        catch (Exception e)
        {
            /*
             * We should always be able to parse our own settings.
             */
            failure(e);
        }

    }

    @Override
    public void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        outState.putString(EXTRA_ACCOUNT, mAccount.getUuid());
    }

    private void validateFields()
    {
        mNextButton
        .setEnabled(
            Utility.domainFieldValid(mServerView) &&
            Utility.requiredFieldValid(mPortView) &&
            (!mRequireLoginView.isChecked() ||
             (Utility.requiredFieldValid(mUsernameView) &&
              Utility.requiredFieldValid(mPasswordView))));
        Utility.setCompoundDrawablesAlpha(mNextButton, mNextButton.isEnabled() ? 255 : 128);
    }

    private void updatePortFromSecurityType()
    {
        int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
        mPortView.setText(Integer.toString(smtpPorts[securityType]));
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        if (resultCode == RESULT_OK)
        {
            if (Intent.ACTION_EDIT.equals(getIntent().getAction()))
            {
                mAccount.save(Preferences.getPreferences(this));
                finish();
            }
            else
            {
                AccountSetupOptions.actionOptions(this, mAccount, mMakeDefault);
                finish();
            }
        }
    }

    private void onNext()
    {
        int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
        URI uri;
        try
        {
            String usernameEnc = URLEncoder.encode(mUsernameView.getText().toString(), ""UTF-8"");
            String passwordEnc = URLEncoder.encode(mPasswordView.getText().toString(), ""UTF-8"");

            String userInfo = null;
            String authType = ((SpinnerOption)mAuthTypeView.getSelectedItem()).label;
            if (mRequireLoginView.isChecked())
            {
                userInfo = usernameEnc + "":"" + passwordEnc + "":"" + authType;
            }
            uri = new URI(smtpSchemes[securityType], userInfo, mServerView.getText().toString(),
                          Integer.parseInt(mPortView.getText().toString()), null, null, null);
            mAccount.setTransportUri(uri.toString());
            AccountSetupCheckSettings.actionCheckSettings(this, mAccount, false, true);
        }
        catch (UnsupportedEncodingException enc)
        {
            // This really shouldn't happen since the encoding is hardcoded to UTF-8
            Log.e(K9.LOG_TAG, ""Couldn't urlencode username or password."", enc);
        }
        catch (Exception e)
        {
            /*
             * It's unrecoverable if we cannot create a URI from components that
             * we validated to be safe.
             */
            failure(e);
        }

    }

    public void onClick(View v)
    {
        switch (v.getId())
        {
            case R.id.next:
                onNext();
                break;
        }
    }

    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
    {
        mRequireLoginSettingsView.setVisibility(isChecked ? View.VISIBLE : View.GONE);
        validateFields();
    }
    private void failure(Exception use)
    {
        Log.e(K9.LOG_TAG, ""Failure"", use);
        String toastText = getString(R.string.account_setup_bad_uri, use.getMessage());

        Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
        toast.show();
    }
}
",True,216,0,0,8,52,2,8,L1
66,com.fsck.k9.activity.setup.SpinnerHelper.java,"package com.fsck.k9.activity.setup;
/*
 * SpinnerHelper donated to K-9 Mail by Boutique Software
 */

import android.content.Context;
import android.widget.ArrayAdapter;
import android.widget.Spinner;

public class SpinnerHelper
{
    public static void initSpinner(Context context, Spinner spinner, int entryRes, int valueRes, String curVal)
    {
        String[] entryArray = context.getResources().getStringArray(entryRes);
        String[] valueArray = context.getResources().getStringArray(valueRes);
        initSpinner(context, spinner, entryArray, valueArray, curVal);
    }
    public static void initSpinner(Context context, Spinner spinner, String[] entryArray, String[] valueArray, String curVal)
    {

        if (entryArray.length != valueArray.length)
        {
            throw new RuntimeException(""Entry and value arrays are of unequal lenght"");
        }

        EntryValue[] entryValues = new EntryValue[entryArray.length];
        int curSelection = 0;
        for (int i = 0; i < entryArray.length; i++)
        {
            entryValues[i] = new EntryValue(entryArray[i], valueArray[i]);
            if (valueArray[i].equals(curVal))
            {
                curSelection = i;
            }
        }

        ArrayAdapter<EntryValue> entryValuesAdapter = new ArrayAdapter<EntryValue>(context, android.R.layout.simple_spinner_item, entryValues);
        entryValuesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        spinner.setAdapter(entryValuesAdapter);
        spinner.setSelection(curSelection);
    }

    public static String getSpinnerValue(Spinner spinner)
    {
        EntryValue entryValue = (EntryValue)spinner.getSelectedItem();
        if (entryValue != null)
        {
            return entryValue.getValue();
        }
        else
        {
            return null;
        }
    }
    public static String getSpinnerEntry(Spinner spinner)
    {
        EntryValue entryValue = (EntryValue)spinner.getSelectedItem();
        if (entryValue != null)
        {
            return entryValue.getEntry();
        }
        else
        {
            return null;
        }
    }
    private static class EntryValue
    {
        final String entry;
        final String value;
        EntryValue(String entry, String value)
        {
            this.entry = entry;
            this.value = value;
        }
        @Override
        public String toString()
        {
            return entry;
        }
        public String getEntry()
        {
            return entry;
        }
        public String getValue()
        {
            return value;
        }
    }
}
",False,92,9,41,0,0,1,0,L1
67,com.fsck.k9.activity.setup.AccountSetupCheckSettings.java,"
package com.fsck.k9.activity.setup;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.os.Process;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.TextView;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9Activity;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.mail.AuthenticationFailedException;
import com.fsck.k9.mail.CertificateValidationException;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.Transport;
import com.fsck.k9.mail.store.TrustManagerFactory;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

/**
 * Checks the given settings to make sure that they can be used to send and
 * receive mail.
 *
 * XXX NOTE: The manifest for this app has it ignore config changes, because
 * it doesn't correctly deal with restarting while its thread is running.
 */
public class AccountSetupCheckSettings extends K9Activity implements OnClickListener
{

    public static final int ACTIVITY_REQUEST_CODE = 1;

    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_CHECK_INCOMING = ""checkIncoming"";

    private static final String EXTRA_CHECK_OUTGOING = ""checkOutgoing"";

    private Handler mHandler = new Handler();

    private ProgressBar mProgressBar;

    private TextView mMessageView;

    private Account mAccount;

    private boolean mCheckIncoming;

    private boolean mCheckOutgoing;

    private boolean mCanceled;

    private boolean mDestroyed;

    public static void actionCheckSettings(Activity context, Account account,
                                           boolean checkIncoming, boolean checkOutgoing)
    {
        Intent i = new Intent(context, AccountSetupCheckSettings.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_CHECK_INCOMING, checkIncoming);
        i.putExtra(EXTRA_CHECK_OUTGOING, checkOutgoing);
        context.startActivityForResult(i, ACTIVITY_REQUEST_CODE);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_check_settings);
        mMessageView = (TextView)findViewById(R.id.message);
        mProgressBar = (ProgressBar)findViewById(R.id.progress);
        ((Button)findViewById(R.id.cancel)).setOnClickListener(this);

        setMessage(R.string.account_setup_check_settings_retr_info_msg);
        mProgressBar.setIndeterminate(true);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mCheckIncoming = (boolean)getIntent().getBooleanExtra(EXTRA_CHECK_INCOMING, false);
        mCheckOutgoing = (boolean)getIntent().getBooleanExtra(EXTRA_CHECK_OUTGOING, false);

        new Thread()
        {
            @Override
            public void run()
            {
                Store store = null;
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                try
                {
                    if (mDestroyed)
                    {
                        return;
                    }
                    if (mCanceled)
                    {
                        finish();
                        return;
                    }
                    if (mCheckIncoming)
                    {
                        setMessage(R.string.account_setup_check_settings_check_incoming_msg);
                        store = mAccount.getRemoteStore();
                        store.checkSettings();

                        MessagingController.getInstance(getApplication()).listFolders(mAccount, true, null);
                        MessagingController.getInstance(getApplication()).synchronizeMailbox(mAccount, K9.INBOX , null, null);

                    }
                    if (mDestroyed)
                    {
                        return;
                    }
                    if (mCanceled)
                    {
                        finish();
                        return;
                    }
                    if (mCheckOutgoing)
                    {
                        setMessage(R.string.account_setup_check_settings_check_outgoing_msg);
                        Transport transport = Transport.getInstance(mAccount);
                        transport.close();
                        transport.open();
                        transport.close();
                    }
                    if (mDestroyed)
                    {
                        return;
                    }
                    if (mCanceled)
                    {
                        finish();
                        return;
                    }
                    setResult(RESULT_OK);
                    finish();
                }
                catch (final AuthenticationFailedException afe)
                {
                    Log.e(K9.LOG_TAG, ""Error while testing settings"", afe);
                    showErrorDialog(
                        R.string.account_setup_failed_dlg_auth_message_fmt,
                        afe.getMessage() == null ? """" : afe.getMessage());
                }
                catch (final CertificateValidationException cve)
                {
                    Log.e(K9.LOG_TAG, ""Error while testing settings"", cve);
                    acceptKeyDialog(
                        R.string.account_setup_failed_dlg_certificate_message_fmt,
                        cve);
                }
                catch (final Throwable t)
                {
                    Log.e(K9.LOG_TAG, ""Error while testing settings"", t);
                    showErrorDialog(
                        R.string.account_setup_failed_dlg_server_message_fmt,
                        (t.getMessage() == null ? """" : t.getMessage()));

                }
            }

        }
        .start();
    }

    @Override
    public void onDestroy()
    {
        super.onDestroy();
        mDestroyed = true;
        mCanceled = true;
    }

    private void setMessage(final int resId)
    {
        mHandler.post(new Runnable()
        {
            public void run()
            {
                if (mDestroyed)
                {
                    return;
                }
                mMessageView.setText(getString(resId));
            }
        });
    }

    private void showErrorDialog(final int msgResId, final Object... args)
    {
        mHandler.post(new Runnable()
        {
            public void run()
            {
                if (mDestroyed)
                {
                    return;
                }
                mProgressBar.setIndeterminate(false);
                new AlertDialog.Builder(AccountSetupCheckSettings.this)
                .setTitle(getString(R.string.account_setup_failed_dlg_title))
                .setMessage(getString(msgResId, args))
                .setCancelable(true)
                .setNegativeButton(
                    getString(R.string.account_setup_failed_dlg_continue_action),

                    new DialogInterface.OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        mCanceled=false;
                        setResult(RESULT_OK);
                        finish();
                    }
                })
                .setPositiveButton(
                    getString(R.string.account_setup_failed_dlg_edit_details_action),
                    new DialogInterface.OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        finish();
                    }
                })
                .show();
            }
        });
    }
    private void acceptKeyDialog(final int msgResId, final Object... args)
    {
        mHandler.post(new Runnable()
        {
            public void run()
            {
                if (mDestroyed)
                {
                    return;
                }
                final X509Certificate[] chain = TrustManagerFactory.getLastCertChain();
                String exMessage = ""Unknown Error"";

                Exception ex = ((Exception)args[0]);
                if (ex != null)
                {
                    if (ex.getCause() != null)
                    {
                        if (ex.getCause().getCause() != null)
                        {
                            exMessage = ex.getCause().getCause().getMessage();

                        }
                        else
                        {
                            exMessage = ex.getCause().getMessage();
                        }
                    }
                    else
                    {
                        exMessage = ex.getMessage();
                    }
                }

                mProgressBar.setIndeterminate(false);
                StringBuffer chainInfo = new StringBuffer(100);
                for (int i = 0; i < chain.length; i++)
                {
                    // display certificate chain information
                    chainInfo.append(""Certificate chain["" + i + ""]:\n"");
                    chainInfo.append(""Subject: "" + chain[i].getSubjectDN().toString() + ""\n"");
                    chainInfo.append(""Issuer: "" + chain[i].getIssuerDN().toString() + ""\n"");
                }

                new AlertDialog.Builder(AccountSetupCheckSettings.this)
                .setTitle(getString(R.string.account_setup_failed_dlg_invalid_certificate_title))
                //.setMessage(getString(R.string.account_setup_failed_dlg_invalid_certificate)
                .setMessage(getString(msgResId,exMessage)
                            + "" "" + chainInfo.toString()
                           )
                .setCancelable(true)
                .setPositiveButton(
                    getString(R.string.account_setup_failed_dlg_invalid_certificate_accept),
                    new DialogInterface.OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        try
                        {
                            String alias = mAccount.getUuid();
                            if (mCheckIncoming)
                            {
                                alias = alias + "".incoming"";
                            }
                            if (mCheckOutgoing)
                            {
                                alias = alias + "".outgoing"";
                            }
                            TrustManagerFactory.addCertificateChain(alias, chain);
                        }
                        catch (CertificateException e)
                        {
                            showErrorDialog(
                                R.string.account_setup_failed_dlg_certificate_message_fmt,
                                e.getMessage() == null ? """" : e.getMessage());
                        }
                        AccountSetupCheckSettings.actionCheckSettings(AccountSetupCheckSettings.this, mAccount,
                                mCheckIncoming, mCheckOutgoing);
                    }
                })
                .setNegativeButton(
                    getString(R.string.account_setup_failed_dlg_invalid_certificate_reject),
                    new DialogInterface.OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        finish();
                    }
                })
                .show();
            }
        });
    }

    @Override
    public void onActivityResult(int reqCode, int resCode, Intent data)
    {
        setResult(resCode);
        finish();
    }


    private void onCancel()
    {
        mCanceled = true;
        setMessage(R.string.account_setup_check_settings_canceling_msg);
    }

    public void onClick(View v)
    {
        switch (v.getId())
        {
            case R.id.cancel:
                onCancel();
                break;
        }
    }
}
",True,216,0,0,7,67,3,10,L1
68,com.fsck.k9.activity.setup.AccountSetupAccountType.java,"
package com.fsck.k9.activity.setup;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.Toast;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.activity.K9Activity;
import java.net.URI;

/**
 * Prompts the user to select an account type. The account type, along with the
 * passed in email address, password and makeDefault are then passed on to the
 * AccountSetupIncoming activity.
 */
public class AccountSetupAccountType extends K9Activity implements OnClickListener
{
    private static final String EXTRA_ACCOUNT = ""account"";

    private static final String EXTRA_MAKE_DEFAULT = ""makeDefault"";

    private Account mAccount;

    private boolean mMakeDefault;

    public static void actionSelectAccountType(Context context, Account account, boolean makeDefault)
    {
        Intent i = new Intent(context, AccountSetupAccountType.class);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_account_type);
        ((Button)findViewById(R.id.pop)).setOnClickListener(this);
        ((Button)findViewById(R.id.imap)).setOnClickListener(this);
        ((Button)findViewById(R.id.webdav)).setOnClickListener(this);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        mMakeDefault = (boolean)getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false);
    }

    private void onPop()
    {
        try
        {
            URI uri = new URI(mAccount.getStoreUri());
            uri = new URI(""pop3"", uri.getUserInfo(), uri.getHost(), uri.getPort(), null, null, null);
            mAccount.setStoreUri(uri.toString());
            AccountSetupIncoming.actionIncomingSettings(this, mAccount, mMakeDefault);
            finish();
        }
        catch (Exception use)
        {
            failure(use);
        }

    }

    private void onImap()
    {
        try
        {
            URI uri = new URI(mAccount.getStoreUri());
            uri = new URI(""imap"", uri.getUserInfo(), uri.getHost(), uri.getPort(), null, null, null);
            mAccount.setStoreUri(uri.toString());
            AccountSetupIncoming.actionIncomingSettings(this, mAccount, mMakeDefault);
            finish();
        }
        catch (Exception use)
        {
            failure(use);
        }

    }

    private void onWebDav()
    {
        try
        {
            URI uri = new URI(mAccount.getStoreUri());
            uri = new URI(""webdav"", uri.getUserInfo(), uri.getHost(), uri.getPort(), null, null, null);
            mAccount.setStoreUri(uri.toString());
            AccountSetupIncoming.actionIncomingSettings(this, mAccount, mMakeDefault);
            finish();
        }
        catch (Exception use)
        {
            failure(use);
        }

    }

    public void onClick(View v)
    {
        switch (v.getId())
        {
            case R.id.pop:
                onPop();
                break;
            case R.id.imap:
                onImap();
                break;
            case R.id.webdav:
                onWebDav();
                break;
        }
    }
    private void failure(Exception use)
    {
        Log.e(K9.LOG_TAG, ""Failure"", use);
        String toastText = getString(R.string.account_setup_bad_uri, use.getMessage());

        Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
        toast.show();
    }
}
",True,216,0,0,8,57,1,5,L1
69,com.fsck.k9.activity.setup.AccountSetupComposition.java,"package com.fsck.k9.activity.setup;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.KeyEvent;
import android.view.View;
import android.widget.CompoundButton;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.RadioButton;
import com.fsck.k9.Account;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.activity.K9Activity;

public class AccountSetupComposition extends K9Activity
{

    private static final String EXTRA_ACCOUNT = ""account"";

    private Account mAccount;

    private EditText mAccountSignature;
    private EditText mAccountEmail;
    private EditText mAccountAlwaysBcc;
    private EditText mAccountName;
    private CheckBox mAccountSignatureUse;
    private RadioButton mAccountSignatureBeforeLocation;
    private RadioButton mAccountSignatureAfterLocation;
    private LinearLayout mAccountSignatureLayout;

    public static void actionEditCompositionSettings(Activity context, Account account)
    {
        Intent i = new Intent(context, AccountSetupComposition.class);
        i.setAction(Intent.ACTION_EDIT);
        i.putExtra(EXTRA_ACCOUNT, account.getUuid());
        context.startActivity(i);
    }


    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        String accountUuid = getIntent().getStringExtra(EXTRA_ACCOUNT);
        mAccount = Preferences.getPreferences(this).getAccount(accountUuid);

        setContentView(R.layout.account_setup_composition);

        /*
         * If we're being reloaded we override the original account with the one
         * we saved
         */
        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT))
        {
            accountUuid = savedInstanceState.getString(EXTRA_ACCOUNT);
            mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        }

        mAccountName = (EditText)findViewById(R.id.account_name);
        mAccountName.setText(mAccount.getName());

        mAccountEmail = (EditText)findViewById(R.id.account_email);
        mAccountEmail.setText(mAccount.getEmail());

        mAccountAlwaysBcc = (EditText)findViewById(R.id.account_always_bcc);
        mAccountAlwaysBcc.setText(mAccount.getAlwaysBcc());

        mAccountSignatureLayout = (LinearLayout)findViewById(R.id.account_signature_layout);

        mAccountSignatureUse = (CheckBox)findViewById(R.id.account_signature_use);
        boolean useSignature = mAccount.getSignatureUse();
        mAccountSignatureUse.setChecked(useSignature);
        mAccountSignatureUse.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener()
        {
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
            {
                if (isChecked)
                {
                    mAccountSignatureLayout.setVisibility(View.VISIBLE);
                    mAccountSignature.setText(mAccount.getSignature());
                    boolean isSignatureBeforeQuotedText = mAccount.isSignatureBeforeQuotedText();
                    mAccountSignatureBeforeLocation.setChecked(isSignatureBeforeQuotedText);
                    mAccountSignatureAfterLocation.setChecked(!isSignatureBeforeQuotedText);
                }
                else
                {
                    mAccountSignatureLayout.setVisibility(View.GONE);
                }
            }
        });

        mAccountSignature = (EditText)findViewById(R.id.account_signature);

        mAccountSignatureBeforeLocation = (RadioButton)findViewById(R.id.account_signature_location_before_quoted_text);
        mAccountSignatureAfterLocation = (RadioButton)findViewById(R.id.account_signature_location_after_quoted_text);

        if (useSignature)
        {
            mAccountSignature.setText(mAccount.getSignature());

            boolean isSignatureBeforeQuotedText = mAccount.isSignatureBeforeQuotedText();
            mAccountSignatureBeforeLocation.setChecked(isSignatureBeforeQuotedText);
            mAccountSignatureAfterLocation.setChecked(!isSignatureBeforeQuotedText);
        }
        else
        {
            mAccountSignatureLayout.setVisibility(View.GONE);
        }
    }

    @Override
    public void onResume()
    {
        super.onResume();
        //mAccount.refresh(Preferences.getPreferences(this));
    }

    private void saveSettings()
    {
        mAccount.setEmail(mAccountEmail.getText().toString());
        mAccount.setAlwaysBcc(mAccountAlwaysBcc.getText().toString());
        mAccount.setName(mAccountName.getText().toString());
        mAccount.setSignatureUse(mAccountSignatureUse.isChecked());
        if (mAccountSignatureUse.isChecked())
        {
            mAccount.setSignature(mAccountSignature.getText().toString());
            boolean isSignatureBeforeQuotedText = mAccountSignatureBeforeLocation.isChecked();
            mAccount.setSignatureBeforeQuotedText(isSignatureBeforeQuotedText);
        }

        mAccount.save(Preferences.getPreferences(this));
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        if (keyCode == KeyEvent.KEYCODE_BACK)
        {
            saveSettings();
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        outState.putSerializable(EXTRA_ACCOUNT, mAccount.getUuid());
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        mAccount.save(Preferences.getPreferences(this));
        finish();
    }
}
",False,216,0,0,8,53,1,3,L1
70,com.fsck.k9.activity.setup.AccountSetupBasics.java,"
package com.fsck.k9.activity.setup;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.XmlResourceParser;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import com.fsck.k9.*;
import com.fsck.k9.activity.K9Activity;
import com.fsck.k9.helper.Contacts;
import com.fsck.k9.helper.Utility;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLEncoder;

/**
 * Prompts the user for the email address and password. Also prompts for
 * ""Use this account as default"" if this is the 2nd+ account being set up.
 * Attempts to lookup default settings for the domain the user specified. If the
 * domain is known the settings are handed off to the AccountSetupCheckSettings
 * activity. If no settings are found the settings are handed off to the
 * AccountSetupAccountType activity.
 */
public class AccountSetupBasics extends K9Activity
        implements OnClickListener, TextWatcher
{
    private final static String EXTRA_ACCOUNT = ""com.fsck.k9.AccountSetupBasics.account"";
    private final static int DIALOG_NOTE = 1;
    private final static String STATE_KEY_PROVIDER =
        ""com.fsck.k9.AccountSetupBasics.provider"";

    private Preferences mPrefs;
    private EditText mEmailView;
    private EditText mPasswordView;
    private CheckBox mDefaultView;
    private Button mNextButton;
    private Button mManualSetupButton;
    private Account mAccount;
    private Provider mProvider;

    private EmailAddressValidator mEmailValidator = new EmailAddressValidator();

    public static void actionNewAccount(Context context)
    {
        Intent i = new Intent(context, AccountSetupBasics.class);
        context.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.account_setup_basics);
        mPrefs = Preferences.getPreferences(this);
        mEmailView = (EditText)findViewById(R.id.account_email);
        mPasswordView = (EditText)findViewById(R.id.account_password);
        mDefaultView = (CheckBox)findViewById(R.id.account_default);
        mNextButton = (Button)findViewById(R.id.next);
        mManualSetupButton = (Button)findViewById(R.id.manual_setup);

        mNextButton.setOnClickListener(this);
        mManualSetupButton.setOnClickListener(this);

        mEmailView.addTextChangedListener(this);
        mPasswordView.addTextChangedListener(this);

        if (mPrefs.getAccounts().length > 0)
        {
            mDefaultView.setVisibility(View.VISIBLE);
        }

        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT))
        {
            String accountUuid = savedInstanceState.getString(EXTRA_ACCOUNT);
            mAccount = Preferences.getPreferences(this).getAccount(accountUuid);
        }

        if (savedInstanceState != null && savedInstanceState.containsKey(STATE_KEY_PROVIDER))
        {
            mProvider = (Provider)savedInstanceState.getSerializable(STATE_KEY_PROVIDER);
        }
    }

    @Override
    public void onResume()
    {
        super.onResume();
        validateFields();
    }

    @Override
    public void onSaveInstanceState(Bundle outState)
    {
        super.onSaveInstanceState(outState);
        if (mAccount != null)
        {
            outState.putString(EXTRA_ACCOUNT, mAccount.getUuid());
        }
        if (mProvider != null)
        {
            outState.putSerializable(STATE_KEY_PROVIDER, mProvider);
        }
    }

    public void afterTextChanged(Editable s)
    {
        validateFields();
    }

    public void beforeTextChanged(CharSequence s, int start, int count, int after)
    {
    }

    public void onTextChanged(CharSequence s, int start, int before, int count)
    {
    }

    private void validateFields()
    {
        String email = mEmailView.getText().toString();
        boolean valid = Utility.requiredFieldValid(mEmailView)
                        && Utility.requiredFieldValid(mPasswordView)
                        && mEmailValidator.isValidAddressOnly(email);

        mNextButton.setEnabled(valid);
        mManualSetupButton.setEnabled(valid);
        /*
         * Dim the next button's icon to 50% if the button is disabled.
         * TODO this can probably be done with a stateful drawable. Check into it.
         * android:state_enabled
         */
        Utility.setCompoundDrawablesAlpha(mNextButton, mNextButton.isEnabled() ? 255 : 128);
    }

    private String getOwnerName()
    {
        String name = null;
        try
        {
            name = Contacts.getInstance(this).getOwnerName();
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Could not get owner name, using default account name"", e);
        }
        if (name == null || name.length() == 0)
        {
            try
            {
                name = getDefaultAccountName();
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Could not get default account name"", e);
            }
        }
        if (name == null)
        {
            name = """";
        }
        return name;
    }

    private String getDefaultAccountName()
    {
        String name = null;
        Account account = Preferences.getPreferences(this).getDefaultAccount();
        if (account != null)
        {
            name = account.getName();
        }
        return name;
    }

    @Override
    public Dialog onCreateDialog(int id)
    {
        if (id == DIALOG_NOTE)
        {
            if (mProvider != null && mProvider.note != null)
            {
                return new AlertDialog.Builder(this)
                       .setMessage(mProvider.note)
                       .setPositiveButton(
                           getString(R.string.okay_action),
                           new DialogInterface.OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        finishAutoSetup();
                    }
                })
                       .setNegativeButton(
                           getString(R.string.cancel_action),
                           null)
                       .create();
            }
        }
        return null;
    }

    private void finishAutoSetup()
    {
        String email = mEmailView.getText().toString();
        String password = mPasswordView.getText().toString();
        String[] emailParts = splitEmail(email);
        String user = emailParts[0];
        String domain = emailParts[1];
        URI incomingUri = null;
        URI outgoingUri = null;
        try
        {
            String userEnc = URLEncoder.encode(user, ""UTF-8"");
            String passwordEnc = URLEncoder.encode(password, ""UTF-8"");

            String incomingUsername = mProvider.incomingUsernameTemplate;
            incomingUsername = incomingUsername.replaceAll(""\\$email"", email);
            incomingUsername = incomingUsername.replaceAll(""\\$user"", userEnc);
            incomingUsername = incomingUsername.replaceAll(""\\$domain"", domain);

            URI incomingUriTemplate = mProvider.incomingUriTemplate;
            incomingUri = new URI(incomingUriTemplate.getScheme(), incomingUsername + "":""
                                  + passwordEnc, incomingUriTemplate.getHost(), incomingUriTemplate.getPort(), null,
                                  null, null);

            String outgoingUsername = mProvider.outgoingUsernameTemplate;
            outgoingUsername = outgoingUsername.replaceAll(""\\$email"", email);
            outgoingUsername = outgoingUsername.replaceAll(""\\$user"", userEnc);
            outgoingUsername = outgoingUsername.replaceAll(""\\$domain"", domain);

            URI outgoingUriTemplate = mProvider.outgoingUriTemplate;
            outgoingUri = new URI(outgoingUriTemplate.getScheme(), outgoingUsername + "":""
                                  + passwordEnc, outgoingUriTemplate.getHost(), outgoingUriTemplate.getPort(), null,
                                  null, null);

            mAccount = Preferences.getPreferences(this).newAccount();
            mAccount.setName(getOwnerName());
            mAccount.setEmail(email);
            mAccount.setStoreUri(incomingUri.toString());
            mAccount.setTransportUri(outgoingUri.toString());
            mAccount.setDraftsFolderName(getString(R.string.special_mailbox_name_drafts));
            mAccount.setTrashFolderName(getString(R.string.special_mailbox_name_trash));
            mAccount.setArchiveFolderName(getString(R.string.special_mailbox_name_archive));
            mAccount.setSpamFolderName(getString(R.string.special_mailbox_name_spam));
            mAccount.setOutboxFolderName(getString(R.string.special_mailbox_name_outbox));
            mAccount.setSentFolderName(getString(R.string.special_mailbox_name_sent));
            AccountSetupCheckSettings.actionCheckSettings(this, mAccount, true, true);
        }
        catch (UnsupportedEncodingException enc)
        {
            // This really shouldn't happen since the encoding is hardcoded to UTF-8
            Log.e(K9.LOG_TAG, ""Couldn't urlencode username or password."", enc);
        }
        catch (URISyntaxException use)
        {
            /*
             * If there is some problem with the URI we give up and go on to
             * manual setup.
             */
            onManualSetup();
        }
    }

    private void onNext()
    {
        String email = mEmailView.getText().toString();
        String[] emailParts = splitEmail(email);
        String domain = emailParts[1];
        mProvider = findProviderForDomain(domain);
        if (mProvider == null)
        {
            /*
             * We don't have default settings for this account, start the manual
             * setup process.
             */
            onManualSetup();
            return;
        }

        if (mProvider.note != null)
        {
            showDialog(DIALOG_NOTE);
        }
        else
        {
            finishAutoSetup();
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        if (resultCode == RESULT_OK)
        {
            mAccount.setDescription(mAccount.getEmail());
            mAccount.save(Preferences.getPreferences(this));
            if (mDefaultView.isChecked())
            {
                Preferences.getPreferences(this).setDefaultAccount(mAccount);
            }
            K9.setServicesEnabled(this);
            AccountSetupNames.actionSetNames(this, mAccount);
            finish();
        }
    }

    private void onManualSetup()
    {
        String email = mEmailView.getText().toString();
        String password = mPasswordView.getText().toString();
        String[] emailParts = splitEmail(email);
        String user = emailParts[0];
        String domain = emailParts[1];

        mAccount = Preferences.getPreferences(this).newAccount();
        mAccount.setName(getOwnerName());
        mAccount.setEmail(email);
        try
        {
            String userEnc = URLEncoder.encode(user, ""UTF-8"");
            String passwordEnc = URLEncoder.encode(password, ""UTF-8"");

            URI uri = new URI(""placeholder"", userEnc + "":"" + passwordEnc, ""mail."" + domain, -1, null,
                              null, null);
            mAccount.setStoreUri(uri.toString());
            mAccount.setTransportUri(uri.toString());
        }
        catch (UnsupportedEncodingException enc)
        {
            // This really shouldn't happen since the encoding is hardcoded to UTF-8
            Log.e(K9.LOG_TAG, ""Couldn't urlencode username or password."", enc);
        }
        catch (URISyntaxException use)
        {
            /*
             * If we can't set up the URL we just continue. It's only for
             * convenience.
             */
        }
        mAccount.setDraftsFolderName(getString(R.string.special_mailbox_name_drafts));
        mAccount.setTrashFolderName(getString(R.string.special_mailbox_name_trash));
        mAccount.setOutboxFolderName(getString(R.string.special_mailbox_name_outbox));
        mAccount.setSentFolderName(getString(R.string.special_mailbox_name_sent));

        AccountSetupAccountType.actionSelectAccountType(this, mAccount, mDefaultView.isChecked());
        finish();
    }

    public void onClick(View v)
    {
        switch (v.getId())
        {
            case R.id.next:
                onNext();
                break;
            case R.id.manual_setup:
                onManualSetup();
                break;
        }
    }

    /**
     * Attempts to get the given attribute as a String resource first, and if it fails
     * returns the attribute as a simple String value.
     * @param xml
     * @param name
     * @return
     */
    private String getXmlAttribute(XmlResourceParser xml, String name)
    {
        int resId = xml.getAttributeResourceValue(null, name, 0);
        if (resId == 0)
        {
            return xml.getAttributeValue(null, name);
        }
        else
        {
            return getString(resId);
        }
    }

    private Provider findProviderForDomain(String domain)
    {
        try
        {
            XmlResourceParser xml = getResources().getXml(R.xml.providers);
            int xmlEventType;
            Provider provider = null;
            while ((xmlEventType = xml.next()) != XmlResourceParser.END_DOCUMENT)
            {
                if (xmlEventType == XmlResourceParser.START_TAG
                        && ""provider"".equals(xml.getName())
                        && domain.equalsIgnoreCase(getXmlAttribute(xml, ""domain"")))
                {
                    provider = new Provider();
                    provider.id = getXmlAttribute(xml, ""id"");
                    provider.label = getXmlAttribute(xml, ""label"");
                    provider.domain = getXmlAttribute(xml, ""domain"");
                    provider.note = getXmlAttribute(xml, ""note"");
                }
                else if (xmlEventType == XmlResourceParser.START_TAG
                         && ""incoming"".equals(xml.getName())
                         && provider != null)
                {
                    provider.incomingUriTemplate = new URI(getXmlAttribute(xml, ""uri""));
                    provider.incomingUsernameTemplate = getXmlAttribute(xml, ""username"");
                }
                else if (xmlEventType == XmlResourceParser.START_TAG
                         && ""outgoing"".equals(xml.getName())
                         && provider != null)
                {
                    provider.outgoingUriTemplate = new URI(getXmlAttribute(xml, ""uri""));
                    provider.outgoingUsernameTemplate = getXmlAttribute(xml, ""username"");
                }
                else if (xmlEventType == XmlResourceParser.END_TAG
                         && ""provider"".equals(xml.getName())
                         && provider != null)
                {
                    return provider;
                }
            }
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Error while trying to load provider settings."", e);
        }
        return null;
    }

    private String[] splitEmail(String email)
    {
        String[] retParts = new String[2];
        String[] emailParts = email.split(""@"");
        retParts[0] = (emailParts.length > 0) ? emailParts[0] : """";
        retParts[1] = (emailParts.length > 1) ? emailParts[1] : """";
        return retParts;
    }

    static class Provider implements Serializable
    {
        private static final long serialVersionUID = 8511656164616538989L;

        public String id;

        public String label;

        public String domain;

        public URI incomingUriTemplate;

        public String incomingUsernameTemplate;

        public URI outgoingUriTemplate;

        public String outgoingUsernameTemplate;

        public String note;
    }
}
",True,216,0,0,8,53,1,10,L1
71,com.fsck.k9.remotecontrol.K9RemoteControl.java,"package com.fsck.k9.remotecontrol;


import android.app.Activity;
import android.content.Context;
import android.content.Intent;

/**
 * Utillity definitions for Android applications to control the behavior of K-9 Mail.  All such applications must declare the following permission:
 * <uses-permission android:name=""com.fsck.k9.permission.REMOTE_CONTROL""/>
 * in their AndroidManifest.xml  In addition, all applications sending remote control messages to K-9 Mail must
 *
 * An application that wishes to act on a particular Account in K-9 needs to fetch the list of configured Accounts by broadcasting an
 * {@link Intent} using K9_REQUEST_ACCOUNTS as the Action.  The broadcast must be made using the {@link ContextWrapper}
 * sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver,
 * Handler scheduler, int initialCode, String initialData, Bundle initialExtras).sendOrderedBroadcast}
 * method in order to receive the list of Account UUIDs and descriptions that K-9 will provide.
 *
 * @author Daniel I. Applebaum
 *
 */
public class K9RemoteControl
{
    /**
     * Permission that every application sending a broadcast to K-9 for Remote Control purposes should send on every broadcast.
     * Prevent other applications from intercepting the broadcasts.
     */
    public final static String K9_REMOTE_CONTROL_PERMISSION = ""com.fsck.k9.permission.REMOTE_CONTROL"";
    /**
     * {@link Intent} Action to be sent to K-9 using {@link ContextWrapper.sendOrderedBroadcast} in order to fetch the list of configured Accounts.
     * The responseData will contain two String[] with keys K9_ACCOUNT_UUIDS and K9_ACCOUNT_DESCRIPTIONS
     */
    public final static String K9_REQUEST_ACCOUNTS = ""com.fsck.k9.K9RemoteControl.requestAccounts"";
    public final static String K9_ACCOUNT_UUIDS = ""com.fsck.k9.K9RemoteControl.accountUuids"";
    public final static String K9_ACCOUNT_DESCRIPTIONS = ""com.fsck.k9.K9RemoteControl.accountDescriptions"";

    /**
     * The {@link {@link Intent}} Action to set in order to cause K-9 to check mail.  (Not yet implemented)
     */
    //public final static String K9_CHECK_MAIL = ""com.fsck.k9.K9RemoteControl.checkMail"";

    /**
     * The {@link {@link Intent}} Action to set when remotely changing K-9 Mail settings
     */
    public final static String K9_SET = ""com.fsck.k9.K9RemoteControl.set"";
    /**
     * The key of the {@link Intent} Extra to set to hold the UUID of a single Account's settings to change.  Used only if K9_ALL_ACCOUNTS
     * is absent or false.
     */
    public final static String K9_ACCOUNT_UUID = ""com.fsck.k9.K9RemoteControl.accountUuid"";
    /**
     * The key of the {@link Intent} Extra to set to control if the settings will apply to all Accounts, or to the one
     * specified with K9_ACCOUNT_UUID
     */
    public final static String K9_ALL_ACCOUNTS = ""com.fsck.k9.K9RemoteControl.allAccounts"";

    public final static String K9_ENABLED = ""true"";
    public final static String K9_DISABLED = ""false"";

    /*
     * Key for the {@link Intent} Extra for controlling whether notifications will be generated for new unread mail.
     * Acceptable values are K9_ENABLED and K9_DISABLED
     */
    public final static String K9_NOTIFICATION_ENABLED = ""com.fsck.k9.K9RemoteControl.notificationEnabled"";
    /*
     * Key for the {@link Intent} Extra for controlling whether K-9 will sound the ringtone for new unread mail.
     * Acceptable values are K9_ENABLED and K9_DISABLED
     */
    public final static String K9_RING_ENABLED = ""com.fsck.k9.K9RemoteControl.ringEnabled"";
    /*
     * Key for the {@link Intent} Extra for controlling whether K-9 will activate the vibrator for new unread mail.
     * Acceptable values are K9_ENABLED and K9_DISABLED
     */
    public final static String K9_VIBRATE_ENABLED = ""com.fsck.k9.K9RemoteControl.vibrateEnabled"";

    public final static String K9_FOLDERS_NONE = ""NONE"";
    public final static String K9_FOLDERS_ALL = ""ALL"";
    public final static String K9_FOLDERS_FIRST_CLASS = ""FIRST_CLASS"";
    public final static String K9_FOLDERS_FIRST_AND_SECOND_CLASS = ""FIRST_AND_SECOND_CLASS"";
    public final static String K9_FOLDERS_NOT_SECOND_CLASS = ""NOT_SECOND_CLASS"";
    /**
     * Key for the {@link Intent} Extra to set for controlling which folders to be synchronized with Push.
     * Acceptable values are K9_FOLDERS_ALL, K9_FOLDERS_FIRST_CLASS, K9_FOLDERS_FIRST_AND_SECOND_CLASS,
     * K9_FOLDERS_NOT_SECOND_CLASS, K9_FOLDERS_NONE
     */
    public final static String K9_PUSH_CLASSES = ""com.fsck.k9.K9RemoteControl.pushClasses"";
    /**
     * Key for the {@link Intent} Extra to set for controlling which folders to be synchronized with Poll.
     * Acceptable values are K9_FOLDERS_ALL, K9_FOLDERS_FIRST_CLASS, K9_FOLDERS_FIRST_AND_SECOND_CLASS,
     * K9_FOLDERS_NOT_SECOND_CLASS, K9_FOLDERS_NONE
     */
    public final static String K9_POLL_CLASSES = ""com.fsck.k9.K9RemoteControl.pollClasses"";

    public final static String[] K9_POLL_FREQUENCIES = { ""-1"", ""1"", ""5"", ""10"", ""15"", ""30"", ""60"", ""120"", ""180"", ""360"", ""720"", ""1440""};
    /**
     * Key for the {@link Intent} Extra to set with the desired poll frequency.  The value is a String representing a number of minutes.
     * Acceptable values are available in K9_POLL_FREQUENCIES
     */
    public final static String K9_POLL_FREQUENCY = ""com.fsck.k9.K9RemoteControl.pollFrequency"";

    /**
     * Key for the {@link Intent} Extra to set for controlling K-9's global ""Background sync"" setting.
     * Acceptable values are K9_BACKGROUND_OPERATIONS_ALWAYS, K9_BACKGROUND_OPERATIONS_NEVER
     * K9_BACKGROUND_OPERATIONS_WHEN_CHECKED
     */
    public final static String K9_BACKGROUND_OPERATIONS = ""com.fsck.k9.K9RemoteControl.backgroundOperations"";
    public final static String K9_BACKGROUND_OPERATIONS_WHEN_CHECKED = ""WHEN_CHECKED"";
    public final static String K9_BACKGROUND_OPERATIONS_ALWAYS = ""ALWAYS"";
    public final static String K9_BACKGROUND_OPERATIONS_NEVER = ""NEVER"";
    public final static String K9_BACKGROUND_OPERATIONS_WHEN_CHECKED_AUTO_SYNC = ""WHEN_CHECKED_AUTO_SYNC"";

    /**
     * Key for the {@link Intent} Extra to set for controlling which display theme K-9 will use.  Acceptable values are
     * K9_THEME_LIGHT, K9_THEME_DARK
     */
    public final static String K9_THEME = ""com.fsck.k9.K9RemoteControl.theme"";
    public final static String K9_THEME_LIGHT = ""LIGHT"";
    public final static String K9_THEME_DARK = ""DARK"";

    protected static String LOG_TAG = ""K9RemoteControl"";

    public static void set(Context context, Intent broadcastIntent)
    {
        broadcastIntent.setAction(K9RemoteControl.K9_SET);
        context.sendBroadcast(broadcastIntent, K9RemoteControl.K9_REMOTE_CONTROL_PERMISSION);
    }

    public static void fetchAccounts(Context context, K9AccountReceptor receptor)
    {
        Intent accountFetchIntent = new Intent();
        accountFetchIntent.setAction(K9RemoteControl.K9_REQUEST_ACCOUNTS);
        AccountReceiver receiver = new AccountReceiver(receptor);
        context.sendOrderedBroadcast(accountFetchIntent, K9RemoteControl.K9_REMOTE_CONTROL_PERMISSION, receiver, null, Activity.RESULT_OK, null, null);
    }

}


",False,5,1,2,1,2,3,2,L4
72,com.fsck.k9.remotecontrol.K9AccountReceptor.java,"package com.fsck.k9.remotecontrol;
/**
 *
 * @author Daniel I. Applebaum
 * The interface to implement in order to accept the arrays containing the UUIDs and descriptions of
 * the accounts configured in K-9 Mail.  Should be passed to fetchAccounts(Context, K9AccountReceptor)
 */
public interface K9AccountReceptor
{
    public void accounts(String[] uuids, String[] descriptions);
}",False,5,2,2,0,0,2,0,L4
73,com.fsck.k9.remotecontrol.AccountReceiver.java,"package com.fsck.k9.remotecontrol;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

class AccountReceiver extends BroadcastReceiver
{
    K9AccountReceptor receptor = null;

    protected AccountReceiver(K9AccountReceptor nReceptor)
    {
        receptor = nReceptor;
    }

    @Override
    public void onReceive(Context context, Intent intent)
    {
        if (K9RemoteControl.K9_REQUEST_ACCOUNTS.equals(intent.getAction()))
        {
            Bundle bundle = getResultExtras(false);
            if (bundle == null)
            {
                Log.w(K9RemoteControl.LOG_TAG, ""Response bundle is empty"");
                return;
            }
            receptor.accounts(bundle.getStringArray(K9RemoteControl.K9_ACCOUNT_UUIDS), bundle.getStringArray(K9RemoteControl.K9_ACCOUNT_DESCRIPTIONS));
        }
    }

}
",False,3,0,0,1,2,1,2,L4
74,com.fsck.k9.provider.MessageProvider.java,"package com.fsck.k9.provider;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.content.Context;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.net.Uri;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.AccountStats;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.SearchAccount;
import com.fsck.k9.activity.FolderInfoHolder;
import com.fsck.k9.activity.MessageInfoHolder;
import com.fsck.k9.activity.MessageList;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.helper.MessageHelper;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.store.LocalStore;

public class MessageProvider extends ContentProvider
{

    protected interface QueryHandler
    {
        /**
         * The path this instance is able to respond to.
         * 
         * @return Never <code>null</code>.
         */
        String getPath();

        /**
         * @param uri
         * @param projection
         * @param selection
         * @param selectionArgs
         * @param sortOrder
         * @return
         * @throws Exception
         * @see {@link ContentProvider#query(Uri, String[], String, String[], String)}
         */
        Cursor query(Uri uri, String[] projection,
                String selection, String[] selectionArgs, String sortOrder) throws Exception;
    }

    /**
     * Retrieve messages from the integrated inbox.
     */
    protected class MessagesQueryHandler implements QueryHandler
    {

        @Override
        public String getPath()
        {
            return ""inbox_messages/"";
        }

        @Override
        public Cursor query(final Uri uri, final String[] projection, final String selection,
                final String[] selectionArgs, final String sortOrder) throws Exception
        {
            return getMessages(projection);
        }

        /**
         * @param projection
         *            Projection to use. If <code>null</code>, use the default
         *            projection.
         * @return Never <code>null</code>.
         * @throws InterruptedException
         */
        protected MatrixCursor getMessages(final String[] projection) throws InterruptedException
        {
            // TODO use the given projection if prevent
            final MatrixCursor cursor = new MatrixCursor(DEFAULT_MESSAGE_PROJECTION);
            final BlockingQueue<List<MessageInfoHolder>> queue = new SynchronousQueue<List<MessageInfoHolder>>();

            // new code for integrated inbox, only execute this once as it will be processed afterwards via the listener
            final SearchAccount integratedInboxAccount = new SearchAccount(getContext(), true, null, null);
            final MessagingController msgController = MessagingController.getInstance(K9.app);

            msgController.searchLocalMessages(integratedInboxAccount, null,
                    new MesssageInfoHolderRetrieverListener(queue));

            final List<MessageInfoHolder> holders = queue.take();

            // TODO add sort order parameter
            Collections.sort(holders, new MessageList.ReverseComparator<MessageInfoHolder>(
                    new MessageList.DateComparator()));

            int id = -1;
            for (final MessageInfoHolder holder : holders)
            {
                final Message message = holder.message;
                id++;

                cursor.addRow(new Object[]
                {
                        id,
                        holder.fullDate,
                        holder.sender,
                        holder.subject,
                        holder.preview,
                        holder.account,
                        holder.uri,
                        CONTENT_URI + ""/delete_message/""
                                + message.getFolder().getAccount().getAccountNumber() + ""/""
                                + message.getFolder().getName() + ""/"" + message.getUid() });
            }
            return cursor;
        }

    }

    /**
     * Retrieve the account list.
     */
    protected class AccountsQueryHandler implements QueryHandler
    {

        @Override
        public String getPath()
        {
            return ""accounts"";
        }

        @Override
        public Cursor query(final Uri uri, String[] projection, String selection,
                String[] selectionArgs, String sortOrder) throws Exception
        {
            return getAllAccounts();
        }

        public Cursor getAllAccounts()
        {
            String[] projection = new String[] { ""accountNumber"", ""accountName"" };

            MatrixCursor ret = new MatrixCursor(projection);

            for (Account account : Preferences.getPreferences(getContext()).getAccounts())
            {
                Object[] values = new Object[2];
                values[0] = account.getAccountNumber();
                values[1] = account.getDescription();
                ret.addRow(values);
            }

            return ret;
        }

    }

    /**
     * Retrieve the unread message count for a given account specified by its
     * {@link Account#getAccountNumber() number}.
     */
    protected class UnreadQueryHandler implements QueryHandler
    {

        @Override
        public String getPath()
        {
            return ""account_unread/#"";
        }

        @Override
        public Cursor query(final Uri uri, String[] projection, String selection,
                String[] selectionArgs, String sortOrder) throws Exception
        {
            List<String> segments = null;
            int accountId = -1;
            segments = uri.getPathSegments();
            accountId = Integer.parseInt(segments.get(1));
            return getAccountUnread(accountId);
        }

        public Cursor getAccountUnread(int accountNumber)
        {
            String[] projection = new String[] { ""accountName"", ""unread"" };

            MatrixCursor ret = new MatrixCursor(projection);

            Account myAccount;
            AccountStats myAccountStats = null;

            Object[] values = new Object[2];

            for (Account account : Preferences.getPreferences(getContext()).getAccounts())
            {
                if (account.getAccountNumber()==accountNumber)
                {
                    myAccount = account;
                    try
                    {
                        myAccountStats = account.getStats(getContext());
                        values[0] = myAccount.getDescription();
                        values[1] = myAccountStats.unreadMessageCount;
                        ret.addRow(values);
                    }
                    catch (MessagingException e)
                    {
                        Log.e(K9.LOG_TAG, e.getMessage());
                        values[0] = ""Unknown"";
                        values[1] = 0;
                    }
                }
            }

            return ret;
        }
    }

    /**
     * Synchronized listener used to retrieve {@link MessageInfoHolder}s using a
     * given {@link BlockingQueue}.
     */
    protected class MesssageInfoHolderRetrieverListener extends MessagingListener
    {
        private final BlockingQueue<List<MessageInfoHolder>> queue;

        private List<MessageInfoHolder> mHolders = new ArrayList<MessageInfoHolder>();

        /**
         * @param queue
         *            Never <code>null</code>. The synchronized channel to use
         *            to retrieve {@link MessageInfoHolder}s.
         */
        public MesssageInfoHolderRetrieverListener(final BlockingQueue<List<MessageInfoHolder>> queue)
        {
            this.queue = queue;
        }

        @Override
        public void listLocalMessagesAddMessages(final Account account,
                final String folderName, final List<Message> messages)
        {
            // cache fields into local variables for faster access on JVM without JIT
            final MessageHelper helper = mMessageHelper;
            final List<MessageInfoHolder> holders = mHolders;

            final Context context = getContext();

            for (final Message message : messages)
            {
                final MessageInfoHolder messageInfoHolder = new MessageInfoHolder();
                final Folder messageFolder = message.getFolder();
                final Account messageAccount = messageFolder.getAccount();

                helper.populate(messageInfoHolder, message, new FolderInfoHolder(context,
                        messageFolder, messageAccount), messageAccount);

                holders.add(messageInfoHolder);
            }
        }

        @Override
        public void searchStats(AccountStats stats)
        {
            try
            {
                queue.put(mHolders);
            }
            catch (InterruptedException e)
            {
                Log.e(K9.LOG_TAG, ""Unable to return message list back to caller"", e);
            }
        }
    }

    public static final String AUTHORITY = ""com.fsck.k9.messageprovider"";

    public static final Uri CONTENT_URI = Uri.parse(""content://"" + AUTHORITY);

    private static final String[] DEFAULT_MESSAGE_PROJECTION = new String[]
    {
        ""id"",
        ""date"",
        ""sender"",
        ""subject"",
        ""preview"",
        ""account"",
        ""uri"",
        ""delUri""
    };

    /**
     * URI matcher used for
     * {@link #query(Uri, String[], String, String[], String)}
     */
    private UriMatcher mUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);

    /**
     * Handlers registered to respond to
     * {@link #query(Uri, String[], String, String[], String)}
     */
    private List<QueryHandler> mQueryHandlers = new ArrayList<QueryHandler>();

    private MessageHelper mMessageHelper;

    @Override
    public boolean onCreate()
    {
        mMessageHelper = MessageHelper.getInstance(getContext());

        registerQueryHandler(new AccountsQueryHandler());
        registerQueryHandler(new MessagesQueryHandler());
        registerQueryHandler(new UnreadQueryHandler());

        return true;
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs)
    {
        if (K9.DEBUG)
        {
            Log.v(K9.LOG_TAG, ""delete"");
        }

        // Nota : can only delete a message

        List<String> segments = null;
        int accountId = -1;
        String folderName = null;
        String msgUid = null;

        segments = uri.getPathSegments();
        accountId = Integer.parseInt(segments.get(1));
        folderName = segments.get(2);
        msgUid = segments.get(3);

        // get account
        Account myAccount = null;
        for (Account account : Preferences.getPreferences(getContext()).getAccounts())
        {
            if (account.getAccountNumber() == accountId)
            {
                myAccount = account;
            }
        }

        // get localstore parameter
        Message msg = null;
        try
        {
            Folder lf = LocalStore.getLocalInstance(myAccount, K9.app).getFolder(folderName);
            int msgCount = lf.getMessageCount();
            if (K9.DEBUG)
            {
                Log.d(K9.LOG_TAG, ""folder msg count = "" + msgCount);
            }
            msg = lf.getMessage(msgUid);
        }
        catch (MessagingException e)
        {
            Log.e(K9.LOG_TAG, ""Unable to retrieve message"", e);
        }

        // launch command to delete the message
        if ((myAccount != null) && (msg != null))
        {
            MessagingController.getInstance(K9.app).deleteMessages(new Message[] { msg }, null);
        }

        return 0;
    }

    @Override
    public String getType(Uri uri)
    {
        return null;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values)
    {
        return null;
    }

    @Override
    public Cursor query(final Uri uri, final String[] projection, final String selection,
            final String[] selectionArgs, final String sortOrder)
    {
        final Cursor cursor;

        final int code = mUriMatcher.match(uri);

        if (code == -1)
        {
            throw new IllegalStateException(""Unrecognized URI: "" + uri);
        }

        try
        {
            // since we used the list index as the UriMatcher code, using it
            // back to retrieve the handler from the list
            final QueryHandler handler = mQueryHandlers.get(code);
            cursor = handler.query(uri, projection, selection, selectionArgs, sortOrder);
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Unable to execute query for URI: "" + uri, e);
            return null;
        }

        return cursor;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
    {

        if (K9.DEBUG)
        {
            Log.v(K9.LOG_TAG, ""update"");
        }

//TBD

        return 0;
    }

    /**
     * Register a {@link QueryHandler} to handle a certain {@link Uri} for
     * {@link #query(Uri, String[], String, String[], String)}
     * 
     * @param handler
     *            Never <code>null</code>.
     */
    protected void registerQueryHandler(final QueryHandler handler)
    {
        if (mQueryHandlers.contains(handler))
        {
            return;
        }
        mQueryHandlers.add(handler);

        // use the index inside the list as the UriMatcher code for that handler
        final int code = mQueryHandlers.indexOf(handler);
        mUriMatcher.addURI(AUTHORITY, handler.getPath(), code);
    }

}
",True,217,0,0,7,62,0,16,L4
75,com.fsck.k9.provider.AttachmentProvider.java,"package com.fsck.k9.provider;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.database.sqlite.SQLiteDatabase;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.os.ParcelFileDescriptor;
import android.os.Environment;
import android.util.Log;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.mail.internet.MimeUtility;

import java.io.*;
import java.util.List;

/*
 * A simple ContentProvider that allows file access to Email's attachments.
 */
public class AttachmentProvider extends ContentProvider
{
    public static final Uri CONTENT_URI = Uri.parse(""content://com.fsck.k9.attachmentprovider"");

    private static final String FORMAT_RAW = ""RAW"";
    private static final String FORMAT_THUMBNAIL = ""THUMBNAIL"";

    public static class AttachmentProviderColumns
    {
        public static final String _ID = ""_id"";
        public static final String DATA = ""_data"";
        public static final String DISPLAY_NAME = ""_display_name"";
        public static final String SIZE = ""_size"";
    }

    public static Uri getAttachmentUri(Account account, long id)
    {
        return getAttachmentUri(account.getUuid() + "".db"" , id);
    }

    public static Uri getAttachmentThumbnailUri(Account account, long id, int width, int height)
    {
        return CONTENT_URI.buildUpon()
               .appendPath(account.getUuid() + "".db"")
               .appendPath(Long.toString(id))
               .appendPath(FORMAT_THUMBNAIL)
               .appendPath(Integer.toString(width))
               .appendPath(Integer.toString(height))
               .build();
    }

    public static Uri getAttachmentUri(String db, long id)
    {
        return CONTENT_URI.buildUpon()
               .appendPath(db)
               .appendPath(Long.toString(id))
               .appendPath(FORMAT_RAW)
               .build();
    }

    @Override
    public boolean onCreate()
    {
        /*
         * We use the cache dir as a temporary directory (since Android doesn't give us one) so
         * on startup we'll clean up any .tmp files from the last run.
         */
        File[] files = getContext().getCacheDir().listFiles();
        for (File file : files)
        {
            if (file.getName().endsWith("".tmp""))
            {
                file.delete();
            }
        }

        return true;
    }

    public static void clear(Context lContext)
    {
        /*
         * We use the cache dir as a temporary directory (since Android doesn't give us one) so
         * on startup we'll clean up any .tmp files from the last run.
         */
        File[] files = lContext.getCacheDir().listFiles();
        for (File file : files)
        {
            try
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Deleting file "" + file.getCanonicalPath());
            }
            catch (IOException ioe) {}   // No need to log failure to log
            file.delete();
        }
    }

    @Override
    public String getType(Uri uri)
    {
        List<String> segments = uri.getPathSegments();
        String dbName = segments.get(0);
        String id = segments.get(1);
        String format = segments.get(2);
        if (FORMAT_THUMBNAIL.equals(format))
        {
            return ""image/png"";
        }
        else
        {
            String path = getContext().getDatabasePath(dbName).getAbsolutePath();
            SQLiteDatabase db = null;
            Cursor cursor = null;
            try
            {
                db = SQLiteDatabase.openDatabase(path, null, 0);
                cursor = db.query(
                             ""attachments"",
                             new String[] { ""mime_type"", ""name"" },
                             ""id = ?"",
                             new String[] { id },
                             null,
                             null,
                             null);
                cursor.moveToFirst();
                String type = cursor.getString(0);
                String name = cursor.getString(1);
                cursor.close();
                db.close();

                if (MimeUtility.DEFAULT_ATTACHMENT_MIME_TYPE.equals(type))
                {
                    type = MimeUtility.getMimeTypeByExtension(name);
                }
                return type;
            }
            finally
            {
                if (cursor != null)
                {
                    cursor.close();
                }
                if (db != null)
                {
                    db.close();
                }

            }
        }
    }

    private File getFile(String dbName, String id)
    throws FileNotFoundException
    {
        try
        {
            File attachmentsDir = getContext().getDatabasePath(dbName + ""_att"");
            File file = new File(attachmentsDir, id);
            if (!file.exists())
            {
                file = new File(Environment.getExternalStorageDirectory()  + attachmentsDir.getCanonicalPath().substring(""/data"".length()), id);
                if (!file.exists())
                {
                    throw new FileNotFoundException();
                }
            }
            return file;
        }
        catch (IOException e)
        {
            Log.w(K9.LOG_TAG, null, e);
            throw new FileNotFoundException(e.getMessage());
        }
    }

    @Override
    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException
    {
        List<String> segments = uri.getPathSegments();
        String dbName = segments.get(0);
        String id = segments.get(1);
        String format = segments.get(2);
        if (FORMAT_THUMBNAIL.equals(format))
        {
            int width = Integer.parseInt(segments.get(3));
            int height = Integer.parseInt(segments.get(4));
            String filename = ""thmb_"" + dbName + ""_"" + id + "".tmp"";
            File dir = getContext().getCacheDir();
            File file = new File(dir, filename);
            if (!file.exists())
            {
                Uri attachmentUri = getAttachmentUri(dbName, Long.parseLong(id));
                String type = getType(attachmentUri);
                try
                {
                    FileInputStream in = new FileInputStream(getFile(dbName, id));
                    Bitmap thumbnail = createThumbnail(type, in);
                    thumbnail = Bitmap.createScaledBitmap(thumbnail, width, height, true);
                    FileOutputStream out = new FileOutputStream(file);
                    thumbnail.compress(Bitmap.CompressFormat.PNG, 100, out);
                    out.close();
                    in.close();
                }
                catch (IOException ioe)
                {
                    return null;
                }
            }
            return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
        }
        else
        {
            return ParcelFileDescriptor.open(
                       getFile(dbName, id),
                       ParcelFileDescriptor.MODE_READ_ONLY);
        }
    }

    @Override
    public int delete(Uri uri, String arg1, String[] arg2)
    {
        return 0;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values)
    {
        return null;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
                        String sortOrder)
    {
        if (projection == null)
        {
            projection =
                new String[]
            {
                AttachmentProviderColumns._ID,
                AttachmentProviderColumns.DATA,
            };
        }

        List<String> segments = uri.getPathSegments();
        String dbName = segments.get(0);
        String id = segments.get(1);
        //String format = segments.get(2);
        String path = getContext().getDatabasePath(dbName).getAbsolutePath();
        String name = null;
        int size = -1;
        SQLiteDatabase db = null;
        Cursor cursor = null;
        try
        {
            db = SQLiteDatabase.openDatabase(path, null, 0);
            cursor = db.query(
                         ""attachments"",
                         new String[] { ""name"", ""size"" },
                         ""id = ?"",
                         new String[] { id },
                         null,
                         null,
                         null);
            if (!cursor.moveToFirst())
            {
                return null;
            }
            name = cursor.getString(0);
            size = cursor.getInt(1);
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
            if (db != null)
            {
                db.close();
            }
        }

        MatrixCursor ret = new MatrixCursor(projection);
        Object[] values = new Object[projection.length];
        for (int i = 0, count = projection.length; i < count; i++)
        {
            String column = projection[i];
            if (AttachmentProviderColumns._ID.equals(column))
            {
                values[i] = id;
            }
            else if (AttachmentProviderColumns.DATA.equals(column))
            {
                values[i] = uri.toString();
            }
            else if (AttachmentProviderColumns.DISPLAY_NAME.equals(column))
            {
                values[i] = name;
            }
            else if (AttachmentProviderColumns.SIZE.equals(column))
            {
                values[i] = size;
            }
        }
        ret.addRow(values);
        return ret;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
    {
        return 0;
    }

    private Bitmap createThumbnail(String type, InputStream data)
    {
        if (MimeUtility.mimeTypeMatches(type, ""image/*""))
        {
            return createImageThumbnail(data);
        }
        return null;
    }

    private Bitmap createImageThumbnail(InputStream data)
    {
        try
        {
            Bitmap bitmap = BitmapFactory.decodeStream(data);
            return bitmap;
        }
        catch (OutOfMemoryError oome)
        {
            /*
             * Improperly downloaded images, corrupt bitmaps and the like can commonly
             * cause OOME due to invalid allocation sizes. We're happy with a null bitmap in
             * that case. If the system is really out of memory we'll know about it soon
             * enough.
             */
            return null;
        }
        catch (Exception e)
        {
            return null;
        }
    }
}
",True,216,0,0,8,51,2,3,L1
76,com.fsck.k9.web.AccessibleWebView.java,"/*
 * Copyright (C) 2010 The IDEAL Group
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.web;

import android.content.Context;
import android.content.Intent;
import android.text.Html;
import android.util.AttributeSet;
import android.view.View;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.widget.TextView;

public class AccessibleWebView extends TextView
{
    private Context mContext;
    private String mHtmlSource;
    private WebView mDummyWebView;

    public AccessibleWebView(Context context)
    {
        super(context);
        init(context);
    }

    public AccessibleWebView(Context context, AttributeSet attributes)
    {
        super(context, attributes);
        init(context);
    }

    private void init(Context context)
    {
        mContext = context;
        mDummyWebView = new WebView(context);
        setFocusable(true);
        setFocusableInTouchMode(true);
        setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View arg0)
            {
                diveIn();
            }
        });
    }

    public void loadData(String data, String mimeType, String encoding)
    {
        mHtmlSource = data;
        this.setText(Html.fromHtml(mHtmlSource, null, null));
    }

    public WebSettings getSettings()
    {
        return mDummyWebView.getSettings();
    }

    public void loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding,
                                    String historyUrl)
    {
        mHtmlSource = data;
        this.setText(Html.fromHtml(mHtmlSource, null, null));
    }

    public boolean zoomIn()
    {
        if (getTextSize() < 100)
        {
            setTextSize(getTextSize() + 5);
            return true;
        }
        return false;
    }

    public boolean zoomOut()
    {
        if (getTextSize() > 5)
        {
            setTextSize(getTextSize() - 5);
            return true;
        }
        return false;
    }

    private void diveIn()
    {
        Intent i = new Intent();
        i.setClass(mContext, AccessibleEmailContentActivity.class);
        i.putExtra(""content"", mHtmlSource);
        mContext.startActivity(i);
    }
}
",False,92,8,39,0,0,1,0,L1
77,com.fsck.k9.web.AccessibleEmailContentActivity.java,"/*
 * Copyright (C) 2010 The IDEAL Group
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.web;

import java.util.ArrayList;
import android.app.ListActivity;
import android.os.Bundle;
import android.text.Html;
import android.text.Spanned;
import android.widget.ArrayAdapter;

public class AccessibleEmailContentActivity extends ListActivity
{
    /**
     * Immutable empty String array
     */
    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    /**
     * Called when the activity is first created.
     */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        String htmlSource = getIntent().getStringExtra(""content"");
        Spanned parsedHtml = Html.fromHtml(htmlSource, null, null);
        String[] rawListItems = parsedHtml.toString().split(""\n"");

        ArrayList<String> cleanedList = new ArrayList<String>();
        for (int i = 0; i < rawListItems.length; i++)
        {
            if (rawListItems[i].trim().length() > 0)
            {
                addToCleanedList(cleanedList, rawListItems[i]);
            }
        }

        String[] listItems = cleanedList.toArray(EMPTY_STRING_ARRAY);

        setContentView(com.fsck.k9.R.layout.accessible_email_content);
        setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, listItems));
    }

    private void addToCleanedList(ArrayList<String> cleanedList, String line)
    {
        if (line.length() < 80)
        {
            cleanedList.add(line);
        }
        else
        {
            while (line.length() > 80)
            {
                int cutPoint = line.indexOf("" "", 80);
                if ((cutPoint > 0) && (cutPoint < line.length()))
                {
                    cleanedList.add(line.substring(0, cutPoint));
                    line = line.substring(cutPoint).trim();
                }
                else
                {
                    cleanedList.add(line);
                    line = """";
                }
            }
            if (line.length() > 0)
            {
                cleanedList.add(line);
            }
        }
    }

}
",False,1,0,0,0,0,0,0,I0
78,com.fsck.k9.service.PollService.java,"package com.fsck.k9.service;

import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.os.PowerManager;
import android.util.Log;
import com.fsck.k9.*;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.controller.MessagingListener;
import com.fsck.k9.helper.power.TracingPowerManager;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;

import java.util.HashMap;

public class PollService extends CoreService
{
    private static String START_SERVICE = ""com.fsck.k9.service.PollService.startService"";
    private static String STOP_SERVICE = ""com.fsck.k9.service.PollService.stopService"";

    private Listener mListener = new Listener();

    public static void startService(Context context)
    {
        Intent i = new Intent();
        i.setClass(context, PollService.class);
        i.setAction(PollService.START_SERVICE);
        addWakeLock(context, i);
        context.startService(i);
    }

    public static void stopService(Context context)
    {
        Intent i = new Intent();
        i.setClass(context, PollService.class);
        i.setAction(PollService.STOP_SERVICE);
        addWakeLock(context, i);
        context.startService(i);
    }

    @Override
    public void startService(Intent intent, int startId)
    {
        if (START_SERVICE.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PollService started with startId = "" + startId);

            MessagingController controller = MessagingController.getInstance(getApplication());
            Listener listener = (Listener)controller.getCheckMailListener();
            if (listener == null)
            {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""***** PollService *****: starting new check"");
                mListener.setStartId(startId);
                mListener.wakeLockAcquire();
                controller.setCheckMailListener(mListener);
                controller.checkMail(this, null, false, false, mListener);
            }
            else
            {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG,""***** PollService *****: renewing WakeLock"");
                listener.setStartId(startId);
                listener.wakeLockAcquire();
            }
        }
        else if (STOP_SERVICE.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PollService stopping"");
            stopSelf();
        }

    }

    @Override
    public IBinder onBind(Intent arg0)
    {
        return null;
    }

    class Listener extends MessagingListener
    {
        HashMap<String, Integer> accountsChecked = new HashMap<String, Integer>();
        private TracingWakeLock wakeLock = null;
        private int startId = -1;

        // wakelock strategy is to be very conservative.  If there is any reason to release, then release
        // don't want to take the chance of running wild
        public synchronized void wakeLockAcquire()
        {
            TracingWakeLock oldWakeLock = wakeLock;

            TracingPowerManager pm = TracingPowerManager.getPowerManager(PollService.this);
            wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""PollService wakeLockAcquire"");
            wakeLock.setReferenceCounted(false);
            wakeLock.acquire(K9.WAKE_LOCK_TIMEOUT);

            if (oldWakeLock != null)
            {
                oldWakeLock.release();
            }

        }
        public synchronized void wakeLockRelease()
        {
            if (wakeLock != null)
            {
                wakeLock.release();
                wakeLock = null;
            }
        }
        @Override
        public void checkMailStarted(Context context, Account account)
        {
            accountsChecked.clear();
        }

        @Override
        public void checkMailFailed(Context context, Account account, String reason)
        {
            release();
        }

        @Override
        public void synchronizeMailboxFinished(
            Account account,
            String folder,
            int totalMessagesInMailbox,
            int numNewMessages)
        {
            if (account.isNotifyNewMail())
            {
                Integer existingNewMessages = accountsChecked.get(account.getUuid());
                if (existingNewMessages == null)
                {
                    existingNewMessages = 0;
                }
                accountsChecked.put(account.getUuid(), existingNewMessages + numNewMessages);
            }
        }

        private void release()
        {

            MessagingController controller = MessagingController.getInstance(getApplication());
            controller.setCheckMailListener(null);
            MailService.saveLastCheckEnd(getApplication());

            MailService.actionReschedulePoll(PollService.this, null);
            wakeLockRelease();
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PollService stopping with startId = "" + startId);

            stopSelf(startId);
        }

        @Override
        public void checkMailFinished(Context context, Account account)
        {

            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""***** PollService *****: checkMailFinished"");
            release();
        }
        public int getStartId()
        {
            return startId;
        }
        public void setStartId(int startId)
        {
            this.startId = startId;
        }
    }

}
",False,216,0,0,8,59,1,7,L1
79,com.fsck.k9.service.PushService.java,"package com.fsck.k9.service;

import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.util.Log;
import com.fsck.k9.K9;

public class PushService extends CoreService
{
    private static String START_SERVICE = ""com.fsck.k9.service.PushService.startService"";
    private static String STOP_SERVICE = ""com.fsck.k9.service.PushService.stopService"";

    public static void startService(Context context)
    {
        Intent i = new Intent();
        i.setClass(context, PushService.class);
        i.setAction(PushService.START_SERVICE);
        addWakeLock(context, i);
        context.startService(i);
    }

    public static void stopService(Context context)
    {
        Intent i = new Intent();
        i.setClass(context, PushService.class);
        i.setAction(PushService.STOP_SERVICE);
        addWakeLock(context, i);
        context.startService(i);
    }

    @Override
    public void startService(Intent intent, int startId)
    {
        if (START_SERVICE.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PushService started with startId = "" + startId);
        }
        else if (STOP_SERVICE.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""PushService stopping with startId = "" + startId);
            stopSelf(startId);
        }

    }

    @Override
    public IBinder onBind(Intent arg0)
    {
        // TODO Auto-generated method stub
        return null;
    }
}
",False,216,0,0,9,59,1,2,L1
80,com.fsck.k9.service.RemoteControlReceiver.java,"
package com.fsck.k9.service;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.remotecontrol.K9RemoteControl;
import com.fsck.k9.Preferences;

import static com.fsck.k9.remotecontrol.K9RemoteControl.*;

public class RemoteControlReceiver extends CoreReceiver
{
    @Override
    public Integer receive(Context context, Intent intent, Integer tmpWakeLockId)
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""RemoteControlReceiver.onReceive"" + intent);

        if (K9RemoteControl.K9_SET.equals(intent.getAction()))
        {
            RemoteControlService.set(context, intent, tmpWakeLockId);
            tmpWakeLockId = null;
        }
        else if (K9RemoteControl.K9_REQUEST_ACCOUNTS.equals(intent.getAction()))
        {
            try
            {
                Preferences preferences = Preferences.getPreferences(context);
                Account[] accounts = preferences.getAccounts();
                String[] uuids = new String[accounts.length];
                String[] descriptions = new String[accounts.length];
                for (int i = 0; i < accounts.length; i++)
                {
                    Account account = accounts[i];

                    uuids[i] = account.getUuid();
                    descriptions[i] = account.getDescription();
                }
                Bundle bundle = getResultExtras(true);
                bundle.putStringArray(K9_ACCOUNT_UUIDS, uuids);
                bundle.putStringArray(K9_ACCOUNT_DESCRIPTIONS, descriptions);
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Could not handle K9_RESPONSE_INTENT"", e);
            }

        }

        return tmpWakeLockId;
    }

}
",True,221,0,0,8,50,0,6,L4
81,com.fsck.k9.service.RemoteControlService.java,"package com.fsck.k9.service;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.remotecontrol.K9RemoteControl;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.K9.BACKGROUND_OPS;

import static com.fsck.k9.remotecontrol.K9RemoteControl.*;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.util.Log;
import android.widget.Toast;

public class RemoteControlService extends CoreService
{
    private final static String RESCHEDULE_ACTION = ""com.fsck.k9.service.RemoteControlService.RESCHEDULE_ACTION"";
    private final static String PUSH_RESTART_ACTION = ""com.fsck.k9.service.RemoteControlService.PUSH_RESTART_ACTION"";

    private final static String SET_ACTION = ""com.fsck.k9.service.RemoteControlService.SET_ACTION"";

    public static void set(Context context, Intent i, Integer wakeLockId)
    {
        //  Intent i = new Intent();
        i.setClass(context, RemoteControlService.class);
        i.setAction(RemoteControlService.SET_ACTION);
        addWakeLockId(i, wakeLockId);
        if (wakeLockId == null)
        {
            addWakeLock(context, i);
        }
        context.startService(i);
    }

    public static final int REMOTE_CONTROL_SERVICE_WAKE_LOCK_TIMEOUT = 20000;

    @Override
    public void startService(final Intent intent, final int startId)
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""RemoteControlService started with startId = "" + startId);
        final Preferences preferences = Preferences.getPreferences(this);

        if (RESCHEDULE_ACTION.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""RemoteControlService requesting MailService poll reschedule"");
            MailService.actionReschedulePoll(this, null);
        }
        if (PUSH_RESTART_ACTION.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""RemoteControlService requesting MailService push restart"");
            MailService.actionRestartPushers(this, null);
        }
        else if (RemoteControlService.SET_ACTION.equals(intent.getAction()))
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""RemoteControlService got request to change settings"");
            execute(getApplication(), new Runnable()
            {
                public void run()
                {
                    try
                    {
                        boolean needsReschedule = false;
                        boolean needsPushRestart = false;
                        String uuid = intent.getStringExtra(K9_ACCOUNT_UUID);
                        boolean allAccounts = intent.getBooleanExtra(K9_ALL_ACCOUNTS, false);
                        if (K9.DEBUG)
                        {
                            if (allAccounts)
                            {
                                Log.i(K9.LOG_TAG, ""RemoteControlService changing settings for all accounts"");
                            }
                            else
                            {
                                Log.i(K9.LOG_TAG, ""RemoteControlService changing settings for account with UUID "" + uuid);
                            }
                        }
                        Account[] accounts = preferences.getAccounts();
                        for (Account account : accounts)
                        {
                            if (allAccounts || account.getUuid().equals(uuid))
                            {

                                if (K9.DEBUG)
                                    Log.i(K9.LOG_TAG, ""RemoteControlService changing settings for account "" + account.getDescription());

                                String notificationEnabled = intent.getStringExtra(K9_NOTIFICATION_ENABLED);
                                String ringEnabled = intent.getStringExtra(K9_RING_ENABLED);
                                String vibrateEnabled = intent.getStringExtra(K9_VIBRATE_ENABLED);
                                String pushClasses = intent.getStringExtra(K9_PUSH_CLASSES);
                                String pollClasses = intent.getStringExtra(K9_POLL_CLASSES);
                                String pollFrequency = intent.getStringExtra(K9_POLL_FREQUENCY);

                                if (notificationEnabled != null)
                                {
                                    account.setNotifyNewMail(Boolean.parseBoolean(notificationEnabled));
                                }
                                if (ringEnabled != null)
                                {
                                    account.getNotificationSetting().setRing(Boolean.parseBoolean(ringEnabled));
                                }
                                if (vibrateEnabled != null)
                                {
                                    account.getNotificationSetting().setVibrate(Boolean.parseBoolean(vibrateEnabled));
                                }
                                if (pushClasses != null)
                                {
                                    needsPushRestart |= account.setFolderPushMode(FolderMode.valueOf(pushClasses));
                                }
                                if (pollClasses != null)
                                {
                                    needsReschedule |= account.setFolderSyncMode(FolderMode.valueOf(pollClasses));
                                }
                                if (pollFrequency != null)
                                {
                                    String[] allowedFrequencies = getResources().getStringArray(R.array.account_settings_check_frequency_values);
                                    for (String allowedFrequency : allowedFrequencies)
                                    {
                                        if (allowedFrequency.equals(pollFrequency))
                                        {
                                            Integer newInterval = Integer.parseInt(allowedFrequency);
                                            needsReschedule |= account.setAutomaticCheckIntervalMinutes(newInterval);
                                        }
                                    }
                                }
                                account.save(Preferences.getPreferences(RemoteControlService.this));
                            }
                        }
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""RemoteControlService changing global settings"");

                        String backgroundOps = intent.getStringExtra(K9_BACKGROUND_OPERATIONS);
                        if (K9RemoteControl.K9_BACKGROUND_OPERATIONS_ALWAYS.equals(backgroundOps)
                                || K9RemoteControl.K9_BACKGROUND_OPERATIONS_NEVER.equals(backgroundOps)
                                || K9RemoteControl.K9_BACKGROUND_OPERATIONS_WHEN_CHECKED.equals(backgroundOps)
                                || K9RemoteControl.K9_BACKGROUND_OPERATIONS_WHEN_CHECKED_AUTO_SYNC.equals(backgroundOps))
                        {
                            BACKGROUND_OPS newBackgroundOps = BACKGROUND_OPS.valueOf(backgroundOps);
                            boolean needsReset = K9.setBackgroundOps(newBackgroundOps);
                            needsPushRestart |= needsReset;
                            needsReschedule |= needsReset;
                        }

                        String theme = intent.getStringExtra(K9_THEME);
                        if (theme != null)
                        {
                            K9.setK9Theme(K9RemoteControl.K9_THEME_DARK.equals(theme) ? android.R.style.Theme : android.R.style.Theme_Light);
                        }

                        SharedPreferences sPrefs = preferences.getPreferences();

                        Editor editor = sPrefs.edit();
                        K9.save(editor);
                        editor.commit();

                        if (needsReschedule)
                        {
                            Intent i = new Intent();
                            i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.RemoteControlService"");
                            i.setAction(RESCHEDULE_ACTION);
                            long nextTime = System.currentTimeMillis() + 10000;
                            BootReceiver.scheduleIntent(RemoteControlService.this, nextTime, i);
                        }
                        if (needsPushRestart)
                        {
                            Intent i = new Intent();
                            i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.RemoteControlService"");
                            i.setAction(PUSH_RESTART_ACTION);
                            long nextTime = System.currentTimeMillis() + 10000;
                            BootReceiver.scheduleIntent(RemoteControlService.this, nextTime, i);
                        }
                    }
                    catch (Exception e)
                    {
                        Log.e(K9.LOG_TAG, ""Could not handle K9_SET"", e);
                        Toast toast = Toast.makeText(RemoteControlService.this, e.getMessage(), Toast.LENGTH_LONG);
                        toast.show();
                    }
                }
            }
            , RemoteControlService.REMOTE_CONTROL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
        }
    }

}
",True,221,1,1,8,49,1,8,L4
82,com.fsck.k9.service.SleepService.java,"package com.fsck.k9.service;

import android.content.Context;
import android.content.Intent;
import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class SleepService extends CoreService
{

    private static String ALARM_FIRED = ""com.fsck.k9.service.SleepService.ALARM_FIRED"";
    private static String LATCH_ID = ""com.fsck.k9.service.SleepService.LATCH_ID_EXTRA"";


    private static ConcurrentHashMap<Integer, SleepDatum> sleepData = new ConcurrentHashMap<Integer, SleepDatum>();

    private static AtomicInteger latchId = new AtomicInteger();

    public static void sleep(Context context, long sleepTime, TracingWakeLock wakeLock, long wakeLockTimeout)
    {
        Integer id = latchId.getAndIncrement();
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SleepService Preparing CountDownLatch with id = "" + id + "", thread "" + Thread.currentThread().getName());
        SleepDatum sleepDatum = new SleepDatum();
        CountDownLatch latch = new CountDownLatch(1);
        sleepDatum.latch = latch;
        sleepDatum.reacquireLatch = new CountDownLatch(1);
        sleepData.put(id, sleepDatum);

        Intent i = new Intent();
        i.setClassName(context.getPackageName(), ""com.fsck.k9.service.SleepService"");
        i.putExtra(LATCH_ID, id);
        i.setAction(ALARM_FIRED + ""."" + id);
        long startTime = System.currentTimeMillis();
        long nextTime = startTime + sleepTime;
        BootReceiver.scheduleIntent(context, nextTime, i);
        if (wakeLock != null)
        {
            sleepDatum.wakeLock = wakeLock;
            sleepDatum.timeout = wakeLockTimeout;
            wakeLock.release();
        }
        try
        {
            boolean countedDown = latch.await(sleepTime, TimeUnit.MILLISECONDS);
            if (!countedDown)
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SleepService latch timed out for id = "" + id + "", thread "" + Thread.currentThread().getName());
            }
        }
        catch (InterruptedException ie)
        {
            Log.e(K9.LOG_TAG, ""SleepService Interrupted while awaiting latch"", ie);
        }
        SleepDatum releaseDatum = sleepData.remove(id);
        if (releaseDatum == null)
        {
            try
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SleepService waiting for reacquireLatch for id = "" + id + "", thread "" + Thread.currentThread().getName());
                if (!sleepDatum.reacquireLatch.await(5000, TimeUnit.MILLISECONDS))
                {
                    Log.w(K9.LOG_TAG, ""SleepService reacquireLatch timed out for id = "" + id + "", thread "" + Thread.currentThread().getName());
                }
                else if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SleepService reacquireLatch finished for id = "" + id + "", thread "" + Thread.currentThread().getName());
            }
            catch (InterruptedException ie)
            {
                Log.e(K9.LOG_TAG, ""SleepService Interrupted while awaiting reacquireLatch"", ie);
            }
        }
        else
        {
            reacquireWakeLock(releaseDatum);
        }

        long endTime = System.currentTimeMillis();
        long actualSleep = endTime - startTime;

        if (actualSleep < sleepTime)
        {
            Log.w(K9.LOG_TAG, ""SleepService sleep time too short: requested was "" + sleepTime + "", actual was "" + actualSleep);
        }
        else
        {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""SleepService requested sleep time was "" + sleepTime + "", actual was "" + actualSleep);
        }
    }

    private static void endSleep(Integer id)
    {
        if (id != -1)
        {
            SleepDatum sleepDatum = sleepData.remove(id);
            if (sleepDatum != null)
            {
                CountDownLatch latch = sleepDatum.latch;
                if (latch == null)
                {
                    Log.e(K9.LOG_TAG, ""SleepService No CountDownLatch available with id = "" + id);
                }
                else
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""SleepService Counting down CountDownLatch with id = "" + id);
                    latch.countDown();
                }
                reacquireWakeLock(sleepDatum);
                sleepDatum.reacquireLatch.countDown();
            }
            else
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SleepService Sleep for id "" + id + "" already finished"");
            }
        }
    }

    private static void reacquireWakeLock(SleepDatum sleepDatum)
    {
        TracingWakeLock wakeLock = sleepDatum.wakeLock;
        if (wakeLock != null)
        {
            synchronized (wakeLock)
            {
                long timeout = sleepDatum.timeout;
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""SleepService Acquiring wakeLock for "" + timeout + ""ms"");
                wakeLock.acquire(timeout);
            }
        }
    }

    @Override
    public void startService(Intent intent, int startId)
    {
        if (intent.getAction().startsWith(ALARM_FIRED))
        {
            Integer id = intent.getIntExtra(LATCH_ID, -1);
            endSleep(id);
        }
        stopSelf(startId);
    }

    private static class SleepDatum
    {
        CountDownLatch latch;
        TracingWakeLock wakeLock;
        long timeout;
        CountDownLatch reacquireLatch;
    }

}
",False,216,0,0,9,59,1,4,L1
83,com.fsck.k9.service.MailService.java,"
package com.fsck.k9.service;

import java.util.Collection;
import java.util.Date;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.NetworkInfo.State;
import android.os.IBinder;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.Account.FolderMode;
import com.fsck.k9.controller.MessagingController;
import com.fsck.k9.helper.AutoSyncHelper;
import com.fsck.k9.mail.Pusher;

/**
 */
public class MailService extends CoreService
{
    private static final String ACTION_CHECK_MAIL = ""com.fsck.k9.intent.action.MAIL_SERVICE_WAKEUP"";
    private static final String ACTION_RESET = ""com.fsck.k9.intent.action.MAIL_SERVICE_RESET"";
    private static final String ACTION_RESCHEDULE_POLL = ""com.fsck.k9.intent.action.MAIL_SERVICE_RESCHEDULE_POLL"";
    private static final String ACTION_CANCEL = ""com.fsck.k9.intent.action.MAIL_SERVICE_CANCEL"";
    private static final String ACTION_REFRESH_PUSHERS = ""com.fsck.k9.intent.action.MAIL_SERVICE_REFRESH_PUSHERS"";
    private static final String ACTION_RESTART_PUSHERS = ""com.fsck.k9.intent.action.MAIL_SERVICE_RESTART_PUSHERS"";
    private static final String CONNECTIVITY_CHANGE = ""com.fsck.k9.intent.action.MAIL_SERVICE_CONNECTIVITY_CHANGE"";
    private static final String CANCEL_CONNECTIVITY_NOTICE = ""com.fsck.k9.intent.action.MAIL_SERVICE_CANCEL_CONNECTIVITY_NOTICE"";

    private static long nextCheck = -1;

    public static void actionReset(Context context, Integer wakeLockId)
    {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_RESET);
        addWakeLockId(i, wakeLockId);
        if (wakeLockId == null)
        {
            addWakeLock(context, i);
        }
        context.startService(i);
    }

    public static void actionRestartPushers(Context context, Integer wakeLockId)
    {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_RESTART_PUSHERS);
        addWakeLockId(i, wakeLockId);
        if (wakeLockId == null)
        {
            addWakeLock(context, i);
        }
        context.startService(i);
    }

    public static void actionReschedulePoll(Context context, Integer wakeLockId)
    {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_RESCHEDULE_POLL);
        addWakeLockId(i, wakeLockId);
        if (wakeLockId == null)
        {
            addWakeLock(context, i);
        }
        context.startService(i);
    }

    public static void actionCancel(Context context, Integer wakeLockId)
    {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_CANCEL);
        addWakeLockId(i, wakeLockId);
        context.startService(i);
    }

    public static void connectivityChange(Context context, Integer wakeLockId)
    {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.CONNECTIVITY_CHANGE);
        addWakeLockId(i, wakeLockId);
        context.startService(i);
    }

    @Override
    public void onCreate()
    {
        super.onCreate();
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""***** MailService *****: onCreate"");
    }

    @Override
    public void startService(Intent intent, int startId)
    {
        Integer startIdObj = startId;
        long startTime = System.currentTimeMillis();
        try
        {
            ConnectivityManager connectivityManager = (ConnectivityManager)getApplication().getSystemService(Context.CONNECTIVITY_SERVICE);
            boolean doBackground = true;
            boolean hasConnectivity = false;

            if (connectivityManager != null)
            {
                NetworkInfo netInfo = connectivityManager.getActiveNetworkInfo();
                if (netInfo != null)
                {
                    State state = netInfo.getState();
                    hasConnectivity = state == State.CONNECTED;
                }
                boolean backgroundData = connectivityManager.getBackgroundDataSetting();
                boolean autoSync = true;
                if (AutoSyncHelper.isAvailable())
                {
                    autoSync = AutoSyncHelper.getMasterSyncAutomatically();

                    Log.i(K9.LOG_TAG, ""AutoSync help is available, autoSync = "" + autoSync);
                }

                K9.BACKGROUND_OPS bOps = K9.getBackgroundOps();

                switch (bOps)
                {
                    case NEVER:
                        doBackground = false;
                        break;
                    case ALWAYS:
                        doBackground = true;
                        break;
                    case WHEN_CHECKED:
                        doBackground = backgroundData;
                        break;
                    case WHEN_CHECKED_AUTO_SYNC:
                        doBackground = backgroundData & autoSync;
                        break;
                }

            }

            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""MailService.onStart("" + intent + "", "" + startId
                      + ""), hasConnectivity = "" + hasConnectivity + "", doBackground = "" + doBackground);

            // MessagingController.getInstance(getApplication()).addListener(mListener);
            if (ACTION_CHECK_MAIL.equals(intent.getAction()))
            {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""***** MailService *****: checking mail"");

                if (hasConnectivity && doBackground)
                {
                    PollService.startService(this);
                }
                reschedulePoll(hasConnectivity, doBackground, startIdObj, false);
                startIdObj = null;
            }
            else if (ACTION_CANCEL.equals(intent.getAction()))
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""***** MailService *****: cancel"");

                cancel();
            }
            else if (ACTION_RESET.equals(intent.getAction()))
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""***** MailService *****: reschedule"");

                rescheduleAll(hasConnectivity, doBackground, startIdObj);
                startIdObj = null;

            }
            else if (ACTION_RESTART_PUSHERS.equals(intent.getAction()))
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""***** MailService *****: restarting pushers"");
                reschedulePushers(hasConnectivity, doBackground, startIdObj);
                startIdObj = null;

            }
            else if (ACTION_RESCHEDULE_POLL.equals(intent.getAction()))
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""***** MailService *****: rescheduling poll"");
                reschedulePoll(hasConnectivity, doBackground, startIdObj, true);
                startIdObj = null;

            }
            else if (ACTION_REFRESH_PUSHERS.equals(intent.getAction()))
            {
                if (hasConnectivity && doBackground)
                {
                    refreshPushers(null);
                    schedulePushers(startIdObj);
                    startIdObj = null;
                }
            }
            else if (CONNECTIVITY_CHANGE.equals(intent.getAction()))
            {
                notifyConnectionStatus(hasConnectivity);
                rescheduleAll(hasConnectivity, doBackground, startIdObj);
                startIdObj = null;
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Got connectivity action with hasConnectivity = "" + hasConnectivity + "", doBackground = "" + doBackground);
            }
            else if (CANCEL_CONNECTIVITY_NOTICE.equals(intent.getAction()))
            {
                notifyConnectionStatus(true);
            }
        }
        finally
        {
            if (startIdObj != null)
            {
                stopSelf(startId);
            }
        }
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""MailService.onStart took "" + (System.currentTimeMillis() - startTime) + ""ms"");
    }

    private void rescheduleAll(final boolean hasConnectivity, final boolean doBackground, final Integer startId)
    {
        reschedulePoll(hasConnectivity, doBackground, null, true);
        reschedulePushers(hasConnectivity, doBackground, startId);

    }

    private void notifyConnectionStatus(boolean hasConnectivity)
    {
        if (true) return;
        NotificationManager notifMgr =
            (NotificationManager)getApplication().getSystemService(Context.NOTIFICATION_SERVICE);
        if (!hasConnectivity)
        {
            String notice = getApplication().getString(R.string.no_connection_alert);
            String header = getApplication().getString(R.string.alert_header);


            Notification notif = new Notification(R.drawable.stat_notify_email_generic,
                                                  header, System.currentTimeMillis());

            Intent i = new Intent();
            i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.MailService"");
            i.setAction(MailService.CANCEL_CONNECTIVITY_NOTICE);

            PendingIntent pi = PendingIntent.getService(this, 0, i, 0);

            notif.setLatestEventInfo(getApplication(), header, notice, pi);
            notif.flags = Notification.FLAG_ONGOING_EVENT;

            notifMgr.notify(K9.CONNECTIVITY_ID, notif);
        }
        else
        {
            notifMgr.cancel(K9.CONNECTIVITY_ID);
        }
    }

    @Override
    public void onDestroy()
    {
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""***** MailService *****: onDestroy()"");
        super.onDestroy();
        //     MessagingController.getInstance(getApplication()).removeListener(mListener);
    }

    private void cancel()
    {
        Intent i = new Intent();
        i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.MailService"");
        i.setAction(ACTION_CHECK_MAIL);
        BootReceiver.cancelIntent(this, i);
    }

    private final static String PREVIOUS_INTERVAL = ""MailService.previousInterval"";
    private final static String LAST_CHECK_END = ""MailService.lastCheckEnd"";

    public static void saveLastCheckEnd(Context context)
    {

        long lastCheckEnd = System.currentTimeMillis();
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Saving lastCheckEnd = "" + new Date(lastCheckEnd));
        Preferences prefs = Preferences.getPreferences(context);
        SharedPreferences sPrefs = prefs.getPreferences();
        SharedPreferences.Editor editor = sPrefs.edit();
        editor.putLong(LAST_CHECK_END, lastCheckEnd);
        editor.commit();
    }

    private void reschedulePoll(final boolean hasConnectivity, final boolean doBackground, Integer startId, final boolean considerLastCheckEnd)
    {
        if (hasConnectivity && doBackground)
        {
            execute(getApplication(), new Runnable()
            {
                public void run()
                {
                    int shortestInterval = -1;

                    Preferences prefs = Preferences.getPreferences(MailService.this);
                    SharedPreferences sPrefs = prefs.getPreferences();
                    int previousInterval = sPrefs.getInt(PREVIOUS_INTERVAL, -1);
                    long lastCheckEnd = sPrefs.getLong(LAST_CHECK_END, -1);
                    for (Account account : prefs.getAccounts())
                    {
                        if (account.getAutomaticCheckIntervalMinutes() != -1
                                && account.getFolderSyncMode() != FolderMode.NONE
                                && (account.getAutomaticCheckIntervalMinutes() < shortestInterval || shortestInterval == -1))
                        {
                            shortestInterval = account.getAutomaticCheckIntervalMinutes();
                        }
                    }
                    SharedPreferences.Editor editor = sPrefs.edit();
                    editor.putInt(PREVIOUS_INTERVAL, shortestInterval);
                    editor.commit();

                    if (shortestInterval == -1)
                    {
                        nextCheck = -1;
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""No next check scheduled for package "" + getApplication().getPackageName());
                        cancel();
                    }
                    else
                    {
                        long delay = (shortestInterval * (60 * 1000));
                        long base = (previousInterval == -1 || lastCheckEnd == -1 || !considerLastCheckEnd ? System.currentTimeMillis() : lastCheckEnd);
                        long nextTime = base + delay;
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG,
                                  ""previousInterval = "" + previousInterval
                                  + "", shortestInterval = "" + shortestInterval
                                  + "", lastCheckEnd = "" + new Date(lastCheckEnd)
                                  + "", considerLastCheckEnd = "" + considerLastCheckEnd);
                        nextCheck = nextTime;
                        try
                        {
                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Next check for package "" + getApplication().getPackageName() + "" scheduled for "" + new Date(nextTime));
                        }
                        catch (Exception e)
                        {
                            // I once got a NullPointerException deep in new Date();
                            Log.e(K9.LOG_TAG, ""Exception while logging"", e);
                        }

                        Intent i = new Intent();
                        i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.MailService"");
                        i.setAction(ACTION_CHECK_MAIL);
                        BootReceiver.scheduleIntent(MailService.this, nextTime, i);

                    }
                }
            }
            , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
        }
        else
        {
            nextCheck = -1;
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""No connectivity, canceling check for "" + getApplication().getPackageName());
            cancel();
        }
    }

    private void stopPushers(final Integer startId)
    {
        execute(getApplication(), new Runnable()
        {
            public void run()
            {
                MessagingController.getInstance(getApplication()).stopAllPushing();
                PushService.stopService(MailService.this);
            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
    }

    private void reschedulePushers(final boolean hasConnectivity, final boolean doBackground, final Integer startId)
    {
        execute(getApplication(), new Runnable()
        {
            public void run()
            {

                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Rescheduling pushers"");
                stopPushers(null);
                if (hasConnectivity && doBackground)
                {
                    setupPushers(null);
                    schedulePushers(startId);
                }
                else
                {
                    if (K9.DEBUG)
                    {
                        Log.i(K9.LOG_TAG, ""Not scheduling pushers:  connectivity? ""+hasConnectivity + "" -- doBackground? ""+doBackground);

                    }
                }

            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, null);
    }

    private void setupPushers(final Integer startId)
    {
        execute(getApplication(), new Runnable()
        {
            public void run()
            {
                boolean pushing = false;
                for (Account account : Preferences.getPreferences(MailService.this).getAccounts())
                {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Setting up pushers for account "" + account.getDescription());
                    pushing |= MessagingController.getInstance(getApplication()).setupPushing(account);
                }
                if (pushing)
                {
                    PushService.startService(MailService.this);
                }
            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
    }

    private void refreshPushers(final Integer startId)
    {
        execute(getApplication(), new Runnable()
        {
            public void run()
            {
                try
                {
                    long nowTime = System.currentTimeMillis();
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Refreshing pushers"");
                    Collection<Pusher> pushers = MessagingController.getInstance(getApplication()).getPushers();
                    for (Pusher pusher : pushers)
                    {
                        long lastRefresh = pusher.getLastRefresh();
                        int refreshInterval = pusher.getRefreshInterval();
                        long sinceLast = nowTime - lastRefresh;
                        if (sinceLast + 10000 > refreshInterval)  // Add 10 seconds to keep pushers in sync, avoid drift
                        {
                            if (K9.DEBUG)
                            {
                                Log.d(K9.LOG_TAG, ""PUSHREFRESH: refreshing lastRefresh = "" + lastRefresh + "", interval = "" + refreshInterval
                                      + "", nowTime = "" + nowTime + "", sinceLast = "" + sinceLast);
                            }
                            pusher.refresh();
                            pusher.setLastRefresh(nowTime);
                        }
                        else
                        {
                            if (K9.DEBUG)
                            {
                                Log.d(K9.LOG_TAG, ""PUSHREFRESH: NOT refreshing lastRefresh = "" + lastRefresh + "", interval = "" + refreshInterval
                                      + "", nowTime = "" + nowTime + "", sinceLast = "" + sinceLast);
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Exception while refreshing pushers"", e);
                }
            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
    }

    private void schedulePushers(final Integer startId)
    {
        execute(getApplication(), new Runnable()
        {
            public void run()
            {
                int minInterval = -1;

                Collection<Pusher> pushers = MessagingController.getInstance(getApplication()).getPushers();
                for (Pusher pusher : pushers)
                {
                    int interval = pusher.getRefreshInterval();
                    if (interval > 0 && (interval < minInterval || minInterval == -1))
                    {
                        minInterval = interval;
                    }
                }
                if (K9.DEBUG)
                {
                    Log.v(K9.LOG_TAG, ""Pusher refresh interval = "" + minInterval);
                }
                if (minInterval > 0)
                {
                    long nextTime = System.currentTimeMillis() + minInterval;
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Next pusher refresh scheduled for "" + new Date(nextTime));
                    Intent i = new Intent();
                    i.setClassName(getApplication().getPackageName(), ""com.fsck.k9.service.MailService"");
                    i.setAction(ACTION_REFRESH_PUSHERS);
                    BootReceiver.scheduleIntent(MailService.this, nextTime, i);
                }
            }
        }
        , K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT, startId);
    }


    @Override
    public IBinder onBind(Intent intent)
    {
        return null;
    }

    public static long getNextPollTime()
    {
        return nextCheck;
    }


}
",True,218,2,1,8,56,9,10,L1
84,com.fsck.k9.service.CoreReceiver.java,"
package com.fsck.k9.service;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.PowerManager;
import android.util.Log;

import com.fsck.k9.K9;
import com.fsck.k9.helper.power.TracingPowerManager;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;

public class CoreReceiver extends BroadcastReceiver
{

    public static String WAKE_LOCK_RELEASE = ""com.fsck.k9.service.CoreReceiver.wakeLockRelease"";

    public static String WAKE_LOCK_ID = ""com.fsck.k9.service.CoreReceiver.wakeLockId"";

    private static ConcurrentHashMap<Integer, TracingWakeLock> wakeLocks = new ConcurrentHashMap<Integer, TracingWakeLock>();
    private static AtomicInteger wakeLockSeq = new AtomicInteger(0);

    private static Integer getWakeLock(Context context)
    {
        TracingPowerManager pm = TracingPowerManager.getPowerManager(context);
        TracingWakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""CoreReceiver getWakeLock"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(K9.BOOT_RECEIVER_WAKE_LOCK_TIMEOUT);
        Integer tmpWakeLockId = wakeLockSeq.getAndIncrement();
        wakeLocks.put(tmpWakeLockId, wakeLock);
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""CoreReceiver Created wakeLock "" + tmpWakeLockId);
        return tmpWakeLockId;
    }

    private static void releaseWakeLock(Integer wakeLockId)
    {
        if (wakeLockId != null)
        {
            TracingWakeLock wl = wakeLocks.remove(wakeLockId);
            if (wl != null)
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""CoreReceiver Releasing wakeLock "" + wakeLockId);
                wl.release();
            }
            else
            {
                Log.w(K9.LOG_TAG, ""BootReceiver WakeLock "" + wakeLockId + "" doesn't exist"");
            }
        }
    }

    @Override
    public void onReceive(Context context, Intent intent)
    {
        Integer tmpWakeLockId = CoreReceiver.getWakeLock(context);
        try
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""CoreReceiver.onReceive"" + intent);
            if (CoreReceiver.WAKE_LOCK_RELEASE.equals(intent.getAction()))
            {
                Integer wakeLockId = intent.getIntExtra(WAKE_LOCK_ID, -1);
                if (wakeLockId != -1)
                {
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""CoreReceiver Release wakeLock "" + wakeLockId);
                    CoreReceiver.releaseWakeLock(wakeLockId);
                }
            }
            else
            {
                tmpWakeLockId = receive(context, intent, tmpWakeLockId);
            }
        }
        finally
        {
            CoreReceiver.releaseWakeLock(tmpWakeLockId);
        }
    }

    public Integer receive(Context context, Intent intent, Integer wakeLockId)
    {
        return wakeLockId;
    }

    public static void releaseWakeLock(Context context, int wakeLockId)
    {
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""CoreReceiver Got request to release wakeLock "" + wakeLockId);
        Intent i = new Intent();
        i.setClass(context, CoreReceiver.class);
        i.setAction(WAKE_LOCK_RELEASE);
        i.putExtra(WAKE_LOCK_ID, wakeLockId);
        context.sendBroadcast(i);
    }
}
",True,217,1,1,9,59,3,2,L1
85,com.fsck.k9.service.CoreService.java,"package com.fsck.k9.service;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.os.PowerManager;
import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.helper.power.TracingPowerManager;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;

public abstract class CoreService extends Service
{

    public static String WAKE_LOCK_ID = ""com.fsck.k9.service.CoreService.wakeLockId"";
    private static ConcurrentHashMap<Integer, TracingWakeLock> wakeLocks = new ConcurrentHashMap<Integer, TracingWakeLock>();
    private static AtomicInteger wakeLockSeq = new AtomicInteger(0);
    private ExecutorService threadPool = null;
    private final String className = getClass().getName();

    @Override
    public void onCreate()
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""CoreService: "" + className + "".onCreate()"");
        threadPool = Executors.newFixedThreadPool(1);  // Must be single threaded
        super.onCreate();

    }

    protected static void addWakeLockId(Intent i, Integer wakeLockId)
    {
        if (wakeLockId != null)
        {
            i.putExtra(BootReceiver.WAKE_LOCK_ID, wakeLockId);
        }
    }

    protected static void addWakeLock(Context context, Intent i)
    {
        TracingPowerManager pm = TracingPowerManager.getPowerManager(context);
        TracingWakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""CoreService addWakeLock"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT);

        Integer tmpWakeLockId = wakeLockSeq.getAndIncrement();
        wakeLocks.put(tmpWakeLockId, wakeLock);

        i.putExtra(WAKE_LOCK_ID, tmpWakeLockId);
    }



    @Override
    public void onStart(Intent intent, int startId)
    {
        TracingPowerManager pm = TracingPowerManager.getPowerManager(this);
        TracingWakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""CoreService onStart"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT);

        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""CoreService: "" + className + "".onStart("" + intent + "", "" + startId);

        int wakeLockId = intent.getIntExtra(BootReceiver.WAKE_LOCK_ID, -1);
        if (wakeLockId != -1)
        {
            BootReceiver.releaseWakeLock(this, wakeLockId);
        }
        Integer coreWakeLockId = intent.getIntExtra(WAKE_LOCK_ID, -1);
        if (coreWakeLockId != null && coreWakeLockId != -1)
        {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Got core wake lock id "" + coreWakeLockId);
            TracingWakeLock coreWakeLock = wakeLocks.remove(coreWakeLockId);
            if (coreWakeLock != null)
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Found core wake lock with id "" + coreWakeLockId + "", releasing"");
                coreWakeLock.release();
            }
        }

        try
        {
            super.onStart(intent, startId);
            startService(intent, startId);
        }
        finally
        {
            if (wakeLock != null)
            {
                wakeLock.release();
            }
        }

    }

    public void execute(Context context, final Runnable runner, int wakeLockTime, final Integer startId)
    {

        TracingPowerManager pm = TracingPowerManager.getPowerManager(context);
        final TracingWakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""CoreService execute"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(wakeLockTime);

        Runnable myRunner = new Runnable()
        {
            public void run()
            {
                try
                {

                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""CoreService ("" + className + "") running Runnable "" + runner.hashCode() + "" with startId "" + startId);
                    runner.run();
                }
                finally
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""CoreService ("" + className + "") completed Runnable "" + runner.hashCode() + "" with startId "" + startId);
                    wakeLock.release();
                    if (startId != null)
                    {
                        stopSelf(startId);
                    }
                }
            }

        };
        if (threadPool == null)
        {
            Log.e(K9.LOG_TAG, ""CoreService.execute ("" + className + "") called with no threadPool available; running Runnable "" + runner.hashCode() + "" in calling thread"", new Throwable());
            synchronized (this)
            {
                myRunner.run();
            }
        }
        else
        {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""CoreService ("" + className + "") queueing Runnable "" + runner.hashCode() + "" with startId "" + startId);
            threadPool.execute(myRunner);
        }
    }

    public abstract void startService(Intent intent, int startId);

    @Override
    public IBinder onBind(Intent arg0)
    {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public void onDestroy()
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""CoreService: "" + className + "".onDestroy()"");
        threadPool.shutdown();
        super.onDestroy();
        //     MessagingController.getInstance(getApplication()).removeListener(mListener);
    }
}
",True,218,2,1,9,59,5,3,L1
86,com.fsck.k9.service.BootReceiver.java,"
package com.fsck.k9.service;

import java.util.Date;

import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.net.ConnectivityManager;
import android.net.Uri;
import android.util.Log;

import com.fsck.k9.K9;
import com.fsck.k9.helper.AutoSyncHelper;

public class BootReceiver extends CoreReceiver
{

    public static String FIRE_INTENT = ""com.fsck.k9.service.BroadcastReceiver.fireIntent"";
    public static String SCHEDULE_INTENT = ""com.fsck.k9.service.BroadcastReceiver.scheduleIntent"";
    public static String CANCEL_INTENT = ""com.fsck.k9.service.BroadcastReceiver.cancelIntent"";

    public static String ALARMED_INTENT = ""com.fsck.k9.service.BroadcastReceiver.pendingIntent"";
    public static String AT_TIME = ""com.fsck.k9.service.BroadcastReceiver.atTime"";

    @Override
    public Integer receive(Context context, Intent intent, Integer tmpWakeLockId)
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""BootReceiver.onReceive"" + intent);

        if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction()))
        {
            //K9.setServicesEnabled(context, tmpWakeLockId);
            //tmpWakeLockId = null;
        }
        else if (Intent.ACTION_DEVICE_STORAGE_LOW.equals(intent.getAction()))
        {
            MailService.actionCancel(context, tmpWakeLockId);
            tmpWakeLockId = null;
        }
        else if (Intent.ACTION_DEVICE_STORAGE_OK.equals(intent.getAction()))
        {
            MailService.actionReset(context, tmpWakeLockId);
            tmpWakeLockId = null;
        }
        else if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction()))
        {
            MailService.connectivityChange(context, tmpWakeLockId);
            tmpWakeLockId = null;
        }
        else if (AutoSyncHelper.SYNC_CONN_STATUS_CHANGE.equals(intent.getAction()))
        {
            K9.BACKGROUND_OPS bOps = K9.getBackgroundOps();
            if (bOps == K9.BACKGROUND_OPS.WHEN_CHECKED_AUTO_SYNC)
            {
                MailService.actionReset(context, tmpWakeLockId);
                tmpWakeLockId = null;
            }
        }
        else if (ConnectivityManager.ACTION_BACKGROUND_DATA_SETTING_CHANGED.equals(intent.getAction()))
        {
            K9.BACKGROUND_OPS bOps = K9.getBackgroundOps();
            if (bOps == K9.BACKGROUND_OPS.WHEN_CHECKED || bOps == K9.BACKGROUND_OPS.WHEN_CHECKED_AUTO_SYNC)
            {
                MailService.actionReset(context, tmpWakeLockId);
                tmpWakeLockId = null;
            }
        }
        else if (FIRE_INTENT.equals(intent.getAction()))
        {
            Intent alarmedIntent = intent.getParcelableExtra(ALARMED_INTENT);
            String alarmedAction = alarmedIntent.getAction();
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""BootReceiver Got alarm to fire alarmedIntent "" + alarmedAction);
            alarmedIntent.putExtra(WAKE_LOCK_ID, tmpWakeLockId);
            tmpWakeLockId = null;
            if (alarmedIntent != null)
            {
                context.startService(alarmedIntent);
            }
        }
        else if (SCHEDULE_INTENT.equals(intent.getAction()))
        {
            long atTime = intent.getLongExtra(AT_TIME, -1);
            Intent alarmedIntent = intent.getParcelableExtra(ALARMED_INTENT);
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG,""BootReceiver Scheduling intent "" + alarmedIntent + "" for "" + new Date(atTime));

            PendingIntent pi = buildPendingIntent(context, intent);
            AlarmManager alarmMgr = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);

            alarmMgr.set(AlarmManager.RTC_WAKEUP, atTime, pi);
        }
        else if (CANCEL_INTENT.equals(intent.getAction()))
        {
            Intent alarmedIntent = intent.getParcelableExtra(ALARMED_INTENT);
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""BootReceiver Canceling alarmedIntent "" + alarmedIntent);

            PendingIntent pi = buildPendingIntent(context, intent);

            AlarmManager alarmMgr = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
            alarmMgr.cancel(pi);
        }


        return tmpWakeLockId;
    }

    private PendingIntent buildPendingIntent(Context context, Intent intent)
    {
        Intent alarmedIntent = intent.getParcelableExtra(ALARMED_INTENT);
        String alarmedAction = alarmedIntent.getAction();

        Intent i = new Intent(context, BootReceiver.class);
        i.setAction(FIRE_INTENT);
        i.putExtra(ALARMED_INTENT, alarmedIntent);
        Uri uri = Uri.parse(""action://"" + alarmedAction);
        i.setData(uri);
        PendingIntent pi = PendingIntent.getBroadcast(context, 0, i, 0);
        return pi;
    }

    public static void scheduleIntent(Context context, long atTime, Intent alarmedIntent)
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""BootReceiver Got request to schedule alarmedIntent "" + alarmedIntent.getAction());
        Intent i = new Intent();
        i.setClass(context, BootReceiver.class);
        i.setAction(SCHEDULE_INTENT);
        i.putExtra(ALARMED_INTENT, alarmedIntent);
        i.putExtra(AT_TIME, atTime);
        context.sendBroadcast(i);
    }

    public static void cancelIntent(Context context, Intent alarmedIntent)
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""BootReceiver Got request to cancel alarmedIntent "" + alarmedIntent.getAction());
        Intent i = new Intent();
        i.setClass(context, BootReceiver.class);
        i.setAction(CANCEL_INTENT);
        i.putExtra(ALARMED_INTENT, alarmedIntent);
        context.sendBroadcast(i);
    }

}
",True,218,2,1,9,59,4,4,L1
87,com.fsck.k9.mail.CertificateValidationException.java,"
package com.fsck.k9.mail;

public class CertificateValidationException extends MessagingException
{
    public static final long serialVersionUID = -1;

    public CertificateValidationException(String message)
    {
        super(message);
    }

    public CertificateValidationException(String message, Throwable throwable)
    {
        super(message, throwable);
    }
}",False,93,8,33,1,1,5,1,L1
88,com.fsck.k9.mail.Folder.java,"package com.fsck.k9.mail;

import java.util.Date;

import android.util.Log;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.controller.MessageRetrievalListener;


public abstract class Folder
{
    protected final Account mAccount;

    private String status = null;
    private long lastChecked = 0;
    private long lastPush = 0;
    public enum OpenMode
    {
        READ_WRITE, READ_ONLY,
    }
    // NONE is obsolete, it will be translated to NO_CLASS for display and to INHERITED for sync and push
    public enum FolderClass
    {
        NONE, NO_CLASS, INHERITED, FIRST_CLASS, SECOND_CLASS;
    }

    public enum FolderType
    {
        HOLDS_FOLDERS, HOLDS_MESSAGES,
    }

    protected Folder(Account account)
    {
        mAccount = account;
    }

    /**
     * Forces an open of the MailProvider. If the provider is already open this
     * function returns without doing anything.
     *
     * @param mode READ_ONLY or READ_WRITE
     */
    public abstract void open(OpenMode mode) throws MessagingException;

    /**
     * Forces a close of the MailProvider. Any further access will attempt to
     * reopen the MailProvider.
     */
    public abstract void close();

    /**
     * @return True if further commands are not expected to have to open the
     *         connection.
     */
    public abstract boolean isOpen();

    /**
     * Get the mode the folder was opened with. This may be different than the mode the open
     * was requested with.
     * @return
     */
    public abstract OpenMode getMode() throws MessagingException;

    public abstract boolean create(FolderType type) throws MessagingException;

    /**
     * Create a new folder with a specified display limit.  Not abstract to allow
     * remote folders to not override or worry about this call if they don't care to.
     */
    public boolean create(FolderType type, int displayLimit) throws MessagingException
    {
        return create(type);
    }

    public abstract boolean exists() throws MessagingException;

    /**
     * @return A count of the messages in the selected folder.
     */
    public abstract int getMessageCount() throws MessagingException;

    public abstract int getUnreadMessageCount() throws MessagingException;
    public abstract int getFlaggedMessageCount() throws MessagingException;

    public abstract Message getMessage(String uid) throws MessagingException;

    public abstract Message[] getMessages(int start, int end, Date earliestDate, MessageRetrievalListener listener)
    throws MessagingException;

    /**
     * Fetches the given list of messages. The specified listener is notified as
     * each fetch completes. Messages are downloaded as (as) lightweight (as
     * possible) objects to be filled in with later requests. In most cases this
     * means that only the UID is downloaded.
     *
     * @param uids
     * @param listener
     */
    public abstract Message[] getMessages(MessageRetrievalListener listener)
    throws MessagingException;

    public Message[] getMessages(MessageRetrievalListener listener, boolean includeDeleted) throws MessagingException
    {
        return getMessages(listener);
    }

    public abstract Message[] getMessages(String[] uids, MessageRetrievalListener listener)
    throws MessagingException;

    public abstract void appendMessages(Message[] messages) throws MessagingException;

    public void copyMessages(Message[] msgs, Folder folder) throws MessagingException {} ;

    public void moveMessages(Message[] msgs, Folder folder) throws MessagingException {} ;

    public void delete(Message[] msgs, String trashFolderName) throws MessagingException
    {
        for (Message message : msgs)
        {
            Message myMessage = getMessage(message.getUid());
            myMessage.delete(trashFolderName);
        }
    }

    public abstract void setFlags(Message[] messages, Flag[] flags, boolean value)
    throws MessagingException;

    public abstract void setFlags(Flag[] flags, boolean value) throws MessagingException;

    public abstract String getUidFromMessageId(Message message) throws MessagingException;

    public void expunge() throws MessagingException
        {}

    public abstract void fetch(Message[] messages, FetchProfile fp,
                               MessageRetrievalListener listener) throws MessagingException;

    public void fetchPart(Message message, Part part,
                          MessageRetrievalListener listener) throws MessagingException
    {
        // This is causing trouble. Disabled for now. See issue 1733
        //throw new RuntimeException(""fetchPart() not implemented."");

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""fetchPart() not implemented."");
    }

    public abstract void delete(boolean recurse) throws MessagingException;

    public abstract String getName();

    public abstract Flag[] getPermanentFlags() throws MessagingException;

    /**
     *
     * @param oldPushState
     * @param message
     * @return empty string to clear the pushState, null to leave the state as-is
     */
    public String getNewPushState(String oldPushState, Message message)
    {
        return null;
    }

    public boolean supportsFetchingFlags()
    {
        return true;
    }//isFlagSupported

    @Override
    public String toString()
    {
        return getName();
    }

    public long getLastChecked()
    {
        return lastChecked;
    }

    public void setLastChecked(long lastChecked) throws MessagingException
    {
        this.lastChecked = lastChecked;
    }

    public long getLastPush()
    {
        return lastPush;
    }

    public void setLastPush(long lastCheckedDisplay) throws MessagingException
    {
        this.lastPush = lastCheckedDisplay;
    }

    public long getLastUpdate()
    {
        return Math.max(getLastChecked(), getLastPush());
    }

    public FolderClass getDisplayClass()
    {
        return FolderClass.NO_CLASS;
    }

    public FolderClass getSyncClass()
    {
        return getDisplayClass();
    }
    public FolderClass getPushClass()
    {
        return getSyncClass();
    }

    public void refresh(Preferences preferences) throws MessagingException
    {

    }

    public boolean isInTopGroup()
    {
        return false;
    }

    public String getStatus()
    {
        return status;
    }

    public void setStatus(String status) throws MessagingException
    {
        this.status = status;
    }

    public Account getAccount()
    {
        return mAccount;
    }
}
",False,217,1,1,8,50,19,9,L1
89,com.fsck.k9.mail.FetchProfile.java,"
package com.fsck.k9.mail;

import java.util.ArrayList;

/**
 * <pre>
 * A FetchProfile is a list of items that should be downloaded in bulk for a set of messages.
 * FetchProfile can contain the following objects:
 *      FetchProfile.Item:      Described below.
 *      Message:                Indicates that the body of the entire message should be fetched.
 *                              Synonymous with FetchProfile.Item.BODY.
 *      Part:                   Indicates that the given Part should be fetched. The provider
 *                              is expected have previously created the given BodyPart and stored
 *                              any information it needs to download the content.
 * </pre>
 */
public class FetchProfile extends ArrayList<FetchProfile.Item>
{
    /**
     * Default items available for pre-fetching. It should be expected that any
     * item fetched by using these items could potentially include all of the
     * previous items.
     */
    public enum Item
    {
        /**
         * Download the flags of the message.
         */
        FLAGS,

        /**
         * Download the envelope of the message. This should include at minimum
         * the size and the following headers: date, subject, from, content-type, to, cc
         */
        ENVELOPE,

        /**
         * Download the structure of the message. This maps directly to IMAP's BODYSTRUCTURE
         * and may map to other providers.
         * The provider should, if possible, fill in a properly formatted MIME structure in
         * the message without actually downloading any message data. If the provider is not
         * capable of this operation it should specifically set the body of the message to null
         * so that upper levels can detect that a full body download is needed.
         */
        STRUCTURE,

        /**
         * A sane portion of the entire message, cut off at a provider determined limit.
         * This should generaly be around 50kB.
         */
        BODY_SANE,

        /**
         * The entire message.
         */
        BODY,
    }
}
",False,92,6,52,0,0,6,0,L1
90,com.fsck.k9.mail.PushReceiver.java,"package com.fsck.k9.mail;

import java.util.List;

import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;

import android.content.Context;

public interface PushReceiver
{
    public Context getContext();
    public void syncFolder(Folder folder);
    public void messagesArrived(Folder folder, List<Message> mess);
    public void messagesFlagsChanged(Folder folder, List<Message> mess);
    public void messagesRemoved(Folder folder, List<Message> mess);
    public String getPushState(String folderName);
    public void pushError(String errorMessage, Exception e);
    public void setPushActive(String folderName, boolean enabled);
    public void sleep(TracingWakeLock wakeLock, long millis);
}
",False,216,0,0,9,66,4,3,L1
91,com.fsck.k9.mail.Part.java,"
package com.fsck.k9.mail;

import java.io.IOException;
import java.io.OutputStream;

public interface Part
{
    public void addHeader(String name, String value) throws MessagingException;

    public void removeHeader(String name) throws MessagingException;

    public void setHeader(String name, String value) throws MessagingException;

    public Body getBody() throws MessagingException;

    public String getContentType() throws MessagingException;

    public String getDisposition() throws MessagingException;

    public String getContentId() throws MessagingException;

    public String[] getHeader(String name) throws MessagingException;

    public int getSize() throws MessagingException;

    public boolean isMimeType(String mimeType) throws MessagingException;

    public String getMimeType() throws MessagingException;

    public void setBody(Body body) throws MessagingException;

    public void writeTo(OutputStream out) throws IOException, MessagingException;
}
",False,94,4,39,1,2,16,2,L1
92,com.fsck.k9.mail.Flag.java,"
package com.fsck.k9.mail;

/**
 * Flags that can be applied to Messages.
 */
public enum Flag
{
    DELETED,
    SEEN,
    ANSWERED,
    FLAGGED,
    DRAFT,
    RECENT,

    /*
     * The following flags are for internal library use only.
     */
    /**
     * Delete and remove from the LocalStore immediately.
     */
    X_DESTROYED,

    /**
     * Sending of an unsent message failed. It will be retried. Used to show status.
     */
    X_SEND_FAILED,

    /**
     * Sending of an unsent message is in progress.
     */
    X_SEND_IN_PROGRESS,

    /**
     * Indicates that a message is fully downloaded from the server and can be viewed normally.
     * This does not include attachments, which are never downloaded fully.
     */
    X_DOWNLOADED_FULL,

    /**
     * Indicates that a message is partially downloaded from the server and can be viewed but
     * more content is available on the server.
     * This does not include attachments, which are never downloaded fully.
     */
    X_DOWNLOADED_PARTIAL,

    /**
     * Indicates that the copy of a message to the Sent folder has started.
     */
    X_REMOTE_COPY_STARTED,

    /**
     * Indicates that all headers of the message have been stored in the
     * database. If this is false, additional headers might be retrieved from
     * the server (if the message is still there).
     */
    X_GOT_ALL_HEADERS,
}
",False,94,5,41,0,0,17,0,L1
93,com.fsck.k9.mail.Pusher.java,"package com.fsck.k9.mail;

import java.util.List;


public interface Pusher
{
    public void start(List<String> folderNames);
    public void refresh();
    public void stop();
    /**
     *
     * @return milliseconds of required refresh interval
     */
    public int getRefreshInterval();
    public void setLastRefresh(long lastRefresh);
    public long getLastRefresh();
}
",False,92,6,47,0,0,4,0,L1
94,com.fsck.k9.mail.AuthenticationFailedException.java,"
package com.fsck.k9.mail;

public class AuthenticationFailedException extends MessagingException
{
    public static final long serialVersionUID = -1;

    public AuthenticationFailedException(String message)
    {
        super(message);
    }

    public AuthenticationFailedException(String message, Throwable throwable)
    {
        super(message, throwable);
    }
}
",False,93,8,33,1,1,4,1,L1
95,com.fsck.k9.mail.Message.java,"
package com.fsck.k9.mail;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;
import com.fsck.k9.activity.MessageReference;

public abstract class Message implements Part, Body
{
    private static final Flag[] EMPTY_FLAG_ARRAY = new Flag[0];

    private MessageReference mReference = null;

    public enum RecipientType
    {
        TO, CC, BCC,
    }

    protected String mUid;

    protected HashSet<Flag> mFlags = new HashSet<Flag>();

    protected Date mInternalDate;

    protected Folder mFolder;

    public boolean olderThan(Date earliestDate)
    {
        if (earliestDate == null)
        {
            return false;
        }
        Date myDate = getSentDate();
        if (myDate == null)
        {
            myDate = getInternalDate();
        }
        if (myDate != null)
        {
            return myDate.before(earliestDate);
        }
        return false;
    }
    @Override
    public boolean equals(Object o)
    {
        if (o == null || !(o instanceof Message))
        {
            return false;
        }
        Message other = (Message)o;
        return (mFolder.getName().equals(other.getFolder().getName())
                && mFolder.getAccount().getUuid().equals(other.getFolder().getAccount().getUuid())
                && mUid.equals(other.getUid()));
    }

    @Override
    public int hashCode()
    {
        final int MULTIPLIER = 31;

        int result = 1;
        result = MULTIPLIER * result + mFolder.getName().hashCode();
        result = MULTIPLIER * result + mFolder.getAccount().getUuid().hashCode();
        result = MULTIPLIER * result + mUid.hashCode();
        return result;
    }

    public String getUid()
    {
        return mUid;
    }

    public void setUid(String uid)
    {
        mReference = null;
        this.mUid = uid;
    }

    public Folder getFolder()
    {
        return mFolder;
    }

    public abstract String getSubject() throws MessagingException;

    public abstract void setSubject(String subject) throws MessagingException;

    public Date getInternalDate()
    {
        return mInternalDate;
    }

    public void setInternalDate(Date internalDate)
    {
        this.mInternalDate = internalDate;
    }

    public abstract Date getSentDate();

    public abstract void setSentDate(Date sentDate) throws MessagingException;

    public abstract Address[] getRecipients(RecipientType type) throws MessagingException;

    public abstract void setRecipients(RecipientType type, Address[] addresses)
    throws MessagingException;

    public void setRecipient(RecipientType type, Address address) throws MessagingException
    {
        setRecipients(type, new Address[]
                      {
                          address
                      });
    }

    public abstract Address[] getFrom() throws MessagingException;

    public abstract void setFrom(Address from) throws MessagingException;

    public abstract Address[] getReplyTo() throws MessagingException;

    public abstract void setReplyTo(Address[] from) throws MessagingException;

    public abstract String getMessageId() throws MessagingException;

    public abstract void setInReplyTo(String inReplyTo) throws MessagingException;

    public abstract String[] getReferences() throws MessagingException;

    public abstract void setReferences(String references) throws MessagingException;

    public abstract Body getBody() throws MessagingException;

    public abstract String getContentType() throws MessagingException;

    public abstract void addHeader(String name, String value) throws MessagingException;

    public abstract void setHeader(String name, String value) throws MessagingException;

    public abstract String[] getHeader(String name) throws MessagingException;

    public abstract Set<String> getHeaderNames();

    public abstract void removeHeader(String name) throws MessagingException;

    public abstract void setBody(Body body) throws MessagingException;

    public boolean isMimeType(String mimeType) throws MessagingException
    {
        return getContentType().startsWith(mimeType);
    }

    public void delete(String trashFolderName) throws MessagingException {} ;

    /*
     * TODO Refactor Flags at some point to be able to store user defined flags.
     */
    public Flag[] getFlags()
    {
        return mFlags.toArray(EMPTY_FLAG_ARRAY);
    }

    /**
     * @param flag
     *            Flag to set. Never <code>null</code>.
     * @param set
     *            If <code>true</code>, the flag is added. If <code>false</code>
     *            , the flag is removed.
     * @throws MessagingException
     */
    public void setFlag(Flag flag, boolean set) throws MessagingException
    {
        if (set)
        {
            mFlags.add(flag);
        }
        else
        {
            mFlags.remove(flag);
        }
    }

    /**
     * This method calls setFlag(Flag, boolean)
     * @param flags
     * @param set
     */
    public void setFlags(Flag[] flags, boolean set) throws MessagingException
    {
        for (Flag flag : flags)
        {
            setFlag(flag, set);
        }
    }

    public boolean isSet(Flag flag)
    {
        return mFlags.contains(flag);
    }

    public abstract void saveChanges() throws MessagingException;

    public abstract void setEncoding(String encoding);

    public MessageReference makeMessageReference()
    {
        if (mReference == null)
        {
            mReference = new MessageReference();
            mReference.accountUuid = getFolder().getAccount().getUuid();
            mReference.folderName = getFolder().getName();
            mReference.uid = mUid;
        }
        return mReference;
    }

    public boolean equalsReference(MessageReference ref)
    {
        MessageReference tmpReference = makeMessageReference();
        return tmpReference.equals(ref);
    }
}
",False,218,1,2,8,65,30,8,L1
96,com.fsck.k9.mail.Body.java,"
package com.fsck.k9.mail;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public interface Body
{
    public InputStream getInputStream() throws MessagingException;
    public void writeTo(OutputStream out) throws IOException, MessagingException;
}
",False,96,4,45,1,1,11,1,L1
97,com.fsck.k9.mail.Transport.java,"
package com.fsck.k9.mail;

import com.fsck.k9.Account;
import com.fsck.k9.mail.transport.SmtpTransport;
import com.fsck.k9.mail.transport.WebDavTransport;

public abstract class Transport
{
    protected static final int SOCKET_CONNECT_TIMEOUT = 10000;

    // RFC 1047
    protected static final int SOCKET_READ_TIMEOUT = 300000;

    public synchronized static Transport getInstance(Account account) throws MessagingException
    {
        String uri = account.getTransportUri();
        if (uri.startsWith(""smtp""))
        {
            return new SmtpTransport(uri);
        }
        else if (uri.startsWith(""webdav""))
        {
            return new WebDavTransport(account);
        }
        else
        {
            throw new MessagingException(""Unable to locate an applicable Transport for "" + uri);
        }
    }

    public abstract void open() throws MessagingException;

    public abstract void sendMessage(Message message) throws MessagingException;

    public abstract void close() throws MessagingException;
}
",False,216,0,0,8,51,4,5,L1
98,com.fsck.k9.mail.BodyPart.java,"
package com.fsck.k9.mail;

public abstract class BodyPart implements Part
{
    protected Multipart mParent;

    public Multipart getParent()
    {
        return mParent;
    }
}
",False,216,0,0,12,57,5,2,L1
99,com.fsck.k9.mail.Store.java,"
package com.fsck.k9.mail;

import android.app.Application;

import com.fsck.k9.Account;
import com.fsck.k9.mail.store.ImapStore;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.Pop3Store;
import com.fsck.k9.mail.store.WebDavStore;

import java.util.HashMap;
import java.util.List;

/**
 * Store is the access point for an email message store. It's location can be
 * local or remote and no specific protocol is defined. Store is intended to
 * loosely model in combination the JavaMail classes javax.mail.Store and
 * javax.mail.Folder along with some additional functionality to improve
 * performance on mobile devices. Implementations of this class should focus on
 * making as few network connections as possible.
 */
public abstract class Store
{
    protected static final int SOCKET_CONNECT_TIMEOUT = 30000;
    protected static final int SOCKET_READ_TIMEOUT = 60000;

    private static HashMap<String, Store> mStores = new HashMap<String, Store>();

    protected final Account mAccount;

    protected Store(Account account)
    {
        mAccount = account;
    }

    /**
     * Get an instance of a remote mail store.
     */
    public synchronized static Store getRemoteInstance(Account account) throws MessagingException
    {
        String uri = account.getStoreUri();

        if (uri.startsWith(""local""))
        {
            throw new RuntimeException(""Asked to get non-local Store object but given LocalStore URI"");
        }

        Store store = mStores.get(uri);
        if (store == null)
        {
            if (uri.startsWith(""imap""))
            {
                store = new ImapStore(account);
            }
            else if (uri.startsWith(""pop3""))
            {
                store = new Pop3Store(account);
            }
            else if (uri.startsWith(""webdav""))
            {
                store = new WebDavStore(account);
            }

            if (store != null)
            {
                mStores.put(uri, store);
            }
        }

        if (store == null)
        {
            throw new MessagingException(""Unable to locate an applicable Store for "" + uri);
        }

        return store;
    }

    /**
     * Get an instance of a local mail store.
     */
    public synchronized static LocalStore getLocalInstance(Account account, Application application) throws MessagingException
    {
        String uri = account.getLocalStoreUri();

        if (!uri.startsWith(""local""))
        {
            throw new RuntimeException(""LocalStore URI doesn't start with 'local'"");
        }

        Store store = mStores.get(uri);
        if (store == null)
        {
            store = new LocalStore(account, application);

            if (store != null)
            {
                mStores.put(uri, store);
            }
        }

        if (store == null)
        {
            throw new MessagingException(""Unable to locate an applicable Store for "" + uri);
        }

        return (LocalStore)store;
    }

    public abstract Folder getFolder(String name) throws MessagingException;

    public abstract List<? extends Folder> getPersonalNamespaces(boolean forceListAll) throws MessagingException;

    public abstract void checkSettings() throws MessagingException;

    public boolean isCopyCapable()
    {
        return false;
    }
    public boolean isMoveCapable()
    {
        return false;
    }
    public boolean isPushCapable()
    {
        return false;
    }
    public boolean isSendCapable()
    {
        return false;
    }
    public boolean isExpungeCapable()
    {
        return false;
    }


    public void sendMessages(Message[] messages) throws MessagingException
    {
    }

    public Pusher getPusher(PushReceiver receiver)
    {
        return null;
    }

    public Account getAccount()
    {
        return mAccount;
    }
}
",False,217,1,1,7,55,11,10,L1
100,com.fsck.k9.mail.Address.java,"
package com.fsck.k9.mail;

import android.database.Cursor;
import android.graphics.Color;
import android.text.Html;
import android.text.Spannable;
import android.text.SpannableString;
import android.text.SpannableStringBuilder;
import android.text.style.ForegroundColorSpan;
import android.text.util.Rfc822Token;
import android.text.util.Rfc822Tokenizer;
import android.util.Log;

import com.fsck.k9.K9;
import com.fsck.k9.helper.Contacts;
import com.fsck.k9.helper.Utility;
import org.apache.james.mime4j.codec.EncoderUtil;
import org.apache.james.mime4j.field.address.AddressList;
import org.apache.james.mime4j.field.address.Mailbox;
import org.apache.james.mime4j.field.address.MailboxList;
import org.apache.james.mime4j.field.address.NamedMailbox;
import org.apache.james.mime4j.field.address.parser.ParseException;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class Address
{

    /**
     * Immutable empty {@link Address} array
     */
    private static final Address[] EMPTY_ADDRESS_ARRAY = new Address[0];
    private static Map<String,String> sContactsName = new ConcurrentHashMap<String, String>();

    public static void clearContactsNameCache() {
        sContactsName.clear();
    }

    private static final String NO_ENTRY = """";

    String mAddress;

    String mPersonal;

    public Address(String address, String personal)
    {
        this.mAddress = address;
        if ("""".equals(personal))
        {
            personal = null;
        }
        if (personal!=null)
        {
            personal = personal.trim();
        }
        this.mPersonal = personal;
    }

    public Address(String address)
    {
        this.mAddress = address;
    }

    public String getAddress()
    {
        return mAddress;
    }

    public void setAddress(String address)
    {
        this.mAddress = address;
    }

    public String getPersonal()
    {
        return mPersonal;
    }

    public void setPersonal(String personal)
    {
        if ("""".equals(personal))
        {
            personal = null;
        }
        if (personal!=null)
        {
            personal = personal.trim();
        }
        this.mPersonal = personal;
    }

    /**
     * Parse a comma separated list of email addresses in human readable format and return an
     * array of Address objects, RFC-822 encoded.
     *
     * @param addressList
     * @return An array of 0 or more Addresses.
     */
    public static Address[] parseUnencoded(String addressList)
    {
        List<Address> addresses = new ArrayList<Address>();
        if (addressList!=null
                && !"""".equals(addressList))
        {
            Rfc822Token[] tokens =  Rfc822Tokenizer.tokenize(addressList);
            for (Rfc822Token token : tokens)
            {
                String address = token.getAddress();
                if (address!=null
                        && !"""".equals(address))
                {
                    addresses.add(new Address(token.getAddress(), token.getName()));
                }
            }
        }
        return addresses.toArray(EMPTY_ADDRESS_ARRAY);
    }

    /**
     * Parse a comma separated list of addresses in RFC-822 format and return an
     * array of Address objects.
     *
     * @param addressList
     * @return An array of 0 or more Addresses.
     */
    public static Address[] parse(String addressList)
    {
        ArrayList<Address> addresses = new ArrayList<Address>();
        if (addressList == null
                && !"""".equals(addressList))
        {
            return EMPTY_ADDRESS_ARRAY;
        }
        try
        {
            MailboxList parsedList = AddressList.parse(addressList).flatten();
            for (int i = 0, count = parsedList.size(); i < count; i++)
            {
                org.apache.james.mime4j.field.address.Address address = parsedList.get(i);
                if (address instanceof NamedMailbox)
                {
                    NamedMailbox namedMailbox = (NamedMailbox)address;
                    addresses.add(new Address(namedMailbox.getLocalPart() + ""@""
                                              + namedMailbox.getDomain(), namedMailbox.getName()));
                }
                else if (address instanceof Mailbox)
                {
                    Mailbox mailbox = (Mailbox)address;
                    addresses.add(new Address(mailbox.getLocalPart() + ""@"" + mailbox.getDomain()));
                }
                else
                {
                    Log.e(K9.LOG_TAG, ""Unknown address type from Mime4J: ""
                          + address.getClass().toString());
                }

            }
        }
        catch (ParseException pe)
        {
        }
        return addresses.toArray(EMPTY_ADDRESS_ARRAY);
    }

    @Override
    public boolean equals(Object o)
    {
        if (o instanceof Address)
        {
            return getAddress().equals(((Address) o).getAddress());
        }
        return super.equals(o);
    }

    @Override
    public int hashCode()
    {
        return getAddress().hashCode();
    }

    @Override
    public String toString()
    {
        if (mPersonal != null)
        {
            return Utility.quoteString(mPersonal) + "" <"" + mAddress + "">"";
        }
        else
        {
            return mAddress;
        }
    }

    public static String toString(Address[] addresses)
    {
        if (addresses == null)
        {
            return null;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < addresses.length; i++)
        {
            sb.append(addresses[i].toString());
            if (i < addresses.length - 1)
            {
                sb.append(',');
            }
        }
        return sb.toString();
    }

    public String toEncodedString()
    {
        if (mPersonal != null)
        {
            return EncoderUtil.encodeAddressDisplayName(mPersonal) + "" <"" + mAddress + "">"";
        }
        else
        {
            return mAddress;
        }
    }

    public static String toEncodedString(Address[] addresses)
    {
        if (addresses == null)
        {
            return null;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < addresses.length; i++)
        {
            sb.append(addresses[i].toEncodedString());
            if (i < addresses.length - 1)
            {
                sb.append(',');
            }
        }
        return sb.toString();
    }

    /**
     * Returns either the personal portion of the Address or the address portion if the personal
     * is not available.
     * @return
     */
    public CharSequence toFriendly()
    {
        return toFriendly((Contacts)null);
    }

    public CharSequence toFriendly(Contacts contacts)
    {
        if (contacts != null)
        {
            String name = sContactsName.get(mAddress);

            if (name != null && name != NO_ENTRY)
            {
                if (K9.changeRegisteredNameColor()) {
                    SpannableString sname = new SpannableString(name);
                    sname.setSpan(new ForegroundColorSpan(K9.getRegisteredNameColor()),
                                  0,
                                  sname.length(),
                                  Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                                  );
                    return sname;
                }
                else {
                    return name;
                }
            }
            if (name == null)
            {
                Cursor cursor = contacts.searchByAddress(mAddress);
                if (cursor != null)
                {
                    try
                    {
                        if (cursor.getCount() > 0)
                        {
                            cursor.moveToFirst();
                            name = contacts.getName(cursor); // name might return null
                            if (name != null) {
                                sContactsName.put(mAddress, name);

                                if (K9.changeRegisteredNameColor()) {
                                    SpannableString sname = new SpannableString(name);
                                    sname.setSpan(new ForegroundColorSpan(K9.getRegisteredNameColor()),
                                                  0,
                                                  sname.length(),
                                                  Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                                                  );
                                    return sname;
                                }
                                else {
                                    return name;
                                }
                            }
                        }
                        else
                        {
                            sContactsName.put(mAddress, NO_ENTRY);
                        }
                    }
                    finally
                    {
                        // cursor.close(); // TODO: should close cursor.
                    }
                }
            }
        }

        if (mPersonal != null && mPersonal.length() > 0)
        {
            return mPersonal;
        }
        else
        {
            return mAddress;
        }
    }

    public static CharSequence toFriendly(Address[] addresses)
    {
        return toFriendly(addresses, null);
    }

    public static CharSequence toFriendly(Address[] addresses, Contacts contacts)
    {
        if (addresses == null)
        {
            return null;
        }
        SpannableStringBuilder sb = new SpannableStringBuilder();
        for (int i = 0; i < addresses.length; i++)
        {
            sb.append(addresses[i].toFriendly(contacts));
            if (i < addresses.length - 1)
            {
                sb.append(',');
            }
        }
        return sb;
    }

    /**
     * Unpacks an address list previously packed with packAddressList()
     * @param list
     * @return
     */
    public static Address[] unpack(String addressList)
    {
        if (addressList == null)
        {
            return new Address[] { };
        }
        ArrayList<Address> addresses = new ArrayList<Address>();
        int length = addressList.length();
        int pairStartIndex = 0;
        int pairEndIndex = 0;
        int addressEndIndex = 0;
        while (pairStartIndex < length)
        {
            pairEndIndex = addressList.indexOf("",\u0000"", pairStartIndex);
            if (pairEndIndex == -1)
            {
                pairEndIndex = length;
            }
            addressEndIndex = addressList.indexOf("";\u0000"", pairStartIndex);
            String address = null;
            String personal = null;
            if (addressEndIndex == -1 || addressEndIndex > pairEndIndex)
            {
                address = addressList.substring(pairStartIndex, pairEndIndex);
            }
            else
            {
                address = addressList.substring(pairStartIndex, addressEndIndex);
                personal =addressList.substring(addressEndIndex + 2, pairEndIndex);
            }
            addresses.add(new Address(address, personal));
            pairStartIndex = pairEndIndex + 2;
        }
        return addresses.toArray(new Address[addresses.size()]);
    }

    /**
     * Packs an address list into a String that is very quick to read
     * and parse. Packed lists can be unpacked with unpackAddressList()
     * The packed list is a ""\u0000,"" seperated list of:
     * address\u0000;personal
     * @param list
     * @return
     */
    public static String pack(Address[] addresses)
    {
        if (addresses == null)
        {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0, count = addresses.length; i < count; i++)
        {
            Address address = addresses[i];
            sb.append(address.getAddress());
            String personal = address.getPersonal();
            if (personal != null)
            {
                sb.append("";\u0000"");
                // Escape quotes in the address part on the way in
                personal.replaceAll(""\"""",""\\\"""");
                sb.append(personal);
            }
            if (i < count - 1)
            {
                sb.append("",\u0000"");
            }
        }
        return sb.toString();
    }
}
",True,218,1,2,9,67,15,10,L1
101,com.fsck.k9.mail.MessagingException.java,"
package com.fsck.k9.mail;

public class MessagingException extends Exception
{
    public static final long serialVersionUID = -1;

    boolean permanentFailure = false;

    public MessagingException(String message)
    {
        super(message);
    }

    public MessagingException(String message, boolean perm)
    {
        super(message);
        permanentFailure = perm;
    }

    public MessagingException(String message, Throwable throwable)
    {
        super(message, throwable);
    }

    public MessagingException(String message, boolean perm, Throwable throwable)
    {
        super(message, throwable);
        permanentFailure = perm;
    }

    public boolean isPermanentFailure()
    {
        return permanentFailure;
    }

    public void setPermanentFailure(boolean permanentFailure)
    {
        this.permanentFailure = permanentFailure;
    }


}
",True,98,3,55,0,0,35,0,L1
102,com.fsck.k9.mail.Multipart.java,"
package com.fsck.k9.mail;

import java.util.ArrayList;

import com.fsck.k9.mail.internet.MimeHeader;
import com.fsck.k9.mail.internet.TextBody;

public abstract class Multipart implements Body
{
    protected Part mParent;

    protected ArrayList<BodyPart> mParts = new ArrayList<BodyPart>();

    protected String mContentType;

    public void addBodyPart(BodyPart part) throws MessagingException
    {
        mParts.add(part);
    }

    public void addBodyPart(BodyPart part, int index) throws MessagingException
    {
        mParts.add(index, part);
    }

    public BodyPart getBodyPart(int index) throws MessagingException
    {
        return mParts.get(index);
    }

    public String getContentType() throws MessagingException
    {
        return mContentType;
    }

    public int getCount() throws MessagingException
    {
        return mParts.size();
    }

    public boolean removeBodyPart(BodyPart part) throws MessagingException
    {
        return mParts.remove(part);
    }

    public void removeBodyPart(int index) throws MessagingException
    {
        mParts.remove(index);
    }

    public Part getParent() throws MessagingException
    {
        return mParent;
    }

    public void setParent(Part parent) throws MessagingException
    {
        this.mParent = parent;
    }

    public void setEncoding(String encoding)
    {
        for (BodyPart part : mParts)
        {
            try
            {
                Body body = part.getBody();
                if (body instanceof TextBody)
                {
                    part.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, encoding);
                    ((TextBody)body).setEncoding(encoding);
                }
            }
            catch (MessagingException e)
            {
                // Ignore
            }
        }

    }
}
",True,216,0,0,11,57,9,6,L1
103,com.fsck.k9.mail.transport.WebDavTransport.java,"
package com.fsck.k9.mail.transport;

import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Transport;
import com.fsck.k9.mail.filter.PeekableInputStream;
import com.fsck.k9.mail.store.WebDavStore;

import java.io.OutputStream;
import java.net.Socket;

public class WebDavTransport extends Transport
{
    public static final int CONNECTION_SECURITY_NONE = 0;
    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

    String host;
    int mPort;

    boolean mSecure;
    Socket mSocket;
    PeekableInputStream mIn;
    OutputStream mOut;
    private WebDavStore store;

    /**
     * webdav://user:password@server:port CONNECTION_SECURITY_NONE
     * webdav+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * webdav+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * webdav+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * webdav+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     *
     * @param _uri
     */
    public WebDavTransport(Account account) throws MessagingException
    {
        store = new WebDavStore(account);
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, "">>> New WebDavTransport creation complete"");
    }

    @Override
    public void open() throws MessagingException
    {
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, "">>> open called on WebDavTransport "");

        store.getHttpClient();
    }

    @Override
    public void close()
    {
    }

    @Override
    public void sendMessage(Message message) throws MessagingException
    {

        store.sendMessages(new Message[] { message });


    }

}
",False,216,0,0,8,55,1,7,L1
104,com.fsck.k9.mail.transport.TrustedSocketFactory.java,"package com.fsck.k9.mail.transport;

import com.fsck.k9.mail.store.TrustManagerFactory;
import org.apache.http.conn.ConnectTimeoutException;
import org.apache.http.conn.scheme.LayeredSocketFactory;
import org.apache.http.params.HttpParams;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

public class TrustedSocketFactory implements LayeredSocketFactory
{
    private SSLSocketFactory mSocketFactory;
    private org.apache.http.conn.ssl.SSLSocketFactory mSchemeSocketFactory;

    public TrustedSocketFactory(String host, boolean secure) throws NoSuchAlgorithmException, KeyManagementException
    {
        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, new TrustManager[]
                        {
                            TrustManagerFactory.get(host, secure)
                        }, new SecureRandom());
        mSocketFactory = sslContext.getSocketFactory();
        mSchemeSocketFactory = org.apache.http.conn.ssl.SSLSocketFactory.getSocketFactory();
        mSchemeSocketFactory.setHostnameVerifier(
            org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
    }

    public Socket connectSocket(Socket sock, String host, int port,
                                InetAddress localAddress, int localPort, HttpParams params)
    throws IOException, UnknownHostException, ConnectTimeoutException
    {
        return mSchemeSocketFactory.connectSocket(sock, host, port, localAddress, localPort, params);
    }

    public Socket createSocket() throws IOException
    {
        return mSocketFactory.createSocket();
    }

    public boolean isSecure(Socket sock) throws IllegalArgumentException
    {
        return mSchemeSocketFactory.isSecure(sock);
    }
    public Socket createSocket(
        final Socket socket,
        final String host,
        final int port,
        final boolean autoClose
    ) throws IOException, UnknownHostException
    {
        SSLSocket sslSocket = (SSLSocket) mSocketFactory.createSocket(
                                  socket,
                                  host,
                                  port,
                                  autoClose
                              );
        //hostnameVerifier.verify(host, sslSocket);
        // verifyHostName() didn't blowup - good!
        return sslSocket;
    }
}
",False,216,0,0,10,57,1,1,L1
105,com.fsck.k9.mail.transport.SmtpTransport.java,"
package com.fsck.k9.mail.transport;

import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.filter.Base64;
import com.fsck.k9.mail.filter.EOLConvertingOutputStream;
import com.fsck.k9.mail.filter.LineWrapOutputStream;
import com.fsck.k9.mail.filter.PeekableInputStream;
import com.fsck.k9.mail.filter.SmtpDataStuffing;
import com.fsck.k9.mail.store.TrustManagerFactory;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.TrustManager;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.*;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import org.apache.commons.codec.binary.Hex;
import java.util.ArrayList;
import java.util.List;

public class SmtpTransport extends Transport
{
    public static final int CONNECTION_SECURITY_NONE = 0;

    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;

    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;

    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;

    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

    String mHost;

    int mPort;

    String mUsername;

    String mPassword;

    String mAuthType;

    int mConnectionSecurity;

    boolean mSecure;

    Socket mSocket;

    PeekableInputStream mIn;

    OutputStream mOut;
    private boolean m8bitEncodingAllowed;

    /**
     * smtp://user:password@server:port CONNECTION_SECURITY_NONE
     * smtp+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * smtp+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * smtp+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * smtp+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     *
     * @param _uri
     */
    public SmtpTransport(String _uri) throws MessagingException
    {
        URI uri;
        try
        {
            uri = new URI(_uri);
        }
        catch (URISyntaxException use)
        {
            throw new MessagingException(""Invalid SmtpTransport URI"", use);
        }

        String scheme = uri.getScheme();
        if (scheme.equals(""smtp""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_NONE;
            mPort = 25;
        }
        else if (scheme.equals(""smtp+tls""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
            mPort = 25;
        }
        else if (scheme.equals(""smtp+tls+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
            mPort = 25;
        }
        else if (scheme.equals(""smtp+ssl+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
            mPort = 465;
        }
        else if (scheme.equals(""smtp+ssl""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
            mPort = 465;
        }
        else
        {
            throw new MessagingException(""Unsupported protocol"");
        }

        mHost = uri.getHost();

        if (uri.getPort() != -1)
        {
            mPort = uri.getPort();
        }

        if (uri.getUserInfo() != null)
        {
            try
            {
                String[] userInfoParts = uri.getUserInfo().split("":"");
                mUsername = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                if (userInfoParts.length > 1)
                {
                    mPassword = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
                if (userInfoParts.length > 2)
                {
                    mAuthType = userInfoParts[2];
                }
            }
            catch (UnsupportedEncodingException enc)
            {
                // This shouldn't happen since the encoding is hardcoded to UTF-8
                Log.e(K9.LOG_TAG, ""Couldn't urldecode username or password."", enc);
            }
        }
    }

    @Override
    public void open() throws MessagingException
    {
        try
        {
            SocketAddress socketAddress = new InetSocketAddress(mHost, mPort);
            if (mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
                    mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL)
            {
                SSLContext sslContext = SSLContext.getInstance(""TLS"");
                boolean secure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
                sslContext.init(null, new TrustManager[]
                                {
                                    TrustManagerFactory.get(mHost, secure)
                                }, new SecureRandom());
                mSocket = sslContext.getSocketFactory().createSocket();
                mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                mSecure = true;
            }
            else
            {
                mSocket = new Socket();
                mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
            }

            // RFC 1047
            mSocket.setSoTimeout(SOCKET_READ_TIMEOUT);

            mIn = new PeekableInputStream(new BufferedInputStream(mSocket.getInputStream(), 1024));
            mOut = mSocket.getOutputStream();

            // Eat the banner
            executeSimpleCommand(null);

            InetAddress localAddress = mSocket.getLocalAddress();
            String localHost = localAddress.getHostName();
            String ipAddr = localAddress.getHostAddress();

            if (localHost.equals(ipAddr) || localHost.contains(""_""))
            {
                // We don't have a FQDN or the hostname contains invalid
                // characters (see issue 2143), so use IP address.
                if (localAddress instanceof Inet6Address)
                {
                    localHost = ""[IPV6:"" + ipAddr + ""]"";
                }
                else
                {
                    localHost = ""["" + ipAddr + ""]"";
                }
            }

            List<String> results = executeSimpleCommand(""EHLO "" + localHost);

            m8bitEncodingAllowed = results.contains(""8BITMIME"");

            /*
             * TODO may need to add code to fall back to HELO I switched it from
             * using HELO on non STARTTLS connections because of AOL's mail
             * server. It won't let you use AUTH without EHLO.
             * We should really be paying more attention to the capabilities
             * and only attempting auth if it's available, and warning the user
             * if not.
             */
            if (mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL
                    || mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED)
            {
                if (results.contains(""STARTTLS""))
                {
                    executeSimpleCommand(""STARTTLS"");

                    SSLContext sslContext = SSLContext.getInstance(""TLS"");
                    boolean secure = mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED;
                    sslContext.init(null, new TrustManager[]
                                    {
                                        TrustManagerFactory.get(mHost, secure)
                                    }, new SecureRandom());
                    mSocket = sslContext.getSocketFactory().createSocket(mSocket, mHost, mPort,
                              true);
                    mIn = new PeekableInputStream(new BufferedInputStream(mSocket.getInputStream(),
                                                  1024));
                    mOut = mSocket.getOutputStream();
                    mSecure = true;
                    /*
                     * Now resend the EHLO. Required by RFC2487 Sec. 5.2, and more specifically,
                     * Exim.
                     */
                    results = executeSimpleCommand(""EHLO "" + localHost);
                }
                else if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED)
                {
                    throw new MessagingException(""TLS not supported but required"");
                }
            }

            /*
             * result contains the results of the EHLO in concatenated form
             */
            boolean authLoginSupported = false;
            boolean authPlainSupported = false;
            boolean authCramMD5Supported = false;
            for (String result : results)
            {
                if (result.matches("".*AUTH.*LOGIN.*$""))
                {
                    authLoginSupported = true;
                }
                if (result.matches("".*AUTH.*PLAIN.*$""))
                {
                    authPlainSupported = true;
                }
                if (result.matches("".*AUTH.*CRAM-MD5.*$"") && mAuthType != null && mAuthType.equals(""CRAM_MD5""))
                {
                    authCramMD5Supported = true;
                }
            }

            if (mUsername != null && mUsername.length() > 0 && mPassword != null
                    && mPassword.length() > 0)
            {
                if (authCramMD5Supported)
                {
                    saslAuthCramMD5(mUsername, mPassword);
                }
                else if (authPlainSupported)
                {
                    saslAuthPlain(mUsername, mPassword);
                }
                else if (authLoginSupported)
                {
                    saslAuthLogin(mUsername, mPassword);
                }
                else
                {
                    throw new MessagingException(""No valid authentication mechanism found."");
                }
            }
        }
        catch (SSLException e)
        {
            throw new CertificateValidationException(e.getMessage(), e);
        }
        catch (GeneralSecurityException gse)
        {
            throw new MessagingException(
                ""Unable to open connection to SMTP server due to security error."", gse);
        }
        catch (IOException ioe)
        {
            throw new MessagingException(""Unable to open connection to SMTP server."", ioe);
        }
    }

    @Override
    public void sendMessage(Message message) throws MessagingException
    {
        close();
        open();

        if (m8bitEncodingAllowed)
        {
            message.setEncoding(""8bit"");
        }

        Address[] from = message.getFrom();
        boolean possibleSend = false;
        try
        {
            //TODO: Add BODY=8BITMIME parameter if appropriate?
            executeSimpleCommand(""MAIL FROM: "" + ""<"" + from[0].getAddress() + "">"");
            for (Address address : message.getRecipients(RecipientType.TO))
            {
                executeSimpleCommand(""RCPT TO: "" + ""<"" + address.getAddress() + "">"");
            }
            for (Address address : message.getRecipients(RecipientType.CC))
            {
                executeSimpleCommand(""RCPT TO: "" + ""<"" + address.getAddress() + "">"");
            }
            for (Address address : message.getRecipients(RecipientType.BCC))
            {
                executeSimpleCommand(""RCPT TO: "" + ""<"" + address.getAddress() + "">"");
            }
            message.setRecipients(RecipientType.BCC, null);
            executeSimpleCommand(""DATA"");

            EOLConvertingOutputStream msgOut = new EOLConvertingOutputStream(
                new SmtpDataStuffing(
                    new LineWrapOutputStream(
                        new BufferedOutputStream(mOut, 1024),
                        1000)));

            message.writeTo(msgOut);

            // We use BufferedOutputStream. So make sure to call flush() !
            msgOut.flush();

            possibleSend = true; // After the ""\r\n."" is attempted, we may have sent the message
            executeSimpleCommand(""\r\n."");
        }
        catch (Exception e)
        {
            MessagingException me = new MessagingException(""Unable to send message"", e);
            me.setPermanentFailure(possibleSend);
            throw me;
        }
        finally
        {
            close();
        }



    }

    @Override
    public void close()
    {
        try
        {
            executeSimpleCommand(""QUIT"");
        }
        catch (Exception e)
        {

        }
        try
        {
            mIn.close();
        }
        catch (Exception e)
        {

        }
        try
        {
            mOut.close();
        }
        catch (Exception e)
        {

        }
        try
        {
            mSocket.close();
        }
        catch (Exception e)
        {

        }
        mIn = null;
        mOut = null;
        mSocket = null;
    }

    private String readLine() throws IOException
    {
        StringBuffer sb = new StringBuffer();
        int d;
        while ((d = mIn.read()) != -1)
        {
            if (((char)d) == '\r')
            {
                continue;
            }
            else if (((char)d) == '\n')
            {
                break;
            }
            else
            {
                sb.append((char)d);
            }
        }
        String ret = sb.toString();
        if (K9.DEBUG && K9.DEBUG_PROTOCOL_SMTP)
            Log.d(K9.LOG_TAG, ""SMTP <<< "" + ret);

        return ret;
    }

    private void writeLine(String s, boolean sensitive) throws IOException
    {
        if (K9.DEBUG && K9.DEBUG_PROTOCOL_SMTP)
        {
            final String commandToLog;
            if (sensitive && !K9.DEBUG_SENSITIVE)
            {
                commandToLog = ""SMTP >>> *sensitive*"";
            }
            else
            {
                commandToLog = ""SMTP >>> "" + s;
            }
            Log.d(K9.LOG_TAG, commandToLog);
        }

        /*
         * Note: We can use the string length to compute the buffer size since
         * only ASCII characters are allowed in SMTP commands i.e. this string
         * will never contain multi-byte characters.
         */
        int len = s.length();
        byte[] data = new byte[len + 2];
        s.getBytes(0, len, data, 0);
        data[len+0] = '\r';
        data[len+1] = '\n';

        /*
         * Important: Send command + CRLF using just one write() call. Using
         * multiple calls will likely result in multiple TCP packets and some
         * SMTP servers misbehave if CR and LF arrive in separate pakets.
         * See issue 799.
         */
        mOut.write(data);
        mOut.flush();
    }

    private void checkLine(String line) throws MessagingException
    {
        if (line.length() < 1)
        {
            throw new MessagingException(""SMTP response is 0 length"");
        }
        char c = line.charAt(0);
        if ((c == '4') || (c == '5'))
        {
            throw new MessagingException(line);
        }
    }

    private List<String> executeSimpleCommand(String command) throws IOException, MessagingException
    {
        return executeSimpleCommand(command, false);
    }

    private List<String> executeSimpleCommand(String command, boolean sensitive)
    throws IOException, MessagingException
    {
        List<String> results = new ArrayList<String>();
        if (command != null)
        {
            writeLine(command, sensitive);
        }

        boolean cont = false;
        do
        {
            String line = readLine();
            checkLine(line);
            if (line.length() > 4)
            {
                results.add(line.substring(4));
                if (line.charAt(3) == '-')
                {
                    cont = true;
                }
                else
                {
                    cont = false;
                }
            }
        }
        while (cont);
        return results;

    }


//    C: AUTH LOGIN
//    S: 334 VXNlcm5hbWU6
//    C: d2VsZG9u
//    S: 334 UGFzc3dvcmQ6
//    C: dzNsZDBu
//    S: 235 2.0.0 OK Authenticated
//
//    Lines 2-5 of the conversation contain base64-encoded information. The same conversation, with base64 strings decoded, reads:
//
//
//    C: AUTH LOGIN
//    S: 334 Username:
//    C: weldon
//    S: 334 Password:
//    C: w3ld0n
//    S: 235 2.0.0 OK Authenticated

    private void saslAuthLogin(String username, String password) throws MessagingException,
                AuthenticationFailedException, IOException
    {
        try
        {
            executeSimpleCommand(""AUTH LOGIN"");
            executeSimpleCommand(new String(Base64.encodeBase64(username.getBytes())), true);
            executeSimpleCommand(new String(Base64.encodeBase64(password.getBytes())), true);
        }
        catch (MessagingException me)
        {
            if (me.getMessage().length() > 1 && me.getMessage().charAt(1) == '3')
            {
                throw new AuthenticationFailedException(""AUTH LOGIN failed ("" + me.getMessage()
                                                        + "")"");
            }
            throw me;
        }
    }

    private void saslAuthPlain(String username, String password) throws MessagingException,
                AuthenticationFailedException, IOException
    {
        byte[] data = (""\000"" + username + ""\000"" + password).getBytes();
        data = new Base64().encode(data);
        try
        {
            executeSimpleCommand(""AUTH PLAIN "" + new String(data), true);
        }
        catch (MessagingException me)
        {
            if (me.getMessage().length() > 1 && me.getMessage().charAt(1) == '3')
            {
                throw new AuthenticationFailedException(""AUTH PLAIN failed ("" + me.getMessage()
                                                        + "")"");
            }
            throw me;
        }
    }

    private void saslAuthCramMD5(String username, String password) throws MessagingException,
                AuthenticationFailedException, IOException
    {
        List<String> respList = executeSimpleCommand(""AUTH CRAM-MD5"");
        if (respList.size() != 1) throw new AuthenticationFailedException(""Unable to negotiate CRAM-MD5"");
        String b64Nonce = respList.get(0);
        byte[] nonce = Base64.decodeBase64(b64Nonce.getBytes(""US-ASCII""));
        byte[] ipad = new byte[64];
        byte[] opad = new byte[64];
        byte[] secretBytes = password.getBytes(""US-ASCII"");
        MessageDigest md;
        try
        {
            md = MessageDigest.getInstance(""MD5"");
        }
        catch (NoSuchAlgorithmException nsae)
        {
            throw new AuthenticationFailedException(""MD5 Not Available."");
        }
        if (secretBytes.length > 64)
        {
            secretBytes = md.digest(secretBytes);
        }
        System.arraycopy(secretBytes, 0, ipad, 0, secretBytes.length);
        System.arraycopy(secretBytes, 0, opad, 0, secretBytes.length);
        for (int i = 0; i < ipad.length; i++) ipad[i] ^= 0x36;
        for (int i = 0; i < opad.length; i++) opad[i] ^= 0x5c;
        md.update(ipad);
        byte[] firstPass = md.digest(nonce);
        md.update(opad);
        byte[] result = md.digest(firstPass);
        String plainCRAM = username + "" "" + new String(Hex.encodeHex(result));
        byte[] b64CRAM = Base64.encodeBase64(plainCRAM.getBytes(""US-ASCII""));
        String b64CRAMString = new String(b64CRAM, ""US-ASCII"");
        try
        {
            executeSimpleCommand(b64CRAMString, true);
        }
        catch (MessagingException me)
        {
            throw new AuthenticationFailedException(""Unable to negotiate MD5 CRAM"");
        }
    }
}
",True,216,0,0,9,57,1,13,L1
106,com.fsck.k9.mail.filter.EOLConvertingOutputStream.java,"package com.fsck.k9.mail.filter;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class EOLConvertingOutputStream extends FilterOutputStream
{
    private int lastChar;
    private boolean ignoreNextIfLF = false;

    public EOLConvertingOutputStream(OutputStream out)
    {
        super(out);
    }

    @Override
    public void write(int oneByte) throws IOException
    {
        if (!ignoreNextIfLF)
        {
            if ((oneByte == '\n') && (lastChar != '\r'))
            {
                super.write('\r');
            }
            super.write(oneByte);
            lastChar = oneByte;
        }
        ignoreNextIfLF = false;
    }

    @Override
    public void flush() throws IOException
    {
        if (lastChar == '\r')
        {
            super.write('\n');
            lastChar = '\n';

            // We have to ignore the next character if it is <LF>. Otherwise it
            // will be expanded to an additional <CR><LF> sequence although it
            // belongs to the one just completed.
            ignoreNextIfLF = true;
        }
        super.flush();
    }
}
",True,92,8,34,0,0,3,0,L1
107,com.fsck.k9.mail.filter.StatusOutputStream.java,"package com.fsck.k9.mail.filter;

import android.util.Config;
import android.util.Log;
import com.fsck.k9.K9;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class StatusOutputStream extends FilterOutputStream
{
    private long mCount = 0;

    public StatusOutputStream(OutputStream out)
    {
        super(out);
    }

    @Override
    public void write(int oneByte) throws IOException
    {
        super.write(oneByte);
        mCount++;
        if (Config.LOGV)
        {
            if (mCount % 1024 == 0)
            {
                Log.v(K9.LOG_TAG, ""# "" + mCount);
            }
        }
    }
}
",True,217,0,0,9,59,0,1,L4
108,com.fsck.k9.mail.filter.CountingOutputStream.java,"package com.fsck.k9.mail.filter;

import java.io.IOException;
import java.io.OutputStream;

/**
 * A simple OutputStream that does nothing but count how many bytes are written to it and
 * makes that count available to callers.
 */
public class CountingOutputStream extends OutputStream
{
    private long mCount;

    public CountingOutputStream()
    {
    }

    public long getCount()
    {
        return mCount;
    }

    @Override
    public void write(int oneByte) throws IOException
    {
        mCount++;
    }
}
",False,92,8,35,0,0,1,0,L1
109,com.fsck.k9.mail.filter.Base64OutputStream.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.mail.filter;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

/**
 * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).
 * When encoding the default lineLength is 76 characters and the default
 * lineEnding is CRLF, but these can be overridden by using the appropriate
 * constructor.
 * <p>
 * The default behaviour of the Base64OutputStream is to ENCODE, whereas the
 * default behaviour of the Base64InputStream is to DECODE.  But this behaviour
 * can be overridden by using a different constructor.
 * </p><p>
 * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
 * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
 * </p>
 *
 * @author Apache Software Foundation
 * @version $Id $
 * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045</a>
 * @since 1.0-dev
 */
public class Base64OutputStream extends FilterOutputStream
{
    private final boolean doEncode;
    private final Base64 base64;
    private final byte[] singleByte = new byte[1];

    /**
     * Creates a Base64OutputStream such that all data written is Base64-encoded
     * to the original provided OutputStream.
     *
     * @param out OutputStream to wrap.
     */
    public Base64OutputStream(OutputStream out)
    {
        this(out, true);
    }

    /**
     * Creates a Base64OutputStream such that all data written is either
     * Base64-encoded or Base64-decoded to the original provided OutputStream.
     *
     * @param out      OutputStream to wrap.
     * @param doEncode true if we should encode all data written to us,
     *                 false if we should decode.
     */
    public Base64OutputStream(OutputStream out, boolean doEncode)
    {
        super(out);
        this.doEncode = doEncode;
        this.base64 = new Base64();
    }

    /**
     * Creates a Base64OutputStream such that all data written is either
     * Base64-encoded or Base64-decoded to the original provided OutputStream.
     *
     * @param out           OutputStream to wrap.
     * @param doEncode      true if we should encode all data written to us,
     *                      false if we should decode.
     * @param lineLength    If doEncode is true, each line of encoded
     *                      data will contain lineLength characters.
     *                      If lineLength <=0, the encoded data is not divided into lines.
     *                      If doEncode is false, lineLength is ignored.
     * @param lineSeparator If doEncode is true, each line of encoded
     *                      data will be terminated with this byte sequence (e.g. \r\n).
     *                      If lineLength <= 0, the lineSeparator is not used.
     *                      If doEncode is false lineSeparator is ignored.
     */
    public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator)
    {
        super(out);
        this.doEncode = doEncode;
        this.base64 = new Base64(lineLength, lineSeparator);
    }

    /**
     * Writes the specified <code>byte</code> to this output stream.
     */
    @Override
    public void write(int i) throws IOException
    {
        singleByte[0] = (byte) i;
        write(singleByte, 0, 1);
    }

    /**
     * Writes <code>len</code> bytes from the specified
     * <code>b</code> array starting at <code>offset</code> to
     * this output stream.
     *
     * @param b source byte array
     * @param offset where to start reading the bytes
     * @param len maximum number of bytes to write
     *
     * @throws IOException if an I/O error occurs.
     * @throws NullPointerException if the byte array parameter is null
     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid
     */
    @Override
    public void write(byte b[], int offset, int len) throws IOException
    {
        if (b == null)
        {
            throw new NullPointerException();
        }
        else if (offset < 0 || len < 0 || offset + len < 0)
        {
            throw new IndexOutOfBoundsException();
        }
        else if (offset > b.length || offset + len > b.length)
        {
            throw new IndexOutOfBoundsException();
        }
        else if (len > 0)
        {
            if (doEncode)
            {
                base64.encode(b, offset, len);
            }
            else
            {
                base64.decode(b, offset, len);
            }
            flush(false);
        }
    }

    /**
     * Flushes this output stream and forces any buffered output bytes
     * to be written out to the stream.  If propogate is true, the wrapped
     * stream will also be flushed.
     *
     * @param propogate boolean flag to indicate whether the wrapped
     *                  OutputStream should also be flushed.
     * @throws IOException if an I/O error occurs.
     */
    private void flush(boolean propogate) throws IOException
    {
        int avail = base64.avail();
        if (avail > 0)
        {
            byte[] buf = new byte[avail];
            int c = base64.readResults(buf, 0, avail);
            if (c > 0)
            {
                out.write(buf, 0, c);
            }
        }
        if (propogate)
        {
            out.flush();
        }
    }

    /**
     * Flushes this output stream and forces any buffered output bytes
     * to be written out to the stream.
     *
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void flush() throws IOException
    {
        flush(true);
    }

    /**
     * Closes this output stream, flushing any remaining bytes that must be encoded. The
     * underlying stream is flushed but not closed.
     */
    @Override
    public void close() throws IOException
    {
        // Notify encoder of EOF (-1).
        if (doEncode)
        {
            base64.encode(singleByte, 0, -1);
        }
        else
        {
            base64.decode(singleByte, 0, -1);
        }
        flush();
    }

}
",True,94,5,62,1,1,2,1,L1
110,com.fsck.k9.mail.filter.PeekableInputStream.java,"
package com.fsck.k9.mail.filter;

import java.io.IOException;
import java.io.InputStream;

/**
 * A filtering InputStream that allows single byte ""peeks"" without consuming the byte. The
 * client of this stream can call peek() to see the next available byte in the stream
 * and a subsequent read will still return the peeked byte.
 */
public class PeekableInputStream extends InputStream
{
    private InputStream mIn;
    private boolean mPeeked;
    private int mPeekedByte;

    public PeekableInputStream(InputStream in)
    {
        this.mIn = in;
    }

    @Override
    public int read() throws IOException
    {
        if (!mPeeked)
        {
            return mIn.read();
        }
        else
        {
            mPeeked = false;
            return mPeekedByte;
        }
    }

    public int peek() throws IOException
    {
        if (!mPeeked)
        {
            mPeekedByte = read();
            mPeeked = true;
        }
        return mPeekedByte;
    }

    @Override
    public int read(byte[] b, int offset, int length) throws IOException
    {
        if (!mPeeked)
        {
            return mIn.read(b, offset, length);
        }
        else
        {
            b[0] = (byte)mPeekedByte;
            mPeeked = false;
            int r = mIn.read(b, offset + 1, length - 1);
            if (r == -1)
            {
                return 1;
            }
            else
            {
                return r + 1;
            }
        }
    }

    @Override
    public int read(byte[] b) throws IOException
    {
        return read(b, 0, b.length);
    }

    @Override
    public String toString()
    {
        return String.format(""PeekableInputStream(in=%s, peeked=%b, peekedByte=%d)"",
                             mIn.toString(), mPeeked, mPeekedByte);
    }
}
",True,92,8,33,0,0,4,0,L1
111,com.fsck.k9.mail.filter.LineWrapOutputStream.java,"package com.fsck.k9.mail.filter;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class LineWrapOutputStream extends FilterOutputStream
{
    private static final byte[] CRLF = new byte[] {'\r', '\n'};

    private byte[] buffer;
    private int bufferStart = 0;
    private int lineLength = 0;
    private int endOfLastWord = 0;


    public LineWrapOutputStream(OutputStream out, int maxLineLength)
    {
        super(out);
        buffer = new byte[maxLineLength - 2];
    }

    @Override
    public void write(int oneByte) throws IOException
    {
        // Buffer full?
        if (lineLength == buffer.length)
        {
            // Usable word-boundary found earlier?
            if (endOfLastWord > 0)
            {
                // Yes, so output everything up to that word-boundary
                out.write(buffer, bufferStart, endOfLastWord - bufferStart);
                out.write(CRLF);

                bufferStart = 0;

                // Skip the <SPACE> in the buffer
                endOfLastWord++;
                lineLength = buffer.length - endOfLastWord;
                if (lineLength > 0)
                {
                    // Copy rest of the buffer to the front
                    for (int i = 0; i < lineLength; i++)
                    {
                        buffer[i] = buffer[endOfLastWord + i];
                    }
                }
                endOfLastWord = 0;
            }
            else
            {
                // No word-boundary found, so output whole buffer
                out.write(buffer, bufferStart, buffer.length - bufferStart);
                out.write(CRLF);
                lineLength = 0;
                bufferStart = 0;
            }
        }

        if ((oneByte == '\n') || (oneByte == '\r'))
        {
            // <CR> or <LF> character found, so output buffer ...
            if (lineLength - bufferStart > 0)
            {
                out.write(buffer, bufferStart, lineLength - bufferStart);
            }
            // ... and that character
            out.write(oneByte);
            lineLength = 0;
            bufferStart = 0;
            endOfLastWord = 0;
        }
        else
        {
            // Remember this position as last word-boundary if <SPACE> found
            if (oneByte == ' ')
            {
                endOfLastWord = lineLength;
            }

            // Write character to the buffer
            buffer[lineLength] = (byte)oneByte;
            lineLength++;
        }
    }

    @Override
    public void flush() throws IOException
    {
        // Buffer empty?
        if (lineLength > bufferStart)
        {
            // Output everything we have up till now
            out.write(buffer, bufferStart, lineLength - bufferStart);

            // Mark current position as new start of the buffer
            bufferStart = (lineLength == buffer.length) ? 0 : lineLength;
            endOfLastWord = 0;
        }
        out.flush();
    }
}
",True,92,8,44,0,0,1,0,L1
112,com.fsck.k9.mail.filter.FixedLengthInputStream.java,"
package com.fsck.k9.mail.filter;

import java.io.IOException;
import java.io.InputStream;

/**
 * A filtering InputStream that stops allowing reads after the given length has been read. This
 * is used to allow a client to read directly from an underlying protocol stream without reading
 * past where the protocol handler intended the client to read.
 */
public class FixedLengthInputStream extends InputStream
{
    private InputStream mIn;
    private int mLength;
    private int mCount;

    public FixedLengthInputStream(InputStream in, int length)
    {
        this.mIn = in;
        this.mLength = length;
    }

    @Override
    public int available() throws IOException
    {
        return mLength - mCount;
    }

    @Override
    public int read() throws IOException
    {
        if (mCount < mLength)
        {
            mCount++;
            return mIn.read();
        }
        else
        {
            return -1;
        }
    }

    @Override
    public int read(byte[] b, int offset, int length) throws IOException
    {
        if (mCount < mLength)
        {
            int d = mIn.read(b, offset, Math.min(mLength - mCount, length));
            if (d == -1)
            {
                return -1;
            }
            else
            {
                mCount += d;
                return d;
            }
        }
        else
        {
            return -1;
        }
    }

    @Override
    public int read(byte[] b) throws IOException
    {
        return read(b, 0, b.length);
    }

    @Override
    public String toString()
    {
        return String.format(""FixedLengthInputStream(in=%s, length=%d)"", mIn.toString(), mLength);
    }
}
",True,92,8,35,0,0,2,0,L1
113,com.fsck.k9.mail.filter.Base64.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fsck.k9.mail.filter;

import org.apache.commons.codec.BinaryDecoder;
import org.apache.commons.codec.BinaryEncoder;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.EncoderException;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;

/**
 * Provides Base64 encoding and decoding as defined by RFC 2045.
 *
 * <p>
 * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
 * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
 * </p>
 *
 * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045</a>
 * @author Apache Software Foundation
 * @since 1.0-dev
 * @version $Id$
 */
public class Base64 implements BinaryEncoder, BinaryDecoder
{
    /**
     * Chunk size per RFC 2045 section 6.8.
     *
     * <p>
     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any
     * equal signs.
     * </p>
     *
     * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045 section 6.8</a>
     */
    static final int CHUNK_SIZE = 76;

    /**
     * Chunk separator per RFC 2045 section 2.1.
     *
     * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045 section 2.1</a>
     */
    static final byte[] CHUNK_SEPARATOR = {'\r','\n'};

    /**
     * This array is a lookup table that translates 6-bit positive integer
     * index values into their ""Base64 Alphabet"" equivalents as specified
     * in Table 1 of RFC 2045.
     *
     * Thanks to ""commons"" project in ws.apache.org for this code.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     */
    private static final byte[] intToBase64 =
    {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
    };

    /**
     * Byte used to pad output.
     */
    private static final byte PAD = '=';

    /**
     * This array is a lookup table that translates unicode characters
     * drawn from the ""Base64 Alphabet"" (as specified in Table 1 of RFC 2045)
     * into their 6-bit positive integer equivalents.  Characters that
     * are not in the Base64 alphabet but fall within the bounds of the
     * array are translated to -1.
     *
     * Thanks to ""commons"" project in ws.apache.org for this code.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     */
    private static final byte[] base64ToInt =
    {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,
        55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,
        5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
        24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,
        35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
    };

    /** Mask used to extract 6 bits, used when encoding */
    private static final int MASK_6BITS = 0x3f;

    /** Mask used to extract 8 bits, used in decoding base64 bytes */
    private static final int MASK_8BITS = 0xff;

    // The static final fields above are used for the original static byte[] methods on Base64.
    // The private member fields below are used with the new streaming approach, which requires
    // some state be preserved between calls of encode() and decode().


    /**
     * Line length for encoding.  Not used when decoding.  A value of zero or less implies
     * no chunking of the base64 encoded data.
     */
    private final int lineLength;

    /**
     * Line separator for encoding.  Not used when decoding.  Only used if lineLength > 0.
     */
    private final byte[] lineSeparator;

    /**
     * Convenience variable to help us determine when our buffer is going to run out of
     * room and needs resizing.  <code>decodeSize = 3 + lineSeparator.length;</code>
     */
    private final int decodeSize;

    /**
     * Convenience variable to help us determine when our buffer is going to run out of
     * room and needs resizing.  <code>encodeSize = 4 + lineSeparator.length;</code>
     */
    private final int encodeSize;

    /**
     * Buffer for streaming.
     */
    private byte[] buf;

    /**
     * Position where next character should be written in the buffer.
     */
    private int pos;

    /**
     * Position where next character should be read from the buffer.
     */
    private int readPos;

    /**
     * Variable tracks how many characters have been written to the current line.
     * Only used when encoding.  We use it to make sure each encoded line never
     * goes beyond lineLength (if lineLength > 0).
     */
    private int currentLinePos;

    /**
     * Writes to the buffer only occur after every 3 reads when encoding, an
     * every 4 reads when decoding.  This variable helps track that.
     */
    private int modulus;

    /**
     * Boolean flag to indicate the EOF has been reached.  Once EOF has been
     * reached, this Base64 object becomes useless, and must be thrown away.
     */
    private boolean eof;

    /**
     * Place holder for the 3 bytes we're dealing with for our base64 logic.
     * Bitwise operations store and extract the base64 encoding or decoding from
     * this variable.
     */
    private int x;

    /**
     * Default constructor:  lineLength is 76, and the lineSeparator is CRLF
     * when encoding, and all forms can be decoded.
     */
    public Base64()
    {
        this(CHUNK_SIZE, CHUNK_SEPARATOR);
    }

    /**
     * <p>
     * Consumer can use this constructor to choose a different lineLength
     * when encoding (lineSeparator is still CRLF).  All forms of data can
     * be decoded.
     * </p><p>
     * Note:  lineLengths that aren't multiples of 4 will still essentially
     * end up being multiples of 4 in the encoded data.
     * </p>
     *
     * @param lineLength each line of encoded data will be at most this long
     * (rounded up to nearest multiple of 4).
     * If lineLength <= 0, then the output will not be divided into lines (chunks).
     * Ignored when decoding.
     */
    public Base64(int lineLength)
    {
        this(lineLength, CHUNK_SEPARATOR);
    }

    /**
     * <p>
     * Consumer can use this constructor to choose a different lineLength
     * and lineSeparator when encoding.  All forms of data can
     * be decoded.
     * </p><p>
     * Note:  lineLengths that aren't multiples of 4 will still essentially
     * end up being multiples of 4 in the encoded data.
     * </p>
     * @param lineLength    Each line of encoded data will be at most this long
     *                      (rounded up to nearest multiple of 4).  Ignored when decoding.
     *                      If <= 0, then output will not be divided into lines (chunks).
     * @param lineSeparator Each line of encoded data will end with this
     *                      sequence of bytes.
     *                      If lineLength <= 0, then the lineSeparator is not used.
     * @throws IllegalArgumentException The provided lineSeparator included
     *                                  some base64 characters.  That's not going to work!
     */
    public Base64(int lineLength, byte[] lineSeparator)
    {
        this.lineLength = lineLength;
        this.lineSeparator = new byte[lineSeparator.length];
        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
        if (lineLength > 0)
        {
            this.encodeSize = 4 + lineSeparator.length;
        }
        else
        {
            this.encodeSize = 4;
        }
        this.decodeSize = encodeSize - 1;
        if (containsBase64Byte(lineSeparator))
        {
            String sep;
            try
            {
                sep = new String(lineSeparator, ""UTF-8"");
            }
            catch (UnsupportedEncodingException uee)
            {
                sep = new String(lineSeparator);
            }
            throw new IllegalArgumentException(""lineSeperator must not contain base64 characters: ["" + sep + ""]"");
        }
    }

    /**
     * Returns true if this Base64 object has buffered data for reading.
     *
     * @return true if there is Base64 object still available for reading.
     */
    boolean hasData()
    {
        return buf != null;
    }

    /**
     * Returns the amount of buffered data available for reading.
     *
     * @return The amount of buffered data available for reading.
     */
    int avail()
    {
        return buf != null ? pos - readPos : 0;
    }

    /** Doubles our buffer. */
    private void resizeBuf()
    {
        if (buf == null)
        {
            buf = new byte[8192];
            pos = 0;
            readPos = 0;
        }
        else
        {
            byte[] b = new byte[buf.length * 2];
            System.arraycopy(buf, 0, b, 0, buf.length);
            buf = b;
        }
    }

    /**
     * Extracts buffered data into the provided byte[] array, starting
     * at position bPos, up to a maximum of bAvail bytes.  Returns how
     * many bytes were actually extracted.
     *
     * @param b      byte[] array to extract the buffered data into.
     * @param bPos   position in byte[] array to start extraction at.
     * @param bAvail amount of bytes we're allowed to extract.  We may extract
     *               fewer (if fewer are available).
     * @return The number of bytes successfully extracted into the provided
     *         byte[] array.
     */
    int readResults(byte[] b, int bPos, int bAvail)
    {
        if (buf != null)
        {
            int len = Math.min(avail(), bAvail);
            if (buf != b)
            {
                System.arraycopy(buf, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos)
                {
                    buf = null;
                }
            }
            else
            {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buf = null;
            }
            return len;
        }
        else
        {
            return eof ? -1 : 0;
        }
    }

    /**
     * Small optimization where we try to buffer directly to the consumer's
     * output array for one round (if consumer calls this method first!) instead
     * of starting our own buffer.
     *
     * @param out byte[] array to buffer directly to.
     * @param outPos Position to start buffering into.
     * @param outAvail Amount of bytes available for direct buffering.
     */
    void setInitialBuffer(byte[] out, int outPos, int outAvail)
    {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail)
        {
            buf = out;
            pos = outPos;
            readPos = outPos;
        }
    }

    /**
     * <p>
     * Encodes all of the provided data, starting at inPos, for inAvail bytes.
     * Must be called at least twice:  once with the data to encode, and once
     * with inAvail set to ""-1"" to alert encoder that EOF has been reached,
     * so flush last remaining bytes (if not multiple of 3).
     * </p><p>
     * Thanks to ""commons"" project in ws.apache.org for the bitwise operations,
     * and general approach.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * </p>
     *
     * @param in byte[] array of binary data to base64 encode.
     * @param inPos Position to start reading data from.
     * @param inAvail Amount of bytes available from input for encoding.
     */
    void encode(byte[] in, int inPos, int inAvail)
    {
        if (eof)
        {
            return;
        }

        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0)
        {
            eof = true;
            if (buf == null || buf.length - pos < encodeSize)
            {
                resizeBuf();
            }
            switch (modulus)
            {
                case 1:
                    buf[pos++] = intToBase64[(x >> 2) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x << 4) & MASK_6BITS];
                    buf[pos++] = PAD;
                    buf[pos++] = PAD;
                    break;

                case 2:
                    buf[pos++] = intToBase64[(x >> 10) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x >> 4) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x << 2) & MASK_6BITS];
                    buf[pos++] = PAD;
                    break;
            }
            if (lineLength > 0)
            {
                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        }
        else
        {
            for (int i = 0; i < inAvail; i++)
            {
                if (buf == null || buf.length - pos < encodeSize)
                {
                    resizeBuf();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0)
                {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus)
                {
                    buf[pos++] = intToBase64[(x >> 18) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x >> 12) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x >> 6) & MASK_6BITS];
                    buf[pos++] = intToBase64[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos)
                    {
                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }

    /**
     * <p>
     * Decodes all of the provided data, starting at inPos, for inAvail bytes.
     * Should be called at least twice:  once with the data to decode, and once
     * with inAvail set to ""-1"" to alert decoder that EOF has been reached.
     * The ""-1"" call is not necessary when decoding, but it doesn't hurt, either.
     * </p><p>
     * Ignores all non-base64 characters.  This is how chunked (e.g. 76 character)
     * data is handled, since CR and LF are silently ignored, but has implications
     * for other bytes, too.  This method subscribes to the garbage-in, garbage-out
     * philosophy:  it will not check the provided data for validity.
     * </p><p>
     * Thanks to ""commons"" project in ws.apache.org for the bitwise operations,
     * and general approach.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * </p>

     * @param in byte[] array of ascii data to base64 decode.
     * @param inPos Position to start reading data from.
     * @param inAvail Amount of bytes available from input for encoding.
     */
    void decode(byte[] in, int inPos, int inAvail)
    {
        if (eof)
        {
            return;
        }
        if (inAvail < 0)
        {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++)
        {
            if (buf == null || buf.length - pos < decodeSize)
            {
                resizeBuf();
            }
            byte b = in[inPos++];
            if (b == PAD)
            {
                x = x << 6;
                switch (modulus)
                {
                    case 2:
                        x = x << 6;
                        buf[pos++] = (byte)((x >> 16) & MASK_8BITS);
                        break;
                    case 3:
                        buf[pos++] = (byte)((x >> 16) & MASK_8BITS);
                        buf[pos++] = (byte)((x >> 8) & MASK_8BITS);
                        break;
                }
                // WE'RE DONE!!!!
                eof = true;
                return;
            }
            else
            {
                if (b >= 0 && b < base64ToInt.length)
                {
                    int result = base64ToInt[b];
                    if (result >= 0)
                    {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0)
                        {
                            buf[pos++] = (byte)((x >> 16) & MASK_8BITS);
                            buf[pos++] = (byte)((x >> 8) & MASK_8BITS);
                            buf[pos++] = (byte)(x & MASK_8BITS);
                        }
                    }
                }
            }
        }
    }

    /**
     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
     *
     * @param octet
     *            The value to test
     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
     */
    public static boolean isBase64(byte octet)
    {
        return octet == PAD || (octet >= 0 && octet < base64ToInt.length && base64ToInt[octet] != -1);
    }

    /**
     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.
     * Currently the method treats whitespace as valid.
     *
     * @param arrayOctet
     *            byte array to test
     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is
     *         empty; false, otherwise
     */
    public static boolean isArrayByteBase64(byte[] arrayOctet)
    {
        for (int i = 0; i < arrayOctet.length; i++)
        {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i]))
            {
                return false;
            }
        }
        return true;
    }

    /*
     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.
     *
     * @param arrayOctet
     *            byte array to test
     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise
     */
    private static boolean containsBase64Byte(byte[] arrayOctet)
    {
        for (byte element : arrayOctet)
        {
            if (isBase64(element))
            {
                return true;
            }
        }
        return false;
    }

    /**
     * Encodes binary data using the base64 algorithm but does not chunk the output.
     *
     * @param binaryData
     *            binary data to encode
     * @return Base64 characters
     */
    public static byte[] encodeBase64(byte[] binaryData)
    {
        return encodeBase64(binaryData, false);
    }

    /**
     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
     *
     * @param binaryData
     *            binary data to encode
     * @return Base64 characters chunked in 76 character blocks
     */
    public static byte[] encodeBase64Chunked(byte[] binaryData)
    {
        return encodeBase64(binaryData, true);
    }

    /**
     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[].
     *
     * @param pObject
     *            Object to decode
     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] supplied.
     * @throws DecoderException
     *             if the parameter supplied is not of type byte[]
     */
    public Object decode(Object pObject) throws DecoderException
    {
        if (!(pObject instanceof byte[]))
        {
            throw new DecoderException(""Parameter supplied to Base64 decode is not a byte[]"");
        }
        return decode((byte[]) pObject);
    }

    /**
     * Decodes a byte[] containing containing characters in the Base64 alphabet.
     *
     * @param pArray
     *            A byte array containing Base64 character data
     * @return a byte array containing binary data
     */
    public byte[] decode(byte[] pArray)
    {
        return decodeBase64(pArray);
    }

    /**
     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
     *
     * @param binaryData
     *            Array containing binary data to encode.
     * @param isChunked
     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
     * @return Base64-encoded data.
     * @throws IllegalArgumentException
     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
     */
    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked)
    {
        if (binaryData == null || binaryData.length == 0)
        {
            return binaryData;
        }
        Base64 b64 = isChunked ? new Base64() : new Base64(0);

        long len = (binaryData.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0)
        {
            len += 4 - mod;
        }
        if (isChunked)
        {
            len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;
        }

        if (len > Integer.MAX_VALUE)
        {
            throw new IllegalArgumentException(
                ""Input array too big, output array would be bigger than Integer.MAX_VALUE="" + Integer.MAX_VALUE);
        }
        byte[] buf = new byte[(int) len];
        b64.setInitialBuffer(buf, 0, buf.length);
        b64.encode(binaryData, 0, binaryData.length);
        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.

        // Encoder might have resized, even though it was unnecessary.
        if (b64.buf != buf)
        {
            b64.readResults(buf, 0, buf.length);
        }
        return buf;
    }

    /**
     * Decodes Base64 data into octets
     *
     * @param base64Data Byte array containing Base64 data
     * @return Array containing decoded data.
     */
    public static byte[] decodeBase64(byte[] base64Data)
    {
        if (base64Data == null || base64Data.length == 0)
        {
            return base64Data;
        }
        Base64 b64 = new Base64();

        long len = (base64Data.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        b64.setInitialBuffer(buf, 0, buf.length);
        b64.decode(base64Data, 0, base64Data.length);
        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.

        // We have no idea what the line-length was, so we
        // cannot know how much of our array wasn't used.
        byte[] result = new byte[b64.pos];
        b64.readResults(result, 0, result.length);
        return result;
    }

    /**
     * Check if a byte value is whitespace or not.
     *
     * @param byteToCheck the byte to check
     * @return true if byte is whitespace, false otherwise
     */
    private static boolean isWhiteSpace(byte byteToCheck)
    {
        switch (byteToCheck)
        {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }

    /**
     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - ""Any
     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.""
     *
     * @param data
     *            The base-64 encoded data to groom
     * @return The data, less non-base64 characters (see RFC 2045).
     */
    static byte[] discardNonBase64(byte[] data)
    {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;

        for (byte element : data)
        {
            if (isBase64(element))
            {
                groomedData[bytesCopied++] = element;
            }
        }

        byte packedData[] = new byte[bytesCopied];

        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);

        return packedData;
    }

    // Implementation of the Encoder Interface

    /**
     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].
     *
     * @param pObject
     *            Object to encode
     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.
     * @throws EncoderException
     *             if the parameter supplied is not of type byte[]
     */
    public Object encode(Object pObject) throws EncoderException
    {
        if (!(pObject instanceof byte[]))
        {
            throw new EncoderException(""Parameter supplied to Base64 encode is not a byte[]"");
        }
        return encode((byte[]) pObject);
    }

    /**
     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.
     *
     * @param pArray
     *            a byte array containing binary data
     * @return A byte array containing only Base64 character data
     */
    public byte[] encode(byte[] pArray)
    {
        return encodeBase64(pArray, false);
    }

    // Implementation of integer encoding used for crypto
    /**
     * Decode a byte64-encoded integer according to crypto
     * standards such as W3C's XML-Signature
     *
     * @param pArray a byte array containing base64 character data
     * @return A BigInteger
     */
    public static BigInteger decodeInteger(byte[] pArray)
    {
        return new BigInteger(1, decodeBase64(pArray));
    }

    /**
     * Encode to a byte64-encoded integer according to crypto
     * standards such as W3C's XML-Signature
     *
     * @param bigInt a BigInteger
     * @return A byte array containing base64 character data
     * @throws NullPointerException if null is passed in
     */
    public static byte[] encodeInteger(BigInteger bigInt)
    {
        if (bigInt == null)
        {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }

        return encodeBase64(toIntegerBytes(bigInt), false);
    }

    /**
     * Returns a byte-array representation of a <code>BigInteger</code>
     * without sign bit.
     *
     * @param bigInt <code>BigInteger</code> to be converted
     * @return a byte array representation of the BigInteger parameter
     */
    static byte[] toIntegerBytes(BigInteger bigInt)
    {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) &&
                (((bigInt.bitLength() / 8) + 1) == (bitlen / 8)))
        {
            return bigBytes;
        }

        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0)
        {
            startSrc = 1;
            len--;
        }

        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];

        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);

        return resizedBytes;
    }
}
",False,95,5,43,0,0,3,0,L1
114,com.fsck.k9.mail.filter.SmtpDataStuffing.java,"package com.fsck.k9.mail.filter;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class SmtpDataStuffing extends FilterOutputStream
{
    private static final int STATE_NORMAL = 0;
    private static final int STATE_CR = 1;
    private static final int STATE_CRLF = 2;

    private int state = STATE_NORMAL;

    public SmtpDataStuffing(OutputStream out)
    {
        super(out);
    }

    @Override
    public void write(int oneByte) throws IOException
    {
        if (oneByte == '\r')
        {
            state = STATE_CR;
        }
        else if ((state == STATE_CR) && (oneByte == '\n'))
        {
            state = STATE_CRLF;
        }
        else if ((state == STATE_CRLF) && (oneByte == '.'))
        {
            // Read <CR><LF><DOT> so this line needs an additional period.
            super.write('.');
            state = STATE_NORMAL;
        }
        else
        {
            state = STATE_NORMAL;
        }
        super.write(oneByte);
    }
}
",False,92,8,44,0,0,1,0,L1
115,com.fsck.k9.mail.internet.TextBody.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.Body;
import com.fsck.k9.mail.MessagingException;

import java.io.*;

import org.apache.james.mime4j.codec.QuotedPrintableOutputStream;

public class TextBody implements Body
{

    /**
     * Immutable empty byte array
     */
    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];

    private String mBody;
    private String mEncoding;

    public TextBody(String body)
    {
        this.mBody = body;
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException
    {
        if (mBody != null)
        {
            byte[] bytes = mBody.getBytes(""UTF-8"");
            if (""8bit"".equals(mEncoding))
            {
                out.write(bytes);
            }
            else
            {
                QuotedPrintableOutputStream qp = new QuotedPrintableOutputStream(out, false);
                qp.write(bytes);
                qp.flush();
            }
        }
    }

    /**
     * Get the text of the body in it's unencoded format.
     * @return
     */
    public String getText()
    {
        return mBody;
    }

    /**
     * Returns an InputStream that reads this body's text in UTF-8 format.
     */
    public InputStream getInputStream() throws MessagingException
    {
        try
        {
            byte[] b;
            if (mBody!=null)
            {
                b = mBody.getBytes(""UTF-8"");
            }
            else
            {
                b = EMPTY_BYTE_ARRAY;
            }
            return new ByteArrayInputStream(b);
        }
        catch (UnsupportedEncodingException usee)
        {
            return null;
        }
    }

    public void setEncoding(String encoding)
    {
        mEncoding = encoding;
    }
}
",False,96,4,49,2,3,7,3,L1
116,com.fsck.k9.mail.internet.MimeMessage.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.*;
import org.apache.james.mime4j.BodyDescriptor;
import org.apache.james.mime4j.ContentHandler;
import org.apache.james.mime4j.EOLConvertingInputStream;
import org.apache.james.mime4j.MimeStreamParser;
import org.apache.james.mime4j.field.DateTimeField;
import org.apache.james.mime4j.field.Field;

import java.io.*;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * An implementation of Message that stores all of it's metadata in RFC 822 and
 * RFC 2045 style headers.
 */
public class MimeMessage extends Message
{
    protected MimeHeader mHeader = new MimeHeader();
    protected Address[] mFrom;
    protected Address[] mTo;
    protected Address[] mCc;
    protected Address[] mBcc;
    protected Address[] mReplyTo;

    protected String mMessageId;
    protected String[] mReferences;
    protected String[] mInReplyTo;

    protected Date mSentDate;
    protected SimpleDateFormat mDateFormat;

    protected Body mBody;
    protected int mSize;

    public MimeMessage()
    {
    }


    /**
     * Parse the given InputStream using Apache Mime4J to build a MimeMessage.
     *
     * @param in
     * @throws IOException
     * @throws MessagingException
     */
    public MimeMessage(InputStream in) throws IOException, MessagingException
    {
        parse(in);
    }

    protected void parse(InputStream in) throws IOException, MessagingException
    {
        mHeader.clear();
        mFrom = null;
        mTo = null;
        mCc = null;
        mBcc = null;
        mReplyTo = null;

        mMessageId = null;
        mReferences = null;
        mInReplyTo = null;

        mSentDate = null;

        mBody = null;

        MimeStreamParser parser = new MimeStreamParser();
        parser.setContentHandler(new MimeMessageBuilder());
        parser.parse(new EOLConvertingInputStream(in));
    }

    @Override
    public Date getSentDate()
    {
        if (mSentDate == null)
        {
            try
            {
                DateTimeField field = (DateTimeField)Field.parse(""Date: ""
                                      + MimeUtility.unfoldAndDecode(getFirstHeader(""Date"")));
                mSentDate = field.getDate();
            }
            catch (Exception e)
            {

            }
        }
        return mSentDate;
    }

    /**
     * Sets the sent date object member as well as *adds* the 'Date' header
     * instead of setting it (for performance reasons).
     *
     * @see #mSentDate
     * @param sentDate
     * @throws com.fsck.k9.mail.MessagingException
     */
    public void addSentDate(Date sentDate) throws MessagingException
    {
        if (mDateFormat == null)
        {
            mDateFormat = new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss Z"", Locale.US);
        }
        addHeader(""Date"", mDateFormat.format(sentDate));
        setInternalSentDate(sentDate);
    }

    @Override
    public void setSentDate(Date sentDate) throws MessagingException
    {
        removeHeader(""Date"");
        addSentDate(sentDate);
    }

    public void setInternalSentDate(Date sentDate) throws MessagingException
    {
        this.mSentDate = sentDate;
    }

    @Override
    public String getContentType() throws MessagingException
    {
        String contentType = getFirstHeader(MimeHeader.HEADER_CONTENT_TYPE);
        if (contentType == null)
        {
            return ""text/plain"";
        }
        else
        {
            return contentType.toLowerCase();
        }
    }

    public String getDisposition() throws MessagingException
    {
        String contentDisposition = getFirstHeader(MimeHeader.HEADER_CONTENT_DISPOSITION);
        if (contentDisposition == null)
        {
            return null;
        }
        else
        {
            return contentDisposition;
        }
    }
    public String getContentId() throws MessagingException
    {
        return null;
    }
    public String getMimeType() throws MessagingException
    {
        return MimeUtility.getHeaderParameter(getContentType(), null);
    }

    public int getSize() throws MessagingException
    {
        return mSize;
    }

    /**
     * Returns a list of the given recipient type from this message. If no addresses are
     * found the method returns an empty array.
     */
    @Override
    public Address[] getRecipients(RecipientType type) throws MessagingException
    {
        if (type == RecipientType.TO)
        {
            if (mTo == null)
            {
                mTo = Address.parse(MimeUtility.unfold(getFirstHeader(""To"")));
            }
            return mTo;
        }
        else if (type == RecipientType.CC)
        {
            if (mCc == null)
            {
                mCc = Address.parse(MimeUtility.unfold(getFirstHeader(""CC"")));
            }
            return mCc;
        }
        else if (type == RecipientType.BCC)
        {
            if (mBcc == null)
            {
                mBcc = Address.parse(MimeUtility.unfold(getFirstHeader(""BCC"")));
            }
            return mBcc;
        }
        else
        {
            throw new MessagingException(""Unrecognized recipient type."");
        }
    }

    @Override
    public void setRecipients(RecipientType type, Address[] addresses) throws MessagingException
    {
        if (type == RecipientType.TO)
        {
            if (addresses == null || addresses.length == 0)
            {
                removeHeader(""To"");
                this.mTo = null;
            }
            else
            {
                setHeader(""To"", Address.toEncodedString(addresses));
                this.mTo = addresses;
            }
        }
        else if (type == RecipientType.CC)
        {
            if (addresses == null || addresses.length == 0)
            {
                removeHeader(""CC"");
                this.mCc = null;
            }
            else
            {
                setHeader(""CC"", Address.toEncodedString(addresses));
                this.mCc = addresses;
            }
        }
        else if (type == RecipientType.BCC)
        {
            if (addresses == null || addresses.length == 0)
            {
                removeHeader(""BCC"");
                this.mBcc = null;
            }
            else
            {
                setHeader(""BCC"", Address.toEncodedString(addresses));
                this.mBcc = addresses;
            }
        }
        else
        {
            throw new MessagingException(""Unrecognized recipient type."");
        }
    }

    /**
     * Returns the unfolded, decoded value of the Subject header.
     */
    @Override
    public String getSubject() throws MessagingException
    {
        return MimeUtility.unfoldAndDecode(getFirstHeader(""Subject""));
    }

    @Override
    public void setSubject(String subject) throws MessagingException
    {
        setHeader(""Subject"", subject);
    }

    @Override
    public Address[] getFrom() throws MessagingException
    {
        if (mFrom == null)
        {
            String list = MimeUtility.unfold(getFirstHeader(""From""));
            if (list == null || list.length() == 0)
            {
                list = MimeUtility.unfold(getFirstHeader(""Sender""));
            }
            mFrom = Address.parse(list);
        }
        return mFrom;
    }

    @Override
    public void setFrom(Address from) throws MessagingException
    {
        if (from != null)
        {
            setHeader(""From"", from.toEncodedString());
            this.mFrom = new Address[]
            {
                from
            };
        }
        else
        {
            this.mFrom = null;
        }
    }

    @Override
    public Address[] getReplyTo() throws MessagingException
    {
        if (mReplyTo == null)
        {
            mReplyTo = Address.parse(MimeUtility.unfold(getFirstHeader(""Reply-to"")));
        }
        return mReplyTo;
    }

    @Override
    public void setReplyTo(Address[] replyTo) throws MessagingException
    {
        if (replyTo == null || replyTo.length == 0)
        {
            removeHeader(""Reply-to"");
            mReplyTo = null;
        }
        else
        {
            setHeader(""Reply-to"", Address.toEncodedString(replyTo));
            mReplyTo = replyTo;
        }
    }

    @Override
    public String getMessageId() throws MessagingException
    {
        if (mMessageId == null)
        {
            mMessageId = getFirstHeader(""Message-ID"");
        }
        if (mMessageId == null) //  even after checking the header
        {
            setMessageId(generateMessageId());
        }
        return mMessageId;
    }

    private String generateMessageId()
    {
        return ""<""+UUID.randomUUID().toString()+""@email.android.com>"";
    }

    public void setMessageId(String messageId)
    {
        setHeader(""Message-ID"", messageId);
        mMessageId = messageId;
    }

    @Override
    public void setInReplyTo(String inReplyTo) throws MessagingException
    {
        setHeader(""In-Reply-To"", inReplyTo);
    }

    @Override
    public String[] getReferences() throws MessagingException
    {
        if (mReferences == null)
        {
            mReferences = getHeader(""References"");
        }
        return mReferences;
    }

    @Override
    public void setReferences(String references) throws MessagingException
    {
        /*
         * Make sure the References header doesn't exceed the maximum header
         * line length and won't get (Q-)encoded later. Otherwise some clients
         * will break threads apart.
         *
         * For more information see issue 1559.
         */

        // Make sure separator is SPACE to prevent Q-encoding when TAB is encountered
        references = references.replaceAll(""\\s+"", "" "");

        /*
         * NOTE: Usually the maximum header line is 998 + CRLF = 1000 characters.
         * But at least one implementations seems to have problems with 998
         * characters, so we adjust for that fact.
         */
        final int limit = 1000 - 2 /* CRLF */ - 12 /* ""References: "" */ - 1 /* Off-by-one bugs */;
        final int originalLength = references.length();
        if (originalLength >= limit)
        {
            // Find start of first reference
            final int start = references.indexOf('<');

            // First reference + SPACE
            final String firstReference = references.substring(start,
                                          references.indexOf('<', start + 1));

            // Find longest tail
            final String tail = references.substring(references.indexOf('<',
                                firstReference.length() + originalLength - limit));

            references = firstReference + tail;
        }
        setHeader(""References"", references);
    }

    @Override
    public void saveChanges() throws MessagingException
    {
        throw new MessagingException(""saveChanges not yet implemented"");
    }

    @Override
    public Body getBody() throws MessagingException
    {
        return mBody;
    }

    @Override
    public void setBody(Body body) throws MessagingException
    {
        this.mBody = body;
        setHeader(""MIME-Version"", ""1.0"");
        if (body instanceof Multipart)
        {
            Multipart multipart = ((Multipart)body);
            multipart.setParent(this);
            setHeader(MimeHeader.HEADER_CONTENT_TYPE, multipart.getContentType());
        }
        else if (body instanceof TextBody)
        {
            setHeader(MimeHeader.HEADER_CONTENT_TYPE, String.format(""%s;\n charset=utf-8"",
                      getMimeType()));
            setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, ""quoted-printable"");
        }
    }

    protected String getFirstHeader(String name)
    {
        return mHeader.getFirstHeader(name);
    }

    @Override
    public void addHeader(String name, String value)
    {
        mHeader.addHeader(name, value);
    }

    @Override
    public void setHeader(String name, String value)
    {
        mHeader.setHeader(name, value);
    }

    @Override
    public String[] getHeader(String name)
    {
        return mHeader.getHeader(name);
    }

    @Override
    public void removeHeader(String name)
    {
        mHeader.removeHeader(name);
    }

    @Override
    public Set<String> getHeaderNames()
    {
        return mHeader.getHeaderNames();
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException
    {

        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out), 1024);
        mHeader.writeTo(out);
        writer.write(""\r\n"");
        writer.flush();
        if (mBody != null)
        {
            mBody.writeTo(out);
        }
    }

    public InputStream getInputStream() throws MessagingException
    {
        return null;
    }

    @Override
    public void setEncoding(String encoding)
    {
        if (mBody instanceof Multipart)
        {
            ((Multipart)mBody).setEncoding(encoding);
        }
        else if (mBody instanceof TextBody)
        {
            setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, encoding);
            ((TextBody)mBody).setEncoding(encoding);
        }
    }

    class MimeMessageBuilder implements ContentHandler
    {
        private Stack<Object> stack = new Stack<Object>();

        public MimeMessageBuilder()
        {
        }

        private void expect(Class<?> c)
        {
            if (!c.isInstance(stack.peek()))
            {
                throw new IllegalStateException(""Internal stack error: "" + ""Expected '""
                                                + c.getName() + ""' found '"" + stack.peek().getClass().getName() + ""'"");
            }
        }

        public void startMessage()
        {
            if (stack.isEmpty())
            {
                stack.push(MimeMessage.this);
            }
            else
            {
                expect(Part.class);
                try
                {
                    MimeMessage m = new MimeMessage();
                    ((Part)stack.peek()).setBody(m);
                    stack.push(m);
                }
                catch (MessagingException me)
                {
                    throw new Error(me);
                }
            }
        }

        public void endMessage()
        {
            expect(MimeMessage.class);
            stack.pop();
        }

        public void startHeader()
        {
            expect(Part.class);
        }

        public void field(String fieldData)
        {
            expect(Part.class);
            try
            {
                String[] tokens = fieldData.split("":"", 2);
                ((Part)stack.peek()).addHeader(tokens[0], tokens[1].trim());
            }
            catch (MessagingException me)
            {
                throw new Error(me);
            }
        }

        public void endHeader()
        {
            expect(Part.class);
        }

        public void startMultipart(BodyDescriptor bd)
        {
            expect(Part.class);

            Part e = (Part)stack.peek();
            try
            {
                MimeMultipart multiPart = new MimeMultipart(e.getContentType());
                e.setBody(multiPart);
                stack.push(multiPart);
            }
            catch (MessagingException me)
            {
                throw new Error(me);
            }
        }

        public void body(BodyDescriptor bd, InputStream in) throws IOException
        {
            expect(Part.class);
            Body body = MimeUtility.decodeBody(in, bd.getTransferEncoding());
            try
            {
                ((Part)stack.peek()).setBody(body);
            }
            catch (MessagingException me)
            {
                throw new Error(me);
            }
        }

        public void endMultipart()
        {
            stack.pop();
        }

        public void startBodyPart()
        {
            expect(MimeMultipart.class);

            try
            {
                MimeBodyPart bodyPart = new MimeBodyPart();
                ((MimeMultipart)stack.peek()).addBodyPart(bodyPart);
                stack.push(bodyPart);
            }
            catch (MessagingException me)
            {
                throw new Error(me);
            }
        }

        public void endBodyPart()
        {
            expect(BodyPart.class);
            stack.pop();
        }

        public void epilogue(InputStream is) throws IOException
        {
            expect(MimeMultipart.class);
            StringBuffer sb = new StringBuffer();
            int b;
            while ((b = is.read()) != -1)
            {
                sb.append((char)b);
            }
            // ((Multipart) stack.peek()).setEpilogue(sb.toString());
        }

        public void preamble(InputStream is) throws IOException
        {
            expect(MimeMultipart.class);
            StringBuffer sb = new StringBuffer();
            int b;
            while ((b = is.read()) != -1)
            {
                sb.append((char)b);
            }
            try
            {
                ((MimeMultipart)stack.peek()).setPreamble(sb.toString());
            }
            catch (MessagingException me)
            {
                throw new Error(me);
            }
        }

        public void raw(InputStream is) throws IOException
        {
            throw new UnsupportedOperationException(""Not supported"");
        }
    }
}
",True,216,0,0,9,57,7,17,L1
117,com.fsck.k9.mail.internet.MimeHeader.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.MessagingException;
import org.apache.james.mime4j.codec.EncoderUtil;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.*;

public class MimeHeader
{
    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    /**
     * Application specific header that contains Store specific information about an attachment.
     * In IMAP this contains the IMAP BODYSTRUCTURE part id so that the ImapStore can later
     * retrieve the attachment at will from the server.
     * The info is recorded from this header on LocalStore.appendMessages and is put back
     * into the MIME data by LocalStore.fetch.
     */
    public static final String HEADER_ANDROID_ATTACHMENT_STORE_DATA = ""X-Android-Attachment-StoreData"";

    public static final String HEADER_CONTENT_TYPE = ""Content-Type"";
    public static final String HEADER_CONTENT_TRANSFER_ENCODING = ""Content-Transfer-Encoding"";
    public static final String HEADER_CONTENT_DISPOSITION = ""Content-Disposition"";
    public static final String HEADER_CONTENT_ID = ""Content-ID"";

    /**
     * Fields that should be omitted when writing the header using writeTo()
     */
    private static final String[] writeOmitFields =
    {
//        HEADER_ANDROID_ATTACHMENT_DOWNLOADED,
//        HEADER_ANDROID_ATTACHMENT_ID,
        HEADER_ANDROID_ATTACHMENT_STORE_DATA
    };

    protected ArrayList<Field> mFields = new ArrayList<Field>();

    public void clear()
    {
        mFields.clear();
    }

    public String getFirstHeader(String name)
    {
        String[] header = getHeader(name);
        if (header == null)
        {
            return null;
        }
        return header[0];
    }

    public void addHeader(String name, String value)
    {
        mFields.add(new Field(name, MimeUtility.foldAndEncode(value)));
    }

    public void setHeader(String name, String value)
    {
        if (name == null || value == null)
        {
            return;
        }
        removeHeader(name);
        addHeader(name, value);
    }

    public Set<String> getHeaderNames()
    {
        Set<String> names = new HashSet<String>();
        for (Field field : mFields)
        {
            names.add(field.name);
        }
        return names;
    }

    public String[] getHeader(String name)
    {
        ArrayList<String> values = new ArrayList<String>();
        for (Field field : mFields)
        {
            if (field.name.equalsIgnoreCase(name))
            {
                values.add(field.value);
            }
        }
        if (values.size() == 0)
        {
            return null;
        }
        return values.toArray(EMPTY_STRING_ARRAY);
    }

    public void removeHeader(String name)
    {
        ArrayList<Field> removeFields = new ArrayList<Field>();
        for (Field field : mFields)
        {
            if (field.name.equalsIgnoreCase(name))
            {
                removeFields.add(field);
            }
        }
        mFields.removeAll(removeFields);
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException
    {
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out), 1024);
        for (Field field : mFields)
        {
            if (!Utility.arrayContains(writeOmitFields, field.name))
            {
                String v = field.value;

                if (hasToBeEncoded(v))
                {
                    v = EncoderUtil.encodeEncodedWord(
                            field.value,
                            EncoderUtil.Usage.WORD_ENTITY
                        );
                }

                writer.write(field.name + "": "" + v + ""\r\n"");
            }
        }
        writer.flush();
    }

    // encode non printable characters except LF/CR codes.
    public boolean hasToBeEncoded(String text)
    {
        for (int i = 0; i < text.length(); i++)
        {
            char c = text.charAt(i);
            if (c < 0x20 || 0x7e < c)   // non printable
            {
                if (c != 0x0a && c != 0x0d)   // non LF/CR
                {
                    return true;
                }
            }
        }

        return false;
    }

    class Field
    {
        String name;

        String value;

        public Field(String name, String value)
        {
            this.name = name;
            this.value = value;
        }

        public String toString()
        {
            StringBuilder sb = new StringBuilder(""("");
            sb.append(name).append('=').append(value).append(')');
            return sb.toString();
        }
    }
}
",True,216,0,0,10,57,6,4,L1
118,com.fsck.k9.mail.internet.MimeBodyPart.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.Body;
import com.fsck.k9.mail.BodyPart;
import com.fsck.k9.mail.MessagingException;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

/**
 * TODO this is a close approximation of Message, need to update along with
 * Message.
 */
public class MimeBodyPart extends BodyPart
{
    protected MimeHeader mHeader = new MimeHeader();
    protected Body mBody;
    protected int mSize;

    public MimeBodyPart() throws MessagingException
    {
        this(null);
    }

    public MimeBodyPart(Body body) throws MessagingException
    {
        this(body, null);
    }

    public MimeBodyPart(Body body, String mimeType) throws MessagingException
    {
        if (mimeType != null)
        {
            addHeader(MimeHeader.HEADER_CONTENT_TYPE, mimeType);
        }
        setBody(body);
    }

    protected String getFirstHeader(String name) throws MessagingException
    {
        return mHeader.getFirstHeader(name);
    }

    public void addHeader(String name, String value) throws MessagingException
    {
        mHeader.addHeader(name, value);
    }

    public void setHeader(String name, String value) throws MessagingException
    {
        mHeader.setHeader(name, value);
    }

    public String[] getHeader(String name) throws MessagingException
    {
        return mHeader.getHeader(name);
    }

    public void removeHeader(String name) throws MessagingException
    {
        mHeader.removeHeader(name);
    }

    public Body getBody() throws MessagingException
    {
        return mBody;
    }

    public void setBody(Body body) throws MessagingException
    {
        this.mBody = body;
        if (body instanceof com.fsck.k9.mail.Multipart)
        {
            com.fsck.k9.mail.Multipart multipart = ((com.fsck.k9.mail.Multipart)body);
            multipart.setParent(this);
            setHeader(MimeHeader.HEADER_CONTENT_TYPE, multipart.getContentType());
        }
        else if (body instanceof TextBody)
        {
            String contentType = String.format(""%s;\n charset=utf-8"", getMimeType());
            String name = MimeUtility.getHeaderParameter(getContentType(), ""name"");
            if (name != null)
            {
                contentType += String.format("";\n name=\""%s\"""", name);
            }
            setHeader(MimeHeader.HEADER_CONTENT_TYPE, contentType);
            setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, ""quoted-printable"");
        }
    }

    public String getContentType() throws MessagingException
    {
        String contentType = getFirstHeader(MimeHeader.HEADER_CONTENT_TYPE);
        if (contentType == null)
        {
            return ""text/plain"";
        }
        else
        {
            return contentType;
        }
    }

    public String getDisposition() throws MessagingException
    {
        String contentDisposition = getFirstHeader(MimeHeader.HEADER_CONTENT_DISPOSITION);
        if (contentDisposition == null)
        {
            return null;
        }
        else
        {
            return contentDisposition;
        }
    }

    public String getContentId() throws MessagingException
    {
        String contentId = getFirstHeader(MimeHeader.HEADER_CONTENT_ID);
        if (contentId == null)
        {
            return null;
        }
        else
        {
            int first = contentId.indexOf('<');
            int last = contentId.lastIndexOf('>');
            if (first != -1 && last != -1)
            {
                return contentId.substring(first+1, last);
            }
            else
            {
                return contentId;
            }
        }
    }

    public String getMimeType() throws MessagingException
    {
        return MimeUtility.getHeaderParameter(getContentType(), null);
    }

    public boolean isMimeType(String mimeType) throws MessagingException
    {
        return getMimeType().equals(mimeType);
    }

    public int getSize() throws MessagingException
    {
        return mSize;
    }

    /**
     * Write the MimeMessage out in MIME format.
     */
    public void writeTo(OutputStream out) throws IOException, MessagingException
    {
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out), 1024);
        mHeader.writeTo(out);
        writer.write(""\r\n"");
        writer.flush();
        if (mBody != null)
        {
            mBody.writeTo(out);
        }
    }
}
",False,216,0,0,10,57,4,7,L1
119,com.fsck.k9.mail.internet.BinaryTempFileBody.java,"package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.Body;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.filter.Base64OutputStream;
import org.apache.commons.io.IOUtils;

import java.io.*;

/**
 * A Body that is backed by a temp file. The Body exposes a getOutputStream method that allows
 * the user to write to the temp file. After the write the body is available via getInputStream
 * and writeTo one time. After writeTo is called, or the InputStream returned from
 * getInputStream is closed the file is deleted and the Body should be considered disposed of.
 */
public class BinaryTempFileBody implements Body
{
    private static File mTempDirectory;

    private File mFile;

    public static void setTempDirectory(File tempDirectory)
    {
        mTempDirectory = tempDirectory;
    }

    public BinaryTempFileBody() throws IOException
    {
        if (mTempDirectory == null)
        {
            throw new
            RuntimeException(""setTempDirectory has not been called on BinaryTempFileBody!"");
        }
    }

    public OutputStream getOutputStream() throws IOException
    {
        mFile = File.createTempFile(""body"", null, mTempDirectory);
        mFile.deleteOnExit();
        return new FileOutputStream(mFile);
    }

    public InputStream getInputStream() throws MessagingException
    {
        try
        {
            return new BinaryTempFileBodyInputStream(new FileInputStream(mFile));
        }
        catch (IOException ioe)
        {
            throw new MessagingException(""Unable to open body"", ioe);
        }
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException
    {
        InputStream in = getInputStream();
        Base64OutputStream base64Out = new Base64OutputStream(out);
        IOUtils.copy(in, base64Out);
        base64Out.close();
        mFile.delete();
    }

    class BinaryTempFileBodyInputStream extends FilterInputStream
    {
        public BinaryTempFileBodyInputStream(InputStream in)
        {
            super(in);
        }

        @Override
        public void close() throws IOException
        {
            super.close();
            mFile.delete();
        }
    }
}
",True,99,4,64,2,4,2,4,L1
120,com.fsck.k9.mail.internet.MimeUtility.java,"
package com.fsck.k9.mail.internet;

import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.mail.*;
import org.apache.commons.io.IOUtils;
import org.apache.james.mime4j.decoder.Base64InputStream;
import org.apache.james.mime4j.decoder.DecoderUtil;
import org.apache.james.mime4j.decoder.QuotedPrintableInputStream;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.nio.charset.Charset;


public class MimeUtility
{
    public static final String DEFAULT_ATTACHMENT_MIME_TYPE = ""application/octet-stream"";

    /*
     * http://www.w3schools.com/media/media_mimeref.asp
     * + png
     */
    public static final String[][] MIME_TYPE_BY_EXTENSION_MAP = new String[][]
    {
        { """",       ""application/octet-stream"" },
        { ""323"",    ""text/h323""},
        { ""acx"",    ""application/internet-property-stream""},
        { ""ai"",     ""application/postscript""},
        { ""aif"",    ""audio/x-aiff""},
        { ""aifc"",   ""audio/x-aiff""},
        { ""aiff"",   ""audio/x-aiff""},
        { ""asf"",    ""video/x-ms-asf""},
        { ""asr"",    ""video/x-ms-asf""},
        { ""asx"",    ""video/x-ms-asf""},
        { ""au"",     ""audio/basic""},
        { ""avi"",    ""video/x-msvideo""},
        { ""axs"",    ""application/olescript""},
        { ""bas"",    ""text/plain""},
        { ""bcpio"",  ""application/x-bcpio""},
        { ""bin"",    ""application/octet-stream""},
        { ""bmp"",    ""image/bmp""},
        { ""c"",      ""text/plain""},
        { ""cat"",    ""application/vnd.ms-pkiseccat""},
        { ""cdf"",    ""application/x-cdf""},
        { ""cer"",    ""application/x-x509-ca-cert""},
        { ""class"",  ""application/octet-stream""},
        { ""clp"",    ""application/x-msclip""},
        { ""cmx"",    ""image/x-cmx""},
        { ""cod"",    ""image/cis-cod""},
        { ""cpio"",   ""application/x-cpio""},
        { ""crd"",    ""application/x-mscardfile""},
        { ""crl"",    ""application/pkix-crl""},
        { ""crt"",    ""application/x-x509-ca-cert""},
        { ""csh"",    ""application/x-csh""},
        { ""css"",    ""text/css""},
        { ""dcr"",    ""application/x-director""},
        { ""der"",    ""application/x-x509-ca-cert""},
        { ""dir"",    ""application/x-director""},
        { ""dll"",    ""application/x-msdownload""},
        { ""dms"",    ""application/octet-stream""},
        { ""doc"",    ""application/msword""},
        { ""dot"",    ""application/msword""},
        { ""dvi"",    ""application/x-dvi""},
        { ""dxr"",    ""application/x-director""},
        { ""eps"",    ""application/postscript""},
        { ""etx"",    ""text/x-setext""},
        { ""evy"",    ""application/envoy""},
        { ""exe"",    ""application/octet-stream""},
        { ""fif"",    ""application/fractals""},
        { ""flr"",    ""x-world/x-vrml""},
        { ""gif"",    ""image/gif""},
        { ""gtar"",   ""application/x-gtar""},
        { ""gz"",     ""application/x-gzip""},
        { ""h"",      ""text/plain""},
        { ""hdf"",    ""application/x-hdf""},
        { ""hlp"",    ""application/winhlp""},
        { ""hqx"",    ""application/mac-binhex40""},
        { ""hta"",    ""application/hta""},
        { ""htc"",    ""text/x-component""},
        { ""htm"",    ""text/html""},
        { ""html"",   ""text/html""},
        { ""htt"",    ""text/webviewhtml""},
        { ""ico"",    ""image/x-icon""},
        { ""ief"",    ""image/ief""},
        { ""iii"",    ""application/x-iphone""},
        { ""ins"",    ""application/x-internet-signup""},
        { ""isp"",    ""application/x-internet-signup""},
        { ""jfif"",   ""image/pipeg""},
        { ""jpe"",    ""image/jpeg""},
        { ""jpeg"",   ""image/jpeg""},
        { ""jpg"",    ""image/jpeg""},
        { ""js"",     ""application/x-javascript""},
        { ""latex"",  ""application/x-latex""},
        { ""lha"",    ""application/octet-stream""},
        { ""lsf"",    ""video/x-la-asf""},
        { ""lsx"",    ""video/x-la-asf""},
        { ""lzh"",    ""application/octet-stream""},
        { ""m13"",    ""application/x-msmediaview""},
        { ""m14"",    ""application/x-msmediaview""},
        { ""m3u"",    ""audio/x-mpegurl""},
        { ""man"",    ""application/x-troff-man""},
        { ""mdb"",    ""application/x-msaccess""},
        { ""me"",     ""application/x-troff-me""},
        { ""mht"",    ""message/rfc822""},
        { ""mhtml"",  ""message/rfc822""},
        { ""mid"",    ""audio/mid""},
        { ""mny"",    ""application/x-msmoney""},
        { ""mov"",    ""video/quicktime""},
        { ""movie"",  ""video/x-sgi-movie""},
        { ""mp2"",    ""video/mpeg""},
        { ""mp3"",    ""audio/mpeg""},
        { ""mpa"",    ""video/mpeg""},
        { ""mpe"",    ""video/mpeg""},
        { ""mpeg"",   ""video/mpeg""},
        { ""mpg"",    ""video/mpeg""},
        { ""mpp"",    ""application/vnd.ms-project""},
        { ""mpv2"",   ""video/mpeg""},
        { ""ms"",     ""application/x-troff-ms""},
        { ""mvb"",    ""application/x-msmediaview""},
        { ""nws"",    ""message/rfc822""},
        { ""oda"",    ""application/oda""},
        { ""p10"",    ""application/pkcs10""},
        { ""p12"",    ""application/x-pkcs12""},
        { ""p7b"",    ""application/x-pkcs7-certificates""},
        { ""p7c"",    ""application/x-pkcs7-mime""},
        { ""p7m"",    ""application/x-pkcs7-mime""},
        { ""p7r"",    ""application/x-pkcs7-certreqresp""},
        { ""p7s"",    ""application/x-pkcs7-signature""},
        { ""pbm"",    ""image/x-portable-bitmap""},
        { ""pdf"",    ""application/pdf""},
        { ""pfx"",    ""application/x-pkcs12""},
        { ""pgm"",    ""image/x-portable-graymap""},
        { ""pko"",    ""application/ynd.ms-pkipko""},
        { ""pma"",    ""application/x-perfmon""},
        { ""pmc"",    ""application/x-perfmon""},
        { ""pml"",    ""application/x-perfmon""},
        { ""pmr"",    ""application/x-perfmon""},
        { ""pmw"",    ""application/x-perfmon""},
        { ""png"",    ""image/png""},
        { ""pnm"",    ""image/x-portable-anymap""},
        { ""pot,"",   ""application/vnd.ms-powerpoint""},
        { ""ppm"",    ""image/x-portable-pixmap""},
        { ""pps"",    ""application/vnd.ms-powerpoint""},
        { ""ppt"",    ""application/vnd.ms-powerpoint""},
        { ""prf"",    ""application/pics-rules""},
        { ""ps"",     ""application/postscript""},
        { ""pub"",    ""application/x-mspublisher""},
        { ""qt"",     ""video/quicktime""},
        { ""ra"",     ""audio/x-pn-realaudio""},
        { ""ram"",    ""audio/x-pn-realaudio""},
        { ""ras"",    ""image/x-cmu-raster""},
        { ""rgb"",    ""image/x-rgb""},
        { ""rmi"",    ""audio/mid""},
        { ""roff"",   ""application/x-troff""},
        { ""rtf"",    ""application/rtf""},
        { ""rtx"",    ""text/richtext""},
        { ""scd"",    ""application/x-msschedule""},
        { ""sct"",    ""text/scriptlet""},
        { ""setpay"", ""application/set-payment-initiation""},
        { ""setreg"", ""application/set-registration-initiation""},
        { ""sh"",     ""application/x-sh""},
        { ""shar"",   ""application/x-shar""},
        { ""sit"",    ""application/x-stuffit""},
        { ""snd"",    ""audio/basic""},
        { ""spc"",    ""application/x-pkcs7-certificates""},
        { ""spl"",    ""application/futuresplash""},
        { ""src"",    ""application/x-wais-source""},
        { ""sst"",    ""application/vnd.ms-pkicertstore""},
        { ""stl"",    ""application/vnd.ms-pkistl""},
        { ""stm"",    ""text/html""},
        { ""svg"",    ""image/svg+xml""},
        { ""sv4cpio"",""application/x-sv4cpio""},
        { ""sv4crc"", ""application/x-sv4crc""},
        { ""swf"",    ""application/x-shockwave-flash""},
        { ""t"",      ""application/x-troff""},
        { ""tar"",    ""application/x-tar""},
        { ""tcl"",    ""application/x-tcl""},
        { ""tex"",    ""application/x-tex""},
        { ""texi"",   ""application/x-texinfo""},
        { ""texinfo"",""application/x-texinfo""},
        { ""tgz"",    ""application/x-compressed""},
        { ""tif"",    ""image/tiff""},
        { ""tiff"",   ""image/tiff""},
        { ""tr"",     ""application/x-troff""},
        { ""trm"",    ""application/x-msterminal""},
        { ""tsv"",    ""text/tab-separated-values""},
        { ""txt"",    ""text/plain""},
        { ""uls"",    ""text/iuls""},
        { ""ustar"",  ""application/x-ustar""},
        { ""vcf"",    ""text/x-vcard""},
        { ""vrml"",   ""x-world/x-vrml""},
        { ""wav"",    ""audio/x-wav""},
        { ""wcm"",    ""application/vnd.ms-works""},
        { ""wdb"",    ""application/vnd.ms-works""},
        { ""wks"",    ""application/vnd.ms-works""},
        { ""wmf"",    ""application/x-msmetafile""},
        { ""wps"",    ""application/vnd.ms-works""},
        { ""wri"",    ""application/x-mswrite""},
        { ""wrl"",    ""x-world/x-vrml""},
        { ""wrz"",    ""x-world/x-vrml""},
        { ""xaf"",    ""x-world/x-vrml""},
        { ""xbm"",    ""image/x-xbitmap""},
        { ""xla"",    ""application/vnd.ms-excel""},
        { ""xlc"",    ""application/vnd.ms-excel""},
        { ""xlm"",    ""application/vnd.ms-excel""},
        { ""xls"",    ""application/vnd.ms-excel""},
        { ""xlt"",    ""application/vnd.ms-excel""},
        { ""xlw"",    ""application/vnd.ms-excel""},
        { ""xof"",    ""x-world/x-vrml""},
        { ""xpm"",    ""image/x-xpixmap""},
        { ""xwd"",    ""image/x-xwindowdump""},
        { ""z"",      ""application/x-compress""},
        { ""zip"",    ""application/zip""}
    };

    public static String unfold(String s)
    {
        if (s == null)
        {
            return null;
        }
        return s.replaceAll(""\r|\n"", """");
    }

    public static String decode(String s)
    {
        if (s == null)
        {
            return null;
        }
        return DecoderUtil.decodeEncodedWords(s);
    }

    public static String unfoldAndDecode(String s)
    {
        return decode(unfold(s));
    }

    // TODO implement proper foldAndEncode
    public static String foldAndEncode(String s)
    {
        return s;
    }

    /**
     * Returns the named parameter of a header field. If name is null the first
     * parameter is returned, or if there are no additional parameters in the
     * field the entire field is returned. Otherwise the named parameter is
     * searched for in a case insensitive fashion and returned. If the parameter
     * cannot be found the method returns null.
     *
     * @param header
     * @param name
     * @return
     */
    public static String getHeaderParameter(String header, String name)
    {
        if (header == null)
        {
            return null;
        }
        header = header.replaceAll(""\r|\n"", """");
        String[] parts = header.split("";"");
        if (name == null)
        {
            return parts[0];
        }
        for (String part : parts)
        {
            if (part.trim().toLowerCase().startsWith(name.toLowerCase()))
            {
                String parameter = part.split(""="", 2)[1].trim();
                if (parameter.startsWith(""\"""") && parameter.endsWith(""\""""))
                {
                    return parameter.substring(1, parameter.length() - 1);
                }
                else
                {
                    return parameter;
                }
            }
        }
        return null;
    }

    public static Part findFirstPartByMimeType(Part part, String mimeType)
    throws MessagingException
    {
        if (part.getBody() instanceof Multipart)
        {
            Multipart multipart = (Multipart)part.getBody();
            for (int i = 0, count = multipart.getCount(); i < count; i++)
            {
                BodyPart bodyPart = multipart.getBodyPart(i);
                Part ret = findFirstPartByMimeType(bodyPart, mimeType);
                if (ret != null)
                {
                    return ret;
                }
            }
        }
        else if (part.getMimeType().equalsIgnoreCase(mimeType))
        {
            return part;
        }
        return null;
    }

    public static Part findPartByContentId(Part part, String contentId) throws Exception
    {
        if (part.getBody() instanceof Multipart)
        {
            Multipart multipart = (Multipart)part.getBody();
            for (int i = 0, count = multipart.getCount(); i < count; i++)
            {
                BodyPart bodyPart = multipart.getBodyPart(i);
                Part ret = findPartByContentId(bodyPart, contentId);
                if (ret != null)
                {
                    return ret;
                }
            }
        }
        String[] header = part.getHeader(""Content-ID"");
        if (header != null)
        {
            for (String s : header)
            {
                if (s.equals(contentId))
                {
                    return part;
                }
            }
        }
        return null;
    }

    /**
      * Reads the Part's body and returns a String based on any charset conversion that needed
      * to be done.
      * @param part The part containing a body
      * @return a String containing the converted text in the body, or null if there was no text
      * or an error during conversion.
      */
    public static String getTextFromPart(Part part)
    {
        try
        {
            if ((part != null) && (part.getBody() != null))
            {
                final Body body = part.getBody();
                if (body instanceof TextBody)
                {
                    return ((TextBody)body).getText();
                }

                final String mimeType = part.getMimeType();
                if ((mimeType != null) && MimeUtility.mimeTypeMatches(mimeType, ""text/*""))
                {
                    /*
                     * We've got a text part, so let's see if it needs to be processed further.
                     */
                    final String originalCharset = getHeaderParameter(part.getContentType(), ""charset"");
                    String charset = ""ASCII"";   // No encoding, so use us-ascii, which is the standard.
                    if ((originalCharset != null) && (""0"".equals(originalCharset) == false))
                    {
                        /*
                         * See if there is conversion from the MIME charset to the Java one.
                         */

                        charset = Charset.forName(fixupCharset(originalCharset)).name();

                        if (charset == null)
                        {
                            Log.e(K9.LOG_TAG,""I don't know how to deal with the charset ""+originalCharset+"". Falling back to US-ASCII"");
                            charset = ""US-ASCII"";
                        }
                    }

                    /*
                     * Now we read the part into a buffer for further processing. Because
                     * the stream is now wrapped we'll remove any transfer encoding at this point.
                     */
                    InputStream in = part.getBody().getInputStream();
                    ByteArrayOutputStream out = new ByteArrayOutputStream(in.available());
                    IOUtils.copy(in, out);
                    in.close();
                    in = null;      // we want all of our memory back, and close might not release
                    // Cargo culted from AOSP - This disagrees with the platform docs

                    /*
                     * Convert and return as new String
                     */
                    final String result = out.toString(charset);
                    out.close();
                    return result;
                }
            }

        }
        catch (OutOfMemoryError oom)
        {
            /*
             * If we are not able to process the body there's nothing we can do about it. Return
             * null and let the upper layers handle the missing content.
             */
            Log.e(K9.LOG_TAG, ""Unable to getTextFromPart "" + oom.toString());
        }
        catch (Exception e)
        {
            /*
             * If we are not able to process the body there's nothing we can do about it. Return
             * null and let the upper layers handle the missing content.
             */
            Log.e(K9.LOG_TAG, ""Unable to getTextFromPart"", e);
        }
        return null;
    }

    /**
     * Returns true if the given mimeType matches the matchAgainst specification.
     * @param mimeType A MIME type to check.
     * @param matchAgainst A MIME type to check against. May include wildcards such as image/* or
     * * /*.
     * @return
     */
    public static boolean mimeTypeMatches(String mimeType, String matchAgainst)
    {
        Pattern p = Pattern.compile(matchAgainst.replaceAll(""\\*"", ""\\.\\*""),
                                    Pattern.CASE_INSENSITIVE);
        return p.matcher(mimeType).matches();
    }

    /**
     * Returns true if the given mimeType matches any of the matchAgainst specifications.
     * @param mimeType A MIME type to check.
     * @param matchAgainst An array of MIME types to check against. May include wildcards such
     * as image/* or * /*.
     * @return
     */
    public static boolean mimeTypeMatches(String mimeType, String[] matchAgainst)
    {
        for (String matchType : matchAgainst)
        {
            if (mimeTypeMatches(mimeType, matchType))
            {
                return true;
            }
        }
        return false;
    }

    /**
     * Removes any content transfer encoding from the stream and returns a Body.
     */
    public static Body decodeBody(InputStream in, String contentTransferEncoding)
    throws IOException
    {
        /*
         * We'll remove any transfer encoding by wrapping the stream.
         */
        if (contentTransferEncoding != null)
        {
            contentTransferEncoding =
                MimeUtility.getHeaderParameter(contentTransferEncoding, null);
            if (""quoted-printable"".equalsIgnoreCase(contentTransferEncoding))
            {
                in = new QuotedPrintableInputStream(in);
            }
            else if (""base64"".equalsIgnoreCase(contentTransferEncoding))
            {
                in = new Base64InputStream(in);
            }
        }

        BinaryTempFileBody tempBody = new BinaryTempFileBody();
        OutputStream out = tempBody.getOutputStream();
        IOUtils.copy(in, out);
        out.close();
        return tempBody;
    }

    /**
     * An unfortunately named method that makes decisions about a Part (usually a Message)
     * as to which of it's children will be ""viewable"" and which will be attachments.
     * The method recursively sorts the viewables and attachments into seperate
     * lists for further processing.
     * @param part
     * @param viewables
     * @param attachments
     * @throws MessagingException
     */
    public static void collectParts(Part part, ArrayList<Part> viewables,
                                    ArrayList<Part> attachments) throws MessagingException
    {
        /*
         * If the part is Multipart but not alternative it's either mixed or
         * something we don't know about, which means we treat it as mixed
         * per the spec. We just process it's pieces recursively.
         */
        if (part.getBody() instanceof Multipart)
        {
            Multipart mp = (Multipart)part.getBody();
            for (int i = 0; i < mp.getCount(); i++)
            {
                collectParts(mp.getBodyPart(i), viewables, attachments);
            }
        }
        /*
         * If the part is an embedded message we just continue to process
         * it, pulling any viewables or attachments into the running list.
         */
        else if (part.getBody() instanceof Message)
        {
            Message message = (Message)part.getBody();
            collectParts(message, viewables, attachments);
        }
        /*
         * If the part is HTML and it got this far it's part of a mixed (et
         * al) and should be rendered inline.
         */
        else if (isPartTextualBody(part))
        {
            viewables.add(part);
        }
        else
        {
            attachments.add(part);
        }

    }


    public static Boolean isPartTextualBody(Part part) throws MessagingException
    {
        String disposition = part.getDisposition();
        String dispositionType = null;
        String dispositionFilename = null;
        if (disposition != null)
        {
            dispositionType = MimeUtility.getHeaderParameter(disposition, null);
            dispositionFilename = MimeUtility.getHeaderParameter(disposition, ""filename"");
        }

        /*
         * A best guess that this part is intended to be an attachment and not inline.
         */
        boolean attachment = (""attachment"".equalsIgnoreCase(dispositionType)
                              || (dispositionFilename != null));

        if ((!attachment) && (part.getMimeType().equalsIgnoreCase(""text/html"")))
        {
            return true;
        }
        /*
         * If the part is plain text and it got this far it's part of a
         * mixed (et al) and should be rendered inline.
         */
        else if ((!attachment) && (part.getMimeType().equalsIgnoreCase(""text/plain"")))
        {
            return true;
        }
        /*
         * Finally, if it's nothing else we will include it as an attachment.
         */
        else
        {
            return false;
        }
    }


    public static String getMimeTypeByExtension(String filename)
    {
        if (filename!=null
                && filename.lastIndexOf('.')!=-1)
        {
            String extension = filename.substring(filename.lastIndexOf('.')+1).toLowerCase();
            for (String[] contentTypeMapEntry : MIME_TYPE_BY_EXTENSION_MAP)
            {
                if (contentTypeMapEntry[0].equals(extension))
                {
                    return contentTypeMapEntry[1];
                }
            }
        }
        return DEFAULT_ATTACHMENT_MIME_TYPE;
    }


    private static String fixupCharset(String charset)
    {
        charset = charset.toLowerCase();
        if (charset.equals(""cp932""))
            return ""shift-jis"";
        else if (charset.equals(""koi8-u""))
            return ""koi8-r"";

        return charset;

    }


}
",True,216,0,0,9,57,11,13,L1
121,com.fsck.k9.mail.internet.MimeMultipart.java,"
package com.fsck.k9.mail.internet;

import com.fsck.k9.mail.BodyPart;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Multipart;

import java.io.*;

public class MimeMultipart extends Multipart
{
    protected String mPreamble;

    protected String mContentType;

    protected String mBoundary;

    protected String mSubType;

    public MimeMultipart() throws MessagingException
    {
        mBoundary = generateBoundary();
        setSubType(""mixed"");
    }

    public MimeMultipart(String contentType) throws MessagingException
    {
        this.mContentType = contentType;
        try
        {
            mSubType = MimeUtility.getHeaderParameter(contentType, null).split(""/"")[1];
            mBoundary = MimeUtility.getHeaderParameter(contentType, ""boundary"");
            if (mBoundary == null)
            {
                throw new MessagingException(""MultiPart does not contain boundary: "" + contentType);
            }
        }
        catch (Exception e)
        {
            throw new MessagingException(
                ""Invalid MultiPart Content-Type; must contain subtype and boundary. (""
                + contentType + "")"", e);
        }
    }

    public String generateBoundary()
    {
        StringBuffer sb = new StringBuffer();
        sb.append(""----"");
        for (int i = 0; i < 30; i++)
        {
            sb.append(Integer.toString((int)(Math.random() * 35), 36));
        }
        return sb.toString().toUpperCase();
    }

    public String getPreamble() throws MessagingException
    {
        return mPreamble;
    }

    public void setPreamble(String preamble) throws MessagingException
    {
        this.mPreamble = preamble;
    }

    @Override
    public String getContentType() throws MessagingException
    {
        return mContentType;
    }

    public void setSubType(String subType) throws MessagingException
    {
        this.mSubType = subType;
        mContentType = String.format(""multipart/%s; boundary=\""%s\"""", subType, mBoundary);
    }

    public void writeTo(OutputStream out) throws IOException, MessagingException
    {
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out), 1024);

        if (mPreamble != null)
        {
            writer.write(mPreamble + ""\r\n"");
        }

        if (mParts.size() == 0)
        {
            writer.write(""--"" + mBoundary + ""\r\n"");
        }

        for (int i = 0, count = mParts.size(); i < count; i++)
        {
            BodyPart bodyPart = (BodyPart)mParts.get(i);
            writer.write(""--"" + mBoundary + ""\r\n"");
            writer.flush();
            bodyPart.writeTo(out);
            writer.write(""\r\n"");
        }

        writer.write(""--"" + mBoundary + ""--\r\n"");
        writer.flush();
    }

    public InputStream getInputStream() throws MessagingException
    {
        return null;
    }
}
",True,216,0,0,10,57,4,5,L1
122,com.fsck.k9.mail.store.WebDavStore.java,"package com.fsck.k9.mail.store;

import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.controller.MessageRetrievalListener;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Folder.OpenMode;
import com.fsck.k9.mail.filter.EOLConvertingOutputStream;
import com.fsck.k9.mail.internet.MimeMessage;
import com.fsck.k9.mail.transport.TrustedSocketFactory;
import org.apache.http.*;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.Credentials;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.CookieStore;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.protocol.ExecutionContext;
import org.apache.http.protocol.HttpContext;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;

import javax.net.ssl.SSLException;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.*;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;
import java.util.zip.GZIPInputStream;

/**
 * <pre>
 * Uses WebDAV formatted HTTP calls to an MS Exchange server to fetch emails
 * and email information.  This has only been tested on an MS Exchange
 * Server 2003.  It uses Form-Based authentication and requires that
 * Outlook Web Access be enabled on the server.
 * </pre>
 */
public class WebDavStore extends Store
{
    public static final int CONNECTION_SECURITY_NONE = 0;
    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED, Flag.SEEN, Flag.ANSWERED };

    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    private static final Message[] EMPTY_MESSAGE_ARRAY = new Message[0];

    private int mConnectionSecurity;
    private String mUsername; /* Stores the username for authentications */
    private String alias;
    private String mPassword; /* Stores the password for authentications */
    private String mUrl;      /* Stores the base URL for the server */
    private String mHost;     /* Stores the host name for the server */
    private String mPath;     /* Stores the path for the server */
    private String mAuthPath; /* Stores the path off of the server to post data to for form based authentication */
    private String mMailboxPath; /* Stores the user specified path to the mailbox */
    private URI mUri;         /* Stores the Uniform Resource Indicator with all connection info */
    private String mRedirectUrl;
    private String mAuthString;
    private static String DAV_MAIL_SEND_FOLDER = ""##DavMailSubmissionURI##"";
    private static String DAV_MAIL_TMP_FOLDER = ""drafts"";


    private CookieStore mAuthCookies; /* Stores cookies from authentication */
    private boolean mAuthenticated = false; /* Stores authentication state */
    private long mLastAuth = -1; /* Stores the timestamp of last auth */
    private long mAuthTimeout = 5 * 60;

    private HashMap<String, WebDavFolder> mFolderList = new HashMap<String, WebDavFolder>();
    private boolean mSecure;
    private WebDavHttpClient mHttpClient = null;

    /**
     * webdav://user:password@server:port CONNECTION_SECURITY_NONE
     * webdav+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * webdav+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * webdav+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * webdav+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     */
    public WebDavStore(Account account) throws MessagingException
    {
        super(account);

        try
        {
            mUri = new URI(mAccount.getStoreUri());
        }
        catch (URISyntaxException use)
        {
            throw new MessagingException(""Invalid WebDavStore URI"", use);
        }
        String scheme = mUri.getScheme();
        if (scheme.equals(""webdav""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_NONE;
        }
        else if (scheme.equals(""webdav+ssl""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
        }
        else if (scheme.equals(""webdav+ssl+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
        }
        else if (scheme.equals(""webdav+tls""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
        }
        else if (scheme.equals(""webdav+tls+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
        }
        else
        {
            throw new MessagingException(""Unsupported protocol"");
        }

        mHost = mUri.getHost();
        if (mHost.startsWith(""http""))
        {
            String[] hostParts = mHost.split(""://"", 2);
            if (hostParts.length > 1)
            {
                mHost = hostParts[1];
            }
        }

        String[] pathParts = mUri.getPath().split(""\\|"");

        for (int i = 0, count = pathParts.length; i < count; i++)
        {
            if (i == 0)
            {
                if (pathParts[0] != null &&
                        pathParts[0].length() > 1)
                {
                    if (!pathParts[0].substring(1).equals(""""))
                    {
                        mPath = pathParts[0].substring(1);
                    }
                    else
                    {
                        mPath = """";
                    }
                }
                else
                {
                    mPath = """";
                }
            }
            else if (i == 1)
            {
                if (pathParts[1] != null &&
                        pathParts[1].length() > 1)
                {
                    mAuthPath = ""/"" + pathParts[1];
                }
            }
            else if (i == 2)
            {
                if (pathParts[2] != null &&
                        pathParts[2].length() > 1)
                {
                    mMailboxPath = ""/"" + pathParts[2];
                    if (mPath == null ||
                            mPath.equals(""""))
                    {
                        mPath = mMailboxPath;
                    }
                }
            }
        }
        String path = mPath;
        if (path.length() > 0 && !path.startsWith(""/""))
        {
            path = ""/"" + mPath;
        }

        this.mUrl = getRoot() + path;

        if (mUri.getUserInfo() != null)
        {
            try
            {
                String[] userInfoParts = mUri.getUserInfo().split("":"");
                mUsername = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                String userParts[] = mUsername.split(""/"", 2);

                if (userParts.length > 1)
                {
                    alias = userParts[1];
                }
                else
                {
                    alias = mUsername;
                }
                if (userInfoParts.length > 1)
                {
                    mPassword = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
            }
            catch (UnsupportedEncodingException enc)
            {
                // This shouldn't happen since the encoding is hardcoded to UTF-8
                Log.e(K9.LOG_TAG, ""Couldn't urldecode username or password."", enc);
            }
        }
        mSecure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
        mAuthString = ""Basic "" + Utility.base64Encode(mUsername + "":"" + mPassword);
    }

    private String getRoot()
    {
        String root;
        if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED ||
                mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
                mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL ||
                mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL)
        {
            root = ""https"";
        }
        else
        {
            root = ""http"";
        }
        root += ""://"" + mHost + "":"" + mUri.getPort();
        return root;
    }


    @Override
    public void checkSettings() throws MessagingException
    {
        Log.e(K9.LOG_TAG, ""WebDavStore.checkSettings() not implemented"");
    }

    @Override
    public List<? extends Folder> getPersonalNamespaces(boolean forceListAll) throws MessagingException
    {
        LinkedList<Folder> folderList = new LinkedList<Folder>();
        HashMap<String, String> headers = new HashMap<String, String>();
        DataSet dataset = new DataSet();
        String messageBody;
        String[] folderUrls;
        int urlLength;

        /**
         * We have to check authentication here so we have the proper URL stored
         */
        getHttpClient();
        messageBody = getFolderListXml();
        headers.put(""Brief"", ""t"");
        dataset = processRequest(this.mUrl, ""SEARCH"", messageBody, headers);

        folderUrls = dataset.getHrefs();
        urlLength = folderUrls.length;

        for (int i = 0; i < urlLength; i++)
        {
//            Log.i(K9.LOG_TAG, ""folderUrls["" + i + ""] = '"" + folderUrls[i]);
            String[] urlParts = folderUrls[i].split(""/"");
//            Log.i(K9.LOG_TAG, ""urlParts = "" + urlParts);
            String folderName = urlParts[urlParts.length - 1];
            String fullPathName = """";
            WebDavFolder wdFolder;

            if (folderName.equalsIgnoreCase(K9.INBOX))
            {
                folderName = ""INBOX"";
            }
            else
            {
                for (int j = 5, count = urlParts.length; j < count; j++)
                {
                    if (j != 5)
                    {
                        fullPathName = fullPathName + ""/"" + urlParts[j];
                    }
                    else
                    {
                        fullPathName = urlParts[j];
                    }
                }
                try
                {
                    folderName = java.net.URLDecoder.decode(fullPathName, ""UTF-8"");
                }
                catch (UnsupportedEncodingException uee)
                {
                    /** If we don't support UTF-8 there's a problem, don't decode it then */
                    folderName = fullPathName;
                }
            }

            wdFolder = new WebDavFolder(this, folderName);
            wdFolder.setUrl(folderUrls[i]);
            folderList.add(wdFolder);
            this.mFolderList.put(folderName, wdFolder);
        }

        return folderList;
    }

    @Override
    public Folder getFolder(String name) throws MessagingException
    {
        WebDavFolder folder;

        if ((folder = this.mFolderList.get(name)) == null)
        {
            folder = new WebDavFolder(this, name);
        }

        return folder;
    }

    public Folder getSendSpoolFolder() throws MessagingException
    {
        return getFolder(DAV_MAIL_SEND_FOLDER);
    }

    @Override
    public boolean isMoveCapable()
    {
        return true;
    }

    @Override
    public boolean isCopyCapable()
    {
        return true;
    }

    /***************************************************************
     * WebDAV XML Request body retrieval functions
     */

    private String getFolderListXml()
    {
        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""DAV:uid\"", \""DAV:ishidden\""\r\n"");
        buffer.append("" FROM SCOPE('hierarchical traversal of \""""+this.mUrl+""\""')\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=True\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessageCountXml(String messageState)
    {
        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""DAV:visiblecount\""\r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False AND \""urn:schemas:httpmail:read\""=""+messageState+""\r\n"");
        buffer.append("" GROUP BY \""DAV:ishidden\""\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessageEnvelopeXml(String[] uids)
    {
        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""DAV:uid\"", \""DAV:getcontentlength\"","");
        buffer.append("" \""urn:schemas:mailheader:mime-version\"","");
        buffer.append("" \""urn:schemas:mailheader:content-type\"","");
        buffer.append("" \""urn:schemas:mailheader:subject\"","");
        buffer.append("" \""urn:schemas:mailheader:date\"","");
        buffer.append("" \""urn:schemas:mailheader:thread-topic\"","");
        buffer.append("" \""urn:schemas:mailheader:thread-index\"","");
        buffer.append("" \""urn:schemas:mailheader:from\"","");
        buffer.append("" \""urn:schemas:mailheader:to\"","");
        buffer.append("" \""urn:schemas:mailheader:in-reply-to\"","");
        buffer.append("" \""urn:schemas:mailheader:cc\"","");
        buffer.append("" \""urn:schemas:httpmail:read\"""");
        buffer.append("" \r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False AND "");
        for (int i = 0, count = uids.length; i < count; i++)
        {
            if (i != 0)
            {
                buffer.append(""  OR "");
            }
            buffer.append("" \""DAV:uid\""='""+uids[i]+""' "");
        }
        buffer.append(""\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessagesXml()
    {
        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""DAV:uid\""\r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessageUrlsXml(String[] uids)
    {
        StringBuffer buffer = new StringBuffer(600);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""urn:schemas:httpmail:read\"", \""DAV:uid\""\r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False AND "");
        for (int i = 0, count = uids.length; i < count; i++)
        {
            if (i != 0)
            {
                buffer.append(""  OR "");
            }

            buffer.append("" \""DAV:uid\""='""+uids[i]+""' "");

        }
        buffer.append(""\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMessageFlagsXml(String[] uids) throws MessagingException
    {
        if (uids.length == 0)
        {
            throw new MessagingException(""Attempt to get flags on 0 length array for uids"");
        }

        StringBuffer buffer = new StringBuffer(200);
        buffer.append(""<?xml version='1.0' ?>"");
        buffer.append(""<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n"");
        buffer.append(""SELECT \""urn:schemas:httpmail:read\"", \""DAV:uid\""\r\n"");
        buffer.append("" FROM \""\""\r\n"");
        buffer.append("" WHERE \""DAV:ishidden\""=False AND \""DAV:isfolder\""=False AND "");

        for (int i = 0, count = uids.length; i < count; i++)
        {
            if (i != 0)
            {
                buffer.append("" OR "");
            }
            buffer.append("" \""DAV:uid\""='""+uids[i]+""' "");
        }
        buffer.append(""\r\n"");
        buffer.append(""</a:sql></a:searchrequest>\r\n"");
        return buffer.toString();
    }

    private String getMarkMessagesReadXml(String[] urls, boolean read)
    {
        StringBuffer buffer = new StringBuffer(600);
        buffer.append(""<?xml version='1.0' ?>\r\n"");
        buffer.append(""<a:propertyupdate xmlns:a='DAV:' xmlns:b='urn:schemas:httpmail:'>\r\n"");
        buffer.append(""<a:target>\r\n"");
        for (String url : urls)
        {
            buffer.append("" <a:href>""+url+""</a:href>\r\n"");
        }
        buffer.append(""</a:target>\r\n"");
        buffer.append(""<a:set>\r\n"");
        buffer.append("" <a:prop>\r\n"");
        buffer.append(""  <b:read>"" + (read ? ""1"" : ""0"") + ""</b:read>\r\n"");
        buffer.append("" </a:prop>\r\n"");
        buffer.append(""</a:set>\r\n"");
        buffer.append(""</a:propertyupdate>\r\n"");
        return buffer.toString();
    }

    // For flag:
//    http://www.devnewsgroups.net/group/microsoft.public.exchange.development/topic27175.aspx
    //""<m:0x10900003>1</m:0x10900003>"" & _

    private String getMoveOrCopyMessagesReadXml(String[] urls, boolean isMove)
    {

        String action = (isMove ? ""move"" : ""copy"");
        StringBuffer buffer = new StringBuffer(600);
        buffer.append(""<?xml version='1.0' ?>\r\n"");
        buffer.append(""<a:"" + action + "" xmlns:a='DAV:' xmlns:b='urn:schemas:httpmail:'>\r\n"");
        buffer.append(""<a:target>\r\n"");
        for (String url : urls)
        {
            buffer.append("" <a:href>""+url+""</a:href>\r\n"");
        }
        buffer.append(""</a:target>\r\n"");

        buffer.append(""</a:"" + action + "">\r\n"");
        return buffer.toString();
    }

    /***************************************************************
     * Authentication related methods
     */

    /**
     * Performs Form Based authentication regardless of the current
     * authentication state
     * @throws MessagingException
     */
    public void authenticate() throws MessagingException
    {
        try
        {
            doFBA();
            //this.mAuthCookies = doAuthentication(this.mUsername, this.mPassword, this.mUrl);
        }
        catch (IOException ioe)
        {
            Log.e(K9.LOG_TAG, ""Error during authentication: "" + ioe + ""\nStack: "" + processException(ioe));
            throw new MessagingException(""Error during authentication"", ioe);
        }

        if (this.mAuthCookies == null)
        {
            this.mAuthenticated = false;
        }
        else
        {
            this.mAuthenticated = true;
            this.mLastAuth = System.currentTimeMillis()/1000;
        }
    }

    /**
     * Determines if a new authentication is needed.
     * Returns true if new authentication is needed.
     */
    public boolean needAuth()
    {
        boolean status = false;
        long currentTime = -1;
        if (!this.mAuthenticated)
        {
            status = true;
        }

        currentTime = System.currentTimeMillis()/1000;
        if ((currentTime - this.mLastAuth) > (this.mAuthTimeout))
        {
            status = true;
        }
        return status;
    }

    public static String getHttpRequestResponse(HttpEntity request, HttpEntity response) throws IllegalStateException, IOException
    {
        String responseText = """";
        String requestText = """";
        if (response != null)
        {
            BufferedReader reader = new BufferedReader(new InputStreamReader(WebDavHttpClient.getUngzippedContent(response)), 8192);
            String tempText = """";

            while ((tempText = reader.readLine()) != null)
            {
                responseText += tempText;
            }
        }
        if (request != null)
        {
            BufferedReader reader = new BufferedReader(new InputStreamReader(WebDavHttpClient.getUngzippedContent(response)), 8192);
            String tempText = """";

            while ((tempText = reader.readLine()) != null)
            {
                requestText += tempText;
            }
            requestText = requestText.replaceAll(""password=.*?&"", ""password=(omitted)&"");
        }
        return ""Request: "" + requestText +
               ""\n\nResponse: "" + responseText;

    }

    /**
     * Performs the Form Based Authentication
     * Returns the CookieStore object for later use or null
     * @throws MessagingException
     */
    public void doFBA() throws IOException, MessagingException
    {
        /*    public CookieStore doAuthentication(String username, String password,
              String url) throws IOException, MessagingException {*/
        String authPath;
        String url = this.mUrl;
        String username = this.mUsername;
        String password = this.mPassword;
        String[] urlParts = url.split(""/"");
        String finalUrl = """";
        String loginUrl = """";
        String destinationUrl = """";

        if (this.mAuthPath != null &&
                !this.mAuthPath.equals("""") &&
                !this.mAuthPath.equals(""/""))
        {
            authPath = this.mAuthPath;
        }
        else
        {
            authPath = ""/exchweb/bin/auth/owaauth.dll"";
        }

        for (int i = 0; i <= 2; i++)
        {
            if (i != 0)
            {
                finalUrl = finalUrl + ""/"" + urlParts[i];
            }
            else
            {
                finalUrl = urlParts[i];
            }
        }

        if (finalUrl.equals(""""))
        {
            throw new MessagingException(""doFBA failed, unable to construct URL to post login credentials to."");
        }

        loginUrl = finalUrl + authPath;

        try
        {
            /* Browser Client */
            WebDavHttpClient httpclient = mHttpClient;

            /**
             * This is in a separate block because I really don't like how it's done.
             * This basically scrapes the OWA login page for the form submission URL.
             * UGLY!WebDavHttpClient
             * Added an if-check to see if there's a user supplied authentication path for FBA
             */
            if (this.mAuthPath == null ||
                    this.mAuthPath.equals("""") ||
                    this.mAuthPath.equals(""/""))
            {

                httpclient.addRequestInterceptor(new HttpRequestInterceptor()
                {
                    public void process(HttpRequest request, HttpContext context)
                    throws HttpException, IOException
                    {
                        mRedirectUrl = ((HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST)).toURI() + request.getRequestLine().getUri();
                    }
                });
                HashMap<String, String> headers = new HashMap<String, String>();
                InputStream istream = sendRequest(finalUrl, ""GET"", null, headers, false);

                if (istream != null)
                {
                    BufferedReader reader = new BufferedReader(new InputStreamReader(istream), 4096);
                    String tempText = """";
                    boolean matched = false;

                    while ((tempText = reader.readLine()) != null &&
                            !matched)
                    {
                        if (tempText.indexOf("" action"") >= 0)
                        {
                            String[] tagParts = tempText.split(""\"""");
                            if (tagParts[1].lastIndexOf('/') < 0 &&
                                    mRedirectUrl != null &&
                                    !mRedirectUrl.equals(""""))
                            {
                                /* We have to do a multi-stage substring here because of potential GET parameters */
                                mRedirectUrl = mRedirectUrl.substring(0, mRedirectUrl.lastIndexOf('?'));
                                mRedirectUrl = mRedirectUrl.substring(0, mRedirectUrl.lastIndexOf('/'));
                                loginUrl = mRedirectUrl + ""/"" + tagParts[1];
                                this.mAuthPath = ""/"" + tagParts[1];
                            }
                            else
                            {
                                loginUrl = finalUrl + tagParts[1];
                                this.mAuthPath = ""/"" + tagParts[1];
                            }
                        }

                        if (tempText.indexOf(""destination"") >= 0)
                        {
                            String[] tagParts = tempText.split(""value"");
                            if (tagParts[1] != null)
                            {
                                String[] valueParts = tagParts[1].split(""\"""");
                                destinationUrl = valueParts[1];
                                matched = true;
                            }
                        }
                    }
                    istream.close();
                }
            }


            /** Build the POST data to use */
            ArrayList<BasicNameValuePair> pairs = new ArrayList<BasicNameValuePair>();
            pairs.add(new BasicNameValuePair(""username"", username));
            pairs.add(new BasicNameValuePair(""password"", password));
            if (this.mMailboxPath != null &&
                    !this.mMailboxPath.equals(""""))
            {
                pairs.add(new BasicNameValuePair(""destination"", finalUrl + this.mMailboxPath));
            }
            else if (destinationUrl != null &&
                     !destinationUrl.equals(""""))
            {
                pairs.add(new BasicNameValuePair(""destination"", destinationUrl));
            }
            else
            {
                pairs.add(new BasicNameValuePair(""destination"", ""/""));
            }
            pairs.add(new BasicNameValuePair(""flags"", ""0""));
            pairs.add(new BasicNameValuePair(""SubmitCreds"", ""Log+On""));
            pairs.add(new BasicNameValuePair(""forcedownlevel"", ""0""));
            pairs.add(new BasicNameValuePair(""trusted"", ""0""));

            try
            {
                UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(pairs);
                HashMap<String, String> headers = new HashMap<String, String>();
                String tempUrl = """";
                InputStream istream = sendRequest(loginUrl, ""POST"", formEntity, headers, false);

                /** Get the URL for the mailbox and set it for the store */
                if (istream != null)
                {
                    BufferedReader reader = new BufferedReader(new InputStreamReader(istream), 8192);
                    String tempText = """";

                    while ((tempText = reader.readLine()) != null)
                    {
                        if (tempText.indexOf(""BASE href"") >= 0)
                        {
                            String[] tagParts = tempText.split(""\"""");
                            tempUrl = tagParts[1];
                        }
                    }
                }

                if (this.mMailboxPath != null &&
                        !this.mMailboxPath.equals(""""))
                {
                    this.mUrl = finalUrl + ""/"" + this.mMailboxPath + ""/"";
                }
                else if (tempUrl.equals(""""))
                {
                    this.mUrl = finalUrl + ""/Exchange/"" + this.alias + ""/"";
                }
                else
                {
                    this.mUrl = tempUrl;
                }

            }
            catch (UnsupportedEncodingException uee)
            {
                Log.e(K9.LOG_TAG, ""Error encoding POST data for authentication: "" + uee + ""\nTrace: "" + processException(uee));
                throw new MessagingException(""Error encoding POST data for authentication"", uee);
            }
        }
        catch (SSLException e)
        {
            throw new CertificateValidationException(e.getMessage(), e);
        }

        this.mAuthenticated = true;
    }

    public CookieStore getAuthCookies()
    {
        return mAuthCookies;
    }

    public String getAlias()
    {
        return alias;
    }

    public String getUrl()
    {
        return mUrl;
    }

    public WebDavHttpClient getHttpClient() throws MessagingException
    {
        SchemeRegistry reg;
        Scheme s;
        boolean needAuth = false;

        if (mHttpClient == null)
        {
            mHttpClient = new WebDavHttpClient();
            needAuth = true;
        }

        reg = mHttpClient.getConnectionManager().getSchemeRegistry();
        try
        {
            // Log.i(K9.LOG_TAG, ""getHttpClient mHost = "" + mHost);
            s = new Scheme(""https"", new TrustedSocketFactory(mHost, mSecure), 443);
        }
        catch (NoSuchAlgorithmException nsa)
        {
            Log.e(K9.LOG_TAG, ""NoSuchAlgorithmException in getHttpClient: "" + nsa);
            throw new MessagingException(""NoSuchAlgorithmException in getHttpClient: "" + nsa);
        }
        catch (KeyManagementException kme)
        {
            Log.e(K9.LOG_TAG, ""KeyManagementException in getHttpClient: "" + kme);
            throw new MessagingException(""KeyManagementException in getHttpClient: "" + kme);
        }
        reg.register(s);

        if (needAuth)
        {
            HashMap<String, String> headers = new HashMap<String, String>();
            processRequest(this.mUrl, ""GET"", null, headers, false);
        }

        /*
        if (needAuth()) {
            if (!checkAuth()) {
                try {
                    CookieStore cookies = mHttpClient.getCookieStore();
                    cookies.clear();
                    mHttpClient.setCookieStore(cookies);
                    cookies = doAuthentication(this.mUsername, this.mPassword, this.mUrl);
                    if (cookies != null) {
                        this.mAuthenticated = true;
                        this.mLastAuth = System.currentTimeMillis()/1000;
                    }
                    mHttpClient.setCookieStore(cookies);
                } catch (IOException ioe) {
                    Log.e(K9.LOG_TAG, ""IOException: "" + ioe + ""\nTrace: "" + processException(ioe));
                }
            } else {
                Credentials creds = new UsernamePasswordCredentials(mUsername, mPassword);
                CredentialsProvider credsProvider = mHttpClient.getCredentialsProvider();
                credsProvider.setCredentials(new AuthScope(mHost, 80, AuthScope.ANY_REALM), creds);
                credsProvider.setCredentials(new AuthScope(mHost, 443, AuthScope.ANY_REALM), creds);
                credsProvider.setCredentials(new AuthScope(mHost, mUri.getPort(), AuthScope.ANY_REALM), creds);
                mHttpClient.setCredentialsProvider(credsProvider);
                // Assume we're authenticated and ok here since the checkAuth() was 401 and we've now set the credentials
                this.mAuthenticated = true;
                this.mLastAuth = System.currentTimeMillis()/1000;
            }
        }
        */
        return mHttpClient;
    }

    public WebDavHttpClient getTrustedHttpClient() throws KeyManagementException, NoSuchAlgorithmException
    {
        if (mHttpClient == null)
        {
            mHttpClient = new WebDavHttpClient();
            SchemeRegistry reg = mHttpClient.getConnectionManager().getSchemeRegistry();
            Scheme s = new Scheme(""https"",new TrustedSocketFactory(mHost,mSecure),443);
            reg.register(s);


            //Add credentials for NTLM/Digest/Basic Auth
            Credentials creds = new UsernamePasswordCredentials(mUsername, mPassword);
            CredentialsProvider credsProvider  = mHttpClient.getCredentialsProvider();
            // setting AuthScope for 80 and 443, in case we end up getting redirected
            // from 80 to 443.
            credsProvider.setCredentials(new AuthScope(mHost, 80, AuthScope.ANY_REALM), creds);
            credsProvider.setCredentials(new AuthScope(mHost, 443, AuthScope.ANY_REALM), creds);
            credsProvider.setCredentials(new AuthScope(mHost, mUri.getPort(), AuthScope.ANY_REALM), creds);
            mHttpClient.setCredentialsProvider(credsProvider);
        }

        return mHttpClient;
    }

    private InputStream sendRequest(String url, String method, StringEntity messageBody, HashMap<String, String> headers, boolean tryAuth)
    throws MessagingException
    {
        WebDavHttpClient httpclient;
        InputStream istream = null;

        if (url == null ||
                method == null)
        {
            return istream;
        }

        httpclient = getHttpClient();

        try
        {
            int statusCode = -1;
            HttpGeneric httpmethod = new HttpGeneric(url);
            HttpResponse response;
            HttpEntity entity;

            if (messageBody != null)
            {
                httpmethod.setEntity(messageBody);
            }

            for (String headerName : headers.keySet())
            {
                httpmethod.setHeader(headerName, headers.get(headerName));
            }

            if (mAuthString != null && mAuthenticated)
            {
                httpmethod.setHeader(""Authorization"", mAuthString);
            }

            httpmethod.setMethod(method);
            response = httpclient.executeOverride(httpmethod);
            statusCode = response.getStatusLine().getStatusCode();

            entity = response.getEntity();

            if (statusCode == 401)
            {
                if (tryAuth)
                {
                    mAuthenticated = true;
                    sendRequest(url, method, messageBody, headers, false);
                }
                else
                {
                    throw new MessagingException(""Invalid username or password for Basic authentication"");
                }
            }
            else if (statusCode == 440)
            {
                if (tryAuth)
                {
                    doFBA();
                    sendRequest(url, method, messageBody, headers, false);
                }
                else
                {
                    throw new MessagingException(""Authentication failure in sendRequest"");
                }
            }
            else if (statusCode < 200 ||
                     statusCode >= 300)
            {
                throw new IOException(""Error with code "" + statusCode + "" during request processing: ""+
                                      response.getStatusLine().toString());
            }
            else
            {
                if (tryAuth &&
                        !mAuthenticated)
                {
                    doFBA();
                    sendRequest(url, method, messageBody, headers, false);
                }
            }

            if (entity != null)
            {
                istream = WebDavHttpClient.getUngzippedContent(entity);
            }
        }
        catch (UnsupportedEncodingException uee)
        {
            Log.e(K9.LOG_TAG, ""UnsupportedEncodingException: "" + uee + ""\nTrace: "" + processException(uee));
            throw new MessagingException(""UnsupportedEncodingException"", uee);
        }
        catch (IOException ioe)
        {
            Log.e(K9.LOG_TAG, ""IOException: "" + ioe + ""\nTrace: "" + processException(ioe));
            throw new MessagingException(""IOException"", ioe);
        }

        return istream;
    }

    public String getAuthString()
    {
        return mAuthString;
    }

    /**
     * Performs an httprequest to the supplied url using the supplied method.
     * messageBody and headers are optional as not all requests will need them.
     * There are two signatures to support calls that don't require parsing of the response.
     */
    private DataSet processRequest(String url, String method, String messageBody, HashMap<String, String> headers)
    throws MessagingException
    {
        return processRequest(url, method, messageBody, headers, true);
    }

    private DataSet processRequest(String url, String method, String messageBody, HashMap<String, String> headers, boolean needsParsing)
    throws MessagingException
    {
        DataSet dataset = new DataSet();
        if (K9.DEBUG && K9.DEBUG_PROTOCOL_WEBDAV)
        {
            Log.v(K9.LOG_TAG, ""processRequest url = '"" + url + ""', method = '"" + method + ""', messageBody = '"" + messageBody + ""'"");
        }

        if (url == null ||
                method == null)
        {
            return dataset;
        }

        getHttpClient();

        try
        {
            StringEntity messageEntity = null;
            if (messageBody != null)
            {
                messageEntity = new StringEntity(messageBody);
                messageEntity.setContentType(""text/xml"");
                //                httpmethod.setEntity(messageEntity);
            }
            InputStream istream = sendRequest(url, method, messageEntity, headers, true);
            if (istream != null &&
                    needsParsing)
            {
                try
                {
                    SAXParserFactory spf = SAXParserFactory.newInstance();
                    SAXParser sp = spf.newSAXParser();
                    XMLReader xr = sp.getXMLReader();
                    WebDavHandler myHandler = new WebDavHandler();

                    xr.setContentHandler(myHandler);

                    xr.parse(new InputSource(istream));

                    dataset = myHandler.getDataSet();
                }
                catch (SAXException se)
                {
                    Log.e(K9.LOG_TAG, ""SAXException in processRequest() "" + se + ""\nTrace: "" + processException(se));
                    throw new MessagingException(""SAXException in processRequest() "", se);
                }
                catch (ParserConfigurationException pce)
                {
                    Log.e(K9.LOG_TAG, ""ParserConfigurationException in processRequest() "" + pce + ""\nTrace: "" + processException(pce));
                    throw new MessagingException(""ParserConfigurationException in processRequest() "", pce);
                }

                istream.close();
            }
        }
        catch (UnsupportedEncodingException uee)
        {
            Log.e(K9.LOG_TAG, ""UnsupportedEncodingException: "" + uee + ""\nTrace: "" + processException(uee));
            throw new MessagingException(""UnsupportedEncodingException in processRequest() "", uee);
        }
        catch (IOException ioe)
        {
            Log.e(K9.LOG_TAG, ""IOException: "" + ioe + ""\nTrace: "" + processException(ioe));
            throw new MessagingException(""IOException in processRequest() "", ioe);
        }

        return dataset;
    }

    /**
     * Returns a string of the stacktrace for a Throwable to allow for easy inline printing of errors.
     */
    private String processException(Throwable t)
    {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        PrintStream ps = new PrintStream(baos);

        t.printStackTrace(ps);
        ps.close();

        return baos.toString();
    }

    @Override
    public boolean isSendCapable()
    {
        return true;
    }

    @Override
    public void sendMessages(Message[] messages) throws MessagingException
    {
        WebDavFolder tmpFolder = (WebDavStore.WebDavFolder)getFolder(DAV_MAIL_TMP_FOLDER);
        try
        {
            tmpFolder.open(OpenMode.READ_WRITE);
            Message[] retMessages = tmpFolder.appendWebDavMessages(messages);

            tmpFolder.moveMessages(retMessages, getSendSpoolFolder());
        }
        finally
        {
            if (tmpFolder != null)
            {
                tmpFolder.close();
            }
        }
    }

    /*************************************************************************
     * Helper and Inner classes
     */

    /**
     * A WebDav Folder
     */
    class WebDavFolder extends Folder
    {
        private String mName;
        private String mFolderUrl;
        private boolean mIsOpen = false;
        private int mMessageCount = 0;
        private int mUnreadMessageCount = 0;
        private WebDavStore store;

        protected WebDavStore getStore()
        {
            return store;
        }


        public WebDavFolder(WebDavStore nStore, String name)
        {
            super(nStore.getAccount());
            store = nStore;
            this.mName = name;


            if (DAV_MAIL_SEND_FOLDER.equals(name))
            {
                this.mFolderUrl = getUrl() + ""/"" + name +""/"";
            }
            else
            {
                String encodedName = """";
                try
                {
                    String[] urlParts = name.split(""/"");
                    String url = """";
                    for (int i = 0, count = urlParts.length; i < count; i++)
                    {
                        if (i != 0)
                        {
                            url = url + ""/"" + java.net.URLEncoder.encode(urlParts[i], ""UTF-8"");
                        }
                        else
                        {
                            url = java.net.URLEncoder.encode(urlParts[i], ""UTF-8"");
                        }
                    }
                    encodedName = url;
                }
                catch (UnsupportedEncodingException uee)
                {
                    Log.e(K9.LOG_TAG, ""UnsupportedEncodingException URLEncoding folder name, skipping encoded"");
                    encodedName = name;
                }

                encodedName = encodedName.replaceAll(""\\+"", ""%20"");

                /**
                 * In some instances, it is possible that our folder objects have been collected,
                 * but getPersonalNamespaces() isn't called again (ex. Android destroys the email client).
                 * Perform an authentication to get the appropriate URLs in place again
                 */
                // TODO: danapple0 - huh?
                //getHttpClient();

                if (encodedName.equals(""INBOX""))
                {
                    encodedName = ""Inbox"";
                }
                this.mFolderUrl = WebDavStore.this.mUrl;
                if (!WebDavStore.this.mUrl.endsWith(""/""))
                {
                    this.mFolderUrl += ""/"";
                }
                this.mFolderUrl += encodedName;
            }
        }

        public void setUrl(String url)
        {
            if (url != null)
            {
                this.mFolderUrl = url;
            }
        }

        @Override
        public void open(OpenMode mode) throws MessagingException
        {
            getHttpClient();

            this.mIsOpen = true;
        }

        @Override
        public void copyMessages(Message[] messages, Folder folder) throws MessagingException
        {
            moveOrCopyMessages(messages, folder.getName(), false);
        }

        @Override
        public void moveMessages(Message[] messages, Folder folder) throws MessagingException
        {
            moveOrCopyMessages(messages, folder.getName(), true);
        }

        @Override
        public void delete(Message[] msgs, String trashFolderName) throws MessagingException
        {
            moveOrCopyMessages(msgs, trashFolderName, true);
        }
        private void moveOrCopyMessages(Message[] messages, String folderName, boolean isMove) throws MessagingException
        {
            String[] uids = new String[messages.length];

            for (int i = 0, count = messages.length; i < count; i++)
            {
                uids[i] = messages[i].getUid();
            }
            String messageBody = """";
            HashMap<String, String> headers = new HashMap<String, String>();
            HashMap<String, String> uidToUrl = getMessageUrls(uids);
            String[] urls = new String[uids.length];

            for (int i = 0, count = uids.length; i < count; i++)
            {
                urls[i] = uidToUrl.get(uids[i]);
                if (urls[i] == null && messages[i] instanceof WebDavMessage)
                {
                    WebDavMessage wdMessage = (WebDavMessage)messages[i];
                    urls[i] = wdMessage.getUrl();
                }
            }

            messageBody = getMoveOrCopyMessagesReadXml(urls, isMove);
            WebDavFolder destFolder = (WebDavFolder)store.getFolder(folderName);
            headers.put(""Destination"", destFolder.mFolderUrl);
            headers.put(""Brief"", ""t"");
            headers.put(""If-Match"", ""*"");
            String action = (isMove ? ""BMOVE"" : ""BCOPY"");
            Log.i(K9.LOG_TAG, ""Moving "" + messages.length + "" messages to "" + destFolder.mFolderUrl);

            processRequest(mFolderUrl, action, messageBody, headers, false);

        }

        private int getMessageCount(boolean read, CookieStore authCookies) throws MessagingException
        {
            String isRead;
            int messageCount = 0;
            DataSet dataset = new DataSet();
            HashMap<String, String> headers = new HashMap<String, String>();
            String messageBody;

            if (read)
            {
                isRead = ""True"";
            }
            else
            {
                isRead = ""False"";
            }

            messageBody = getMessageCountXml(isRead);
            headers.put(""Brief"", ""t"");
            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);
            if (dataset != null)
            {
                messageCount = dataset.getMessageCount();
            }


            return messageCount;
        }

        @Override
        public int getMessageCount() throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            this.mMessageCount = getMessageCount(true, WebDavStore.this.mAuthCookies);

            return this.mMessageCount;
        }

        @Override
        public int getUnreadMessageCount() throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            this.mUnreadMessageCount = getMessageCount(false, WebDavStore.this.mAuthCookies);

            return this.mUnreadMessageCount;
        }
        @Override
        public int getFlaggedMessageCount() throws MessagingException
        {
            return -1;
        }

        @Override
        public boolean isOpen()
        {
            return this.mIsOpen;
        }

        @Override
        public OpenMode getMode() throws MessagingException
        {
            return OpenMode.READ_WRITE;
        }

        @Override
        public String getName()
        {
            return this.mName;
        }

        @Override
        public boolean exists()
        {
            return true;
        }

        @Override
        public void close()
        {
            this.mMessageCount = 0;
            this.mUnreadMessageCount = 0;

            this.mIsOpen = false;
        }

        @Override
        public boolean create(FolderType type) throws MessagingException
        {
            return true;
        }

        @Override
        public void delete(boolean recursive) throws MessagingException
        {
            throw new Error(""WebDavFolder.delete() not implemeneted"");
        }

        @Override
        public Message getMessage(String uid) throws MessagingException
        {
            return new WebDavMessage(uid, this);
        }

        @Override
        public Message[] getMessages(int start, int end, Date earliestDate, MessageRetrievalListener listener)
        throws MessagingException
        {
            ArrayList<Message> messages = new ArrayList<Message>();
            String[] uids;
            DataSet dataset = new DataSet();
            HashMap<String, String> headers = new HashMap<String, String>();
            int uidsLength = -1;

            String messageBody;
            int prevStart = start;

            /** Reverse the message range since 0 index is newest */
            start = this.mMessageCount - end;
            end = start + (end - prevStart);

            //end = this.mMessageCount - prevStart;

            if (start < 0 || end < 0 || end < start)
            {
                throw new MessagingException(String.format(""Invalid message set %d %d"", start, end));
            }

            if (start == 0 && end < 10)
            {
                end = 10;
            }

            /** Verify authentication */
            messageBody = getMessagesXml();

            headers.put(""Brief"", ""t"");
            headers.put(""Range"", ""rows="" + start + ""-"" + end);
            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);

            uids = dataset.getUids();
            HashMap<String, String> uidToUrl = dataset.getUidToUrl();
            uidsLength = uids.length;

            for (int i = 0; i < uidsLength; i++)
            {
                if (listener != null)
                {
                    listener.messageStarted(uids[i], i, uidsLength);
                }
                WebDavMessage message = new WebDavMessage(uids[i], this);
                message.setUrl(uidToUrl.get(uids[i]));
                messages.add(message);

                if (listener != null)
                {
                    listener.messageFinished(message, i, uidsLength);
                }
            }

            return messages.toArray(EMPTY_MESSAGE_ARRAY);
        }


        @Override
        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException
        {
            return getMessages(null, listener);
        }

        @Override
        public Message[] getMessages(String[] uids, MessageRetrievalListener listener) throws MessagingException
        {
            ArrayList<Message> messageList = new ArrayList<Message>();
            Message[] messages;

            if (uids == null ||
                    uids.length == 0)
            {
                return messageList.toArray(EMPTY_MESSAGE_ARRAY);
            }

            for (int i = 0, count = uids.length; i < count; i++)
            {
                if (listener != null)
                {
                    listener.messageStarted(uids[i], i, count);
                }

                WebDavMessage message = new WebDavMessage(uids[i], this);
                messageList.add(message);

                if (listener != null)
                {
                    listener.messageFinished(message, i, count);
                }
            }
            messages = messageList.toArray(EMPTY_MESSAGE_ARRAY);

            return messages;
        }

        private HashMap<String, String> getMessageUrls(String[] uids) throws MessagingException
        {
            HashMap<String, String> uidToUrl = new HashMap<String, String>();
            HashMap<String, String> headers = new HashMap<String, String>();
            DataSet dataset = new DataSet();
            String messageBody;

            /** Retrieve and parse the XML entity for our messages */
            messageBody = getMessageUrlsXml(uids);
            headers.put(""Brief"", ""t"");

            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);
            uidToUrl = dataset.getUidToUrl();

            return uidToUrl;
        }

        @Override
        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
        throws MessagingException
        {

            if (messages == null ||
                    messages.length == 0)
            {
                return;
            }

            /**
             * Fetch message envelope information for the array
             */
            if (fp.contains(FetchProfile.Item.ENVELOPE))
            {
                fetchEnvelope(messages, listener);
            }
            /**
             * Fetch message flag info for the array
             */
            if (fp.contains(FetchProfile.Item.FLAGS))
            {
                fetchFlags(messages, listener);
            }



            if (fp.contains(FetchProfile.Item.BODY_SANE))
            {
                fetchMessages(messages, listener, (mAccount.getMaximumAutoDownloadMessageSize() / 76));
            }
            if (fp.contains(FetchProfile.Item.BODY))
            {
                fetchMessages(messages, listener, -1);
            }

//            if (fp.contains(FetchProfile.Item.STRUCTURE)) {
//                for (int i = 0, count = messages.length; i < count; i++) {
//                    if (!(messages[i] instanceof WebDavMessage)) {
//                        throw new MessagingException(""WebDavStore fetch called with non-WebDavMessage"");
//                    }
//                    WebDavMessage wdMessage = (WebDavMessage) messages[i];
//
//                    if (listener != null) {
//                        listener.messageStarted(wdMessage.getUid(), i, count);
//                    }
//
//                    wdMessage.setBody(null);
//
//                    if (listener != null) {
//                        listener.messageFinished(wdMessage, i, count);
//                    }
//                }
//            }
        }

        /**
         * Fetches the full messages or up to lines lines and passes them to the message parser.
         */
        private void fetchMessages(Message[] messages, MessageRetrievalListener listener, int lines) throws MessagingException
        {
            WebDavHttpClient httpclient;
            httpclient = getHttpClient();

            /**
             * We can't hand off to processRequest() since we need the stream to parse.
             */
            for (int i = 0, count = messages.length; i < count; i++)
            {
                WebDavMessage wdMessage;
                int statusCode = 0;

                if (!(messages[i] instanceof WebDavMessage))
                {
                    throw new MessagingException(""WebDavStore fetch called with non-WebDavMessage"");
                }

                wdMessage = (WebDavMessage) messages[i];

                if (listener != null)
                {
                    listener.messageStarted(wdMessage.getUid(), i, count);
                }

                /**
                 * If fetch is called outside of the initial list (ie, a locally stored
                 * message), it may not have a URL associated.  Verify and fix that
                 */
                if (wdMessage.getUrl().equals(""""))
                {
                    wdMessage.setUrl(getMessageUrls(new String[] {wdMessage.getUid()}).get(wdMessage.getUid()));
                    Log.i(K9.LOG_TAG, ""Fetching messages with UID = '"" + wdMessage.getUid() + ""', URL = '"" + wdMessage.getUrl() + ""'"");
                    if (wdMessage.getUrl().equals(""""))
                    {
                        throw new MessagingException(""Unable to get URL for message"");
                    }
                }

                try
                {
                    Log.i(K9.LOG_TAG, ""Fetching message with UID = '"" + wdMessage.getUid() + ""', URL = '"" + wdMessage.getUrl() + ""'"");
                    HttpGet httpget = new HttpGet(new URI(wdMessage.getUrl()));
                    HttpResponse response;
                    HttpEntity entity;

                    httpget.setHeader(""translate"", ""f"");
                    if (mAuthString != null && mAuthenticated)
                    {
                        httpget.setHeader(""Authorization"", mAuthString);
                    }
                    response = httpclient.executeOverride(httpget);

                    statusCode = response.getStatusLine().getStatusCode();

                    entity = response.getEntity();

                    if (statusCode < 200 ||
                            statusCode > 300)
                    {
                        throw new IOException(""Error during with code "" + statusCode + "" during fetch: ""
                                              + response.getStatusLine().toString());
                    }

                    if (entity != null)
                    {
                        InputStream istream = null;
                        StringBuffer buffer = new StringBuffer();
                        String tempText = """";
                        String resultText = """";
                        BufferedReader reader;
                        int currentLines = 0;

                        istream = WebDavHttpClient.getUngzippedContent(entity);

                        if (lines != -1)
                        {
                            reader = new BufferedReader(new InputStreamReader(istream), 8192);

                            while ((tempText = reader.readLine()) != null &&
                                    (currentLines < lines))
                            {
                                buffer.append(tempText+""\r\n"");
                                currentLines++;
                            }

                            istream.close();
                            resultText = buffer.toString();
                            istream = new ByteArrayInputStream(resultText.getBytes(""UTF-8""));
                        }

                        wdMessage.parse(istream);
                    }

                }
                catch (IllegalArgumentException iae)
                {
                    Log.e(K9.LOG_TAG, ""IllegalArgumentException caught "" + iae + ""\nTrace: "" + processException(iae));
                    throw new MessagingException(""IllegalArgumentException caught"", iae);
                }
                catch (URISyntaxException use)
                {
                    Log.e(K9.LOG_TAG, ""URISyntaxException caught "" + use + ""\nTrace: "" + processException(use));
                    throw new MessagingException(""URISyntaxException caught"", use);
                }
                catch (IOException ioe)
                {
                    Log.e(K9.LOG_TAG, ""Non-success response code loading message, response code was "" + statusCode + ""\nURL: "" + wdMessage.getUrl() + ""\nError: "" + ioe.getMessage() + ""\nTrace: "" + processException(ioe));
                    throw new MessagingException(""Failure code "" + statusCode, ioe);
                }

                if (listener != null)
                {
                    listener.messageFinished(wdMessage, i, count);
                }
            }
        }

        /**
         * Fetches and sets the message flags for the supplied messages.
         * The idea is to have this be recursive so that we do a series of medium calls
         * instead of one large massive call or a large number of smaller calls.
         */
        private void fetchFlags(Message[] startMessages, MessageRetrievalListener listener) throws MessagingException
        {
            HashMap<String, Boolean> uidToReadStatus = new HashMap<String, Boolean>();
            HashMap<String, String> headers = new HashMap<String, String>();
            DataSet dataset = new DataSet();
            String messageBody = """";
            Message[] messages = new Message[20];
            String[] uids;


            if (startMessages == null ||
                    startMessages.length == 0)
            {
                return;
            }

            if (startMessages.length > 20)
            {
                Message[] newMessages = new Message[startMessages.length - 20];
                for (int i = 0, count = startMessages.length; i < count; i++)
                {
                    if (i < 20)
                    {
                        messages[i] = startMessages[i];
                    }
                    else
                    {
                        newMessages[i - 20] = startMessages[i];
                    }
                }

                fetchFlags(newMessages, listener);
            }
            else
            {
                messages = startMessages;
            }

            uids = new String[messages.length];

            for (int i = 0, count = messages.length; i < count; i++)
            {
                uids[i] = messages[i].getUid();
            }

            messageBody = getMessageFlagsXml(uids);
            headers.put(""Brief"", ""t"");
            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);

            if (dataset == null)
            {
                throw new MessagingException(""Data Set from request was null"");
            }

            uidToReadStatus = dataset.getUidToRead();

            for (int i = 0, count = messages.length; i < count; i++)
            {
                if (!(messages[i] instanceof WebDavMessage))
                {
                    throw new MessagingException(""WebDavStore fetch called with non-WebDavMessage"");
                }
                WebDavMessage wdMessage = (WebDavMessage) messages[i];

                if (listener != null)
                {
                    listener.messageStarted(messages[i].getUid(), i, count);
                }

                wdMessage.setFlagInternal(Flag.SEEN, uidToReadStatus.get(wdMessage.getUid()));

                if (listener != null)
                {
                    listener.messageFinished(messages[i], i, count);
                }
            }
        }

        /**
         * Fetches and parses the message envelopes for the supplied messages.
         * The idea is to have this be recursive so that we do a series of medium calls
         * instead of one large massive call or a large number of smaller calls.
         * Call it a happy balance
         */
        private void fetchEnvelope(Message[] startMessages, MessageRetrievalListener listener) throws MessagingException
        {
            HashMap<String, ParsedMessageEnvelope> envelopes = new HashMap<String, ParsedMessageEnvelope>();
            HashMap<String, String> headers = new HashMap<String, String>();
            DataSet dataset = new DataSet();
            String messageBody = """";
            String[] uids;
            Message[] messages = new Message[10];

            if (startMessages == null ||
                    startMessages.length == 0)
            {
                return;
            }

            if (startMessages.length > 10)
            {
                Message[] newMessages = new Message[startMessages.length - 10];
                for (int i = 0, count = startMessages.length; i < count; i++)
                {
                    if (i < 10)
                    {
                        messages[i] = startMessages[i];
                    }
                    else
                    {
                        newMessages[i - 10] = startMessages[i];
                    }
                }

                fetchEnvelope(newMessages, listener);
            }
            else
            {
                messages = startMessages;
            }

            uids = new String[messages.length];

            for (int i = 0, count = messages.length; i < count; i++)
            {
                uids[i] = messages[i].getUid();
            }

            messageBody = getMessageEnvelopeXml(uids);
            headers.put(""Brief"", ""t"");
            dataset = processRequest(this.mFolderUrl, ""SEARCH"", messageBody, headers);

            envelopes = dataset.getMessageEnvelopes();

            int count = messages.length;
            for (int i = messages.length - 1; i >= 0; i--)
            {
                if (!(messages[i] instanceof WebDavMessage))
                {
                    throw new MessagingException(""WebDavStore fetch called with non-WebDavMessage"");
                }
                WebDavMessage wdMessage = (WebDavMessage) messages[i];

                if (listener != null)
                {
                    listener.messageStarted(messages[i].getUid(), i, count);
                }

                wdMessage.setNewHeaders(envelopes.get(wdMessage.getUid()));
                wdMessage.setFlagInternal(Flag.SEEN, envelopes.get(wdMessage.getUid()).getReadStatus());

                if (listener != null)
                {
                    listener.messageFinished(messages[i], i, count);
                }
            }
        }

        @Override
        public Flag[] getPermanentFlags() throws MessagingException
        {
            return PERMANENT_FLAGS;
        }

        @Override
        public void setFlags(Message[] messages, Flag[] flags, boolean value)
        throws MessagingException
        {
            String[] uids = new String[messages.length];

            for (int i = 0, count = messages.length; i < count; i++)
            {
                uids[i] = messages[i].getUid();
            }

            for (Flag flag : flags)
            {
                if (flag == Flag.SEEN)
                {
                    markServerMessagesRead(uids, value);
                }
                else if (flag == Flag.DELETED)
                {
                    deleteServerMessages(uids);
                }
            }
        }

        private void markServerMessagesRead(String[] uids, boolean read) throws MessagingException
        {
            String messageBody = """";
            HashMap<String, String> headers = new HashMap<String, String>();
            HashMap<String, String> uidToUrl = getMessageUrls(uids);
            String[] urls = new String[uids.length];

            for (int i = 0, count = uids.length; i < count; i++)
            {
                urls[i] = uidToUrl.get(uids[i]);
            }

            messageBody = getMarkMessagesReadXml(urls, read);
            headers.put(""Brief"", ""t"");
            headers.put(""If-Match"", ""*"");

            processRequest(this.mFolderUrl, ""BPROPPATCH"", messageBody, headers, false);
        }

        private void deleteServerMessages(String[] uids) throws MessagingException
        {
            HashMap<String, String> uidToUrl = getMessageUrls(uids);

            for (String uid : uids)
            {
                HashMap<String, String> headers = new HashMap<String, String>();
                String url = uidToUrl.get(uid);
                String destinationUrl = generateDeleteUrl(url);

                /**
                 * If the destination is the same as the origin, assume delete forever
                 */
                if (destinationUrl.equals(url))
                {
                    headers.put(""Brief"", ""t"");
                    processRequest(url, ""DELETE"", null, headers, false);
                }
                else
                {
                    headers.put(""Destination"", generateDeleteUrl(url));
                    headers.put(""Brief"", ""t"");
                    processRequest(url, ""MOVE"", null, headers, false);
                }
            }
        }

        private String generateDeleteUrl(String startUrl)
        {
            String[] urlParts = startUrl.split(""/"");
            String filename = urlParts[urlParts.length - 1];
            String finalUrl = WebDavStore.this.mUrl + ""Deleted%20Items/"" + filename;

            return finalUrl;
        }

        @Override
        public void appendMessages(Message[] messages) throws MessagingException
        {
            appendWebDavMessages(messages);
        }

        public Message[] appendWebDavMessages(Message[] messages) throws MessagingException
        {

            Message[] retMessages = new Message[messages.length];
            int ind = 0;

            WebDavHttpClient httpclient = getHttpClient();

            for (Message message : messages)
            {
                HttpGeneric httpmethod;
                HttpResponse response;
                StringEntity bodyEntity;
                int statusCode;

                try
                {
                    /*
                    String subject;

                    try
                    {
                        subject = message.getSubject();
                    }
                    catch (MessagingException e)
                    {
                        Log.e(K9.LOG_TAG, ""MessagingException while retrieving Subject: "" + e);
                        subject = """";
                    }
                    */

                    ByteArrayOutputStream out;
                    try
                    {
                        out = new ByteArrayOutputStream(message.getSize());
                    }
                    catch (MessagingException e)
                    {
                        Log.e(K9.LOG_TAG, ""MessagingException while getting size of message: "" + e);
                        out = new ByteArrayOutputStream();
                    }
                    open(OpenMode.READ_WRITE);
                    EOLConvertingOutputStream msgOut = new EOLConvertingOutputStream(
                        new BufferedOutputStream(out, 1024));
                    message.writeTo(msgOut);
                    msgOut.flush();

                    bodyEntity = new StringEntity(out.toString(), ""UTF-8"");
                    bodyEntity.setContentType(""message/rfc822"");

                    String messageURL = mFolderUrl;
                    if (!messageURL.endsWith(""/""))
                    {
                        messageURL += ""/"";
                    }
                    messageURL += URLEncoder.encode(message.getUid() + "":"" + System.currentTimeMillis() + "".eml"");

                    Log.i(K9.LOG_TAG, ""Uploading message as "" + messageURL);

                    httpmethod = new HttpGeneric(messageURL);
                    httpmethod.setMethod(""PUT"");
                    httpmethod.setEntity(bodyEntity);

                    String mAuthString = getAuthString();

                    if (mAuthString != null)
                    {
                        httpmethod.setHeader(""Authorization"", mAuthString);
                    }

                    response = httpclient.executeOverride(httpmethod);
                    statusCode = response.getStatusLine().getStatusCode();

                    if (statusCode < 200 ||
                            statusCode > 300)
                    {
                        throw new IOException(""Error with status code "" + statusCode
                                              + "" while sending/appending message.  Response = ""
                                              + response.getStatusLine().toString() + "" for message "" + messageURL);
                    }
                    WebDavMessage retMessage = new WebDavMessage(message.getUid(), this);

                    retMessage.setUrl(messageURL);
                    retMessages[ind++] = retMessage;
                }
                catch (Exception e)
                {
                    throw new MessagingException(""Unable to append"", e);
                }

            }
            return retMessages;
        }

        @Override
        public boolean equals(Object o)
        {
            return false;
        }

        @Override
        public int hashCode()
        {
            return super.hashCode();
        }

        @Override
        public String getUidFromMessageId(Message message) throws MessagingException
        {
            Log.e(K9.LOG_TAG, ""Unimplemented method getUidFromMessageId in WebDavStore.WebDavFolder could lead to duplicate messages ""
                  + "" being uploaded to the Sent folder"");
            return null;
        }

        @Override
        public void setFlags(Flag[] flags, boolean value) throws MessagingException
        {
            Log.e(K9.LOG_TAG, ""Unimplemented method setFlags(Flag[], boolean) breaks markAllMessagesAsRead and EmptyTrash"");
            // Try to make this efficient by not retrieving all of the messages
        }
    }

    /**
     * A WebDav Message
     */
    class WebDavMessage extends MimeMessage
    {
        private String mUrl = """";


        WebDavMessage(String uid, Folder folder) throws MessagingException
        {
            this.mUid = uid;
            this.mFolder = folder;
        }

        public void setUrl(String url)
        {
            //TODO: This is a not as ugly hack (ie, it will actually work)
            //XXX: prevent URLs from getting to us that are broken
            if (!(url.toLowerCase().contains(""http"")))
            {
                if (!(url.startsWith(""/"")))
                {
                    url = ""/"" + url;
                }
                url = WebDavStore.this.mUrl + this.mFolder + url;
            }

            String[] urlParts = url.split(""/"");
            int length = urlParts.length;
            String end = urlParts[length - 1];

            this.mUrl = """";
            url = """";

            /**
             * We have to decode, then encode the URL because Exchange likes to
             * not properly encode all characters
             */
            try
            {
                end = java.net.URLDecoder.decode(end, ""UTF-8"");
                end = java.net.URLEncoder.encode(end, ""UTF-8"");
                end = end.replaceAll(""\\+"", ""%20"");
            }
            catch (UnsupportedEncodingException uee)
            {
                Log.e(K9.LOG_TAG, ""UnsupportedEncodingException caught in setUrl: "" + uee + ""\nTrace: "" + processException(uee));
            }
            catch (IllegalArgumentException iae)
            {
                Log.e(K9.LOG_TAG, ""IllegalArgumentException caught in setUrl: "" + iae + ""\nTrace: "" + processException(iae));
            }

            for (int i = 0; i < length - 1; i++)
            {
                if (i != 0)
                {
                    url = url + ""/"" + urlParts[i];
                }
                else
                {
                    url = urlParts[i];
                }
            }

            url = url + ""/"" + end;

            this.mUrl = url;
        }

        public String getUrl()
        {
            return this.mUrl;
        }

        public void setSize(int size)
        {
            this.mSize = size;
        }

        @Override
        public void parse(InputStream in) throws IOException, MessagingException
        {
            super.parse(in);
        }

        public void setFlagInternal(Flag flag, boolean set) throws MessagingException
        {
            super.setFlag(flag, set);
        }

        public void setNewHeaders(ParsedMessageEnvelope envelope) throws MessagingException
        {
            String[] headers = envelope.getHeaderList();
            HashMap<String, String> messageHeaders = envelope.getMessageHeaders();

            for (String header : headers)
            {
                String headerValue = messageHeaders.get(header);
                if (header.equals(""Content-Length""))
                {
                    int size = Integer.parseInt(messageHeaders.get(header));
                    this.setSize(size);
                }

                if (headerValue != null &&
                        !headerValue.equals(""""))
                {
                    this.addHeader(header, headerValue);
                }
            }
        }


        @Override
        public void delete(String trashFolderName) throws MessagingException
        {
            WebDavFolder wdFolder = (WebDavFolder)getFolder();
            Log.i(K9.LOG_TAG, ""Deleting message by moving to "" + trashFolderName);
            wdFolder.moveMessages(new Message[] { this }, wdFolder.getStore().getFolder(trashFolderName));

        }

        @Override
        public void setFlag(Flag flag, boolean set) throws MessagingException
        {
            super.setFlag(flag, set);
            mFolder.setFlags(new Message[] { this }, new Flag[] { flag }, set);
        }
    }

    /**
     * XML Parsing Handler
     * Can handle all XML handling needs
     */
    public class WebDavHandler extends DefaultHandler
    {
        private DataSet mDataSet = new DataSet();
        private Stack<String> mOpenTags = new Stack<String>();

        public DataSet getDataSet()
        {
            return this.mDataSet;
        }

        @Override
        public void startDocument() throws SAXException
        {
            this.mDataSet = new DataSet();
        }

        @Override
        public void endDocument() throws SAXException
        {
            /* Do nothing */
        }

        @Override
        public void startElement(String namespaceURI, String localName,
                                 String qName, Attributes atts) throws SAXException
        {
            mOpenTags.push(localName);
        }

        @Override
        public void endElement(String namespaceURI, String localName, String qName)
        {
            mOpenTags.pop();

            /** Reset the hash temp variables */
            if (localName.equals(""response""))
            {
                this.mDataSet.finish();
            }
        }

        @Override
        public void characters(char ch[], int start, int length)
        {
            String value = new String(ch, start, length);
            mDataSet.addValue(value, mOpenTags.peek());
        }
    }

    /**
     * Data set for a single E-Mail message's required headers (the envelope)
     * Only provides accessor methods to the stored data.  All processing should be
     * done elsewhere.  This is done rather than having multiple hashmaps
     * associating UIDs to values
     */
    public class ParsedMessageEnvelope
    {
        /**
         * Holds the mappings from the name returned from Exchange to the MIME format header name
         */
        private final HashMap<String, String> mHeaderMappings = new HashMap<String, String>()
        {
            {
                put(""mime-version"", ""MIME-Version"");
                put(""content-type"", ""Content-Type"");
                put(""subject"", ""Subject"");
                put(""date"", ""Date"");
                put(""thread-topic"", ""Thread-Topic"");
                put(""thread-index"", ""Thread-Index"");
                put(""from"", ""From"");
                put(""to"", ""To"");
                put(""in-reply-to"", ""In-Reply-To"");
                put(""cc"", ""Cc"");
                put(""getcontentlength"", ""Content-Length"");
            }
        };

        private boolean mReadStatus = false;
        private String mUid = """";
        private HashMap<String, String> mMessageHeaders = new HashMap<String, String>();
        private ArrayList<String> mHeaders = new ArrayList<String>();

        public void addHeader(String field, String value)
        {
            String headerName = mHeaderMappings.get(field);
            //Log.i(K9.LOG_TAG, ""header "" + headerName + "" = '"" + value + ""'"");

            if (headerName != null)
            {
                this.mMessageHeaders.put(mHeaderMappings.get(field), value);
                this.mHeaders.add(mHeaderMappings.get(field));
            }
        }

        public HashMap<String, String> getMessageHeaders()
        {
            return this.mMessageHeaders;
        }

        public String[] getHeaderList()
        {
            return this.mHeaders.toArray(EMPTY_STRING_ARRAY);
        }

        public void setReadStatus(boolean status)
        {
            this.mReadStatus = status;
        }

        public boolean getReadStatus()
        {
            return this.mReadStatus;
        }

        public void setUid(String uid)
        {
            if (uid != null)
            {
                this.mUid = uid;
            }
        }

        public String getUid()
        {
            return this.mUid;
        }
    }

    /**
     * Dataset for all XML parses.
     * Data is stored in a single format inside the class and is formatted appropriately depending on the accessor calls made.
     */
    public class DataSet
    {
        private HashMap<String, HashMap<String, String>> mData = new HashMap<String, HashMap<String, String>>();
        //private HashMap<String, String> mLostData = new HashMap<String, String>();
        private String mUid = """";
        private HashMap<String, String> mTempData = new HashMap<String, String>();

        public void addValue(String value, String tagName)
        {
            if (tagName.equals(""uid""))
            {
                mUid = value;
            }

            if (mTempData.containsKey(tagName))
            {
                mTempData.put(tagName, mTempData.get(tagName) + value);
            }
            else
            {
                mTempData.put(tagName, value);
            }
        }

        public void finish()
        {
            if (mUid != null &&
                    mTempData != null)
            {
                mData.put(mUid, mTempData);
            }
            else if (mTempData != null)
            {
                /* Lost Data are for requests that don't include a message UID.
                 * These requests should only have a depth of one for the response so it will never get stomped over.
                 */
                //mLostData = mTempData;
                //String visibleCount = mLostData.get(""visiblecount"");
            }

            mUid = """";
            mTempData = new HashMap<String, String>();
        }

        /**
         * Returns a hashmap of Message UID => Message Url
         */
        public HashMap<String, String> getUidToUrl()
        {
            HashMap<String, String> uidToUrl = new HashMap<String, String>();

            for (String uid : mData.keySet())
            {
                HashMap<String, String> data = mData.get(uid);
                String value = data.get(""href"");
                if (value != null &&
                        !value.equals(""""))
                {
                    uidToUrl.put(uid, value);
                }
            }

            return uidToUrl;
        }

        /**
         * Returns a hashmap of Message UID => Read Status
         */
        public HashMap<String, Boolean> getUidToRead()
        {
            HashMap<String, Boolean> uidToRead = new HashMap<String, Boolean>();

            for (String uid : mData.keySet())
            {
                HashMap<String, String> data = mData.get(uid);
                String readStatus = data.get(""read"");
                if (readStatus != null &&
                        !readStatus.equals(""""))
                {
                    Boolean value = !readStatus.equals(""0"");
                    uidToRead.put(uid, value);
                }
            }

            return uidToRead;
        }

        /**
         * Returns an array of all hrefs (urls) that were received
         */
        public String[] getHrefs()
        {
            ArrayList<String> hrefs = new ArrayList<String>();

            for (String uid : mData.keySet())
            {
                HashMap<String, String> data = mData.get(uid);
                String href = data.get(""href"");
                hrefs.add(href);
            }

            return hrefs.toArray(EMPTY_STRING_ARRAY);
        }

        /**
         * Return an array of all Message UIDs that were received
         */
        public String[] getUids()
        {
            ArrayList<String> uids = new ArrayList<String>();

            for (String uid : mData.keySet())
            {
                uids.add(uid);
            }

            return uids.toArray(EMPTY_STRING_ARRAY);
        }

        /**
         * Returns the message count as it was retrieved
         */
        public int getMessageCount()
        {
            int messageCount = -1;

            for (String uid : mData.keySet())
            {
                HashMap<String, String> data = mData.get(uid);
                String count = data.get(""visiblecount"");

                if (count != null &&
                        !count.equals(""""))
                {
                    messageCount = Integer.parseInt(count);
                }

            }

            return messageCount;
        }

        /**
         * Returns a HashMap of message UID => ParsedMessageEnvelope
         */
        public HashMap<String, ParsedMessageEnvelope> getMessageEnvelopes()
        {
            HashMap<String, ParsedMessageEnvelope> envelopes = new HashMap<String, ParsedMessageEnvelope>();

            for (String uid : mData.keySet())
            {
                ParsedMessageEnvelope envelope = new ParsedMessageEnvelope();
                HashMap<String, String> data = mData.get(uid);

                if (data != null)
                {
                    for (String header : data.keySet())
                    {
                        if (header.equals(""read""))
                        {
                            String read = data.get(header);
                            Boolean readStatus = !read.equals(""0"");

                            envelope.setReadStatus(readStatus);
                        }
                        else if (header.equals(""date""))
                        {
                            /**
                             * Exchange doesn't give us rfc822 dates like it claims.  The date is in the format:
                             * yyyy-MM-dd'T'HH:mm:ss.SSS<Single digit representation of timezone, so far, all instances are Z>
                             */
                            String date = data.get(header);
                            date = date.substring(0, date.length() - 1);

                            DateFormat dfInput = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS"");
                            DateFormat dfOutput = new SimpleDateFormat(""EEE, d MMM yy HH:mm:ss Z"");
                            String tempDate = """";

                            try
                            {
                                Date parsedDate = dfInput.parse(date);
                                tempDate = dfOutput.format(parsedDate);
                            }
                            catch (java.text.ParseException pe)
                            {
                                Log.e(K9.LOG_TAG, ""Error parsing date: ""+ pe + ""\nTrace: "" + processException(pe));
                            }
                            envelope.addHeader(header, tempDate);
                        }
                        else
                        {
                            envelope.addHeader(header, data.get(header));
                        }
                    }
                }

                if (envelope != null)
                {
                    envelopes.put(uid, envelope);
                }
            }

            return envelopes;
        }
    }

    /**
     * New HTTP Method that allows changing of the method and generic handling
     * Needed for WebDAV custom methods such as SEARCH and PROPFIND
     */
    public class HttpGeneric extends HttpEntityEnclosingRequestBase
    {
        public String METHOD_NAME = ""POST"";

        public HttpGeneric()
        {
            super();
        }

        public HttpGeneric(final URI uri)
        {
            super();
            setURI(uri);
        }

        /**
         * @throws IllegalArgumentException if the uri is invalid.
         */
        public HttpGeneric(final String uri)
        {
            super();

            if (K9.DEBUG)
            {
                Log.v(K9.LOG_TAG, ""Starting uri = '"" + uri + ""'"");
            }

            String[] urlParts = uri.split(""/"");
            int length = urlParts.length;
            String end = urlParts[length - 1];
            String url = """";

            /**
             * We have to decode, then encode the URL because Exchange likes to
             * not properly encode all characters
             */
            try
            {
                if (length > 3)
                {
                    end = java.net.URLDecoder.decode(end, ""UTF-8"");
                    end = java.net.URLEncoder.encode(end, ""UTF-8"");
                    end = end.replaceAll(""\\+"", ""%20"");
                }
            }
            catch (UnsupportedEncodingException uee)
            {
                Log.e(K9.LOG_TAG, ""UnsupportedEncodingException caught in HttpGeneric(String uri): "" + uee + ""\nTrace: "" + processException(uee));
            }
            catch (IllegalArgumentException iae)
            {
                Log.e(K9.LOG_TAG, ""IllegalArgumentException caught in HttpGeneric(String uri): "" + iae + ""\nTrace: "" + processException(iae));
            }

            for (int i = 0; i < length - 1; i++)
            {
                if (i != 0)
                {
                    url = url + ""/"" + urlParts[i];
                }
                else
                {
                    url = urlParts[i];
                }
            }
            if (K9.DEBUG && K9.DEBUG_PROTOCOL_WEBDAV)
            {
                Log.v(K9.LOG_TAG, ""url = '"" + url + ""' length = "" + url.length()
                      + "", end = '"" + end + ""' length = "" + end.length());
            }
            url = url + ""/"" + end;

            Log.i(K9.LOG_TAG, ""url = "" + url);
            setURI(URI.create(url));
        }

        @Override
        public String getMethod()
        {
            return METHOD_NAME;
        }

        public void setMethod(String method)
        {
            if (method != null)
            {
                METHOD_NAME = method;
            }
        }
    }
    public static class WebDavHttpClient extends DefaultHttpClient
    {
        /*
        * Copyright (C) 2007 The Android Open Source Project
        *
        * Licensed under the Apache License, Version 2.0 (the ""License"");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an ""AS IS"" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        public static void modifyRequestToAcceptGzipResponse(HttpRequest request)
        {
            Log.i(K9.LOG_TAG, ""Requesting gzipped data"");
            request.addHeader(""Accept-Encoding"", ""gzip"");
        }
        public static InputStream getUngzippedContent(HttpEntity entity)
        throws IOException
        {
            InputStream responseStream = entity.getContent();
            if (responseStream == null) return responseStream;
            Header header = entity.getContentEncoding();
            if (header == null) return responseStream;
            String contentEncoding = header.getValue();
            if (contentEncoding == null) return responseStream;
            if (contentEncoding.contains(""gzip""))
            {
                Log.i(K9.LOG_TAG, ""Response is gzipped"");
                responseStream = new GZIPInputStream(responseStream);
            }
            return responseStream;
        }


        public HttpResponse executeOverride(HttpUriRequest request) throws IOException
        {
            modifyRequestToAcceptGzipResponse(request);
            return super.execute(request);
        }

    }
}
",True,216,0,0,7,57,2,15,L1
123,com.fsck.k9.mail.store.Pop3Store.java,"
package com.fsck.k9.mail.store;

import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.controller.MessageRetrievalListener;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Folder.OpenMode;
import com.fsck.k9.mail.internet.MimeMessage;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.TrustManager;
import java.io.*;
import java.net.*;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

public class Pop3Store extends Store
{
    public static final int CONNECTION_SECURITY_NONE = 0;
    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED };

    private String mHost;
    private int mPort;
    private String mUsername;
    private String mPassword;
    private int mConnectionSecurity;
    private HashMap<String, Folder> mFolders = new HashMap<String, Folder>();
    private Pop3Capabilities mCapabilities;

//    /**
//     * Detected latency, used for usage scaling.
//     * Usage scaling occurs when it is neccesary to get information about
//     * messages that could result in large data loads. This value allows
//     * the code that loads this data to decide between using large downloads
//     * (high latency) or multiple round trips (low latency) to accomplish
//     * the same thing.
//     * Default is Integer.MAX_VALUE implying massive latency so that the large
//     * download method is used by default until latency data is collected.
//     */
//    private int mLatencyMs = Integer.MAX_VALUE;
//
//    /**
//     * Detected throughput, used for usage scaling.
//     * Usage scaling occurs when it is neccesary to get information about
//     * messages that could result in large data loads. This value allows
//     * the code that loads this data to decide between using large downloads
//     * (high latency) or multiple round trips (low latency) to accomplish
//     * the same thing.
//     * Default is Integer.MAX_VALUE implying massive bandwidth so that the
//     * large download method is used by default until latency data is
//     * collected.
//     */
//    private int mThroughputKbS = Integer.MAX_VALUE;

    /**
     * pop3://user:password@server:port CONNECTION_SECURITY_NONE
     * pop3+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * pop3+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * pop3+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * pop3+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     */
    public Pop3Store(Account account) throws MessagingException
    {
        super(account);

        URI uri;
        try
        {
            uri = new URI(mAccount.getStoreUri());
        }
        catch (URISyntaxException use)
        {
            throw new MessagingException(""Invalid Pop3Store URI"", use);
        }

        String scheme = uri.getScheme();
        if (scheme.equals(""pop3""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_NONE;
            mPort = 110;
        }
        else if (scheme.equals(""pop3+tls""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
            mPort = 110;
        }
        else if (scheme.equals(""pop3+tls+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
            mPort = 110;
        }
        else if (scheme.equals(""pop3+ssl+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
            mPort = 995;
        }
        else if (scheme.equals(""pop3+ssl""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
            mPort = 995;
        }
        else
        {
            throw new MessagingException(""Unsupported protocol"");
        }

        mHost = uri.getHost();

        if (uri.getPort() != -1)
        {
            mPort = uri.getPort();
        }

        if (uri.getUserInfo() != null)
        {
            try
            {
                String[] userInfoParts = uri.getUserInfo().split("":"");
                mUsername = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                if (userInfoParts.length > 1)
                {
                    mPassword = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
            }
            catch (UnsupportedEncodingException enc)
            {
                // This shouldn't happen since the encoding is hardcoded to UTF-8
                Log.e(K9.LOG_TAG, ""Couldn't urldecode username or password."", enc);
            }
        }
    }

    @Override
    public Folder getFolder(String name) throws MessagingException
    {
        Folder folder = mFolders.get(name);
        if (folder == null)
        {
            folder = new Pop3Folder(name);
            mFolders.put(folder.getName(), folder);
        }
        return folder;
    }

    @Override
    public List<? extends Folder> getPersonalNamespaces(boolean forceListAll) throws MessagingException
    {
        List<Folder> folders = new LinkedList<Folder>();
        folders.add(getFolder(""INBOX""));
        return folders;
    }

    @Override
    public void checkSettings() throws MessagingException
    {
        Pop3Folder folder = new Pop3Folder(""INBOX"");
        folder.open(OpenMode.READ_WRITE);
        if (!mCapabilities.uidl)
        {
            /*
             * Run an additional test to see if UIDL is supported on the server. If it's not we
             * can't service this account.
             */

            /*
             * If the server doesn't support UIDL it will return a - response, which causes
             * executeSimpleCommand to throw a MessagingException, exiting this method.
             */
            folder.executeSimpleCommand(""UIDL"");

        }
        folder.close();
    }

    class Pop3Folder extends Folder
    {
        private Socket mSocket;
        private InputStream mIn;
        private OutputStream mOut;
        private HashMap<String, Pop3Message> mUidToMsgMap = new HashMap<String, Pop3Message>();
        private HashMap<Integer, Pop3Message> mMsgNumToMsgMap = new HashMap<Integer, Pop3Message>();
        private HashMap<String, Integer> mUidToMsgNumMap = new HashMap<String, Integer>();
        private String mName;
        private int mMessageCount;

        public Pop3Folder(String name)
        {
            super(Pop3Store.this.mAccount);
            this.mName = name;
            if (mName.equalsIgnoreCase(""INBOX""))
            {
                mName = ""INBOX"";
            }
        }

        @Override
        public synchronized void open(OpenMode mode) throws MessagingException
        {
            if (isOpen())
            {
                return;
            }

            if (!mName.equalsIgnoreCase(""INBOX""))
            {
                throw new MessagingException(""Folder does not exist"");
            }

            try
            {
                SocketAddress socketAddress = new InetSocketAddress(mHost, mPort);
                if (mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
                        mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL)
                {
                    SSLContext sslContext = SSLContext.getInstance(""TLS"");
                    final boolean secure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
                    sslContext.init(null, new TrustManager[]
                                    {
                                        TrustManagerFactory.get(mHost, secure)
                                    }, new SecureRandom());
                    mSocket = sslContext.getSocketFactory().createSocket();
                    mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                    mIn = new BufferedInputStream(mSocket.getInputStream(), 1024);
                    mOut = new BufferedOutputStream(mSocket.getOutputStream(), 512);
                }
                else
                {
                    mSocket = new Socket();
                    mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                    mIn = new BufferedInputStream(mSocket.getInputStream(), 1024);
                    mOut = new BufferedOutputStream(mSocket.getOutputStream(), 512);
                }

                mSocket.setSoTimeout(Store.SOCKET_READ_TIMEOUT);
                if (!isOpen())
                {
                    throw new MessagingException(""Unable to connect socket"");
                }

                // Eat the banner
                executeSimpleCommand(null);

                if (mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL
                        || mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED)
                {
                    mCapabilities = getCapabilities();

                    if (mCapabilities.stls)
                    {
                        writeLine(""STLS"");

                        SSLContext sslContext = SSLContext.getInstance(""TLS"");
                        boolean secure = mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED;
                        sslContext.init(null, new TrustManager[]
                                        {
                                            TrustManagerFactory.get(mHost, secure)
                                        }, new SecureRandom());
                        mSocket = sslContext.getSocketFactory().createSocket(mSocket, mHost, mPort,
                                  true);
                        mSocket.setSoTimeout(Store.SOCKET_READ_TIMEOUT);
                        mIn = new BufferedInputStream(mSocket.getInputStream(), 1024);
                        mOut = new BufferedOutputStream(mSocket.getOutputStream(), 512);
                        if (!isOpen())
                        {
                            throw new MessagingException(""Unable to connect socket"");
                        }
                    }
                    else if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED)
                    {
                        throw new MessagingException(""TLS not supported but required"");
                    }
                }

                try
                {
                    executeSimpleCommand(""USER "" + mUsername);
                    executeSimpleCommand(""PASS "" + mPassword, true);
                }
                catch (MessagingException me)
                {
                    throw new AuthenticationFailedException(null, me);
                }

                mCapabilities = getCapabilities();
            }
            catch (SSLException e)
            {
                throw new CertificateValidationException(e.getMessage(), e);
            }
            catch (GeneralSecurityException gse)
            {
                throw new MessagingException(
                    ""Unable to open connection to POP server due to security error."", gse);
            }
            catch (IOException ioe)
            {
                throw new MessagingException(""Unable to open connection to POP server."", ioe);
            }

            String response = executeSimpleCommand(""STAT"");
            String[] parts = response.split("" "");
            mMessageCount = Integer.parseInt(parts[1]);

            mUidToMsgMap.clear();
            mMsgNumToMsgMap.clear();
            mUidToMsgNumMap.clear();
        }

        @Override
        public boolean isOpen()
        {
            return (mIn != null && mOut != null && mSocket != null
                    && mSocket.isConnected() && !mSocket.isClosed());
        }

        @Override
        public OpenMode getMode() throws MessagingException
        {
            return OpenMode.READ_WRITE;
        }

        @Override
        public void close()
        {
            try
            {
                executeSimpleCommand(""QUIT"");
            }
            catch (Exception e)
            {
                /*
                 * QUIT may fail if the connection is already closed. We don't care. It's just
                 * being friendly.
                 */
            }

            closeIO();
        }

        private void closeIO()
        {
            try
            {
                mIn.close();
            }
            catch (Exception e)
            {
                /*
                 * May fail if the connection is already closed.
                 */
            }
            try
            {
                mOut.close();
            }
            catch (Exception e)
            {
                /*
                 * May fail if the connection is already closed.
                 */
            }
            try
            {
                mSocket.close();
            }
            catch (Exception e)
            {
                /*
                 * May fail if the connection is already closed.
                 */
            }
            mIn = null;
            mOut = null;
            mSocket = null;
        }

        @Override
        public String getName()
        {
            return mName;
        }

        @Override
        public boolean create(FolderType type) throws MessagingException
        {
            return false;
        }

        @Override
        public boolean exists() throws MessagingException
        {
            return mName.equalsIgnoreCase(""INBOX"");
        }

        @Override
        public int getMessageCount()
        {
            return mMessageCount;
        }

        @Override
        public int getUnreadMessageCount() throws MessagingException
        {
            return -1;
        }
        @Override
        public int getFlaggedMessageCount() throws MessagingException
        {
            return -1;
        }

        @Override
        public Message getMessage(String uid) throws MessagingException
        {
            Pop3Message message = mUidToMsgMap.get(uid);
            if (message == null)
            {
                message = new Pop3Message(uid, this);
            }
            return message;
        }

        @Override
        public Message[] getMessages(int start, int end, Date earliestDate, MessageRetrievalListener listener)
        throws MessagingException
        {
            if (start < 1 || end < 1 || end < start)
            {
                throw new MessagingException(String.format(""Invalid message set %d %d"",
                                             start, end));
            }
            try
            {
                indexMsgNums(start, end);
            }
            catch (IOException ioe)
            {
                throw new MessagingException(""getMessages"", ioe);
            }
            ArrayList<Message> messages = new ArrayList<Message>();
            int i = 0;
            for (int msgNum = start; msgNum <= end; msgNum++)
            {
                Pop3Message message = mMsgNumToMsgMap.get(msgNum);
                if (message == null)
                {
                    /*
                     * There could be gaps in the message numbers or malformed
                     * responses which lead to ""gaps"" in mMsgNumToMsgMap.
                     *
                     * See issue 2252
                     */
                    continue;
                }

                if (listener != null)
                {
                    listener.messageStarted(message.getUid(), i++, (end - start) + 1);
                }
                messages.add(message);
                if (listener != null)
                {
                    listener.messageFinished(message, i++, (end - start) + 1);
                }
            }
            return messages.toArray(new Message[messages.size()]);
        }

        /**
         * Ensures that the given message set (from start to end inclusive)
         * has been queried so that uids are available in the local cache.
         * @param start
         * @param end
         * @throws MessagingException
         * @throws IOException
         */
        private void indexMsgNums(int start, int end)
        throws MessagingException, IOException
        {
            int unindexedMessageCount = 0;
            for (int msgNum = start; msgNum <= end; msgNum++)
            {
                if (mMsgNumToMsgMap.get(msgNum) == null)
                {
                    unindexedMessageCount++;
                }
            }
            if (unindexedMessageCount == 0)
            {
                return;
            }
            if (unindexedMessageCount < 50 && mMessageCount > 5000)
            {
                /*
                 * In extreme cases we'll do a UIDL command per message instead of a bulk
                 * download.
                 */
                for (int msgNum = start; msgNum <= end; msgNum++)
                {
                    Pop3Message message = mMsgNumToMsgMap.get(msgNum);
                    if (message == null)
                    {
                        String response = executeSimpleCommand(""UIDL "" + msgNum);
                        int uidIndex = response.lastIndexOf(' ');
                        String msgUid = response.substring(uidIndex + 1);
                        message = new Pop3Message(msgUid, this);
                        indexMessage(msgNum, message);
                    }
                }
            }
            else
            {
                String response = executeSimpleCommand(""UIDL"");
                while ((response = readLine()) != null)
                {
                    if (response.equals("".""))
                    {
                        break;
                    }
                    String[] uidParts = response.split("" "");
                    if ((uidParts.length >= 3) && ""+OK"".equals(uidParts[0]))
                    {
                        /*
                         * At least one server software places a ""+OK"" in
                         * front of every line in the unique-id listing.
                         *
                         * Fix up the array if we detected this behavior.
                         * See Issue 1237
                         */
                        uidParts[0] = uidParts[1];
                        uidParts[1] = uidParts[2];
                    }
                    if (uidParts.length >= 2)
                    {
                        Integer msgNum = Integer.valueOf(uidParts[0]);
                        String msgUid = uidParts[1];
                        if (msgNum >= start && msgNum <= end)
                        {
                            Pop3Message message = mMsgNumToMsgMap.get(msgNum);
                            if (message == null)
                            {
                                message = new Pop3Message(msgUid, this);
                                indexMessage(msgNum, message);
                            }
                        }
                    }
                }
            }
        }

        private void indexUids(ArrayList<String> uids)
        throws MessagingException, IOException
        {
            HashSet<String> unindexedUids = new HashSet<String>();
            for (String uid : uids)
            {
                if (mUidToMsgMap.get(uid) == null)
                {
                    if (K9.DEBUG && K9.DEBUG_PROTOCOL_POP3)
                    {
                        Log.d(K9.LOG_TAG, ""Need to index UID "" + uid);
                    }
                    unindexedUids.add(uid);
                }
            }
            if (unindexedUids.size() == 0)
            {
                return;
            }
            /*
             * If we are missing uids in the cache the only sure way to
             * get them is to do a full UIDL list. A possible optimization
             * would be trying UIDL for the latest X messages and praying.
             */
            String response = executeSimpleCommand(""UIDL"");
            while ((response = readLine()) != null)
            {
                if (response.equals("".""))
                {
                    break;
                }
                String[] uidParts = response.split("" "");
                Integer msgNum = Integer.valueOf(uidParts[0]);
                String msgUid = uidParts[1];
                if (unindexedUids.contains(msgUid))
                {
                    if (K9.DEBUG && K9.DEBUG_PROTOCOL_POP3)
                    {
                        Log.d(K9.LOG_TAG, ""Got msgNum "" + msgNum + "" for UID "" + msgUid);
                    }

                    Pop3Message message = mUidToMsgMap.get(msgUid);
                    if (message == null)
                    {
                        message = new Pop3Message(msgUid, this);
                    }
                    indexMessage(msgNum, message);
                }
            }
        }

        private void indexMessage(int msgNum, Pop3Message message)
        {
            if (K9.DEBUG && K9.DEBUG_PROTOCOL_POP3)
            {
                Log.d(K9.LOG_TAG, ""Adding index for UID "" + message.getUid() + "" to msgNum "" + msgNum);
            }
            mMsgNumToMsgMap.put(msgNum, message);
            mUidToMsgMap.put(message.getUid(), message);
            mUidToMsgNumMap.put(message.getUid(), msgNum);
        }

        @Override
        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException
        {
            throw new UnsupportedOperationException(""Pop3: No getMessages"");
        }

        @Override
        public Message[] getMessages(String[] uids, MessageRetrievalListener listener)
        throws MessagingException
        {
            throw new UnsupportedOperationException(""Pop3: No getMessages by uids"");
        }

        /**
         * Fetch the items contained in the FetchProfile into the given set of
         * Messages in as efficient a manner as possible.
         * @param messages
         * @param fp
         * @throws MessagingException
         */
        @Override
        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
        throws MessagingException
        {
            if (messages == null || messages.length == 0)
            {
                return;
            }
            ArrayList<String> uids = new ArrayList<String>();
            for (Message message : messages)
            {
                uids.add(message.getUid());
            }
            try
            {
                indexUids(uids);
            }
            catch (IOException ioe)
            {
                throw new MessagingException(""fetch"", ioe);
            }
            try
            {
                if (fp.contains(FetchProfile.Item.ENVELOPE))
                {
                    /*
                     * We pass the listener only if there are other things to do in the
                     * FetchProfile. Since fetchEnvelop works in bulk and eveything else
                     * works one at a time if we let fetchEnvelope send events the
                     * event would get sent twice.
                     */
                    fetchEnvelope(messages, fp.size() == 1 ? listener : null);
                }
            }
            catch (IOException ioe)
            {
                throw new MessagingException(""fetch"", ioe);
            }
            for (int i = 0, count = messages.length; i < count; i++)
            {
                Message message = messages[i];
                if (!(message instanceof Pop3Message))
                {
                    throw new MessagingException(""Pop3Store.fetch called with non-Pop3 Message"");
                }
                Pop3Message pop3Message = (Pop3Message)message;
                try
                {
                    if (listener != null && !fp.contains(FetchProfile.Item.ENVELOPE))
                    {
                        listener.messageStarted(pop3Message.getUid(), i, count);
                    }
                    if (fp.contains(FetchProfile.Item.BODY))
                    {
                        fetchBody(pop3Message, -1);
                    }
                    else if (fp.contains(FetchProfile.Item.BODY_SANE))
                    {
                        /*
                         * To convert the suggested download size we take the size
                         * divided by the maximum line size (76).
                         */
                        fetchBody(pop3Message,
                                  (mAccount.getMaximumAutoDownloadMessageSize() / 76));
                    }
                    else if (fp.contains(FetchProfile.Item.STRUCTURE))
                    {
                        /*
                         * If the user is requesting STRUCTURE we are required to set the body
                         * to null since we do not support the function.
                         */
                        pop3Message.setBody(null);
                    }
                    if (listener != null && !(fp.contains(FetchProfile.Item.ENVELOPE) && fp.size() == 1))
                    {
                        listener.messageFinished(message, i, count);
                    }
                }
                catch (IOException ioe)
                {
                    throw new MessagingException(""Unable to fetch message"", ioe);
                }
            }
        }

        private void fetchEnvelope(Message[] messages,
                                   MessageRetrievalListener listener)  throws IOException, MessagingException
        {
            int unsizedMessages = 0;
            for (Message message : messages)
            {
                if (message.getSize() == -1)
                {
                    unsizedMessages++;
                }
            }
            if (unsizedMessages == 0)
            {
                return;
            }
            if (unsizedMessages < 50 && mMessageCount > 5000)
            {
                /*
                 * In extreme cases we'll do a command per message instead of a bulk request
                 * to hopefully save some time and bandwidth.
                 */
                for (int i = 0, count = messages.length; i < count; i++)
                {
                    Message message = messages[i];
                    if (!(message instanceof Pop3Message))
                    {
                        throw new MessagingException(""Pop3Store.fetch called with non-Pop3 Message"");
                    }
                    Pop3Message pop3Message = (Pop3Message)message;
                    if (listener != null)
                    {
                        listener.messageStarted(pop3Message.getUid(), i, count);
                    }
                    String response = executeSimpleCommand(String.format(""LIST %d"",
                                                           mUidToMsgNumMap.get(pop3Message.getUid())));
                    String[] listParts = response.split("" "");
                    //int msgNum = Integer.parseInt(listParts[1]);
                    int msgSize = Integer.parseInt(listParts[2]);
                    pop3Message.setSize(msgSize);
                    if (listener != null)
                    {
                        listener.messageFinished(pop3Message, i, count);
                    }
                }
            }
            else
            {
                HashSet<String> msgUidIndex = new HashSet<String>();
                for (Message message : messages)
                {
                    msgUidIndex.add(message.getUid());
                }
                int i = 0, count = messages.length;
                String response = executeSimpleCommand(""LIST"");
                while ((response = readLine()) != null)
                {
                    if (response.equals("".""))
                    {
                        break;
                    }
                    String[] listParts = response.split("" "");
                    int msgNum = Integer.parseInt(listParts[0]);
                    int msgSize = Integer.parseInt(listParts[1]);
                    Pop3Message pop3Message = mMsgNumToMsgMap.get(msgNum);
                    if (pop3Message != null && msgUidIndex.contains(pop3Message.getUid()))
                    {
                        if (listener != null)
                        {
                            listener.messageStarted(pop3Message.getUid(), i, count);
                        }
                        pop3Message.setSize(msgSize);
                        if (listener != null)
                        {
                            listener.messageFinished(pop3Message, i, count);
                        }
                        i++;
                    }
                }
            }
        }

        /**
         * Fetches the body of the given message, limiting the stored data
         * to the specified number of lines. If lines is -1 the entire message
         * is fetched. This is implemented with RETR for lines = -1 or TOP
         * for any other value. If the server does not support TOP it is
         * emulated with RETR and extra lines are thrown away.
         * @param message
         * @param lines
         */
        private void fetchBody(Pop3Message message, int lines)
        throws IOException, MessagingException
        {
            String response = null;
            if (lines == -1 || !mCapabilities.top)
            {
                response = executeSimpleCommand(String.format(""RETR %d"",
                                                mUidToMsgNumMap.get(message.getUid())));
            }
            else
            {
                response = executeSimpleCommand(String.format(""TOP %d %d"",
                                                mUidToMsgNumMap.get(message.getUid()),
                                                lines));
            }
            if (response != null)
            {
                try
                {
                    message.parse(new Pop3ResponseInputStream(mIn));
                    if (lines == -1 || !mCapabilities.top)
                    {
                        message.setFlag(Flag.X_DOWNLOADED_FULL, true);
                    }
                }
                catch (MessagingException me)
                {
                    /*
                     * If we're only downloading headers it's possible
                     * we'll get a broken MIME message which we're not
                     * real worried about. If we've downloaded the body
                     * and can't parse it we need to let the user know.
                     */
                    if (lines == -1)
                    {
                        throw me;
                    }
                }
            }
        }

        @Override
        public Flag[] getPermanentFlags() throws MessagingException
        {
            return PERMANENT_FLAGS;
        }

        @Override
        public void appendMessages(Message[] messages) throws MessagingException
        {
        }

        @Override
        public void delete(boolean recurse) throws MessagingException
        {
        }

        @Override
        public void delete(Message[] msgs, String trashFolderName) throws MessagingException
        {
            setFlags(msgs, new Flag[] { Flag.DELETED }, true);
        }

        @Override
        public String getUidFromMessageId(Message message) throws MessagingException
        {
            return null;
        }

        @Override
        public void setFlags(Flag[] flags, boolean value)
        throws MessagingException
        {
            Message[] messages = getMessages(null);
            setFlags(messages, flags, value);
        }

        @Override
        public void setFlags(Message[] messages, Flag[] flags, boolean value)
        throws MessagingException
        {
            if (!value || !Utility.arrayContains(flags, Flag.DELETED))
            {
                /*
                 * The only flagging we support is setting the Deleted flag.
                 */
                return;
            }
            ArrayList<String> uids = new ArrayList<String>();
            try
            {
                for (Message message : messages)
                {
                    uids.add(message.getUid());
                }

                indexUids(uids);
            }
            catch (IOException ioe)
            {
                throw new MessagingException(""Could not get message number for uid "" + uids, ioe);
            }
            for (Message message : messages)
            {

                Integer msgNum = mUidToMsgNumMap.get(message.getUid());
                if (msgNum == null)
                {
                    MessagingException me = new MessagingException(""Could not delete message "" + message.getUid()
                            + "" because no msgNum found; permanent error"");
                    me.setPermanentFailure(true);
                    throw me;
                }
                executeSimpleCommand(String.format(""DELE %s"", msgNum));
            }
        }

//        private boolean isRoundTripModeSuggested() {
//            long roundTripMethodMs =
//                (uncachedMessageCount * 2 * mLatencyMs);
//            long bulkMethodMs =
//                    (mMessageCount * 58) / (mThroughputKbS * 1024 / 8) * 1000;
//        }

        private String readLine() throws IOException
        {
            StringBuffer sb = new StringBuffer();
            int d = mIn.read();
            if (d == -1)
            {
                throw new IOException(""End of stream reached while trying to read line."");
            }
            do
            {
                if (((char)d) == '\r')
                {
                    continue;
                }
                else if (((char)d) == '\n')
                {
                    break;
                }
                else
                {
                    sb.append((char)d);
                }
            }
            while ((d = mIn.read()) != -1);
            String ret = sb.toString();
            if (K9.DEBUG && K9.DEBUG_PROTOCOL_POP3)
            {
                Log.d(K9.LOG_TAG, ""<<< "" + ret);
            }
            return ret;
        }

        private void writeLine(String s) throws IOException
        {
            mOut.write(s.getBytes());
            mOut.write('\r');
            mOut.write('\n');
            mOut.flush();
        }

        private Pop3Capabilities getCapabilities() throws IOException, MessagingException
        {
            Pop3Capabilities capabilities = new Pop3Capabilities();
            try
            {
                String response = executeSimpleCommand(""CAPA"");
                while ((response = readLine()) != null)
                {
                    if (response.equals("".""))
                    {
                        break;
                    }
                    if (response.equalsIgnoreCase(""STLS""))
                    {
                        capabilities.stls = true;
                    }
                    else if (response.equalsIgnoreCase(""UIDL""))
                    {
                        capabilities.uidl = true;
                    }
                    else if (response.equalsIgnoreCase(""PIPELINING""))
                    {
                        capabilities.pipelining = true;
                    }
                    else if (response.equalsIgnoreCase(""USER""))
                    {
                        capabilities.user = true;
                    }
                    else if (response.equalsIgnoreCase(""TOP""))
                    {
                        capabilities.top = true;
                    }
                }
            }
            catch (MessagingException me)
            {
                /*
                 * The server may not support the CAPA command, so we just eat this Exception
                 * and allow the empty capabilities object to be returned.
                 */
            }
            return capabilities;
        }

        private String executeSimpleCommand(String command) throws MessagingException
        {
            return executeSimpleCommand(command, false);
        }

        private String executeSimpleCommand(String command, boolean sensitive) throws MessagingException
        {
            try
            {
                open(OpenMode.READ_WRITE);

                if (command != null)
                {
                    if (K9.DEBUG && K9.DEBUG_PROTOCOL_POP3)
                    {
                        if (sensitive && !K9.DEBUG_SENSITIVE)
                        {
                            Log.d(K9.LOG_TAG, "">>> ""
                                  + ""[Command Hidden, Enable Sensitive Debug Logging To Show]"");
                        }
                        else
                        {
                            Log.d(K9.LOG_TAG, "">>> "" + command);
                        }
                    }

                    writeLine(command);
                }

                String response = readLine();
                if (response.length() > 1 && response.charAt(0) == '-')
                {
                    throw new MessagingException(response);
                }

                return response;
            }
            catch (MessagingException me)
            {
                throw me;
            }
            catch (Exception e)
            {
                closeIO();
                throw new MessagingException(""Unable to execute POP3 command"", e);
            }
        }

        @Override
        public boolean supportsFetchingFlags()
        {
            return false;
        }//isFlagSupported

        @Override
        public boolean equals(Object o)
        {
            if (o instanceof Pop3Folder)
            {
                return ((Pop3Folder) o).mName.equals(mName);
            }
            return super.equals(o);
        }

        @Override
        public int hashCode()
        {
            return mName.hashCode();
        }

    }//Pop3Folder

    class Pop3Message extends MimeMessage
    {
        public Pop3Message(String uid, Pop3Folder folder) throws MessagingException
        {
            mUid = uid;
            mFolder = folder;
            mSize = -1;
        }

        public void setSize(int size)
        {
            mSize = size;
        }

        @Override
        protected void parse(InputStream in) throws IOException, MessagingException
        {
            super.parse(in);
        }

        @Override
        public void setFlag(Flag flag, boolean set) throws MessagingException
        {
            super.setFlag(flag, set);
            mFolder.setFlags(new Message[] { this }, new Flag[] { flag }, set);
        }

        @Override
        public void delete(String trashFolderName) throws MessagingException
        {
            //  try
            //  {
            //  Poor POP3 users, we can't copy the message to the Trash folder, but they still want a delete
            setFlag(Flag.DELETED, true);
            //   }
//         catch (MessagingException me)
//         {
//          Log.w(K9.LOG_TAG, ""Could not delete non-existant message"", me);
//         }
        }
    }

    class Pop3Capabilities
    {
        public boolean stls;
        public boolean top;
        public boolean user;
        public boolean uidl;
        public boolean pipelining;

        @Override
        public String toString()
        {
            return String.format(""STLS %b, TOP %b, USER %b, UIDL %b, PIPELINING %b"",
                                 stls,
                                 top,
                                 user,
                                 uidl,
                                 pipelining);
        }
    }

    class Pop3ResponseInputStream extends InputStream
    {
        InputStream mIn;
        boolean mStartOfLine = true;
        boolean mFinished;

        public Pop3ResponseInputStream(InputStream in)
        {
            mIn = in;
        }

        @Override
        public int read() throws IOException
        {
            if (mFinished)
            {
                return -1;
            }
            int d = mIn.read();
            if (mStartOfLine && d == '.')
            {
                d = mIn.read();
                if (d == '\r')
                {
                    mFinished = true;
                    mIn.read();
                    return -1;
                }
            }

            mStartOfLine = (d == '\n');

            return d;
        }
    }
}
",True,216,0,0,7,57,1,15,L1
124,com.fsck.k9.mail.store.ImapResponseParser.java,"package com.fsck.k9.mail.store;

import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.filter.FixedLengthInputStream;
import com.fsck.k9.mail.filter.PeekableInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Locale;

public class ImapResponseParser
{
    private static final SimpleDateFormat mDateTimeFormat = new SimpleDateFormat(""dd-MMM-yyyy HH:mm:ss Z"", Locale.US);
    private static final SimpleDateFormat badDateTimeFormat = new SimpleDateFormat(""dd MMM yyyy HH:mm:ss Z"", Locale.US);
    private static final SimpleDateFormat badDateTimeFormat2 = new SimpleDateFormat(""E, dd MMM yyyy HH:mm:ss Z"", Locale.US);

    private PeekableInputStream mIn;
    private ImapResponse mResponse;
    private Exception mException;

    public ImapResponseParser(PeekableInputStream in)
    {
        this.mIn = in;
    }

    public ImapResponse readResponse() throws IOException
    {
        return readResponse(null);
    }

    /**
     * Reads the next response available on the stream and returns an
     * ImapResponse object that represents it.
     *
     * @return
     * @throws IOException
     */
    public ImapResponse readResponse(IImapResponseCallback callback) throws IOException
    {
        try
        {
            ImapResponse response = new ImapResponse();
            mResponse = response;
            mResponse.mCallback = callback;

            int ch = mIn.peek();
            if (ch == '*')
            {
                parseUntaggedResponse();
                readTokens(response);
            }
            else if (ch == '+')
            {
                response.mCommandContinuationRequested =
                    parseCommandContinuationRequest();
                readTokens(response);
            }
            else
            {
                response.mTag = parseTaggedResponse();
                readTokens(response);
            }
            if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
            {
                Log.v(K9.LOG_TAG, ""<<< "" + response.toString());
            }

            if (mException != null)
            {
                throw new RuntimeException(""readResponse(): Exception in callback method"", mException);
            }

            return response;
        }
        finally
        {
            mResponse.mCallback = null;
            mResponse = null;
            mException = null;
        }
    }

    private void readTokens(ImapResponse response) throws IOException
    {
        response.clear();
        Object token;
        while ((token = readToken(response)) != null)
        {
            if (!(token instanceof ImapList))
            {
                response.add(token);
            }
        }
        response.mCompleted = token == null;
    }

    /**
     * Reads the next token of the response. The token can be one of: String -
     * for NIL, QUOTED, NUMBER, ATOM. InputStream - for LITERAL.
     * InputStream.available() returns the total length of the stream.
     * ImapResponseList - for PARENTHESIZED LIST. Can contain any of the above
     * elements including List.
     *
     * @return The next token in the response or null if there are no more
     *         tokens.
     * @throws IOException
     */
    private Object readToken(ImapResponse response) throws IOException
    {
        while (true)
        {
            Object token = parseToken(response);
            if (token == null || !(token.equals("")"") || token.equals(""]"")))
            {
                return token;
            }
        }
    }

    private Object parseToken(ImapList parent) throws IOException
    {
        while (true)
        {
            int ch = mIn.peek();
            if (ch == '(')
            {
                return parseList(parent);
            }
            else if (ch == '[')
            {
                return parseSequence(parent);
            }
            else if (ch == ')')
            {
                expect(')');
                return "")"";
            }
            else if (ch == ']')
            {
                expect(']');
                return ""]"";
            }
            else if (ch == '""')
            {
                return parseQuoted();
            }
            else if (ch == '{')
            {
                return parseLiteral();
            }
            else if (ch == ' ')
            {
                expect(' ');
            }
            else if (ch == '\r')
            {
                expect('\r');
                expect('\n');
                return null;
            }
            else if (ch == '\n')
            {
                expect('\n');
                return null;
            }
            else if (ch == '\t')
            {
                expect('\t');
            }
            else
            {
                return parseAtom();
            }
        }
    }

    private boolean parseCommandContinuationRequest() throws IOException
    {
        expect('+');
        return true;
    }

    // * OK [UIDNEXT 175] Predicted next UID
    private void parseUntaggedResponse() throws IOException
    {
        expect('*');
        expect(' ');
    }

    // 3 OK [READ-WRITE] Select completed.
    private String parseTaggedResponse() throws IOException
    {
        String tag = readStringUntil(' ');
        return tag;
    }

    private ImapList parseList(ImapList parent) throws IOException
    {
        expect('(');
        ImapList list = new ImapList();
        parent.add(list);
        Object token;
        while (true)
        {
            token = parseToken(list);
            if (token == null)
            {
                break;
            }
            else if (token.equals("")""))
            {
                break;
            }
            else if (token instanceof ImapList)
            {
                // Do nothing
            }
            else
            {
                list.add(token);
            }
        }
        return list;
    }

    private ImapList parseSequence(ImapList parent) throws IOException
    {
        expect('[');
        ImapList list = new ImapList();
        parent.add(list);
        Object token;
        while (true)
        {
            token = parseToken(list);
            if (token == null)
            {
                break;
            }
            else if (token.equals(""]""))
            {
                break;
            }
            else if (token instanceof ImapList)
            {
                // Do nothing
            }
            else
            {
                list.add(token);
            }
        }
        return list;
    }

    private String parseAtom() throws IOException
    {
        StringBuffer sb = new StringBuffer();
        int ch;
        while (true)
        {
            ch = mIn.peek();
            if (ch == -1)
            {
                throw new IOException(""parseAtom(): end of stream reached"");
            }
            else if (ch == '(' || ch == ')' || ch == '{' || ch == ' ' ||
                     ch == '[' || ch == ']' ||
                     // docs claim that flags are \ atom but atom isn't supposed to
                     // contain
                     // * and some falgs contain *
                     // ch == '%' || ch == '*' ||
//                    ch == '%' ||
                     // TODO probably should not allow \ and should recognize
                     // it as a flag instead
                     // ch == '""' || ch == '\' ||
                     ch == '""' || (ch >= 0x00 && ch <= 0x1f) || ch == 0x7f)
            {
                if (sb.length() == 0)
                {
                    throw new IOException(String.format(""parseAtom(): (%04x %c)"", (int)ch, ch));
                }
                return sb.toString();
            }
            else
            {
                sb.append((char)mIn.read());
            }
        }
    }

    /**
     * A { has been read, read the rest of the size string, the space and then
     * notify the listener with an InputStream.
     *
     * @param mListener
     * @throws IOException
     */
    private Object parseLiteral() throws IOException
    {
        expect('{');
        int size = Integer.parseInt(readStringUntil('}'));
        expect('\r');
        expect('\n');

        if (size == 0)
        {
            return """";
        }

        if (mResponse.mCallback != null)
        {
            FixedLengthInputStream fixed = new FixedLengthInputStream(mIn, size);

            Object result = null;
            try
            {
                result = mResponse.mCallback.foundLiteral(mResponse, fixed);
            }
            catch (IOException e)
            {
                // Pass IOExceptions through
                throw e;
            }
            catch (Exception e)
            {
                // Catch everything else and save it for later.
                mException = e;
                //Log.e(K9.LOG_TAG, ""parseLiteral(): Exception in callback method"", e);
            }

            // Check if only some of the literal data was read
            int available = fixed.available();
            if ((available > 0) && (available != size))
            {
                // If so, skip the rest
                fixed.skip(fixed.available());
            }

            if (result != null)
            {
                return result;
            }
        }

        byte[] data = new byte[size];
        int read = 0;
        while (read != size)
        {
            int count = mIn.read(data, read, size - read);
            if (count == -1)
            {
                throw new IOException(""parseLiteral(): end of stream reached"");
            }
            read += count;
        }

        return new String(data, ""US-ASCII"");
    }

    /**
     * A "" has been read, read to the end of the quoted string and notify the
     * listener.
     *
     * @param mListener
     * @throws IOException
     */
    private String parseQuoted() throws IOException
    {
        expect('""');

        StringBuffer sb = new StringBuffer();
        int ch;
        boolean escape = false;
        while ((ch = mIn.read()) != -1)
        {
            if (!escape && (ch == '\\'))
            {
                // Found the escape character
                escape = true;
            }
            else if (!escape && (ch == '""'))
            {
                return sb.toString();
            }
            else
            {
                sb.append((char)ch);
                escape = false;
            }
        }
        throw new IOException(""parseQuoted(): end of stream reached"");
    }

    private String readStringUntil(char end) throws IOException
    {
        StringBuffer sb = new StringBuffer();
        int ch;
        while ((ch = mIn.read()) != -1)
        {
            if (ch == end)
            {
                return sb.toString();
            }
            else
            {
                sb.append((char)ch);
            }
        }
        throw new IOException(""readStringUntil(): end of stream reached"");
    }

    private int expect(char ch) throws IOException
    {
        int d;
        if ((d = mIn.read()) != ch)
        {
            throw new IOException(String.format(""Expected %04x (%c) but got %04x (%c)"", (int)ch,
                                                ch, d, (char)d));
        }
        return d;
    }

    /**
     * Represents an IMAP LIST response and is also the base class for the
     * ImapResponse.
     */
    public class ImapList extends ArrayList<Object>
    {
        public ImapList getList(int index)
        {
            return (ImapList)get(index);
        }

        public Object getObject(int index)
        {
            return get(index);
        }

        public String getString(int index)
        {
            return (String)get(index);
        }

        public InputStream getLiteral(int index)
        {
            return (InputStream)get(index);
        }

        public int getNumber(int index)
        {
            return Integer.parseInt(getString(index));
        }

        public Date getDate(int index) throws MessagingException
        {
            try
            {
                return parseDate(getString(index));
            }
            catch (ParseException pe)
            {
                throw new MessagingException(""Unable to parse IMAP datetime"", pe);
            }
        }

        public Object getKeyedValue(Object key)
        {
            for (int i = 0, count = size(); i < count; i++)
            {
                if (equalsIgnoreCase(get(i), key))
                {
                    return get(i + 1);
                }
            }
            return null;
        }

        public ImapList getKeyedList(Object key)
        {
            return (ImapList)getKeyedValue(key);
        }

        public String getKeyedString(Object key)
        {
            return (String)getKeyedValue(key);
        }

        public InputStream getKeyedLiteral(Object key)
        {
            return (InputStream)getKeyedValue(key);
        }

        public int getKeyedNumber(Object key)
        {
            return Integer.parseInt(getKeyedString(key));
        }

        public Date getKeyedDate(Object key) throws MessagingException
        {
            try
            {
                String value = getKeyedString(key);
                if (value == null)
                {
                    return null;
                }
                return parseDate(value);
            }
            catch (ParseException pe)
            {
                throw new MessagingException(""Unable to parse IMAP datetime"", pe);
            }
        }

        public boolean containsKey(Object key)
        {
            if (key == null)
            {
                return false;
            }

            for (int i = 0, count = size(); i < count; i++)
            {
                if (equalsIgnoreCase(key, get(i)))
                {
                    return true;
                }
            }
            return false;
        }

        public int getKeyIndex(Object key)
        {
            for (int i = 0, count = size(); i < count; i++)
            {
                if (equalsIgnoreCase(key, get(i)))
                {
                    return i;
                }
            }

            throw new IllegalArgumentException(""getKeyIndex() only works for keys that are in the collection."");
        }

        private Date parseDate(String value) throws ParseException
        {
            //TODO: clean this up a bit
            try
            {
                synchronized (mDateTimeFormat)
                {
                    return mDateTimeFormat.parse(value);
                }
            }
            catch (Exception e)
            {
                try
                {
                    synchronized (badDateTimeFormat)
                    {
                        return badDateTimeFormat.parse(value);
                    }
                }
                catch (Exception e2)
                {
                    synchronized (badDateTimeFormat2)
                    {
                        return badDateTimeFormat2.parse(value);
                    }
                }
            }

        }

    }

    /**
     * Represents a single response from the IMAP server. Tagged responses will
     * have a non-null tag. Untagged responses will have a null tag. The object
     * will contain all of the available tokens at the time the response is
     * received. In general, it will either contain all of the tokens of the
     * response or all of the tokens up until the first LITERAL. If the object
     * does not contain the entire response the caller must call more() to
     * continue reading the response until more returns false.
     */
    public class ImapResponse extends ImapList
    {
        private boolean mCompleted;
        private IImapResponseCallback mCallback;

        boolean mCommandContinuationRequested;
        String mTag;

        public boolean more() throws IOException
        {
            if (mCompleted)
            {
                return false;
            }
            readTokens(this);
            return true;
        }

        public String getAlertText()
        {
            if (size() > 1 && equalsIgnoreCase(""[ALERT]"", get(1)))
            {
                StringBuffer sb = new StringBuffer();
                for (int i = 2, count = size(); i < count; i++)
                {
                    sb.append(get(i).toString());
                    sb.append(' ');
                }
                return sb.toString();
            }
            else
            {
                return null;
            }
        }

        @Override
        public String toString()
        {
            return ""#"" + (mCommandContinuationRequested ? ""+"" : mTag) + ""# "" + super.toString();
        }
    }
    public static boolean equalsIgnoreCase(Object o1, Object o2)
    {
        if (o1 != null && o2 != null && o1 instanceof String && o2 instanceof String)
        {
            String s1 = (String)o1;
            String s2 = (String)o2;
            return s1.equalsIgnoreCase(s2);
        }
        else if (o1 != null)
        {
            return o1.equals(o2);
        }
        else if (o2 != null)
        {
            return o2.equals(o1);
        }
        else
        {
            return o1 == o2;
        }
    }

    public interface IImapResponseCallback
    {
        /**
         * Callback method that is called by the parser when a literal string
         * is found in an IMAP response.
         *
         * @param response ImapResponse object with the fields that have been
         *                 parsed up until now (excluding the literal string).
         * @param literal  FixedLengthInputStream that can be used to access
         *                 the literal string.
         *
         * @return an Object that will be put in the ImapResponse object at the
         *         place of the literal string.
         *
         * @throws IOException passed-through if thrown by FixedLengthInputStream
         * @throws Exception if something goes wrong. Parsing will be resumed
         *                   and the exception will be thrown after the
         *                   complete IMAP response has been parsed.
         */
        public Object foundLiteral(ImapResponse response, FixedLengthInputStream literal)
        throws IOException, Exception;
    }
}
",True,216,0,0,9,56,1,4,L1
125,com.fsck.k9.mail.store.LocalStore.java,"
package com.fsck.k9.mail.store;

import android.app.Application;
import android.content.ContentValues;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.net.Uri;
import android.util.Log;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.Preferences;
import com.fsck.k9.controller.MessageRemovalListener;
import com.fsck.k9.controller.MessageRetrievalListener;
import com.fsck.k9.helper.Regex;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.Message.RecipientType;
import com.fsck.k9.mail.filter.Base64OutputStream;
import com.fsck.k9.mail.internet.*;
import com.fsck.k9.provider.AttachmentProvider;
import org.apache.commons.io.IOUtils;

import java.io.*;
import java.net.URI;
import java.net.URLEncoder;
import java.util.*;
import java.util.regex.Matcher;

/**
 * <pre>
 * Implements a SQLite database backed local store for Messages.
 * </pre>
 */
public class LocalStore extends Store implements Serializable
{

    private static final Message[] EMPTY_MESSAGE_ARRAY = new Message[0];

    /**
     * Immutable empty {@link String} array
     */
    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    private static final int DB_VERSION = 38;
    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED, Flag.X_DESTROYED, Flag.SEEN, Flag.FLAGGED };

    private String mPath;
    private SQLiteDatabase mDb;
    private File mAttachmentsDir;
    private Application mApplication;
    private String uUid = null;

    private static Set<String> HEADERS_TO_SAVE = new HashSet<String>();
    static
    {
        HEADERS_TO_SAVE.add(K9.K9MAIL_IDENTITY);
        HEADERS_TO_SAVE.add(""To"");
        HEADERS_TO_SAVE.add(""Cc"");
        HEADERS_TO_SAVE.add(""From"");
        HEADERS_TO_SAVE.add(""In-Reply-To"");
        HEADERS_TO_SAVE.add(""References"");
        HEADERS_TO_SAVE.add(""Content-ID"");
        HEADERS_TO_SAVE.add(""Content-Disposition"");
        HEADERS_TO_SAVE.add(""X-User-Agent"");
    }
    /*
     * a String containing the columns getMessages expects to work with
     * in the correct order.
     */
    static private String GET_MESSAGES_COLS =
        ""subject, sender_list, date, uid, flags, id, to_list, cc_list, ""
        + ""bcc_list, reply_to_list, attachment_count, internal_date, message_id, folder_id, preview "";

    /**
     * local://localhost/path/to/database/uuid.db
     */
    public LocalStore(Account account, Application application) throws MessagingException
    {
        super(account);
        mApplication = application;
        URI uri = null;
        try
        {
            uri = new URI(mAccount.getLocalStoreUri());
        }
        catch (Exception e)
        {
            throw new MessagingException(""Invalid uri for LocalStore"");
        }
        if (!uri.getScheme().equals(""local""))
        {
            throw new MessagingException(""Invalid scheme"");
        }
        mPath = uri.getPath();


        // We need to associate the localstore with the account.  Since we don't have the account
        // handy here, we'll take the filename from the DB and use the basename of the filename
        // Folders probably should have references to their containing accounts
        //TODO: We do have an account object now
        File dbFile = new File(mPath);
        String[] tokens = dbFile.getName().split(""\\."");
        uUid = tokens[0];

        openOrCreateDataspace(application);

    }

    private void openOrCreateDataspace(Application application)
    {
        File parentDir = new File(mPath).getParentFile();
        if (!parentDir.exists())
        {
            parentDir.mkdirs();
        }

        mAttachmentsDir = new File(mPath + ""_att"");
        if (!mAttachmentsDir.exists())
        {
            mAttachmentsDir.mkdirs();
        }

        mDb = SQLiteDatabase.openOrCreateDatabase(mPath, null);
        if (mDb.getVersion() != DB_VERSION)
        {
            doDbUpgrade(mDb, application);
        }
    }

    private void doDbUpgrade(SQLiteDatabase mDb, Application application)
    {
        Log.i(K9.LOG_TAG, String.format(""Upgrading database from version %d to version %d"",
                                        mDb.getVersion(), DB_VERSION));


        AttachmentProvider.clear(application);

        try
        {
            // schema version 29 was when we moved to incremental updates
            // in the case of a new db or a < v29 db, we blow away and start from scratch
            if (mDb.getVersion() < 29)
            {

                mDb.execSQL(""DROP TABLE IF EXISTS folders"");
                mDb.execSQL(""CREATE TABLE folders (id INTEGER PRIMARY KEY, name TEXT, ""
                            + ""last_updated INTEGER, unread_count INTEGER, visible_limit INTEGER, status TEXT, push_state TEXT, last_pushed INTEGER, flagged_count INTEGER default 0)"");

                mDb.execSQL(""CREATE INDEX IF NOT EXISTS folder_name ON folders (name)"");
                mDb.execSQL(""DROP TABLE IF EXISTS messages"");
                mDb.execSQL(""CREATE TABLE messages (id INTEGER PRIMARY KEY, deleted INTEGER default 0, folder_id INTEGER, uid TEXT, subject TEXT, ""
                            + ""date INTEGER, flags TEXT, sender_list TEXT, to_list TEXT, cc_list TEXT, bcc_list TEXT, reply_to_list TEXT, ""
                            + ""html_content TEXT, text_content TEXT, attachment_count INTEGER, internal_date INTEGER, message_id TEXT, preview TEXT)"");

                mDb.execSQL(""DROP TABLE IF EXISTS headers"");
                mDb.execSQL(""CREATE TABLE headers (id INTEGER PRIMARY KEY, message_id INTEGER, name TEXT, value TEXT)"");
                mDb.execSQL(""CREATE INDEX IF NOT EXISTS header_folder ON headers (message_id)"");

                mDb.execSQL(""CREATE INDEX IF NOT EXISTS msg_uid ON messages (uid, folder_id)"");
                mDb.execSQL(""DROP INDEX IF EXISTS msg_folder_id"");
                mDb.execSQL(""DROP INDEX IF EXISTS msg_folder_id_date"");
                mDb.execSQL(""CREATE INDEX IF NOT EXISTS msg_folder_id_deleted_date ON messages (folder_id,deleted,internal_date)"");
                mDb.execSQL(""DROP TABLE IF EXISTS attachments"");
                mDb.execSQL(""CREATE TABLE attachments (id INTEGER PRIMARY KEY, message_id INTEGER,""
                            + ""store_data TEXT, content_uri TEXT, size INTEGER, name TEXT,""
                            + ""mime_type TEXT, content_id TEXT, content_disposition TEXT)"");

                mDb.execSQL(""DROP TABLE IF EXISTS pending_commands"");
                mDb.execSQL(""CREATE TABLE pending_commands "" +
                            ""(id INTEGER PRIMARY KEY, command TEXT, arguments TEXT)"");

                mDb.execSQL(""DROP TRIGGER IF EXISTS delete_folder"");
                mDb.execSQL(""CREATE TRIGGER delete_folder BEFORE DELETE ON folders BEGIN DELETE FROM messages WHERE old.id = folder_id; END;"");

                mDb.execSQL(""DROP TRIGGER IF EXISTS delete_message"");
                mDb.execSQL(""CREATE TRIGGER delete_message BEFORE DELETE ON messages BEGIN DELETE FROM attachments WHERE old.id = message_id; ""
                            + ""DELETE FROM headers where old.id = message_id; END;"");
            }
            else
            { // in the case that we're starting out at 29 or newer, run all the needed updates

                if (mDb.getVersion() < 30)
                {
                    try
                    {
                        mDb.execSQL(""ALTER TABLE messages ADD deleted INTEGER default 0"");
                    }
                    catch (SQLiteException e)
                    {
                        if (! e.toString().startsWith(""duplicate column name: deleted""))
                        {
                            throw e;
                        }
                    }
                }
                if (mDb.getVersion() < 31)
                {
                    mDb.execSQL(""DROP INDEX IF EXISTS msg_folder_id_date"");
                    mDb.execSQL(""CREATE INDEX IF NOT EXISTS msg_folder_id_deleted_date ON messages (folder_id,deleted,internal_date)"");
                }
                if (mDb.getVersion() < 32)
                {
                    mDb.execSQL(""UPDATE messages SET deleted = 1 WHERE flags LIKE '%DELETED%'"");
                }
                if (mDb.getVersion() < 33)
                {

                    try
                    {
                        mDb.execSQL(""ALTER TABLE messages ADD preview TEXT"");
                    }
                    catch (SQLiteException e)
                    {
                        if (! e.toString().startsWith(""duplicate column name: preview""))
                        {
                            throw e;
                        }
                    }

                }
                if (mDb.getVersion() < 34)
                {
                    try
                    {
                        mDb.execSQL(""ALTER TABLE folders ADD flagged_count INTEGER default 0"");
                    }
                    catch (SQLiteException e)
                    {
                        if (! e.getMessage().startsWith(""duplicate column name: flagged_count""))
                        {
                            throw e;
                        }
                    }
                }
                if (mDb.getVersion() < 35)
                {
                    try
                    {
                        mDb.execSQL(""update messages set flags = replace(flags, 'X_NO_SEEN_INFO', 'X_BAD_FLAG')"");
                    }
                    catch (SQLiteException e)
                    {
                        Log.e(K9.LOG_TAG, ""Unable to get rid of obsolete flag X_NO_SEEN_INFO"", e);
                    }
                }
                if (mDb.getVersion() < 36)
                {
                    try
                    {
                        mDb.execSQL(""ALTER TABLE attachments ADD content_id TEXT"");
                    }
                    catch (SQLiteException e)
                    {
                        Log.e(K9.LOG_TAG, ""Unable to add content_id column to attachments"");
                    }
                }
                if (mDb.getVersion() < 37)
                {
                    try
                    {
                        mDb.execSQL(""ALTER TABLE attachments ADD content_disposition TEXT"");
                    }
                    catch (SQLiteException e)
                    {
                        Log.e(K9.LOG_TAG, ""Unable to add content_disposition column to attachments"");
                    }
                }


                // Database version 38 is solely to prune cached attachments now that we clear them better

            }

        }
        catch (SQLiteException e)
        {
            Log.e(K9.LOG_TAG, ""Exception while upgrading database. Resetting the DB to v0"");
            mDb.setVersion(0);
            throw new Error(""Database upgrade failed! Resetting your DB version to 0 to force a full schema recreation."");
        }



        mDb.setVersion(DB_VERSION);

        if (mDb.getVersion() != DB_VERSION)
        {
            throw new Error(""Database upgrade failed!"");
        }

        try
        {
            pruneCachedAttachments(true);
        }
        catch (Exception me)
        {
            Log.e(K9.LOG_TAG, ""Exception while force pruning attachments during DB update"", me);
        }
    }

    public long getSize()
    {
        long attachmentLength = 0;

        File[] files = mAttachmentsDir.listFiles();
        for (File file : files)
        {
            if (file.exists())
            {
                attachmentLength += file.length();
            }
        }


        File dbFile = new File(mPath);
        return dbFile.length() + attachmentLength;
    }

    public void compact() throws MessagingException
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Before prune size = "" + getSize());

        pruneCachedAttachments();
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""After prune / before compaction size = "" + getSize());

        mDb.execSQL(""VACUUM"");
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""After compaction size = "" + getSize());
    }


    public void clear() throws MessagingException
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Before prune size = "" + getSize());

        pruneCachedAttachments(true);
        if (K9.DEBUG)
        {
            Log.i(K9.LOG_TAG, ""After prune / before compaction size = "" + getSize());

            Log.i(K9.LOG_TAG, ""Before clear folder count = "" + getFolderCount());
            Log.i(K9.LOG_TAG, ""Before clear message count = "" + getMessageCount());

            Log.i(K9.LOG_TAG, ""After prune / before clear size = "" + getSize());
        }
        // don't delete messages that are Local, since there is no copy on the server.
        // Don't delete deleted messages.  They are essentially placeholders for UIDs of messages that have
        // been deleted locally.  They take up insignificant space
        mDb.execSQL(""DELETE FROM messages WHERE deleted = 0 and uid not like 'Local%'"");
        mDb.execSQL(""update folders set flagged_count = 0, unread_count = 0"");

        compact();
        if (K9.DEBUG)
        {
            Log.i(K9.LOG_TAG, ""After clear message count = "" + getMessageCount());

            Log.i(K9.LOG_TAG, ""After clear size = "" + getSize());
        }
    }

    public int getMessageCount() throws MessagingException
    {
        Cursor cursor = null;
        try
        {
            cursor = mDb.rawQuery(""SELECT COUNT(*) FROM messages"", null);
            cursor.moveToFirst();
            int messageCount = cursor.getInt(0);
            return messageCount;
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
        }
    }

    public int getFolderCount() throws MessagingException
    {
        Cursor cursor = null;
        try
        {
            cursor = mDb.rawQuery(""SELECT COUNT(*) FROM folders"", null);
            cursor.moveToFirst();
            int messageCount = cursor.getInt(0);
            return messageCount;
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
        }
    }

    @Override
    public LocalFolder getFolder(String name) throws MessagingException
    {
        return new LocalFolder(name);
    }

    // TODO this takes about 260-300ms, seems slow.
    @Override
    public List<? extends Folder> getPersonalNamespaces(boolean forceListAll) throws MessagingException
    {
        LinkedList<LocalFolder> folders = new LinkedList<LocalFolder>();
        Cursor cursor = null;

        try
        {
            cursor = mDb.rawQuery(""SELECT id, name, unread_count, visible_limit, last_updated, status, push_state, last_pushed, flagged_count FROM folders"", null);
            while (cursor.moveToNext())
            {
                LocalFolder folder = new LocalFolder(cursor.getString(1));
                folder.open(cursor.getInt(0), cursor.getString(1), cursor.getInt(2), cursor.getInt(3), cursor.getLong(4), cursor.getString(5), cursor.getString(6), cursor.getLong(7), cursor.getInt(8));

                folders.add(folder);
            }
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
        }
        return folders;
    }

    @Override
    public void checkSettings() throws MessagingException
    {
    }

    /**
     * Delete the entire Store and it's backing database.
     */
    public void delete()
    {
        try
        {
            mDb.close();
        }
        catch (Exception e)
        {

        }
        try
        {
            File[] attachments = mAttachmentsDir.listFiles();
            for (File attachment : attachments)
            {
                if (attachment.exists())
                {
                    attachment.delete();
                }
            }
            if (mAttachmentsDir.exists())
            {
                mAttachmentsDir.delete();
            }
        }
        catch (Exception e)
        {
        }
        try
        {
            new File(mPath).delete();
        }
        catch (Exception e)
        {

        }
    }

    public void recreate()
    {
        delete();
        openOrCreateDataspace(mApplication);
    }

    public void pruneCachedAttachments() throws MessagingException
    {
        pruneCachedAttachments(false);
    }

    /**
     * Deletes all cached attachments for the entire store.
     */
    public void pruneCachedAttachments(boolean force) throws MessagingException
    {

        if (force)
        {
            ContentValues cv = new ContentValues();
            cv.putNull(""content_uri"");
            mDb.update(""attachments"", cv, null, null);
        }
        File[] files = mAttachmentsDir.listFiles();
        for (File file : files)
        {
            if (file.exists())
            {
                if (!force)
                {
                    Cursor cursor = null;
                    try
                    {
                        cursor = mDb.query(
                                     ""attachments"",
                                     new String[] { ""store_data"" },
                                     ""id = ?"",
                                     new String[] { file.getName() },
                                     null,
                                     null,
                                     null);
                        if (cursor.moveToNext())
                        {
                            if (cursor.getString(0) == null)
                            {
                                if (K9.DEBUG)
                                    Log.d(K9.LOG_TAG, ""Attachment "" + file.getAbsolutePath() + "" has no store data, not deleting"");
                                /*
                                 * If the attachment has no store data it is not recoverable, so
                                 * we won't delete it.
                                 */
                                continue;
                            }
                        }
                    }
                    finally
                    {
                        if (cursor != null)
                        {
                            cursor.close();
                        }
                    }
                }
                if (!force)
                {
                    try
                    {
                        ContentValues cv = new ContentValues();
                        cv.putNull(""content_uri"");
                        mDb.update(""attachments"", cv, ""id = ?"", new String[] { file.getName() });
                    }
                    catch (Exception e)
                    {
                        /*
                         * If the row has gone away before we got to mark it not-downloaded that's
                         * okay.
                         */
                    }
                }
                if (!file.delete())
                {
                    file.deleteOnExit();
                }
            }
        }
    }

    public void resetVisibleLimits()
    {
        resetVisibleLimits(mAccount.getDisplayCount());
    }

    public void resetVisibleLimits(int visibleLimit)
    {
        ContentValues cv = new ContentValues();
        cv.put(""visible_limit"", Integer.toString(visibleLimit));
        mDb.update(""folders"", cv, null, null);
    }

    public ArrayList<PendingCommand> getPendingCommands()
    {
        Cursor cursor = null;
        try
        {
            cursor = mDb.query(""pending_commands"",
                               new String[] { ""id"", ""command"", ""arguments"" },
                               null,
                               null,
                               null,
                               null,
                               ""id ASC"");
            ArrayList<PendingCommand> commands = new ArrayList<PendingCommand>();
            while (cursor.moveToNext())
            {
                PendingCommand command = new PendingCommand();
                command.mId = cursor.getLong(0);
                command.command = cursor.getString(1);
                String arguments = cursor.getString(2);
                command.arguments = arguments.split("","");
                for (int i = 0; i < command.arguments.length; i++)
                {
                    command.arguments[i] = Utility.fastUrlDecode(command.arguments[i]);
                }
                commands.add(command);
            }
            return commands;
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
        }
    }

    public void addPendingCommand(PendingCommand command)
    {
        try
        {
            for (int i = 0; i < command.arguments.length; i++)
            {
                command.arguments[i] = URLEncoder.encode(command.arguments[i], ""UTF-8"");
            }
            ContentValues cv = new ContentValues();
            cv.put(""command"", command.command);
            cv.put(""arguments"", Utility.combine(command.arguments, ','));
            mDb.insert(""pending_commands"", ""command"", cv);
        }
        catch (UnsupportedEncodingException usee)
        {
            throw new Error(""Aparently UTF-8 has been lost to the annals of history."");
        }
    }

    public void removePendingCommand(PendingCommand command)
    {
        mDb.delete(""pending_commands"", ""id = ?"", new String[] { Long.toString(command.mId) });
    }

    public void removePendingCommands()
    {
        mDb.delete(""pending_commands"", null, null);
    }

    public static class PendingCommand
    {
        private long mId;
        public String command;
        public String[] arguments;

        @Override
        public String toString()
        {
            StringBuffer sb = new StringBuffer();
            sb.append(command);
            sb.append("": "");
            for (String argument : arguments)
            {
                sb.append("", "");
                sb.append(argument);
                //sb.append(""\n"");
            }
            return sb.toString();
        }
    }

    @Override
    public boolean isMoveCapable()
    {
        return true;
    }

    @Override
    public boolean isCopyCapable()
    {
        return true;
    }

    public Message[] searchForMessages(MessageRetrievalListener listener, String[] queryFields, String queryString,
                                       List<LocalFolder> folders, Message[] messages, final Flag[] requiredFlags, final Flag[] forbiddenFlags) throws MessagingException
    {
        List<String> args = new LinkedList<String>();

        StringBuilder whereClause = new StringBuilder();
        if (queryString != null && queryString.length() > 0)
        {
            boolean anyAdded = false;
            String likeString = ""%""+queryString+""%"";
            whereClause.append("" AND ("");
            for (String queryField : queryFields)
            {

                if (anyAdded)
                {
                    whereClause.append("" OR "");
                }
                whereClause.append(queryField + "" LIKE ? "");
                args.add(likeString);
                anyAdded = true;
            }


            whereClause.append("" )"");
        }
        if (folders != null && folders.size() > 0)
        {
            whereClause.append("" AND folder_id in ("");
            boolean anyAdded = false;
            for (LocalFolder folder : folders)
            {
                if (anyAdded)
                {
                    whereClause.append("","");
                }
                anyAdded = true;
                whereClause.append(""?"");
                args.add(Long.toString(folder.getId()));
            }
            whereClause.append("" )"");
        }
        if (messages != null && messages.length > 0)
        {
            whereClause.append("" AND ( "");
            boolean anyAdded = false;
            for (Message message : messages)
            {
                if (anyAdded)
                {
                    whereClause.append("" OR "");
                }
                anyAdded = true;
                whereClause.append("" ( uid = ? AND folder_id = ? ) "");
                args.add(message.getUid());
                args.add(Long.toString(((LocalFolder)message.getFolder()).getId()));
            }
            whereClause.append("" )"");
        }
        if (forbiddenFlags != null && forbiddenFlags.length > 0)
        {
            whereClause.append("" AND ("");
            boolean anyAdded = false;
            for (Flag flag : forbiddenFlags)
            {
                if (anyAdded)
                {
                    whereClause.append("" AND "");
                }
                anyAdded = true;
                whereClause.append("" flags NOT LIKE ?"");

                args.add(""%"" + flag.toString() + ""%"");
            }
            whereClause.append("" )"");
        }
        if (requiredFlags != null && requiredFlags.length > 0)
        {
            whereClause.append("" AND ("");
            boolean anyAdded = false;
            for (Flag flag : requiredFlags)
            {
                if (anyAdded)
                {
                    whereClause.append("" OR "");
                }
                anyAdded = true;
                whereClause.append("" flags LIKE ?"");

                args.add(""%"" + flag.toString() + ""%"");
            }
            whereClause.append("" )"");
        }

        if (K9.DEBUG)
        {
            Log.v(K9.LOG_TAG, ""whereClause = "" + whereClause.toString());
            Log.v(K9.LOG_TAG, ""args = "" + args);
        }
        return getMessages(
                   listener,
                   null,
                   ""SELECT ""
                   + GET_MESSAGES_COLS
                   + ""FROM messages WHERE deleted = 0 "" + whereClause.toString() + "" ORDER BY date DESC""
                   , args.toArray(EMPTY_STRING_ARRAY)
               );
    }
    /*
     * Given a query string, actually do the query for the messages and
     * call the MessageRetrievalListener for each one
     */
    private Message[] getMessages(
        MessageRetrievalListener listener,
        LocalFolder folder,
        String queryString, String[] placeHolders
    ) throws MessagingException
    {
        ArrayList<LocalMessage> messages = new ArrayList<LocalMessage>();
        Cursor cursor = null;
        try
        {
            // pull out messages most recent first, since that's what the default sort is
            cursor = mDb.rawQuery(queryString, placeHolders);


            int i = 0;
            while (cursor.moveToNext())
            {
                LocalMessage message = new LocalMessage(null, folder);
                message.populateFromGetMessageCursor(cursor);

                messages.add(message);
                if (listener != null)
                {
                    listener.messageFinished(message, i, -1);
                }
                i++;
            }
            if (listener != null)
            {
                listener.messagesFinished(i);
            }
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
        }

        return messages.toArray(EMPTY_MESSAGE_ARRAY);

    }


    public class LocalFolder extends Folder implements Serializable
    {
        private String mName = null;
        private long mFolderId = -1;
        private int mUnreadMessageCount = -1;
        private int mFlaggedMessageCount = -1;
        private int mVisibleLimit = -1;
        private FolderClass displayClass = FolderClass.NO_CLASS;
        private FolderClass syncClass = FolderClass.INHERITED;
        private FolderClass pushClass = FolderClass.SECOND_CLASS;
        private boolean inTopGroup = false;
        private String prefId = null;
        private String mPushState = null;
        private boolean mIntegrate = false;


        public LocalFolder(String name)
        {
            super(LocalStore.this.mAccount);
            this.mName = name;

            if (K9.INBOX.equals(getName()))
            {
                syncClass =  FolderClass.FIRST_CLASS;
                pushClass =  FolderClass.FIRST_CLASS;
                inTopGroup = true;
            }


        }

        public LocalFolder(long id)
        {
            super(LocalStore.this.mAccount);
            this.mFolderId = id;
        }

        public long getId()
        {
            return mFolderId;
        }

        @Override
        public void open(OpenMode mode) throws MessagingException
        {
            if (isOpen())
            {
                return;
            }
            Cursor cursor = null;
            try
            {
                String baseQuery =
                    ""SELECT id, name,unread_count, visible_limit, last_updated, status, push_state, last_pushed, flagged_count FROM folders "";
                if (mName != null)
                {
                    cursor = mDb.rawQuery(baseQuery + ""where folders.name = ?"", new String[] { mName });
                }
                else
                {
                    cursor = mDb.rawQuery(baseQuery + ""where folders.id = ?"", new String[] { Long.toString(mFolderId) });


                }

                if (cursor.moveToFirst())
                {
                    int folderId = cursor.getInt(0);
                    if (folderId > 0)
                    {
                        open(folderId, cursor.getString(1), cursor.getInt(2), cursor.getInt(3), cursor.getLong(4), cursor.getString(5), cursor.getString(6), cursor.getLong(7), cursor.getInt(8));
                    }
                }
                else
                {
                    Log.w(K9.LOG_TAG, ""Creating folder "" + getName() + "" with existing id "" + getId());
                    create(FolderType.HOLDS_MESSAGES);
                    open(mode);
                }
            }
            finally
            {
                if (cursor != null)
                {
                    cursor.close();
                }
            }
        }

        private void open(int id, String name, int unreadCount, int visibleLimit, long lastChecked, String status, String pushState, long lastPushed, int flaggedCount) throws MessagingException
        {
            mFolderId = id;
            mName = name;
            mUnreadMessageCount = unreadCount;
            mVisibleLimit = visibleLimit;
            mPushState = pushState;
            mFlaggedMessageCount = flaggedCount;
            super.setStatus(status);
            // Only want to set the local variable stored in the super class.  This class
            // does a DB update on setLastChecked
            super.setLastChecked(lastChecked);
            super.setLastPush(lastPushed);
        }

        @Override
        public boolean isOpen()
        {
            return (mFolderId != -1 && mName != null);
        }

        @Override
        public OpenMode getMode() throws MessagingException
        {
            return OpenMode.READ_WRITE;
        }

        @Override
        public String getName()
        {
            return mName;
        }

        @Override
        public boolean exists() throws MessagingException
        {
            Cursor cursor = null;
            try
            {
                cursor = mDb.rawQuery(""SELECT id FROM folders ""
                                      + ""where folders.name = ?"", new String[] { this
                                              .getName()
                                                                               });
                if (cursor.moveToFirst())
                {
                    int folderId = cursor.getInt(0);
                    return (folderId > 0);
                }
                else
                {
                    return false;
                }
            }
            finally
            {
                if (cursor != null)
                {
                    cursor.close();
                }
            }
        }

        @Override
        public boolean create(FolderType type) throws MessagingException
        {
            if (exists())
            {
                throw new MessagingException(""Folder "" + mName + "" already exists."");
            }
            mDb.execSQL(""INSERT INTO folders (name, visible_limit) VALUES (?, ?)"", new Object[]
                        {
                            mName,
                            mAccount.getDisplayCount()
                        });
            return true;
        }

        @Override
        public boolean create(FolderType type, int visibleLimit) throws MessagingException
        {
            if (exists())
            {
                throw new MessagingException(""Folder "" + mName + "" already exists."");
            }
            mDb.execSQL(""INSERT INTO folders (name, visible_limit) VALUES (?, ?)"", new Object[]
                        {
                            mName,
                            visibleLimit
                        });
            return true;
        }

        @Override
        public void close()
        {
            mFolderId = -1;
        }

        @Override
        public int getMessageCount() throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            Cursor cursor = null;
            try
            {
                cursor = mDb.rawQuery(""SELECT COUNT(*) FROM messages WHERE messages.folder_id = ?"",
                                      new String[]
                                      {
                                          Long.toString(mFolderId)
                                      });
                cursor.moveToFirst();
                int messageCount = cursor.getInt(0);
                return messageCount;
            }
            finally
            {
                if (cursor != null)
                {
                    cursor.close();
                }
            }
        }

        @Override
        public int getUnreadMessageCount() throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            return mUnreadMessageCount;
        }

        @Override
        public int getFlaggedMessageCount() throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            return mFlaggedMessageCount;
        }

        public void setUnreadMessageCount(int unreadMessageCount) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            mUnreadMessageCount = Math.max(0, unreadMessageCount);
            mDb.execSQL(""UPDATE folders SET unread_count = ? WHERE id = ?"",
                        new Object[] { mUnreadMessageCount, mFolderId });
        }

        public void setFlaggedMessageCount(int flaggedMessageCount) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            mFlaggedMessageCount = Math.max(0, flaggedMessageCount);
            mDb.execSQL(""UPDATE folders SET flagged_count = ? WHERE id = ?"",
                        new Object[] { mFlaggedMessageCount, mFolderId });
        }

        @Override
        public void setLastChecked(long lastChecked) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            super.setLastChecked(lastChecked);
            mDb.execSQL(""UPDATE folders SET last_updated = ? WHERE id = ?"",
                        new Object[] { lastChecked, mFolderId });
        }

        @Override
        public void setLastPush(long lastChecked) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            super.setLastPush(lastChecked);
            mDb.execSQL(""UPDATE folders SET last_pushed = ? WHERE id = ?"",
                        new Object[] { lastChecked, mFolderId });
        }

        public int getVisibleLimit() throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            return mVisibleLimit;
        }

        public void purgeToVisibleLimit(MessageRemovalListener listener) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            Message[] messages = getMessages(null, false);
            for (int i = mVisibleLimit; i < messages.length; i++)
            {
                if (listener != null)
                {
                    listener.messageRemoved(messages[i]);
                }
                messages[i].setFlag(Flag.X_DESTROYED, true);

            }
        }


        public void setVisibleLimit(int visibleLimit) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            mVisibleLimit = visibleLimit;
            mDb.execSQL(""UPDATE folders SET visible_limit = ? WHERE id = ?"",
                        new Object[] { mVisibleLimit, mFolderId });
        }

        @Override
        public void setStatus(String status) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            super.setStatus(status);
            mDb.execSQL(""UPDATE folders SET status = ? WHERE id = ?"",
                        new Object[] { status, mFolderId });
        }
        public void setPushState(String pushState) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            mPushState = pushState;
            mDb.execSQL(""UPDATE folders SET push_state = ? WHERE id = ?"",
                        new Object[] { pushState, mFolderId });
        }
        public String getPushState()
        {
            return mPushState;
        }
        @Override
        public FolderClass getDisplayClass()
        {
            return displayClass;
        }

        @Override
        public FolderClass getSyncClass()
        {
            if (FolderClass.INHERITED == syncClass)
            {
                return getDisplayClass();
            }
            else
            {
                return syncClass;
            }
        }

        public FolderClass getRawSyncClass()
        {
            return syncClass;

        }

        @Override
        public FolderClass getPushClass()
        {
            if (FolderClass.INHERITED == pushClass)
            {
                return getSyncClass();
            }
            else
            {
                return pushClass;
            }
        }

        public FolderClass getRawPushClass()
        {
            return pushClass;

        }

        public void setDisplayClass(FolderClass displayClass)
        {
            this.displayClass = displayClass;
        }

        public void setSyncClass(FolderClass syncClass)
        {
            this.syncClass = syncClass;
        }
        public void setPushClass(FolderClass pushClass)
        {
            this.pushClass = pushClass;
        }

        public boolean isIntegrate()
        {
            return mIntegrate;
        }
        public void setIntegrate(boolean integrate)
        {
            mIntegrate = integrate;
        }

        private String getPrefId() throws MessagingException
        {
            open(OpenMode.READ_WRITE);

            if (prefId == null)
            {
                prefId = uUid + ""."" + mName;
            }

            return prefId;
        }

        public void delete(Preferences preferences) throws MessagingException
        {
            String id = getPrefId();

            SharedPreferences.Editor editor = preferences.getPreferences().edit();

            editor.remove(id + "".displayMode"");
            editor.remove(id + "".syncMode"");
            editor.remove(id + "".pushMode"");
            editor.remove(id + "".inTopGroup"");
            editor.remove(id + "".integrate"");

            editor.commit();
        }

        public void save(Preferences preferences) throws MessagingException
        {
            String id = getPrefId();

            SharedPreferences.Editor editor = preferences.getPreferences().edit();
            // there can be a lot of folders.  For the defaults, let's not save prefs, saving space, except for INBOX
            if (displayClass == FolderClass.NO_CLASS && !K9.INBOX.equals(getName()))
            {
                editor.remove(id + "".displayMode"");
            }
            else
            {
                editor.putString(id + "".displayMode"", displayClass.name());
            }

            if (syncClass == FolderClass.INHERITED && !K9.INBOX.equals(getName()))
            {
                editor.remove(id + "".syncMode"");
            }
            else
            {
                editor.putString(id + "".syncMode"", syncClass.name());
            }

            if (pushClass == FolderClass.SECOND_CLASS && !K9.INBOX.equals(getName()))
            {
                editor.remove(id + "".pushMode"");
            }
            else
            {
                editor.putString(id + "".pushMode"", pushClass.name());
            }
            editor.putBoolean(id + "".inTopGroup"", inTopGroup);

            editor.putBoolean(id + "".integrate"", mIntegrate);

            editor.commit();
        }


        public FolderClass getDisplayClass(Preferences preferences) throws MessagingException
        {
            String id = getPrefId();
            return FolderClass.valueOf(preferences.getPreferences().getString(id + "".displayMode"",
                                       FolderClass.NO_CLASS.name()));
        }

        @Override
        public void refresh(Preferences preferences) throws MessagingException
        {

            String id = getPrefId();

            try
            {
                displayClass = FolderClass.valueOf(preferences.getPreferences().getString(id + "".displayMode"",
                                                   FolderClass.NO_CLASS.name()));
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to load displayMode for "" + getName(), e);

                displayClass = FolderClass.NO_CLASS;
            }
            if (displayClass == FolderClass.NONE)
            {
                displayClass = FolderClass.NO_CLASS;
            }


            FolderClass defSyncClass = FolderClass.INHERITED;
            if (K9.INBOX.equals(getName()))
            {
                defSyncClass =  FolderClass.FIRST_CLASS;
            }

            try
            {
                syncClass = FolderClass.valueOf(preferences.getPreferences().getString(id  + "".syncMode"",
                                                defSyncClass.name()));
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to load syncMode for "" + getName(), e);

                syncClass = defSyncClass;
            }
            if (syncClass == FolderClass.NONE)
            {
                syncClass = FolderClass.INHERITED;
            }

            FolderClass defPushClass = FolderClass.SECOND_CLASS;
            boolean defInTopGroup = false;
            boolean defIntegrate = false;
            if (K9.INBOX.equals(getName()))
            {
                defPushClass =  FolderClass.FIRST_CLASS;
                defInTopGroup = true;
                defIntegrate = true;
            }

            try
            {
                pushClass = FolderClass.valueOf(preferences.getPreferences().getString(id  + "".pushMode"",
                                                defPushClass.name()));
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to load pushMode for "" + getName(), e);

                pushClass = defPushClass;
            }
            if (pushClass == FolderClass.NONE)
            {
                pushClass = FolderClass.INHERITED;
            }
            inTopGroup = preferences.getPreferences().getBoolean(id + "".inTopGroup"", defInTopGroup);
            mIntegrate = preferences.getPreferences().getBoolean(id + "".integrate"", defIntegrate);

        }

        @Override
        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
        throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            if (fp.contains(FetchProfile.Item.BODY))
            {
                for (Message message : messages)
                {
                    LocalMessage localMessage = (LocalMessage)message;
                    Cursor cursor = null;
                    MimeMultipart mp = new MimeMultipart();
                    mp.setSubType(""mixed"");
                    try
                    {
                        cursor = mDb.rawQuery(""SELECT html_content, text_content FROM messages ""
                                              + ""WHERE id = ?"",
                                              new String[] { Long.toString(localMessage.mId) });
                        cursor.moveToNext();
                        String htmlContent = cursor.getString(0);
                        String textContent = cursor.getString(1);

                        if (textContent != null)
                        {
                            LocalTextBody body = new LocalTextBody(textContent, htmlContent);
                            MimeBodyPart bp = new MimeBodyPart(body, ""text/plain"");
                            mp.addBodyPart(bp);
                        }
                        else
                        {
                            TextBody body = new TextBody(htmlContent);
                            MimeBodyPart bp = new MimeBodyPart(body, ""text/html"");
                            mp.addBodyPart(bp);
                        }
                    }
                    finally
                    {
                        if (cursor != null)
                        {
                            cursor.close();
                        }
                    }

                    try
                    {
                        cursor = mDb.query(
                                     ""attachments"",
                                     new String[]
                                     {
                                         ""id"",
                                         ""size"",
                                         ""name"",
                                         ""mime_type"",
                                         ""store_data"",
                                         ""content_uri"",
                                         ""content_id"",
                                         ""content_disposition""
                                     },
                                     ""message_id = ?"",
                                     new String[] { Long.toString(localMessage.mId) },
                                     null,
                                     null,
                                     null);

                        while (cursor.moveToNext())
                        {
                            long id = cursor.getLong(0);
                            int size = cursor.getInt(1);
                            String name = cursor.getString(2);
                            String type = cursor.getString(3);
                            String storeData = cursor.getString(4);
                            String contentUri = cursor.getString(5);
                            String contentId = cursor.getString(6);
                            String contentDisposition = cursor.getString(7);
                            Body body = null;

                            if (contentDisposition == null)
                            {
                                contentDisposition = ""attachment"";
                            }

                            if (contentUri != null)
                            {
                                body = new LocalAttachmentBody(Uri.parse(contentUri), mApplication);
                            }
                            MimeBodyPart bp = new LocalAttachmentBodyPart(body, id);
                            bp.setHeader(MimeHeader.HEADER_CONTENT_TYPE,
                                         String.format(""%s;\n name=\""%s\"""",
                                                       type,
                                                       name));
                            bp.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, ""base64"");
                            bp.setHeader(MimeHeader.HEADER_CONTENT_DISPOSITION,
                                         String.format(""%s;\n filename=\""%s\"";\n size=%d"",
                                                       contentDisposition,
                                                       name,
                                                       size));

                            bp.setHeader(MimeHeader.HEADER_CONTENT_ID, contentId);
                            /*
                             * HEADER_ANDROID_ATTACHMENT_STORE_DATA is a custom header we add to that
                             * we can later pull the attachment from the remote store if neccesary.
                             */
                            bp.setHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA, storeData);

                            mp.addBodyPart(bp);
                        }
                    }
                    finally
                    {
                        if (cursor != null)
                        {
                            cursor.close();
                        }
                    }

                    if (mp.getCount() == 1)
                    {
                        BodyPart part = mp.getBodyPart(0);
                        localMessage.setHeader(MimeHeader.HEADER_CONTENT_TYPE, part.getContentType());
                        localMessage.setBody(part.getBody());
                    }
                    else
                    {
                        localMessage.setHeader(MimeHeader.HEADER_CONTENT_TYPE, ""multipart/mixed"");
                        localMessage.setBody(mp);
                    }
                }
            }
        }

        @Override
        public Message[] getMessages(int start, int end, Date earliestDate, MessageRetrievalListener listener)
        throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            throw new MessagingException(
                ""LocalStore.getMessages(int, int, MessageRetrievalListener) not yet implemented"");
        }

        /**
         * Populate the header fields of the given list of messages by reading
         * the saved header data from the database.
         *
         * @param messages
         *            The messages whose headers should be loaded.
         */
        private void populateHeaders(List<LocalMessage> messages)
        {
            Cursor cursor = null;
            if (messages.size() == 0)
            {
                return;
            }
            try
            {
                Map<Long, LocalMessage> popMessages = new HashMap<Long, LocalMessage>();
                List<String> ids = new ArrayList<String>();
                StringBuffer questions = new StringBuffer();

                for (int i = 0; i < messages.size(); i++)
                {
                    if (i != 0)
                    {
                        questions.append("", "");
                    }
                    questions.append(""?"");
                    LocalMessage message = messages.get(i);
                    Long id = message.getId();
                    ids.add(Long.toString(id));
                    popMessages.put(id, message);

                }

                cursor = mDb.rawQuery(
                             ""SELECT message_id, name, value FROM headers "" + ""WHERE message_id in ( "" + questions + "") "",
                             ids.toArray(EMPTY_STRING_ARRAY));


                while (cursor.moveToNext())
                {
                    Long id = cursor.getLong(0);
                    String name = cursor.getString(1);
                    String value = cursor.getString(2);
                    //Log.i(K9.LOG_TAG, ""Retrieved header name= "" + name + "", value = "" + value + "" for message "" + id);
                    popMessages.get(id).addHeader(name, value);
                }
            }
            finally
            {
                if (cursor != null)
                {
                    cursor.close();
                }
            }
        }

        @Override
        public Message getMessage(String uid) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            LocalMessage message = new LocalMessage(uid, this);
            Cursor cursor = null;

            try
            {
                cursor = mDb.rawQuery(
                             ""SELECT ""
                             + GET_MESSAGES_COLS
                             + ""FROM messages WHERE uid = ? AND folder_id = ?"",
                             new String[]
                             {
                                 message.getUid(), Long.toString(mFolderId)
                             });
                if (!cursor.moveToNext())
                {
                    return null;
                }
                message.populateFromGetMessageCursor(cursor);
            }
            finally
            {
                if (cursor != null)
                {
                    cursor.close();
                }
            }
            return message;
        }

        @Override
        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException
        {
            return getMessages(listener, true);
        }

        @Override
        public Message[] getMessages(MessageRetrievalListener listener, boolean includeDeleted) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            return LocalStore.this.getMessages(
                       listener,
                       this,
                       ""SELECT "" + GET_MESSAGES_COLS
                       + ""FROM messages WHERE ""
                       + (includeDeleted ? """" : ""deleted = 0 AND "")
                       + "" folder_id = ? ORDER BY date DESC""
                       , new String[]
                       {
                           Long.toString(mFolderId)
                       }
                   );

        }


        @Override
        public Message[] getMessages(String[] uids, MessageRetrievalListener listener)
        throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            if (uids == null)
            {
                return getMessages(listener);
            }
            ArrayList<Message> messages = new ArrayList<Message>();
            for (String uid : uids)
            {
                Message message = getMessage(uid);
                if (message != null)
                {
                    messages.add(message);
                }
            }
            return messages.toArray(EMPTY_MESSAGE_ARRAY);
        }

        @Override
        public void copyMessages(Message[] msgs, Folder folder) throws MessagingException
        {
            if (!(folder instanceof LocalFolder))
            {
                throw new MessagingException(""copyMessages called with incorrect Folder"");
            }
            ((LocalFolder) folder).appendMessages(msgs, true);
        }

        @Override
        public void moveMessages(Message[] msgs, Folder destFolder) throws MessagingException
        {
            if (!(destFolder instanceof LocalFolder))
            {
                throw new MessagingException(""moveMessages called with non-LocalFolder"");
            }

            LocalFolder lDestFolder = (LocalFolder)destFolder;
            lDestFolder.open(OpenMode.READ_WRITE);
            for (Message message : msgs)
            {
                LocalMessage lMessage = (LocalMessage)message;

                if (!message.isSet(Flag.SEEN))
                {
                    setUnreadMessageCount(getUnreadMessageCount() - 1);
                    lDestFolder.setUnreadMessageCount(lDestFolder.getUnreadMessageCount() + 1);
                }

                if (message.isSet(Flag.FLAGGED))
                {
                    setFlaggedMessageCount(getFlaggedMessageCount() - 1);
                    lDestFolder.setFlaggedMessageCount(lDestFolder.getFlaggedMessageCount() + 1);
                }

                String oldUID = message.getUid();

                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Updating folder_id to "" + lDestFolder.getId() + "" for message with UID ""
                          + message.getUid() + "", id "" + lMessage.getId() + "" currently in folder "" + getName());

                message.setUid(K9.LOCAL_UID_PREFIX + UUID.randomUUID().toString());

                mDb.execSQL(""UPDATE messages "" + ""SET folder_id = ?, uid = ? "" + ""WHERE id = ?"", new Object[]
                            {
                                lDestFolder.getId(),
                                message.getUid(),
                                lMessage.getId()
                            });

                LocalMessage placeHolder = new LocalMessage(oldUID, this);
                placeHolder.setFlagInternal(Flag.DELETED, true);
                placeHolder.setFlagInternal(Flag.SEEN, true);
                appendMessages(new Message[] { placeHolder });
            }

        }

        /**
         * The method differs slightly from the contract; If an incoming message already has a uid
         * assigned and it matches the uid of an existing message then this message will replace the
         * old message. It is implemented as a delete/insert. This functionality is used in saving
         * of drafts and re-synchronization of updated server messages.
         *
         * NOTE that although this method is located in the LocalStore class, it is not guaranteed
         * that the messages supplied as parameters are actually {@link LocalMessage} instances (in
         * fact, in most cases, they are not). Therefore, if you want to make local changes only to a
         * message, retrieve the appropriate local message instance first (if it already exists).
         */
        @Override
        public void appendMessages(Message[] messages) throws MessagingException
        {
            appendMessages(messages, false);
        }

        /**
         * The method differs slightly from the contract; If an incoming message already has a uid
         * assigned and it matches the uid of an existing message then this message will replace the
         * old message. It is implemented as a delete/insert. This functionality is used in saving
         * of drafts and re-synchronization of updated server messages.
         *
         * NOTE that although this method is located in the LocalStore class, it is not guaranteed
         * that the messages supplied as parameters are actually {@link LocalMessage} instances (in
         * fact, in most cases, they are not). Therefore, if you want to make local changes only to a
         * message, retrieve the appropriate local message instance first (if it already exists).
         */
        private void appendMessages(Message[] messages, boolean copy) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            for (Message message : messages)
            {
                if (!(message instanceof MimeMessage))
                {
                    throw new Error(""LocalStore can only store Messages that extend MimeMessage"");
                }

                String uid = message.getUid();
                if (uid == null || copy)
                {
                    uid = K9.LOCAL_UID_PREFIX + UUID.randomUUID().toString();
                    if (!copy)
                    {
                        message.setUid(uid);
                    }
                }
                else
                {
                    Message oldMessage = getMessage(uid);
                    if (oldMessage != null && !oldMessage.isSet(Flag.SEEN))
                    {
                        setUnreadMessageCount(getUnreadMessageCount() - 1);
                    }
                    if (oldMessage != null && oldMessage.isSet(Flag.FLAGGED))
                    {
                        setFlaggedMessageCount(getFlaggedMessageCount() - 1);
                    }
                    /*
                     * The message may already exist in this Folder, so delete it first.
                     */
                    deleteAttachments(message.getUid());
                    mDb.execSQL(""DELETE FROM messages WHERE folder_id = ? AND uid = ?"",
                                new Object[] { mFolderId, message.getUid() });
                }

                ArrayList<Part> viewables = new ArrayList<Part>();
                ArrayList<Part> attachments = new ArrayList<Part>();
                MimeUtility.collectParts(message, viewables, attachments);

                StringBuffer sbHtml = new StringBuffer();
                StringBuffer sbText = new StringBuffer();
                for (Part viewable : viewables)
                {
                    try
                    {
                        String text = MimeUtility.getTextFromPart(viewable);
                        /*
                         * Anything with MIME type text/html will be stored as such. Anything
                         * else will be stored as text/plain.
                         */
                        if (viewable.getMimeType().equalsIgnoreCase(""text/html""))
                        {
                            sbHtml.append(text);
                        }
                        else
                        {
                            sbText.append(text);
                        }
                    }
                    catch (Exception e)
                    {
                        throw new MessagingException(""Unable to get text for message part"", e);
                    }
                }

                String text = sbText.toString();
                String html = markupContent(text, sbHtml.toString());
                String preview = calculateContentPreview(text);

                try
                {
                    ContentValues cv = new ContentValues();
                    cv.put(""uid"", uid);
                    cv.put(""subject"", message.getSubject());
                    cv.put(""sender_list"", Address.pack(message.getFrom()));
                    cv.put(""date"", message.getSentDate() == null
                           ? System.currentTimeMillis() : message.getSentDate().getTime());
                    cv.put(""flags"", Utility.combine(message.getFlags(), ',').toUpperCase());
                    cv.put(""deleted"", message.isSet(Flag.DELETED) ? 1 : 0);
                    cv.put(""folder_id"", mFolderId);
                    cv.put(""to_list"", Address.pack(message.getRecipients(RecipientType.TO)));
                    cv.put(""cc_list"", Address.pack(message.getRecipients(RecipientType.CC)));
                    cv.put(""bcc_list"", Address.pack(message.getRecipients(RecipientType.BCC)));
                    cv.put(""html_content"", html.length() > 0 ? html : null);
                    cv.put(""text_content"", text.length() > 0 ? text : null);
                    cv.put(""preview"", preview.length() > 0 ? preview : null);
                    cv.put(""reply_to_list"", Address.pack(message.getReplyTo()));
                    cv.put(""attachment_count"", attachments.size());
                    cv.put(""internal_date"",  message.getInternalDate() == null
                           ? System.currentTimeMillis() : message.getInternalDate().getTime());

                    String messageId = message.getMessageId();
                    if (messageId != null)
                    {
                        cv.put(""message_id"", messageId);
                    }
                    long messageUid = mDb.insert(""messages"", ""uid"", cv);
                    for (Part attachment : attachments)
                    {
                        saveAttachment(messageUid, attachment, copy);
                    }
                    saveHeaders(messageUid, (MimeMessage)message);
                    if (!message.isSet(Flag.SEEN))
                    {
                        setUnreadMessageCount(getUnreadMessageCount() + 1);
                    }
                    if (message.isSet(Flag.FLAGGED))
                    {
                        setFlaggedMessageCount(getFlaggedMessageCount() + 1);
                    }
                }
                catch (Exception e)
                {
                    throw new MessagingException(""Error appending message"", e);
                }
            }
        }

        /**
         * Update the given message in the LocalStore without first deleting the existing
         * message (contrast with appendMessages). This method is used to store changes
         * to the given message while updating attachments and not removing existing
         * attachment data.
         * TODO In the future this method should be combined with appendMessages since the Message
         * contains enough data to decide what to do.
         * @param message
         * @throws MessagingException
         */
        public void updateMessage(LocalMessage message) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            ArrayList<Part> viewables = new ArrayList<Part>();
            ArrayList<Part> attachments = new ArrayList<Part>();

            message.buildMimeRepresentation();

            MimeUtility.collectParts(message, viewables, attachments);

            StringBuffer sbHtml = new StringBuffer();
            StringBuffer sbText = new StringBuffer();
            for (int i = 0, count = viewables.size(); i < count; i++)
            {
                Part viewable = viewables.get(i);
                try
                {
                    String text = MimeUtility.getTextFromPart(viewable);
                    /*
                     * Anything with MIME type text/html will be stored as such. Anything
                     * else will be stored as text/plain.
                     */
                    if (viewable.getMimeType().equalsIgnoreCase(""text/html""))
                    {
                        sbHtml.append(text);
                    }
                    else
                    {
                        sbText.append(text);
                    }
                }
                catch (Exception e)
                {
                    throw new MessagingException(""Unable to get text for message part"", e);
                }
            }

            String text = sbText.toString();
            String html = markupContent(text, sbHtml.toString());
            String preview = calculateContentPreview(text);

            try
            {
                mDb.execSQL(""UPDATE messages SET ""
                            + ""uid = ?, subject = ?, sender_list = ?, date = ?, flags = ?, ""
                            + ""folder_id = ?, to_list = ?, cc_list = ?, bcc_list = ?, ""
                            + ""html_content = ?, text_content = ?, preview = ?, reply_to_list = ?, ""
                            + ""attachment_count = ? WHERE id = ?"",
                            new Object[]
                            {
                                message.getUid(),
                                message.getSubject(),
                                Address.pack(message.getFrom()),
                                message.getSentDate() == null ? System
                                .currentTimeMillis() : message.getSentDate()
                                .getTime(),
                                Utility.combine(message.getFlags(), ',').toUpperCase(),
                                mFolderId,
                                Address.pack(message
                                             .getRecipients(RecipientType.TO)),
                                Address.pack(message
                                             .getRecipients(RecipientType.CC)),
                                Address.pack(message
                                             .getRecipients(RecipientType.BCC)),
                                html.length() > 0 ? html : null,
                                text.length() > 0 ? text : null,
                                preview.length() > 0 ? preview : null,
                                Address.pack(message.getReplyTo()),
                                attachments.size(),
                                message.mId
                            });

                for (int i = 0, count = attachments.size(); i < count; i++)
                {
                    Part attachment = attachments.get(i);
                    saveAttachment(message.mId, attachment, false);
                }
                saveHeaders(message.getId(), message);
            }
            catch (Exception e)
            {
                throw new MessagingException(""Error appending message"", e);
            }
        }

        /**
         * Save the headers of the given message. Note that the message is not
         * necessarily a {@link LocalMessage} instance.
         */
        private void saveHeaders(long id, MimeMessage message) throws MessagingException
        {
            boolean saveAllHeaders = mAccount.isSaveAllHeaders();
            boolean gotAdditionalHeaders = false;

            deleteHeaders(id);
            for (String name : message.getHeaderNames())
            {
                if (saveAllHeaders || HEADERS_TO_SAVE.contains(name))
                {
                    String[] values = message.getHeader(name);
                    for (String value : values)
                    {
                        ContentValues cv = new ContentValues();
                        cv.put(""message_id"", id);
                        cv.put(""name"", name);
                        cv.put(""value"", value);
                        mDb.insert(""headers"", ""name"", cv);
                    }
                }
                else
                {
                    gotAdditionalHeaders = true;
                }
            }

            if (!gotAdditionalHeaders)
            {
                // Remember that all headers for this message have been saved, so it is
                // not necessary to download them again in case the user wants to see all headers.
                List<Flag> appendedFlags = new ArrayList<Flag>();
                appendedFlags.addAll(Arrays.asList(message.getFlags()));
                appendedFlags.add(Flag.X_GOT_ALL_HEADERS);

                mDb.execSQL(""UPDATE messages "" + ""SET flags = ? "" + "" WHERE id = ?"", new Object[]
                            { Utility.combine(appendedFlags.toArray(), ',').toUpperCase(), id });
            }
        }

        private void deleteHeaders(long id)
        {
            mDb.execSQL(""DELETE FROM headers WHERE message_id = ?"",
                        new Object[]
                        {
                            id
                        });
        }

        /**
         * @param messageId
         * @param attachment
         * @param attachmentId -1 to create a new attachment or >= 0 to update an existing
         * @throws IOException
         * @throws MessagingException
         */
        private void saveAttachment(long messageId, Part attachment, boolean saveAsNew)
        throws IOException, MessagingException
        {
            long attachmentId = -1;
            Uri contentUri = null;
            int size = -1;
            File tempAttachmentFile = null;

            if ((!saveAsNew) && (attachment instanceof LocalAttachmentBodyPart))
            {
                attachmentId = ((LocalAttachmentBodyPart) attachment).getAttachmentId();
            }

            if (attachment.getBody() != null)
            {
                Body body = attachment.getBody();
                if (body instanceof LocalAttachmentBody)
                {
                    contentUri = ((LocalAttachmentBody) body).getContentUri();
                }
                else
                {
                    /*
                     * If the attachment has a body we're expected to save it into the local store
                     * so we copy the data into a cached attachment file.
                     */
                    InputStream in = attachment.getBody().getInputStream();
                    tempAttachmentFile = File.createTempFile(""att"", null, mAttachmentsDir);
                    FileOutputStream out = new FileOutputStream(tempAttachmentFile);
                    size = IOUtils.copy(in, out);
                    in.close();
                    out.close();
                }
            }

            if (size == -1)
            {
                /*
                 * If the attachment is not yet downloaded see if we can pull a size
                 * off the Content-Disposition.
                 */
                String disposition = attachment.getDisposition();
                if (disposition != null)
                {
                    String s = MimeUtility.getHeaderParameter(disposition, ""size"");
                    if (s != null)
                    {
                        size = Integer.parseInt(s);
                    }
                }
            }
            if (size == -1)
            {
                size = 0;
            }

            String storeData =
                Utility.combine(attachment.getHeader(
                                    MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA), ',');

            String name = MimeUtility.getHeaderParameter(attachment.getContentType(), ""name"");
            String contentId = MimeUtility.getHeaderParameter(attachment.getContentId(), null);

            String contentDisposition = MimeUtility.unfoldAndDecode(attachment.getDisposition());
            if (name == null && contentDisposition != null)
            {
                name = MimeUtility.getHeaderParameter(contentDisposition, ""filename"");
            }
            if (attachmentId == -1)
            {
                ContentValues cv = new ContentValues();
                cv.put(""message_id"", messageId);
                cv.put(""content_uri"", contentUri != null ? contentUri.toString() : null);
                cv.put(""store_data"", storeData);
                cv.put(""size"", size);
                cv.put(""name"", name);
                cv.put(""mime_type"", attachment.getMimeType());
                cv.put(""content_id"", contentId);
                cv.put(""content_disposition"", contentDisposition);

                attachmentId = mDb.insert(""attachments"", ""message_id"", cv);
            }
            else
            {
                ContentValues cv = new ContentValues();
                cv.put(""content_uri"", contentUri != null ? contentUri.toString() : null);
                cv.put(""size"", size);
                mDb.update(
                    ""attachments"",
                    cv,
                    ""id = ?"",
                    new String[] { Long.toString(attachmentId) });
            }

            if (attachmentId != -1 && tempAttachmentFile != null)
            {
                File attachmentFile = new File(mAttachmentsDir, Long.toString(attachmentId));
                tempAttachmentFile.renameTo(attachmentFile);
                contentUri = AttachmentProvider.getAttachmentUri(
                                 new File(mPath).getName(),
                                 attachmentId);
                attachment.setBody(new LocalAttachmentBody(contentUri, mApplication));
                ContentValues cv = new ContentValues();
                cv.put(""content_uri"", contentUri != null ? contentUri.toString() : null);
                mDb.update(
                    ""attachments"",
                    cv,
                    ""id = ?"",
                    new String[] { Long.toString(attachmentId) });
            }

            /* The message has attachment with Content-ID */
            if (contentId != null && contentUri != null)
            {
                Cursor cursor = null;
                cursor = mDb.query(""messages"", new String[] { ""html_content"" }, ""id = ?"", new String[] { Long.toString(messageId) }, null, null, null);
                try
                {
                    if (cursor.moveToNext())
                    {
                        String new_html;

                        new_html = cursor.getString(0);
                        new_html = new_html.replaceAll(""cid:"" + contentId, contentUri.toString());

                        ContentValues cv = new ContentValues();
                        cv.put(""html_content"", new_html);
                        mDb.update(""messages"", cv, ""id = ?"", new String[] { Long.toString(messageId) });
                    }
                }
                finally
                {
                    if (cursor != null)
                    {
                        cursor.close();
                    }
                }
            }

            if (attachmentId != -1 && attachment instanceof LocalAttachmentBodyPart)
            {
                ((LocalAttachmentBodyPart) attachment).setAttachmentId(attachmentId);
            }
        }

        /**
         * Changes the stored uid of the given message (using it's internal id as a key) to
         * the uid in the message.
         * @param message
         */
        public void changeUid(LocalMessage message) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            ContentValues cv = new ContentValues();
            cv.put(""uid"", message.getUid());
            mDb.update(""messages"", cv, ""id = ?"", new String[] { Long.toString(message.mId) });
        }

        @Override
        public void setFlags(Message[] messages, Flag[] flags, boolean value)
        throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            for (Message message : messages)
            {
                message.setFlags(flags, value);
            }
        }

        @Override
        public void setFlags(Flag[] flags, boolean value)
        throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            for (Message message : getMessages(null))
            {
                message.setFlags(flags, value);
            }
        }

        @Override
        public String getUidFromMessageId(Message message) throws MessagingException
        {
            throw new MessagingException(""Cannot call getUidFromMessageId on LocalFolder"");
        }

        public void deleteMessagesOlderThan(long cutoff) throws MessagingException
        {
            final String where = ""folder_id = ? and date < ?"";
            final String[] params = new String[]
            {
                Long.toString(mFolderId), Long.toString(cutoff)
            };

            open(OpenMode.READ_ONLY);
            Message[] messages  = LocalStore.this.getMessages(
                                      null,
                                      this,
                                      ""SELECT "" + GET_MESSAGES_COLS + ""FROM messages WHERE "" + where,
                                      params);

            for (Message message : messages)
            {
                deleteAttachments(message.getUid());
            }
            mDb.execSQL(""DELETE FROM messages WHERE "" + where, params);
            resetUnreadAndFlaggedCounts();
        }

        private void resetUnreadAndFlaggedCounts()
        {
            try
            {
                int newUnread = 0;
                int newFlagged = 0;
                Message[] messages = getMessages(null);
                for (Message message : messages)
                {
                    if (!message.isSet(Flag.SEEN))
                    {
                        newUnread++;
                    }
                    if (message.isSet(Flag.FLAGGED))
                    {
                        newFlagged++;
                    }
                }
                setUnreadMessageCount(newUnread);
                setFlaggedMessageCount(newFlagged);
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to fetch all messages from LocalStore"", e);
            }
        }


        @Override
        public void delete(boolean recurse) throws MessagingException
        {
            // We need to open the folder first to make sure we've got it's id
            open(OpenMode.READ_ONLY);
            Message[] messages = getMessages(null);
            for (Message message : messages)
            {
                deleteAttachments(message.getUid());
            }
            mDb.execSQL(""DELETE FROM folders WHERE id = ?"", new Object[]
                        {
                            Long.toString(mFolderId),
                        });
        }

        @Override
        public boolean equals(Object o)
        {
            if (o instanceof LocalFolder)
            {
                return ((LocalFolder)o).mName.equals(mName);
            }
            return super.equals(o);
        }

        @Override
        public int hashCode()
        {
            return mName.hashCode();
        }

        @Override
        public Flag[] getPermanentFlags() throws MessagingException
        {
            return PERMANENT_FLAGS;
        }


        private void deleteAttachments(long messageId) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            Cursor attachmentsCursor = null;
            try
            {
                attachmentsCursor = mDb.query(
                                        ""attachments"",
                                        new String[] { ""id"" },
                                        ""message_id = ?"",
                                        new String[] { Long.toString(messageId) },
                                        null,
                                        null,
                                        null);
                while (attachmentsCursor.moveToNext())
                {
                    long attachmentId = attachmentsCursor.getLong(0);
                    try
                    {
                        File file = new File(mAttachmentsDir, Long.toString(attachmentId));
                        if (file.exists())
                        {
                            file.delete();
                        }
                    }
                    catch (Exception e)
                    {

                    }
                }
            }
            finally
            {
                if (attachmentsCursor != null)
                {
                    attachmentsCursor.close();
                }
            }
        }

        private void deleteAttachments(String uid) throws MessagingException
        {
            open(OpenMode.READ_WRITE);
            Cursor messagesCursor = null;
            try
            {
                messagesCursor = mDb.query(
                                     ""messages"",
                                     new String[] { ""id"" },
                                     ""folder_id = ? AND uid = ?"",
                                     new String[] { Long.toString(mFolderId), uid },
                                     null,
                                     null,
                                     null);
                while (messagesCursor.moveToNext())
                {
                    long messageId = messagesCursor.getLong(0);
                    deleteAttachments(messageId);

                }
            }
            finally
            {
                if (messagesCursor != null)
                {
                    messagesCursor.close();
                }
            }
        }

        /*
         * calculateContentPreview
         * Takes a plain text message body as a string.
         * Returns a message summary as a string suitable for showing in a message list
         *
         * A message summary should be about the first 160 characters
         * of unique text written by the message sender
         * Quoted text, ""On $date"" and so on will be stripped out.
         * All newlines and whitespace will be compressed.
         *
         */
        public String calculateContentPreview(String text)
        {
            if (text == null)
            {
                return null;
            }

            text = text.replaceAll(""(?ms)^-----BEGIN PGP SIGNED MESSAGE-----.(Hash:\\s*?.*?$)?"","""");
            text = text.replaceAll(""https?://\\S+"",""..."");
            text = text.replaceAll(""^.*\\w.*:"","""");
            text = text.replaceAll(""(?m)^>.*$"","""");
            text = text.replaceAll(""^On .*wrote.?$"","""");
            text = text.replaceAll(""(\\r|\\n)+"","" "");
            text = text.replaceAll(""\\s+"","" "");
            if (text.length() <= 250)
            {
                return text;
            }
            else
            {
                text = text.substring(0,250);
                return text;
            }

        }

        public String markupContent(String text, String html)
        {
            if (text.length() > 0 && html.length() == 0)
            {
                html = htmlifyString(text);
            }

            html = convertEmoji2ImgForDocomo(html);

            return html;
        }

        public String htmlifyString(String text)
        {
            StringReader reader = new StringReader(text);
            StringBuilder buff = new StringBuilder(text.length() + 512);
            int c = 0;
            try
            {
                while ((c = reader.read()) != -1)
                {
                    switch (c)
                    {
                        case '&':
                            buff.append(""&amp;"");
                            break;
                        case '<':
                            buff.append(""&lt;"");
                            break;
                        case '>':
                            buff.append(""&gt;"");
                            break;
                        case '\r':
                            break;
                        default:
                            buff.append((char)c);
                    }//switch
                }
            }
            catch (IOException e)
            {
                //Should never happen
                Log.e(K9.LOG_TAG, null, e);
            }
            text = buff.toString();
            text = text.replaceAll(""\\s*([-=_]{30,}+)\\s*"",""<hr />"");
            text = text.replaceAll(""(?m)^([^\r\n]{4,}[\\s\\w,:;+/])(?:\r\n|\n|\r)(?=[a-z]\\S{0,10}[\\s\\n\\r])"",""$1 "");
            text = text.replaceAll(""(?m)(\r\n|\n|\r){4,}"",""\n\n"");


            Matcher m = Regex.WEB_URL_PATTERN.matcher(text);
            StringBuffer sb = new StringBuffer(text.length() + 512);
            sb.append(""<html><head><meta name=\""viewport\"" content=\""width=device-width, height=device-height\""></head><body>"");
            sb.append(htmlifyMessageHeader());
            while (m.find())
            {
                int start = m.start();
                if (start == 0 || (start != 0 && text.charAt(start - 1) != '@'))
                {
                    m.appendReplacement(sb, ""<a href=\""$0\"">$0</a>"");
                }
                else
                {
                    m.appendReplacement(sb, ""$0"");
                }
            }




            m.appendTail(sb);
            sb.append(htmlifyMessageFooter());
            sb.append(""</body></html>"");
            text = sb.toString();

            return text;
        }

        private String htmlifyMessageHeader()
        {
            if (K9.messageViewFixedWidthFont())
            {
                return ""<pre style=\""white-space: pre-wrap; word-wrap:break-word; \"">"";
            }
            else
            {
                return ""<div style=\""white-space: pre-wrap; word-wrap:break-word; \"">"";
            }
        }


        private String htmlifyMessageFooter()
        {
            if (K9.messageViewFixedWidthFont())
            {
                return ""</pre>"";
            }
            else
            {
                return ""</div>"";
            }
        }

        public String convertEmoji2ImgForDocomo(String html)
        {
            StringReader reader = new StringReader(html);
            StringBuilder buff = new StringBuilder(html.length() + 512);
            int c = 0;
            try
            {
                while ((c = reader.read()) != -1)
                {
                    switch (c)
                    {
                            // These emoji codepoints are generated by tools/make_emoji in the K-9 source tree

                        case 0xE6F9: //docomo kissmark
                            buff.append(""<img src=\""file:///android_asset/emoticons/kissmark.gif\"" alt=\""kissmark\"" />"");
                            break;
                        case 0xE729: //docomo wink
                            buff.append(""<img src=\""file:///android_asset/emoticons/wink.gif\"" alt=\""wink\"" />"");
                            break;
                        case 0xE6D2: //docomo info02
                            buff.append(""<img src=\""file:///android_asset/emoticons/info02.gif\"" alt=\""info02\"" />"");
                            break;
                        case 0xE753: //docomo smile
                            buff.append(""<img src=\""file:///android_asset/emoticons/smile.gif\"" alt=\""smile\"" />"");
                            break;
                        case 0xE68D: //docomo heart
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart.gif\"" alt=\""heart\"" />"");
                            break;
                        case 0xE6A5: //docomo downwardleft
                            buff.append(""<img src=\""file:///android_asset/emoticons/downwardleft.gif\"" alt=\""downwardleft\"" />"");
                            break;
                        case 0xE6AD: //docomo pouch
                            buff.append(""<img src=\""file:///android_asset/emoticons/pouch.gif\"" alt=\""pouch\"" />"");
                            break;
                        case 0xE6D4: //docomo by-d
                            buff.append(""<img src=\""file:///android_asset/emoticons/by-d.gif\"" alt=\""by-d\"" />"");
                            break;
                        case 0xE6D7: //docomo free
                            buff.append(""<img src=\""file:///android_asset/emoticons/free.gif\"" alt=\""free\"" />"");
                            break;
                        case 0xE6E8: //docomo seven
                            buff.append(""<img src=\""file:///android_asset/emoticons/seven.gif\"" alt=\""seven\"" />"");
                            break;
                        case 0xE74E: //docomo snail
                            buff.append(""<img src=\""file:///android_asset/emoticons/snail.gif\"" alt=\""snail\"" />"");
                            break;
                        case 0xE658: //docomo basketball
                            buff.append(""<img src=\""file:///android_asset/emoticons/basketball.gif\"" alt=\""basketball\"" />"");
                            break;
                        case 0xE65A: //docomo pocketbell
                            buff.append(""<img src=\""file:///android_asset/emoticons/pocketbell.gif\"" alt=\""pocketbell\"" />"");
                            break;
                        case 0xE6E3: //docomo two
                            buff.append(""<img src=\""file:///android_asset/emoticons/two.gif\"" alt=\""two\"" />"");
                            break;
                        case 0xE74A: //docomo cake
                            buff.append(""<img src=\""file:///android_asset/emoticons/cake.gif\"" alt=\""cake\"" />"");
                            break;
                        case 0xE6D0: //docomo faxto
                            buff.append(""<img src=\""file:///android_asset/emoticons/faxto.gif\"" alt=\""faxto\"" />"");
                            break;
                        case 0xE661: //docomo ship
                            buff.append(""<img src=\""file:///android_asset/emoticons/ship.gif\"" alt=\""ship\"" />"");
                            break;
                        case 0xE64B: //docomo virgo
                            buff.append(""<img src=\""file:///android_asset/emoticons/virgo.gif\"" alt=\""virgo\"" />"");
                            break;
                        case 0xE67E: //docomo ticket
                            buff.append(""<img src=\""file:///android_asset/emoticons/ticket.gif\"" alt=\""ticket\"" />"");
                            break;
                        case 0xE6D6: //docomo yen
                            buff.append(""<img src=\""file:///android_asset/emoticons/yen.gif\"" alt=\""yen\"" />"");
                            break;
                        case 0xE6E0: //docomo sharp
                            buff.append(""<img src=\""file:///android_asset/emoticons/sharp.gif\"" alt=\""sharp\"" />"");
                            break;
                        case 0xE6FE: //docomo bomb
                            buff.append(""<img src=\""file:///android_asset/emoticons/bomb.gif\"" alt=\""bomb\"" />"");
                            break;
                        case 0xE6E1: //docomo mobaq
                            buff.append(""<img src=\""file:///android_asset/emoticons/mobaq.gif\"" alt=\""mobaq\"" />"");
                            break;
                        case 0xE70A: //docomo sign05
                            buff.append(""<img src=\""file:///android_asset/emoticons/sign05.gif\"" alt=\""sign05\"" />"");
                            break;
                        case 0xE667: //docomo bank
                            buff.append(""<img src=\""file:///android_asset/emoticons/bank.gif\"" alt=\""bank\"" />"");
                            break;
                        case 0xE731: //docomo copyright
                            buff.append(""<img src=\""file:///android_asset/emoticons/copyright.gif\"" alt=\""copyright\"" />"");
                            break;
                        case 0xE678: //docomo upwardright
                            buff.append(""<img src=\""file:///android_asset/emoticons/upwardright.gif\"" alt=\""upwardright\"" />"");
                            break;
                        case 0xE694: //docomo scissors
                            buff.append(""<img src=\""file:///android_asset/emoticons/scissors.gif\"" alt=\""scissors\"" />"");
                            break;
                        case 0xE682: //docomo bag
                            buff.append(""<img src=\""file:///android_asset/emoticons/bag.gif\"" alt=\""bag\"" />"");
                            break;
                        case 0xE64D: //docomo scorpius
                            buff.append(""<img src=\""file:///android_asset/emoticons/scorpius.gif\"" alt=\""scorpius\"" />"");
                            break;
                        case 0xE6D9: //docomo key
                            buff.append(""<img src=\""file:///android_asset/emoticons/key.gif\"" alt=\""key\"" />"");
                            break;
                        case 0xE734: //docomo secret
                            buff.append(""<img src=\""file:///android_asset/emoticons/secret.gif\"" alt=\""secret\"" />"");
                            break;
                        case 0xE74F: //docomo chick
                            buff.append(""<img src=\""file:///android_asset/emoticons/chick.gif\"" alt=\""chick\"" />"");
                            break;
                        case 0xE691: //docomo eye
                            buff.append(""<img src=\""file:///android_asset/emoticons/eye.gif\"" alt=\""eye\"" />"");
                            break;
                        case 0xE70B: //docomo ok
                            buff.append(""<img src=\""file:///android_asset/emoticons/ok.gif\"" alt=\""ok\"" />"");
                            break;
                        case 0xE714: //docomo door
                            buff.append(""<img src=\""file:///android_asset/emoticons/door.gif\"" alt=\""door\"" />"");
                            break;
                        case 0xE64F: //docomo capricornus
                            buff.append(""<img src=\""file:///android_asset/emoticons/capricornus.gif\"" alt=\""capricornus\"" />"");
                            break;
                        case 0xE674: //docomo boutique
                            buff.append(""<img src=\""file:///android_asset/emoticons/boutique.gif\"" alt=\""boutique\"" />"");
                            break;
                        case 0xE726: //docomo lovely
                            buff.append(""<img src=\""file:///android_asset/emoticons/lovely.gif\"" alt=\""lovely\"" />"");
                            break;
                        case 0xE68F: //docomo diamond
                            buff.append(""<img src=\""file:///android_asset/emoticons/diamond.gif\"" alt=\""diamond\"" />"");
                            break;
                        case 0xE69B: //docomo wheelchair
                            buff.append(""<img src=\""file:///android_asset/emoticons/wheelchair.gif\"" alt=\""wheelchair\"" />"");
                            break;
                        case 0xE747: //docomo maple
                            buff.append(""<img src=\""file:///android_asset/emoticons/maple.gif\"" alt=\""maple\"" />"");
                            break;
                        case 0xE64C: //docomo libra
                            buff.append(""<img src=\""file:///android_asset/emoticons/libra.gif\"" alt=\""libra\"" />"");
                            break;
                        case 0xE647: //docomo taurus
                            buff.append(""<img src=\""file:///android_asset/emoticons/taurus.gif\"" alt=\""taurus\"" />"");
                            break;
                        case 0xE645: //docomo sprinkle
                            buff.append(""<img src=\""file:///android_asset/emoticons/sprinkle.gif\"" alt=\""sprinkle\"" />"");
                            break;
                        case 0xE6FC: //docomo annoy
                            buff.append(""<img src=\""file:///android_asset/emoticons/annoy.gif\"" alt=\""annoy\"" />"");
                            break;
                        case 0xE6E6: //docomo five
                            buff.append(""<img src=\""file:///android_asset/emoticons/five.gif\"" alt=\""five\"" />"");
                            break;
                        case 0xE676: //docomo karaoke
                            buff.append(""<img src=\""file:///android_asset/emoticons/karaoke.gif\"" alt=\""karaoke\"" />"");
                            break;
                        case 0xE69D: //docomo moon1
                            buff.append(""<img src=\""file:///android_asset/emoticons/moon1.gif\"" alt=\""moon1\"" />"");
                            break;
                        case 0xE709: //docomo sign04
                            buff.append(""<img src=\""file:///android_asset/emoticons/sign04.gif\"" alt=\""sign04\"" />"");
                            break;
                        case 0xE72A: //docomo happy02
                            buff.append(""<img src=\""file:///android_asset/emoticons/happy02.gif\"" alt=\""happy02\"" />"");
                            break;
                        case 0xE669: //docomo hotel
                            buff.append(""<img src=\""file:///android_asset/emoticons/hotel.gif\"" alt=\""hotel\"" />"");
                            break;
                        case 0xE71B: //docomo ring
                            buff.append(""<img src=\""file:///android_asset/emoticons/ring.gif\"" alt=\""ring\"" />"");
                            break;
                        case 0xE644: //docomo mist
                            buff.append(""<img src=\""file:///android_asset/emoticons/mist.gif\"" alt=\""mist\"" />"");
                            break;
                        case 0xE73B: //docomo full
                            buff.append(""<img src=\""file:///android_asset/emoticons/full.gif\"" alt=\""full\"" />"");
                            break;
                        case 0xE683: //docomo book
                            buff.append(""<img src=\""file:///android_asset/emoticons/book.gif\"" alt=\""book\"" />"");
                            break;
                        case 0xE707: //docomo sweat02
                            buff.append(""<img src=\""file:///android_asset/emoticons/sweat02.gif\"" alt=\""sweat02\"" />"");
                            break;
                        case 0xE716: //docomo pc
                            buff.append(""<img src=\""file:///android_asset/emoticons/pc.gif\"" alt=\""pc\"" />"");
                            break;
                        case 0xE671: //docomo bar
                            buff.append(""<img src=\""file:///android_asset/emoticons/bar.gif\"" alt=\""bar\"" />"");
                            break;
                        case 0xE72B: //docomo bearing
                            buff.append(""<img src=\""file:///android_asset/emoticons/bearing.gif\"" alt=\""bearing\"" />"");
                            break;
                        case 0xE65C: //docomo subway
                            buff.append(""<img src=\""file:///android_asset/emoticons/subway.gif\"" alt=\""subway\"" />"");
                            break;
                        case 0xE725: //docomo gawk
                            buff.append(""<img src=\""file:///android_asset/emoticons/gawk.gif\"" alt=\""gawk\"" />"");
                            break;
                        case 0xE745: //docomo apple
                            buff.append(""<img src=\""file:///android_asset/emoticons/apple.gif\"" alt=\""apple\"" />"");
                            break;
                        case 0xE65F: //docomo rvcar
                            buff.append(""<img src=\""file:///android_asset/emoticons/rvcar.gif\"" alt=\""rvcar\"" />"");
                            break;
                        case 0xE664: //docomo building
                            buff.append(""<img src=\""file:///android_asset/emoticons/building.gif\"" alt=\""building\"" />"");
                            break;
                        case 0xE737: //docomo danger
                            buff.append(""<img src=\""file:///android_asset/emoticons/danger.gif\"" alt=\""danger\"" />"");
                            break;
                        case 0xE702: //docomo sign01
                            buff.append(""<img src=\""file:///android_asset/emoticons/sign01.gif\"" alt=\""sign01\"" />"");
                            break;
                        case 0xE6EC: //docomo heart01
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart01.gif\"" alt=\""heart01\"" />"");
                            break;
                        case 0xE660: //docomo bus
                            buff.append(""<img src=\""file:///android_asset/emoticons/bus.gif\"" alt=\""bus\"" />"");
                            break;
                        case 0xE72D: //docomo crying
                            buff.append(""<img src=\""file:///android_asset/emoticons/crying.gif\"" alt=\""crying\"" />"");
                            break;
                        case 0xE652: //docomo sports
                            buff.append(""<img src=\""file:///android_asset/emoticons/sports.gif\"" alt=\""sports\"" />"");
                            break;
                        case 0xE6B8: //docomo on
                            buff.append(""<img src=\""file:///android_asset/emoticons/on.gif\"" alt=\""on\"" />"");
                            break;
                        case 0xE73C: //docomo leftright
                            buff.append(""<img src=\""file:///android_asset/emoticons/leftright.gif\"" alt=\""leftright\"" />"");
                            break;
                        case 0xE6BA: //docomo clock
                            buff.append(""<img src=\""file:///android_asset/emoticons/clock.gif\"" alt=\""clock\"" />"");
                            break;
                        case 0xE6F0: //docomo happy01
                            buff.append(""<img src=\""file:///android_asset/emoticons/happy01.gif\"" alt=\""happy01\"" />"");
                            break;
                        case 0xE701: //docomo sleepy
                            buff.append(""<img src=\""file:///android_asset/emoticons/sleepy.gif\"" alt=\""sleepy\"" />"");
                            break;
                        case 0xE63E: //docomo sun
                            buff.append(""<img src=\""file:///android_asset/emoticons/sun.gif\"" alt=\""sun\"" />"");
                            break;
                        case 0xE67D: //docomo event
                            buff.append(""<img src=\""file:///android_asset/emoticons/event.gif\"" alt=\""event\"" />"");
                            break;
                        case 0xE689: //docomo memo
                            buff.append(""<img src=\""file:///android_asset/emoticons/memo.gif\"" alt=\""memo\"" />"");
                            break;
                        case 0xE68B: //docomo game
                            buff.append(""<img src=\""file:///android_asset/emoticons/game.gif\"" alt=\""game\"" />"");
                            break;
                        case 0xE718: //docomo wrench
                            buff.append(""<img src=\""file:///android_asset/emoticons/wrench.gif\"" alt=\""wrench\"" />"");
                            break;
                        case 0xE741: //docomo clover
                            buff.append(""<img src=\""file:///android_asset/emoticons/clover.gif\"" alt=\""clover\"" />"");
                            break;
                        case 0xE693: //docomo rock
                            buff.append(""<img src=\""file:///android_asset/emoticons/rock.gif\"" alt=\""rock\"" />"");
                            break;
                        case 0xE6F6: //docomo note
                            buff.append(""<img src=\""file:///android_asset/emoticons/note.gif\"" alt=\""note\"" />"");
                            break;
                        case 0xE67A: //docomo music
                            buff.append(""<img src=\""file:///android_asset/emoticons/music.gif\"" alt=\""music\"" />"");
                            break;
                        case 0xE743: //docomo tulip
                            buff.append(""<img src=\""file:///android_asset/emoticons/tulip.gif\"" alt=\""tulip\"" />"");
                            break;
                        case 0xE656: //docomo soccer
                            buff.append(""<img src=\""file:///android_asset/emoticons/soccer.gif\"" alt=\""soccer\"" />"");
                            break;
                        case 0xE69C: //docomo newmoon
                            buff.append(""<img src=\""file:///android_asset/emoticons/newmoon.gif\"" alt=\""newmoon\"" />"");
                            break;
                        case 0xE73E: //docomo school
                            buff.append(""<img src=\""file:///android_asset/emoticons/school.gif\"" alt=\""school\"" />"");
                            break;
                        case 0xE750: //docomo penguin
                            buff.append(""<img src=\""file:///android_asset/emoticons/penguin.gif\"" alt=\""penguin\"" />"");
                            break;
                        case 0xE696: //docomo downwardright
                            buff.append(""<img src=\""file:///android_asset/emoticons/downwardright.gif\"" alt=\""downwardright\"" />"");
                            break;
                        case 0xE6CE: //docomo phoneto
                            buff.append(""<img src=\""file:///android_asset/emoticons/phoneto.gif\"" alt=\""phoneto\"" />"");
                            break;
                        case 0xE728: //docomo bleah
                            buff.append(""<img src=\""file:///android_asset/emoticons/bleah.gif\"" alt=\""bleah\"" />"");
                            break;
                        case 0xE662: //docomo airplane
                            buff.append(""<img src=\""file:///android_asset/emoticons/airplane.gif\"" alt=\""airplane\"" />"");
                            break;
                        case 0xE74C: //docomo noodle
                            buff.append(""<img src=\""file:///android_asset/emoticons/noodle.gif\"" alt=\""noodle\"" />"");
                            break;
                        case 0xE704: //docomo sign03
                            buff.append(""<img src=\""file:///android_asset/emoticons/sign03.gif\"" alt=\""sign03\"" />"");
                            break;
                        case 0xE68E: //docomo spade
                            buff.append(""<img src=\""file:///android_asset/emoticons/spade.gif\"" alt=\""spade\"" />"");
                            break;
                        case 0xE698: //docomo foot
                            buff.append(""<img src=\""file:///android_asset/emoticons/foot.gif\"" alt=\""foot\"" />"");
                            break;
                        case 0xE712: //docomo snowboard
                            buff.append(""<img src=\""file:///android_asset/emoticons/snowboard.gif\"" alt=\""snowboard\"" />"");
                            break;
                        case 0xE684: //docomo ribbon
                            buff.append(""<img src=\""file:///android_asset/emoticons/ribbon.gif\"" alt=\""ribbon\"" />"");
                            break;
                        case 0xE6DA: //docomo enter
                            buff.append(""<img src=\""file:///android_asset/emoticons/enter.gif\"" alt=\""enter\"" />"");
                            break;
                        case 0xE6EA: //docomo nine
                            buff.append(""<img src=\""file:///android_asset/emoticons/nine.gif\"" alt=\""nine\"" />"");
                            break;
                        case 0xE722: //docomo coldsweats01
                            buff.append(""<img src=\""file:///android_asset/emoticons/coldsweats01.gif\"" alt=\""coldsweats01\"" />"");
                            break;
                        case 0xE6F7: //docomo spa
                            buff.append(""<img src=\""file:///android_asset/emoticons/spa.gif\"" alt=\""spa\"" />"");
                            break;
                        case 0xE710: //docomo rouge
                            buff.append(""<img src=\""file:///android_asset/emoticons/rouge.gif\"" alt=\""rouge\"" />"");
                            break;
                        case 0xE73F: //docomo wave
                            buff.append(""<img src=\""file:///android_asset/emoticons/wave.gif\"" alt=\""wave\"" />"");
                            break;
                        case 0xE686: //docomo birthday
                            buff.append(""<img src=\""file:///android_asset/emoticons/birthday.gif\"" alt=\""birthday\"" />"");
                            break;
                        case 0xE721: //docomo confident
                            buff.append(""<img src=\""file:///android_asset/emoticons/confident.gif\"" alt=\""confident\"" />"");
                            break;
                        case 0xE6FF: //docomo notes
                            buff.append(""<img src=\""file:///android_asset/emoticons/notes.gif\"" alt=\""notes\"" />"");
                            break;
                        case 0xE724: //docomo pout
                            buff.append(""<img src=\""file:///android_asset/emoticons/pout.gif\"" alt=\""pout\"" />"");
                            break;
                        case 0xE6A4: //docomo xmas
                            buff.append(""<img src=\""file:///android_asset/emoticons/xmas.gif\"" alt=\""xmas\"" />"");
                            break;
                        case 0xE6FB: //docomo flair
                            buff.append(""<img src=\""file:///android_asset/emoticons/flair.gif\"" alt=\""flair\"" />"");
                            break;
                        case 0xE71D: //docomo bicycle
                            buff.append(""<img src=\""file:///android_asset/emoticons/bicycle.gif\"" alt=\""bicycle\"" />"");
                            break;
                        case 0xE6DC: //docomo search
                            buff.append(""<img src=\""file:///android_asset/emoticons/search.gif\"" alt=\""search\"" />"");
                            break;
                        case 0xE757: //docomo shock
                            buff.append(""<img src=\""file:///android_asset/emoticons/shock.gif\"" alt=\""shock\"" />"");
                            break;
                        case 0xE680: //docomo nosmoking
                            buff.append(""<img src=\""file:///android_asset/emoticons/nosmoking.gif\"" alt=\""nosmoking\"" />"");
                            break;
                        case 0xE66D: //docomo signaler
                            buff.append(""<img src=\""file:///android_asset/emoticons/signaler.gif\"" alt=\""signaler\"" />"");
                            break;
                        case 0xE66A: //docomo 24hours
                            buff.append(""<img src=\""file:///android_asset/emoticons/24hours.gif\"" alt=\""24hours\"" />"");
                            break;
                        case 0xE6F4: //docomo wobbly
                            buff.append(""<img src=\""file:///android_asset/emoticons/wobbly.gif\"" alt=\""wobbly\"" />"");
                            break;
                        case 0xE641: //docomo snow
                            buff.append(""<img src=\""file:///android_asset/emoticons/snow.gif\"" alt=\""snow\"" />"");
                            break;
                        case 0xE6AE: //docomo pen
                            buff.append(""<img src=\""file:///android_asset/emoticons/pen.gif\"" alt=\""pen\"" />"");
                            break;
                        case 0xE70D: //docomo appli02
                            buff.append(""<img src=\""file:///android_asset/emoticons/appli02.gif\"" alt=\""appli02\"" />"");
                            break;
                        case 0xE732: //docomo tm
                            buff.append(""<img src=\""file:///android_asset/emoticons/tm.gif\"" alt=\""tm\"" />"");
                            break;
                        case 0xE755: //docomo pig
                            buff.append(""<img src=\""file:///android_asset/emoticons/pig.gif\"" alt=\""pig\"" />"");
                            break;
                        case 0xE648: //docomo gemini
                            buff.append(""<img src=\""file:///android_asset/emoticons/gemini.gif\"" alt=\""gemini\"" />"");
                            break;
                        case 0xE6DE: //docomo flag
                            buff.append(""<img src=\""file:///android_asset/emoticons/flag.gif\"" alt=\""flag\"" />"");
                            break;
                        case 0xE6A1: //docomo dog
                            buff.append(""<img src=\""file:///android_asset/emoticons/dog.gif\"" alt=\""dog\"" />"");
                            break;
                        case 0xE6EF: //docomo heart04
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart04.gif\"" alt=\""heart04\"" />"");
                            break;
                        case 0xE643: //docomo typhoon
                            buff.append(""<img src=\""file:///android_asset/emoticons/typhoon.gif\"" alt=\""typhoon\"" />"");
                            break;
                        case 0xE65B: //docomo train
                            buff.append(""<img src=\""file:///android_asset/emoticons/train.gif\"" alt=\""train\"" />"");
                            break;
                        case 0xE746: //docomo bud
                            buff.append(""<img src=\""file:///android_asset/emoticons/bud.gif\"" alt=\""bud\"" />"");
                            break;
                        case 0xE653: //docomo baseball
                            buff.append(""<img src=\""file:///android_asset/emoticons/baseball.gif\"" alt=\""baseball\"" />"");
                            break;
                        case 0xE6B2: //docomo chair
                            buff.append(""<img src=\""file:///android_asset/emoticons/chair.gif\"" alt=\""chair\"" />"");
                            break;
                        case 0xE64A: //docomo leo
                            buff.append(""<img src=\""file:///android_asset/emoticons/leo.gif\"" alt=\""leo\"" />"");
                            break;
                        case 0xE6E7: //docomo six
                            buff.append(""<img src=\""file:///android_asset/emoticons/six.gif\"" alt=\""six\"" />"");
                            break;
                        case 0xE6E4: //docomo three
                            buff.append(""<img src=\""file:///android_asset/emoticons/three.gif\"" alt=\""three\"" />"");
                            break;
                        case 0xE6DF: //docomo freedial
                            buff.append(""<img src=\""file:///android_asset/emoticons/freedial.gif\"" alt=\""freedial\"" />"");
                            break;
                        case 0xE744: //docomo banana
                            buff.append(""<img src=\""file:///android_asset/emoticons/banana.gif\"" alt=\""banana\"" />"");
                            break;
                        case 0xE6DB: //docomo clear
                            buff.append(""<img src=\""file:///android_asset/emoticons/clear.gif\"" alt=\""clear\"" />"");
                            break;
                        case 0xE6AC: //docomo slate
                            buff.append(""<img src=\""file:///android_asset/emoticons/slate.gif\"" alt=\""slate\"" />"");
                            break;
                        case 0xE666: //docomo hospital
                            buff.append(""<img src=\""file:///android_asset/emoticons/hospital.gif\"" alt=\""hospital\"" />"");
                            break;
                        case 0xE663: //docomo house
                            buff.append(""<img src=\""file:///android_asset/emoticons/house.gif\"" alt=\""house\"" />"");
                            break;
                        case 0xE695: //docomo paper
                            buff.append(""<img src=\""file:///android_asset/emoticons/paper.gif\"" alt=\""paper\"" />"");
                            break;
                        case 0xE67F: //docomo smoking
                            buff.append(""<img src=\""file:///android_asset/emoticons/smoking.gif\"" alt=\""smoking\"" />"");
                            break;
                        case 0xE65D: //docomo bullettrain
                            buff.append(""<img src=\""file:///android_asset/emoticons/bullettrain.gif\"" alt=\""bullettrain\"" />"");
                            break;
                        case 0xE6B1: //docomo shadow
                            buff.append(""<img src=\""file:///android_asset/emoticons/shadow.gif\"" alt=\""shadow\"" />"");
                            break;
                        case 0xE670: //docomo cafe
                            buff.append(""<img src=\""file:///android_asset/emoticons/cafe.gif\"" alt=\""cafe\"" />"");
                            break;
                        case 0xE654: //docomo golf
                            buff.append(""<img src=\""file:///android_asset/emoticons/golf.gif\"" alt=\""golf\"" />"");
                            break;
                        case 0xE708: //docomo dash
                            buff.append(""<img src=\""file:///android_asset/emoticons/dash.gif\"" alt=\""dash\"" />"");
                            break;
                        case 0xE748: //docomo cherryblossom
                            buff.append(""<img src=\""file:///android_asset/emoticons/cherryblossom.gif\"" alt=\""cherryblossom\"" />"");
                            break;
                        case 0xE6F1: //docomo angry
                            buff.append(""<img src=\""file:///android_asset/emoticons/angry.gif\"" alt=\""angry\"" />"");
                            break;
                        case 0xE736: //docomo r-mark
                            buff.append(""<img src=\""file:///android_asset/emoticons/r-mark.gif\"" alt=\""r-mark\"" />"");
                            break;
                        case 0xE6A2: //docomo cat
                            buff.append(""<img src=\""file:///android_asset/emoticons/cat.gif\"" alt=\""cat\"" />"");
                            break;
                        case 0xE6D1: //docomo info01
                            buff.append(""<img src=\""file:///android_asset/emoticons/info01.gif\"" alt=\""info01\"" />"");
                            break;
                        case 0xE687: //docomo telephone
                            buff.append(""<img src=\""file:///android_asset/emoticons/telephone.gif\"" alt=\""telephone\"" />"");
                            break;
                        case 0xE68C: //docomo cd
                            buff.append(""<img src=\""file:///android_asset/emoticons/cd.gif\"" alt=\""cd\"" />"");
                            break;
                        case 0xE70E: //docomo t-shirt
                            buff.append(""<img src=\""file:///android_asset/emoticons/t-shirt.gif\"" alt=\""t-shirt\"" />"");
                            break;
                        case 0xE733: //docomo run
                            buff.append(""<img src=\""file:///android_asset/emoticons/run.gif\"" alt=\""run\"" />"");
                            break;
                        case 0xE679: //docomo carouselpony
                            buff.append(""<img src=\""file:///android_asset/emoticons/carouselpony.gif\"" alt=\""carouselpony\"" />"");
                            break;
                        case 0xE646: //docomo aries
                            buff.append(""<img src=\""file:///android_asset/emoticons/aries.gif\"" alt=\""aries\"" />"");
                            break;
                        case 0xE690: //docomo club
                            buff.append(""<img src=\""file:///android_asset/emoticons/club.gif\"" alt=\""club\"" />"");
                            break;
                        case 0xE64E: //docomo sagittarius
                            buff.append(""<img src=\""file:///android_asset/emoticons/sagittarius.gif\"" alt=\""sagittarius\"" />"");
                            break;
                        case 0xE6F5: //docomo up
                            buff.append(""<img src=\""file:///android_asset/emoticons/up.gif\"" alt=\""up\"" />"");
                            break;
                        case 0xE720: //docomo think
                            buff.append(""<img src=\""file:///android_asset/emoticons/think.gif\"" alt=\""think\"" />"");
                            break;
                        case 0xE6E2: //docomo one
                            buff.append(""<img src=\""file:///android_asset/emoticons/one.gif\"" alt=\""one\"" />"");
                            break;
                        case 0xE6D8: //docomo id
                            buff.append(""<img src=\""file:///android_asset/emoticons/id.gif\"" alt=\""id\"" />"");
                            break;
                        case 0xE675: //docomo hairsalon
                            buff.append(""<img src=\""file:///android_asset/emoticons/hairsalon.gif\"" alt=\""hairsalon\"" />"");
                            break;
                        case 0xE6B7: //docomo soon
                            buff.append(""<img src=\""file:///android_asset/emoticons/soon.gif\"" alt=\""soon\"" />"");
                            break;
                        case 0xE717: //docomo loveletter
                            buff.append(""<img src=\""file:///android_asset/emoticons/loveletter.gif\"" alt=\""loveletter\"" />"");
                            break;
                        case 0xE673: //docomo fastfood
                            buff.append(""<img src=\""file:///android_asset/emoticons/fastfood.gif\"" alt=\""fastfood\"" />"");
                            break;
                        case 0xE719: //docomo pencil
                            buff.append(""<img src=\""file:///android_asset/emoticons/pencil.gif\"" alt=\""pencil\"" />"");
                            break;
                        case 0xE697: //docomo upwardleft
                            buff.append(""<img src=\""file:///android_asset/emoticons/upwardleft.gif\"" alt=\""upwardleft\"" />"");
                            break;
                        case 0xE730: //docomo clip
                            buff.append(""<img src=\""file:///android_asset/emoticons/clip.gif\"" alt=\""clip\"" />"");
                            break;
                        case 0xE6ED: //docomo heart02
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart02.gif\"" alt=\""heart02\"" />"");
                            break;
                        case 0xE69A: //docomo eyeglass
                            buff.append(""<img src=\""file:///android_asset/emoticons/eyeglass.gif\"" alt=\""eyeglass\"" />"");
                            break;
                        case 0xE65E: //docomo car
                            buff.append(""<img src=\""file:///android_asset/emoticons/car.gif\"" alt=\""car\"" />"");
                            break;
                        case 0xE742: //docomo cherry
                            buff.append(""<img src=\""file:///android_asset/emoticons/cherry.gif\"" alt=\""cherry\"" />"");
                            break;
                        case 0xE71C: //docomo sandclock
                            buff.append(""<img src=\""file:///android_asset/emoticons/sandclock.gif\"" alt=\""sandclock\"" />"");
                            break;
                        case 0xE735: //docomo recycle
                            buff.append(""<img src=\""file:///android_asset/emoticons/recycle.gif\"" alt=\""recycle\"" />"");
                            break;
                        case 0xE752: //docomo delicious
                            buff.append(""<img src=\""file:///android_asset/emoticons/delicious.gif\"" alt=\""delicious\"" />"");
                            break;
                        case 0xE69E: //docomo moon2
                            buff.append(""<img src=\""file:///android_asset/emoticons/moon2.gif\"" alt=\""moon2\"" />"");
                            break;
                        case 0xE68A: //docomo tv
                            buff.append(""<img src=\""file:///android_asset/emoticons/tv.gif\"" alt=\""tv\"" />"");
                            break;
                        case 0xE706: //docomo sweat01
                            buff.append(""<img src=\""file:///android_asset/emoticons/sweat01.gif\"" alt=\""sweat01\"" />"");
                            break;
                        case 0xE738: //docomo ban
                            buff.append(""<img src=\""file:///android_asset/emoticons/ban.gif\"" alt=\""ban\"" />"");
                            break;
                        case 0xE672: //docomo beer
                            buff.append(""<img src=\""file:///android_asset/emoticons/beer.gif\"" alt=\""beer\"" />"");
                            break;
                        case 0xE640: //docomo rain
                            buff.append(""<img src=\""file:///android_asset/emoticons/rain.gif\"" alt=\""rain\"" />"");
                            break;
                        case 0xE69F: //docomo moon3
                            buff.append(""<img src=\""file:///android_asset/emoticons/moon3.gif\"" alt=\""moon3\"" />"");
                            break;
                        case 0xE657: //docomo ski
                            buff.append(""<img src=\""file:///android_asset/emoticons/ski.gif\"" alt=\""ski\"" />"");
                            break;
                        case 0xE70C: //docomo appli01
                            buff.append(""<img src=\""file:///android_asset/emoticons/appli01.gif\"" alt=\""appli01\"" />"");
                            break;
                        case 0xE6E5: //docomo four
                            buff.append(""<img src=\""file:///android_asset/emoticons/four.gif\"" alt=\""four\"" />"");
                            break;
                        case 0xE699: //docomo shoe
                            buff.append(""<img src=\""file:///android_asset/emoticons/shoe.gif\"" alt=\""shoe\"" />"");
                            break;
                        case 0xE63F: //docomo cloud
                            buff.append(""<img src=\""file:///android_asset/emoticons/cloud.gif\"" alt=\""cloud\"" />"");
                            break;
                        case 0xE72F: //docomo ng
                            buff.append(""<img src=\""file:///android_asset/emoticons/ng.gif\"" alt=\""ng\"" />"");
                            break;
                        case 0xE6A3: //docomo yacht
                            buff.append(""<img src=\""file:///android_asset/emoticons/yacht.gif\"" alt=\""yacht\"" />"");
                            break;
                        case 0xE73A: //docomo pass
                            buff.append(""<img src=\""file:///android_asset/emoticons/pass.gif\"" alt=\""pass\"" />"");
                            break;
                        case 0xE67C: //docomo drama
                            buff.append(""<img src=\""file:///android_asset/emoticons/drama.gif\"" alt=\""drama\"" />"");
                            break;
                        case 0xE727: //docomo good
                            buff.append(""<img src=\""file:///android_asset/emoticons/good.gif\"" alt=\""good\"" />"");
                            break;
                        case 0xE6EB: //docomo zero
                            buff.append(""<img src=\""file:///android_asset/emoticons/zero.gif\"" alt=\""zero\"" />"");
                            break;
                        case 0xE72C: //docomo catface
                            buff.append(""<img src=\""file:///android_asset/emoticons/catface.gif\"" alt=\""catface\"" />"");
                            break;
                        case 0xE6D5: //docomo d-point
                            buff.append(""<img src=\""file:///android_asset/emoticons/d-point.gif\"" alt=\""d-point\"" />"");
                            break;
                        case 0xE6F2: //docomo despair
                            buff.append(""<img src=\""file:///android_asset/emoticons/despair.gif\"" alt=\""despair\"" />"");
                            break;
                        case 0xE700: //docomo down
                            buff.append(""<img src=\""file:///android_asset/emoticons/down.gif\"" alt=\""down\"" />"");
                            break;
                        case 0xE655: //docomo tennis
                            buff.append(""<img src=\""file:///android_asset/emoticons/tennis.gif\"" alt=\""tennis\"" />"");
                            break;
                        case 0xE703: //docomo sign02
                            buff.append(""<img src=\""file:///android_asset/emoticons/sign02.gif\"" alt=\""sign02\"" />"");
                            break;
                        case 0xE711: //docomo denim
                            buff.append(""<img src=\""file:///android_asset/emoticons/denim.gif\"" alt=\""denim\"" />"");
                            break;
                        case 0xE705: //docomo impact
                            buff.append(""<img src=\""file:///android_asset/emoticons/impact.gif\"" alt=\""impact\"" />"");
                            break;
                        case 0xE642: //docomo thunder
                            buff.append(""<img src=\""file:///android_asset/emoticons/thunder.gif\"" alt=\""thunder\"" />"");
                            break;
                        case 0xE66C: //docomo parking
                            buff.append(""<img src=\""file:///android_asset/emoticons/parking.gif\"" alt=\""parking\"" />"");
                            break;
                        case 0xE6F3: //docomo sad
                            buff.append(""<img src=\""file:///android_asset/emoticons/sad.gif\"" alt=\""sad\"" />"");
                            break;
                        case 0xE71E: //docomo japanesetea
                            buff.append(""<img src=\""file:///android_asset/emoticons/japanesetea.gif\"" alt=\""japanesetea\"" />"");
                            break;
                        case 0xE6FD: //docomo punch
                            buff.append(""<img src=\""file:///android_asset/emoticons/punch.gif\"" alt=\""punch\"" />"");
                            break;
                        case 0xE73D: //docomo updown
                            buff.append(""<img src=\""file:///android_asset/emoticons/updown.gif\"" alt=\""updown\"" />"");
                            break;
                        case 0xE66F: //docomo restaurant
                            buff.append(""<img src=\""file:///android_asset/emoticons/restaurant.gif\"" alt=\""restaurant\"" />"");
                            break;
                        case 0xE66E: //docomo toilet
                            buff.append(""<img src=\""file:///android_asset/emoticons/toilet.gif\"" alt=\""toilet\"" />"");
                            break;
                        case 0xE739: //docomo empty
                            buff.append(""<img src=\""file:///android_asset/emoticons/empty.gif\"" alt=\""empty\"" />"");
                            break;
                        case 0xE723: //docomo coldsweats02
                            buff.append(""<img src=\""file:///android_asset/emoticons/coldsweats02.gif\"" alt=\""coldsweats02\"" />"");
                            break;
                        case 0xE6B9: //docomo end
                            buff.append(""<img src=\""file:///android_asset/emoticons/end.gif\"" alt=\""end\"" />"");
                            break;
                        case 0xE67B: //docomo art
                            buff.append(""<img src=\""file:///android_asset/emoticons/art.gif\"" alt=\""art\"" />"");
                            break;
                        case 0xE72E: //docomo weep
                            buff.append(""<img src=\""file:///android_asset/emoticons/weep.gif\"" alt=\""weep\"" />"");
                            break;
                        case 0xE715: //docomo dollar
                            buff.append(""<img src=\""file:///android_asset/emoticons/dollar.gif\"" alt=\""dollar\"" />"");
                            break;
                        case 0xE6CF: //docomo mailto
                            buff.append(""<img src=\""file:///android_asset/emoticons/mailto.gif\"" alt=\""mailto\"" />"");
                            break;
                        case 0xE6F8: //docomo cute
                            buff.append(""<img src=\""file:///android_asset/emoticons/cute.gif\"" alt=\""cute\"" />"");
                            break;
                        case 0xE6DD: //docomo new
                            buff.append(""<img src=\""file:///android_asset/emoticons/new.gif\"" alt=\""new\"" />"");
                            break;
                        case 0xE651: //docomo pisces
                            buff.append(""<img src=\""file:///android_asset/emoticons/pisces.gif\"" alt=\""pisces\"" />"");
                            break;
                        case 0xE756: //docomo wine
                            buff.append(""<img src=\""file:///android_asset/emoticons/wine.gif\"" alt=\""wine\"" />"");
                            break;
                        case 0xE649: //docomo cancer
                            buff.append(""<img src=\""file:///android_asset/emoticons/cancer.gif\"" alt=\""cancer\"" />"");
                            break;
                        case 0xE650: //docomo aquarius
                            buff.append(""<img src=\""file:///android_asset/emoticons/aquarius.gif\"" alt=\""aquarius\"" />"");
                            break;
                        case 0xE740: //docomo fuji
                            buff.append(""<img src=\""file:///android_asset/emoticons/fuji.gif\"" alt=\""fuji\"" />"");
                            break;
                        case 0xE681: //docomo camera
                            buff.append(""<img src=\""file:///android_asset/emoticons/camera.gif\"" alt=\""camera\"" />"");
                            break;
                        case 0xE71F: //docomo watch
                            buff.append(""<img src=\""file:///android_asset/emoticons/watch.gif\"" alt=\""watch\"" />"");
                            break;
                        case 0xE6EE: //docomo heart03
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart03.gif\"" alt=\""heart03\"" />"");
                            break;
                        case 0xE71A: //docomo crown
                            buff.append(""<img src=\""file:///android_asset/emoticons/crown.gif\"" alt=\""crown\"" />"");
                            break;
                        case 0xE6B3: //docomo night
                            buff.append(""<img src=\""file:///android_asset/emoticons/night.gif\"" alt=\""night\"" />"");
                            break;
                        case 0xE66B: //docomo gasstation
                            buff.append(""<img src=\""file:///android_asset/emoticons/gasstation.gif\"" alt=\""gasstation\"" />"");
                            break;
                        case 0xE692: //docomo ear
                            buff.append(""<img src=\""file:///android_asset/emoticons/ear.gif\"" alt=\""ear\"" />"");
                            break;
                        case 0xE685: //docomo present
                            buff.append(""<img src=\""file:///android_asset/emoticons/present.gif\"" alt=\""present\"" />"");
                            break;
                        case 0xE6E9: //docomo eight
                            buff.append(""<img src=\""file:///android_asset/emoticons/eight.gif\"" alt=\""eight\"" />"");
                            break;
                        case 0xE70F: //docomo moneybag
                            buff.append(""<img src=\""file:///android_asset/emoticons/moneybag.gif\"" alt=\""moneybag\"" />"");
                            break;
                        case 0xE749: //docomo riceball
                            buff.append(""<img src=\""file:///android_asset/emoticons/riceball.gif\"" alt=\""riceball\"" />"");
                            break;
                        case 0xE6A0: //docomo fullmoon
                            buff.append(""<img src=\""file:///android_asset/emoticons/fullmoon.gif\"" alt=\""fullmoon\"" />"");
                            break;
                        case 0xE74D: //docomo bread
                            buff.append(""<img src=\""file:///android_asset/emoticons/bread.gif\"" alt=\""bread\"" />"");
                            break;
                        case 0xE665: //docomo postoffice
                            buff.append(""<img src=\""file:///android_asset/emoticons/postoffice.gif\"" alt=\""postoffice\"" />"");
                            break;
                        case 0xE677: //docomo movie
                            buff.append(""<img src=\""file:///android_asset/emoticons/movie.gif\"" alt=\""movie\"" />"");
                            break;
                        case 0xE668: //docomo atm
                            buff.append(""<img src=\""file:///android_asset/emoticons/atm.gif\"" alt=\""atm\"" />"");
                            break;
                        case 0xE688: //docomo mobilephone
                            buff.append(""<img src=\""file:///android_asset/emoticons/mobilephone.gif\"" alt=\""mobilephone\"" />"");
                            break;
                        case 0xE6FA: //docomo shine
                            buff.append(""<img src=\""file:///android_asset/emoticons/shine.gif\"" alt=\""shine\"" />"");
                            break;
                        case 0xE713: //docomo bell
                            buff.append(""<img src=\""file:///android_asset/emoticons/bell.gif\"" alt=\""bell\"" />"");
                            break;
                        case 0xE74B: //docomo bottle
                            buff.append(""<img src=\""file:///android_asset/emoticons/bottle.gif\"" alt=\""bottle\"" />"");
                            break;
                        case 0xE754: //docomo horse
                            buff.append(""<img src=\""file:///android_asset/emoticons/horse.gif\"" alt=\""horse\"" />"");
                            break;
                        case 0xE751: //docomo fish
                            buff.append(""<img src=\""file:///android_asset/emoticons/fish.gif\"" alt=\""fish\"" />"");
                            break;
                        case 0xE659: //docomo motorsports
                            buff.append(""<img src=\""file:///android_asset/emoticons/motorsports.gif\"" alt=\""motorsports\"" />"");
                            break;
                        case 0xE6D3: //docomo mail
                            buff.append(""<img src=\""file:///android_asset/emoticons/mail.gif\"" alt=\""mail\"" />"");
                            break;
                            // These emoji codepoints are generated by tools/make_emoji in the K-9 source tree
                            // The spaces between the < and the img are a hack to avoid triggering
                            // K-9's 'load images' button

                        case 0xE223: //softbank eight
                            buff.append(""<img src=\""file:///android_asset/emoticons/eight.gif\"" alt=\""eight\"" />"");
                            break;
                        case 0xE415: //softbank coldsweats01
                            buff.append(""<img src=\""file:///android_asset/emoticons/coldsweats01.gif\"" alt=\""coldsweats01\"" />"");
                            break;
                        case 0xE21F: //softbank four
                            buff.append(""<img src=\""file:///android_asset/emoticons/four.gif\"" alt=\""four\"" />"");
                            break;
                        case 0xE125: //softbank ticket
                            buff.append(""<img src=\""file:///android_asset/emoticons/ticket.gif\"" alt=\""ticket\"" />"");
                            break;
                        case 0xE148: //softbank book
                            buff.append(""<img src=\""file:///android_asset/emoticons/book.gif\"" alt=\""book\"" />"");
                            break;
                        case 0xE242: //softbank cancer
                            buff.append(""<img src=\""file:///android_asset/emoticons/cancer.gif\"" alt=\""cancer\"" />"");
                            break;
                        case 0xE31C: //softbank rouge
                            buff.append(""<img src=\""file:///android_asset/emoticons/rouge.gif\"" alt=\""rouge\"" />"");
                            break;
                        case 0xE252: //softbank danger
                            buff.append(""<img src=\""file:///android_asset/emoticons/danger.gif\"" alt=\""danger\"" />"");
                            break;
                        case 0xE011: //softbank scissors
                            buff.append(""<img src=\""file:///android_asset/emoticons/scissors.gif\"" alt=\""scissors\"" />"");
                            break;
                        case 0xE342: //softbank riceball
                            buff.append(""<img src=\""file:///android_asset/emoticons/riceball.gif\"" alt=\""riceball\"" />"");
                            break;
                        case 0xE04B: //softbank rain
                            buff.append(""<img src=\""file:///android_asset/emoticons/rain.gif\"" alt=\""rain\"" />"");
                            break;
                        case 0xE03E: //softbank note
                            buff.append(""<img src=\""file:///android_asset/emoticons/note.gif\"" alt=\""note\"" />"");
                            break;
                        case 0xE43C: //softbank sprinkle
                            buff.append(""<img src=\""file:///android_asset/emoticons/sprinkle.gif\"" alt=\""sprinkle\"" />"");
                            break;
                        case 0xE20A: //softbank wheelchair
                            buff.append(""<img src=\""file:///android_asset/emoticons/wheelchair.gif\"" alt=\""wheelchair\"" />"");
                            break;
                        case 0xE42A: //softbank basketball
                            buff.append(""<img src=\""file:///android_asset/emoticons/basketball.gif\"" alt=\""basketball\"" />"");
                            break;
                        case 0xE03D: //softbank movie
                            buff.append(""<img src=\""file:///android_asset/emoticons/movie.gif\"" alt=\""movie\"" />"");
                            break;
                        case 0xE30E: //softbank smoking
                            buff.append(""<img src=\""file:///android_asset/emoticons/smoking.gif\"" alt=\""smoking\"" />"");
                            break;
                        case 0xE003: //softbank kissmark
                            buff.append(""<img src=\""file:///android_asset/emoticons/kissmark.gif\"" alt=\""kissmark\"" />"");
                            break;
                        case 0xE21C: //softbank one
                            buff.append(""<img src=\""file:///android_asset/emoticons/one.gif\"" alt=\""one\"" />"");
                            break;
                        case 0xE237: //softbank upwardleft
                            buff.append(""<img src=\""file:///android_asset/emoticons/upwardleft.gif\"" alt=\""upwardleft\"" />"");
                            break;
                        case 0xE407: //softbank sad
                            buff.append(""<img src=\""file:///android_asset/emoticons/sad.gif\"" alt=\""sad\"" />"");
                            break;
                        case 0xE03B: //softbank fuji
                            buff.append(""<img src=\""file:///android_asset/emoticons/fuji.gif\"" alt=\""fuji\"" />"");
                            break;
                        case 0xE40E: //softbank gawk
                            buff.append(""<img src=\""file:///android_asset/emoticons/gawk.gif\"" alt=\""gawk\"" />"");
                            break;
                        case 0xE245: //softbank libra
                            buff.append(""<img src=\""file:///android_asset/emoticons/libra.gif\"" alt=\""libra\"" />"");
                            break;
                        case 0xE24A: //softbank pisces
                            buff.append(""<img src=\""file:///android_asset/emoticons/pisces.gif\"" alt=\""pisces\"" />"");
                            break;
                        case 0xE443: //softbank typhoon
                            buff.append(""<img src=\""file:///android_asset/emoticons/typhoon.gif\"" alt=\""typhoon\"" />"");
                            break;
                        case 0xE052: //softbank dog
                            buff.append(""<img src=\""file:///android_asset/emoticons/dog.gif\"" alt=\""dog\"" />"");
                            break;
                        case 0xE244: //softbank virgo
                            buff.append(""<img src=\""file:///android_asset/emoticons/virgo.gif\"" alt=\""virgo\"" />"");
                            break;
                        case 0xE523: //softbank chick
                            buff.append(""<img src=\""file:///android_asset/emoticons/chick.gif\"" alt=\""chick\"" />"");
                            break;
                        case 0xE023: //softbank heart03
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart03.gif\"" alt=\""heart03\"" />"");
                            break;
                        case 0xE325: //softbank bell
                            buff.append(""<img src=\""file:///android_asset/emoticons/bell.gif\"" alt=\""bell\"" />"");
                            break;
                        case 0xE239: //softbank downwardleft
                            buff.append(""<img src=\""file:///android_asset/emoticons/downwardleft.gif\"" alt=\""downwardleft\"" />"");
                            break;
                        case 0xE20C: //softbank heart
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart.gif\"" alt=\""heart\"" />"");
                            break;
                        case 0xE211: //softbank freedial
                            buff.append(""<img src=\""file:///android_asset/emoticons/freedial.gif\"" alt=\""freedial\"" />"");
                            break;
                        case 0xE11F: //softbank chair
                            buff.append(""<img src=\""file:///android_asset/emoticons/chair.gif\"" alt=\""chair\"" />"");
                            break;
                        case 0xE108: //softbank coldsweats02
                            buff.append(""<img src=\""file:///android_asset/emoticons/coldsweats02.gif\"" alt=\""coldsweats02\"" />"");
                            break;
                        case 0xE330: //softbank dash
                            buff.append(""<img src=\""file:///android_asset/emoticons/dash.gif\"" alt=\""dash\"" />"");
                            break;
                        case 0xE404: //softbank smile
                            buff.append(""<img src=\""file:///android_asset/emoticons/smile.gif\"" alt=\""smile\"" />"");
                            break;
                        case 0xE304: //softbank tulip
                            buff.append(""<img src=\""file:///android_asset/emoticons/tulip.gif\"" alt=\""tulip\"" />"");
                            break;
                        case 0xE419: //softbank eye
                            buff.append(""<img src=\""file:///android_asset/emoticons/eye.gif\"" alt=\""eye\"" />"");
                            break;
                        case 0xE13D: //softbank thunder
                            buff.append(""<img src=\""file:///android_asset/emoticons/thunder.gif\"" alt=\""thunder\"" />"");
                            break;
                        case 0xE013: //softbank ski
                            buff.append(""<img src=\""file:///android_asset/emoticons/ski.gif\"" alt=\""ski\"" />"");
                            break;
                        case 0xE136: //softbank bicycle
                            buff.append(""<img src=\""file:///android_asset/emoticons/bicycle.gif\"" alt=\""bicycle\"" />"");
                            break;
                        case 0xE059: //softbank angry
                            buff.append(""<img src=\""file:///android_asset/emoticons/angry.gif\"" alt=\""angry\"" />"");
                            break;
                        case 0xE01D: //softbank airplane
                            buff.append(""<img src=\""file:///android_asset/emoticons/airplane.gif\"" alt=\""airplane\"" />"");
                            break;
                        case 0xE048: //softbank snow
                            buff.append(""<img src=\""file:///android_asset/emoticons/snow.gif\"" alt=\""snow\"" />"");
                            break;
                        case 0xE435: //softbank bullettrain
                            buff.append(""<img src=\""file:///android_asset/emoticons/bullettrain.gif\"" alt=\""bullettrain\"" />"");
                            break;
                        case 0xE20E: //softbank spade
                            buff.append(""<img src=\""file:///android_asset/emoticons/spade.gif\"" alt=\""spade\"" />"");
                            break;
                        case 0xE247: //softbank sagittarius
                            buff.append(""<img src=\""file:///android_asset/emoticons/sagittarius.gif\"" alt=\""sagittarius\"" />"");
                            break;
                        case 0xE157: //softbank school
                            buff.append(""<img src=\""file:///android_asset/emoticons/school.gif\"" alt=\""school\"" />"");
                            break;
                        case 0xE10F: //softbank flair
                            buff.append(""<img src=\""file:///android_asset/emoticons/flair.gif\"" alt=\""flair\"" />"");
                            break;
                        case 0xE502: //softbank art
                            buff.append(""<img src=\""file:///android_asset/emoticons/art.gif\"" alt=\""art\"" />"");
                            break;
                        case 0xE338: //softbank japanesetea
                            buff.append(""<img src=\""file:///android_asset/emoticons/japanesetea.gif\"" alt=\""japanesetea\"" />"");
                            break;
                        case 0xE34B: //softbank birthday
                            buff.append(""<img src=\""file:///android_asset/emoticons/birthday.gif\"" alt=\""birthday\"" />"");
                            break;
                        case 0xE22B: //softbank empty
                            buff.append(""<img src=\""file:///android_asset/emoticons/empty.gif\"" alt=\""empty\"" />"");
                            break;
                        case 0xE311: //softbank bomb
                            buff.append(""<img src=\""file:///android_asset/emoticons/bomb.gif\"" alt=\""bomb\"" />"");
                            break;
                        case 0xE012: //softbank paper
                            buff.append(""<img src=\""file:///android_asset/emoticons/paper.gif\"" alt=\""paper\"" />"");
                            break;
                        case 0xE151: //softbank toilet
                            buff.append(""<img src=\""file:///android_asset/emoticons/toilet.gif\"" alt=\""toilet\"" />"");
                            break;
                        case 0xE01A: //softbank horse
                            buff.append(""<img src=\""file:///android_asset/emoticons/horse.gif\"" alt=\""horse\"" />"");
                            break;
                        case 0xE03A: //softbank gasstation
                            buff.append(""<img src=\""file:///android_asset/emoticons/gasstation.gif\"" alt=\""gasstation\"" />"");
                            break;
                        case 0xE03F: //softbank key
                            buff.append(""<img src=\""file:///android_asset/emoticons/key.gif\"" alt=\""key\"" />"");
                            break;
                        case 0xE00D: //softbank punch
                            buff.append(""<img src=\""file:///android_asset/emoticons/punch.gif\"" alt=\""punch\"" />"");
                            break;
                        case 0xE24D: //softbank ok
                            buff.append(""<img src=\""file:///android_asset/emoticons/ok.gif\"" alt=\""ok\"" />"");
                            break;
                        case 0xE105: //softbank bleah
                            buff.append(""<img src=\""file:///android_asset/emoticons/bleah.gif\"" alt=\""bleah\"" />"");
                            break;
                        case 0xE00E: //softbank good
                            buff.append(""<img src=\""file:///android_asset/emoticons/good.gif\"" alt=\""good\"" />"");
                            break;
                        case 0xE154: //softbank atm
                            buff.append(""<img src=\""file:///android_asset/emoticons/atm.gif\"" alt=\""atm\"" />"");
                            break;
                        case 0xE405: //softbank wink
                            buff.append(""<img src=\""file:///android_asset/emoticons/wink.gif\"" alt=\""wink\"" />"");
                            break;
                        case 0xE030: //softbank cherryblossom
                            buff.append(""<img src=\""file:///android_asset/emoticons/cherryblossom.gif\"" alt=\""cherryblossom\"" />"");
                            break;
                        case 0xE057: //softbank happy01
                            buff.append(""<img src=\""file:///android_asset/emoticons/happy01.gif\"" alt=\""happy01\"" />"");
                            break;
                        case 0xE229: //softbank id
                            buff.append(""<img src=\""file:///android_asset/emoticons/id.gif\"" alt=\""id\"" />"");
                            break;
                        case 0xE016: //softbank baseball
                            buff.append(""<img src=\""file:///android_asset/emoticons/baseball.gif\"" alt=\""baseball\"" />"");
                            break;
                        case 0xE044: //softbank wine
                            buff.append(""<img src=\""file:///android_asset/emoticons/wine.gif\"" alt=\""wine\"" />"");
                            break;
                        case 0xE115: //softbank run
                            buff.append(""<img src=\""file:///android_asset/emoticons/run.gif\"" alt=\""run\"" />"");
                            break;
                        case 0xE14F: //softbank parking
                            buff.append(""<img src=\""file:///android_asset/emoticons/parking.gif\"" alt=\""parking\"" />"");
                            break;
                        case 0xE327: //softbank heart04
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart04.gif\"" alt=\""heart04\"" />"");
                            break;
                        case 0xE014: //softbank golf
                            buff.append(""<img src=\""file:///android_asset/emoticons/golf.gif\"" alt=\""golf\"" />"");
                            break;
                        case 0xE021: //softbank sign01
                            buff.append(""<img src=\""file:///android_asset/emoticons/sign01.gif\"" alt=\""sign01\"" />"");
                            break;
                        case 0xE30A: //softbank music
                            buff.append(""<img src=\""file:///android_asset/emoticons/music.gif\"" alt=\""music\"" />"");
                            break;
                        case 0xE411: //softbank crying
                            buff.append(""<img src=\""file:///android_asset/emoticons/crying.gif\"" alt=\""crying\"" />"");
                            break;
                        case 0xE536: //softbank foot
                            buff.append(""<img src=\""file:///android_asset/emoticons/foot.gif\"" alt=\""foot\"" />"");
                            break;
                        case 0xE047: //softbank beer
                            buff.append(""<img src=\""file:///android_asset/emoticons/beer.gif\"" alt=\""beer\"" />"");
                            break;
                        case 0xE43E: //softbank wave
                            buff.append(""<img src=\""file:///android_asset/emoticons/wave.gif\"" alt=\""wave\"" />"");
                            break;
                        case 0xE022: //softbank heart01
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart01.gif\"" alt=\""heart01\"" />"");
                            break;
                        case 0xE007: //softbank shoe
                            buff.append(""<img src=\""file:///android_asset/emoticons/shoe.gif\"" alt=\""shoe\"" />"");
                            break;
                        case 0xE010: //softbank rock
                            buff.append(""<img src=\""file:///android_asset/emoticons/rock.gif\"" alt=\""rock\"" />"");
                            break;
                        case 0xE32E: //softbank shine
                            buff.append(""<img src=\""file:///android_asset/emoticons/shine.gif\"" alt=\""shine\"" />"");
                            break;
                        case 0xE055: //softbank penguin
                            buff.append(""<img src=\""file:///android_asset/emoticons/penguin.gif\"" alt=\""penguin\"" />"");
                            break;
                        case 0xE03C: //softbank karaoke
                            buff.append(""<img src=\""file:///android_asset/emoticons/karaoke.gif\"" alt=\""karaoke\"" />"");
                            break;
                        case 0xE018: //softbank soccer
                            buff.append(""<img src=\""file:///android_asset/emoticons/soccer.gif\"" alt=\""soccer\"" />"");
                            break;
                        case 0xE159: //softbank bus
                            buff.append(""<img src=\""file:///android_asset/emoticons/bus.gif\"" alt=\""bus\"" />"");
                            break;
                        case 0xE107: //softbank shock
                            buff.append(""<img src=\""file:///android_asset/emoticons/shock.gif\"" alt=\""shock\"" />"");
                            break;
                        case 0xE04A: //softbank sun
                            buff.append(""<img src=\""file:///android_asset/emoticons/sun.gif\"" alt=\""sun\"" />"");
                            break;
                        case 0xE156: //softbank 24hours
                            buff.append(""<img src=\""file:///android_asset/emoticons/24hours.gif\"" alt=\""24hours\"" />"");
                            break;
                        case 0xE110: //softbank clover
                            buff.append(""<img src=\""file:///android_asset/emoticons/clover.gif\"" alt=\""clover\"" />"");
                            break;
                        case 0xE034: //softbank ring
                            buff.append(""<img src=\""file:///android_asset/emoticons/ring.gif\"" alt=\""ring\"" />"");
                            break;
                        case 0xE24F: //softbank r-mark
                            buff.append(""<img src=\""file:///android_asset/emoticons/r-mark.gif\"" alt=\""r-mark\"" />"");
                            break;
                        case 0xE112: //softbank present
                            buff.append(""<img src=\""file:///android_asset/emoticons/present.gif\"" alt=\""present\"" />"");
                            break;
                        case 0xE14D: //softbank bank
                            buff.append(""<img src=\""file:///android_asset/emoticons/bank.gif\"" alt=\""bank\"" />"");
                            break;
                        case 0xE42E: //softbank rvcar
                            buff.append(""<img src=\""file:///android_asset/emoticons/rvcar.gif\"" alt=\""rvcar\"" />"");
                            break;
                        case 0xE13E: //softbank boutique
                            buff.append(""<img src=\""file:///android_asset/emoticons/boutique.gif\"" alt=\""boutique\"" />"");
                            break;
                        case 0xE413: //softbank weep
                            buff.append(""<img src=\""file:///android_asset/emoticons/weep.gif\"" alt=\""weep\"" />"");
                            break;
                        case 0xE241: //softbank gemini
                            buff.append(""<img src=\""file:///android_asset/emoticons/gemini.gif\"" alt=\""gemini\"" />"");
                            break;
                        case 0xE212: //softbank new
                            buff.append(""<img src=\""file:///android_asset/emoticons/new.gif\"" alt=\""new\"" />"");
                            break;
                        case 0xE324: //softbank slate
                            buff.append(""<img src=\""file:///android_asset/emoticons/slate.gif\"" alt=\""slate\"" />"");
                            break;
                        case 0xE220: //softbank five
                            buff.append(""<img src=\""file:///android_asset/emoticons/five.gif\"" alt=\""five\"" />"");
                            break;
                        case 0xE503: //softbank drama
                            buff.append(""<img src=\""file:///android_asset/emoticons/drama.gif\"" alt=\""drama\"" />"");
                            break;
                        case 0xE248: //softbank capricornus
                            buff.append(""<img src=\""file:///android_asset/emoticons/capricornus.gif\"" alt=\""capricornus\"" />"");
                            break;
                        case 0xE049: //softbank cloud
                            buff.append(""<img src=\""file:///android_asset/emoticons/cloud.gif\"" alt=\""cloud\"" />"");
                            break;
                        case 0xE243: //softbank leo
                            buff.append(""<img src=\""file:///android_asset/emoticons/leo.gif\"" alt=\""leo\"" />"");
                            break;
                        case 0xE326: //softbank notes
                            buff.append(""<img src=\""file:///android_asset/emoticons/notes.gif\"" alt=\""notes\"" />"");
                            break;
                        case 0xE00B: //softbank faxto
                            buff.append(""<img src=\""file:///android_asset/emoticons/faxto.gif\"" alt=\""faxto\"" />"");
                            break;
                        case 0xE221: //softbank six
                            buff.append(""<img src=\""file:///android_asset/emoticons/six.gif\"" alt=\""six\"" />"");
                            break;
                        case 0xE240: //softbank taurus
                            buff.append(""<img src=\""file:///android_asset/emoticons/taurus.gif\"" alt=\""taurus\"" />"");
                            break;
                        case 0xE24E: //softbank copyright
                            buff.append(""<img src=\""file:///android_asset/emoticons/copyright.gif\"" alt=\""copyright\"" />"");
                            break;
                        case 0xE224: //softbank nine
                            buff.append(""<img src=\""file:///android_asset/emoticons/nine.gif\"" alt=\""nine\"" />"");
                            break;
                        case 0xE008: //softbank camera
                            buff.append(""<img src=\""file:///android_asset/emoticons/camera.gif\"" alt=\""camera\"" />"");
                            break;
                        case 0xE01E: //softbank train
                            buff.append(""<img src=\""file:///android_asset/emoticons/train.gif\"" alt=\""train\"" />"");
                            break;
                        case 0xE20D: //softbank diamond
                            buff.append(""<img src=\""file:///android_asset/emoticons/diamond.gif\"" alt=\""diamond\"" />"");
                            break;
                        case 0xE009: //softbank telephone
                            buff.append(""<img src=\""file:///android_asset/emoticons/telephone.gif\"" alt=\""telephone\"" />"");
                            break;
                        case 0xE019: //softbank fish
                            buff.append(""<img src=\""file:///android_asset/emoticons/fish.gif\"" alt=\""fish\"" />"");
                            break;
                        case 0xE01C: //softbank yacht
                            buff.append(""<img src=\""file:///android_asset/emoticons/yacht.gif\"" alt=\""yacht\"" />"");
                            break;
                        case 0xE40A: //softbank confident
                            buff.append(""<img src=\""file:///android_asset/emoticons/confident.gif\"" alt=\""confident\"" />"");
                            break;
                        case 0xE246: //softbank scorpius
                            buff.append(""<img src=\""file:///android_asset/emoticons/scorpius.gif\"" alt=\""scorpius\"" />"");
                            break;
                        case 0xE120: //softbank fastfood
                            buff.append(""<img src=\""file:///android_asset/emoticons/fastfood.gif\"" alt=\""fastfood\"" />"");
                            break;
                        case 0xE323: //softbank bag
                            buff.append(""<img src=\""file:///android_asset/emoticons/bag.gif\"" alt=\""bag\"" />"");
                            break;
                        case 0xE345: //softbank apple
                            buff.append(""<img src=\""file:///android_asset/emoticons/apple.gif\"" alt=\""apple\"" />"");
                            break;
                        case 0xE339: //softbank bread
                            buff.append(""<img src=\""file:///android_asset/emoticons/bread.gif\"" alt=\""bread\"" />"");
                            break;
                        case 0xE13C: //softbank sleepy
                            buff.append(""<img src=\""file:///android_asset/emoticons/sleepy.gif\"" alt=\""sleepy\"" />"");
                            break;
                        case 0xE106: //softbank lovely
                            buff.append(""<img src=\""file:///android_asset/emoticons/lovely.gif\"" alt=\""lovely\"" />"");
                            break;
                        case 0xE340: //softbank noodle
                            buff.append(""<img src=\""file:///android_asset/emoticons/noodle.gif\"" alt=\""noodle\"" />"");
                            break;
                        case 0xE20F: //softbank club
                            buff.append(""<img src=\""file:///android_asset/emoticons/club.gif\"" alt=\""club\"" />"");
                            break;
                        case 0xE114: //softbank search
                            buff.append(""<img src=\""file:///android_asset/emoticons/search.gif\"" alt=\""search\"" />"");
                            break;
                        case 0xE10E: //softbank crown
                            buff.append(""<img src=\""file:///android_asset/emoticons/crown.gif\"" alt=\""crown\"" />"");
                            break;
                        case 0xE406: //softbank wobbly
                            buff.append(""<img src=\""file:///android_asset/emoticons/wobbly.gif\"" alt=\""wobbly\"" />"");
                            break;
                        case 0xE331: //softbank sweat02
                            buff.append(""<img src=\""file:///android_asset/emoticons/sweat02.gif\"" alt=\""sweat02\"" />"");
                            break;
                        case 0xE04F: //softbank cat
                            buff.append(""<img src=\""file:///android_asset/emoticons/cat.gif\"" alt=\""cat\"" />"");
                            break;
                        case 0xE301: //softbank memo
                            buff.append(""<img src=\""file:///android_asset/emoticons/memo.gif\"" alt=\""memo\"" />"");
                            break;
                        case 0xE01B: //softbank car
                            buff.append(""<img src=\""file:///android_asset/emoticons/car.gif\"" alt=\""car\"" />"");
                            break;
                        case 0xE314: //softbank ribbon
                            buff.append(""<img src=\""file:///android_asset/emoticons/ribbon.gif\"" alt=\""ribbon\"" />"");
                            break;
                        case 0xE315: //softbank secret
                            buff.append(""<img src=\""file:///android_asset/emoticons/secret.gif\"" alt=\""secret\"" />"");
                            break;
                        case 0xE236: //softbank up
                            buff.append(""<img src=\""file:///android_asset/emoticons/up.gif\"" alt=\""up\"" />"");
                            break;
                        case 0xE208: //softbank nosmoking
                            buff.append(""<img src=\""file:///android_asset/emoticons/nosmoking.gif\"" alt=\""nosmoking\"" />"");
                            break;
                        case 0xE006: //softbank t-shirt
                            buff.append(""<img src=\""file:///android_asset/emoticons/t-shirt.gif\"" alt=\""t-shirt\"" />"");
                            break;
                        case 0xE12A: //softbank tv
                            buff.append(""<img src=\""file:///android_asset/emoticons/tv.gif\"" alt=\""tv\"" />"");
                            break;
                        case 0xE238: //softbank downwardright
                            buff.append(""<img src=\""file:///android_asset/emoticons/downwardright.gif\"" alt=\""downwardright\"" />"");
                            break;
                        case 0xE10B: //softbank pig
                            buff.append(""<img src=\""file:///android_asset/emoticons/pig.gif\"" alt=\""pig\"" />"");
                            break;
                        case 0xE126: //softbank cd
                            buff.append(""<img src=\""file:///android_asset/emoticons/cd.gif\"" alt=\""cd\"" />"");
                            break;
                        case 0xE402: //softbank catface
                            buff.append(""<img src=\""file:///android_asset/emoticons/catface.gif\"" alt=\""catface\"" />"");
                            break;
                        case 0xE416: //softbank pout
                            buff.append(""<img src=\""file:///android_asset/emoticons/pout.gif\"" alt=\""pout\"" />"");
                            break;
                        case 0xE045: //softbank cafe
                            buff.append(""<img src=\""file:///android_asset/emoticons/cafe.gif\"" alt=\""cafe\"" />"");
                            break;
                        case 0xE41B: //softbank ear
                            buff.append(""<img src=\""file:///android_asset/emoticons/ear.gif\"" alt=\""ear\"" />"");
                            break;
                        case 0xE23F: //softbank aries
                            buff.append(""<img src=\""file:///android_asset/emoticons/aries.gif\"" alt=\""aries\"" />"");
                            break;
                        case 0xE21E: //softbank three
                            buff.append(""<img src=\""file:///android_asset/emoticons/three.gif\"" alt=\""three\"" />"");
                            break;
                        case 0xE056: //softbank delicious
                            buff.append(""<img src=\""file:///android_asset/emoticons/delicious.gif\"" alt=\""delicious\"" />"");
                            break;
                        case 0xE14E: //softbank signaler
                            buff.append(""<img src=\""file:///android_asset/emoticons/signaler.gif\"" alt=\""signaler\"" />"");
                            break;
                        case 0xE155: //softbank hospital
                            buff.append(""<img src=\""file:///android_asset/emoticons/hospital.gif\"" alt=\""hospital\"" />"");
                            break;
                        case 0xE033: //softbank xmas
                            buff.append(""<img src=\""file:///android_asset/emoticons/xmas.gif\"" alt=\""xmas\"" />"");
                            break;
                        case 0xE22A: //softbank full
                            buff.append(""<img src=\""file:///android_asset/emoticons/full.gif\"" alt=\""full\"" />"");
                            break;
                        case 0xE123: //softbank spa
                            buff.append(""<img src=\""file:///android_asset/emoticons/spa.gif\"" alt=\""spa\"" />"");
                            break;
                        case 0xE132: //softbank motorsports
                            buff.append(""<img src=\""file:///android_asset/emoticons/motorsports.gif\"" alt=\""motorsports\"" />"");
                            break;
                        case 0xE434: //softbank subway
                            buff.append(""<img src=\""file:///android_asset/emoticons/subway.gif\"" alt=\""subway\"" />"");
                            break;
                        case 0xE403: //softbank think
                            buff.append(""<img src=\""file:///android_asset/emoticons/think.gif\"" alt=\""think\"" />"");
                            break;
                        case 0xE043: //softbank restaurant
                            buff.append(""<img src=\""file:///android_asset/emoticons/restaurant.gif\"" alt=\""restaurant\"" />"");
                            break;
                        case 0xE537: //softbank tm
                            buff.append(""<img src=\""file:///android_asset/emoticons/tm.gif\"" alt=\""tm\"" />"");
                            break;
                        case 0xE058: //softbank despair
                            buff.append(""<img src=\""file:///android_asset/emoticons/despair.gif\"" alt=\""despair\"" />"");
                            break;
                        case 0xE04C: //softbank moon3
                            buff.append(""<img src=\""file:///android_asset/emoticons/moon3.gif\"" alt=\""moon3\"" />"");
                            break;
                        case 0xE21D: //softbank two
                            buff.append(""<img src=\""file:///android_asset/emoticons/two.gif\"" alt=\""two\"" />"");
                            break;
                        case 0xE202: //softbank ship
                            buff.append(""<img src=\""file:///android_asset/emoticons/ship.gif\"" alt=\""ship\"" />"");
                            break;
                        case 0xE30B: //softbank bottle
                            buff.append(""<img src=\""file:///android_asset/emoticons/bottle.gif\"" alt=\""bottle\"" />"");
                            break;
                        case 0xE118: //softbank maple
                            buff.append(""<img src=\""file:///android_asset/emoticons/maple.gif\"" alt=\""maple\"" />"");
                            break;
                        case 0xE103: //softbank loveletter
                            buff.append(""<img src=\""file:///android_asset/emoticons/loveletter.gif\"" alt=\""loveletter\"" />"");
                            break;
                        case 0xE225: //softbank zero
                            buff.append(""<img src=\""file:///android_asset/emoticons/zero.gif\"" alt=\""zero\"" />"");
                            break;
                        case 0xE00C: //softbank pc
                            buff.append(""<img src=\""file:///android_asset/emoticons/pc.gif\"" alt=\""pc\"" />"");
                            break;
                        case 0xE210: //softbank sharp
                            buff.append(""<img src=\""file:///android_asset/emoticons/sharp.gif\"" alt=\""sharp\"" />"");
                            break;
                        case 0xE015: //softbank tennis
                            buff.append(""<img src=\""file:///android_asset/emoticons/tennis.gif\"" alt=\""tennis\"" />"");
                            break;
                        case 0xE038: //softbank building
                            buff.append(""<img src=\""file:///android_asset/emoticons/building.gif\"" alt=\""building\"" />"");
                            break;
                        case 0xE02D: //softbank clock
                            buff.append(""<img src=\""file:///android_asset/emoticons/clock.gif\"" alt=\""clock\"" />"");
                            break;
                        case 0xE334: //softbank annoy
                            buff.append(""<img src=\""file:///android_asset/emoticons/annoy.gif\"" alt=\""annoy\"" />"");
                            break;
                        case 0xE153: //softbank postoffice
                            buff.append(""<img src=\""file:///android_asset/emoticons/postoffice.gif\"" alt=\""postoffice\"" />"");
                            break;
                        case 0xE222: //softbank seven
                            buff.append(""<img src=\""file:///android_asset/emoticons/seven.gif\"" alt=\""seven\"" />"");
                            break;
                        case 0xE12F: //softbank dollar
                            buff.append(""<img src=\""file:///android_asset/emoticons/dollar.gif\"" alt=\""dollar\"" />"");
                            break;
                        case 0xE00A: //softbank mobilephone
                            buff.append(""<img src=\""file:///android_asset/emoticons/mobilephone.gif\"" alt=\""mobilephone\"" />"");
                            break;
                        case 0xE158: //softbank hotel
                            buff.append(""<img src=\""file:///android_asset/emoticons/hotel.gif\"" alt=\""hotel\"" />"");
                            break;
                        case 0xE249: //softbank aquarius
                            buff.append(""<img src=\""file:///android_asset/emoticons/aquarius.gif\"" alt=\""aquarius\"" />"");
                            break;
                        case 0xE036: //softbank house
                            buff.append(""<img src=\""file:///android_asset/emoticons/house.gif\"" alt=\""house\"" />"");
                            break;
                        case 0xE046: //softbank cake
                            buff.append(""<img src=\""file:///android_asset/emoticons/cake.gif\"" alt=\""cake\"" />"");
                            break;
                        case 0xE104: //softbank phoneto
                            buff.append(""<img src=\""file:///android_asset/emoticons/phoneto.gif\"" alt=\""phoneto\"" />"");
                            break;
                        case 0xE44B: //softbank night
                            buff.append(""<img src=\""file:///android_asset/emoticons/night.gif\"" alt=\""night\"" />"");
                            break;
                        case 0xE313: //softbank hairsalon
                            buff.append(""<img src=\""file:///android_asset/emoticons/hairsalon.gif\"" alt=\""hairsalon\"" />"");
                            break;
                            // These emoji codepoints are generated by tools/make_emoji in the K-9 source tree
                            // The spaces between the < and the img are a hack to avoid triggering
                            // K-9's 'load images' button

                        case 0xE488: //kddi sun
                            buff.append(""<img src=\""file:///android_asset/emoticons/sun.gif\"" alt=\""sun\"" />"");
                            break;
                        case 0xEA88: //kddi id
                            buff.append(""<img src=\""file:///android_asset/emoticons/id.gif\"" alt=\""id\"" />"");
                            break;
                        case 0xE4BA: //kddi baseball
                            buff.append(""<img src=\""file:///android_asset/emoticons/baseball.gif\"" alt=\""baseball\"" />"");
                            break;
                        case 0xE525: //kddi four
                            buff.append(""<img src=\""file:///android_asset/emoticons/four.gif\"" alt=\""four\"" />"");
                            break;
                        case 0xE578: //kddi free
                            buff.append(""<img src=\""file:///android_asset/emoticons/free.gif\"" alt=\""free\"" />"");
                            break;
                        case 0xE4C1: //kddi wine
                            buff.append(""<img src=\""file:///android_asset/emoticons/wine.gif\"" alt=\""wine\"" />"");
                            break;
                        case 0xE512: //kddi bell
                            buff.append(""<img src=\""file:///android_asset/emoticons/bell.gif\"" alt=\""bell\"" />"");
                            break;
                        case 0xEB83: //kddi rock
                            buff.append(""<img src=\""file:///android_asset/emoticons/rock.gif\"" alt=\""rock\"" />"");
                            break;
                        case 0xE4D0: //kddi cake
                            buff.append(""<img src=\""file:///android_asset/emoticons/cake.gif\"" alt=\""cake\"" />"");
                            break;
                        case 0xE473: //kddi crying
                            buff.append(""<img src=\""file:///android_asset/emoticons/crying.gif\"" alt=\""crying\"" />"");
                            break;
                        case 0xE48C: //kddi rain
                            buff.append(""<img src=\""file:///android_asset/emoticons/rain.gif\"" alt=\""rain\"" />"");
                            break;
                        case 0xEAC2: //kddi bearing
                            buff.append(""<img src=\""file:///android_asset/emoticons/bearing.gif\"" alt=\""bearing\"" />"");
                            break;
                        case 0xE47E: //kddi nosmoking
                            buff.append(""<img src=\""file:///android_asset/emoticons/nosmoking.gif\"" alt=\""nosmoking\"" />"");
                            break;
                        case 0xEAC0: //kddi despair
                            buff.append(""<img src=\""file:///android_asset/emoticons/despair.gif\"" alt=\""despair\"" />"");
                            break;
                        case 0xE559: //kddi r-mark
                            buff.append(""<img src=\""file:///android_asset/emoticons/r-mark.gif\"" alt=\""r-mark\"" />"");
                            break;
                        case 0xEB2D: //kddi up
                            buff.append(""<img src=\""file:///android_asset/emoticons/up.gif\"" alt=\""up\"" />"");
                            break;
                        case 0xEA89: //kddi full
                            buff.append(""<img src=\""file:///android_asset/emoticons/full.gif\"" alt=\""full\"" />"");
                            break;
                        case 0xEAC9: //kddi gawk
                            buff.append(""<img src=\""file:///android_asset/emoticons/gawk.gif\"" alt=\""gawk\"" />"");
                            break;
                        case 0xEB79: //kddi recycle
                            buff.append(""<img src=\""file:///android_asset/emoticons/recycle.gif\"" alt=\""recycle\"" />"");
                            break;
                        case 0xE5AC: //kddi zero
                            buff.append(""<img src=\""file:///android_asset/emoticons/zero.gif\"" alt=\""zero\"" />"");
                            break;
                        case 0xEAAE: //kddi japanesetea
                            buff.append(""<img src=\""file:///android_asset/emoticons/japanesetea.gif\"" alt=\""japanesetea\"" />"");
                            break;
                        case 0xEB30: //kddi sign03
                            buff.append(""<img src=\""file:///android_asset/emoticons/sign03.gif\"" alt=\""sign03\"" />"");
                            break;
                        case 0xE4B6: //kddi soccer
                            buff.append(""<img src=\""file:///android_asset/emoticons/soccer.gif\"" alt=\""soccer\"" />"");
                            break;
                        case 0xE556: //kddi downwardleft
                            buff.append(""<img src=\""file:///android_asset/emoticons/downwardleft.gif\"" alt=\""downwardleft\"" />"");
                            break;
                        case 0xE4BE: //kddi slate
                            buff.append(""<img src=\""file:///android_asset/emoticons/slate.gif\"" alt=\""slate\"" />"");
                            break;
                        case 0xE4A5: //kddi toilet
                            buff.append(""<img src=\""file:///android_asset/emoticons/toilet.gif\"" alt=\""toilet\"" />"");
                            break;
                            // Skipping kddi codepoint E523 two
                            // It conflicts with an earlier definition from another carrier:
                            // softbank chick

                        case 0xE496: //kddi scorpius
                            buff.append(""<img src=\""file:///android_asset/emoticons/scorpius.gif\"" alt=\""scorpius\"" />"");
                            break;
                        case 0xE4C6: //kddi game
                            buff.append(""<img src=\""file:///android_asset/emoticons/game.gif\"" alt=\""game\"" />"");
                            break;
                        case 0xE5A0: //kddi birthday
                            buff.append(""<img src=\""file:///android_asset/emoticons/birthday.gif\"" alt=\""birthday\"" />"");
                            break;
                        case 0xE5B8: //kddi pc
                            buff.append(""<img src=\""file:///android_asset/emoticons/pc.gif\"" alt=\""pc\"" />"");
                            break;
                        case 0xE516: //kddi hairsalon
                            buff.append(""<img src=\""file:///android_asset/emoticons/hairsalon.gif\"" alt=\""hairsalon\"" />"");
                            break;
                        case 0xE475: //kddi sleepy
                            buff.append(""<img src=\""file:///android_asset/emoticons/sleepy.gif\"" alt=\""sleepy\"" />"");
                            break;
                        case 0xE4A3: //kddi atm
                            buff.append(""<img src=\""file:///android_asset/emoticons/atm.gif\"" alt=\""atm\"" />"");
                            break;
                        case 0xE59A: //kddi basketball
                            buff.append(""<img src=\""file:///android_asset/emoticons/basketball.gif\"" alt=\""basketball\"" />"");
                            break;
                        case 0xE497: //kddi sagittarius
                            buff.append(""<img src=\""file:///android_asset/emoticons/sagittarius.gif\"" alt=\""sagittarius\"" />"");
                            break;
                        case 0xEACD: //kddi delicious
                            buff.append(""<img src=\""file:///android_asset/emoticons/delicious.gif\"" alt=\""delicious\"" />"");
                            break;
                        case 0xE5A8: //kddi newmoon
                            buff.append(""<img src=\""file:///android_asset/emoticons/newmoon.gif\"" alt=\""newmoon\"" />"");
                            break;
                        case 0xE49E: //kddi ticket
                            buff.append(""<img src=\""file:///android_asset/emoticons/ticket.gif\"" alt=\""ticket\"" />"");
                            break;
                        case 0xE5AE: //kddi wobbly
                            buff.append(""<img src=\""file:///android_asset/emoticons/wobbly.gif\"" alt=\""wobbly\"" />"");
                            break;
                        case 0xE4E6: //kddi sweat02
                            buff.append(""<img src=\""file:///android_asset/emoticons/sweat02.gif\"" alt=\""sweat02\"" />"");
                            break;
                        case 0xE59E: //kddi event
                            buff.append(""<img src=\""file:///android_asset/emoticons/event.gif\"" alt=\""event\"" />"");
                            break;
                        case 0xE4AB: //kddi house
                            buff.append(""<img src=\""file:///android_asset/emoticons/house.gif\"" alt=\""house\"" />"");
                            break;
                        case 0xE491: //kddi gemini
                            buff.append(""<img src=\""file:///android_asset/emoticons/gemini.gif\"" alt=\""gemini\"" />"");
                            break;
                        case 0xE4C9: //kddi xmas
                            buff.append(""<img src=\""file:///android_asset/emoticons/xmas.gif\"" alt=\""xmas\"" />"");
                            break;
                        case 0xE5BE: //kddi note
                            buff.append(""<img src=\""file:///android_asset/emoticons/note.gif\"" alt=\""note\"" />"");
                            break;
                        case 0xEB2F: //kddi sign02
                            buff.append(""<img src=\""file:///android_asset/emoticons/sign02.gif\"" alt=\""sign02\"" />"");
                            break;
                        case 0xE508: //kddi music
                            buff.append(""<img src=\""file:///android_asset/emoticons/music.gif\"" alt=\""music\"" />"");
                            break;
                        case 0xE5DF: //kddi hospital
                            buff.append(""<img src=\""file:///android_asset/emoticons/hospital.gif\"" alt=\""hospital\"" />"");
                            break;
                        case 0xE5BC: //kddi subway
                            buff.append(""<img src=\""file:///android_asset/emoticons/subway.gif\"" alt=\""subway\"" />"");
                            break;
                        case 0xE5C9: //kddi crown
                            buff.append(""<img src=\""file:///android_asset/emoticons/crown.gif\"" alt=\""crown\"" />"");
                            break;
                        case 0xE4BC: //kddi spa
                            buff.append(""<img src=\""file:///android_asset/emoticons/spa.gif\"" alt=\""spa\"" />"");
                            break;
                        case 0xE514: //kddi ring
                            buff.append(""<img src=\""file:///android_asset/emoticons/ring.gif\"" alt=\""ring\"" />"");
                            break;
                            // Skipping kddi codepoint E502 tv
                            // It conflicts with an earlier definition from another carrier:
                            // softbank art

                        case 0xE4AC: //kddi restaurant
                            buff.append(""<img src=\""file:///android_asset/emoticons/restaurant.gif\"" alt=\""restaurant\"" />"");
                            break;
                        case 0xE529: //kddi eight
                            buff.append(""<img src=\""file:///android_asset/emoticons/eight.gif\"" alt=\""eight\"" />"");
                            break;
                        case 0xE518: //kddi search
                            buff.append(""<img src=\""file:///android_asset/emoticons/search.gif\"" alt=\""search\"" />"");
                            break;
                        case 0xE505: //kddi notes
                            buff.append(""<img src=\""file:///android_asset/emoticons/notes.gif\"" alt=\""notes\"" />"");
                            break;
                        case 0xE498: //kddi capricornus
                            buff.append(""<img src=\""file:///android_asset/emoticons/capricornus.gif\"" alt=\""capricornus\"" />"");
                            break;
                        case 0xEB7E: //kddi snail
                            buff.append(""<img src=\""file:///android_asset/emoticons/snail.gif\"" alt=\""snail\"" />"");
                            break;
                        case 0xEA97: //kddi bottle
                            buff.append(""<img src=\""file:///android_asset/emoticons/bottle.gif\"" alt=\""bottle\"" />"");
                            break;
                        case 0xEB08: //kddi phoneto
                            buff.append(""<img src=\""file:///android_asset/emoticons/phoneto.gif\"" alt=\""phoneto\"" />"");
                            break;
                        case 0xE4D2: //kddi cherry
                            buff.append(""<img src=\""file:///android_asset/emoticons/cherry.gif\"" alt=\""cherry\"" />"");
                            break;
                        case 0xE54D: //kddi downwardright
                            buff.append(""<img src=\""file:///android_asset/emoticons/downwardright.gif\"" alt=\""downwardright\"" />"");
                            break;
                        case 0xE5C3: //kddi wink
                            buff.append(""<img src=\""file:///android_asset/emoticons/wink.gif\"" alt=\""wink\"" />"");
                            break;
                        case 0xEAAC: //kddi ski
                            buff.append(""<img src=\""file:///android_asset/emoticons/ski.gif\"" alt=\""ski\"" />"");
                            break;
                        case 0xE515: //kddi camera
                            buff.append(""<img src=\""file:///android_asset/emoticons/camera.gif\"" alt=\""camera\"" />"");
                            break;
                        case 0xE5B6: //kddi t-shirt
                            buff.append(""<img src=\""file:///android_asset/emoticons/t-shirt.gif\"" alt=\""t-shirt\"" />"");
                            break;
                        case 0xE5C4: //kddi lovely
                            buff.append(""<img src=\""file:///android_asset/emoticons/lovely.gif\"" alt=\""lovely\"" />"");
                            break;
                        case 0xE4AD: //kddi building
                            buff.append(""<img src=\""file:///android_asset/emoticons/building.gif\"" alt=\""building\"" />"");
                            break;
                        case 0xE4CE: //kddi maple
                            buff.append(""<img src=\""file:///android_asset/emoticons/maple.gif\"" alt=\""maple\"" />"");
                            break;
                        case 0xE5AA: //kddi moon2
                            buff.append(""<img src=\""file:///android_asset/emoticons/moon2.gif\"" alt=\""moon2\"" />"");
                            break;
                        case 0xE5B4: //kddi noodle
                            buff.append(""<img src=\""file:///android_asset/emoticons/noodle.gif\"" alt=\""noodle\"" />"");
                            break;
                        case 0xE5A6: //kddi scissors
                            buff.append(""<img src=\""file:///android_asset/emoticons/scissors.gif\"" alt=\""scissors\"" />"");
                            break;
                        case 0xE4AA: //kddi bank
                            buff.append(""<img src=\""file:///android_asset/emoticons/bank.gif\"" alt=\""bank\"" />"");
                            break;
                        case 0xE4B5: //kddi train
                            buff.append(""<img src=\""file:///android_asset/emoticons/train.gif\"" alt=\""train\"" />"");
                            break;
                        case 0xE477: //kddi heart03
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart03.gif\"" alt=\""heart03\"" />"");
                            break;
                        case 0xE481: //kddi danger
                            buff.append(""<img src=\""file:///android_asset/emoticons/danger.gif\"" alt=\""danger\"" />"");
                            break;
                        case 0xE597: //kddi cafe
                            buff.append(""<img src=\""file:///android_asset/emoticons/cafe.gif\"" alt=\""cafe\"" />"");
                            break;
                        case 0xEB2B: //kddi shoe
                            buff.append(""<img src=\""file:///android_asset/emoticons/shoe.gif\"" alt=\""shoe\"" />"");
                            break;
                        case 0xEB7C: //kddi wave
                            buff.append(""<img src=\""file:///android_asset/emoticons/wave.gif\"" alt=\""wave\"" />"");
                            break;
                        case 0xE471: //kddi happy01
                            buff.append(""<img src=\""file:///android_asset/emoticons/happy01.gif\"" alt=\""happy01\"" />"");
                            break;
                        case 0xE4CA: //kddi cherryblossom
                            buff.append(""<img src=\""file:///android_asset/emoticons/cherryblossom.gif\"" alt=\""cherryblossom\"" />"");
                            break;
                        case 0xE4D5: //kddi riceball
                            buff.append(""<img src=\""file:///android_asset/emoticons/riceball.gif\"" alt=\""riceball\"" />"");
                            break;
                        case 0xE587: //kddi wrench
                            buff.append(""<img src=\""file:///android_asset/emoticons/wrench.gif\"" alt=\""wrench\"" />"");
                            break;
                        case 0xEB2A: //kddi foot
                            buff.append(""<img src=\""file:///android_asset/emoticons/foot.gif\"" alt=\""foot\"" />"");
                            break;
                        case 0xE47D: //kddi smoking
                            buff.append(""<img src=\""file:///android_asset/emoticons/smoking.gif\"" alt=\""smoking\"" />"");
                            break;
                        case 0xE4DC: //kddi penguin
                            buff.append(""<img src=\""file:///android_asset/emoticons/penguin.gif\"" alt=\""penguin\"" />"");
                            break;
                        case 0xE4B3: //kddi airplane
                            buff.append(""<img src=\""file:///android_asset/emoticons/airplane.gif\"" alt=\""airplane\"" />"");
                            break;
                        case 0xE4DE: //kddi pig
                            buff.append(""<img src=\""file:///android_asset/emoticons/pig.gif\"" alt=\""pig\"" />"");
                            break;
                        case 0xE59B: //kddi pocketbell
                            buff.append(""<img src=\""file:///android_asset/emoticons/pocketbell.gif\"" alt=\""pocketbell\"" />"");
                            break;
                        case 0xE4AF: //kddi bus
                            buff.append(""<img src=\""file:///android_asset/emoticons/bus.gif\"" alt=\""bus\"" />"");
                            break;
                        case 0xE4A6: //kddi parking
                            buff.append(""<img src=\""file:///android_asset/emoticons/parking.gif\"" alt=\""parking\"" />"");
                            break;
                        case 0xE486: //kddi moon3
                            buff.append(""<img src=\""file:///android_asset/emoticons/moon3.gif\"" alt=\""moon3\"" />"");
                            break;
                        case 0xE5A4: //kddi eye
                            buff.append(""<img src=\""file:///android_asset/emoticons/eye.gif\"" alt=\""eye\"" />"");
                            break;
                        case 0xE50C: //kddi cd
                            buff.append(""<img src=\""file:///android_asset/emoticons/cd.gif\"" alt=\""cd\"" />"");
                            break;
                        case 0xE54C: //kddi upwardleft
                            buff.append(""<img src=\""file:///android_asset/emoticons/upwardleft.gif\"" alt=\""upwardleft\"" />"");
                            break;
                        case 0xEA82: //kddi ship
                            buff.append(""<img src=\""file:///android_asset/emoticons/ship.gif\"" alt=\""ship\"" />"");
                            break;
                        case 0xE4B1: //kddi car
                            buff.append(""<img src=\""file:///android_asset/emoticons/car.gif\"" alt=\""car\"" />"");
                            break;
                        case 0xEB80: //kddi smile
                            buff.append(""<img src=\""file:///android_asset/emoticons/smile.gif\"" alt=\""smile\"" />"");
                            break;
                        case 0xE5B0: //kddi impact
                            buff.append(""<img src=\""file:///android_asset/emoticons/impact.gif\"" alt=\""impact\"" />"");
                            break;
                        case 0xE504: //kddi moneybag
                            buff.append(""<img src=\""file:///android_asset/emoticons/moneybag.gif\"" alt=\""moneybag\"" />"");
                            break;
                        case 0xE4B9: //kddi motorsports
                            buff.append(""<img src=\""file:///android_asset/emoticons/motorsports.gif\"" alt=\""motorsports\"" />"");
                            break;
                        case 0xE494: //kddi virgo
                            buff.append(""<img src=\""file:///android_asset/emoticons/virgo.gif\"" alt=\""virgo\"" />"");
                            break;
                        case 0xE595: //kddi heart01
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart01.gif\"" alt=\""heart01\"" />"");
                            break;
                        case 0xEB03: //kddi pen
                            buff.append(""<img src=\""file:///android_asset/emoticons/pen.gif\"" alt=\""pen\"" />"");
                            break;
                        case 0xE57D: //kddi yen
                            buff.append(""<img src=\""file:///android_asset/emoticons/yen.gif\"" alt=\""yen\"" />"");
                            break;
                        case 0xE598: //kddi mist
                            buff.append(""<img src=\""file:///android_asset/emoticons/mist.gif\"" alt=\""mist\"" />"");
                            break;
                        case 0xE5A2: //kddi diamond
                            buff.append(""<img src=\""file:///android_asset/emoticons/diamond.gif\"" alt=\""diamond\"" />"");
                            break;
                        case 0xE4A4: //kddi 24hours
                            buff.append(""<img src=\""file:///android_asset/emoticons/24hours.gif\"" alt=\""24hours\"" />"");
                            break;
                        case 0xE524: //kddi three
                            buff.append(""<img src=\""file:///android_asset/emoticons/three.gif\"" alt=\""three\"" />"");
                            break;
                        case 0xEB7B: //kddi updown
                            buff.append(""<img src=\""file:///android_asset/emoticons/updown.gif\"" alt=\""updown\"" />"");
                            break;
                        case 0xE5A1: //kddi spade
                            buff.append(""<img src=\""file:///android_asset/emoticons/spade.gif\"" alt=\""spade\"" />"");
                            break;
                        case 0xE495: //kddi libra
                            buff.append(""<img src=\""file:///android_asset/emoticons/libra.gif\"" alt=\""libra\"" />"");
                            break;
                        case 0xE588: //kddi mobilephone
                            buff.append(""<img src=\""file:///android_asset/emoticons/mobilephone.gif\"" alt=\""mobilephone\"" />"");
                            break;
                        case 0xE599: //kddi golf
                            buff.append(""<img src=\""file:///android_asset/emoticons/golf.gif\"" alt=\""golf\"" />"");
                            break;
                        case 0xE520: //kddi faxto
                            buff.append(""<img src=\""file:///android_asset/emoticons/faxto.gif\"" alt=\""faxto\"" />"");
                            break;
                            // Skipping kddi codepoint E503 karaoke
                            // It conflicts with an earlier definition from another carrier:
                            // softbank drama

                        case 0xE4D6: //kddi fastfood
                            buff.append(""<img src=\""file:///android_asset/emoticons/fastfood.gif\"" alt=\""fastfood\"" />"");
                            break;
                        case 0xE4A1: //kddi pencil
                            buff.append(""<img src=\""file:///android_asset/emoticons/pencil.gif\"" alt=\""pencil\"" />"");
                            break;
                        case 0xE522: //kddi one
                            buff.append(""<img src=\""file:///android_asset/emoticons/one.gif\"" alt=\""one\"" />"");
                            break;
                        case 0xEB84: //kddi sharp
                            buff.append(""<img src=\""file:///android_asset/emoticons/sharp.gif\"" alt=\""sharp\"" />"");
                            break;
                        case 0xE476: //kddi flair
                            buff.append(""<img src=\""file:///android_asset/emoticons/flair.gif\"" alt=\""flair\"" />"");
                            break;
                        case 0xE46B: //kddi run
                            buff.append(""<img src=\""file:///android_asset/emoticons/run.gif\"" alt=\""run\"" />"");
                            break;
                        case 0xEAF5: //kddi drama
                            buff.append(""<img src=\""file:///android_asset/emoticons/drama.gif\"" alt=\""drama\"" />"");
                            break;
                        case 0xEAB9: //kddi apple
                            buff.append(""<img src=\""file:///android_asset/emoticons/apple.gif\"" alt=\""apple\"" />"");
                            break;
                        case 0xE4EB: //kddi kissmark
                            buff.append(""<img src=\""file:///android_asset/emoticons/kissmark.gif\"" alt=\""kissmark\"" />"");
                            break;
                        case 0xE55D: //kddi enter
                            buff.append(""<img src=\""file:///android_asset/emoticons/enter.gif\"" alt=\""enter\"" />"");
                            break;
                        case 0xE59F: //kddi ribbon
                            buff.append(""<img src=\""file:///android_asset/emoticons/ribbon.gif\"" alt=\""ribbon\"" />"");
                            break;
                        case 0xE526: //kddi five
                            buff.append(""<img src=\""file:///android_asset/emoticons/five.gif\"" alt=\""five\"" />"");
                            break;
                        case 0xE571: //kddi gasstation
                            buff.append(""<img src=\""file:///android_asset/emoticons/gasstation.gif\"" alt=\""gasstation\"" />"");
                            break;
                        case 0xE517: //kddi movie
                            buff.append(""<img src=\""file:///android_asset/emoticons/movie.gif\"" alt=\""movie\"" />"");
                            break;
                        case 0xE4B8: //kddi snowboard
                            buff.append(""<img src=\""file:///android_asset/emoticons/snowboard.gif\"" alt=\""snowboard\"" />"");
                            break;
                        case 0xEAE8: //kddi sprinkle
                            buff.append(""<img src=\""file:///android_asset/emoticons/sprinkle.gif\"" alt=\""sprinkle\"" />"");
                            break;
                        case 0xEA80: //kddi school
                            buff.append(""<img src=\""file:///android_asset/emoticons/school.gif\"" alt=\""school\"" />"");
                            break;
                        case 0xE47C: //kddi sandclock
                            buff.append(""<img src=\""file:///android_asset/emoticons/sandclock.gif\"" alt=\""sandclock\"" />"");
                            break;
                        case 0xEB31: //kddi sign05
                            buff.append(""<img src=\""file:///android_asset/emoticons/sign05.gif\"" alt=\""sign05\"" />"");
                            break;
                        case 0xE5AB: //kddi clear
                            buff.append(""<img src=\""file:///android_asset/emoticons/clear.gif\"" alt=\""clear\"" />"");
                            break;
                        case 0xE5DE: //kddi postoffice
                            buff.append(""<img src=\""file:///android_asset/emoticons/postoffice.gif\"" alt=\""postoffice\"" />"");
                            break;
                        case 0xEB62: //kddi mailto
                            buff.append(""<img src=\""file:///android_asset/emoticons/mailto.gif\"" alt=\""mailto\"" />"");
                            break;
                        case 0xE528: //kddi seven
                            buff.append(""<img src=\""file:///android_asset/emoticons/seven.gif\"" alt=\""seven\"" />"");
                            break;
                        case 0xE4C2: //kddi bar
                            buff.append(""<img src=\""file:///android_asset/emoticons/bar.gif\"" alt=\""bar\"" />"");
                            break;
                        case 0xE487: //kddi thunder
                            buff.append(""<img src=\""file:///android_asset/emoticons/thunder.gif\"" alt=\""thunder\"" />"");
                            break;
                        case 0xE5A9: //kddi moon1
                            buff.append(""<img src=\""file:///android_asset/emoticons/moon1.gif\"" alt=\""moon1\"" />"");
                            break;
                        case 0xEB7A: //kddi leftright
                            buff.append(""<img src=\""file:///android_asset/emoticons/leftright.gif\"" alt=\""leftright\"" />"");
                            break;
                        case 0xE513: //kddi clover
                            buff.append(""<img src=\""file:///android_asset/emoticons/clover.gif\"" alt=\""clover\"" />"");
                            break;
                        case 0xE492: //kddi cancer
                            buff.append(""<img src=\""file:///android_asset/emoticons/cancer.gif\"" alt=\""cancer\"" />"");
                            break;
                        case 0xEB78: //kddi loveletter
                            buff.append(""<img src=\""file:///android_asset/emoticons/loveletter.gif\"" alt=\""loveletter\"" />"");
                            break;
                        case 0xE4E0: //kddi chick
                            buff.append(""<img src=\""file:///android_asset/emoticons/chick.gif\"" alt=\""chick\"" />"");
                            break;
                        case 0xE4CF: //kddi present
                            buff.append(""<img src=\""file:///android_asset/emoticons/present.gif\"" alt=\""present\"" />"");
                            break;
                        case 0xE478: //kddi heart04
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart04.gif\"" alt=\""heart04\"" />"");
                            break;
                        case 0xEAC3: //kddi sad
                            buff.append(""<img src=\""file:///android_asset/emoticons/sad.gif\"" alt=\""sad\"" />"");
                            break;
                        case 0xE52A: //kddi nine
                            buff.append(""<img src=\""file:///android_asset/emoticons/nine.gif\"" alt=\""nine\"" />"");
                            break;
                        case 0xE482: //kddi sign01
                            buff.append(""<img src=\""file:///android_asset/emoticons/sign01.gif\"" alt=\""sign01\"" />"");
                            break;
                        case 0xEABF: //kddi catface
                            buff.append(""<img src=\""file:///android_asset/emoticons/catface.gif\"" alt=\""catface\"" />"");
                            break;
                        case 0xE527: //kddi six
                            buff.append(""<img src=\""file:///android_asset/emoticons/six.gif\"" alt=\""six\"" />"");
                            break;
                        case 0xE52C: //kddi mobaq
                            buff.append(""<img src=\""file:///android_asset/emoticons/mobaq.gif\"" alt=\""mobaq\"" />"");
                            break;
                        case 0xE485: //kddi snow
                            buff.append(""<img src=\""file:///android_asset/emoticons/snow.gif\"" alt=\""snow\"" />"");
                            break;
                        case 0xE4B7: //kddi tennis
                            buff.append(""<img src=\""file:///android_asset/emoticons/tennis.gif\"" alt=\""tennis\"" />"");
                            break;
                        case 0xE5BD: //kddi fuji
                            buff.append(""<img src=\""file:///android_asset/emoticons/fuji.gif\"" alt=\""fuji\"" />"");
                            break;
                        case 0xE558: //kddi copyright
                            buff.append(""<img src=\""file:///android_asset/emoticons/copyright.gif\"" alt=\""copyright\"" />"");
                            break;
                        case 0xE4D8: //kddi horse
                            buff.append(""<img src=\""file:///android_asset/emoticons/horse.gif\"" alt=\""horse\"" />"");
                            break;
                        case 0xE4B0: //kddi bullettrain
                            buff.append(""<img src=\""file:///android_asset/emoticons/bullettrain.gif\"" alt=\""bullettrain\"" />"");
                            break;
                        case 0xE596: //kddi telephone
                            buff.append(""<img src=\""file:///android_asset/emoticons/telephone.gif\"" alt=\""telephone\"" />"");
                            break;
                        case 0xE48F: //kddi aries
                            buff.append(""<img src=\""file:///android_asset/emoticons/aries.gif\"" alt=\""aries\"" />"");
                            break;
                        case 0xE46A: //kddi signaler
                            buff.append(""<img src=\""file:///android_asset/emoticons/signaler.gif\"" alt=\""signaler\"" />"");
                            break;
                        case 0xE472: //kddi angry
                            buff.append(""<img src=\""file:///android_asset/emoticons/angry.gif\"" alt=\""angry\"" />"");
                            break;
                        case 0xE54E: //kddi tm
                            buff.append(""<img src=\""file:///android_asset/emoticons/tm.gif\"" alt=\""tm\"" />"");
                            break;
                        case 0xE51A: //kddi boutique
                            buff.append(""<img src=\""file:///android_asset/emoticons/boutique.gif\"" alt=\""boutique\"" />"");
                            break;
                        case 0xE493: //kddi leo
                            buff.append(""<img src=\""file:///android_asset/emoticons/leo.gif\"" alt=\""leo\"" />"");
                            break;
                        case 0xE5A3: //kddi club
                            buff.append(""<img src=\""file:///android_asset/emoticons/club.gif\"" alt=\""club\"" />"");
                            break;
                        case 0xE499: //kddi aquarius
                            buff.append(""<img src=\""file:///android_asset/emoticons/aquarius.gif\"" alt=\""aquarius\"" />"");
                            break;
                        case 0xE4AE: //kddi bicycle
                            buff.append(""<img src=\""file:///android_asset/emoticons/bicycle.gif\"" alt=\""bicycle\"" />"");
                            break;
                        case 0xE4E7: //kddi bleah
                            buff.append(""<img src=\""file:///android_asset/emoticons/bleah.gif\"" alt=\""bleah\"" />"");
                            break;
                        case 0xE49F: //kddi book
                            buff.append(""<img src=\""file:///android_asset/emoticons/book.gif\"" alt=\""book\"" />"");
                            break;
                        case 0xE5AD: //kddi ok
                            buff.append(""<img src=\""file:///android_asset/emoticons/ok.gif\"" alt=\""ok\"" />"");
                            break;
                        case 0xE5A7: //kddi paper
                            buff.append(""<img src=\""file:///android_asset/emoticons/paper.gif\"" alt=\""paper\"" />"");
                            break;
                        case 0xE4E5: //kddi annoy
                            buff.append(""<img src=\""file:///android_asset/emoticons/annoy.gif\"" alt=\""annoy\"" />"");
                            break;
                        case 0xE4A0: //kddi clip
                            buff.append(""<img src=\""file:///android_asset/emoticons/clip.gif\"" alt=\""clip\"" />"");
                            break;
                        case 0xE509: //kddi rouge
                            buff.append(""<img src=\""file:///android_asset/emoticons/rouge.gif\"" alt=\""rouge\"" />"");
                            break;
                        case 0xEAAF: //kddi bread
                            buff.append(""<img src=\""file:///android_asset/emoticons/bread.gif\"" alt=\""bread\"" />"");
                            break;
                        case 0xE519: //kddi key
                            buff.append(""<img src=\""file:///android_asset/emoticons/key.gif\"" alt=\""key\"" />"");
                            break;
                        case 0xE594: //kddi clock
                            buff.append(""<img src=\""file:///android_asset/emoticons/clock.gif\"" alt=\""clock\"" />"");
                            break;
                        case 0xEB7D: //kddi bud
                            buff.append(""<img src=\""file:///android_asset/emoticons/bud.gif\"" alt=\""bud\"" />"");
                            break;
                        case 0xEA8A: //kddi empty
                            buff.append(""<img src=\""file:///android_asset/emoticons/empty.gif\"" alt=\""empty\"" />"");
                            break;
                        case 0xE5B5: //kddi new
                            buff.append(""<img src=\""file:///android_asset/emoticons/new.gif\"" alt=\""new\"" />"");
                            break;
                        case 0xE47A: //kddi bomb
                            buff.append(""<img src=\""file:///android_asset/emoticons/bomb.gif\"" alt=\""bomb\"" />"");
                            break;
                        case 0xE5C6: //kddi coldsweats02
                            buff.append(""<img src=\""file:///android_asset/emoticons/coldsweats02.gif\"" alt=\""coldsweats02\"" />"");
                            break;
                        case 0xE49A: //kddi pisces
                            buff.append(""<img src=\""file:///android_asset/emoticons/pisces.gif\"" alt=\""pisces\"" />"");
                            break;
                        case 0xE4F3: //kddi punch
                            buff.append(""<img src=\""file:///android_asset/emoticons/punch.gif\"" alt=\""punch\"" />"");
                            break;
                        case 0xEB5D: //kddi pout
                            buff.append(""<img src=\""file:///android_asset/emoticons/pout.gif\"" alt=\""pout\"" />"");
                            break;
                        case 0xE469: //kddi typhoon
                            buff.append(""<img src=\""file:///android_asset/emoticons/typhoon.gif\"" alt=\""typhoon\"" />"");
                            break;
                        case 0xE5B1: //kddi sweat01
                            buff.append(""<img src=\""file:///android_asset/emoticons/sweat01.gif\"" alt=\""sweat01\"" />"");
                            break;
                        case 0xE4C7: //kddi dollar
                            buff.append(""<img src=\""file:///android_asset/emoticons/dollar.gif\"" alt=\""dollar\"" />"");
                            break;
                        case 0xE5C5: //kddi shock
                            buff.append(""<img src=\""file:///android_asset/emoticons/shock.gif\"" alt=\""shock\"" />"");
                            break;
                        case 0xE4F9: //kddi good
                            buff.append(""<img src=\""file:///android_asset/emoticons/good.gif\"" alt=\""good\"" />"");
                            break;
                        case 0xE4F1: //kddi secret
                            buff.append(""<img src=\""file:///android_asset/emoticons/secret.gif\"" alt=\""secret\"" />"");
                            break;
                        case 0xE4E4: //kddi tulip
                            buff.append(""<img src=\""file:///android_asset/emoticons/tulip.gif\"" alt=\""tulip\"" />"");
                            break;
                        case 0xEA81: //kddi hotel
                            buff.append(""<img src=\""file:///android_asset/emoticons/hotel.gif\"" alt=\""hotel\"" />"");
                            break;
                        case 0xE4FE: //kddi eyeglass
                            buff.append(""<img src=\""file:///android_asset/emoticons/eyeglass.gif\"" alt=\""eyeglass\"" />"");
                            break;
                        case 0xEAF1: //kddi night
                            buff.append(""<img src=\""file:///android_asset/emoticons/night.gif\"" alt=\""night\"" />"");
                            break;
                        case 0xE555: //kddi upwardright
                            buff.append(""<img src=\""file:///android_asset/emoticons/upwardright.gif\"" alt=\""upwardright\"" />"");
                            break;
                        case 0xEB2E: //kddi down
                            buff.append(""<img src=\""file:///android_asset/emoticons/down.gif\"" alt=\""down\"" />"");
                            break;
                        case 0xE4DB: //kddi cat
                            buff.append(""<img src=\""file:///android_asset/emoticons/cat.gif\"" alt=\""cat\"" />"");
                            break;
                        case 0xE59C: //kddi art
                            buff.append(""<img src=\""file:///android_asset/emoticons/art.gif\"" alt=\""art\"" />"");
                            break;
                        case 0xEB69: //kddi weep
                            buff.append(""<img src=\""file:///android_asset/emoticons/weep.gif\"" alt=\""weep\"" />"");
                            break;
                        case 0xE4F4: //kddi dash
                            buff.append(""<img src=\""file:///android_asset/emoticons/dash.gif\"" alt=\""dash\"" />"");
                            break;
                        case 0xE490: //kddi taurus
                            buff.append(""<img src=\""file:///android_asset/emoticons/taurus.gif\"" alt=\""taurus\"" />"");
                            break;
                        case 0xE57A: //kddi watch
                            buff.append(""<img src=\""file:///android_asset/emoticons/watch.gif\"" alt=\""watch\"" />"");
                            break;
                        case 0xEB2C: //kddi flag
                            buff.append(""<img src=\""file:///android_asset/emoticons/flag.gif\"" alt=\""flag\"" />"");
                            break;
                        case 0xEB77: //kddi denim
                            buff.append(""<img src=\""file:///android_asset/emoticons/denim.gif\"" alt=\""denim\"" />"");
                            break;
                        case 0xEAC5: //kddi confident
                            buff.append(""<img src=\""file:///android_asset/emoticons/confident.gif\"" alt=\""confident\"" />"");
                            break;
                        case 0xE4B4: //kddi yacht
                            buff.append(""<img src=\""file:///android_asset/emoticons/yacht.gif\"" alt=\""yacht\"" />"");
                            break;
                        case 0xE49C: //kddi bag
                            buff.append(""<img src=\""file:///android_asset/emoticons/bag.gif\"" alt=\""bag\"" />"");
                            break;
                        case 0xE5A5: //kddi ear
                            buff.append(""<img src=\""file:///android_asset/emoticons/ear.gif\"" alt=\""ear\"" />"");
                            break;
                        case 0xE4E1: //kddi dog
                            buff.append(""<img src=\""file:///android_asset/emoticons/dog.gif\"" alt=\""dog\"" />"");
                            break;
                        case 0xE521: //kddi mail
                            buff.append(""<img src=\""file:///android_asset/emoticons/mail.gif\"" alt=\""mail\"" />"");
                            break;
                        case 0xEB35: //kddi banana
                            buff.append(""<img src=\""file:///android_asset/emoticons/banana.gif\"" alt=\""banana\"" />"");
                            break;
                        case 0xEAA5: //kddi heart
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart.gif\"" alt=\""heart\"" />"");
                            break;
                        case 0xE47F: //kddi wheelchair
                            buff.append(""<img src=\""file:///android_asset/emoticons/wheelchair.gif\"" alt=\""wheelchair\"" />"");
                            break;
                        case 0xEB75: //kddi heart02
                            buff.append(""<img src=\""file:///android_asset/emoticons/heart02.gif\"" alt=\""heart02\"" />"");
                            break;
                        case 0xE48D: //kddi cloud
                            buff.append(""<img src=\""file:///android_asset/emoticons/cloud.gif\"" alt=\""cloud\"" />"");
                            break;
                        case 0xE4C3: //kddi beer
                            buff.append(""<img src=\""file:///android_asset/emoticons/beer.gif\"" alt=\""beer\"" />"");
                            break;
                        case 0xEAAB: //kddi shine
                            buff.append(""<img src=\""file:///android_asset/emoticons/shine.gif\"" alt=\""shine\"" />"");
                            break;
                        case 0xEA92: //kddi memo
                            buff.append(""<img src=\""file:///android_asset/emoticons/memo.gif\"" alt=\""memo\"" />"");
                            break;
                        default:
                            buff.append((char)c);
                    }//switch
                }
            }
            catch (IOException e)
            {
                //Should never happen
                Log.e(K9.LOG_TAG, null, e);
            }

            return buff.toString();
        }

        @Override
        public boolean isInTopGroup()
        {
            return inTopGroup;
        }

        public void setInTopGroup(boolean inTopGroup)
        {
            this.inTopGroup = inTopGroup;
        }
    }

    public class LocalTextBody extends TextBody
    {
        private String mBodyForDisplay;

        public LocalTextBody(String body)
        {
            super(body);
        }

        public LocalTextBody(String body, String bodyForDisplay) throws MessagingException
        {
            super(body);
            this.mBodyForDisplay = bodyForDisplay;
        }

        public String getBodyForDisplay()
        {
            return mBodyForDisplay;
        }

        public void setBodyForDisplay(String mBodyForDisplay)
        {
            this.mBodyForDisplay = mBodyForDisplay;
        }

    }//LocalTextBody

    public class LocalMessage extends MimeMessage
    {
        private long mId;
        private int mAttachmentCount;
        private String mSubject;

        private String mPreview = """";

        private boolean mHeadersLoaded = false;
        private boolean mMessageDirty = false;

        public LocalMessage()
        {
        }

        LocalMessage(String uid, Folder folder) throws MessagingException
        {
            this.mUid = uid;
            this.mFolder = folder;
        }

        private void populateFromGetMessageCursor(Cursor cursor)
        throws MessagingException
        {
            final String subject = cursor.getString(0);
            this.setSubject(subject == null ? """" : subject);

            Address[] from = Address.unpack(cursor.getString(1));
            if (from.length > 0)
            {
                this.setFrom(from[0]);
            }
            this.setInternalSentDate(new Date(cursor.getLong(2)));
            this.setUid(cursor.getString(3));
            String flagList = cursor.getString(4);
            if (flagList != null && flagList.length() > 0)
            {
                String[] flags = flagList.split("","");

                for (String flag : flags)
                {
                    try
                    {
                        this.setFlagInternal(Flag.valueOf(flag), true);
                    }

                    catch (Exception e)
                    {
                        if (!""X_BAD_FLAG"".equals(flag))
                        {
                            Log.w(K9.LOG_TAG, ""Unable to parse flag "" + flag);
                        }
                    }
                }
            }
            this.mId = cursor.getLong(5);
            this.setRecipients(RecipientType.TO, Address.unpack(cursor.getString(6)));
            this.setRecipients(RecipientType.CC, Address.unpack(cursor.getString(7)));
            this.setRecipients(RecipientType.BCC, Address.unpack(cursor.getString(8)));
            this.setReplyTo(Address.unpack(cursor.getString(9)));

            this.mAttachmentCount = cursor.getInt(10);
            this.setInternalDate(new Date(cursor.getLong(11)));
            this.setMessageId(cursor.getString(12));

            final String preview = cursor.getString(14);
            mPreview = (preview == null ? """" : preview);

            if (this.mFolder == null)
            {
                LocalFolder f = new LocalFolder(cursor.getInt(13));
                f.open(LocalFolder.OpenMode.READ_WRITE);
                this.mFolder = f;
            }
        }


        /* Custom version of writeTo that updates the MIME message based on localMessage
         * changes.
         */

        @Override
        public void writeTo(OutputStream out) throws IOException, MessagingException
        {
            if (mMessageDirty) buildMimeRepresentation();
            super.writeTo(out);
        }

        private void buildMimeRepresentation() throws MessagingException
        {
            if (!mMessageDirty)
            {
                return;
            }

            super.setSubject(mSubject);
            if (this.mFrom != null && this.mFrom.length > 0)
            {
                super.setFrom(this.mFrom[0]);
            }

            super.setReplyTo(mReplyTo);
            super.setSentDate(this.getSentDate());
            super.setRecipients(RecipientType.TO, mTo);
            super.setRecipients(RecipientType.CC, mCc);
            super.setRecipients(RecipientType.BCC, mBcc);
            if (mMessageId != null) super.setMessageId(mMessageId);

            mMessageDirty = false;
        }

        public String getPreview()
        {
            return mPreview;
        }

        @Override
        public String getSubject() throws MessagingException
        {
            return mSubject;
        }


        @Override
        public void setSubject(String subject) throws MessagingException
        {
            mSubject = subject;
            mMessageDirty = true;
        }


        @Override
        public void setMessageId(String messageId)
        {
            mMessageId = messageId;
            mMessageDirty = true;
        }



        public int getAttachmentCount()
        {
            return mAttachmentCount;
        }

        @Override
        public void setFrom(Address from) throws MessagingException
        {
            this.mFrom = new Address[] { from };
            mMessageDirty = true;
        }


        @Override
        public void setReplyTo(Address[] replyTo) throws MessagingException
        {
            if (replyTo == null || replyTo.length == 0)
            {
                mReplyTo = null;
            }
            else
            {
                mReplyTo = replyTo;
            }
            mMessageDirty = true;
        }


        /*
         * For performance reasons, we add headers instead of setting them (see super implementation)
         * which removes (expensive) them before adding them
         */
        @Override
        public void setRecipients(RecipientType type, Address[] addresses) throws MessagingException
        {
            if (type == RecipientType.TO)
            {
                if (addresses == null || addresses.length == 0)
                {
                    this.mTo = null;
                }
                else
                {
                    this.mTo = addresses;
                }
            }
            else if (type == RecipientType.CC)
            {
                if (addresses == null || addresses.length == 0)
                {
                    this.mCc = null;
                }
                else
                {
                    this.mCc = addresses;
                }
            }
            else if (type == RecipientType.BCC)
            {
                if (addresses == null || addresses.length == 0)
                {
                    this.mBcc = null;
                }
                else
                {
                    this.mBcc = addresses;
                }
            }
            else
            {
                throw new MessagingException(""Unrecognized recipient type."");
            }
            mMessageDirty = true;
        }



        public void setFlagInternal(Flag flag, boolean set) throws MessagingException
        {
            super.setFlag(flag, set);
        }

        public long getId()
        {
            return mId;
        }

        @Override
        public void setFlag(Flag flag, boolean set) throws MessagingException
        {
            /*
             * If a message is being marked as deleted we want to clear out it's content
             * and attachments as well. Delete will not actually remove the row since we need
             * to retain the uid for synchronization purposes.
             */

            if (flag == Flag.DELETED && set)
            {
                delete();
            }
            else if (flag == Flag.X_DESTROYED && set)
            {
                ((LocalFolder) mFolder).deleteAttachments(mId);
                mDb.execSQL(""DELETE FROM messages WHERE id = ?"", new Object[] { mId });
            }

            /*
             * Update the unread count on the folder.
             */
            try
            {
                LocalFolder folder = (LocalFolder)mFolder;
                if (flag == Flag.DELETED || flag == Flag.X_DESTROYED
                        || (flag == Flag.SEEN && !isSet(Flag.DELETED)))
                {
                    if (set && !isSet(Flag.SEEN))
                    {
                        folder.setUnreadMessageCount(folder.getUnreadMessageCount() - 1);
                    }
                    else if (!set && isSet(Flag.SEEN))
                    {
                        folder.setUnreadMessageCount(folder.getUnreadMessageCount() + 1);
                    }
                }
                if ((flag == Flag.DELETED || flag == Flag.X_DESTROYED) && isSet(Flag.FLAGGED))
                {
                    folder.setFlaggedMessageCount(folder.getFlaggedMessageCount() + (set ? -1 : 1));
                }
                if (flag == Flag.FLAGGED && !isSet(Flag.DELETED))
                {
                    folder.setFlaggedMessageCount(folder.getFlaggedMessageCount() + (set ?  1 : -1));
                }
            }
            catch (MessagingException me)
            {
                Log.e(K9.LOG_TAG, ""Unable to update LocalStore unread message count"",
                      me);
                throw new RuntimeException(me);
            }

            super.setFlag(flag, set);
            /*
             * Set the flags on the message.
             */
            mDb.execSQL(""UPDATE messages "" + ""SET flags = ? "" + "" WHERE id = ?"", new Object[]
                        {
                            Utility.combine(getFlags(), ',').toUpperCase(), mId
                        });


        }

        private void delete() throws MessagingException

        {
            /*
             * Delete all of the message's content to save space.
             */

            mDb.execSQL(
                ""UPDATE messages SET "" +
                ""deleted = 1,"" +
                ""subject = NULL, "" +
                ""sender_list = NULL, "" +
                ""date = NULL, "" +
                ""to_list = NULL, "" +
                ""cc_list = NULL, "" +
                ""bcc_list = NULL, "" +
                ""preview = NULL, "" +
                ""html_content = NULL, "" +
                ""text_content = NULL, "" +
                ""reply_to_list = NULL "" +
                ""WHERE id = ?"",
                new Object[]
                {
                    mId
                });

            /*
             * Delete all of the message's attachments to save space.
             * We do this explicit deletion here because we're not deleting the record
             * in messages, which means our ON DELETE trigger for messages won't cascade
             */
            ((LocalFolder)mFolder).deleteAttachments(mId);
            mDb.execSQL(""DELETE FROM attachments WHERE message_id = ?"",
                        new Object[]
                        {
                            mId
                        });

            ((LocalFolder)mFolder).deleteHeaders(mId);


        }




        private void loadHeaders()
        {
            ArrayList<LocalMessage> messages = new ArrayList<LocalMessage>();
            messages.add(this);
            mHeadersLoaded = true; // set true before calling populate headers to stop recursion
            ((LocalFolder) mFolder).populateHeaders(messages);

        }

        @Override
        public void addHeader(String name, String value)
        {
            if (!mHeadersLoaded)
                loadHeaders();
            super.addHeader(name, value);
        }

        @Override
        public void setHeader(String name, String value)
        {
            if (!mHeadersLoaded)
                loadHeaders();
            super.setHeader(name, value);
        }

        @Override
        public String[] getHeader(String name)
        {
            if (!mHeadersLoaded)
                loadHeaders();
            return super.getHeader(name);
        }

        @Override
        public void removeHeader(String name)
        {
            if (!mHeadersLoaded)
                loadHeaders();
            super.removeHeader(name);
        }

        @Override
        public Set<String> getHeaderNames()
        {
            if (!mHeadersLoaded)
                loadHeaders();
            return super.getHeaderNames();
        }
    }

    public class LocalAttachmentBodyPart extends MimeBodyPart
    {
        private long mAttachmentId = -1;

        public LocalAttachmentBodyPart(Body body, long attachmentId) throws MessagingException
        {
            super(body);
            mAttachmentId = attachmentId;
        }

        /**
         * Returns the local attachment id of this body, or -1 if it is not stored.
         * @return
         */
        public long getAttachmentId()
        {
            return mAttachmentId;
        }

        public void setAttachmentId(long attachmentId)
        {
            mAttachmentId = attachmentId;
        }

        @Override
        public String toString()
        {
            return """" + mAttachmentId;
        }
    }

    public static class LocalAttachmentBody implements Body
    {
        private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
        private Application mApplication;
        private Uri mUri;

        public LocalAttachmentBody(Uri uri, Application application)
        {
            mApplication = application;
            mUri = uri;
        }

        public InputStream getInputStream() throws MessagingException
        {
            try
            {
                return mApplication.getContentResolver().openInputStream(mUri);
            }
            catch (FileNotFoundException fnfe)
            {
                /*
                 * Since it's completely normal for us to try to serve up attachments that
                 * have been blown away, we just return an empty stream.
                 */
                return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);
            }
        }

        public void writeTo(OutputStream out) throws IOException, MessagingException
        {
            InputStream in = getInputStream();
            Base64OutputStream base64Out = new Base64OutputStream(out);
            IOUtils.copy(in, base64Out);
            base64Out.close();
        }

        public Uri getContentUri()
        {
            return mUri;
        }
    }
}
",True,217,1,1,7,56,13,27,L1
126,com.fsck.k9.mail.store.TrustManagerFactory.java,"
package com.fsck.k9.mail.store;

import android.app.Application;
import android.content.Context;
import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.helper.DomainNameChecker;

import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.HashMap;
import java.util.Map;

public final class TrustManagerFactory
{
    private static final String LOG_TAG = ""TrustManagerFactory"";

    private static X509TrustManager defaultTrustManager;
    private static X509TrustManager unsecureTrustManager;
    private static X509TrustManager localTrustManager;

    private static X509Certificate[] lastCertChain = null;

    private static File keyStoreFile;
    private static KeyStore keyStore;


    private static class SimpleX509TrustManager implements X509TrustManager
    {
        public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException
        {
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException
        {
        }

        public X509Certificate[] getAcceptedIssuers()
        {
            return null;
        }
    }

    private static class SecureX509TrustManager implements X509TrustManager
    {
        private static final Map<String, SecureX509TrustManager> mTrustManager =
            new HashMap<String, SecureX509TrustManager>();

        private final String mHost;

        private SecureX509TrustManager(String host)
        {
            mHost = host;
        }

        public synchronized static X509TrustManager getInstance(String host)
        {
            SecureX509TrustManager trustManager;
            if (mTrustManager.containsKey(host))
            {
                trustManager = mTrustManager.get(host);
            }
            else
            {
                trustManager = new SecureX509TrustManager(host);
                mTrustManager.put(host, trustManager);
            }

            return trustManager;
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException
        {
            defaultTrustManager.checkClientTrusted(chain, authType);
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException
        {
            TrustManagerFactory.setLastCertChain(chain);
            try
            {
                defaultTrustManager.checkServerTrusted(chain, authType);
            }
            catch (CertificateException e)
            {
                localTrustManager.checkServerTrusted(new X509Certificate[] {chain[0]}, authType);
            }
            if (!DomainNameChecker.match(chain[0], mHost))
            {
                try
                {
                    String dn = chain[0].getSubjectDN().toString();
                    if ((dn != null) && (dn.equalsIgnoreCase(keyStore.getCertificateAlias(chain[0]))))
                    {
                        return;
                    }
                }
                catch (KeyStoreException e)
                {
                    throw new CertificateException(""Certificate cannot be verified; KeyStore Exception: "" + e);
                }
                throw new CertificateException(""Certificate domain name does not match ""
                                               + mHost);
            }
        }

        public X509Certificate[] getAcceptedIssuers()
        {
            return defaultTrustManager.getAcceptedIssuers();
        }

    }

    static
    {
        try
        {
            javax.net.ssl.TrustManagerFactory tmf = javax.net.ssl.TrustManagerFactory.getInstance(""X509"");
            Application app = K9.app;
            keyStoreFile = new File(app.getDir(""KeyStore"", Context.MODE_PRIVATE) + File.separator + ""KeyStore.bks"");
            keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            java.io.FileInputStream fis;
            try
            {
                fis = new java.io.FileInputStream(keyStoreFile);
            }
            catch (FileNotFoundException e1)
            {
                fis = null;
            }
            try
            {
                keyStore.load(fis, """".toCharArray());
                //if (fis != null) {
                // fis.close();
                //}
            }
            catch (IOException e)
            {
                Log.e(LOG_TAG, ""KeyStore IOException while initializing TrustManagerFactory "", e);
                keyStore = null;
            }
            catch (CertificateException e)
            {
                Log.e(LOG_TAG, ""KeyStore CertificateException while initializing TrustManagerFactory "", e);
                keyStore = null;
            }
            tmf.init(keyStore);
            TrustManager[] tms = tmf.getTrustManagers();
            if (tms != null)
            {
                for (TrustManager tm : tms)
                {
                    if (tm instanceof X509TrustManager)
                    {
                        localTrustManager = (X509TrustManager)tm;
                        break;
                    }
                }
            }
            tmf = javax.net.ssl.TrustManagerFactory.getInstance(""X509"");
            tmf.init((KeyStore)null);
            tms = tmf.getTrustManagers();
            if (tms != null)
            {
                for (TrustManager tm : tms)
                {
                    if (tm instanceof X509TrustManager)
                    {
                        defaultTrustManager = (X509TrustManager) tm;
                        break;
                    }
                }
            }

        }
        catch (NoSuchAlgorithmException e)
        {
            Log.e(LOG_TAG, ""Unable to get X509 Trust Manager "", e);
        }
        catch (KeyStoreException e)
        {
            Log.e(LOG_TAG, ""Key Store exception while initializing TrustManagerFactory "", e);
        }
        unsecureTrustManager = new SimpleX509TrustManager();
    }

    private TrustManagerFactory()
    {
    }

    public static X509TrustManager get(String host, boolean secure)
    {
        return secure ? SecureX509TrustManager.getInstance(host) :
               unsecureTrustManager;
    }

    public static KeyStore getKeyStore()
    {
        return keyStore;
    }

    public static void setLastCertChain(X509Certificate[] chain)
    {
        lastCertChain = chain;
    }
    public static X509Certificate[] getLastCertChain()
    {
        return lastCertChain;
    }

    public static void addCertificateChain(String alias, X509Certificate[] chain) throws CertificateException
    {
        try
        {
            javax.net.ssl.TrustManagerFactory tmf = javax.net.ssl.TrustManagerFactory.getInstance(""X509"");
            for (X509Certificate element : chain)
            {
                keyStore.setCertificateEntry
                (element.getSubjectDN().toString(), element);
            }

            tmf.init(keyStore);
            TrustManager[] tms = tmf.getTrustManagers();
            if (tms != null)
            {
                for (TrustManager tm : tms)
                {
                    if (tm instanceof X509TrustManager)
                    {
                        localTrustManager = (X509TrustManager) tm;
                        break;
                    }
                }
            }
            java.io.FileOutputStream keyStoreStream;
            try
            {
                keyStoreStream = new java.io.FileOutputStream(keyStoreFile);
                keyStore.store(keyStoreStream, """".toCharArray());
                keyStoreStream.close();
            }
            catch (FileNotFoundException e)
            {
                throw new CertificateException(""Unable to write KeyStore: "" + e.getMessage());
            }
            catch (CertificateException e)
            {
                throw new CertificateException(""Unable to write KeyStore: "" + e.getMessage());
            }
            catch (IOException e)
            {
                throw new CertificateException(""Unable to write KeyStore: "" + e.getMessage());
            }

        }
        catch (NoSuchAlgorithmException e)
        {
            Log.e(LOG_TAG, ""Unable to get X509 Trust Manager "", e);
        }
        catch (KeyStoreException e)
        {
            Log.e(LOG_TAG, ""Key Store exception while initializing TrustManagerFactory "", e);
        }
    }
}
",True,216,0,0,9,58,5,2,L1
127,com.fsck.k9.mail.store.ImapStore.java,"
package com.fsck.k9.mail.store;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.PowerManager;
import android.util.Log;
import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.controller.MessageRetrievalListener;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.helper.power.TracingPowerManager;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;
import com.fsck.k9.mail.*;
import com.fsck.k9.mail.filter.CountingOutputStream;
import com.fsck.k9.mail.filter.EOLConvertingOutputStream;
import com.fsck.k9.mail.filter.FixedLengthInputStream;
import com.fsck.k9.mail.filter.PeekableInputStream;
import com.fsck.k9.mail.internet.*;
import com.fsck.k9.mail.store.ImapResponseParser.ImapList;
import com.fsck.k9.mail.store.ImapResponseParser.ImapResponse;
import com.jcraft.jzlib.JZlib;
import com.jcraft.jzlib.ZInputStream;
import com.jcraft.jzlib.ZOutputStream;
import com.beetstra.jutf7.CharsetProvider;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.TrustManager;


import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.binary.Hex;

import java.io.*;
import java.net.*;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.Security;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * <pre>
 * TODO Need to start keeping track of UIDVALIDITY
 * TODO Need a default response handler for things like folder updates
 * </pre>
 */
public class ImapStore extends Store
{
    public static final int CONNECTION_SECURITY_NONE = 0;
    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

    private enum AuthType { PLAIN, CRAM_MD5 };

    private static final int IDLE_READ_TIMEOUT_INCREMENT = 5 * 60 * 1000;
    private static final int IDLE_FAILURE_COUNT_LIMIT = 10;
    private static int MAX_DELAY_TIME = 5 * 60 * 1000; // 5 minutes
    private static int NORMAL_DELAY_TIME = 5000;

    private static int FETCH_WINDOW_SIZE = 100;

    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED, Flag.SEEN };

    private static final String CAPABILITY_IDLE = ""IDLE"";
    private static final String COMMAND_IDLE = ""IDLE"";
    private static final String CAPABILITY_NAMESPACE = ""NAMESPACE"";
    private static final String COMMAND_NAMESPACE = ""NAMESPACE"";

    private static final String CAPABILITY_CAPABILITY = ""CAPABILITY"";
    private static final String COMMAND_CAPABILITY = ""CAPABILITY"";

    private static final String CAPABILITY_COMPRESS_DEFLATE = ""COMPRESS=DEFLATE"";
    private static final String COMMAND_COMPRESS_DEFLATE = ""COMPRESS DEFLATE"";

    private static final Message[] EMPTY_MESSAGE_ARRAY = new Message[0];

    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    private String mHost;
    private int mPort;
    private String mUsername;
    private String mPassword;
    private int mConnectionSecurity;
    private AuthType mAuthType;
    private volatile String mPathPrefix;
    private volatile String mCombinedPrefix = null;
    private volatile String mPathDelimeter = null;

    private static final SimpleDateFormat RFC3501_DATE = new SimpleDateFormat(""dd-MMM-yyyy"", Locale.US);

    private LinkedList<ImapConnection> mConnections =
        new LinkedList<ImapConnection>();

    /**
     * Charset used for converting folder names to and from UTF-7 as defined by RFC 3501.
     */
    private Charset mModifiedUtf7Charset;

    /**
     * Cache of ImapFolder objects. ImapFolders are attached to a given folder on the server
     * and as long as their associated connection remains open they are reusable between
     * requests. This cache lets us make sure we always reuse, if possible, for a given
     * folder name.
     */
    private HashMap<String, ImapFolder> mFolderCache = new HashMap<String, ImapFolder>();

    /**
     * imap://auth:user:password@server:port CONNECTION_SECURITY_NONE
     * imap+tls://auth:user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
     * imap+tls+://auth:user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
     * imap+ssl+://auth:user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
     * imap+ssl://auth:user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
     *
     * @param _uri
     */
    public ImapStore(Account account) throws MessagingException
    {
        super(account);
        URI uri;
        try
        {
            uri = new URI(mAccount.getStoreUri());
        }
        catch (URISyntaxException use)
        {
            throw new MessagingException(""Invalid ImapStore URI"", use);
        }

        String scheme = uri.getScheme();
        if (scheme.equals(""imap""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_NONE;
            mPort = 143;
        }
        else if (scheme.equals(""imap+tls""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
            mPort = 143;
        }
        else if (scheme.equals(""imap+tls+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
            mPort = 143;
        }
        else if (scheme.equals(""imap+ssl+""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
            mPort = 993;
        }
        else if (scheme.equals(""imap+ssl""))
        {
            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
            mPort = 993;
        }
        else
        {
            throw new MessagingException(""Unsupported protocol"");
        }

        mHost = uri.getHost();

        if (uri.getPort() != -1)
        {
            mPort = uri.getPort();
        }

        if (uri.getUserInfo() != null)
        {
            try
            {
                String[] userInfoParts = uri.getUserInfo().split("":"");
                if (userInfoParts.length == 2)
                {
                    mAuthType = AuthType.PLAIN;
                    mUsername = URLDecoder.decode(userInfoParts[0], ""UTF-8"");
                    mPassword = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                }
                else
                {
                    mAuthType = AuthType.valueOf(userInfoParts[0]);
                    mUsername = URLDecoder.decode(userInfoParts[1], ""UTF-8"");
                    mPassword = URLDecoder.decode(userInfoParts[2], ""UTF-8"");
                }
            }
            catch (UnsupportedEncodingException enc)
            {
                // This shouldn't happen since the encoding is hardcoded to UTF-8
                Log.e(K9.LOG_TAG, ""Couldn't urldecode username or password."", enc);
            }
        }

        if ((uri.getPath() != null) && (uri.getPath().length() > 0))
        {
            mPathPrefix = uri.getPath().substring(1);
            if (mPathPrefix != null && mPathPrefix.trim().length() == 0)
            {
                mPathPrefix = null;
            }
        }

        mModifiedUtf7Charset = new CharsetProvider().charsetForName(""X-RFC-3501"");
    }

    @Override
    public Folder getFolder(String name) throws MessagingException
    {
        ImapFolder folder;
        synchronized (mFolderCache)
        {
            folder = mFolderCache.get(name);
            if (folder == null)
            {
                folder = new ImapFolder(this, name);
                mFolderCache.put(name, folder);
            }
        }
        return folder;
    }

    private String getCombinedPrefix()
    {
        if (mCombinedPrefix == null)
        {
            if (mPathPrefix != null)
            {
                String tmpPrefix = mPathPrefix.trim();
                String tmpDelim = (mPathDelimeter != null ? mPathDelimeter.trim() : """");
                if (tmpPrefix.endsWith(tmpDelim))
                {
                    mCombinedPrefix = tmpPrefix;
                }
                else if (tmpPrefix.length() > 0)
                {
                    mCombinedPrefix = tmpPrefix + tmpDelim;
                }
                else
                {
                    mCombinedPrefix = """";
                }
            }
            else
            {
                mCombinedPrefix = """";
            }
        }
        return mCombinedPrefix;
    }

    @Override
    public List<? extends Folder> getPersonalNamespaces(boolean forceListAll) throws MessagingException
    {
        ImapConnection connection = getConnection();
        try
        {
            List<? extends Folder> allFolders = listFolders(connection, false);
            if (forceListAll || !mAccount.subscribedFoldersOnly())
            {
                return allFolders;
            }
            else
            {
                List<Folder> resultFolders = new LinkedList<Folder>();
                HashSet<String> subscribedFolderNames = new HashSet<String>();
                List<? extends Folder> subscribedFolders = listFolders(connection, true);
                for (Folder subscribedFolder : subscribedFolders)
                {
                    subscribedFolderNames.add(subscribedFolder.getName());
                }
                for (Folder folder : allFolders)
                {
                    if (subscribedFolderNames.contains(folder.getName()))
                    {
                        resultFolders.add(folder);
                    }
                }
                return resultFolders;
            }
        }
        catch (IOException ioe)
        {
            connection.close();
            throw new MessagingException(""Unable to get folder list."", ioe);
        }
        catch (MessagingException me)
        {
            connection.close();
            throw new MessagingException(""Unable to get folder list."", me);
        }
        finally
        {
            releaseConnection(connection);
        }
    }


    private List<? extends Folder> listFolders(ImapConnection connection, boolean LSUB) throws IOException, MessagingException
    {
        String commandResponse = LSUB ? ""LSUB"" : ""LIST"";

        LinkedList<Folder> folders = new LinkedList<Folder>();

        List<ImapResponse> responses =
            connection.executeSimpleCommand(String.format(commandResponse + "" \""\"" \""%s*\"""",
                                            getCombinedPrefix()));

        for (ImapResponse response : responses)
        {
            if (ImapResponseParser.equalsIgnoreCase(response.get(0), commandResponse))
            {
                boolean includeFolder = true;
                String folder = decodeFolderName(response.getString(3));

                if (mPathDelimeter == null)
                {
                    mPathDelimeter = response.getString(2);
                    mCombinedPrefix = null;
                }

                if (folder.equalsIgnoreCase(K9.INBOX))
                {
                    continue;
                }
                else
                {

                    if (getCombinedPrefix().length() > 0)
                    {
                        if (folder.length() >= getCombinedPrefix().length())
                        {
                            folder = folder.substring(getCombinedPrefix().length());
                        }
                        if (!decodeFolderName(response.getString(3)).equalsIgnoreCase(getCombinedPrefix() + folder))
                        {
                            includeFolder = false;
                        }
                    }
                }

                ImapList attributes = response.getList(1);
                for (int i = 0, count = attributes.size(); i < count; i++)
                {
                    String attribute = attributes.getString(i);
                    if (attribute.equalsIgnoreCase(""\\NoSelect""))
                    {
                        includeFolder = false;
                    }
                }
                if (includeFolder)
                {
                    folders.add(getFolder(folder));
                }
            }
        }
        folders.add(getFolder(""INBOX""));
        return folders;

    }

    @Override
    public void checkSettings() throws MessagingException
    {
        try
        {
            ImapConnection connection = new ImapConnection();
            connection.open();
            connection.close();
        }
        catch (IOException ioe)
        {
            throw new MessagingException(""Unable to connect."", ioe);
        }
    }

    /**
     * Gets a connection if one is available for reuse, or creates a new one if not.
     * @return
     */
    private ImapConnection getConnection() throws MessagingException
    {
        synchronized (mConnections)
        {
            ImapConnection connection = null;
            while ((connection = mConnections.poll()) != null)
            {
                try
                {
                    connection.executeSimpleCommand(""NOOP"");
                    break;
                }
                catch (IOException ioe)
                {
                    connection.close();
                }
            }
            if (connection == null)
            {
                connection = new ImapConnection();
            }
            return connection;
        }
    }

    private void releaseConnection(ImapConnection connection)
    {
        if (connection != null && connection.isOpen())
        {
            synchronized (mConnections)
            {
                mConnections.offer(connection);
            }
        }
    }

    private String encodeFolderName(String name)
    {
        try
        {
            ByteBuffer bb = mModifiedUtf7Charset.encode(name);
            byte[] b = new byte[bb.limit()];
            bb.get(b);
            return new String(b, ""US-ASCII"");
        }
        catch (UnsupportedEncodingException uee)
        {
            /*
             * The only thing that can throw this is getBytes(""US-ASCII"") and if US-ASCII doesn't
             * exist we're totally screwed.
             */
            throw new RuntimeException(""Unable to encode folder name: "" + name, uee);
        }
    }

    private String decodeFolderName(String name)
    {
        /*
         * Convert the encoded name to US-ASCII, then pass it through the modified UTF-7
         * decoder and return the Unicode String.
         */
        try
        {
            byte[] encoded = name.getBytes(""US-ASCII"");
            CharBuffer cb = mModifiedUtf7Charset.decode(ByteBuffer.wrap(encoded));
            return cb.toString();
        }
        catch (UnsupportedEncodingException uee)
        {
            /*
             * The only thing that can throw this is getBytes(""US-ASCII"") and if US-ASCII doesn't
             * exist we're totally screwed.
             */
            throw new RuntimeException(""Unable to decode folder name: "" + name, uee);
        }
    }

    @Override
    public boolean isMoveCapable()
    {
        return true;
    }

    @Override
    public boolean isCopyCapable()
    {
        return true;
    }
    @Override
    public boolean isPushCapable()
    {
        return true;
    }
    @Override
    public boolean isExpungeCapable()
    {
        return true;
    }


    class ImapFolder extends Folder
    {
        private String mName;
        protected volatile int mMessageCount = -1;
        protected volatile int uidNext = -1;
        protected volatile ImapConnection mConnection;
        private OpenMode mMode;
        private volatile boolean mExists;
        private ImapStore store = null;
        Map<Integer, String> msgSeqUidMap = new ConcurrentHashMap<Integer, String>();


        public ImapFolder(ImapStore nStore, String name)
        {
            super(nStore.getAccount());
            store = nStore;
            this.mName = name;
        }

        public String getPrefixedName() throws MessagingException
        {
            String prefixedName = """";
            if (!K9.INBOX.equalsIgnoreCase(mName))
            {
                ImapConnection connection = null;
                synchronized (this)
                {
                    if (mConnection == null)
                    {
                        connection = getConnection();
                    }
                    else
                    {
                        connection = mConnection;
                    }
                }
                try
                {

                    connection.open();
                }
                catch (IOException ioe)
                {
                    throw new MessagingException(""Unable to get IMAP prefix"", ioe);
                }
                finally
                {
                    if (mConnection == null)
                    {
                        releaseConnection(connection);
                    }
                }
                prefixedName = getCombinedPrefix();
            }

            prefixedName += mName;
            return prefixedName;
        }

        protected List<ImapResponse> executeSimpleCommand(String command) throws MessagingException, IOException
        {
            return handleUntaggedResponses(mConnection.executeSimpleCommand(command));
        }

        protected List<ImapResponse> executeSimpleCommand(String command, boolean sensitve, UntaggedHandler untaggedHandler) throws MessagingException, IOException
        {
            return handleUntaggedResponses(mConnection.executeSimpleCommand(command, sensitve, untaggedHandler));
        }

        @Override
        public void open(OpenMode mode) throws MessagingException
        {
            internalOpen(mode);

            if (mMessageCount == -1)
            {
                throw new MessagingException(
                    ""Did not find message count during open"");
            }
        }

        public List<ImapResponse> internalOpen(OpenMode mode) throws MessagingException
        {
            if (isOpen() && mMode == mode)
            {
                // Make sure the connection is valid. If it's not we'll close it down and continue
                // on to get a new one.
                try
                {
                    List<ImapResponse> responses = executeSimpleCommand(""NOOP"");
                    return responses;
                }
                catch (IOException ioe)
                {
                    ioExceptionHandler(mConnection, ioe);
                }
            }
            releaseConnection(mConnection);
            synchronized (this)
            {
                mConnection = getConnection();
            }
            // * FLAGS (\Answered \Flagged \Deleted \Seen \Draft NonJunk
            // $MDNSent)
            // * OK [PERMANENTFLAGS (\Answered \Flagged \Deleted \Seen \Draft
            // NonJunk $MDNSent \*)] Flags permitted.
            // * 23 EXISTS
            // * 0 RECENT
            // * OK [UIDVALIDITY 1125022061] UIDs valid
            // * OK [UIDNEXT 57576] Predicted next UID
            // 2 OK [READ-WRITE] Select completed.
            try
            {
                msgSeqUidMap.clear();
                String command = String.format((mode == OpenMode.READ_WRITE ? ""SELECT"" : ""EXAMINE"") + "" \""%s\"""",
                                               encodeFolderName(getPrefixedName()));

                List<ImapResponse> responses = executeSimpleCommand(command);

                /*
                 * If the command succeeds we expect the folder has been opened read-write
                 * unless we are notified otherwise in the responses.
                 */
                mMode = mode;

                for (ImapResponse response : responses)
                {
                    if (response.mTag != null && response.size() >= 2)
                    {
                        Object bracketedObj = response.get(1);
                        if (bracketedObj instanceof ImapList)
                        {
                            ImapList bracketed = (ImapList)bracketedObj;

                            if (bracketed.size() > 0)
                            {
                                Object keyObj = bracketed.get(0);
                                if (keyObj instanceof String)
                                {
                                    String key = (String)keyObj;

                                    if (""READ-ONLY"".equalsIgnoreCase(key))
                                    {
                                        mMode = OpenMode.READ_ONLY;
                                    }
                                    else if (""READ-WRITE"".equalsIgnoreCase(key))
                                    {
                                        mMode = OpenMode.READ_WRITE;
                                    }
                                }
                            }
                        }

                    }
                }

                mExists = true;
                return responses;
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
            catch (MessagingException me)
            {
                Log.e(K9.LOG_TAG, ""Unable to open connection for "" + getLogId(), me);
                throw me;
            }

        }

        @Override
        public boolean isOpen()
        {
            return mConnection != null;
        }

        @Override
        public OpenMode getMode() throws MessagingException
        {
            return mMode;
        }

        @Override
        public void close()
        {
            if (mMessageCount != -1)
            {
                mMessageCount = -1;
            }
            if (!isOpen())
            {
                return;
            }

            synchronized (this)
            {
                releaseConnection(mConnection);
                mConnection = null;
            }
        }

        @Override
        public String getName()
        {
            return mName;
        }

        private boolean exists(String folderName) throws MessagingException
        {
            try
            {
                // Since we don't care about RECENT, we'll use that for the check, because we're checking
                // a folder other than ourself, and don't want any untagged responses to cause a change
                // in our own fields
                mConnection.executeSimpleCommand(String.format(""STATUS \""%s\"" (RECENT)"", folderName));
                return true;
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
            catch (MessagingException me)
            {
                return false;
            }
        }

        @Override
        public boolean exists() throws MessagingException
        {
            if (mExists)
            {
                return true;
            }
            /*
             * This method needs to operate in the unselected mode as well as the selected mode
             * so we must get the connection ourselves if it's not there. We are specifically
             * not calling checkOpen() since we don't care if the folder is open.
             */
            ImapConnection connection = null;
            synchronized (this)
            {
                if (mConnection == null)
                {
                    connection = getConnection();
                }
                else
                {
                    connection = mConnection;
                }
            }
            try
            {
                connection.executeSimpleCommand(String.format(""STATUS \""%s\"" (UIDVALIDITY)"",
                                                encodeFolderName(getPrefixedName())));
                mExists = true;
                return true;
            }
            catch (MessagingException me)
            {
                return false;
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(connection, ioe);
            }
            finally
            {
                if (mConnection == null)
                {
                    releaseConnection(connection);
                }
            }
        }

        @Override
        public boolean create(FolderType type) throws MessagingException
        {
            /*
             * This method needs to operate in the unselected mode as well as the selected mode
             * so we must get the connection ourselves if it's not there. We are specifically
             * not calling checkOpen() since we don't care if the folder is open.
             */
            ImapConnection connection = null;
            synchronized (this)
            {
                if (mConnection == null)
                {
                    connection = getConnection();
                }
                else
                {
                    connection = mConnection;
                }
            }
            try
            {
                connection.executeSimpleCommand(String.format(""CREATE \""%s\"""",
                                                encodeFolderName(getPrefixedName())));
                return true;
            }
            catch (MessagingException me)
            {
                return false;
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
            finally
            {
                if (mConnection == null)
                {
                    releaseConnection(connection);
                }
            }
        }

        @Override
        public void copyMessages(Message[] messages, Folder folder) throws MessagingException
        {
            if (!(folder instanceof ImapFolder))
            {
                throw new MessagingException(""ImapFolder.copyMessages passed non-ImapFolder"");
            }

            if (messages.length == 0)
                return;

            ImapFolder iFolder = (ImapFolder)folder;
            checkOpen();
            String[] uids = new String[messages.length];
            for (int i = 0, count = messages.length; i < count; i++)
            {
                uids[i] = messages[i].getUid();
            }
            try
            {
                String remoteDestName = encodeFolderName(iFolder.getPrefixedName());

                if (!exists(remoteDestName))
                {
                    /*
                     * If the remote trash folder doesn't exist we try to create it.
                     */
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""IMAPMessage.copyMessages: attempting to create remote '"" + remoteDestName + ""' folder for "" + getLogId());
                    iFolder.create(FolderType.HOLDS_MESSAGES);
                }

                if (exists(remoteDestName))
                {
                    executeSimpleCommand(String.format(""UID COPY %s \""%s\"""",
                                                       Utility.combine(uids, ','),
                                                       encodeFolderName(iFolder.getPrefixedName())));
                }
                else
                {
                    throw new MessagingException(""IMAPMessage.copyMessages: remote destination folder "" + folder.getName()
                                                 + "" does not exist and could not be created for "" + getLogId()
                                                 , true);
                }
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        @Override
        public void moveMessages(Message[] messages, Folder folder) throws MessagingException
        {
            if (messages.length == 0)
                return;
            copyMessages(messages, folder);
            setFlags(messages, new Flag[] { Flag.DELETED }, true);
        }

        @Override
        public void delete(Message[] messages, String trashFolderName) throws MessagingException
        {
            if (messages.length == 0)
                return;

            if (trashFolderName == null || getName().equalsIgnoreCase(trashFolderName))
            {
                setFlags(messages, new Flag[] { Flag.DELETED }, true);
            }
            else
            {
                ImapFolder remoteTrashFolder = (ImapFolder)getStore().getFolder(trashFolderName);
                String remoteTrashName = encodeFolderName(remoteTrashFolder.getPrefixedName());

                if (!exists(remoteTrashName))
                {
                    /*
                     * If the remote trash folder doesn't exist we try to create it.
                     */
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""IMAPMessage.delete: attempting to create remote '"" + trashFolderName + ""' folder for "" + getLogId());
                    remoteTrashFolder.create(FolderType.HOLDS_MESSAGES);
                }

                if (exists(remoteTrashName))
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""IMAPMessage.delete: copying remote "" + messages.length + "" messages to '"" + trashFolderName + ""' for "" + getLogId());

                    moveMessages(messages, remoteTrashFolder);
                }
                else
                {
                    throw new MessagingException(""IMAPMessage.delete: remote Trash folder "" + trashFolderName + "" does not exist and could not be created for "" + getLogId()
                                                 , true);
                }
            }
        }


        @Override
        public int getMessageCount()
        {
            return mMessageCount;
        }


        private int getRemoteMessageCount(String criteria) throws MessagingException
        {
            checkOpen();
            try
            {
                int count = 0;
                int start = 1;

                List<ImapResponse> responses = executeSimpleCommand(String.format(""SEARCH %d:* ""+criteria, start));
                for (ImapResponse response : responses)
                {
                    if (ImapResponseParser.equalsIgnoreCase(response.get(0), ""SEARCH""))
                    {
                        count += response.size() - 1;
                    }
                }
                return count;
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }


        }

        @Override
        public int getUnreadMessageCount() throws MessagingException
        {
            return getRemoteMessageCount(""UNSEEN NOT DELETED"");
        }

        @Override
        public int getFlaggedMessageCount() throws MessagingException
        {
            return getRemoteMessageCount(""FLAGGED NOT DELETED"");
        }

        protected int getHighestUid()
        {
            try
            {
                ImapSearcher searcher = new ImapSearcher()
                {
                    public List<ImapResponse> search() throws IOException, MessagingException
                    {
                        return executeSimpleCommand(String.format(""UID SEARCH *:* ""));
                    }
                };
                Message[] messages = search(searcher, null);
                if (messages.length > 0)
                {
                    return Integer.parseInt(messages[0].getUid());
                }
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to find highest UID in folder "" + getName(), e);
            }
            return -1;

        }

        @Override
        public void delete(boolean recurse) throws MessagingException
        {
            throw new Error(""ImapStore.delete() not yet implemented"");
        }

        @Override
        public Message getMessage(String uid) throws MessagingException
        {
            return new ImapMessage(uid, this);
        }


        @Override
        public Message[] getMessages(int start, int end, Date earliestDate, MessageRetrievalListener listener)
        throws MessagingException
        {
            return getMessages(start, end, earliestDate, false, listener);
        }

        protected Message[] getMessages(final int start, final int end, Date earliestDate, final boolean includeDeleted, final MessageRetrievalListener listener)
        throws MessagingException
        {
            if (start < 1 || end < 1 || end < start)
            {
                throw new MessagingException(
                    String.format(""Invalid message set %d %d"",
                                  start, end));
            }
            final StringBuilder dateSearchString = new StringBuilder();
            if (earliestDate != null)
            {
                dateSearchString.append("" SINCE "");
                synchronized (RFC3501_DATE)
                {
                    dateSearchString.append(RFC3501_DATE.format(earliestDate));
                }
            }


            ImapSearcher searcher = new ImapSearcher()
            {
                public List<ImapResponse> search() throws IOException, MessagingException
                {
                    return executeSimpleCommand(String.format(""UID SEARCH %d:%d%s"" + (includeDeleted ? """" : "" NOT DELETED""), start, end, dateSearchString));
                }
            };
            return search(searcher, listener);

        }
        protected Message[] getMessages(final List<Integer> mesgSeqs, final boolean includeDeleted, final MessageRetrievalListener listener)
        throws MessagingException
        {
            ImapSearcher searcher = new ImapSearcher()
            {
                public List<ImapResponse> search() throws IOException, MessagingException
                {
                    return executeSimpleCommand(String.format(""UID SEARCH %s"" + (includeDeleted ? """" : "" NOT DELETED""), Utility.combine(mesgSeqs.toArray(), ',')));
                }
            };
            return search(searcher, listener);
        }

        protected Message[] getMessagesFromUids(final List<String> mesgUids, final boolean includeDeleted, final MessageRetrievalListener listener)
        throws MessagingException
        {
            ImapSearcher searcher = new ImapSearcher()
            {
                public List<ImapResponse> search() throws IOException, MessagingException
                {
                    return executeSimpleCommand(String.format(""UID SEARCH UID %s"" + (includeDeleted ? """" : "" NOT DELETED""), Utility.combine(mesgUids.toArray(), ',')));
                }
            };
            return search(searcher, listener);
        }

        private Message[] search(ImapSearcher searcher, MessageRetrievalListener listener) throws MessagingException
        {

            checkOpen();
            ArrayList<Message> messages = new ArrayList<Message>();
            try
            {
                ArrayList<Integer> uids = new ArrayList<Integer>();
                List<ImapResponse> responses = searcher.search(); //
                for (ImapResponse response : responses)
                {
                    if (response.mTag == null)
                    {
                        if (ImapResponseParser.equalsIgnoreCase(response.get(0), ""SEARCH""))
                        {
                            for (int i = 1, count = response.size(); i < count; i++)
                            {
                                uids.add(Integer.parseInt(response.getString(i)));
                            }
                        }
                    }
                }

                // Sort the uids in numerically ascending order
                Collections.sort(uids);
                for (int i = 0, count = uids.size(); i < count; i++)
                {
                    if (listener != null)
                    {
                        listener.messageStarted("""" + uids.get(i), i, count);
                    }
                    ImapMessage message = new ImapMessage("""" + uids.get(i), this);
                    messages.add(message);
                    if (listener != null)
                    {
                        listener.messageFinished(message, i, count);
                    }
                }
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
            return messages.toArray(EMPTY_MESSAGE_ARRAY);
        }


        @Override
        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException
        {
            return getMessages(null, listener);
        }

        @Override
        public Message[] getMessages(String[] uids, MessageRetrievalListener listener)
        throws MessagingException
        {
            checkOpen();
            ArrayList<Message> messages = new ArrayList<Message>();
            try
            {
                if (uids == null)
                {
                    List<ImapResponse> responses = executeSimpleCommand(""UID SEARCH 1:* NOT DELETED"");
                    ArrayList<String> tempUids = new ArrayList<String>();
                    for (ImapResponse response : responses)
                    {
                        if (ImapResponseParser.equalsIgnoreCase(response.get(0), ""SEARCH""))
                        {
                            for (int i = 1, count = response.size(); i < count; i++)
                            {
                                tempUids.add(response.getString(i));
                            }
                        }
                    }
                    uids = tempUids.toArray(EMPTY_STRING_ARRAY);
                }
                for (int i = 0, count = uids.length; i < count; i++)
                {
                    if (listener != null)
                    {
                        listener.messageStarted(uids[i], i, count);
                    }
                    ImapMessage message = new ImapMessage(uids[i], this);
                    messages.add(message);
                    if (listener != null)
                    {
                        listener.messageFinished(message, i, count);
                    }
                }
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
            return messages.toArray(EMPTY_MESSAGE_ARRAY);
        }

        @Override
        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
        throws MessagingException
        {
            if (messages == null || messages.length == 0)
            {
                return;
            }
            checkOpen();
            List<String> uids = new ArrayList<String>(messages.length);
            HashMap<String, Message> messageMap = new HashMap<String, Message>();
            for (int i = 0, count = messages.length; i < count; i++)
            {

                String uid = messages[i].getUid();
                uids.add(uid);
                messageMap.put(uid, messages[i]);
            }

            /*
             * Figure out what command we are going to run:
             * Flags - UID FETCH (FLAGS)
             * Envelope - UID FETCH ([FLAGS] INTERNALDATE UID RFC822.SIZE FLAGS BODY.PEEK[HEADER.FIELDS (date subject from content-type to cc)])
             *
             */
            LinkedHashSet<String> fetchFields = new LinkedHashSet<String>();
            fetchFields.add(""UID"");
            if (fp.contains(FetchProfile.Item.FLAGS))
            {
                fetchFields.add(""FLAGS"");
            }
            if (fp.contains(FetchProfile.Item.ENVELOPE))
            {
                fetchFields.add(""INTERNALDATE"");
                fetchFields.add(""RFC822.SIZE"");
                fetchFields.add(""BODY.PEEK[HEADER.FIELDS (date subject from content-type to cc reply-to ""
                                + K9.K9MAIL_IDENTITY + "")]"");
            }
            if (fp.contains(FetchProfile.Item.STRUCTURE))
            {
                fetchFields.add(""BODYSTRUCTURE"");
            }
            if (fp.contains(FetchProfile.Item.BODY_SANE))
            {
                fetchFields.add(String.format(""BODY.PEEK[]<0.%d>"", mAccount.getMaximumAutoDownloadMessageSize()));
            }
            if (fp.contains(FetchProfile.Item.BODY))
            {
                fetchFields.add(""BODY.PEEK[]"");
            }



            for (int windowStart=0; windowStart <= messages.length; windowStart += (FETCH_WINDOW_SIZE +1))
            {
                List<String> uidWindow = uids.subList(windowStart, Math.min((windowStart+FETCH_WINDOW_SIZE),messages.length));

                try
                {
                    mConnection.sendCommand(String.format(""UID FETCH %s (%s)"",
                                                          Utility.combine(uidWindow.toArray(new String[uidWindow.size()]), ','),
                                                          Utility.combine(fetchFields.toArray(new String[fetchFields.size()]), ' ')
                                                         ), false);
                    ImapResponse response;
                    int messageNumber = 0;

                    ImapResponseParser.IImapResponseCallback callback = null;
                    if (fp.contains(FetchProfile.Item.BODY) || fp.contains(FetchProfile.Item.BODY_SANE))
                    {
                        callback = new FetchBodyCallback(messageMap);
                    }

                    do
                    {
                        response = mConnection.readResponse(callback);

                        if (response.mTag == null && ImapResponseParser.equalsIgnoreCase(response.get(1), ""FETCH""))
                        {
                            ImapList fetchList = (ImapList)response.getKeyedValue(""FETCH"");
                            String uid = fetchList.getKeyedString(""UID"");
                            int msgSeq = response.getNumber(0);
                            if (uid != null)
                            {
                                try
                                {
                                    msgSeqUidMap.put(msgSeq, uid);
                                    if (K9.DEBUG)
                                    {
                                        Log.v(K9.LOG_TAG, ""Stored uid '"" + uid + ""' for msgSeq "" + msgSeq + "" into map "" /*+ msgSeqUidMap.toString() */);
                                    }
                                }
                                catch (Exception e)
                                {
                                    Log.e(K9.LOG_TAG, ""Unable to store uid '"" + uid + ""' for msgSeq "" + msgSeq);
                                }
                            }

                            Message message = messageMap.get(uid);
                            if (message == null)
                            {
                                if (K9.DEBUG)
                                    Log.d(K9.LOG_TAG, ""Do not have message in messageMap for UID "" + uid + "" for "" + getLogId());

                                handleUntaggedResponse(response);
                                continue;
                            }
                            if (listener != null)
                            {
                                listener.messageStarted(uid, messageNumber++, messageMap.size());
                            }

                            ImapMessage imapMessage = (ImapMessage) message;

                            Object literal = handleFetchResponse(imapMessage, fetchList);

                            if (literal != null)
                            {
                                if (literal instanceof String)
                                {
                                    String bodyString = (String)literal;
                                    InputStream bodyStream = new ByteArrayInputStream(bodyString.getBytes());
                                    imapMessage.parse(bodyStream);
                                }
                                else if (literal instanceof Integer)
                                {
                                    // All the work was done in FetchBodyCallback.foundLiteral()
                                }
                                else
                                {
                                    // This shouldn't happen
                                    throw new MessagingException(""Got FETCH response with bogus parameters"");
                                }
                            }

                            if (listener != null)
                            {
                                listener.messageFinished(message, messageNumber, messageMap.size());
                            }
                        }
                        else
                        {
                            handleUntaggedResponse(response);
                        }

                        while (response.more());

                    }
                    while (response.mTag == null);
                }
                catch (IOException ioe)
                {
                    throw ioExceptionHandler(mConnection, ioe);
                }
            }
        }


        @Override
        public void fetchPart(Message message, Part part, MessageRetrievalListener listener)
        throws MessagingException
        {
            checkOpen();

            String[] parts = part.getHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA);
            if (parts == null)
            {
                return;
            }

            String fetch;
            String partId = parts[0];
            if (""TEXT"".equalsIgnoreCase(partId))
            {
                fetch = String.format(""BODY.PEEK[TEXT]<0.%d>"", mAccount.getMaximumAutoDownloadMessageSize());
            }
            else
            {
                fetch = String.format(""BODY.PEEK[%s]"", partId);
            }

            try
            {
                mConnection.sendCommand(
                    String.format(""UID FETCH %s (UID %s)"", message.getUid(), fetch),
                    false);

                ImapResponse response;
                int messageNumber = 0;

                ImapResponseParser.IImapResponseCallback callback = new FetchPartCallback(part);

                do
                {
                    response = mConnection.readResponse(callback);

                    if ((response.mTag == null) &&
                            (ImapResponseParser.equalsIgnoreCase(response.get(1), ""FETCH"")))
                    {
                        ImapList fetchList = (ImapList)response.getKeyedValue(""FETCH"");
                        String uid = fetchList.getKeyedString(""UID"");

                        if (!message.getUid().equals(uid))
                        {
                            if (K9.DEBUG)
                                Log.d(K9.LOG_TAG, ""Did not ask for UID "" + uid + "" for "" + getLogId());

                            handleUntaggedResponse(response);
                            continue;
                        }
                        if (listener != null)
                        {
                            listener.messageStarted(uid, messageNumber++, 1);
                        }

                        ImapMessage imapMessage = (ImapMessage) message;

                        Object literal = handleFetchResponse(imapMessage, fetchList);

                        if (literal != null)
                        {
                            if (literal instanceof Body)
                            {
                                // Most of the work was done in FetchAttchmentCallback.foundLiteral()
                                part.setBody((Body)literal);
                            }
                            else if (literal instanceof String)
                            {
                                String bodyString = (String)literal;
                                InputStream bodyStream = new ByteArrayInputStream(bodyString.getBytes());

                                String contentTransferEncoding = part.getHeader(
                                                                     MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING)[0];
                                part.setBody(MimeUtility.decodeBody(bodyStream, contentTransferEncoding));
                            }
                            else
                            {
                                // This shouldn't happen
                                throw new MessagingException(""Got FETCH response with bogus parameters"");
                            }
                        }

                        if (listener != null)
                        {
                            listener.messageFinished(message, messageNumber, 1);
                        }
                    }
                    else
                    {
                        handleUntaggedResponse(response);
                    }

                    while (response.more());

                }
                while (response.mTag == null);
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        // Returns value of body field
        private Object handleFetchResponse(ImapMessage message, ImapList fetchList) throws MessagingException
        {
            Object result = null;
            if (fetchList.containsKey(""FLAGS""))
            {
                ImapList flags = fetchList.getKeyedList(""FLAGS"");
                if (flags != null)
                {
                    for (int i = 0, count = flags.size(); i < count; i++)
                    {
                        String flag = flags.getString(i);
                        if (flag.equalsIgnoreCase(""\\Deleted""))
                        {
                            message.setFlagInternal(Flag.DELETED, true);
                        }
                        else if (flag.equalsIgnoreCase(""\\Answered""))
                        {
                            message.setFlagInternal(Flag.ANSWERED, true);
                        }
                        else if (flag.equalsIgnoreCase(""\\Seen""))
                        {
                            message.setFlagInternal(Flag.SEEN, true);
                        }
                        else if (flag.equalsIgnoreCase(""\\Flagged""))
                        {
                            message.setFlagInternal(Flag.FLAGGED, true);
                        }
                    }
                }
            }

            if (fetchList.containsKey(""INTERNALDATE""))
            {
                Date internalDate = fetchList.getKeyedDate(""INTERNALDATE"");
                message.setInternalDate(internalDate);
            }

            if (fetchList.containsKey(""RFC822.SIZE""))
            {
                int size = fetchList.getKeyedNumber(""RFC822.SIZE"");
                message.setSize(size);
            }

            if (fetchList.containsKey(""BODYSTRUCTURE""))
            {
                ImapList bs = fetchList.getKeyedList(""BODYSTRUCTURE"");
                if (bs != null)
                {
                    try
                    {
                        parseBodyStructure(bs, message, ""TEXT"");
                    }
                    catch (MessagingException e)
                    {
                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""Error handling message for "" + getLogId(), e);
                        message.setBody(null);
                    }
                }
            }

            if (fetchList.containsKey(""BODY""))
            {
                int index = fetchList.getKeyIndex(""BODY"") + 2;
                result = fetchList.getObject(index);

                // Check if there's an origin octet
                if (result instanceof String)
                {
                    String originOctet = (String)result;
                    if (originOctet.startsWith(""<""))
                    {
                        result = fetchList.getObject(index + 1);
                    }
                }
            }

            return result;
        }

        @Override
        public Flag[] getPermanentFlags() throws MessagingException
        {
            return PERMANENT_FLAGS;
        }

        /**
         * Handle any untagged responses that the caller doesn't care to handle themselves.
         * @param responses
         */
        protected List<ImapResponse> handleUntaggedResponses(List<ImapResponse> responses)
        {
            for (ImapResponse response : responses)
            {
                handleUntaggedResponse(response);
            }
            return responses;
        }

        protected void handlePossibleUidNext(ImapResponse response)
        {
            if (ImapResponseParser.equalsIgnoreCase(response.get(0), ""OK"") && response.size() > 1)
            {
                Object bracketedObj = response.get(1);
                if (bracketedObj instanceof ImapList)
                {
                    ImapList bracketed = (ImapList)bracketedObj;

                    if (bracketed.size() > 1)
                    {
                        Object keyObj = bracketed.get(0);
                        if (keyObj instanceof String)
                        {
                            String key = (String)keyObj;
                            if (""UIDNEXT"".equalsIgnoreCase(key))
                            {
                                uidNext = bracketed.getNumber(1);
                                if (K9.DEBUG)
                                    Log.d(K9.LOG_TAG, ""Got UidNext = "" + uidNext + "" for "" + getLogId());
                            }
                        }
                    }


                }
            }
        }

        /**
         * Handle an untagged response that the caller doesn't care to handle themselves.
         * @param response
         */
        protected void handleUntaggedResponse(ImapResponse response)
        {
            if (response.mTag == null && response.size() > 1)
            {
                if (ImapResponseParser.equalsIgnoreCase(response.get(1), ""EXISTS""))
                {
                    mMessageCount = response.getNumber(0);
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Got untagged EXISTS with value "" + mMessageCount + "" for "" + getLogId());
                }
                handlePossibleUidNext(response);

                if (ImapResponseParser.equalsIgnoreCase(response.get(1), ""EXPUNGE"") && mMessageCount > 0)
                {
                    mMessageCount--;
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Got untagged EXPUNGE with mMessageCount "" + mMessageCount + "" for "" + getLogId());
                }
//            if (response.size() > 1) {
//                Object bracketedObj = response.get(1);
//                if (bracketedObj instanceof ImapList)
//                {
//                    ImapList bracketed = (ImapList)bracketedObj;
//
//                    if (bracketed.size() > 0)
//                    {
//                        Object keyObj = bracketed.get(0);
//                        if (keyObj instanceof String)
//                        {
//                            String key = (String)keyObj;
//                            if (""ALERT"".equalsIgnoreCase(key))
//                            {
//                                StringBuffer sb = new StringBuffer();
//                                for (int i = 2, count = response.size(); i < count; i++) {
//                                    sb.append(response.get(i).toString());
//                                    sb.append(' ');
//                                }
//
//                                Log.w(K9.LOG_TAG, ""ALERT: "" + sb.toString() + "" for "" + getLogId());
//                            }
//                        }
//                    }
//
//
//                }
//            }
            }
            //Log.i(K9.LOG_TAG, ""mMessageCount = "" + mMessageCount + "" for "" + getLogId());
        }

        private void parseBodyStructure(ImapList bs, Part part, String id)
        throws MessagingException
        {
            if (bs.get(0) instanceof ImapList)
            {
                /*
                 * This is a multipart/*
                 */
                MimeMultipart mp = new MimeMultipart();
                for (int i = 0, count = bs.size(); i < count; i++)
                {
                    if (bs.get(i) instanceof ImapList)
                    {
                        /*
                         * For each part in the message we're going to add a new BodyPart and parse
                         * into it.
                         */
                        ImapBodyPart bp = new ImapBodyPart();
                        if (id.equalsIgnoreCase(""TEXT""))
                        {
                            parseBodyStructure(bs.getList(i), bp, Integer.toString(i + 1));
                        }
                        else
                        {
                            parseBodyStructure(bs.getList(i), bp, id + ""."" + (i + 1));
                        }
                        mp.addBodyPart(bp);
                    }
                    else
                    {
                        /*
                         * We've got to the end of the children of the part, so now we can find out
                         * what type it is and bail out.
                         */
                        String subType = bs.getString(i);
                        mp.setSubType(subType.toLowerCase());
                        break;
                    }
                }
                part.setBody(mp);
            }
            else
            {
                /*
                 * This is a body. We need to add as much information as we can find out about
                 * it to the Part.
                 */

                /*
                 body type
                 body subtype
                 body parameter parenthesized list
                 body id
                 body description
                 body encoding
                 body size
                 */


                String type = bs.getString(0);
                String subType = bs.getString(1);
                String mimeType = (type + ""/"" + subType).toLowerCase();

                ImapList bodyParams = null;
                if (bs.get(2) instanceof ImapList)
                {
                    bodyParams = bs.getList(2);
                }
                String encoding = bs.getString(5);
                int size = bs.getNumber(6);

                if (MimeUtility.mimeTypeMatches(mimeType, ""message/rfc822""))
                {
//                  A body type of type MESSAGE and subtype RFC822
//                  contains, immediately after the basic fields, the
//                  envelope structure, body structure, and size in
//                  text lines of the encapsulated message.
//                    [MESSAGE, RFC822, [NAME, Fwd: [#HTR-517941]:  update plans at 1am Friday - Memory allocation - displayware.eml], NIL, NIL, 7BIT, 5974, NIL, [INLINE, [FILENAME*0, Fwd: [#HTR-517941]:  update plans at 1am Friday - Memory all, FILENAME*1, ocation - displayware.eml]], NIL]
                    /*
                     * This will be caught by fetch and handled appropriately.
                     */
                    throw new MessagingException(""BODYSTRUCTURE message/rfc822 not yet supported."");
                }

                /*
                 * Set the content type with as much information as we know right now.
                 */
                String contentType = String.format(""%s"", mimeType);

                if (bodyParams != null)
                {
                    /*
                     * If there are body params we might be able to get some more information out
                     * of them.
                     */
                    for (int i = 0, count = bodyParams.size(); i < count; i += 2)
                    {
                        contentType += String.format("";\n %s=\""%s\"""",
                                                     bodyParams.getString(i),
                                                     bodyParams.getString(i + 1));
                    }
                }

                part.setHeader(MimeHeader.HEADER_CONTENT_TYPE, contentType);

                // Extension items
                ImapList bodyDisposition = null;
                if ((""text"".equalsIgnoreCase(type))
                        && (bs.size() > 8)
                        && (bs.get(9) instanceof ImapList))
                {
                    bodyDisposition = bs.getList(9);
                }
                else if (!(""text"".equalsIgnoreCase(type))
                         && (bs.size() > 7)
                         && (bs.get(8) instanceof ImapList))
                {
                    bodyDisposition = bs.getList(8);
                }

                String contentDisposition = """";

                if (bodyDisposition != null && bodyDisposition.size() > 0)
                {
                    if (!""NIL"".equalsIgnoreCase(bodyDisposition.getString(0)))
                    {
                        contentDisposition = bodyDisposition.getString(0).toLowerCase();
                    }

                    if ((bodyDisposition.size() > 1)
                            && (bodyDisposition.get(1) instanceof ImapList))
                    {
                        ImapList bodyDispositionParams = bodyDisposition.getList(1);
                        /*
                         * If there is body disposition information we can pull some more information
                         * about the attachment out.
                         */
                        for (int i = 0, count = bodyDispositionParams.size(); i < count; i += 2)
                        {
                            contentDisposition += String.format("";\n %s=\""%s\"""",
                                                                bodyDispositionParams.getString(i).toLowerCase(),
                                                                bodyDispositionParams.getString(i + 1));
                        }
                    }
                }

                if (MimeUtility.getHeaderParameter(contentDisposition, ""size"") == null)
                {
                    contentDisposition += String.format("";\n size=%d"", size);
                }

                /*
                 * Set the content disposition containing at least the size. Attachment
                 * handling code will use this down the road.
                 */
                part.setHeader(MimeHeader.HEADER_CONTENT_DISPOSITION, contentDisposition);


                /*
                 * Set the Content-Transfer-Encoding header. Attachment code will use this
                 * to parse the body.
                 */
                part.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, encoding);

                if (part instanceof ImapMessage)
                {
                    ((ImapMessage) part).setSize(size);
                }
                else if (part instanceof ImapBodyPart)
                {
                    ((ImapBodyPart) part).setSize(size);
                }
                else
                {
                    throw new MessagingException(""Unknown part type "" + part.toString());
                }
                part.setHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA, id);
            }

        }

        /**
         * Appends the given messages to the selected folder. This implementation also determines
         * the new UID of the given message on the IMAP server and sets the Message's UID to the
         * new server UID.
         */
        @Override
        public void appendMessages(Message[] messages) throws MessagingException
        {
            checkOpen();
            try
            {
                for (Message message : messages)
                {
                    CountingOutputStream out = new CountingOutputStream();
                    EOLConvertingOutputStream eolOut = new EOLConvertingOutputStream(out);
                    message.writeTo(eolOut);
                    eolOut.flush();

                    mConnection.sendCommand(
                        String.format(""APPEND \""%s\"" (%s) {%d}"",
                                      encodeFolderName(getPrefixedName()),
                                      combineFlags(message.getFlags()),
                                      out.getCount()), false);
                    ImapResponse response;
                    do
                    {
                        response = mConnection.readResponse();
                        handleUntaggedResponse(response);
                        if (response.mCommandContinuationRequested)
                        {
                            eolOut = new EOLConvertingOutputStream(mConnection.mOut);
                            message.writeTo(eolOut);
                            eolOut.write('\r');
                            eolOut.write('\n');
                            eolOut.flush();
                        }
                        while (response.more());
                    }
                    while (response.mTag == null);

                    String newUid = getUidFromMessageId(message);
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Got UID "" + newUid + "" for message for "" + getLogId());

                    if (newUid != null)
                    {
                        message.setUid(newUid);
                    }


                }
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        @Override
        public String getUidFromMessageId(Message message) throws MessagingException
        {
            try
            {
                /*
                * Try to find the UID of the message we just appended using the
                * Message-ID header.
                */
                String[] messageIdHeader = message.getHeader(""Message-ID"");

                if (messageIdHeader == null || messageIdHeader.length == 0)
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Did not get a message-id in order to search for UID  for "" + getLogId());
                    return null;
                }
                String messageId = messageIdHeader[0];
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Looking for UID for message with message-id "" + messageId + "" for "" + getLogId());

                List<ImapResponse> responses =
                    executeSimpleCommand(
                        String.format(""UID SEARCH HEADER MESSAGE-ID %s"", messageId));
                for (ImapResponse response1 : responses)
                {
                    if (response1.mTag == null && ImapResponseParser.equalsIgnoreCase(response1.get(0), ""SEARCH"")
                            && response1.size() > 1)
                    {
                        return response1.getString(1);
                    }
                }
                return null;
            }
            catch (IOException ioe)
            {
                throw new MessagingException(""Could not find UID for message based on Message-ID"", ioe);
            }
        }


        @Override
        public void expunge() throws MessagingException
        {
            checkOpen();
            try
            {
                executeSimpleCommand(""EXPUNGE"");
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        private String combineFlags(Flag[] flags)
        {
            ArrayList<String> flagNames = new ArrayList<String>();
            for (Flag flag : flags)
            {
                if (flag == Flag.SEEN)
                {
                    flagNames.add(""\\Seen"");
                }
                else if (flag == Flag.DELETED)
                {
                    flagNames.add(""\\Deleted"");
                }
                else if (flag == Flag.ANSWERED)
                {
                    flagNames.add(""\\Answered"");
                }
                else if (flag == Flag.FLAGGED)
                {
                    flagNames.add(""\\Flagged"");
                }

            }
            return Utility.combine(flagNames.toArray(new String[flagNames.size()]), ' ');
        }


        @Override
        public void setFlags(Flag[] flags, boolean value)
        throws MessagingException
        {
            checkOpen();


            try
            {
                executeSimpleCommand(String.format(""UID STORE 1:* %sFLAGS.SILENT (%s)"",
                                                   value ? ""+"" : ""-"", combineFlags(flags)));
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        @Override
        public String getNewPushState(String oldPushStateS, Message message)
        {
            try
            {
                String messageUidS = message.getUid();
                int messageUid = Integer.parseInt(messageUidS);
                ImapPushState oldPushState = ImapPushState.parse(oldPushStateS);
                if (messageUid >= oldPushState.uidNext)
                {
                    int uidNext = messageUid + 1;
                    ImapPushState newPushState = new ImapPushState(uidNext);
                    return newPushState.toString();
                }
                else
                {
                    return null;
                }
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Exception while updated push state for "" + getLogId(), e);
                return null;
            }
        }


        @Override
        public void setFlags(Message[] messages, Flag[] flags, boolean value)
        throws MessagingException
        {
            checkOpen();
            String[] uids = new String[messages.length];
            for (int i = 0, count = messages.length; i < count; i++)
            {
                uids[i] = messages[i].getUid();
            }
            ArrayList<String> flagNames = new ArrayList<String>();
            for (Flag flag : flags)
            {
                if (flag == Flag.SEEN)
                {
                    flagNames.add(""\\Seen"");
                }
                else if (flag == Flag.DELETED)
                {
                    flagNames.add(""\\Deleted"");
                }
                else if (flag == Flag.ANSWERED)
                {
                    flagNames.add(""\\Answered"");
                }
                else if (flag == Flag.FLAGGED)
                {
                    flagNames.add(""\\Flagged"");
                }
            }
            try
            {
                executeSimpleCommand(String.format(""UID STORE %s %sFLAGS.SILENT (%s)"",
                                                   Utility.combine(uids, ','),
                                                   value ? ""+"" : ""-"",
                                                   Utility.combine(flagNames.toArray(new String[flagNames.size()]), ' ')));
            }
            catch (IOException ioe)
            {
                throw ioExceptionHandler(mConnection, ioe);
            }
        }

        private void checkOpen() throws MessagingException
        {
            if (!isOpen())
            {
                throw new MessagingException(""Folder "" + getPrefixedName() + "" is not open."");
            }
        }

        private MessagingException ioExceptionHandler(ImapConnection connection, IOException ioe)
        throws MessagingException
        {
            Log.e(K9.LOG_TAG, ""IOException for "" + getLogId(), ioe);
            if (connection != null)
            {
                connection.close();
            }
            close();
            return new MessagingException(""IO Error"", ioe);
        }

        @Override
        public boolean equals(Object o)
        {
            if (o instanceof ImapFolder)
            {
                return ((ImapFolder)o).getName().equalsIgnoreCase(getName());
            }
            return super.equals(o);
        }

        @Override
        public int hashCode()
        {
            return getName().hashCode();
        }

        protected ImapStore getStore()
        {
            return store;
        }

        protected String getLogId()
        {
            String id = getAccount().getDescription() + "":"" + getName() + ""/"" + Thread.currentThread().getName();
            if (mConnection != null)
            {
                id += ""/"" + mConnection.getLogId();
            }
            return id;
        }
    }

    /**
     * A cacheable class that stores the details for a single IMAP connection.
     */
    class ImapConnection
    {
        private Socket mSocket;
        private PeekableInputStream mIn;
        private OutputStream mOut;
        private ImapResponseParser mParser;
        private int mNextCommandTag;
        protected Set<String> capabilities = new HashSet<String>();

        private String getLogId()
        {
            return ""conn"" + hashCode();
        }

        private List<ImapResponse> receiveCapabilities(List<ImapResponse> responses)
        {
            for (ImapResponse response : responses)
            {
                ImapList capabilityList = null;
                if (response.size() > 0 && ImapResponseParser.equalsIgnoreCase(response.get(0), ""OK""))
                {
                    for (Object thisPart : response)
                    {
                        if (thisPart instanceof ImapList)
                        {
                            ImapList thisList = (ImapList)thisPart;
                            if (ImapResponseParser.equalsIgnoreCase(thisList.get(0), CAPABILITY_CAPABILITY))
                            {
                                capabilityList = thisList;
                                break;
                            }
                        }
                    }
                }
                else if (response.mTag == null)
                {
                    capabilityList = response;
                }

                if (capabilityList != null)
                {
                    if (capabilityList.size() > 0 && ImapResponseParser.equalsIgnoreCase(capabilityList.get(0), CAPABILITY_CAPABILITY))
                    {
                        if (K9.DEBUG)
                        {
                            Log.d(K9.LOG_TAG, ""Saving "" + capabilityList.size() + "" capabilities for "" + getLogId());
                        }
                        for (Object capability : capabilityList)
                        {
                            if (capability instanceof String)
                            {
//                                if (K9.DEBUG)
//                                {
//                                    Log.v(K9.LOG_TAG, ""Saving capability '"" + capability + ""' for "" + getLogId());
//                                }
                                capabilities.add(((String)capability).toUpperCase());
                            }
                        }

                    }
                }
            }
            return responses;
        }


        public void open() throws IOException, MessagingException
        {
            if (isOpen())
            {
                return;
            }

            boolean authSuccess = false;

            mNextCommandTag = 1;
            try
            {
                Security.setProperty(""networkaddress.cache.ttl"", ""0"");
            }
            catch (Exception e)
            {
                Log.w(K9.LOG_TAG, ""Could not set DNS ttl to 0 for "" + getLogId(), e);
            }

            try
            {

                SocketAddress socketAddress = new InetSocketAddress(mHost, mPort);

                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Connection "" + getLogId() + "" connecting to "" + mHost + "" @ IP addr "" + socketAddress);

                if (mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
                        mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL)
                {
                    SSLContext sslContext = SSLContext.getInstance(""TLS"");
                    final boolean secure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
                    sslContext.init(null, new TrustManager[]
                                    {
                                        TrustManagerFactory.get(mHost, secure)
                                    }, new SecureRandom());
                    mSocket = sslContext.getSocketFactory().createSocket();
                    mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                }
                else
                {
                    mSocket = new Socket();
                    mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
                }

                setReadTimeout(Store.SOCKET_READ_TIMEOUT);

                mIn = new PeekableInputStream(new BufferedInputStream(mSocket.getInputStream(),
                                              1024));
                mParser = new ImapResponseParser(mIn);
                mOut = mSocket.getOutputStream();

                capabilities.clear();
                ImapResponse nullResponse = mParser.readResponse();
                if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
                    Log.v(K9.LOG_TAG, getLogId() + ""<<<"" + nullResponse);

                List<ImapResponse> nullResponses = new LinkedList<ImapResponse>();
                nullResponses.add(nullResponse);
                receiveCapabilities(nullResponses);

                if (!hasCapability(CAPABILITY_CAPABILITY))
                {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Did not get capabilities in banner, requesting CAPABILITY for "" + getLogId());
                    List<ImapResponse> responses = receiveCapabilities(executeSimpleCommand(COMMAND_CAPABILITY));
                    if (responses.size() != 2)
                    {
                        throw new MessagingException(""Invalid CAPABILITY response received"");
                    }
                }

                if (mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL
                        || mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED)
                {

                    if (hasCapability(""STARTTLS""))
                    {
                        // STARTTLS
                        executeSimpleCommand(""STARTTLS"");

                        SSLContext sslContext = SSLContext.getInstance(""TLS"");
                        boolean secure = mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED;
                        sslContext.init(null, new TrustManager[]
                                        {
                                            TrustManagerFactory.get(mHost, secure)
                                        }, new SecureRandom());
                        mSocket = sslContext.getSocketFactory().createSocket(mSocket, mHost, mPort,
                                  true);
                        mSocket.setSoTimeout(Store.SOCKET_READ_TIMEOUT);
                        mIn = new PeekableInputStream(new BufferedInputStream(mSocket
                                                      .getInputStream(), 1024));
                        mParser = new ImapResponseParser(mIn);
                        mOut = mSocket.getOutputStream();
                    }
                    else if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED)
                    {
                        throw new MessagingException(""TLS not supported but required"");
                    }
                }

                mOut = new BufferedOutputStream(mOut, 1024);

                try
                {
                    // Yahoo! requires a custom IMAP command to work right over a non-3G network
                    if (mHost.endsWith(""yahoo.com""))
                    {
                        if (K9.DEBUG)
                            Log.v(K9.LOG_TAG, ""Found Yahoo! account.  Sending proprietary commands."");
                        executeSimpleCommand(""ID (\""GUID\"" \""1\"")"");
                    }
                    if (mAuthType == AuthType.CRAM_MD5)
                    {
                        authCramMD5();
                        // The authCramMD5 method called on the previous line does not allow for handling updated capabilities
                        // sent by the server.  So, to make sure we update to the post-authentication capability list
                        // we fetch the capabilities here.
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Updating capabilities after CRAM-MD5 authentication for "" + getLogId());
                        List<ImapResponse> responses = receiveCapabilities(executeSimpleCommand(COMMAND_CAPABILITY));
                        if (responses.size() != 2)
                        {
                            throw new MessagingException(""Invalid CAPABILITY response received"");
                        }

                    }
                    else if (mAuthType == AuthType.PLAIN)
                    {
                        receiveCapabilities(executeSimpleCommand(""LOGIN \"""" + escapeString(mUsername) + ""\"" \"""" + escapeString(mPassword) + ""\"""", true));
                    }
                    authSuccess = true;
                }
                catch (ImapException ie)
                {
                    throw new AuthenticationFailedException(ie.getAlertText(), ie);

                }
                catch (MessagingException me)
                {
                    throw new AuthenticationFailedException(null, me);
                }
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, CAPABILITY_COMPRESS_DEFLATE + "" = "" + hasCapability(CAPABILITY_COMPRESS_DEFLATE));
                }
                if (hasCapability(CAPABILITY_COMPRESS_DEFLATE))
                {
                    ConnectivityManager connectivityManager = (ConnectivityManager)K9.app.getSystemService(Context.CONNECTIVITY_SERVICE);
                    boolean useCompression = true;

                    NetworkInfo netInfo = connectivityManager.getActiveNetworkInfo();
                    if (netInfo != null)
                    {
                        int type = netInfo.getType();
                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""On network type "" + type);
                        useCompression = mAccount.useCompression(type);

                    }
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""useCompression "" + useCompression);
                    if (useCompression)
                    {
                        try
                        {
                            executeSimpleCommand(COMMAND_COMPRESS_DEFLATE);
                            ZInputStream zInputStream = new ZInputStream(mSocket.getInputStream(), true);
                            zInputStream.setFlushMode(JZlib.Z_PARTIAL_FLUSH);
                            mIn = new PeekableInputStream(new BufferedInputStream(zInputStream, 1024));
                            mParser = new ImapResponseParser(mIn);
                            ZOutputStream zOutputStream = new ZOutputStream(mSocket.getOutputStream(), JZlib.Z_BEST_SPEED, true);
                            mOut = new BufferedOutputStream(zOutputStream, 1024);
                            zOutputStream.setFlushMode(JZlib.Z_PARTIAL_FLUSH);
                            if (K9.DEBUG)
                            {
                                Log.i(K9.LOG_TAG, ""Compression enabled for "" + getLogId());
                            }
                        }
                        catch (Exception e)
                        {
                            Log.e(K9.LOG_TAG, ""Unable to negotiate compression"", e);
                        }
                    }
                }


                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""NAMESPACE = "" + hasCapability(CAPABILITY_NAMESPACE)
                          + "", mPathPrefix = "" + mPathPrefix);

                if (mPathPrefix == null)
                {
                    if (hasCapability(CAPABILITY_NAMESPACE))
                    {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""mPathPrefix is unset and server has NAMESPACE capability"");
                        List<ImapResponse> namespaceResponses =
                            executeSimpleCommand(COMMAND_NAMESPACE);
                        for (ImapResponse response : namespaceResponses)
                        {
                            if (ImapResponseParser.equalsIgnoreCase(response.get(0), COMMAND_NAMESPACE))
                            {
                                if (K9.DEBUG)
                                    Log.d(K9.LOG_TAG, ""Got NAMESPACE response "" + response + "" on "" + getLogId());

                                Object personalNamespaces = response.get(1);
                                if (personalNamespaces != null && personalNamespaces instanceof ImapList)
                                {
                                    if (K9.DEBUG)
                                        Log.d(K9.LOG_TAG, ""Got personal namespaces: "" + personalNamespaces);
                                    ImapList bracketed = (ImapList)personalNamespaces;
                                    Object firstNamespace = bracketed.get(0);
                                    if (firstNamespace != null && firstNamespace instanceof ImapList)
                                    {
                                        if (K9.DEBUG)
                                            Log.d(K9.LOG_TAG, ""Got first personal namespaces: "" + firstNamespace);
                                        bracketed = (ImapList)firstNamespace;
                                        mPathPrefix = bracketed.getString(0);
                                        mPathDelimeter = bracketed.getString(1);
                                        mCombinedPrefix = null;
                                        if (K9.DEBUG)
                                            Log.d(K9.LOG_TAG, ""Got path '"" + mPathPrefix + ""' and separator '"" + mPathDelimeter + ""'"");
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""mPathPrefix is unset but server does not have NAMESPACE capability"");
                        mPathPrefix = """";
                    }
                }
                if (mPathDelimeter == null)
                {
                    try
                    {
                        List<ImapResponse> nameResponses =
                            executeSimpleCommand(String.format(""LIST \""\"" \""\""""));
                        for (ImapResponse response : nameResponses)
                        {
                            if (ImapResponseParser.equalsIgnoreCase(response.get(0), ""LIST""))
                            {
                                mPathDelimeter = response.getString(2);
                                mCombinedPrefix = null;
                                if (K9.DEBUG)
                                    Log.d(K9.LOG_TAG, ""Got path delimeter '"" + mPathDelimeter + ""' for "" + getLogId());
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        Log.e(K9.LOG_TAG, ""Unable to get path delimeter using LIST"", e);
                    }
                }


            }
            catch (SSLException e)
            {
                throw new CertificateValidationException(e.getMessage(), e);
            }
            catch (GeneralSecurityException gse)
            {
                throw new MessagingException(
                    ""Unable to open connection to IMAP server due to security error."", gse);
            }
            catch (ConnectException ce)
            {
                String ceMess = ce.getMessage();
                String[] tokens = ceMess.split(""-"");
                if (tokens != null && tokens.length > 1 && tokens[1] != null)
                {
                    Log.e(K9.LOG_TAG, ""Stripping host/port from ConnectionException for "" + getLogId(), ce);
                    throw new ConnectException(tokens[1].trim());
                }
                else
                {
                    throw ce;
                }
            }
            finally
            {
                if (!authSuccess)
                {
                    Log.e(K9.LOG_TAG, ""Failed to login, closing connection for "" + getLogId());
                    close();
                }
            }
        }

        protected void authCramMD5() throws AuthenticationFailedException, MessagingException
        {
            try
            {
                String tag = sendCommand(""AUTHENTICATE CRAM-MD5"", false);
                byte[] buf = new byte[ 1024 ];
                int b64NonceLen = 0;
                for (int i = 0; i < buf.length; i++)
                {
                    buf[ i ] = (byte)mIn.read();
                    if (buf[i] == 0x0a)
                    {
                        b64NonceLen = i;
                        break;
                    }
                }
                if (b64NonceLen == 0)
                {
                    throw new AuthenticationFailedException(""Error negotiating CRAM-MD5: nonce too long."");
                }
                byte[] b64NonceTrim = new byte[ b64NonceLen - 2 ];
                System.arraycopy(buf, 1, b64NonceTrim, 0, b64NonceLen - 2);
                byte[] nonce = Base64.decodeBase64(b64NonceTrim);
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Got nonce: "" + new String(b64NonceTrim, ""US-ASCII""));
                    Log.d(K9.LOG_TAG, ""Plaintext nonce: "" + new String(nonce, ""US-ASCII""));
                }

                byte[] ipad = new byte[64];
                byte[] opad = new byte[64];
                byte[] secretBytes = mPassword.getBytes(""US-ASCII"");
                MessageDigest md = MessageDigest.getInstance(""MD5"");
                if (secretBytes.length > 64)
                {
                    secretBytes = md.digest(secretBytes);
                }
                System.arraycopy(secretBytes, 0, ipad, 0, secretBytes.length);
                System.arraycopy(secretBytes, 0, opad, 0, secretBytes.length);
                for (int i = 0; i < ipad.length; i++) ipad[i] ^= 0x36;
                for (int i = 0; i < opad.length; i++) opad[i] ^= 0x5c;
                md.update(ipad);
                byte[] firstPass = md.digest(nonce);
                md.update(opad);
                byte[] result = md.digest(firstPass);
                String plainCRAM = mUsername + "" "" + new String(Hex.encodeHex(result));
                byte[] b64CRAM = Base64.encodeBase64(plainCRAM.getBytes(""US-ASCII""));
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Username == "" + mUsername);
                    Log.d(K9.LOG_TAG, ""plainCRAM: "" + plainCRAM);
                    Log.d(K9.LOG_TAG, ""b64CRAM: "" + new String(b64CRAM, ""US-ASCII""));
                }

                mOut.write(b64CRAM);
                mOut.write(new byte[] { 0x0d, 0x0a });
                mOut.flush();
                int respLen = 0;
                for (int i = 0; i < buf.length; i++)
                {
                    buf[ i ] = (byte)mIn.read();
                    if (buf[i] == 0x0a)
                    {
                        respLen = i;
                        break;
                    }
                }
                String toMatch = tag + "" OK"";
                String respStr = new String(buf, 0, respLen);
                if (!respStr.startsWith(toMatch))
                {
                    throw new AuthenticationFailedException(""CRAM-MD5 error: "" + respStr);
                }
            }
            catch (IOException ioe)
            {
                throw new AuthenticationFailedException(""CRAM-MD5 Auth Failed."");
            }
            catch (NoSuchAlgorithmException nsae)
            {
                throw new AuthenticationFailedException(""MD5 Not Available."");
            }
        }

        protected void setReadTimeout(int millis) throws SocketException
        {
            Socket sock = mSocket;
            if (sock != null)
            {
                sock.setSoTimeout(millis);
            }
        }

        protected boolean isIdleCapable()
        {
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""Connection "" + getLogId() + "" has "" + capabilities.size() + "" capabilities"");

            return capabilities.contains(CAPABILITY_IDLE);
        }

        protected boolean hasCapability(String capability)
        {
            return capabilities.contains(capability.toUpperCase());
        }

        private boolean isOpen()
        {
            return (mIn != null && mOut != null && mSocket != null && mSocket.isConnected() && !mSocket.isClosed());
        }

        private void close()
        {
//            if (isOpen()) {
//                try {
//                    executeSimpleCommand(""LOGOUT"");
//                } catch (Exception e) {
//
//                }
//            }
            try
            {
                mIn.close();
            }
            catch (Exception e)
            {

            }
            try
            {
                mOut.close();
            }
            catch (Exception e)
            {

            }
            try
            {
                mSocket.close();
            }
            catch (Exception e)
            {

            }
            mIn = null;
            mOut = null;
            mSocket = null;
        }

        private ImapResponse readResponse() throws IOException, MessagingException
        {
            return readResponse(null);
        }

        private ImapResponse readResponse(ImapResponseParser.IImapResponseCallback callback) throws IOException, MessagingException
        {
            try
            {
                ImapResponse response = mParser.readResponse(callback);
                if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
                    Log.v(K9.LOG_TAG, getLogId() + ""<<<"" + response);

                return response;
            }
            catch (IOException ioe)
            {
                close();
                throw ioe;
            }
        }

        private String escapeString(String in)
        {
            if (in == null)
            {
                return null;
            }
            String out = in.replaceAll(""\\\\"", ""\\\\\\\\"");
            out = out.replaceAll(""\"""", ""\\\\\"""");
            return out;
        }

        private void sendContinuation(String continuation) throws IOException
        {
            mOut.write(continuation.getBytes());
            mOut.write('\r');
            mOut.write('\n');
            mOut.flush();

            if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
                Log.v(K9.LOG_TAG, getLogId() + "">>> "" + continuation);

        }

        public String sendCommand(String command, boolean sensitive)
        throws MessagingException, IOException
        {
            try
            {
                open();
                String tag = Integer.toString(mNextCommandTag++);
                String commandToSend = tag + "" "" + command;
                mOut.write(commandToSend.getBytes());
                mOut.write('\r');
                mOut.write('\n');
                mOut.flush();

                if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
                {
                    if (sensitive && !K9.DEBUG_SENSITIVE)
                    {
                        Log.v(K9.LOG_TAG, getLogId() + "">>> ""
                              + ""[Command Hidden, Enable Sensitive Debug Logging To Show]"");
                    }
                    else
                    {
                        Log.v(K9.LOG_TAG, getLogId() + "">>> "" + commandToSend);
                    }
                }

                return tag;
            }
            catch (IOException ioe)
            {
                close();
                throw ioe;
            }
            catch (ImapException ie)
            {
                close();
                throw ie;
            }
            catch (MessagingException me)
            {
                close();
                throw me;
            }
        }

        public List<ImapResponse> executeSimpleCommand(String command) throws IOException,
                    ImapException, MessagingException
        {
            return executeSimpleCommand(command, false);
        }

        public List<ImapResponse> executeSimpleCommand(String command, boolean sensitive) throws IOException,
                    ImapException, MessagingException
        {
            return executeSimpleCommand(command, sensitive, null);
        }

        private List<ImapResponse> executeSimpleCommand(String command, boolean sensitive, UntaggedHandler untaggedHandler)
        throws IOException, ImapException, MessagingException
        {
            String commandToLog = command;
            if (sensitive && !K9.DEBUG_SENSITIVE)
            {
                commandToLog = ""*sensitive*"";
            }


            //if (K9.DEBUG)
            //    Log.v(K9.LOG_TAG, ""Sending IMAP command "" + commandToLog + "" on connection "" + getLogId());

            String tag = sendCommand(command, sensitive);
            //if (K9.DEBUG)
            //    Log.v(K9.LOG_TAG, ""Sent IMAP command "" + commandToLog + "" with tag "" + tag + "" for "" + getLogId());

            ArrayList<ImapResponse> responses = new ArrayList<ImapResponse>();
            ImapResponse response;
            do
            {
                response = mParser.readResponse();
                if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
                    Log.v(K9.LOG_TAG, getLogId() + ""<<<"" + response);

                if (response.mTag != null && !response.mTag.equalsIgnoreCase(tag))
                {
                    Log.w(K9.LOG_TAG, ""After sending tag "" + tag + "", got tag response from previous command "" + response + "" for "" + getLogId());
                    Iterator<ImapResponse> iter = responses.iterator();
                    while (iter.hasNext())
                    {
                        ImapResponse delResponse = iter.next();
                        if (delResponse.mTag != null || delResponse.size() < 2
                                || (!ImapResponseParser.equalsIgnoreCase(delResponse.get(1), ""EXISTS"") && !ImapResponseParser.equalsIgnoreCase(delResponse.get(1), ""EXPUNGE"")))
                        {
                            iter.remove();
                        }
                    }
                    response.mTag = null;
                    continue;
                }
                if (untaggedHandler != null)
                {
                    untaggedHandler.handleAsyncUntaggedResponse(response);
                }
                responses.add(response);
            }
            while (response.mTag == null);
            if (response.size() < 1 || !ImapResponseParser.equalsIgnoreCase(response.get(0), ""OK""))
            {
                throw new ImapException(""Command: "" + commandToLog + ""; response: "" + response.toString(), response.getAlertText());
            }
            return responses;
        }
    }

    class ImapMessage extends MimeMessage
    {
        ImapMessage(String uid, Folder folder)
        {
            this.mUid = uid;
            this.mFolder = folder;
        }

        public void setSize(int size)
        {
            this.mSize = size;
        }

        @Override
        public void parse(InputStream in) throws IOException, MessagingException
        {
            super.parse(in);
        }

        public void setFlagInternal(Flag flag, boolean set) throws MessagingException
        {
            super.setFlag(flag, set);
        }


        @Override
        public void setFlag(Flag flag, boolean set) throws MessagingException
        {
            super.setFlag(flag, set);
            mFolder.setFlags(new Message[] { this }, new Flag[] { flag }, set);
        }

        @Override
        public void delete(String trashFolderName) throws MessagingException
        {
            getFolder().delete(new Message[] { this }, trashFolderName);
        }
    }

    class ImapBodyPart extends MimeBodyPart
    {
        public ImapBodyPart() throws MessagingException
        {
            super();
        }

        public void setSize(int size)
        {
            this.mSize = size;
        }
    }

    class ImapException extends MessagingException
    {
        String mAlertText;

        public ImapException(String message, String alertText, Throwable throwable)
        {
            super(message, throwable);
            this.mAlertText = alertText;
        }

        public ImapException(String message, String alertText)
        {
            super(message);
            this.mAlertText = alertText;
        }

        public String getAlertText()
        {
            return mAlertText;
        }

        public void setAlertText(String alertText)
        {
            mAlertText = alertText;
        }
    }

    public class ImapFolderPusher extends ImapFolder implements UntaggedHandler
    {
        final PushReceiver receiver;
        Thread listeningThread = null;
        final AtomicBoolean stop = new AtomicBoolean(false);
        final AtomicBoolean idling = new AtomicBoolean(false);
        final AtomicBoolean doneSent = new AtomicBoolean(false);
        final AtomicInteger delayTime = new AtomicInteger(NORMAL_DELAY_TIME);
        final AtomicInteger idleFailureCount = new AtomicInteger(0);
        final AtomicBoolean needsPoll = new AtomicBoolean(false);
        List<ImapResponse> storedUntaggedResponses = new ArrayList<ImapResponse>();
        TracingWakeLock wakeLock = null;

        public ImapFolderPusher(ImapStore store, String name, PushReceiver nReceiver)
        {
            super(store, name);
            receiver = nReceiver;
            TracingPowerManager pm = TracingPowerManager.getPowerManager(receiver.getContext());
            wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""ImapFolderPusher "" + store.getAccount().getDescription() + "":"" + getName());
            wakeLock.setReferenceCounted(false);

        }
        public void refresh() throws IOException, MessagingException
        {
            if (idling.get())
            {
                wakeLock.acquire(K9.PUSH_WAKE_LOCK_TIMEOUT);
                sendDone();
            }
        }

        private void sendDone() throws IOException, MessagingException
        {
            if (doneSent.compareAndSet(false, true))
            {
                ImapConnection conn = mConnection;
                if (conn != null)
                {
                    conn.setReadTimeout(Store.SOCKET_READ_TIMEOUT);
                    sendContinuation(""DONE"");
                }

            }
        }

        private void sendContinuation(String continuation)
        throws MessagingException, IOException
        {
            ImapConnection conn = mConnection;
            if (conn != null)
            {
                conn.sendContinuation(continuation);
            }
        }

        public void start()
        {
            Runnable runner = new Runnable()
            {
                public void run()
                {
                    wakeLock.acquire(K9.PUSH_WAKE_LOCK_TIMEOUT);
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Pusher starting for "" + getLogId());

                    while (!stop.get())
                    {
                        try
                        {
                            int oldUidNext = -1;
                            try
                            {
                                String pushStateS = receiver.getPushState(getName());
                                ImapPushState pushState = ImapPushState.parse(pushStateS);
                                oldUidNext = pushState.uidNext;
                                if (K9.DEBUG)
                                    Log.i(K9.LOG_TAG, ""Got oldUidNext "" + oldUidNext + "" for "" + getLogId());
                            }
                            catch (Exception e)
                            {
                                Log.e(K9.LOG_TAG, ""Unable to get oldUidNext for "" + getLogId(), e);
                            }
                            ImapConnection oldConnection = mConnection;
                            internalOpen(OpenMode.READ_ONLY);
                            ImapConnection conn = mConnection;
                            if (conn == null)
                            {
                                receiver.pushError(""Could not establish connection for IDLE"", null);
                                throw new MessagingException(""Could not establish connection for IDLE"");

                            }
                            if (!conn.isIdleCapable())
                            {
                                stop.set(true);
                                receiver.pushError(""IMAP server is not IDLE capable: "" + conn.toString(), null);
                                throw new MessagingException(""IMAP server is not IDLE capable:"" + conn.toString());
                            }

                            if (!stop.get() && mAccount.isPushPollOnConnect() && (conn != oldConnection || needsPoll.getAndSet(false)))
                            {
                                List<ImapResponse> untaggedResponses = new ArrayList<ImapResponse>(storedUntaggedResponses);
                                storedUntaggedResponses.clear();
                                processUntaggedResponses(untaggedResponses);
                                if (mMessageCount == -1)
                                {
                                    throw new MessagingException(""Message count = -1 for idling"");
                                }
                                receiver.syncFolder(ImapFolderPusher.this);
                            }
                            if (stop.get())
                            {
                                continue;
                            }
                            int startUid = oldUidNext;

                            int newUidNext = uidNext;

                            if (newUidNext == -1)
                            {
                                if (K9.DEBUG)
                                {
                                    Log.d(K9.LOG_TAG, ""uidNext is -1, using search to find highest UID"");
                                }
                                int highestUid = getHighestUid();
                                if (highestUid != -1)
                                {
                                    if (K9.DEBUG)
                                        Log.d(K9.LOG_TAG, ""highest UID = "" + highestUid);
                                    newUidNext = highestUid + 1;
                                    if (K9.DEBUG)
                                        Log.d(K9.LOG_TAG, ""highest UID = "" + highestUid
                                              + "", set newUidNext to "" + newUidNext);
                                }
                            }

                            if (startUid < newUidNext - mAccount.getDisplayCount())
                            {
                                startUid = newUidNext - mAccount.getDisplayCount();
                            }
                            if (startUid < 1)
                            {
                                startUid = 1;
                            }
                            if (newUidNext > startUid)
                            {

                                if (K9.DEBUG)
                                    Log.i(K9.LOG_TAG, ""Needs sync from uid "" + startUid  + "" to "" + newUidNext + "" for "" + getLogId());
                                List<Message> messages = new ArrayList<Message>();
                                for (int uid = startUid; uid < newUidNext; uid++)
                                {
                                    ImapMessage message = new ImapMessage("""" + uid, ImapFolderPusher.this);
                                    messages.add(message);
                                }
                                if (messages.size() > 0)
                                {
                                    pushMessages(messages, true);
                                }

                            }
                            else
                            {
                                List<ImapResponse> untaggedResponses = null;
                                while (storedUntaggedResponses.size() > 0)
                                {
                                    if (K9.DEBUG)
                                        Log.i(K9.LOG_TAG, ""Processing "" + storedUntaggedResponses.size() + "" untagged responses from previous commands for "" + getLogId());
                                    untaggedResponses = new ArrayList<ImapResponse>(storedUntaggedResponses);
                                    storedUntaggedResponses.clear();
                                    processUntaggedResponses(untaggedResponses);
                                }

                                if (K9.DEBUG)
                                    Log.i(K9.LOG_TAG, ""About to IDLE for "" + getLogId());

                                receiver.setPushActive(getName(), true);
                                idling.set(true);
                                doneSent.set(false);

                                if (conn == null)
                                {
                                    throw new MessagingException(""No connection available for idling"");
                                }
                                conn.setReadTimeout((getAccount().getIdleRefreshMinutes() * 60 * 1000) + IDLE_READ_TIMEOUT_INCREMENT);
                                untaggedResponses = executeSimpleCommand(COMMAND_IDLE, false, ImapFolderPusher.this);
                                idling.set(false);
                                delayTime.set(NORMAL_DELAY_TIME);
                                idleFailureCount.set(0);
                            }
                        }
                        catch (Exception e)
                        {
                            wakeLock.acquire(K9.PUSH_WAKE_LOCK_TIMEOUT);
                            storedUntaggedResponses.clear();
                            idling.set(false);
                            receiver.setPushActive(getName(), false);
                            try
                            {
                                close();
                            }
                            catch (Exception me)
                            {
                                Log.e(K9.LOG_TAG, ""Got exception while closing for exception for "" + getLogId(), me);
                            }
                            if (stop.get())
                            {
                                Log.i(K9.LOG_TAG, ""Got exception while idling, but stop is set for "" + getLogId());
                            }
                            else
                            {
                                receiver.pushError(""Push error for "" + getName(), e);
                                Log.e(K9.LOG_TAG, ""Got exception while idling for "" + getLogId(), e);
                                int delayTimeInt = delayTime.get();
                                receiver.sleep(wakeLock, delayTimeInt);
                                delayTimeInt *= 2;
                                if (delayTimeInt > MAX_DELAY_TIME)
                                {
                                    delayTimeInt = MAX_DELAY_TIME;
                                }
                                delayTime.set(delayTimeInt);
                                if (idleFailureCount.incrementAndGet() > IDLE_FAILURE_COUNT_LIMIT)
                                {
                                    Log.e(K9.LOG_TAG, ""Disabling pusher for "" + getLogId() + "" after "" + idleFailureCount.get() + "" consecutive errors"");
                                    receiver.pushError(""Push disabled for "" + getName() + "" after "" + idleFailureCount.get() + "" consecutive errors"", e);
                                    stop.set(true);
                                }

                            }
                        }
                    }
                    receiver.setPushActive(getName(), false);
                    try
                    {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Pusher for "" + getLogId() + "" is exiting"");
                        close();
                    }
                    catch (Exception me)
                    {
                        Log.e(K9.LOG_TAG, ""Got exception while closing for "" + getLogId(), me);
                    }
                    finally
                    {
                        wakeLock.release();
                    }
                }
            };
            listeningThread = new Thread(runner);
            listeningThread.start();
        }

        @Override
        protected void handleUntaggedResponse(ImapResponse response)
        {
            if (response.mTag == null && response.size() > 1)
            {
                Object responseType = response.get(1);
                if (ImapResponseParser.equalsIgnoreCase(responseType, ""FETCH"")
                        || ImapResponseParser.equalsIgnoreCase(responseType, ""EXPUNGE"")
                        || ImapResponseParser.equalsIgnoreCase(responseType, ""EXISTS""))
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Storing response "" + response + "" for later processing"");

                    storedUntaggedResponses.add(response);
                }
                handlePossibleUidNext(response);
            }
        }

        protected void processUntaggedResponses(List<ImapResponse> responses) throws MessagingException
        {
            boolean skipSync = false;
            int oldMessageCount = mMessageCount;
            if (oldMessageCount == -1)
            {
                skipSync = true;
            }
            List<Integer> flagSyncMsgSeqs = new ArrayList<Integer>();
            List<String> removeMsgUids = new LinkedList<String>();

            for (ImapResponse response : responses)
            {
                oldMessageCount += processUntaggedResponse(oldMessageCount, response, flagSyncMsgSeqs, removeMsgUids);
            }
            if (!skipSync)
            {
                if (oldMessageCount < 0)
                {
                    oldMessageCount = 0;
                }
                if (mMessageCount > oldMessageCount)
                {
                    syncMessages(mMessageCount, true);
                }
            }
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""UIDs for messages needing flag sync are "" + flagSyncMsgSeqs + ""  for "" + getLogId());

            if (flagSyncMsgSeqs.size() > 0)
            {
                syncMessages(flagSyncMsgSeqs);
            }
            if (removeMsgUids.size() > 0)
            {
                removeMessages(removeMsgUids);
            }
        }

        private void syncMessages(int end, boolean newArrivals) throws MessagingException
        {
            int oldUidNext = -1;
            try
            {
                String pushStateS = receiver.getPushState(getName());
                ImapPushState pushState = ImapPushState.parse(pushStateS);
                oldUidNext = pushState.uidNext;
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Got oldUidNext "" + oldUidNext + "" for "" + getLogId());
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Unable to get oldUidNext for "" + getLogId(), e);
            }

            Message[] messageArray = getMessages(end, end, null, true, null);
            if (messageArray != null && messageArray.length > 0)
            {
                int newUid = Integer.parseInt(messageArray[0].getUid());
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Got newUid "" + newUid + "" for message "" + end + "" on "" + getLogId());
                int startUid = oldUidNext;
                if (startUid < newUid - 10)
                {
                    startUid = newUid - 10;
                }
                if (startUid < 1)
                {
                    startUid = 1;
                }
                if (newUid >= startUid)
                {

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Needs sync from uid "" + startUid  + "" to "" + newUid + "" for "" + getLogId());
                    List<Message> messages = new ArrayList<Message>();
                    for (int uid = startUid; uid <= newUid; uid++)
                    {
                        ImapMessage message = new ImapMessage("""" + uid, ImapFolderPusher.this);
                        messages.add(message);
                    }
                    if (messages.size() > 0)
                    {
                        pushMessages(messages, true);
                    }
                }
            }
        }

        private void syncMessages(List<Integer> flagSyncMsgSeqs)
        {
            try
            {
                Message[] messageArray = null;

                messageArray = getMessages(flagSyncMsgSeqs, true, null);

                List<Message> messages = new ArrayList<Message>();
                for (Message message : messageArray)
                {
                    messages.add(message);
                }
                pushMessages(messages, false);

            }
            catch (Exception e)
            {
                receiver.pushError(""Exception while processing Push untagged responses"", e);
            }
        }

        private void removeMessages(List<String> removeUids)
        {
            List<Message> messages = new ArrayList<Message>(removeUids.size());

            try
            {
                Message[] existingMessages = getMessagesFromUids(removeUids, true, null);
                for (Message existingMessage : existingMessages)
                {
                    needsPoll.set(true);
                    msgSeqUidMap.clear();
                    String existingUid = existingMessage.getUid();
                    Log.w(K9.LOG_TAG, ""Message with UID "" + existingUid + "" still exists on server, not expunging"");
                    removeUids.remove(existingUid);
                }
                for (String uid : removeUids)
                {
                    ImapMessage message = new ImapMessage(uid, this);
                    try
                    {
                        message.setFlagInternal(Flag.DELETED, true);
                    }
                    catch (MessagingException me)
                    {
                        Log.e(K9.LOG_TAG, ""Unable to set DELETED flag on message "" + message.getUid());
                    }
                    messages.add(message);
                }
                receiver.messagesRemoved(this, messages);
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Cannot remove EXPUNGEd messages"", e);
            }

        }

        protected int processUntaggedResponse(int oldMessageCount, ImapResponse response, List<Integer> flagSyncMsgSeqs, List<String> removeMsgUids)
        {
            super.handleUntaggedResponse(response);
            int messageCountDelta = 0;
            if (response.mTag == null && response.size() > 1)
            {
                try
                {
                    Object responseType = response.get(1);
                    if (ImapResponseParser.equalsIgnoreCase(responseType, ""FETCH""))
                    {
                        Log.i(K9.LOG_TAG, ""Got FETCH "" + response);
                        int msgSeq = response.getNumber(0);

                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""Got untagged FETCH for msgseq "" + msgSeq + "" for "" + getLogId());

                        if (!flagSyncMsgSeqs.contains(msgSeq))
                        {
                            flagSyncMsgSeqs.add(msgSeq);
                        }
                    }
                    if (ImapResponseParser.equalsIgnoreCase(responseType, ""EXPUNGE""))
                    {
                        int msgSeq = response.getNumber(0);
                        if (msgSeq <= oldMessageCount)
                        {
                            messageCountDelta = -1;
                        }
                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""Got untagged EXPUNGE for msgseq "" + msgSeq + "" for "" + getLogId());

                        List<Integer> newSeqs = new ArrayList<Integer>();
                        Iterator<Integer> flagIter = flagSyncMsgSeqs.iterator();
                        while (flagIter.hasNext())
                        {
                            Integer flagMsg = flagIter.next();
                            if (flagMsg >= msgSeq)
                            {
                                flagIter.remove();
                                if (flagMsg > msgSeq)
                                {
                                    newSeqs.add(flagMsg--);
                                }
                            }
                        }
                        flagSyncMsgSeqs.addAll(newSeqs);


                        List<Integer> msgSeqs = new ArrayList<Integer>(msgSeqUidMap.keySet());
                        Collections.sort(msgSeqs);  // Have to do comparisons in order because of msgSeq reductions

                        for (Integer msgSeqNumI : msgSeqs)
                        {
                            if (K9.DEBUG)
                            {
                                Log.v(K9.LOG_TAG, ""Comparing EXPUNGEd msgSeq "" + msgSeq + "" to "" + msgSeqNumI);
                            }
                            int msgSeqNum = msgSeqNumI;
                            if (msgSeqNum == msgSeq)
                            {
                                String uid = msgSeqUidMap.get(msgSeqNum);
                                if (K9.DEBUG)
                                {
                                    Log.d(K9.LOG_TAG, ""Scheduling removal of UID "" + uid + "" because msgSeq "" + msgSeqNum + "" was expunged"");
                                }
                                removeMsgUids.add(uid);
                                msgSeqUidMap.remove(msgSeqNum);
                            }
                            else if (msgSeqNum > msgSeq)
                            {
                                String uid = msgSeqUidMap.get(msgSeqNum);
                                if (K9.DEBUG)
                                {
                                    Log.d(K9.LOG_TAG, ""Reducing msgSeq for UID "" + uid + "" from "" + msgSeqNum + "" to "" + (msgSeqNum - 1));
                                }
                                msgSeqUidMap.remove(msgSeqNum);
                                msgSeqUidMap.put(msgSeqNum-1, uid);
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Could not handle untagged FETCH for "" + getLogId(), e);
                }
            }
            return messageCountDelta;
        }


        private void pushMessages(List<Message> messages, boolean newArrivals)
        {
            RuntimeException holdException = null;
            try
            {
                if (newArrivals)
                {
                    receiver.messagesArrived(this, messages);
                }
                else
                {
                    receiver.messagesFlagsChanged(this, messages);
                }
            }
            catch (RuntimeException e)
            {
                holdException = e;
            }

            if (holdException != null)
            {
                throw holdException;
            }
        }

        public void stop()
        {
            stop.set(true);
            if (listeningThread != null)
            {
                listeningThread.interrupt();
            }
            ImapConnection conn = mConnection;
            if (conn != null)
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""Closing mConnection to stop pushing for "" + getLogId());
                conn.close();
            }
            else
            {
                Log.w(K9.LOG_TAG, ""Attempt to interrupt null mConnection to stop pushing on folderPusher for "" + getLogId());
            }
        }

        public void handleAsyncUntaggedResponse(ImapResponse response)
        {
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""Got async response: "" + response);

            if (stop.get())
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Got async untagged response: "" + response + "", but stop is set for "" + getLogId());

                try
                {
                    sendDone();
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Exception while sending DONE for "" + getLogId(), e);
                }
            }
            else
            {
                if (response.mTag == null)
                {
                    if (response.size() > 1)
                    {
                        boolean started = false;
                        Object responseType = response.get(1);
                        if (ImapResponseParser.equalsIgnoreCase(responseType, ""EXISTS"") || ImapResponseParser.equalsIgnoreCase(responseType, ""EXPUNGE"") ||
                                ImapResponseParser.equalsIgnoreCase(responseType,""FETCH""))
                        {
                            if (!started)
                            {
                                wakeLock.acquire(K9.PUSH_WAKE_LOCK_TIMEOUT);
                                started = true;
                            }

                            if (K9.DEBUG)
                                Log.d(K9.LOG_TAG, ""Got useful async untagged response: "" + response + "" for "" + getLogId());

                            try
                            {
                                sendDone();
                            }
                            catch (Exception e)
                            {
                                Log.e(K9.LOG_TAG, ""Exception while sending DONE for "" + getLogId(), e);
                            }
                        }
                    }
                    else if (response.mCommandContinuationRequested)
                    {
                        if (K9.DEBUG)
                            Log.d(K9.LOG_TAG, ""Idling "" + getLogId());

                        wakeLock.release();
                    }
                }
            }
        }
    }
    @Override
    public Pusher getPusher(PushReceiver receiver)
    {
        return new ImapPusher(this, receiver);
    }

    public class ImapPusher implements Pusher
    {
        final ImapStore mStore;
        final PushReceiver mReceiver;
        private long lastRefresh = -1;

        HashMap<String, ImapFolderPusher> folderPushers = new HashMap<String, ImapFolderPusher>();

        public ImapPusher(ImapStore store, PushReceiver receiver)
        {
            mStore = store;
            mReceiver = receiver;
        }

        public void start(List<String> folderNames)
        {
            stop();
            synchronized (folderPushers)
            {
                setLastRefresh(System.currentTimeMillis());
                for (String folderName : folderNames)
                {
                    ImapFolderPusher pusher = folderPushers.get(folderName);
                    if (pusher == null)
                    {
                        pusher = new ImapFolderPusher(mStore, folderName, mReceiver);
                        folderPushers.put(folderName, pusher);
                        pusher.start();
                    }
                }
            }
        }

        public void refresh()
        {
            synchronized (folderPushers)
            {
                for (ImapFolderPusher folderPusher : folderPushers.values())
                {
                    try
                    {
                        folderPusher.refresh();
                    }
                    catch (Exception e)
                    {
                        Log.e(K9.LOG_TAG, ""Got exception while refreshing for "" + folderPusher.getName(), e);
                    }
                }
            }
        }

        public void stop()
        {
            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""Requested stop of IMAP pusher"");

            synchronized (folderPushers)
            {
                for (ImapFolderPusher folderPusher : folderPushers.values())
                {
                    try
                    {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Requesting stop of IMAP folderPusher "" + folderPusher.getName());
                        folderPusher.stop();
                    }
                    catch (Exception e)
                    {
                        Log.e(K9.LOG_TAG, ""Got exception while stopping "" + folderPusher.getName(), e);
                    }
                }
                folderPushers.clear();
            }
        }

        public int getRefreshInterval()
        {
            return (getAccount().getIdleRefreshMinutes() * 60 * 1000);
        }

        public long getLastRefresh()
        {
            return lastRefresh;
        }

        public void setLastRefresh(long lastRefresh)
        {
            this.lastRefresh = lastRefresh;
        }

    }
    private interface UntaggedHandler
    {
        void handleAsyncUntaggedResponse(ImapResponse respose);
    }

    protected static class ImapPushState
    {
        protected int uidNext;
        protected ImapPushState(int nUidNext)
        {
            uidNext = nUidNext;
        }
        protected static ImapPushState parse(String pushState)
        {
            int newUidNext = -1;
            if (pushState != null)
            {
                StringTokenizer tokenizer = new StringTokenizer(pushState, "";"");
                while (tokenizer.hasMoreTokens())
                {
                    StringTokenizer thisState = new StringTokenizer(tokenizer.nextToken(), ""="");
                    if (thisState.hasMoreTokens())
                    {
                        String key = thisState.nextToken();

                        if (""uidNext"".equalsIgnoreCase(key) && thisState.hasMoreTokens())
                        {
                            String value = thisState.nextToken();
                            try
                            {
                                newUidNext = Integer.parseInt(value);
                            }
                            catch (Exception e)
                            {
                                Log.e(K9.LOG_TAG, ""Unable to part uidNext value "" + value, e);
                            }

                        }
                    }
                }
            }
            return new ImapPushState(newUidNext);
        }
        @Override
        public String toString()
        {
            return ""uidNext="" + uidNext;
        }

    }
    private interface ImapSearcher
    {
        List<ImapResponse> search() throws IOException, MessagingException;
    }

    private class FetchBodyCallback implements ImapResponseParser.IImapResponseCallback
    {
        private HashMap<String, Message> mMessageMap;

        FetchBodyCallback(HashMap<String, Message> mesageMap)
        {
            mMessageMap = mesageMap;
        }

        @Override
        public Object foundLiteral(ImapResponse response,
                                   FixedLengthInputStream literal) throws IOException, Exception
        {
            if (response.mTag == null &&
                    ImapResponseParser.equalsIgnoreCase(response.get(1), ""FETCH""))
            {
                ImapList fetchList = (ImapList)response.getKeyedValue(""FETCH"");
                String uid = fetchList.getKeyedString(""UID"");

                ImapMessage message = (ImapMessage) mMessageMap.get(uid);
                message.parse(literal);

                // Return placeholder object
                return new Integer(1);
            }
            return null;
        }
    }

    private class FetchPartCallback implements ImapResponseParser.IImapResponseCallback
    {
        private Part mPart;

        FetchPartCallback(Part part)
        {
            mPart = part;
        }

        @Override
        public Object foundLiteral(ImapResponse response,
                                   FixedLengthInputStream literal) throws IOException, Exception
        {
            if (response.mTag == null &&
                    ImapResponseParser.equalsIgnoreCase(response.get(1), ""FETCH""))
            {
                //TODO: check for correct UID

                String contentTransferEncoding = mPart.getHeader(
                                                     MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING)[0];

                return MimeUtility.decodeBody(literal, contentTransferEncoding);
            }
            return null;
        }
    }

}
",True,216,0,0,6,49,1,33,L1
128,com.fsck.k9.preferences.Editor.java,"package com.fsck.k9.preferences;

import android.util.Log;
import com.fsck.k9.K9;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

public class Editor implements android.content.SharedPreferences.Editor
{
    private Storage storage;
    private HashMap<String, String> changes = new HashMap<String, String>();
    private ArrayList<String> removals = new ArrayList<String>();
    private boolean removeAll = false;

    Map<String, String> snapshot = new HashMap<String, String>();


    protected Editor(Storage storage)
    {
        this.storage = storage;
        snapshot.putAll(storage.getAll());
    }

    public void copy(android.content.SharedPreferences input)
    {
        Map<String, ?> oldVals = input.getAll();
        for (Entry<String, ?> entry : oldVals.entrySet())
        {
            String key = entry.getKey();
            Object value = entry.getValue();
            if (key != null && value != null)
            {
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Copying key '"" + key + ""', value '"" + value + ""'"");
                }
                changes.put(key, """" + value);
            }
            else
            {
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Skipping copying key '"" + key + ""', value '"" + value + ""'"");
                }
            }
        }
    }

    //@Override
    public android.content.SharedPreferences.Editor clear()
    {
        removeAll = true;
        return this;
    }

    /* This method is poorly defined.  It should throw an Exception on failure */
    //@Override
    public boolean commit()
    {
        try
        {
            commitChanges();
            return true;
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Failed to save preferences"", e);
            return false;
        }
    }

    public void commitChanges() throws Exception
    {
        long startTime = System.currentTimeMillis();
        Log.i(K9.LOG_TAG, ""Committing preference changes"");
        Runnable committer = new Runnable()
        {
            public void run()
            {
                if (removeAll)
                {
                    storage.removeAll();
                }
                for (String removeKey : removals)
                {
                    storage.remove(removeKey);
                }
                for (Entry<String, String> entry : changes.entrySet())
                {
                    String key = entry.getKey();
                    String newValue = entry.getValue();
                    String oldValue = snapshot.get(key);
                    if (removeAll || removals.contains(key) || !newValue.equals(oldValue))
                    {
                        storage.put(key, newValue);
                    }
                }
            }
        };
        storage.doInTransaction(committer);
        long endTime = System.currentTimeMillis();
        Log.i(K9.LOG_TAG, ""Preferences commit took "" + (endTime - startTime) + ""ms"");

    }

    //@Override
    public android.content.SharedPreferences.Editor putBoolean(String key,
            boolean value)
    {
        changes.put(key, """" + value);
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor putFloat(String key,
            float value)
    {
        changes.put(key, """" + value);
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor putInt(String key, int value)
    {
        changes.put(key, """" + value);
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor putLong(String key, long value)
    {
        changes.put(key, """" + value);
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor putString(String key,
            String value)
    {
        if (value == null)
        {
            remove(key);
        }
        else
        {
            changes.put(key, value);
        }
        return this;
    }

    //@Override
    public android.content.SharedPreferences.Editor remove(String key)
    {
        removals.add(key);
        return this;
    }

}
",True,216,0,0,9,59,2,2,L1
129,com.fsck.k9.preferences.Storage.java,"package com.fsck.k9.preferences;

import android.content.ContentValues;
import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import com.fsck.k9.K9;
import com.fsck.k9.helper.Utility;

import java.net.URI;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

public class Storage implements SharedPreferences
{
    private static ConcurrentHashMap<Context, Storage> storages =
        new ConcurrentHashMap<Context, Storage>();

    private volatile ConcurrentHashMap<String, String> storage = new ConcurrentHashMap<String, String>();

    private CopyOnWriteArrayList<OnSharedPreferenceChangeListener> listeners =
        new CopyOnWriteArrayList<OnSharedPreferenceChangeListener>();

    private int DB_VERSION = 2;
    private String DB_NAME = ""preferences_storage"";

    private ThreadLocal<ConcurrentHashMap<String, String>> workingStorage
    = new ThreadLocal<ConcurrentHashMap<String, String>>();
    private ThreadLocal<SQLiteDatabase> workingDB =
        new ThreadLocal<SQLiteDatabase>();
    private ThreadLocal<ArrayList<String>> workingChangedKeys = new ThreadLocal<ArrayList<String>>();


    private Context context = null;

    private SQLiteDatabase openDB()
    {
        SQLiteDatabase mDb = context.openOrCreateDatabase(DB_NAME, Context.MODE_PRIVATE, null);

        if (mDb.getVersion() == 1)
        {
            Log.i(K9.LOG_TAG, ""Updating preferences to urlencoded username/password"");

            String accountUuids = readValue(mDb, ""accountUuids"");
            if (accountUuids != null && accountUuids.length() != 0)
            {
                String[] uuids = accountUuids.split("","");
                for (String uuid : uuids)
                {
                    try
                    {
                        String storeUriStr = Utility.base64Decode(readValue(mDb, uuid + "".storeUri""));
                        String transportUriStr = Utility.base64Decode(readValue(mDb, uuid + "".transportUri""));

                        URI uri = new URI(transportUriStr);
                        String newUserInfo = null;
                        if (transportUriStr != null)
                        {
                            String[] userInfoParts = uri.getUserInfo().split("":"");

                            String usernameEnc = URLEncoder.encode(userInfoParts[0], ""UTF-8"");
                            String passwordEnc = """";
                            String authType = """";
                            if (userInfoParts.length > 1)
                            {
                                passwordEnc = "":"" + URLEncoder.encode(userInfoParts[1], ""UTF-8"");
                            }
                            if (userInfoParts.length > 2)
                            {
                                authType = "":"" + userInfoParts[2];
                            }

                            newUserInfo = usernameEnc + passwordEnc + authType;
                        }

                        if (newUserInfo != null)
                        {
                            URI newUri = new URI(uri.getScheme(), newUserInfo, uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());
                            String newTransportUriStr = Utility.base64Encode(newUri.toString());
                            writeValue(mDb, uuid + "".transportUri"", newTransportUriStr);
                        }

                        uri = new URI(storeUriStr);
                        newUserInfo = null;
                        if (storeUriStr.startsWith(""imap""))
                        {
                            String[] userInfoParts = uri.getUserInfo().split("":"");
                            if (userInfoParts.length == 2)
                            {
                                String usernameEnc = URLEncoder.encode(userInfoParts[0], ""UTF-8"");
                                String passwordEnc = URLEncoder.encode(userInfoParts[1], ""UTF-8"");

                                newUserInfo = usernameEnc + "":"" + passwordEnc;
                            }
                            else
                            {
                                String authType = userInfoParts[0];
                                String usernameEnc = URLEncoder.encode(userInfoParts[1], ""UTF-8"");
                                String passwordEnc = URLEncoder.encode(userInfoParts[2], ""UTF-8"");

                                newUserInfo = authType + "":"" + usernameEnc + "":"" + passwordEnc;
                            }
                        }
                        else if (storeUriStr.startsWith(""pop3""))
                        {
                            String[] userInfoParts = uri.getUserInfo().split("":"", 2);
                            String usernameEnc = URLEncoder.encode(userInfoParts[0], ""UTF-8"");

                            String passwordEnc = """";
                            if (userInfoParts.length > 1)
                            {
                                passwordEnc = "":"" + URLEncoder.encode(userInfoParts[1], ""UTF-8"");
                            }

                            newUserInfo = usernameEnc + passwordEnc;
                        }
                        else if (storeUriStr.startsWith(""webdav""))
                        {
                            String[] userInfoParts = uri.getUserInfo().split("":"", 2);
                            String usernameEnc = URLEncoder.encode(userInfoParts[0], ""UTF-8"");

                            String passwordEnc = """";
                            if (userInfoParts.length > 1)
                            {
                                passwordEnc = "":"" + URLEncoder.encode(userInfoParts[1], ""UTF-8"");
                            }

                            newUserInfo = usernameEnc + passwordEnc;
                        }

                        if (newUserInfo != null)
                        {
                            URI newUri = new URI(uri.getScheme(), newUserInfo, uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());
                            String newStoreUriStr = Utility.base64Encode(newUri.toString());
                            writeValue(mDb, uuid + "".storeUri"", newStoreUriStr);
                        }
                    }
                    catch (Exception e)
                    {
                        Log.e(K9.LOG_TAG, ""ooops"", e);
                    }
                }
            }

            mDb.setVersion(DB_VERSION);
        }

        if (mDb.getVersion() != DB_VERSION)
        {
            Log.i(K9.LOG_TAG, ""Creating Storage database"");
            mDb.execSQL(""DROP TABLE IF EXISTS preferences_storage"");
            mDb.execSQL(""CREATE TABLE preferences_storage "" +
                        ""(primkey TEXT PRIMARY KEY ON CONFLICT REPLACE, value TEXT)"");
            mDb.setVersion(DB_VERSION);
        }
        return mDb;
    }


    public static Storage getStorage(Context context)
    {
        Storage tmpStorage = storages.get(context);
        if (tmpStorage != null)
        {
            if (K9.DEBUG)
            {
                Log.d(K9.LOG_TAG, ""Returning already existing Storage"");
            }
            return tmpStorage;
        }
        else
        {
            if (K9.DEBUG)
            {
                Log.d(K9.LOG_TAG, ""Creating provisional storage"");
            }
            tmpStorage = new Storage(context);
            Storage oldStorage = storages.putIfAbsent(context, tmpStorage);
            if (oldStorage != null)
            {
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Another thread beat us to creating the Storage, returning that one"");
                }
                return oldStorage;
            }
            else
            {
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Returning the Storage we created"");
                }
                return tmpStorage;
            }
        }
    }

    private void loadValues()
    {
        long startTime = System.currentTimeMillis();
        Log.i(K9.LOG_TAG, ""Loading preferences from DB into Storage"");
        Cursor cursor = null;
        SQLiteDatabase mDb = null;
        try
        {
            mDb = openDB();

            cursor = mDb.rawQuery(""SELECT primkey, value FROM preferences_storage"", null);
            while (cursor.moveToNext())
            {
                String key = cursor.getString(0);
                String value = cursor.getString(1);
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Loading key '"" + key + ""', value = '"" + value + ""'"");
                }
                storage.put(key, value);
            }
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
            if (mDb != null)
            {
                mDb.close();
            }
            long endTime = System.currentTimeMillis();
            Log.i(K9.LOG_TAG, ""Preferences load took "" + (endTime - startTime) + ""ms"");
        }
    }

    private Storage(Context context)
    {
        this.context = context;
        loadValues();
    }

    private void keyChange(String key)
    {
        ArrayList<String> changedKeys = workingChangedKeys.get();
        if (!changedKeys.contains(key))
        {
            changedKeys.add(key);
        }
    }

    protected void put(String key, String value)
    {
        ContentValues cv = new ContentValues();
        cv.put(""primkey"", key);
        cv.put(""value"", value);
        workingDB.get().insert(""preferences_storage"", ""primkey"", cv);
        workingStorage.get().put(key, value);

        keyChange(key);
    }

    protected void remove(String key)
    {
        workingDB.get().delete(""preferences_storage"", ""primkey = ?"", new String[] { key });
        workingStorage.get().remove(key);

        keyChange(key);
    }

    protected void removeAll()
    {
        for (String key : workingStorage.get().keySet())
        {
            keyChange(key);
        }
        workingDB.get().execSQL(""DELETE FROM preferences_storage"");
        workingStorage.get().clear();
    }

    protected void doInTransaction(Runnable dbWork)
    {
        ConcurrentHashMap<String, String> newStorage = new ConcurrentHashMap<String, String>();
        newStorage.putAll(storage);
        workingStorage.set(newStorage);

        SQLiteDatabase mDb = openDB();
        workingDB.set(mDb);

        ArrayList<String> changedKeys = new ArrayList<String>();
        workingChangedKeys.set(changedKeys);

        mDb.beginTransaction();
        try
        {
            dbWork.run();
            mDb.setTransactionSuccessful();
            storage = newStorage;
            for (String changedKey : changedKeys)
            {
                for (OnSharedPreferenceChangeListener listener : listeners)
                {
                    listener.onSharedPreferenceChanged(this, changedKey);
                }
            }
        }
        finally
        {
            workingDB.remove();
            workingStorage.remove();
            workingChangedKeys.remove();
            mDb.endTransaction();
            if (mDb != null)
            {
                mDb.close();
            }
        }
    }

    public long size()
    {
        return storage.size();
    }

    //@Override
    public boolean contains(String key)
    {
        return storage.contains(key);
    }

    //@Override
    public com.fsck.k9.preferences.Editor edit()
    {
        return new com.fsck.k9.preferences.Editor(this);
    }

    //@Override
    public Map<String, String> getAll()
    {
        return storage;
    }

    //@Override
    public boolean getBoolean(String key, boolean defValue)
    {
        String val = storage.get(key);
        if (val == null)
        {
            return defValue;
        }
        return Boolean.parseBoolean(val);
    }

    //@Override
    public float getFloat(String key, float defValue)
    {
        String val = storage.get(key);
        if (val == null)
        {
            return defValue;
        }
        return Float.parseFloat(val);
    }

    //@Override
    public int getInt(String key, int defValue)
    {
        String val = storage.get(key);
        if (val == null)
        {
            return defValue;
        }
        return Integer.parseInt(val);
    }

    //@Override
    public long getLong(String key, long defValue)
    {
        String val = storage.get(key);
        if (val == null)
        {
            return defValue;
        }
        return Long.parseLong(val);
    }

    //@Override
    public String getString(String key, String defValue)
    {
        String val = storage.get(key);
        if (val == null)
        {
            return defValue;
        }
        return val;
    }

    //@Override
    public void registerOnSharedPreferenceChangeListener(
        OnSharedPreferenceChangeListener listener)
    {
        listeners.addIfAbsent(listener);
    }

    //@Override
    public void unregisterOnSharedPreferenceChangeListener(
        OnSharedPreferenceChangeListener listener)
    {
        listeners.remove(listener);
    }

    private String readValue(SQLiteDatabase mDb, String key)
    {
        Cursor cursor = null;
        String value = null;
        try
        {
            cursor = mDb.query(
                         ""preferences_storage"",
                         new String[] {""value""},
                         ""primkey = ?"",
                         new String[] {key},
                         null,
                         null,
                         null);

            if (cursor.moveToNext())
            {
                value = cursor.getString(0);
                if (K9.DEBUG)
                {
                    Log.d(K9.LOG_TAG, ""Loading key '"" + key + ""', value = '"" + value + ""'"");
                }
            }
        }
        finally
        {
            if (cursor != null)
            {
                cursor.close();
            }
        }

        return value;
    }

    private void writeValue(SQLiteDatabase mDb, String key, String value)
    {
        ContentValues cv = new ContentValues();
        cv.put(""primkey"", key);
        cv.put(""value"", value);

        long result = mDb.insert(""preferences_storage"", ""primkey"", cv);

        if (result == -1)
        {
            Log.e(K9.LOG_TAG, ""Error writing key '"" + key + ""', value = '"" + value + ""'"");
        }
    }
}
",True,216,0,0,9,59,2,3,L1
130,com.fsck.k9.preferences.CheckBoxListPreference.java,"package com.fsck.k9.preferences;

import android.app.AlertDialog.Builder;
import android.content.Context;
import android.content.DialogInterface;
import android.preference.DialogPreference;
import android.util.AttributeSet;

public class CheckBoxListPreference extends DialogPreference
{

    private CharSequence[] mItems;

    private boolean[] mCheckedItems;

    /**
     * checkboxes state when the dialog is displayed
     */
    private boolean[] mPendingItems;

    /**
     * @param context
     * @param attrs
     * @param defStyle
     */
    public CheckBoxListPreference(Context context, AttributeSet attrs, int defStyle)
    {
        super(context, attrs, defStyle);
    }

    /**
     * @param context
     * @param attrs
     */
    public CheckBoxListPreference(Context context, AttributeSet attrs)
    {
        super(context, attrs);
    }

    @Override
    protected void onPrepareDialogBuilder(final Builder builder)
    {
        mPendingItems = new boolean[mItems.length];

        System.arraycopy(mCheckedItems, 0, mPendingItems, 0, mCheckedItems.length);

        builder.setMultiChoiceItems(mItems, mPendingItems,
                new DialogInterface.OnMultiChoiceClickListener()
                {
                    @Override
                    public void onClick(final DialogInterface dialog, final int which,
                            final boolean isChecked)
                    {
                        mPendingItems[which] = isChecked;
                    }
                });
    }

    @Override
    protected void onDialogClosed(boolean positiveResult)
    {
        if (positiveResult)
        {
            System.arraycopy(mPendingItems, 0, mCheckedItems, 0, mPendingItems.length);
        }
        mPendingItems = null;
    }

    public void setItems(final CharSequence[] items)
    {
        mItems = items;
    }

    public void setCheckedItems(final boolean[] items)
    {
        mCheckedItems = items;
    }

    public boolean[] getCheckedItems()
    {
        return mCheckedItems;
    }

}
",False,92,8,44,0,0,1,0,L1
131,com.fsck.k9.controller.MessageRetrievalListener.java,"
package com.fsck.k9.controller;

import com.fsck.k9.mail.Message;

public interface MessageRetrievalListener
{
    public void messageStarted(String uid, int number, int ofTotal);

    public void messageFinished(Message message, int number, int ofTotal);

    public void messagesFinished(int total);
}
",False,216,0,0,9,65,6,1,L1
132,com.fsck.k9.controller.MessageRemovalListener.java,"package com.fsck.k9.controller;

import com.fsck.k9.mail.Message;

public interface MessageRemovalListener
{
    public void messageRemoved(Message message);
}
",False,216,0,0,9,65,2,1,L1
133,com.fsck.k9.controller.MessageDateComparator.java,"
package com.fsck.k9.controller;

import java.util.Comparator;
import com.fsck.k9.mail.Message;

public class MessageDateComparator implements Comparator<Message>
{
    public int compare(Message o1, Message o2)
    {
        try
        {
            if (o1.getSentDate() == null)
            {
                return 1;
            }
            else if (o2.getSentDate() == null)
            {
                return -1;
            }
            else
                return o2.getSentDate().compareTo(o1.getSentDate());
        }
        catch (Exception e)
        {
            return 0;
        }
    }
}
",True,217,0,0,9,65,0,1,L4
134,com.fsck.k9.controller.MessagingControllerPushReceiver.java,"package com.fsck.k9.controller;

import android.app.Application;
import android.content.Context;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.K9;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Folder.OpenMode;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.PushReceiver;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import com.fsck.k9.service.SleepService;

import java.util.List;
import java.util.concurrent.CountDownLatch;

public class MessagingControllerPushReceiver implements PushReceiver
{
    final Account account;
    final MessagingController controller;
    final Application mApplication;

    public MessagingControllerPushReceiver(Application nApplication, Account nAccount, MessagingController nController)
    {
        account = nAccount;
        controller = nController;
        mApplication = nApplication;
    }

    public void messagesFlagsChanged(Folder folder,
                                     List<Message> messages)
    {
        controller.messagesArrived(account, folder, messages, true);
    }
    public void messagesArrived(Folder folder, List<Message> messages)
    {
        controller.messagesArrived(account, folder, messages, false);
    }
    public void messagesRemoved(Folder folder, List<Message> messages)
    {
        controller.messagesArrived(account, folder, messages, true);
    }

    public void syncFolder(Folder folder)
    {
        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""syncFolder("" + folder.getName() + "")"");
        final CountDownLatch latch = new CountDownLatch(1);
        controller.synchronizeMailbox(account, folder.getName(), new MessagingListener()
        {
            @Override
            public void synchronizeMailboxFinished(Account account, String folder,
                                                   int totalMessagesInMailbox, int numNewMessages)
            {
                latch.countDown();
            }

            @Override
            public void synchronizeMailboxFailed(Account account, String folder,
                                                 String message)
            {
                latch.countDown();
            }
        }, folder);

        if (K9.DEBUG)
            Log.v(K9.LOG_TAG, ""syncFolder("" + folder.getName() + "") about to await latch release"");
        try
        {
            latch.await();
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""syncFolder("" + folder.getName() + "") got latch release"");
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Interrupted while awaiting latch release"", e);
        }
    }

    @Override
    public void sleep(TracingWakeLock wakeLock, long millis)
    {
        SleepService.sleep(mApplication, millis, wakeLock, K9.PUSH_WAKE_LOCK_TIMEOUT);
    }

    public void pushError(String errorMessage, Exception e)
    {
        String errMess = errorMessage;

        if (errMess == null && e != null)
        {
            errMess = e.getMessage();
        }
        controller.addErrorMessage(account, errMess, e);
    }

    public String getPushState(String folderName)
    {
        LocalFolder localFolder = null;
        try
        {
            LocalStore localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folderName);
            localFolder.open(OpenMode.READ_WRITE);
            return localFolder.getPushState();
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Unable to get push state from account "" + account.getDescription()
                  + "", folder "" + folderName, e);
            return null;
        }
        finally
        {
            if (localFolder != null)
            {
                localFolder.close();
            }
        }
    }

    public void setPushActive(String folderName, boolean enabled)
    {
        for (MessagingListener l : controller.getListeners())
        {
            l.setPushActive(account, folderName, enabled);
        }
    }

    @Override
    public Context getContext()
    {
        return mApplication;
    }

}
",True,216,0,0,8,52,1,10,L1
135,com.fsck.k9.controller.MessagingController.java,"
package com.fsck.k9.controller;

import java.io.CharArrayWriter;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import android.app.Application;
import android.app.KeyguardManager;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.media.AudioManager;
import android.net.Uri;
import android.os.PowerManager;
import android.os.Process;
import android.text.TextUtils;
import android.util.Log;

import com.fsck.k9.Account;
import com.fsck.k9.AccountStats;
import com.fsck.k9.K9;
import com.fsck.k9.NotificationSetting;
import com.fsck.k9.Preferences;
import com.fsck.k9.R;
import com.fsck.k9.SearchSpecification;
import com.fsck.k9.activity.FolderList;
import com.fsck.k9.activity.MessageList;
import com.fsck.k9.helper.Utility;
import com.fsck.k9.helper.power.TracingPowerManager;
import com.fsck.k9.helper.power.TracingPowerManager.TracingWakeLock;
import com.fsck.k9.mail.Address;
import com.fsck.k9.mail.FetchProfile;
import com.fsck.k9.mail.Flag;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Folder.FolderType;
import com.fsck.k9.mail.Folder.OpenMode;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.MessagingException;
import com.fsck.k9.mail.Part;
import com.fsck.k9.mail.PushReceiver;
import com.fsck.k9.mail.Pusher;
import com.fsck.k9.mail.Store;
import com.fsck.k9.mail.Transport;
import com.fsck.k9.mail.internet.MimeMessage;
import com.fsck.k9.mail.internet.MimeUtility;
import com.fsck.k9.mail.internet.TextBody;
import com.fsck.k9.mail.store.LocalStore;
import com.fsck.k9.mail.store.LocalStore.LocalFolder;
import com.fsck.k9.mail.store.LocalStore.LocalMessage;
import com.fsck.k9.mail.store.LocalStore.PendingCommand;


/**
 * Starts a long running (application) Thread that will run through commands
 * that require remote mailbox access. This class is used to serialize and
 * prioritize these commands. Each method that will submit a command requires a
 * MessagingListener instance to be provided. It is expected that that listener
 * has also been added as a registered listener using addListener(). When a
 * command is to be executed, if the listener that was provided with the command
 * is no longer registered the command is skipped. The design idea for the above
 * is that when an Activity starts it registers as a listener. When it is paused
 * it removes itself. Thus, any commands that that activity submitted are
 * removed from the queue once the activity is no longer active.
 */
public class MessagingController implements Runnable
{

    /**
     * Immutable empty {@link String} array
     */
    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    /**
     * Immutable empty {@link Message} array
     */
    private static final Message[] EMPTY_MESSAGE_ARRAY = new Message[0];

    /**
     * Immutable empty {@link Folder} array
     */
    private static final Folder[] EMPTY_FOLDER_ARRAY = new Folder[0];

    /**
     * The maximum message size that we'll consider to be ""small"". A small message is downloaded
     * in full immediately instead of in pieces. Anything over this size will be downloaded in
     * pieces with attachments being left off completely and downloaded on demand.
     *
     *
     * 25k for a ""small"" message was picked by educated trial and error.
     * http://answers.google.com/answers/threadview?id=312463 claims that the
     * average size of an email is 59k, which I feel is too large for our
     * blind download. The following tests were performed on a download of
     * 25 random messages.
     * <pre>
     * 5k - 61 seconds,
     * 25k - 51 seconds,
     * 55k - 53 seconds,
     * </pre>
     * So 25k gives good performance and a reasonable data footprint. Sounds good to me.
     */

    private static final String PENDING_COMMAND_MOVE_OR_COPY = ""com.fsck.k9.MessagingController.moveOrCopy"";
    private static final String PENDING_COMMAND_MOVE_OR_COPY_BULK = ""com.fsck.k9.MessagingController.moveOrCopyBulk"";
    private static final String PENDING_COMMAND_EMPTY_TRASH = ""com.fsck.k9.MessagingController.emptyTrash"";
    private static final String PENDING_COMMAND_SET_FLAG_BULK = ""com.fsck.k9.MessagingController.setFlagBulk"";
    private static final String PENDING_COMMAND_SET_FLAG = ""com.fsck.k9.MessagingController.setFlag"";
    private static final String PENDING_COMMAND_APPEND = ""com.fsck.k9.MessagingController.append"";
    private static final String PENDING_COMMAND_MARK_ALL_AS_READ = ""com.fsck.k9.MessagingController.markAllAsRead"";
    private static final String PENDING_COMMAND_EXPUNGE = ""com.fsck.k9.MessagingController.expunge"";

    private static MessagingController inst = null;
    private BlockingQueue<Command> mCommands = new PriorityBlockingQueue<Command>();

    private Thread mThread;
    private Set<MessagingListener> mListeners = new CopyOnWriteArraySet<MessagingListener>();

    private HashMap<SORT_TYPE, Boolean> sortAscending = new HashMap<SORT_TYPE, Boolean>();

    private ConcurrentHashMap<String, AtomicInteger> sendCount = new ConcurrentHashMap<String, AtomicInteger>();

    ConcurrentHashMap<Account, Pusher> pushers = new ConcurrentHashMap<Account, Pusher>();

    private final ExecutorService threadPool = Executors.newCachedThreadPool();

    public enum SORT_TYPE
    {
        SORT_DATE(R.string.sort_earliest_first, R.string.sort_latest_first, false),
        SORT_SUBJECT(R.string.sort_subject_alpha, R.string.sort_subject_re_alpha, true),
        SORT_SENDER(R.string.sort_sender_alpha, R.string.sort_sender_re_alpha, true),
        SORT_UNREAD(R.string.sort_unread_first, R.string.sort_unread_last, true),
        SORT_FLAGGED(R.string.sort_flagged_first, R.string.sort_flagged_last, true),
        SORT_ATTACHMENT(R.string.sort_attach_first, R.string.sort_unattached_first, true);

        private int ascendingToast;
        private int descendingToast;
        private boolean defaultAscending;

        SORT_TYPE(int ascending, int descending, boolean ndefaultAscending)
        {
            ascendingToast = ascending;
            descendingToast = descending;
            defaultAscending = ndefaultAscending;
        }

        public int getToast(boolean ascending)
        {
            if (ascending)
            {
                return ascendingToast;
            }
            else
            {
                return descendingToast;
            }
        }
        public boolean isDefaultAscending()
        {
            return defaultAscending;
        }
    };
    private SORT_TYPE sortType = SORT_TYPE.SORT_DATE;

    private MessagingListener checkMailListener = null;

    private MemorizingListener memorizingListener = new MemorizingListener();

    private boolean mBusy;
    private Application mApplication;

    // Key is accountUuid:folderName:messageUid   ,   value is unimportant
    private ConcurrentHashMap<String, String> deletedUids = new ConcurrentHashMap<String, String>();

    private String createMessageKey(Account account, String folder, Message message)
    {
        return createMessageKey(account, folder, message.getUid());
    }

    private String createMessageKey(Account account, String folder, String uid)
    {
        return account.getUuid() + "":"" + folder + "":"" + uid;
    }

    private void suppressMessage(Account account, String folder, Message message)
    {

        if (account == null || folder == null || message == null)
        {
            return;
        }
        String messKey = createMessageKey(account, folder, message);
        deletedUids.put(messKey, ""true"");
    }

    private void unsuppressMessage(Account account, String folder, String uid)
    {
        if (account == null || folder == null || uid == null)
        {
            return;
        }
        String messKey = createMessageKey(account, folder, uid);
        deletedUids.remove(messKey);
    }


    private boolean isMessageSuppressed(Account account, String folder, Message message)
    {
        if (account == null || folder == null || message == null)
        {
            return false;
        }
        String messKey = createMessageKey(account, folder, message);

        if (deletedUids.containsKey(messKey))
        {
            return true;
        }

        return false;
    }

    private MessagingController(Application application)
    {
        mApplication = application;
        mThread = new Thread(this);
        mThread.start();
        if (memorizingListener != null)
        {
            addListener(memorizingListener);
        }
    }

    /**
     * Gets or creates the singleton instance of MessagingController. Application is used to
     * provide a Context to classes that need it.
     * @param application
     * @return
     */
    public synchronized static MessagingController getInstance(Application application)
    {
        if (inst == null)
        {
            inst = new MessagingController(application);
        }
        return inst;
    }

    public boolean isBusy()
    {
        return mBusy;
    }

    public void run()
    {
        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
        while (true)
        {
            String commandDescription = null;
            try
            {
                Command command = mCommands.take();

                if (command != null)
                {
                    commandDescription = command.description;

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Running "" + (command.isForeground ? ""Foreground"" : ""Background"") + "" command '"" + command.description + ""', seq = "" + command.sequence);

                    mBusy = true;
                    command.runnable.run();

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, (command.isForeground ? ""Foreground"" : ""Background"") +
                              "" Command '"" + command.description + ""' completed"");

                    for (MessagingListener l : getListeners(command.listener))
                    {
                        l.controllerCommandCompleted(mCommands.size() > 0);
                    }
                }
            }
            catch (Exception e)
            {
                Log.e(K9.LOG_TAG, ""Error running command '"" + commandDescription + ""'"", e);
            }
            mBusy = false;
        }
    }

    private void put(String description, MessagingListener listener, Runnable runnable)
    {
        putCommand(mCommands, description, listener, runnable, true);
    }

    private void putBackground(String description, MessagingListener listener, Runnable runnable)
    {
        putCommand(mCommands, description, listener, runnable, false);
    }

    private void putCommand(BlockingQueue<Command> queue, String description, MessagingListener listener, Runnable runnable, boolean isForeground)
    {
        int retries = 10;
        Exception e = null;
        while (retries-- > 0)
        {
            try
            {
                Command command = new Command();
                command.listener = listener;
                command.runnable = runnable;
                command.description = description;
                command.isForeground = isForeground;
                queue.put(command);
                return;
            }
            catch (InterruptedException ie)
            {
                try
                {
                    Thread.sleep(200);
                }
                catch (InterruptedException ne)
                {
                }
                e = ie;
            }
        }
        throw new Error(e);
    }


    public void addListener(MessagingListener listener)
    {
        mListeners.add(listener);
        refreshListener(listener);
    }

    public void refreshListener(MessagingListener listener)
    {
        if (memorizingListener != null && listener != null)
        {
            memorizingListener.refreshOther(listener);
        }
    }

    public void removeListener(MessagingListener listener)
    {
        mListeners.remove(listener);
    }

    public Set<MessagingListener> getListeners()
    {
        return mListeners;
    }


    public Set<MessagingListener> getListeners(MessagingListener listener)
    {
        if (listener == null)
        {
            return mListeners;
        }

        Set<MessagingListener> listeners = new HashSet<MessagingListener>(mListeners);
        listeners.add(listener);
        return listeners;

    }


    /**
     * Lists folders that are available locally and remotely. This method calls
     * listFoldersCallback for local folders before it returns, and then for
     * remote folders at some later point. If there are no local folders
     * includeRemote is forced by this method. This method should be called from
     * a Thread as it may take several seconds to list the local folders.
     * TODO this needs to cache the remote folder list
     *
     * @param account
     * @param includeRemote
     * @param listener
     * @throws MessagingException
     */
    public void listFolders(final Account account, final boolean refreshRemote, final MessagingListener listener)
    {
        threadPool.execute(new Runnable()
        {
            public void run()
            {
                for (MessagingListener l : getListeners(listener))
                {
                    l.listFoldersStarted(account);
                }
                List<? extends Folder> localFolders = null;
                try
                {
                    Store localStore = account.getLocalStore();
                    localFolders = localStore.getPersonalNamespaces(false);

                    Folder[] folderArray = localFolders.toArray(EMPTY_FOLDER_ARRAY);

                    if (refreshRemote || localFolders == null || localFolders.size() == 0)
                    {
                        doRefreshRemote(account, listener);
                        return;
                    }

                    for (MessagingListener l : getListeners(listener))
                    {
                        l.listFolders(account, folderArray);
                    }
                }
                catch (Exception e)
                {
                    for (MessagingListener l : getListeners(listener))
                    {
                        l.listFoldersFailed(account, e.getMessage());
                    }

                    addErrorMessage(account, null, e);
                    return;
                }
                finally
                {
                    if (localFolders != null)
                    {
                        for (Folder localFolder : localFolders)
                        {
                            if (localFolder != null)
                            {
                                localFolder.close();
                            }
                        }
                    }
                }

                for (MessagingListener l : getListeners(listener))
                {
                    l.listFoldersFinished(account);
                }
            }
        });
    }

    private void doRefreshRemote(final Account account, MessagingListener listener)
    {
        put(""doRefreshRemote"", listener, new Runnable()
        {
            public void run()
            {
                List<? extends Folder> localFolders = null;
                try
                {
                    Store store = account.getRemoteStore();

                    List<? extends Folder> remoteFolders = store.getPersonalNamespaces(false);

                    LocalStore localStore = account.getLocalStore();
                    HashSet<String> remoteFolderNames = new HashSet<String>();
                    for (int i = 0, count = remoteFolders.size(); i < count; i++)
                    {
                        LocalFolder localFolder = localStore.getFolder(remoteFolders.get(i).getName());
                        if (!localFolder.exists())
                        {
                            localFolder.create(FolderType.HOLDS_MESSAGES, account.getDisplayCount());
                        }
                        remoteFolderNames.add(remoteFolders.get(i).getName());
                    }

                    localFolders = localStore.getPersonalNamespaces(false);

                    /*
                     * Clear out any folders that are no longer on the remote store.
                     */
                    for (Folder localFolder : localFolders)
                    {
                        String localFolderName = localFolder.getName();
                        if (localFolderName.equalsIgnoreCase(K9.INBOX) ||
                                localFolderName.equals(account.getTrashFolderName()) ||
                                localFolderName.equals(account.getOutboxFolderName()) ||
                                localFolderName.equals(account.getDraftsFolderName()) ||
                                localFolderName.equals(account.getSentFolderName()) ||
                                localFolderName.equals(account.getErrorFolderName()))
                        {
                            continue;
                        }
                        if (!remoteFolderNames.contains(localFolder.getName()))
                        {
                            localFolder.delete(false);
                        }
                    }

                    localFolders = localStore.getPersonalNamespaces(false);
                    Folder[] folderArray = localFolders.toArray(EMPTY_FOLDER_ARRAY);

                    for (MessagingListener l : getListeners())
                    {
                        l.listFolders(account, folderArray);
                    }
                    for (MessagingListener l : getListeners())
                    {
                        l.listFoldersFinished(account);
                    }
                }
                catch (Exception e)
                {
                    for (MessagingListener l : getListeners())
                    {
                        l.listFoldersFailed(account, """");
                    }
                    addErrorMessage(account, null, e);
                }
                finally
                {
                    if (localFolders != null)
                    {
                        for (Folder localFolder : localFolders)
                        {
                            if (localFolder != null)
                            {
                                localFolder.close();
                            }
                        }
                    }
                }
            }
        });
    }



    /**
     * List the messages in the local message store for the given folder asynchronously.
     *
     * @param account
     * @param folder
     * @param listener
     * @throws MessagingException
     */
    public void listLocalMessages(final Account account, final String folder, final MessagingListener listener)
    {
        threadPool.execute(new Runnable()
        {
            public void run()
            {
                listLocalMessagesSynchronous(account, folder, listener);
            }
        });
    }


    /**
     * List the messages in the local message store for the given folder synchronously.
     *
     * @param account
     * @param folder
     * @param listener
     * @throws MessagingException
     */
    public void listLocalMessagesSynchronous(final Account account, final String folder, final MessagingListener listener)
    {

        for (MessagingListener l : getListeners(listener))
        {
            l.listLocalMessagesStarted(account, folder);
        }

        Folder localFolder = null;
        MessageRetrievalListener retrievalListener =
            new MessageRetrievalListener()
        {
            List<Message> pendingMessages = new ArrayList<Message>();


            int totalDone = 0;


            public void messageStarted(String message, int number, int ofTotal) {}
            public void messageFinished(Message message, int number, int ofTotal)
            {

                if (!isMessageSuppressed(account, folder, message))
                {
                    pendingMessages.add(message);
                    totalDone++;
                    if (pendingMessages.size() > 10)
                    {
                        addPendingMessages();
                    }

                }
                else
                {
                    for (MessagingListener l : getListeners(listener))
                    {
                        l.listLocalMessagesRemoveMessage(account, folder, message);
                    }
                }
            }
            public void messagesFinished(int number)
            {
                addPendingMessages();
            }
            private void addPendingMessages()
            {
                for (MessagingListener l : getListeners(listener))
                {
                    l.listLocalMessagesAddMessages(account, folder, pendingMessages);
                }
                pendingMessages.clear();
            }
        };



        try
        {
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folder);
            localFolder.open(OpenMode.READ_WRITE);

            localFolder.getMessages(
                retrievalListener,
                false // Skip deleted messages
            );
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""Got ack that callbackRunner finished"");

            for (MessagingListener l : getListeners(listener))
            {
                l.listLocalMessagesFinished(account, folder);
            }
        }
        catch (Exception e)
        {
            for (MessagingListener l : getListeners(listener))
            {
                l.listLocalMessagesFailed(account, folder, e.getMessage());
            }
            addErrorMessage(account, null, e);
        }
        finally
        {
            if (localFolder != null)
            {
                localFolder.close();
            }
        }
    }

    public void searchLocalMessages(SearchSpecification searchSpecification, final Message[] messages, final MessagingListener listener)
    {
        searchLocalMessages(searchSpecification.getAccountUuids(), searchSpecification.getFolderNames(), messages,
                            searchSpecification.getQuery(), searchSpecification.isIntegrate(), searchSpecification.getRequiredFlags(), searchSpecification.getForbiddenFlags(), listener);
    }


    /**
     * Find all messages in any local account which match the query 'query'
     * @param folderNames TODO
     * @param query
     * @param listener
     * @param searchAccounts TODO
     * @param account TODO
     * @param account
     * @throws MessagingException
     */
    public void searchLocalMessages(final String[] accountUuids, final String[] folderNames, final Message[] messages, final String query, final boolean integrate,
                                    final Flag[] requiredFlags, final Flag[] forbiddenFlags, final MessagingListener listener)
    {
        if (K9.DEBUG)
        {
            Log.i(K9.LOG_TAG, ""searchLocalMessages (""
                  + ""accountUuids="" + Utility.combine(accountUuids, ',')
                  + "", folderNames = "" + Utility.combine(folderNames, ',')
                  + "", messages.size() = "" + (messages != null ? messages.length : null)
                  + "", query = "" + query
                  + "", integrate = "" + integrate
                  + "", requiredFlags = "" + Utility.combine(requiredFlags, ',')
                  + "", forbiddenFlags = "" + Utility.combine(forbiddenFlags, ',')
                  + "")"");
        }

        threadPool.execute(new Runnable()
        {
            public void run()
            {

                final AccountStats stats = new AccountStats();
                final Set<String> accountUuidsSet = new HashSet<String>();
                if (accountUuids != null)
                {
                    for (String accountUuid : accountUuids)
                    {
                        accountUuidsSet.add(accountUuid);
                    }
                }
                final Preferences prefs = Preferences.getPreferences(mApplication.getApplicationContext());
                Account[] accounts = prefs.getAccounts();
                List<LocalFolder> foldersToSearch = null;
                boolean displayableOnly = false;
                boolean noSpecialFolders = true;
                for (final Account account : accounts)
                {
                    if (accountUuids != null && !accountUuidsSet.contains(account.getUuid()))
                    {
                        continue;
                    }

                    if (accountUuids != null && accountUuidsSet.contains(account.getUuid()))
                    {
                        displayableOnly = true;
                        noSpecialFolders = true;
                    }
                    else if (!integrate && folderNames == null)
                    {
                        Account.Searchable searchableFolders = account.getSearchableFolders();
                        switch (searchableFolders)
                        {
                            case NONE:
                                continue;
                            case DISPLAYABLE:
                                displayableOnly = true;
                                break;

                        }
                    }
                    List<Message> messagesToSearch = null;
                    if (messages != null)
                    {
                        messagesToSearch = new LinkedList<Message>();
                        for (Message message : messages)
                        {
                            if (message.getFolder().getAccount().getUuid().equals(account.getUuid()))
                            {
                                messagesToSearch.add(message);
                            }
                        }
                        if (messagesToSearch.isEmpty())
                        {
                            continue;
                        }
                    }
                    if (listener != null)
                    {
                        listener.listLocalMessagesStarted(account, null);
                    }

                    if (integrate || displayableOnly || folderNames != null || noSpecialFolders)
                    {
                        List<LocalFolder> tmpFoldersToSearch = new LinkedList<LocalFolder>();
                        try
                        {
                            LocalStore store = account.getLocalStore();
                            List<? extends Folder> folders = store.getPersonalNamespaces(false);
                            Set<String> folderNameSet = null;
                            if (folderNames != null)
                            {
                                folderNameSet = new HashSet<String>();
                                for (String folderName : folderNames)
                                {
                                    folderNameSet.add(folderName);
                                }
                            }
                            for (Folder folder : folders)
                            {
                                LocalFolder localFolder = (LocalFolder)folder;
                                boolean include = true;
                                folder.refresh(prefs);
                                String localFolderName = localFolder.getName();
                                if (integrate)
                                {
                                    include = localFolder.isIntegrate();
                                }
                                else
                                {
                                    if (folderNameSet != null)
                                    {
                                        if (!folderNameSet.contains(localFolderName))

                                        {
                                            include = false;
                                        }
                                    }
                                    // Never exclude the INBOX (see issue 1817)
                                    else if (noSpecialFolders && !localFolderName.equals(K9.INBOX) && (
                                                 localFolderName.equals(account.getTrashFolderName()) ||
                                                 localFolderName.equals(account.getOutboxFolderName()) ||
                                                 localFolderName.equals(account.getDraftsFolderName()) ||
                                                 localFolderName.equals(account.getSentFolderName()) ||
                                                 localFolderName.equals(account.getErrorFolderName())))
                                    {
                                        include = false;
                                    }
                                    else if (displayableOnly && modeMismatch(account.getFolderDisplayMode(), folder.getDisplayClass()))
                                    {
                                        include = false;
                                    }
                                }

                                if (include)
                                {
                                    tmpFoldersToSearch.add(localFolder);
                                }
                            }
                            if (tmpFoldersToSearch.size() < 1)
                            {
                                continue;
                            }
                            foldersToSearch = tmpFoldersToSearch;
                        }
                        catch (MessagingException me)
                        {
                            Log.e(K9.LOG_TAG, ""Unable to restrict search folders in Account "" + account.getDescription() + "", searching all"", me);
                            addErrorMessage(account, null, me);
                        }

                    }

                    MessageRetrievalListener retrievalListener = new MessageRetrievalListener()
                    {
                        public void messageStarted(String message, int number, int ofTotal) {}
                        public void messageFinished(Message message, int number, int ofTotal)
                        {
                            if (!isMessageSuppressed(message.getFolder().getAccount(), message.getFolder().getName(), message))
                            {
                                List<Message> messages = new ArrayList<Message>();

                                messages.add(message);
                                stats.unreadMessageCount += (!message.isSet(Flag.SEEN)) ? 1 : 0;
                                stats.flaggedMessageCount += (message.isSet(Flag.FLAGGED)) ? 1 : 0;
                                if (listener != null)
                                {
                                    listener.listLocalMessagesAddMessages(account, null, messages);
                                }
                            }

                        }
                        public void messagesFinished(int number)
                        {

                        }
                    };

                    try
                    {
                        String[] queryFields = {""html_content"",""subject"",""sender_list""};
                        LocalStore localStore = account.getLocalStore();
                        localStore.searchForMessages(retrievalListener, queryFields
                                                     , query, foldersToSearch,
                                                     messagesToSearch == null ? null : messagesToSearch.toArray(EMPTY_MESSAGE_ARRAY),
                                                     requiredFlags, forbiddenFlags);

                    }
                    catch (Exception e)
                    {
                        if (listener != null)
                        {
                            listener.listLocalMessagesFailed(account, null, e.getMessage());
                        }
                        addErrorMessage(account, null, e);
                    }
                    finally
                    {
                        if (listener != null)
                        {
                            listener.listLocalMessagesFinished(account, null);
                        }
                    }
                }
                if (listener != null)
                {
                    listener.searchStats(stats);
                }
            }
        });
    }

    public void loadMoreMessages(Account account, String folder, MessagingListener listener)
    {
        try
        {
            LocalStore localStore = account.getLocalStore();
            LocalFolder localFolder = localStore.getFolder(folder);
            localFolder.setVisibleLimit(localFolder.getVisibleLimit() + account.getDisplayCount());
            synchronizeMailbox(account, folder, listener, null);
        }
        catch (MessagingException me)
        {
            addErrorMessage(account, null, me);

            throw new RuntimeException(""Unable to set visible limit on folder"", me);
        }
    }

    public void resetVisibleLimits(Account[] accounts)
    {
        for (Account account : accounts)
        {
            try
            {
                LocalStore localStore = account.getLocalStore();
                localStore.resetVisibleLimits(account.getDisplayCount());
            }
            catch (MessagingException e)
            {
                addErrorMessage(account, null, e);

                Log.e(K9.LOG_TAG, ""Unable to reset visible limits"", e);
            }
        }
    }

    /**
     * Start background synchronization of the specified folder.
     * @param account
     * @param folder
     * @param listener
     * @param providedRemoteFolder TODO
     */
    public void synchronizeMailbox(final Account account, final String folder, final MessagingListener listener, final Folder providedRemoteFolder)
    {
        putBackground(""synchronizeMailbox"", listener, new Runnable()
        {
            public void run()
            {
                synchronizeMailboxSynchronous(account, folder, listener, providedRemoteFolder);
            }
        });
    }

    /**
     * Start foreground synchronization of the specified folder. This is generally only called
     * by synchronizeMailbox.
     * @param account
     * @param folder
     *
     * TODO Break this method up into smaller chunks.
     * @param providedRemoteFolder TODO
     */
    private void synchronizeMailboxSynchronous(final Account account, final String folder, final MessagingListener listener, Folder providedRemoteFolder)
    {
        Folder remoteFolder = null;
        LocalFolder tLocalFolder = null;

        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Synchronizing folder "" + account.getDescription() + "":"" + folder);

        for (MessagingListener l : getListeners(listener))
        {
            l.synchronizeMailboxStarted(account, folder);
        }
        /*
         * We don't ever sync the Outbox or errors folder
         */
        if (folder.equals(account.getOutboxFolderName()) || folder.equals(account.getErrorFolderName()))
        {
            for (MessagingListener l : getListeners(listener))
            {
                l.synchronizeMailboxFinished(account, folder, 0, 0);
            }

            return;
        }

        Exception commandException = null;
        try
        {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""SYNC: About to process pending commands for account "" +
                      account.getDescription());

            try
            {
                processPendingCommandsSynchronous(account);
            }
            catch (Exception e)
            {
                addErrorMessage(account, null, e);

                Log.e(K9.LOG_TAG, ""Failure processing command, but allow message sync attempt"", e);
                commandException = e;
            }

            /*
             * Get the message list from the local store and create an index of
             * the uids within the list.
             */
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""SYNC: About to get local folder "" + folder);

            final LocalStore localStore = account.getLocalStore();
            tLocalFolder = localStore.getFolder(folder);
            final LocalFolder localFolder = tLocalFolder;
            localFolder.open(OpenMode.READ_WRITE);
            Message[] localMessages = localFolder.getMessages(null);
            HashMap<String, Message> localUidMap = new HashMap<String, Message>();
            for (Message message : localMessages)
            {
                localUidMap.put(message.getUid(), message);
            }

            if (providedRemoteFolder != null)
            {
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""SYNC: using providedRemoteFolder "" + folder);

                remoteFolder = providedRemoteFolder;
            }
            else
            {
                Store remoteStore = account.getRemoteStore();

                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""SYNC: About to get remote folder "" + folder);
                remoteFolder = remoteStore.getFolder(folder);



                if (!  verifyOrCreateRemoteSpecialFolder(account, folder, remoteFolder, listener))
                {
                    return;
                }


                /*
                 * Synchronization process:
                Open the folder
                Upload any local messages that are marked as PENDING_UPLOAD (Drafts, Sent, Trash)
                Get the message count
                Get the list of the newest K9.DEFAULT_VISIBLE_LIMIT messages
                getMessages(messageCount - K9.DEFAULT_VISIBLE_LIMIT, messageCount)
                See if we have each message locally, if not fetch it's flags and envelope
                Get and update the unread count for the folder
                Update the remote flags of any messages we have locally with an internal date
                newer than the remote message.
                Get the current flags for any messages we have locally but did not just download
                Update local flags
                For any message we have locally but not remotely, delete the local message to keep
                cache clean.
                Download larger parts of any new messages.
                (Optional) Download small attachments in the background.
                 */

                /*
                 * Open the remote folder. This pre-loads certain metadata like message count.
                 */
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""SYNC: About to open remote folder "" + folder);

                remoteFolder.open(OpenMode.READ_WRITE);
                if (Account.EXPUNGE_ON_POLL.equals(account.getExpungePolicy()))
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""SYNC: Expunging folder "" + account.getDescription() + "":"" + folder);


                    remoteFolder.expunge();
                }

            }

            /*
             * Get the remote message count.
             */
            int remoteMessageCount = remoteFolder.getMessageCount();

            int visibleLimit = localFolder.getVisibleLimit();

            if (visibleLimit < 1)
            {
                visibleLimit = K9.DEFAULT_VISIBLE_LIMIT;
            }

            Message[] remoteMessageArray = EMPTY_MESSAGE_ARRAY;
            final ArrayList<Message> remoteMessages = new ArrayList<Message>();
            //  final ArrayList<Message> unsyncedMessages = new ArrayList<Message>();
            HashMap<String, Message> remoteUidMap = new HashMap<String, Message>();

            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""SYNC: Remote message count for folder "" + folder + "" is "" + remoteMessageCount);
            final Date earliestDate = account.getEarliestPollDate();
            if (remoteMessageCount > 0)
            {
                /*
                 * Message numbers start at 1.
                 */
                int remoteStart = Math.max(0, remoteMessageCount - visibleLimit) + 1;
                int remoteEnd = remoteMessageCount;

                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""SYNC: About to get messages "" + remoteStart + "" through "" + remoteEnd + "" for folder "" + folder);

                final AtomicInteger headerProgress = new AtomicInteger(0);
                for (MessagingListener l : getListeners(listener))
                {
                    l.synchronizeMailboxHeadersStarted(account, folder);
                }


                remoteMessageArray = remoteFolder.getMessages(remoteStart, remoteEnd, earliestDate, null);

                int messageCount = remoteMessageArray.length;

                for (Message thisMess : remoteMessageArray)
                {
                    headerProgress.incrementAndGet();
                    for (MessagingListener l : getListeners(listener))
                    {
                        l.synchronizeMailboxHeadersProgress(account, folder, headerProgress.get(), messageCount);
                    }
                    Message localMessage = localUidMap.get(thisMess.getUid());
                    if (localMessage == null || !localMessage.olderThan(earliestDate))
                    {
                        remoteMessages.add(thisMess);
                        remoteUidMap.put(thisMess.getUid(), thisMess);
                    }
                }
                if (K9.DEBUG)
                    Log.v(K9.LOG_TAG, ""SYNC: Got "" + remoteUidMap.size() + "" messages for folder "" + folder);

                remoteMessageArray = null;
                for (MessagingListener l : getListeners(listener))
                {
                    l.synchronizeMailboxHeadersFinished(account, folder, headerProgress.get(), remoteUidMap.size());
                }

            }
            else if (remoteMessageCount < 0)
            {
                throw new Exception(""Message count "" + remoteMessageCount + "" for folder "" + folder);
            }

            /*
             * Remove any messages that are in the local store but no longer on the remote store or are too old
             */
            if (account.syncRemoteDeletions())
            {
                for (Message localMessage : localMessages)
                {
                    if (remoteUidMap.get(localMessage.getUid()) == null && !localMessage.isSet(Flag.DELETED))
                    {
                        localMessage.setFlag(Flag.X_DESTROYED, true);

                        for (MessagingListener l : getListeners(listener))
                        {
                            l.synchronizeMailboxRemovedMessage(account, folder, localMessage);
                        }
                    }
                }
            }
            localMessages = null;

            /*
             * Now we download the actual content of messages.
             */
            int newMessages = downloadMessages(account, remoteFolder, localFolder, remoteMessages, false);

            int unreadMessageCount = setLocalUnreadCountToRemote(localFolder, remoteFolder,  newMessages);
            setLocalFlaggedCountToRemote(localFolder, remoteFolder);


            for (MessagingListener l : getListeners())
            {
                l.folderStatusChanged(account, folder, unreadMessageCount);
            }

            /*
             * Notify listeners that we're finally done.
             */

            localFolder.setLastChecked(System.currentTimeMillis());
            localFolder.setStatus(null);

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Done synchronizing folder "" +
                      account.getDescription() + "":"" + folder + "" @ "" + new Date() +
                      "" with "" + newMessages + "" new messages"");

            for (MessagingListener l : getListeners(listener))
            {
                l.synchronizeMailboxFinished(account, folder, remoteMessageCount, newMessages);
            }


            if (commandException != null)
            {
                String rootMessage = getRootCauseMessage(commandException);
                Log.e(K9.LOG_TAG, ""Root cause failure in "" + account.getDescription() + "":"" +
                      tLocalFolder.getName() + "" was '"" + rootMessage + ""'"");
                localFolder.setStatus(rootMessage);
                for (MessagingListener l : getListeners(listener))
                {
                    l.synchronizeMailboxFailed(account, folder, rootMessage);
                }
            }

            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""Done synchronizing folder "" + account.getDescription() + "":"" + folder);

        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""synchronizeMailbox"", e);
            // If we don't set the last checked, it can try too often during
            // failure conditions
            String rootMessage = getRootCauseMessage(e);
            if (tLocalFolder != null)
            {
                try
                {
                    tLocalFolder.setStatus(rootMessage);
                    tLocalFolder.setLastChecked(System.currentTimeMillis());
                }
                catch (MessagingException me)
                {
                    Log.e(K9.LOG_TAG, ""Could not set last checked on folder "" + account.getDescription() + "":"" +
                          tLocalFolder.getName(), e);
                }
            }

            for (MessagingListener l : getListeners(listener))
            {
                l.synchronizeMailboxFailed(
                    account,
                    folder,
                    rootMessage);
            }
            addErrorMessage(account, null, e);
            Log.e(K9.LOG_TAG, ""Failed synchronizing folder "" +
                  account.getDescription() + "":"" + folder + "" @ "" + new Date());

        }
        finally
        {
            if (providedRemoteFolder == null && remoteFolder != null)
            {
                remoteFolder.close();
            }
            if (tLocalFolder != null)
            {
                tLocalFolder.close();
            }
        }

    }

    /*
     * If the folder is a ""special"" folder we need to see if it exists
     * on the remote server. It if does not exist we'll try to create it. If we
     * can't create we'll abort. This will happen on every single Pop3 folder as
     * designed and on Imap folders during error conditions. This allows us
     * to treat Pop3 and Imap the same in this code.
     */
    private boolean verifyOrCreateRemoteSpecialFolder(final Account account, final String folder, final Folder remoteFolder, final MessagingListener listener) throws MessagingException
    {
        if (folder.equals(account.getTrashFolderName()) ||
                folder.equals(account.getSentFolderName()) ||
                folder.equals(account.getDraftsFolderName()))
        {
            if (!remoteFolder.exists())
            {
                if (!remoteFolder.create(FolderType.HOLDS_MESSAGES))
                {
                    for (MessagingListener l : getListeners(listener))
                    {
                        l.synchronizeMailboxFinished(account, folder, 0, 0);
                    }
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Done synchronizing folder "" + folder);

                    return false;
                }
            }
        }
        return true;
    }
    private int setLocalUnreadCountToRemote(LocalFolder localFolder, Folder remoteFolder, int newMessageCount) throws MessagingException
    {
        int remoteUnreadMessageCount = remoteFolder.getUnreadMessageCount();
        if (remoteUnreadMessageCount != -1)
        {
            localFolder.setUnreadMessageCount(remoteUnreadMessageCount);
        }
        else
        {
            int unreadCount = 0;
            Message[] messages = localFolder.getMessages(null, false);
            for (Message message : messages)
            {
                if (!message.isSet(Flag.SEEN) && !message.isSet(Flag.DELETED))
                {
                    unreadCount++;
                }
            }
            localFolder.setUnreadMessageCount(unreadCount);
        }
        return localFolder.getUnreadMessageCount();
    }

    private void setLocalFlaggedCountToRemote(LocalFolder localFolder, Folder remoteFolder) throws MessagingException
    {
        int remoteFlaggedMessageCount = remoteFolder.getFlaggedMessageCount();
        if (remoteFlaggedMessageCount != -1)
        {
            localFolder.setFlaggedMessageCount(remoteFlaggedMessageCount);
        }
        else
        {
            int flaggedCount = 0;
            Message[] messages = localFolder.getMessages(null, false);
            for (Message message : messages)
            {
                if (message.isSet(Flag.FLAGGED) && !message.isSet(Flag.DELETED))
                {
                    flaggedCount++;
                }
            }
            localFolder.setFlaggedMessageCount(flaggedCount);
        }
    }

    private int downloadMessages(final Account account, final Folder remoteFolder,
                                 final LocalFolder localFolder, List<Message> inputMessages, boolean flagSyncOnly) throws MessagingException
    {
        final Date earliestDate = account.getEarliestPollDate();
        if (earliestDate != null)
        {
            if (K9.DEBUG)
            {
                Log.d(K9.LOG_TAG, ""Only syncing messages after "" + earliestDate);
            }
        }
        final String folder = remoteFolder.getName();

        int unreadBeforeStart = 0;
        try
        {
            AccountStats stats = account.getStats(mApplication);
            unreadBeforeStart = stats.unreadMessageCount;

        }
        catch (MessagingException e)
        {
            Log.e(K9.LOG_TAG, ""Unable to getUnreadMessageCount for account: "" + account, e);
        }

        ArrayList<Message> syncFlagMessages = new ArrayList<Message>();
        List<Message> unsyncedMessages = new ArrayList<Message>();
        final AtomicInteger newMessages = new AtomicInteger(0);

        List<Message> messages = new ArrayList<Message>(inputMessages);

        for (Message message : messages)
        {
            if (message.isSet(Flag.DELETED))
            {
                syncFlagMessages.add(message);
            }
            else if (!isMessageSuppressed(account, folder, message))
            {
                Message localMessage = localFolder.getMessage(message.getUid());

                if (localMessage == null)
                {
                    if (!flagSyncOnly)
                    {
                        if (!message.isSet(Flag.X_DOWNLOADED_FULL) && !message.isSet(Flag.X_DOWNLOADED_PARTIAL))
                        {
                            if (K9.DEBUG)
                                Log.v(K9.LOG_TAG, ""Message with uid "" + message.getUid() + "" has not yet been downloaded"");

                            unsyncedMessages.add(message);
                        }
                        else
                        {
                            if (K9.DEBUG)
                                Log.v(K9.LOG_TAG, ""Message with uid "" + message.getUid() + "" is partially or fully downloaded"");

                            // Store the updated message locally
                            localFolder.appendMessages(new Message[] { message });

                            localMessage = localFolder.getMessage(message.getUid());

                            localMessage.setFlag(Flag.X_DOWNLOADED_FULL, message.isSet(Flag.X_DOWNLOADED_FULL));
                            localMessage.setFlag(Flag.X_DOWNLOADED_PARTIAL, message.isSet(Flag.X_DOWNLOADED_PARTIAL));

                            for (MessagingListener l : getListeners())
                            {
                                l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                                if (!localMessage.isSet(Flag.SEEN))
                                {
                                    l.synchronizeMailboxNewMessage(account, folder, localMessage);
                                }
                            }
                        }
                    }
                }
                else if (!localMessage.isSet(Flag.DELETED))
                {
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""Message with uid "" + message.getUid() + "" is present in the local store"");

                    if (!localMessage.isSet(Flag.X_DOWNLOADED_FULL) && !localMessage.isSet(Flag.X_DOWNLOADED_PARTIAL))
                    {
                        if (K9.DEBUG)
                            Log.v(K9.LOG_TAG, ""Message with uid "" + message.getUid()
                                  + "" is not downloaded, even partially; trying again"");

                        unsyncedMessages.add(message);
                    }
                    else
                    {
                        String newPushState = remoteFolder.getNewPushState(localFolder.getPushState(), message);
                        if (newPushState != null)
                        {
                            localFolder.setPushState(newPushState);
                        }
                        syncFlagMessages.add(message);
                    }
                }
            }
        }

        final AtomicInteger progress = new AtomicInteger(0);
        final int todo = unsyncedMessages.size() + syncFlagMessages.size();
        for (MessagingListener l : getListeners())
        {
            l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
        }

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Have "" + unsyncedMessages.size() + "" unsynced messages"");

        messages.clear();
        final ArrayList<Message> largeMessages = new ArrayList<Message>();
        final ArrayList<Message> smallMessages = new ArrayList<Message>();
        if (unsyncedMessages.size() > 0)
        {

            /*
             * Reverse the order of the messages. Depending on the server this may get us
             * fetch results for newest to oldest. If not, no harm done.
             */
            Collections.reverse(unsyncedMessages);
            int visibleLimit = localFolder.getVisibleLimit();
            int listSize = unsyncedMessages.size();

            if (listSize > visibleLimit)
            {
                unsyncedMessages = unsyncedMessages.subList(listSize - visibleLimit, listSize);
            }

            FetchProfile fp = new FetchProfile();
            if (remoteFolder.supportsFetchingFlags())
            {
                fp.add(FetchProfile.Item.FLAGS);
            }
            fp.add(FetchProfile.Item.ENVELOPE);

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""SYNC: About to fetch "" + unsyncedMessages.size() + "" unsynced messages for folder "" + folder);


            fetchUnsyncedMessages(account, remoteFolder, localFolder, unsyncedMessages, smallMessages,largeMessages, progress, todo, fp);

            // If a message didn't exist, messageFinished won't be called, but we shouldn't try again
            // If we got here, nothing failed
            for (Message message : unsyncedMessages)
            {
                String newPushState = remoteFolder.getNewPushState(localFolder.getPushState(), message);
                if (newPushState != null)
                {
                    localFolder.setPushState(newPushState);
                }
            }
            if (K9.DEBUG)
            {
                Log.d(K9.LOG_TAG, ""SYNC: Synced unsynced messages for folder "" + folder);
            }


        }

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Have ""
                  + largeMessages.size() + "" large messages and ""
                  + smallMessages.size() + "" small messages out of ""
                  + unsyncedMessages.size() + "" unsynced messages"");

        unsyncedMessages.clear();

        /*
         * Grab the content of the small messages first. This is going to
         * be very fast and at very worst will be a single up of a few bytes and a single
         * download of 625k.
         */
        FetchProfile fp = new FetchProfile();
        fp.add(FetchProfile.Item.BODY);
        //        fp.add(FetchProfile.Item.FLAGS);
        //        fp.add(FetchProfile.Item.ENVELOPE);

        downloadSmallMessages(account, remoteFolder, localFolder, smallMessages, progress, unreadBeforeStart, newMessages, todo, fp);


        smallMessages.clear();

        /*
         * Now do the large messages that require more round trips.
         */
        fp.clear();
        fp.add(FetchProfile.Item.STRUCTURE);



        downloadLargeMessages(account, remoteFolder, localFolder, largeMessages, progress, unreadBeforeStart,  newMessages, todo, fp);
        largeMessages.clear();

        /*
         * Refresh the flags for any messages in the local store that we didn't just
         * download.
         */

        refreshLocalMessageFlags(account,remoteFolder,localFolder,syncFlagMessages,progress,todo);

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Synced remote messages for folder "" + folder + "", "" + newMessages.get() + "" new messages"");

        localFolder.purgeToVisibleLimit(new MessageRemovalListener()
        {
            public void messageRemoved(Message message)
            {
                for (MessagingListener l : getListeners())
                {
                    l.synchronizeMailboxRemovedMessage(account, folder, message);
                }
            }

        });

        return newMessages.get();
    }

    private void fetchUnsyncedMessages(final Account account, final Folder remoteFolder,
                                       final LocalFolder localFolder,
                                       List<Message> unsyncedMessages,
                                       final ArrayList<Message> smallMessages,
                                       final ArrayList<Message> largeMessages,
                                       final AtomicInteger progress,
                                       final int todo,
                                       FetchProfile fp) throws MessagingException
    {
        final String folder = remoteFolder.getName();

        final Date earliestDate = account.getEarliestPollDate();
        remoteFolder.fetch(unsyncedMessages.toArray(EMPTY_MESSAGE_ARRAY), fp,
                           new MessageRetrievalListener()
        {
            public void messageFinished(Message message, int number, int ofTotal)
            {
                try
                {
                    String newPushState = remoteFolder.getNewPushState(localFolder.getPushState(), message);
                    if (newPushState != null)
                    {
                        localFolder.setPushState(newPushState);
                    }
                    if (message.isSet(Flag.DELETED) || message.olderThan(earliestDate))
                    {

                        if (K9.DEBUG)
                        {
                            if (message.isSet(Flag.DELETED))
                            {
                                Log.v(K9.LOG_TAG, ""Newly downloaded message "" + account + "":"" + folder + "":"" + message.getUid()
                                      + "" was marked deleted on server, skipping"");
                            }
                            else
                            {
                                Log.d(K9.LOG_TAG, ""Newly downloaded message "" + message.getUid() + "" is older than ""
                                      + earliestDate + "", skipping"");
                            }
                        }
                        progress.incrementAndGet();
                        for (MessagingListener l : getListeners())
                        {
                            l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
                        }
                        return;
                    }

                    if (message.getSize() > account.getMaximumAutoDownloadMessageSize())
                    {
                        largeMessages.add(message);
                    }
                    else
                    {
                        smallMessages.add(message);
                    }

                    // And include it in the view
                    if (message.getSubject() != null &&
                            message.getFrom() != null)
                    {
                        /*
                         * We check to make sure that we got something worth
                         * showing (subject and from) because some protocols
                         * (POP) may not be able to give us headers for
                         * ENVELOPE, only size.
                         */
                        if (!isMessageSuppressed(account, folder, message))
                        {
                            // Store the new message locally
                            localFolder.appendMessages(new Message[]
                                                       {
                                                           message
                                                       });

                            Message localMessage = localFolder.getMessage(message.getUid());
                            syncFlags(localMessage, message);
                            if (K9.DEBUG)
                                Log.v(K9.LOG_TAG, ""About to notify listeners that we got a new unsynced message ""
                                      + account + "":"" + folder + "":"" + message.getUid());
                            for (MessagingListener l : getListeners())
                            {
                                l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                            }


                        }

                    }

                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Error while storing downloaded message."", e);
                    addErrorMessage(account, null, e);

                }
            }

            public void messageStarted(String uid, int number, int ofTotal)
            {
            }

            public void messagesFinished(int total) {}
        });
    }


    private boolean shouldImportMessage(final Account account, final String folder, final Message message, final AtomicInteger progress, final Date earliestDate)
    {

        if (isMessageSuppressed(account, folder, message))
        {
            if (K9.DEBUG)
            {
                Log.d(K9.LOG_TAG, ""Message "" + message.getUid() + "" was suppressed ""+
                      ""but just downloaded. ""+
                      ""The race condition means we wasted some bandwidth. Oh well."");
            }
            return false;

        }
        if (message.olderThan(earliestDate))
        {
            if (K9.DEBUG)
            {
                Log.d(K9.LOG_TAG, ""Message "" + message.getUid() + "" is older than ""
                      + earliestDate + "", hence not saving"");
            }
            return false;
        }
        return true;
    }

    private void downloadSmallMessages(final Account account, final Folder remoteFolder,
                                       final LocalFolder localFolder,
                                       ArrayList<Message> smallMessages,
                                       final AtomicInteger progress,
                                       final int unreadBeforeStart,
                                       final AtomicInteger newMessages,
                                       final int todo,
                                       FetchProfile fp) throws MessagingException
    {
        final String folder = remoteFolder.getName();

        final Date earliestDate = account.getEarliestPollDate();

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Fetching small messages for folder "" + folder);

        remoteFolder.fetch(smallMessages.toArray(new Message[smallMessages.size()]),
                           fp, new MessageRetrievalListener()
        {
            public void messageFinished(Message message, int number, int ofTotal)
            {
                try
                {

                    if (!shouldImportMessage(account, folder, message, progress, earliestDate))
                    {
                        progress.incrementAndGet();

                        return;
                    }

                    // Store the updated message locally
                    localFolder.appendMessages(new Message[] { message });

                    Message localMessage = localFolder.getMessage(message.getUid());
                    progress.incrementAndGet();

                    // Set a flag indicating this message has now be fully downloaded
                    localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""About to notify listeners that we got a new small message ""
                              + account + "":"" + folder + "":"" + message.getUid());

                    // Update the listener with what we've found
                    for (MessagingListener l : getListeners())
                    {
                        l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                        l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
                        if (!localMessage.isSet(Flag.SEEN))
                        {
                            l.synchronizeMailboxNewMessage(account, folder, localMessage);
                        }
                    }
                    // Send a notification of this message

                    if (shouldNotifyForMessage(account, message))
                    {
                        newMessages.incrementAndGet();
                        notifyAccount(mApplication, account, message, unreadBeforeStart, newMessages);
                    }

                }
                catch (MessagingException me)
                {
                    addErrorMessage(account, null, me);

                    Log.e(K9.LOG_TAG, ""SYNC: fetch small messages"", me);
                }
            }

            public void messageStarted(String uid, int number, int ofTotal)
            {
            }

            public void messagesFinished(int total) {}
        });

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Done fetching small messages for folder "" + folder);
    }



    private void downloadLargeMessages(final Account account, final Folder remoteFolder,
                                       final LocalFolder localFolder,
                                       ArrayList<Message> largeMessages,
                                       final AtomicInteger progress,
                                       final int unreadBeforeStart,
                                       final AtomicInteger newMessages,
                                       final int todo,
                                       FetchProfile fp) throws MessagingException
    {
        final String folder = remoteFolder.getName();

        final Date earliestDate = account.getEarliestPollDate();

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Fetching large messages for folder "" + folder);

        remoteFolder.fetch(largeMessages.toArray(new Message[largeMessages.size()]), fp, null);
        for (Message message : largeMessages)
        {

            if (!shouldImportMessage(account, folder, message, progress, earliestDate))
            {
                progress.incrementAndGet();
                continue;
            }

            if (message.getBody() == null)
            {
                /*
                 * The provider was unable to get the structure of the message, so
                 * we'll download a reasonable portion of the messge and mark it as
                 * incomplete so the entire thing can be downloaded later if the user
                 * wishes to download it.
                 */
                fp.clear();
                fp.add(FetchProfile.Item.BODY_SANE);
                /*
                 *  TODO a good optimization here would be to make sure that all Stores set
                 *  the proper size after this fetch and compare the before and after size. If
                 *  they equal we can mark this SYNCHRONIZED instead of PARTIALLY_SYNCHRONIZED
                 */

                remoteFolder.fetch(new Message[] { message }, fp, null);

                // Store the updated message locally
                localFolder.appendMessages(new Message[] { message });

                Message localMessage = localFolder.getMessage(message.getUid());


                // Certain (POP3) servers give you the whole message even when you ask for only the first x Kb
                if (!message.isSet(Flag.X_DOWNLOADED_FULL))
                {
                    /*
                     * Mark the message as fully downloaded if the message size is smaller than
                     * the account's autodownload size limit, otherwise mark as only a partial
                     * download.  This will prevent the system from downloading the same message
                     * twice.
                     */
                    if (message.getSize() < account.getMaximumAutoDownloadMessageSize())
                    {
                        localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);
                    }
                    else
                    {
                        // Set a flag indicating that the message has been partially downloaded and
                        // is ready for view.
                        localMessage.setFlag(Flag.X_DOWNLOADED_PARTIAL, true);
                    }
                }
            }
            else
            {
                /*
                 * We have a structure to deal with, from which
                 * we can pull down the parts we want to actually store.
                 * Build a list of parts we are interested in. Text parts will be downloaded
                 * right now, attachments will be left for later.
                 */

                ArrayList<Part> viewables = new ArrayList<Part>();
                ArrayList<Part> attachments = new ArrayList<Part>();
                MimeUtility.collectParts(message, viewables, attachments);

                /*
                 * Now download the parts we're interested in storing.
                 */
                for (Part part : viewables)
                {
                    remoteFolder.fetchPart(message, part, null);
                }
                // Store the updated message locally
                localFolder.appendMessages(new Message[] { message });

                Message localMessage = localFolder.getMessage(message.getUid());

                // Set a flag indicating this message has been fully downloaded and can be
                // viewed.
                localMessage.setFlag(Flag.X_DOWNLOADED_PARTIAL, true);
            }
            if (K9.DEBUG)
                Log.v(K9.LOG_TAG, ""About to notify listeners that we got a new large message ""
                      + account + "":"" + folder + "":"" + message.getUid());

            // Update the listener with what we've found
            progress.incrementAndGet();
            Message localMessage = localFolder.getMessage(message.getUid());
            for (MessagingListener l : getListeners())
            {
                l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
                if (!localMessage.isSet(Flag.SEEN))
                {
                    l.synchronizeMailboxNewMessage(account, folder, localMessage);
                }
            }

            // Send a notification of this message
            if (shouldNotifyForMessage(account, message))
            {
                newMessages.incrementAndGet();
                notifyAccount(mApplication, account, message, unreadBeforeStart, newMessages);
            }

        }//for large messsages
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""SYNC: Done fetching large messages for folder "" + folder);

    }

    private void refreshLocalMessageFlags(final Account account, final Folder remoteFolder,
                                          final LocalFolder localFolder,
                                          ArrayList<Message> syncFlagMessages,
                                          final AtomicInteger progress,
                                          final int todo
                                         ) throws MessagingException
    {

        final String folder = remoteFolder.getName();
        if (remoteFolder.supportsFetchingFlags())
        {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""SYNC: About to sync flags for ""
                      + syncFlagMessages.size() + "" remote messages for folder "" + folder);

            FetchProfile fp = new FetchProfile();
            fp.add(FetchProfile.Item.FLAGS);

            List<Message> undeletedMessages = new LinkedList<Message>();
            for (Message message : syncFlagMessages)
            {
                if (!message.isSet(Flag.DELETED))
                {
                    undeletedMessages.add(message);
                }
            }

            remoteFolder.fetch(undeletedMessages.toArray(EMPTY_MESSAGE_ARRAY), fp, null);
            for (Message remoteMessage : syncFlagMessages)
            {
                Message localMessage = localFolder.getMessage(remoteMessage.getUid());
                boolean messageChanged = syncFlags(localMessage, remoteMessage);
                if (messageChanged)
                {
                    if (localMessage.isSet(Flag.DELETED) || isMessageSuppressed(account, folder, localMessage))
                    {
                        for (MessagingListener l : getListeners())
                        {
                            l.synchronizeMailboxRemovedMessage(account, folder, localMessage);
                        }
                    }
                    else
                    {
                        for (MessagingListener l : getListeners())
                        {
                            l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage);
                        }
                    }

                }
                progress.incrementAndGet();
                for (MessagingListener l : getListeners())
                {
                    l.synchronizeMailboxProgress(account, folder, progress.get(), todo);
                }
            }
        }
    }

    private boolean syncFlags(Message localMessage, Message remoteMessage) throws MessagingException
    {
        boolean messageChanged = false;
        if (localMessage == null || localMessage.isSet(Flag.DELETED))
        {
            return false;
        }
        if (remoteMessage.isSet(Flag.DELETED))
        {
            if (localMessage.getFolder().getAccount().syncRemoteDeletions())
            {
                localMessage.setFlag(Flag.DELETED, true);
                messageChanged = true;
            }
        }
        else
        {
            for (Flag flag : new Flag[] { Flag.SEEN, Flag.FLAGGED, Flag.ANSWERED })
            {
                if (remoteMessage.isSet(flag) != localMessage.isSet(flag))
                {
                    localMessage.setFlag(flag, remoteMessage.isSet(flag));
                    messageChanged = true;
                }
            }
        }
        return messageChanged;
    }
    private String getRootCauseMessage(Throwable t)
    {
        Throwable rootCause = t;
        Throwable nextCause = rootCause;
        do
        {
            nextCause = rootCause.getCause();
            if (nextCause != null)
            {
                rootCause = nextCause;
            }
        }
        while (nextCause != null);
        return rootCause.getMessage();
    }

    private void queuePendingCommand(Account account, PendingCommand command)
    {
        try
        {
            LocalStore localStore = account.getLocalStore();
            localStore.addPendingCommand(command);
        }
        catch (Exception e)
        {
            addErrorMessage(account, null, e);

            throw new RuntimeException(""Unable to enqueue pending command"", e);
        }
    }

    private void processPendingCommands(final Account account)
    {
        putBackground(""processPendingCommands"", null, new Runnable()
        {
            public void run()
            {
                try
                {
                    processPendingCommandsSynchronous(account);
                }
                catch (MessagingException me)
                {
                    Log.e(K9.LOG_TAG, ""processPendingCommands"", me);

                    addErrorMessage(account, null, me);

                    /*
                     * Ignore any exceptions from the commands. Commands will be processed
                     * on the next round.
                     */
                }
            }
        });
    }

    private void processPendingCommandsSynchronous(Account account) throws MessagingException
    {
        LocalStore localStore = account.getLocalStore();
        ArrayList<PendingCommand> commands = localStore.getPendingCommands();

        int progress = 0;
        int todo = commands.size();
        if (todo == 0)
        {
            return;
        }

        for (MessagingListener l : getListeners())
        {
            l.pendingCommandsProcessing(account);
            l.synchronizeMailboxProgress(account, null, progress, todo);
        }

        PendingCommand processingCommand = null;
        try
        {
            for (PendingCommand command : commands)
            {
                processingCommand = command;
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Processing pending command '"" + command + ""'"");

                String[] components = command.command.split(""\\."");
                String commandTitle = components[components.length - 1];
                for (MessagingListener l : getListeners())
                {
                    l.pendingCommandStarted(account, commandTitle);
                }
                /*
                 * We specifically do not catch any exceptions here. If a command fails it is
                 * most likely due to a server or IO error and it must be retried before any
                 * other command processes. This maintains the order of the commands.
                 */
                try
                {
                    if (PENDING_COMMAND_APPEND.equals(command.command))
                    {
                        processPendingAppend(command, account);
                    }
                    else if (PENDING_COMMAND_SET_FLAG_BULK.equals(command.command))
                    {
                        processPendingSetFlag(command, account);
                    }
                    else if (PENDING_COMMAND_SET_FLAG.equals(command.command))
                    {
                        processPendingSetFlagOld(command, account);
                    }
                    else if (PENDING_COMMAND_MARK_ALL_AS_READ.equals(command.command))
                    {
                        processPendingMarkAllAsRead(command, account);
                    }
                    else if (PENDING_COMMAND_MOVE_OR_COPY_BULK.equals(command.command))
                    {
                        processPendingMoveOrCopy(command, account);
                    }
                    else if (PENDING_COMMAND_MOVE_OR_COPY.equals(command.command))
                    {
                        processPendingMoveOrCopyOld(command, account);
                    }
                    else if (PENDING_COMMAND_EMPTY_TRASH.equals(command.command))
                    {
                        processPendingEmptyTrash(command, account);
                    }
                    else if (PENDING_COMMAND_EXPUNGE.equals(command.command))
                    {
                        processPendingExpunge(command, account);
                    }
                    localStore.removePendingCommand(command);
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Done processing pending command '"" + command + ""'"");
                }
                catch (MessagingException me)
                {
                    if (me.isPermanentFailure())
                    {
                        addErrorMessage(account, null, me);
                        Log.e(K9.LOG_TAG, ""Failure of command '"" + command + ""' was permanent, removing command from queue"");
                        localStore.removePendingCommand(processingCommand);
                    }
                    else
                    {
                        throw me;
                    }
                }
                finally
                {
                    progress++;
                    for (MessagingListener l : getListeners())
                    {
                        l.synchronizeMailboxProgress(account, null, progress, todo);
                        l.pendingCommandCompleted(account, commandTitle);
                    }
                }
            }
        }
        catch (MessagingException me)
        {
            addErrorMessage(account, null, me);
            Log.e(K9.LOG_TAG, ""Could not process command '"" + processingCommand + ""'"", me);
            throw me;
        }
        finally
        {
            for (MessagingListener l : getListeners())
            {
                l.pendingCommandsFinished(account);
            }
        }
    }

    /**
     * Process a pending append message command. This command uploads a local message to the
     * server, first checking to be sure that the server message is not newer than
     * the local message. Once the local message is successfully processed it is deleted so
     * that the server message will be synchronized down without an additional copy being
     * created.
     * TODO update the local message UID instead of deleteing it
     *
     * @param command arguments = (String folder, String uid)
     * @param account
     * @throws MessagingException
     */
    private void processPendingAppend(PendingCommand command, Account account)
    throws MessagingException
    {
        Folder remoteFolder = null;
        LocalFolder localFolder = null;
        try
        {

            String folder = command.arguments[0];
            String uid = command.arguments[1];

            if (account.getErrorFolderName().equals(folder))
            {
                return;
            }

            LocalStore localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folder);
            LocalMessage localMessage = (LocalMessage) localFolder.getMessage(uid);

            if (localMessage == null)
            {
                return;
            }

            Store remoteStore = account.getRemoteStore();
            remoteFolder = remoteStore.getFolder(folder);
            if (!remoteFolder.exists())
            {
                if (!remoteFolder.create(FolderType.HOLDS_MESSAGES))
                {
                    return;
                }
            }
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE)
            {
                return;
            }

            Message remoteMessage = null;
            if (!localMessage.getUid().startsWith(K9.LOCAL_UID_PREFIX))
            {
                remoteMessage = remoteFolder.getMessage(localMessage.getUid());
            }

            if (remoteMessage == null)
            {
                if (localMessage.isSet(Flag.X_REMOTE_COPY_STARTED))
                {
                    Log.w(K9.LOG_TAG, ""Local message with uid "" + localMessage.getUid() +
                          "" has flag "" + Flag.X_REMOTE_COPY_STARTED + "" already set, checking for remote message with "" +
                          "" same message id"");
                    String rUid = remoteFolder.getUidFromMessageId(localMessage);
                    if (rUid != null)
                    {
                        Log.w(K9.LOG_TAG, ""Local message has flag "" + Flag.X_REMOTE_COPY_STARTED + "" already set, and there is a remote message with "" +
                              "" uid "" + rUid + "", assuming message was already copied and aborting this copy"");

                        String oldUid = localMessage.getUid();
                        localMessage.setUid(rUid);
                        localFolder.changeUid(localMessage);
                        for (MessagingListener l : getListeners())
                        {
                            l.messageUidChanged(account, folder, oldUid, localMessage.getUid());
                        }
                        return;
                    }
                    else
                    {
                        Log.w(K9.LOG_TAG, ""No remote message with message-id found, proceeding with append"");
                    }
                }

                /*
                 * If the message does not exist remotely we just upload it and then
                 * update our local copy with the new uid.
                 */
                FetchProfile fp = new FetchProfile();
                fp.add(FetchProfile.Item.BODY);
                localFolder.fetch(new Message[]
                                  {
                                      localMessage
                                  }
                                  , fp, null);
                String oldUid = localMessage.getUid();
                localMessage.setFlag(Flag.X_REMOTE_COPY_STARTED, true);
                remoteFolder.appendMessages(new Message[] { localMessage });

                localFolder.changeUid(localMessage);
                for (MessagingListener l : getListeners())
                {
                    l.messageUidChanged(account, folder, oldUid, localMessage.getUid());
                }
            }
            else
            {
                /*
                 * If the remote message exists we need to determine which copy to keep.
                 */
                /*
                 * See if the remote message is newer than ours.
                 */
                FetchProfile fp = new FetchProfile();
                fp.add(FetchProfile.Item.ENVELOPE);
                remoteFolder.fetch(new Message[] { remoteMessage }, fp, null);
                Date localDate = localMessage.getInternalDate();
                Date remoteDate = remoteMessage.getInternalDate();
                if (remoteDate != null && remoteDate.compareTo(localDate) > 0)
                {
                    /*
                     * If the remote message is newer than ours we'll just
                     * delete ours and move on. A sync will get the server message
                     * if we need to be able to see it.
                     */
                    localMessage.setFlag(Flag.X_DESTROYED, true);
                }
                else
                {
                    /*
                     * Otherwise we'll upload our message and then delete the remote message.
                     */
                    fp.clear();
                    fp = new FetchProfile();
                    fp.add(FetchProfile.Item.BODY);
                    localFolder.fetch(new Message[] { localMessage }, fp, null);
                    String oldUid = localMessage.getUid();

                    localMessage.setFlag(Flag.X_REMOTE_COPY_STARTED, true);

                    remoteFolder.appendMessages(new Message[] { localMessage });
                    localFolder.changeUid(localMessage);
                    for (MessagingListener l : getListeners())
                    {
                        l.messageUidChanged(account, folder, oldUid, localMessage.getUid());
                    }
                    if (remoteDate != null)
                    {
                        remoteMessage.setFlag(Flag.DELETED, true);
                        if (Account.EXPUNGE_IMMEDIATELY.equals(account.getExpungePolicy()))
                        {
                            remoteFolder.expunge();
                        }
                    }
                }
            }
        }
        finally
        {
            if (remoteFolder != null)
            {
                remoteFolder.close();
            }
            if (localFolder != null)
            {
                localFolder.close();
            }
        }
    }
    private void queueMoveOrCopy(Account account, String srcFolder, String destFolder, boolean isCopy, String uids[])
    {
        if (account.getErrorFolderName().equals(srcFolder))
        {
            return;
        }
        PendingCommand command = new PendingCommand();
        command.command = PENDING_COMMAND_MOVE_OR_COPY_BULK;

        int length = 3 + uids.length;
        command.arguments = new String[length];
        command.arguments[0] = srcFolder;
        command.arguments[1] = destFolder;
        command.arguments[2] = Boolean.toString(isCopy);
        for (int i = 0; i < uids.length; i++)
        {
            command.arguments[3 + i] = uids[i];
        }
        queuePendingCommand(account, command);
    }
    /**
     * Process a pending trash message command.
     *
     * @param command arguments = (String folder, String uid)
     * @param account
     * @throws MessagingException
     */
    private void processPendingMoveOrCopy(PendingCommand command, Account account)
    throws MessagingException
    {
        Folder remoteSrcFolder = null;
        Folder remoteDestFolder = null;
        try
        {
            String srcFolder = command.arguments[0];
            if (account.getErrorFolderName().equals(srcFolder))
            {
                return;
            }
            String destFolder = command.arguments[1];
            String isCopyS = command.arguments[2];
            Store remoteStore = account.getRemoteStore();
            remoteSrcFolder = remoteStore.getFolder(srcFolder);

            List<Message> messages = new ArrayList<Message>();
            for (int i = 3; i < command.arguments.length; i++)
            {
                String uid = command.arguments[i];
                if (!uid.startsWith(K9.LOCAL_UID_PREFIX))
                {
                    messages.add(remoteSrcFolder.getMessage(uid));
                }
            }

            boolean isCopy = false;
            if (isCopyS != null)
            {
                isCopy = Boolean.parseBoolean(isCopyS);
            }

            if (!remoteSrcFolder.exists())
            {
                throw new MessagingException(""processingPendingMoveOrCopy: remoteFolder "" + srcFolder + "" does not exist"", true);
            }
            remoteSrcFolder.open(OpenMode.READ_WRITE);
            if (remoteSrcFolder.getMode() != OpenMode.READ_WRITE)
            {
                throw new MessagingException(""processingPendingMoveOrCopy: could not open remoteSrcFolder "" + srcFolder + "" read/write"", true);
            }

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""processingPendingMoveOrCopy: source folder = "" + srcFolder
                      + "", "" + messages.size() + "" messages, destination folder = "" + destFolder + "", isCopy = "" + isCopy);

            if (!isCopy && destFolder.equals(account.getTrashFolderName()))
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""processingPendingMoveOrCopy doing special case for deleting message"");

                String destFolderName = destFolder;
                if (K9.FOLDER_NONE.equals(destFolderName))
                {
                    destFolderName = null;
                }
                remoteSrcFolder.delete(messages.toArray(EMPTY_MESSAGE_ARRAY), destFolderName);
            }
            else
            {
                remoteDestFolder = remoteStore.getFolder(destFolder);

                if (isCopy)
                {
                    remoteSrcFolder.copyMessages(messages.toArray(EMPTY_MESSAGE_ARRAY), remoteDestFolder);
                }
                else
                {
                    remoteSrcFolder.moveMessages(messages.toArray(EMPTY_MESSAGE_ARRAY), remoteDestFolder);
                }
            }
            if (!isCopy && Account.EXPUNGE_IMMEDIATELY.equals(account.getExpungePolicy()))
            {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""processingPendingMoveOrCopy expunging folder "" + account.getDescription() + "":"" + srcFolder);

                remoteSrcFolder.expunge();
            }
        }
        finally
        {
            if (remoteSrcFolder != null)
            {
                remoteSrcFolder.close();
            }
            if (remoteDestFolder != null)
            {
                remoteDestFolder.close();
            }
        }


    }

    private void queueSetFlag(final Account account, final String folderName, final String newState, final String flag, final String[] uids)
    {
        putBackground(""queueSetFlag "" + account.getDescription() + "":"" + folderName, null, new Runnable()
        {
            public void run()
            {
                PendingCommand command = new PendingCommand();
                command.command = PENDING_COMMAND_SET_FLAG_BULK;
                int length = 3 + uids.length;
                command.arguments = new String[length];
                command.arguments[0] = folderName;
                command.arguments[1] = newState;
                command.arguments[2] = flag;
                for (int i = 0; i < uids.length; i++)
                {
                    command.arguments[3 + i] = uids[i];
                }
                queuePendingCommand(account, command);
                processPendingCommands(account);
            }
        });
    }
    /**
     * Processes a pending mark read or unread command.
     *
     * @param command arguments = (String folder, String uid, boolean read)
     * @param account
     */
    private void processPendingSetFlag(PendingCommand command, Account account)
    throws MessagingException
    {
        String folder = command.arguments[0];

        if (account.getErrorFolderName().equals(folder))
        {
            return;
        }

        boolean newState = Boolean.parseBoolean(command.arguments[1]);

        Flag flag = Flag.valueOf(command.arguments[2]);

        Store remoteStore = account.getRemoteStore();
        Folder remoteFolder = remoteStore.getFolder(folder);
        if (!remoteFolder.exists() ||
                /*
                 * Don't proceed if the remote folder doesn't support flags and
                 * the flag to be changed isn't the deleted flag. This avoids
                 * unnecessary connections to POP3 servers.
                 */
                // TODO: This should actually call a supportsSettingFlag(flag) method.
                (!remoteFolder.supportsFetchingFlags() && !Flag.DELETED.equals(flag)))
        {
            return;
        }

        try
        {
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE)
            {
                return;
            }
            List<Message> messages = new ArrayList<Message>();
            for (int i = 3; i < command.arguments.length; i++)
            {
                String uid = command.arguments[i];
                if (!uid.startsWith(K9.LOCAL_UID_PREFIX))
                {
                    messages.add(remoteFolder.getMessage(uid));
                }
            }

            if (messages.size() == 0)
            {
                return;
            }
            remoteFolder.setFlags(messages.toArray(EMPTY_MESSAGE_ARRAY), new Flag[] { flag }, newState);
        }
        finally
        {
            if (remoteFolder != null)
            {
                remoteFolder.close();
            }
        }
    }

    // TODO: This method is obsolete and is only for transition from K-9 2.0 to K-9 2.1
    // Eventually, it should be removed
    private void processPendingSetFlagOld(PendingCommand command, Account account)
    throws MessagingException
    {
        String folder = command.arguments[0];
        String uid = command.arguments[1];

        if (account.getErrorFolderName().equals(folder))
        {
            return;
        }
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""processPendingSetFlagOld: folder = "" + folder + "", uid = "" + uid);

        boolean newState = Boolean.parseBoolean(command.arguments[2]);

        Flag flag = Flag.valueOf(command.arguments[3]);
        Folder remoteFolder = null;
        try
        {
            Store remoteStore = account.getRemoteStore();
            remoteFolder = remoteStore.getFolder(folder);
            if (!remoteFolder.exists())
            {
                return;
            }
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE)
            {
                return;
            }
            Message remoteMessage = null;
            if (!uid.startsWith(K9.LOCAL_UID_PREFIX))
            {
                remoteMessage = remoteFolder.getMessage(uid);
            }
            if (remoteMessage == null)
            {
                return;
            }
            remoteMessage.setFlag(flag, newState);
        }
        finally
        {
            if (remoteFolder != null)
            {
                remoteFolder.close();
            }
        }
    }
    private void queueExpunge(final Account account, final String folderName)
    {
        putBackground(""queueExpunge "" + account.getDescription() + "":"" + folderName, null, new Runnable()
        {
            public void run()
            {
                PendingCommand command = new PendingCommand();
                command.command = PENDING_COMMAND_EXPUNGE;

                command.arguments = new String[1];

                command.arguments[0] = folderName;
                queuePendingCommand(account, command);
                processPendingCommands(account);
            }
        });
    }
    private void processPendingExpunge(PendingCommand command, Account account)
    throws MessagingException
    {
        String folder = command.arguments[0];

        if (account.getErrorFolderName().equals(folder))
        {
            return;
        }
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""processPendingExpunge: folder = "" + folder);

        Store remoteStore = account.getRemoteStore();
        Folder remoteFolder = remoteStore.getFolder(folder);
        try
        {
            if (!remoteFolder.exists())
            {
                return;
            }
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE)
            {
                return;
            }
            remoteFolder.expunge();
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""processPendingExpunge: complete for folder = "" + folder);
        }
        finally
        {
            if (remoteFolder != null)
            {
                remoteFolder.close();
            }
        }
    }


    // TODO: This method is obsolete and is only for transition from K-9 2.0 to K-9 2.1
    // Eventually, it should be removed
    private void processPendingMoveOrCopyOld(PendingCommand command, Account account)
    throws MessagingException
    {
        String srcFolder = command.arguments[0];
        String uid = command.arguments[1];
        String destFolder = command.arguments[2];
        String isCopyS = command.arguments[3];

        boolean isCopy = false;
        if (isCopyS != null)
        {
            isCopy = Boolean.parseBoolean(isCopyS);
        }

        if (account.getErrorFolderName().equals(srcFolder))
        {
            return;
        }

        Store remoteStore = account.getRemoteStore();
        Folder remoteSrcFolder = remoteStore.getFolder(srcFolder);
        Folder remoteDestFolder = remoteStore.getFolder(destFolder);

        if (!remoteSrcFolder.exists())
        {
            throw new MessagingException(""processPendingMoveOrCopyOld: remoteFolder "" + srcFolder + "" does not exist"", true);
        }
        remoteSrcFolder.open(OpenMode.READ_WRITE);
        if (remoteSrcFolder.getMode() != OpenMode.READ_WRITE)
        {
            throw new MessagingException(""processPendingMoveOrCopyOld: could not open remoteSrcFolder "" + srcFolder + "" read/write"", true);
        }

        Message remoteMessage = null;
        if (!uid.startsWith(K9.LOCAL_UID_PREFIX))
        {
            remoteMessage = remoteSrcFolder.getMessage(uid);
        }
        if (remoteMessage == null)
        {
            throw new MessagingException(""processPendingMoveOrCopyOld: remoteMessage "" + uid + "" does not exist"", true);
        }

        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""processPendingMoveOrCopyOld: source folder = "" + srcFolder
                  + "", uid = "" + uid + "", destination folder = "" + destFolder + "", isCopy = "" + isCopy);

        if (!isCopy && destFolder.equals(account.getTrashFolderName()))
        {
            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""processPendingMoveOrCopyOld doing special case for deleting message"");

            remoteMessage.delete(account.getTrashFolderName());
            remoteSrcFolder.close();
            return;
        }

        remoteDestFolder.open(OpenMode.READ_WRITE);
        if (remoteDestFolder.getMode() != OpenMode.READ_WRITE)
        {
            throw new MessagingException(""processPendingMoveOrCopyOld: could not open remoteDestFolder "" + srcFolder + "" read/write"", true);
        }

        if (isCopy)
        {
            remoteSrcFolder.copyMessages(new Message[] { remoteMessage }, remoteDestFolder);
        }
        else
        {
            remoteSrcFolder.moveMessages(new Message[] { remoteMessage }, remoteDestFolder);
        }
        remoteSrcFolder.close();
        remoteDestFolder.close();
    }

    private void processPendingMarkAllAsRead(PendingCommand command, Account account) throws MessagingException
    {
        String folder = command.arguments[0];
        Folder remoteFolder = null;
        LocalFolder localFolder = null;
        try
        {
            Store localStore = account.getLocalStore();
            localFolder = (LocalFolder) localStore.getFolder(folder);
            localFolder.open(OpenMode.READ_WRITE);
            Message[] messages = localFolder.getMessages(null, false);
            for (Message message : messages)
            {
                if (!message.isSet(Flag.SEEN))
                {
                    message.setFlag(Flag.SEEN, true);
                    for (MessagingListener l : getListeners())
                    {
                        l.listLocalMessagesUpdateMessage(account, folder, message);
                    }
                }
            }
            localFolder.setUnreadMessageCount(0);
            for (MessagingListener l : getListeners())
            {
                l.folderStatusChanged(account, folder, 0);
            }


            if (account.getErrorFolderName().equals(folder))
            {
                return;
            }

            Store remoteStore = account.getRemoteStore();
            remoteFolder = remoteStore.getFolder(folder);

            if (!remoteFolder.exists())
            {
                return;
            }
            remoteFolder.open(OpenMode.READ_WRITE);
            if (remoteFolder.getMode() != OpenMode.READ_WRITE)
            {
                return;
            }

            remoteFolder.setFlags(new Flag[] {Flag.SEEN}, true);
            remoteFolder.close();
        }
        catch (UnsupportedOperationException uoe)
        {
            Log.w(K9.LOG_TAG, ""Could not mark all server-side as read because store doesn't support operation"", uoe);
        }
        finally
        {
            if (localFolder != null)
            {
                localFolder.close();
            }
            if (remoteFolder != null)
            {
                remoteFolder.close();
            }
        }
    }

    static long uidfill = 0;
    static AtomicBoolean loopCatch = new AtomicBoolean();
    public void addErrorMessage(Account account, String subject, Throwable t)
    {
        if (!loopCatch.compareAndSet(false, true))
        {
            return;
        }
        try
        {
            if (t == null)
            {
                return;
            }

            CharArrayWriter baos = new CharArrayWriter(t.getStackTrace().length * 10);
            PrintWriter ps = new PrintWriter(baos);
            t.printStackTrace(ps);
            ps.close();

            if (subject == null)
            {
                subject = getRootCauseMessage(t);
            }

            addErrorMessage(account, subject, baos.toString());
        }
        catch (Throwable it)
        {
            Log.e(K9.LOG_TAG, ""Could not save error message to "" + account.getErrorFolderName(), it);
        }
        finally
        {
            loopCatch.set(false);
        }
    }

    public void addErrorMessage(Account account, String subject, String body)
    {
        if (!K9.ENABLE_ERROR_FOLDER)
        {
            return;
        }
        if (!loopCatch.compareAndSet(false, true))
        {
            return;
        }
        try
        {
            if (body == null || body.length() < 1)
            {
                return;
            }

            Store localStore = account.getLocalStore();
            LocalFolder localFolder = (LocalFolder)localStore.getFolder(account.getErrorFolderName());
            Message[] messages = new Message[1];
            MimeMessage message = new MimeMessage();


            message.setBody(new TextBody(body));
            message.setFlag(Flag.X_DOWNLOADED_FULL, true);
            message.setSubject(subject);

            long nowTime = System.currentTimeMillis();
            Date nowDate = new Date(nowTime);
            message.setInternalDate(nowDate);
            message.addSentDate(nowDate);
            message.setFrom(new Address(account.getEmail(), ""K9mail internal""));
            messages[0] = message;

            localFolder.appendMessages(messages);

            localFolder.deleteMessagesOlderThan(nowTime - (15 * 60 * 1000));

        }
        catch (Throwable it)
        {
            Log.e(K9.LOG_TAG, ""Could not save error message to "" + account.getErrorFolderName(), it);
        }
        finally
        {
            loopCatch.set(false);
        }
    }



    public void markAllMessagesRead(final Account account, final String folder)
    {

        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Marking all messages in "" + account.getDescription() + "":"" + folder + "" as read"");
        List<String> args = new ArrayList<String>();
        args.add(folder);
        PendingCommand command = new PendingCommand();
        command.command = PENDING_COMMAND_MARK_ALL_AS_READ;
        command.arguments = args.toArray(EMPTY_STRING_ARRAY);
        queuePendingCommand(account, command);
        processPendingCommands(account);
    }

    public void setFlag(
        final Message[] messages,
        final Flag flag,
        final boolean newState)
    {
        actOnMessages(messages, new MessageActor()
        {
            @Override
            public void act(final Account account, final Folder folder,
                            final List<Message> messages)
            {
                String[] uids = new String[messages.size()];
                for (int i = 0; i < messages.size(); i++)
                {
                    uids[i] = messages.get(i).getUid();
                }
                setFlag(account, folder.getName(), uids, flag, newState);
            }

        });

    }

    public void setFlag(
        final Account account,
        final String folderName,
        final String[] uids,
        final Flag flag,
        final boolean newState)
    {
        // TODO: put this into the background, but right now that causes odd behavior
        // because the FolderMessageList doesn't have its own cache of the flag states
        Folder localFolder = null;
        try
        {
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folderName);
            localFolder.open(OpenMode.READ_WRITE);
            ArrayList<Message> messages = new ArrayList<Message>();
            for (String uid : uids)
            {
                // Allows for re-allowing sending of messages that could not be sent
                if (flag == Flag.FLAGGED && !newState
                        && uid != null
                        && account.getOutboxFolderName().equals(folderName))
                {
                    sendCount.remove(uid);
                }
                Message msg = localFolder.getMessage(uid);
                if (msg != null)
                {
                    messages.add(msg);
                }
            }

            localFolder.setFlags(messages.toArray(EMPTY_MESSAGE_ARRAY), new Flag[] {flag}, newState);


            for (MessagingListener l : getListeners())
            {
                l.folderStatusChanged(account, folderName, localFolder.getUnreadMessageCount());
            }

            if (account.getErrorFolderName().equals(folderName))
            {
                return;
            }

            queueSetFlag(account, folderName, Boolean.toString(newState), flag.toString(), uids);
            processPendingCommands(account);
        }
        catch (MessagingException me)
        {
            addErrorMessage(account, null, me);

            throw new RuntimeException(me);
        }
        finally
        {
            if (localFolder != null)
            {
                localFolder.close();
            }
        }
    }//setMesssageFlag

    public void clearAllPending(final Account account)
    {
        try
        {
            Log.w(K9.LOG_TAG, ""Clearing pending commands!"");
            LocalStore localStore = account.getLocalStore();
            localStore.removePendingCommands();
        }
        catch (MessagingException me)
        {
            Log.e(K9.LOG_TAG, ""Unable to clear pending command"", me);
            addErrorMessage(account, null, me);
        }
    }

    public void loadMessageForViewRemote(final Account account, final String folder,
                                         final String uid, final MessagingListener listener)
    {
        put(""loadMessageForViewRemote"", listener, new Runnable()
        {
            public void run()
            {
                Folder remoteFolder = null;
                LocalFolder localFolder = null;
                try
                {
                    LocalStore localStore = account.getLocalStore();
                    localFolder = localStore.getFolder(folder);
                    localFolder.open(OpenMode.READ_WRITE);

                    Message message = localFolder.getMessage(uid);

                    if (message.isSet(Flag.X_DOWNLOADED_FULL))
                    {
                        /*
                         * If the message has been synchronized since we were called we'll
                         * just hand it back cause it's ready to go.
                         */
                        FetchProfile fp = new FetchProfile();
                        fp.add(FetchProfile.Item.ENVELOPE);
                        fp.add(FetchProfile.Item.BODY);
                        localFolder.fetch(new Message[] { message }, fp, null);
                    }
                    else
                    {
                        /*
                         * At this point the message is not available, so we need to download it
                         * fully if possible.
                         */

                        Store remoteStore = account.getRemoteStore();
                        remoteFolder = remoteStore.getFolder(folder);
                        remoteFolder.open(OpenMode.READ_WRITE);

                        // Get the remote message and fully download it
                        Message remoteMessage = remoteFolder.getMessage(uid);
                        FetchProfile fp = new FetchProfile();
                        fp.add(FetchProfile.Item.BODY);
                        remoteFolder.fetch(new Message[] { remoteMessage }, fp, null);

                        // Store the message locally and load the stored message into memory
                        localFolder.appendMessages(new Message[] { remoteMessage });
                        fp.add(FetchProfile.Item.ENVELOPE);
                        message = localFolder.getMessage(uid);
                        localFolder.fetch(new Message[] { message }, fp, null);

                        // Mark that this message is now fully synched
                        message.setFlag(Flag.X_DOWNLOADED_FULL, true);
                    }

                    // now that we have the full message, refresh the headers
                    for (MessagingListener l : getListeners(listener))
                    {
                        l.loadMessageForViewHeadersAvailable(account, folder, uid, message);
                    }

                    for (MessagingListener l : getListeners(listener))
                    {
                        l.loadMessageForViewBodyAvailable(account, folder, uid, message);
                    }
                    for (MessagingListener l : getListeners(listener))
                    {
                        l.loadMessageForViewFinished(account, folder, uid, message);
                    }
                }
                catch (Exception e)
                {
                    for (MessagingListener l : getListeners(listener))
                    {
                        l.loadMessageForViewFailed(account, folder, uid, e);
                    }
                    addErrorMessage(account, null, e);

                }
                finally
                {
                    if (remoteFolder!=null)
                    {
                        remoteFolder.close();
                    }

                    if (localFolder!=null)
                    {
                        localFolder.close();
                    }
                }//finally
            }//run
        });
    }

    public void loadMessageForView(final Account account, final String folder, final String uid,
                                   final MessagingListener listener)
    {
        for (MessagingListener l : getListeners(listener))
        {
            l.loadMessageForViewStarted(account, folder, uid);
        }
        threadPool.execute(new Runnable()
        {
            public void run()
            {

                try
                {
                    LocalStore localStore = account.getLocalStore();
                    LocalFolder localFolder = localStore.getFolder(folder);
                    localFolder.open(OpenMode.READ_WRITE);

                    LocalMessage message = (LocalMessage)localFolder.getMessage(uid);
                    if (message==null
                            || message.getId()==0)
                    {
                        throw new IllegalArgumentException(""Message not found: folder="" + folder + "", uid="" + uid);
                    }
                    if (!message.isSet(Flag.SEEN))
                    {
                        message.setFlag(Flag.SEEN, true);
                        setFlag(new Message[] { message }, Flag.SEEN, true);
                    }

                    for (MessagingListener l : getListeners(listener))
                    {
                        l.loadMessageForViewHeadersAvailable(account, folder, uid, message);
                    }

                    FetchProfile fp = new FetchProfile();
                    fp.add(FetchProfile.Item.ENVELOPE);
                    fp.add(FetchProfile.Item.BODY);
                    localFolder.fetch(new Message[]
                                      {
                                          message
                                      }, fp, null);
                    localFolder.close();

                    for (MessagingListener l : getListeners(listener))
                    {
                        l.loadMessageForViewBodyAvailable(account, folder, uid, message);
                    }

                    for (MessagingListener l : getListeners(listener))
                    {
                        l.loadMessageForViewFinished(account, folder, uid, message);
                    }

                }
                catch (Exception e)
                {
                    for (MessagingListener l : getListeners(listener))
                    {
                        l.loadMessageForViewFailed(account, folder, uid, e);
                    }
                    addErrorMessage(account, null, e);

                }
            }
        });
    }

    /**
     * Attempts to load the attachment specified by part from the given account and message.
     * @param account
     * @param message
     * @param part
     * @param listener
     */
    public void loadAttachment(
        final Account account,
        final Message message,
        final Part part,
        final Object tag,
        final MessagingListener listener)
    {
        /*
         * Check if the attachment has already been downloaded. If it has there's no reason to
         * download it, so we just tell the listener that it's ready to go.
         */
        try
        {
            if (part.getBody() != null)
            {
                for (MessagingListener l : getListeners())
                {
                    l.loadAttachmentStarted(account, message, part, tag, false);
                }
                if (listener != null)
                {
                    listener.loadAttachmentStarted(account, message, part, tag, false);
                }

                for (MessagingListener l : getListeners())
                {
                    l.loadAttachmentFinished(account, message, part, tag);
                }

                if (listener != null)
                {
                    listener.loadAttachmentFinished(account, message, part, tag);
                }
                return;
            }
        }
        catch (MessagingException me)
        {
            /*
             * If the header isn't there the attachment isn't downloaded yet, so just continue
             * on.
             */
        }

        for (MessagingListener l : getListeners())
        {
            l.loadAttachmentStarted(account, message, part, tag, true);
        }
        if (listener != null)
        {
            listener.loadAttachmentStarted(account, message, part, tag, false);
        }

        put(""loadAttachment"", listener, new Runnable()
        {
            public void run()
            {
                Folder remoteFolder = null;
                LocalFolder localFolder = null;
                try
                {
                    LocalStore localStore = account.getLocalStore();

                    /*
                     * We clear out any attachments already cached in the entire store and then
                     * we update the passed in message to reflect that there are no cached
                     * attachments. This is in support of limiting the account to having one
                     * attachment downloaded at a time.
                     */
                    localStore.pruneCachedAttachments();
                    ArrayList<Part> viewables = new ArrayList<Part>();
                    ArrayList<Part> attachments = new ArrayList<Part>();
                    MimeUtility.collectParts(message, viewables, attachments);
                    for (Part attachment : attachments)
                    {
                        attachment.setBody(null);
                    }
                    Store remoteStore = account.getRemoteStore();
                    localFolder = localStore.getFolder(message.getFolder().getName());
                    remoteFolder = remoteStore.getFolder(message.getFolder().getName());
                    remoteFolder.open(OpenMode.READ_WRITE);

                    //FIXME: This is an ugly hack that won't be needed once the Message objects have been united.
                    Message remoteMessage = remoteFolder.getMessage(message.getUid());
                    remoteMessage.setBody(message.getBody());
                    remoteFolder.fetchPart(remoteMessage, part, null);

                    localFolder.updateMessage((LocalMessage)message);
                    for (MessagingListener l : getListeners())
                    {
                        l.loadAttachmentFinished(account, message, part, tag);
                    }
                    if (listener != null)
                    {
                        listener.loadAttachmentFinished(account, message, part, tag);
                    }
                }
                catch (MessagingException me)
                {
                    if (K9.DEBUG)
                        Log.v(K9.LOG_TAG, ""Exception loading attachment"", me);

                    for (MessagingListener l : getListeners())
                    {
                        l.loadAttachmentFailed(account, message, part, tag, me.getMessage());
                    }
                    if (listener != null)
                    {
                        listener.loadAttachmentFailed(account, message, part, tag, me.getMessage());
                    }
                    addErrorMessage(account, null, me);

                }
                finally
                {
                    if (remoteFolder != null)
                    {
                        remoteFolder.close();
                    }
                    if (localFolder != null)
                    {
                        localFolder.close();
                    }
                }
            }
        });
    }

    /**
     * Stores the given message in the Outbox and starts a sendPendingMessages command to
     * attempt to send the message.
     * @param account
     * @param message
     * @param listener
     */
    public void sendMessage(final Account account,
                            final Message message,
                            MessagingListener listener)
    {
        try
        {
            LocalStore localStore = account.getLocalStore();
            LocalFolder localFolder = localStore.getFolder(account.getOutboxFolderName());
            localFolder.open(OpenMode.READ_WRITE);
            localFolder.appendMessages(new Message[]
                                       {
                                           message
                                       });
            Message localMessage = localFolder.getMessage(message.getUid());
            localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);
            localFolder.close();
            sendPendingMessages(account, listener);
        }
        catch (Exception e)
        {
            /*
            for (MessagingListener l : getListeners())
            {
                // TODO general failed
            }
            */
            addErrorMessage(account, null, e);

        }
    }

    /**
     * Attempt to send any messages that are sitting in the Outbox.
     * @param account
     * @param listener
     */
    public void sendPendingMessages(final Account account,
                                    MessagingListener listener)
    {
        putBackground(""sendPendingMessages"", listener, new Runnable()
        {
            public void run()
            {
                sendPendingMessagesSynchronous(account);
            }
        });
    }


    public boolean messagesPendingSend(final Account account)
    {
        Folder localFolder = null;
        try
        {
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(
                              account.getOutboxFolderName());
            if (!localFolder.exists())
            {
                return false;
            }

            localFolder.open(OpenMode.READ_WRITE);

            int localMessages = localFolder.getMessageCount();
            if (localMessages > 0)
            {
                return true;
            }
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Exception while checking for unsent messages"", e);
        }
        finally
        {
            if (localFolder != null)
            {
                localFolder.close();
            }
        }
        return false;
    }

    /**
     * Attempt to send any messages that are sitting in the Outbox.
     * @param account
     * @param listener
     */
    public void sendPendingMessagesSynchronous(final Account account)
    {
        Folder localFolder = null;
        try
        {
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(
                              account.getOutboxFolderName());
            if (!localFolder.exists())
            {
                return;
            }
            for (MessagingListener l : getListeners())
            {
                l.sendPendingMessagesStarted(account);
            }
            localFolder.open(OpenMode.READ_WRITE);

            Message[] localMessages = localFolder.getMessages(null);
            boolean anyFlagged = false;
            int progress = 0;
            int todo = localMessages.length;
            for (MessagingListener l : getListeners())
            {
                l.synchronizeMailboxProgress(account, account.getSentFolderName(), progress, todo);
            }
            /*
             * The profile we will use to pull all of the content
             * for a given local message into memory for sending.
             */
            FetchProfile fp = new FetchProfile();
            fp.add(FetchProfile.Item.ENVELOPE);
            fp.add(FetchProfile.Item.BODY);

            if (K9.DEBUG)
                Log.i(K9.LOG_TAG, ""Scanning folder '"" + account.getOutboxFolderName() + ""' ("" + ((LocalFolder)localFolder).getId() + "") for messages to send"");

            Transport transport = Transport.getInstance(account);
            for (Message message : localMessages)
            {
                if (message.isSet(Flag.DELETED))
                {
                    message.setFlag(Flag.X_DESTROYED, true);
                    continue;
                }
                if (message.isSet(Flag.FLAGGED))
                {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Skipping sending FLAGGED message "" + message.getUid());
                    continue;
                }
                try
                {
                    AtomicInteger count = new AtomicInteger(0);
                    AtomicInteger oldCount = sendCount.putIfAbsent(message.getUid(), count);
                    if (oldCount != null)
                    {
                        count = oldCount;
                    }

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Send count for message "" + message.getUid() + "" is "" + count.get());
                    if (count.incrementAndGet() > K9.MAX_SEND_ATTEMPTS)
                    {
                        Log.e(K9.LOG_TAG, ""Send count for message "" + message.getUid() + "" has exceeded maximum attempt threshold, flagging"");
                        message.setFlag(Flag.FLAGGED, true);
                        anyFlagged = true;
                        continue;
                    }

                    localFolder.fetch(new Message[] { message }, fp, null);
                    try
                    {
                        message.setFlag(Flag.X_SEND_IN_PROGRESS, true);
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Sending message with UID "" + message.getUid());
                        transport.sendMessage(message);
                        message.setFlag(Flag.X_SEND_IN_PROGRESS, false);
                        message.setFlag(Flag.SEEN, true);
                        progress++;
                        for (MessagingListener l : getListeners())
                        {
                            l.synchronizeMailboxProgress(account, account.getSentFolderName(), progress, todo);
                        }
                        if (K9.FOLDER_NONE.equals(account.getSentFolderName()))
                        {
                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Sent folder set to "" + K9.FOLDER_NONE + "", deleting sent message"");
                            message.setFlag(Flag.DELETED, true);
                        }
                        else
                        {
                            LocalFolder localSentFolder =
                                (LocalFolder) localStore.getFolder(
                                    account.getSentFolderName());
                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Moving sent message to folder '"" + account.getSentFolderName() + ""' ("" + localSentFolder.getId() + "") "");

                            localFolder.moveMessages(
                                new Message[] { message },
                                localSentFolder);

                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Moved sent message to folder '"" + account.getSentFolderName() + ""' ("" + localSentFolder.getId() + "") "");

                            PendingCommand command = new PendingCommand();
                            command.command = PENDING_COMMAND_APPEND;
                            command.arguments =
                                new String[]
                            {
                                localSentFolder.getName(),
                                message.getUid()
                            };
                            queuePendingCommand(account, command);
                            processPendingCommands(account);
                        }

                    }
                    catch (Exception e)
                    {
                        if (e instanceof MessagingException)
                        {
                            MessagingException me = (MessagingException)e;
                            if (!me.isPermanentFailure())
                            {
                                // Decrement the counter if the message could not possibly have been sent
                                int newVal = count.decrementAndGet();
                                if (K9.DEBUG)
                                    Log.i(K9.LOG_TAG, ""Decremented send count for message "" + message.getUid() + "" to "" + newVal
                                          + ""; no possible send"");
                            }
                        }
                        message.setFlag(Flag.X_SEND_FAILED, true);
                        Log.e(K9.LOG_TAG, ""Failed to send message"", e);
                        for (MessagingListener l : getListeners())
                        {
                            l.synchronizeMailboxFailed(
                                account,
                                localFolder.getName(),
                                getRootCauseMessage(e));
                        }
                        addErrorMessage(account, null, e);

                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Failed to fetch message for sending"", e);
                    for (MessagingListener l : getListeners())
                    {
                        l.synchronizeMailboxFailed(
                            account,
                            localFolder.getName(),
                            getRootCauseMessage(e));
                    }
                    addErrorMessage(account, null, e);

                    /*
                     * We ignore this exception because a future refresh will retry this
                     * message.
                     */
                }
            }
            if (localFolder.getMessageCount() == 0)
            {
                localFolder.delete(false);
            }
            for (MessagingListener l : getListeners())
            {
                l.sendPendingMessagesCompleted(account);
            }
            if (anyFlagged)
            {
                addErrorMessage(account, mApplication.getString(R.string.send_failure_subject),
                                mApplication.getString(R.string.send_failure_body_fmt, K9.ERROR_FOLDER_NAME));

                NotificationManager notifMgr =
                    (NotificationManager)mApplication.getSystemService(Context.NOTIFICATION_SERVICE);

                Notification notif = new Notification(R.drawable.stat_notify_email_generic,
                                                      mApplication.getString(R.string.send_failure_subject), System.currentTimeMillis());

                Intent i = MessageList.actionHandleFolderIntent(mApplication, account, account.getErrorFolderName());

                PendingIntent pi = PendingIntent.getActivity(mApplication, 0, i, 0);

                notif.setLatestEventInfo(mApplication, mApplication.getString(R.string.send_failure_subject),
                                         mApplication.getString(R.string.send_failure_body_abbrev, K9.ERROR_FOLDER_NAME), pi);

                notif.flags |= Notification.FLAG_SHOW_LIGHTS;
                notif.ledARGB = K9.NOTIFICATION_LED_SENDING_FAILURE_COLOR;
                notif.ledOnMS = K9.NOTIFICATION_LED_FAST_ON_TIME;
                notif.ledOffMS = K9.NOTIFICATION_LED_FAST_OFF_TIME;
                notifMgr.notify(-1000 - account.getAccountNumber(), notif);
            }
        }
        catch (Exception e)
        {
            for (MessagingListener l : getListeners())
            {
                l.sendPendingMessagesFailed(account);
            }
            addErrorMessage(account, null, e);

        }
        finally
        {
            if (localFolder != null)
            {
                try
                {
                    localFolder.close();
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Exception while closing folder"", e);
                }
            }
        }
    }

    public void getAccountStats(final Context context, final Account account,
                                final MessagingListener l)
    {
        Runnable unreadRunnable = new Runnable()
        {
            public void run()
            {
                try
                {
                    AccountStats stats = account.getStats(context);
                    l.accountStatusChanged(account, stats);
                }
                catch (MessagingException me)
                {
                    Log.e(K9.LOG_TAG, ""Count not get unread count for account "" + account.getDescription(),
                          me);
                }

            }
        };

        put(""getAccountStats:"" + account.getDescription(), l, unreadRunnable);
    }

    public void getFolderUnreadMessageCount(final Account account, final String folderName,
                                            final MessagingListener l)
    {
        Runnable unreadRunnable = new Runnable()
        {
            public void run()
            {

                int unreadMessageCount = 0;
                try
                {
                    Folder localFolder = account.getLocalStore().getFolder(folderName);
                    unreadMessageCount = localFolder.getUnreadMessageCount();
                }
                catch (MessagingException me)
                {
                    Log.e(K9.LOG_TAG, ""Count not get unread count for account "" + account.getDescription(), me);
                }
                l.folderStatusChanged(account, folderName, unreadMessageCount);
            }
        };


        put(""getFolderUnread:"" + account.getDescription() + "":"" + folderName, l, unreadRunnable);
    }



    public boolean isMoveCapable(Message message)
    {
        return !message.getUid().startsWith(K9.LOCAL_UID_PREFIX);
    }
    public boolean isCopyCapable(Message message)
    {
        return isMoveCapable(message);
    }

    public boolean isMoveCapable(final Account account)
    {
        try
        {
            Store localStore = account.getLocalStore();
            Store remoteStore = account.getRemoteStore();
            return localStore.isMoveCapable() && remoteStore.isMoveCapable();
        }
        catch (MessagingException me)
        {

            Log.e(K9.LOG_TAG, ""Exception while ascertaining move capability"", me);
            return false;
        }
    }
    public boolean isCopyCapable(final Account account)
    {
        try
        {
            Store localStore = account.getLocalStore();
            Store remoteStore = account.getRemoteStore();
            return localStore.isCopyCapable() && remoteStore.isCopyCapable();
        }
        catch (MessagingException me)
        {
            Log.e(K9.LOG_TAG, ""Exception while ascertaining copy capability"", me);
            return false;
        }
    }
    public void moveMessages(final Account account, final String srcFolder, final Message[] messages, final String destFolder,
                             final MessagingListener listener)
    {
        for (Message message : messages)
        {
            suppressMessage(account, srcFolder, message);
        }
        putBackground(""moveMessages"", null, new Runnable()
        {
            public void run()
            {
                moveOrCopyMessageSynchronous(account, srcFolder, messages, destFolder, false, listener);
            }
        });
    }

    public void moveMessage(final Account account, final String srcFolder, final Message message, final String destFolder,
                            final MessagingListener listener)
    {
        moveMessages(account, srcFolder, new Message[] { message }, destFolder, listener);
    }

    public void copyMessages(final Account account, final String srcFolder, final Message[] messages, final String destFolder,
                             final MessagingListener listener)
    {
        putBackground(""copyMessages"", null, new Runnable()
        {
            public void run()
            {
                moveOrCopyMessageSynchronous(account, srcFolder, messages, destFolder, true, listener);
            }
        });
    }
    public void copyMessage(final Account account, final String srcFolder, final Message message, final String destFolder,
                            final MessagingListener listener)
    {
        copyMessages(account, srcFolder, new Message[] { message }, destFolder, listener);
    }

    private void moveOrCopyMessageSynchronous(final Account account, final String srcFolder, final Message[] inMessages,
            final String destFolder, final boolean isCopy, MessagingListener listener)
    {
        try
        {
            Store localStore = account.getLocalStore();
            Store remoteStore = account.getRemoteStore();
            if (!isCopy && (!remoteStore.isMoveCapable() || !localStore.isMoveCapable()))
            {
                return;
            }
            if (isCopy && (!remoteStore.isCopyCapable() || !localStore.isCopyCapable()))
            {
                return;
            }

            Folder localSrcFolder = localStore.getFolder(srcFolder);
            Folder localDestFolder = localStore.getFolder(destFolder);

            List<String> uids = new LinkedList<String>();
            for (Message message : inMessages)
            {
                String uid = message.getUid();
                if (!uid.startsWith(K9.LOCAL_UID_PREFIX))
                {
                    uids.add(uid);
                }
            }

            Message[] messages = localSrcFolder.getMessages(uids.toArray(EMPTY_STRING_ARRAY), null);
            if (messages.length > 0)
            {
                Map<String, Message> origUidMap = new HashMap<String, Message>();

                for (Message message : messages)
                {
                    origUidMap.put(message.getUid(), message);
                }

                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""moveOrCopyMessageSynchronous: source folder = "" + srcFolder
                          + "", "" + messages.length + "" messages, "" + "", destination folder = "" + destFolder + "", isCopy = "" + isCopy);

                if (isCopy)
                {
                    FetchProfile fp = new FetchProfile();
                    fp.add(FetchProfile.Item.ENVELOPE);
                    fp.add(FetchProfile.Item.BODY);
                    localSrcFolder.fetch(messages, fp, null);
                    localSrcFolder.copyMessages(messages, localDestFolder);
                }
                else
                {
                    localSrcFolder.moveMessages(messages, localDestFolder);
                    for (String origUid : origUidMap.keySet())
                    {
                        for (MessagingListener l : getListeners())
                        {
                            l.messageUidChanged(account, srcFolder, origUid, origUidMap.get(origUid).getUid());
                        }
                        unsuppressMessage(account, srcFolder, origUid);
                    }
                }

                queueMoveOrCopy(account, srcFolder, destFolder, isCopy, origUidMap.keySet().toArray(EMPTY_STRING_ARRAY));
            }

            processPendingCommands(account);
        }
        catch (MessagingException me)
        {
            addErrorMessage(account, null, me);

            throw new RuntimeException(""Error moving message"", me);
        }
    }

    public void expunge(final Account account, final String folder, final MessagingListener listener)
    {
        putBackground(""expunge"", null, new Runnable()
        {
            public void run()
            {
                queueExpunge(account, folder);
            }
        });
    }

    public void deleteDraft(final Account account, String uid)
    {
        LocalFolder localFolder = null;
        try
        {
            LocalStore localStore = account.getLocalStore();
            localFolder = localStore.getFolder(account.getDraftsFolderName());
            localFolder.open(OpenMode.READ_WRITE);
            Message message = localFolder.getMessage(uid);
            if (message != null)
            {
                deleteMessages(new Message[] { message }, null);
            }
        }
        catch (MessagingException me)
        {
            addErrorMessage(account, null, me);
        }
        finally
        {
            if (localFolder != null)
            {
                localFolder.close();
            }
        }
    }

    public void deleteMessages(final Message[] messages, final MessagingListener listener)
    {
        actOnMessages(messages, new MessageActor()
        {

            @Override
            public void act(final Account account, final Folder folder,
                            final List<Message> messages)
            {
                for (Message message : messages)
                {
                    suppressMessage(account, folder.getName(), message);
                }

                putBackground(""deleteMessages"", null, new Runnable()
                {
                    public void run()
                    {
                        deleteMessagesSynchronous(account, folder.getName(), messages.toArray(EMPTY_MESSAGE_ARRAY), listener);
                    }
                });
            }

        });

    }

    private void deleteMessagesSynchronous(final Account account, final String folder, final Message[] messages,
                                           MessagingListener listener)
    {
        Folder localFolder = null;
        Folder localTrashFolder = null;
        String[] uids = getUidsFromMessages(messages);
        try
        {
            //We need to make these callbacks before moving the messages to the trash
            //as messages get a new UID after being moved
            for (Message message : messages)
            {
                if (listener != null)
                {
                    listener.messageDeleted(account, folder, message);
                }
                for (MessagingListener l : getListeners())
                {
                    l.messageDeleted(account, folder, message);
                }
            }
            Store localStore = account.getLocalStore();
            localFolder = localStore.getFolder(folder);
            if (folder.equals(account.getTrashFolderName()) || K9.FOLDER_NONE.equals(account.getTrashFolderName()))
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Deleting messages in trash folder or trash set to -None-, not copying"");

                localFolder.setFlags(messages, new Flag[] { Flag.DELETED }, true);
            }
            else
            {
                localTrashFolder = localStore.getFolder(account.getTrashFolderName());
                if (!localTrashFolder.exists())
                {
                    localTrashFolder.create(Folder.FolderType.HOLDS_MESSAGES);
                }
                if (localTrashFolder.exists())
                {
                    if (K9.DEBUG)
                        Log.d(K9.LOG_TAG, ""Deleting messages in normal folder, moving"");

                    localFolder.moveMessages(messages, localTrashFolder);

                }
            }

            for (MessagingListener l : getListeners())
            {
                l.folderStatusChanged(account, folder, localFolder.getUnreadMessageCount());
                if (localTrashFolder != null)
                {
                    l.folderStatusChanged(account, account.getTrashFolderName(), localTrashFolder.getUnreadMessageCount());
                }
            }

            if (K9.DEBUG)
                Log.d(K9.LOG_TAG, ""Delete policy for account "" + account.getDescription() + "" is "" + account.getDeletePolicy());

            if (folder.equals(account.getOutboxFolderName()))
            {
                for (Message message : messages)
                {
                    // If the message was in the Outbox, then it has been copied to local Trash, and has
                    // to be copied to remote trash
                    PendingCommand command = new PendingCommand();
                    command.command = PENDING_COMMAND_APPEND;
                    command.arguments =
                        new String[]
                    {
                        account.getTrashFolderName(),
                        message.getUid()
                    };
                    queuePendingCommand(account, command);
                }
                processPendingCommands(account);
            }
            else if (folder.equals(account.getTrashFolderName()) && account.getDeletePolicy() == Account.DELETE_POLICY_ON_DELETE)
            {
                queueSetFlag(account, folder, Boolean.toString(true), Flag.DELETED.toString(), uids);
                processPendingCommands(account);
            }
            else if (account.getDeletePolicy() == Account.DELETE_POLICY_ON_DELETE)
            {
                queueMoveOrCopy(account, folder, account.getTrashFolderName(), false, uids);
                processPendingCommands(account);
            }
            else if (account.getDeletePolicy() == Account.DELETE_POLICY_MARK_AS_READ)
            {
                queueSetFlag(account, folder, Boolean.toString(true), Flag.SEEN.toString(), uids);
                processPendingCommands(account);
            }
            else
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Delete policy "" + account.getDeletePolicy() + "" prevents delete from server"");
            }
            for (String uid : uids)
            {
                unsuppressMessage(account, folder, uid);
            }
        }
        catch (MessagingException me)
        {
            addErrorMessage(account, null, me);

            throw new RuntimeException(""Error deleting message from local store."", me);
        }
        finally
        {

            if (localFolder != null)
            {
                localFolder.close();
            }
            if (localTrashFolder != null)
            {
                localTrashFolder.close();
            }
        }
    }

    private String[] getUidsFromMessages(Message[] messages)
    {
        String[] uids = new String[messages.length];
        for (int i = 0; i < messages.length; i++)
        {
            uids[i] = messages[i].getUid();
        }
        return uids;
    }

    private void processPendingEmptyTrash(PendingCommand command, Account account) throws MessagingException
    {
        Store remoteStore = account.getRemoteStore();

        Folder remoteFolder = remoteStore.getFolder(account.getTrashFolderName());
        try
        {
            if (remoteFolder.exists())
            {
                remoteFolder.open(OpenMode.READ_WRITE);
                remoteFolder.setFlags(new Flag [] { Flag.DELETED }, true);
                if (Account.EXPUNGE_IMMEDIATELY.equals(account.getExpungePolicy()))
                {
                    remoteFolder.expunge();
                }
            }
        }
        finally
        {
            if (remoteFolder != null)
            {
                remoteFolder.close();
            }
        }
    }

    public void emptyTrash(final Account account, MessagingListener listener)
    {
        putBackground(""emptyTrash"", listener, new Runnable()
        {
            public void run()
            {
                Folder localFolder = null;
                try
                {
                    Store localStore = account.getLocalStore();
                    localFolder = localStore.getFolder(account.getTrashFolderName());
                    localFolder.open(OpenMode.READ_WRITE);
                    localFolder.setFlags(new Flag[] { Flag.DELETED }, true);

                    for (MessagingListener l : getListeners())
                    {
                        l.emptyTrashCompleted(account);
                    }
                    List<String> args = new ArrayList<String>();
                    PendingCommand command = new PendingCommand();
                    command.command = PENDING_COMMAND_EMPTY_TRASH;
                    command.arguments = args.toArray(EMPTY_STRING_ARRAY);
                    queuePendingCommand(account, command);
                    processPendingCommands(account);
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""emptyTrash failed"", e);

                    addErrorMessage(account, null, e);
                }
                finally
                {
                    if (localFolder != null)
                    {
                        localFolder.close();
                    }
                }
            }
        });
    }

    public void sendAlternate(final Context context, Account account, Message message)
    {
        if (K9.DEBUG)
            Log.d(K9.LOG_TAG, ""About to load message "" + account.getDescription() + "":"" + message.getFolder().getName()
                  + "":"" + message.getUid() + "" for sendAlternate"");

        loadMessageForView(account, message.getFolder().getName(),
                           message.getUid(), new MessagingListener()
        {
            @Override
            public void loadMessageForViewBodyAvailable(Account account, String folder, String uid,
                    Message message)
            {
                if (K9.DEBUG)
                    Log.d(K9.LOG_TAG, ""Got message "" + account.getDescription() + "":"" + folder
                          + "":"" + message.getUid() + "" for sendAlternate"");

                try
                {
                    Intent msg=new Intent(Intent.ACTION_SEND);
                    String quotedText = null;
                    Part part = MimeUtility.findFirstPartByMimeType(message,
                                ""text/plain"");
                    if (part == null)
                    {
                        part = MimeUtility.findFirstPartByMimeType(message, ""text/html"");
                    }
                    if (part != null)
                    {
                        quotedText = MimeUtility.getTextFromPart(part);
                    }
                    if (quotedText != null)
                    {
                        msg.putExtra(Intent.EXTRA_TEXT, quotedText);
                    }
                    msg.putExtra(Intent.EXTRA_SUBJECT, ""Fwd: "" + message.getSubject());
                    msg.setType(""text/plain"");
                    context.startActivity(Intent.createChooser(msg, context.getString(R.string.send_alternate_chooser_title)));
                }
                catch (MessagingException me)
                {
                    Log.e(K9.LOG_TAG, ""Unable to send email through alternate program"", me);
                }
            }
        });

    }

    /**
     * Checks mail for one or multiple accounts. If account is null all accounts
     * are checked.
     *
     * @param context
     * @param account
     * @param listener
     */
    public void checkMail(final Context context, final Account account,
                          final boolean ignoreLastCheckedTime,
                          final boolean useManualWakeLock,
                          final MessagingListener listener)
    {

        TracingWakeLock twakeLock = null;
        if (useManualWakeLock)
        {
            TracingPowerManager pm = TracingPowerManager.getPowerManager(context);

            twakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""K9 MessagingController.checkMail"");
            twakeLock.setReferenceCounted(false);
            twakeLock.acquire(K9.MANUAL_WAKE_LOCK_TIMEOUT);
        }
        final TracingWakeLock wakeLock = twakeLock;

        for (MessagingListener l : getListeners())
        {
            l.checkMailStarted(context, account);
        }
        putBackground(""checkMail"", listener, new Runnable()
        {
            public void run()
            {

                final NotificationManager notifMgr = (NotificationManager)context
                                                     .getSystemService(Context.NOTIFICATION_SERVICE);
                try
                {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Starting mail check"");
                    Preferences prefs = Preferences.getPreferences(context);

                    Account[] accounts;
                    if (account != null)
                    {
                        accounts = new Account[]
                        {
                            account
                        };
                    }
                    else
                    {
                        accounts = prefs.getAccounts();
                    }

                    for (final Account account : accounts)
                    {
                        final long accountInterval = account.getAutomaticCheckIntervalMinutes() * 60 * 1000;
                        if (!ignoreLastCheckedTime && accountInterval <= 0)
                        {
                            if (K9.DEBUG)
                                Log.i(K9.LOG_TAG, ""Skipping synchronizing account "" + account.getDescription());
                            continue;
                        }

                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Synchronizing account "" + account.getDescription());

                        account.setRingNotified(false);

                        putBackground(""sendPending "" + account.getDescription(), null, new Runnable()
                        {
                            public void run()
                            {
                                if (messagesPendingSend(account))
                                {
                                    if (account.isShowOngoing())
                                    {
                                        Notification notif = new Notification(R.drawable.ic_menu_refresh,
                                                                              context.getString(R.string.notification_bg_send_ticker, account.getDescription()), System.currentTimeMillis());
                                        Intent intent = MessageList.actionHandleFolderIntent(context, account, K9.INBOX);
                                        PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
                                        notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_send_title),
                                                                 account.getDescription() , pi);
                                        notif.flags = Notification.FLAG_ONGOING_EVENT;

                                        if (K9.NOTIFICATION_LED_WHILE_SYNCING)
                                        {
                                            notif.flags |= Notification.FLAG_SHOW_LIGHTS;
                                            notif.ledARGB = account.getNotificationSetting().getLedColor();
                                            notif.ledOnMS = K9.NOTIFICATION_LED_FAST_ON_TIME;
                                            notif.ledOffMS = K9.NOTIFICATION_LED_FAST_OFF_TIME;
                                        }

                                        notifMgr.notify(K9.FETCHING_EMAIL_NOTIFICATION - account.getAccountNumber(), notif);
                                    }
                                    try
                                    {
                                        sendPendingMessagesSynchronous(account);
                                    }
                                    finally
                                    {
                                        if (account.isShowOngoing())
                                        {
                                            notifMgr.cancel(K9.FETCHING_EMAIL_NOTIFICATION - account.getAccountNumber());
                                        }
                                    }
                                }
                            }
                        }
                                     );
                        try
                        {
                            Account.FolderMode aDisplayMode = account.getFolderDisplayMode();
                            Account.FolderMode aSyncMode = account.getFolderSyncMode();

                            Store localStore = account.getLocalStore();
                            for (final Folder folder : localStore.getPersonalNamespaces(false))
                            {

                                folder.open(Folder.OpenMode.READ_WRITE);
                                folder.refresh(prefs);

                                Folder.FolderClass fDisplayClass = folder.getDisplayClass();
                                Folder.FolderClass fSyncClass = folder.getSyncClass();

                                if (modeMismatch(aDisplayMode, fDisplayClass))
                                {
                                    // Never sync a folder that isn't displayed
                                    if (K9.DEBUG && false)
                                        Log.v(K9.LOG_TAG, ""Not syncing folder "" + folder.getName() +
                                              "" which is in display mode "" + fDisplayClass + "" while account is in display mode "" + aDisplayMode);

                                    continue;
                                }

                                if (modeMismatch(aSyncMode, fSyncClass))
                                {
                                    // Do not sync folders in the wrong class
                                    if (K9.DEBUG && false)
                                        Log.v(K9.LOG_TAG, ""Not syncing folder "" + folder.getName() +
                                              "" which is in sync mode "" + fSyncClass + "" while account is in sync mode "" + aSyncMode);

                                    continue;
                                }

                                if (K9.DEBUG)
                                    Log.v(K9.LOG_TAG, ""Folder "" + folder.getName() + "" was last synced @ "" +
                                          new Date(folder.getLastChecked()));

                                if (!ignoreLastCheckedTime && folder.getLastChecked() >
                                        (System.currentTimeMillis() - accountInterval))
                                {
                                    if (K9.DEBUG)
                                        Log.v(K9.LOG_TAG, ""Not syncing folder "" + folder.getName()
                                              + "", previously synced @ "" + new Date(folder.getLastChecked())
                                              + "" which would be too recent for the account period"");

                                    continue;
                                }
                                putBackground(""sync"" + folder.getName(), null, new Runnable()
                                {
                                    public void run()
                                    {
                                        LocalFolder tLocalFolder = null;
                                        try
                                        {
                                            // In case multiple Commands get enqueued, don't run more than
                                            // once
                                            final LocalStore localStore = account.getLocalStore();
                                            tLocalFolder = localStore.getFolder(folder.getName());
                                            tLocalFolder.open(Folder.OpenMode.READ_WRITE);

                                            if (!ignoreLastCheckedTime && tLocalFolder.getLastChecked() >
                                                    (System.currentTimeMillis() - accountInterval))
                                            {
                                                if (K9.DEBUG)
                                                    Log.v(K9.LOG_TAG, ""Not running Command for folder "" + folder.getName()
                                                          + "", previously synced @ "" + new Date(folder.getLastChecked())
                                                          + "" which would be too recent for the account period"");
                                                return;
                                            }
                                            if (account.isShowOngoing())
                                            {
                                                Notification notif = new Notification(R.drawable.ic_menu_refresh,
                                                                                      context.getString(R.string.notification_bg_sync_ticker, account.getDescription(), folder.getName()),
                                                                                      System.currentTimeMillis());
                                                Intent intent = MessageList.actionHandleFolderIntent(context, account, K9.INBOX);
                                                PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
                                                notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_sync_title), account.getDescription()
                                                                         + context.getString(R.string.notification_bg_title_separator) + folder.getName(), pi);
                                                notif.flags = Notification.FLAG_ONGOING_EVENT;
                                                if (K9.NOTIFICATION_LED_WHILE_SYNCING)
                                                {
                                                    notif.flags |= Notification.FLAG_SHOW_LIGHTS;
                                                    notif.ledARGB = account.getNotificationSetting().getLedColor();
                                                    notif.ledOnMS = K9.NOTIFICATION_LED_FAST_ON_TIME;
                                                    notif.ledOffMS = K9.NOTIFICATION_LED_FAST_OFF_TIME;
                                                }

                                                notifMgr.notify(K9.FETCHING_EMAIL_NOTIFICATION - account.getAccountNumber(), notif);
                                            }
                                            try
                                            {
                                                synchronizeMailboxSynchronous(account, folder.getName(), listener, null);
                                            }
                                            finally
                                            {
                                                if (account.isShowOngoing())
                                                {
                                                    notifMgr.cancel(K9.FETCHING_EMAIL_NOTIFICATION - account.getAccountNumber());
                                                }
                                            }
                                        }
                                        catch (Exception e)
                                        {

                                            Log.e(K9.LOG_TAG, ""Exception while processing folder "" +
                                                  account.getDescription() + "":"" + folder.getName(), e);
                                            addErrorMessage(account, null, e);
                                        }
                                        finally
                                        {
                                            if (tLocalFolder != null)
                                            {
                                                tLocalFolder.close();
                                            }
                                        }
                                    }
                                }
                                             );
                            }
                        }
                        catch (MessagingException e)
                        {
                            Log.e(K9.LOG_TAG, ""Unable to synchronize account "" + account.getName(), e);
                            addErrorMessage(account, null, e);
                        }
                        finally
                        {
                            putBackground(""clear notification flag for "" + account.getDescription(), null, new Runnable()
                            {
                                public void run()
                                {
                                    if (K9.DEBUG)
                                        Log.v(K9.LOG_TAG, ""Clearing notification flag for "" + account.getDescription());
                                    account.setRingNotified(false);
                                    try
                                    {
                                        if (account.getStats(context).unreadMessageCount == 0)
                                        {
                                            notifyAccountCancel(context, account);
                                        }
                                    }
                                    catch (MessagingException e)
                                    {
                                        Log.e(K9.LOG_TAG, ""Unable to getUnreadMessageCount for account: "" + account, e);
                                    }
                                }
                            }
                                         );
                        }


                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Unable to synchronize mail"", e);
                    addErrorMessage(account, null, e);
                }
                putBackground(""finalize sync"", null, new Runnable()
                {
                    public void run()
                    {

                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Finished mail sync"");

                        if (wakeLock != null)
                        {
                            wakeLock.release();
                        }
                        for (MessagingListener l : getListeners())
                        {
                            l.checkMailFinished(context, account);
                        }

                    }
                }
                             );
            }
        });
    }

    public void compact(final Account account, final MessagingListener ml)
    {
        putBackground(""compact:"" + account.getDescription(), ml, new Runnable()
        {
            public void run()
            {
                try
                {
                    LocalStore localStore = account.getLocalStore();
                    long oldSize = localStore.getSize();
                    localStore.compact();
                    long newSize = localStore.getSize();
                    if (ml != null)
                    {
                        ml.accountSizeChanged(account, oldSize, newSize);
                    }
                    for (MessagingListener l : getListeners())
                    {
                        l.accountSizeChanged(account, oldSize, newSize);
                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Failed to compact account "" + account.getDescription(), e);
                }
            }
        });
    }

    public void clear(final Account account, final MessagingListener ml)
    {
        putBackground(""clear:"" + account.getDescription(), ml, new Runnable()
        {
            public void run()
            {
                try
                {
                    LocalStore localStore = account.getLocalStore();
                    long oldSize = localStore.getSize();
                    localStore.clear();
                    localStore.resetVisibleLimits(account.getDisplayCount());
                    long newSize = localStore.getSize();
                    AccountStats stats = new AccountStats();
                    stats.size = newSize;
                    stats.unreadMessageCount = 0;
                    stats.flaggedMessageCount = 0;
                    if (ml != null)
                    {
                        ml.accountSizeChanged(account, oldSize, newSize);
                        ml.accountStatusChanged(account, stats);
                    }
                    for (MessagingListener l : getListeners())
                    {
                        l.accountSizeChanged(account, oldSize, newSize);
                        l.accountStatusChanged(account, stats);
                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Failed to clear account "" + account.getDescription(), e);
                }
            }
        });
    }

    public void recreate(final Account account, final MessagingListener ml)
    {
        putBackground(""recreate:"" + account.getDescription(), ml, new Runnable()
        {
            public void run()
            {
                try
                {
                    LocalStore localStore = account.getLocalStore();
                    long oldSize = localStore.getSize();
                    localStore.recreate();
                    localStore.resetVisibleLimits(account.getDisplayCount());
                    long newSize = localStore.getSize();
                    AccountStats stats = new AccountStats();
                    stats.size = newSize;
                    stats.unreadMessageCount = 0;
                    stats.flaggedMessageCount = 0;
                    if (ml != null)
                    {
                        ml.accountSizeChanged(account, oldSize, newSize);
                        ml.accountStatusChanged(account, stats);
                    }
                    for (MessagingListener l : getListeners())
                    {
                        l.accountSizeChanged(account, oldSize, newSize);
                        l.accountStatusChanged(account, stats);
                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Failed to recreate account "" + account.getDescription(), e);
                }
            }
        });
    }


    private boolean shouldNotifyForMessage(Account account, Message message)
    {
        // Do not notify if the user does not have notifications
        // enabled or if the message has been read
        if (!account.isNotifyNewMail() || message.isSet(Flag.SEEN) || (account.getName() == null))
        {
            return false;
        }


        Folder folder = message.getFolder();
        if (folder != null)
        {
            // No notification for new messages in Trash, Drafts, or Sent folder.
            // But do notify if it's the INBOX (see issue 1817).
            String folderName = folder.getName();
            if (!K9.INBOX.equals(folderName) &&
                    (account.getTrashFolderName().equals(folderName)
                     || account.getDraftsFolderName().equals(folderName)
                     || account.getSentFolderName().equals(folderName)))
            {
                return false;
            }
        }

        return true;

    }



    /** Creates a notification of new email messages
      * ringtone, lights, and vibration to be played
    */
    private boolean notifyAccount(Context context, Account account, Message message, int previousUnreadMessageCount, AtomicInteger newMessageCount)
    {
        // If we have a message, set the notification to ""<From>: <Subject>""
        StringBuilder messageNotice = new StringBuilder();
        final KeyguardManager keyguardService = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
        try
        {
            if (message != null && message.getFrom() != null)
            {
                Address[] fromAddrs = message.getFrom();
                String from = fromAddrs.length > 0 ? fromAddrs[0].toFriendly().toString() : null;
                String subject = message.getSubject();
                if (subject == null)
                {
                    subject = context.getString(R.string.general_no_subject);
                }
                
                if (from != null)
                {
                    // Show From: address by default
                    if (!account.isAnIdentity(fromAddrs))
                    {
                        messageNotice.append(from + "": "" + subject);
                    }
                    // show To: if the message was sent from me
                    else
                    {
                        if (!account.isNotifySelfNewMail())
                        {
                            return false;
                        }
                        
                        Address[] rcpts = message.getRecipients(Message.RecipientType.TO);
                        String to = rcpts.length > 0 ? rcpts[0].toFriendly().toString() : null;
                        if (to != null)
                        {
                            messageNotice.append(String.format(context.getString(R.string.message_list_to_fmt), to) +"": ""+subject);
                        }
                        else
                        {
                            messageNotice.append(context.getString(R.string.general_no_sender) + "": ""+subject);
                            
                        }
                        
                    }
                }
            }
        }
        catch (MessagingException e)
        {
            Log.e(K9.LOG_TAG, ""Unable to get message information for notification."", e);
        }

        // If privacy mode active and keyguard active
        // OR
        // If we could not set a per-message notification, revert to a default message
        if ((K9.keyguardPrivacy() && keyguardService.inKeyguardRestrictedInputMode()) || messageNotice.length() == 0)
        {
            messageNotice = new StringBuilder(context.getString(R.string.notification_new_title));
        }

        NotificationManager notifMgr =
            (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
        Notification notif = new Notification(R.drawable.stat_notify_email_generic, messageNotice, System.currentTimeMillis());
        notif.number = previousUnreadMessageCount + newMessageCount.get();

        Intent i = FolderList.actionHandleNotification(context, account, message.getFolder().getName());
        PendingIntent pi = PendingIntent.getActivity(context, 0, i, 0);

        String accountNotice = context.getString(R.string.notification_new_one_account_fmt, notif.number, account.getDescription());
        notif.setLatestEventInfo(context, accountNotice, messageNotice, pi);

        // Only ring or vibrate if we have not done so already on this
        // account and fetch
        boolean ringAndVibrate = false;
        if (!account.isRingNotified())
        {
            account.setRingNotified(true);
            ringAndVibrate = true;
        }

        configureNotification(account.getNotificationSetting(), notif, ringAndVibrate);

        notifMgr.notify(account.getAccountNumber(), notif);
        return true;
    }

    /**
     * @param setting
     *            Configuration template. Never <code>null</code>.
     * @param notification
     *            Object to configure. Never <code>null</code>.
     * @param ringAndVibrate
     *            <code>true</code> if ringtone/vibration are allowed,
     *            <code>false</code> otherwise.
     */
    private void configureNotification(final NotificationSetting setting, final Notification notification, final boolean ringAndVibrate)
    {
        if (ringAndVibrate)
        {
            if (setting.shouldRing())
            {
                String ringtone = setting.getRingtone();
                notification.sound = TextUtils.isEmpty(ringtone) ? null : Uri.parse(ringtone);
                notification.audioStreamType = AudioManager.STREAM_NOTIFICATION;
            }
            if (setting.isVibrate())
            {
                long[] pattern = getVibratePattern(setting.getVibratePattern(), setting.getVibrateTimes());
                notification.vibrate = pattern;
            }
        }

        if (setting.isLed())
        {
            notification.flags |= Notification.FLAG_SHOW_LIGHTS;
            notification.ledARGB = setting.getLedColor();
            notification.ledOnMS = K9.NOTIFICATION_LED_ON_TIME;
            notification.ledOffMS = K9.NOTIFICATION_LED_OFF_TIME;
        }
    }

    /*
     * Fetch a vibration pattern.
     *
     * @param vibratePattern Vibration pattern index to use.
     * @param vibrateTimes Number of times to do the vibration pattern.
     * @return Pattern multiplied by the number of times requested.
     */
    public static long[] getVibratePattern(int vibratePattern, int vibrateTimes)
    {
        // These are ""off, on"" patterns, specified in milliseconds
        long[] pattern0 = new long[] {300,200}; // like the default pattern
        long[] pattern1 = new long[] {100,200};
        long[] pattern2 = new long[] {100,500};
        long[] pattern3 = new long[] {200,200};
        long[] pattern4 = new long[] {200,500};
        long[] pattern5 = new long[] {500,500};

        long[] selectedPattern = pattern0; //default pattern

        switch (vibratePattern)
        {
            case 1:
                selectedPattern = pattern1;
                break;
            case 2:
                selectedPattern = pattern2;
                break;
            case 3:
                selectedPattern = pattern3;
                break;
            case 4:
                selectedPattern = pattern4;
                break;
            case 5:
                selectedPattern = pattern5;
                break;
        }

        long[] repeatedPattern = new long[selectedPattern.length * vibrateTimes];
        for (int n = 0; n < vibrateTimes; n++)
        {
            System.arraycopy(selectedPattern, 0, repeatedPattern, n * selectedPattern.length, selectedPattern.length);
        }
        // Do not wait before starting the vibration pattern.
        repeatedPattern[0] = 0;
        return repeatedPattern;
    }

    /** Cancel a notification of new email messages */
    public void notifyAccountCancel(Context context, Account account)
    {
        NotificationManager notifMgr =
            (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
        notifMgr.cancel(account.getAccountNumber());
        notifMgr.cancel(-1000 - account.getAccountNumber());
    }


    public Message saveDraft(final Account account, final Message message)
    {
        Message localMessage = null;
        try
        {
            LocalStore localStore = account.getLocalStore();
            LocalFolder localFolder = localStore.getFolder(account.getDraftsFolderName());
            localFolder.open(OpenMode.READ_WRITE);
            localFolder.appendMessages(new Message[]
                                       {
                                           message
                                       });
            localMessage = localFolder.getMessage(message.getUid());
            localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);

            PendingCommand command = new PendingCommand();
            command.command = PENDING_COMMAND_APPEND;
            command.arguments = new String[]
            {
                localFolder.getName(),
                localMessage.getUid()
            };
            queuePendingCommand(account, command);
            processPendingCommands(account);

        }
        catch (MessagingException e)
        {
            Log.e(K9.LOG_TAG, ""Unable to save message as draft."", e);
            addErrorMessage(account, null, e);
        }
        return localMessage;
    }

    public boolean modeMismatch(Account.FolderMode aMode, Folder.FolderClass fMode)
    {
        if (aMode == Account.FolderMode.NONE
                || (aMode == Account.FolderMode.FIRST_CLASS &&
                    fMode != Folder.FolderClass.FIRST_CLASS)
                || (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
                    fMode != Folder.FolderClass.FIRST_CLASS &&
                    fMode != Folder.FolderClass.SECOND_CLASS)
                || (aMode == Account.FolderMode.NOT_SECOND_CLASS &&
                    fMode == Folder.FolderClass.SECOND_CLASS))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    static AtomicInteger sequencing = new AtomicInteger(0);
    class Command implements Comparable<Command>
    {
        public Runnable runnable;

        public MessagingListener listener;

        public String description;

        boolean isForeground;

        int sequence = sequencing.getAndIncrement();

        @Override
        public int compareTo(Command other)
        {
            if (other.isForeground && !isForeground)
            {
                return 1;
            }
            else if (!other.isForeground && isForeground)
            {
                return -1;
            }
            else
            {
                return (sequence - other.sequence);
            }
        }
    }

    public MessagingListener getCheckMailListener()
    {
        return checkMailListener;
    }

    public void setCheckMailListener(MessagingListener checkMailListener)
    {
        if (this.checkMailListener != null)
        {
            removeListener(this.checkMailListener);
        }
        this.checkMailListener = checkMailListener;
        if (this.checkMailListener != null)
        {
            addListener(this.checkMailListener);
        }
    }

    public SORT_TYPE getSortType()
    {
        return sortType;
    }

    public void setSortType(SORT_TYPE sortType)
    {
        this.sortType = sortType;
    }

    public boolean isSortAscending(SORT_TYPE sortType)
    {
        Boolean sortAsc = sortAscending.get(sortType);
        if (sortAsc == null)
        {
            return sortType.isDefaultAscending();
        }
        else return sortAsc;
    }

    public void setSortAscending(SORT_TYPE sortType, boolean nsortAscending)
    {
        sortAscending.put(sortType, nsortAscending);
    }

    public Collection<Pusher> getPushers()
    {
        return pushers.values();
    }

    public boolean setupPushing(final Account account)
    {
        try
        {
            Pusher previousPusher = pushers.remove(account);
            if (previousPusher != null)
            {
                previousPusher.stop();
            }
            Preferences prefs = Preferences.getPreferences(mApplication);

            Account.FolderMode aDisplayMode = account.getFolderDisplayMode();
            Account.FolderMode aPushMode = account.getFolderPushMode();

            List<String> names = new ArrayList<String>();

            Store localStore = account.getLocalStore();
            for (final Folder folder : localStore.getPersonalNamespaces(false))
            {
                if (folder.getName().equals(account.getErrorFolderName())
                        || folder.getName().equals(account.getOutboxFolderName()))
                {
                    if (K9.DEBUG && false)
                        Log.v(K9.LOG_TAG, ""Not pushing folder "" + folder.getName() +
                              "" which should never be pushed"");

                    continue;
                }
                folder.open(Folder.OpenMode.READ_WRITE);
                folder.refresh(prefs);

                Folder.FolderClass fDisplayClass = folder.getDisplayClass();
                Folder.FolderClass fPushClass = folder.getPushClass();

                if (modeMismatch(aDisplayMode, fDisplayClass))
                {
                    // Never push a folder that isn't displayed
                    if (K9.DEBUG && false)
                        Log.v(K9.LOG_TAG, ""Not pushing folder "" + folder.getName() +
                              "" which is in display class "" + fDisplayClass + "" while account is in display mode "" + aDisplayMode);

                    continue;
                }

                if (modeMismatch(aPushMode, fPushClass))
                {
                    // Do not push folders in the wrong class
                    if (K9.DEBUG && false)
                        Log.v(K9.LOG_TAG, ""Not pushing folder "" + folder.getName() +
                              "" which is in push mode "" + fPushClass + "" while account is in push mode "" + aPushMode);

                    continue;
                }
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""Starting pusher for "" + account.getDescription() + "":"" + folder.getName());

                names.add(folder.getName());
            }

            if (names.size() > 0)
            {
                PushReceiver receiver = new MessagingControllerPushReceiver(mApplication, account, this);
                int maxPushFolders = account.getMaxPushFolders();

                if (names.size() > maxPushFolders)
                {
                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""Count of folders to push for account "" + account.getDescription() + "" is "" + names.size()
                              + "", greater than limit of "" + maxPushFolders + "", truncating"");

                    names = names.subList(0, maxPushFolders);
                }

                try
                {
                    Store store = account.getRemoteStore();
                    if (!store.isPushCapable())
                    {
                        if (K9.DEBUG)
                            Log.i(K9.LOG_TAG, ""Account "" + account.getDescription() + "" is not push capable, skipping"");

                        return false;
                    }
                    Pusher pusher = store.getPusher(receiver);
                    if (pusher != null)
                    {
                        Pusher oldPusher  = pushers.putIfAbsent(account, pusher);
                        if (oldPusher == null)
                        {
                            pusher.start(names);
                        }
                    }
                }
                catch (Exception e)
                {
                    Log.e(K9.LOG_TAG, ""Could not get remote store"", e);
                    return false;
                }

                return true;
            }
            else
            {
                if (K9.DEBUG)
                    Log.i(K9.LOG_TAG, ""No folders are configured for pushing in account "" + account.getDescription());
                return false;
            }

        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Got exception while setting up pushing"", e);
        }
        return false;
    }

    public void stopAllPushing()
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Stopping all pushers"");

        Iterator<Pusher> iter = pushers.values().iterator();
        while (iter.hasNext())
        {
            Pusher pusher = iter.next();
            iter.remove();
            pusher.stop();
        }
    }

    public void messagesArrived(final Account account, final Folder remoteFolder, final List<Message> messages, final boolean flagSyncOnly)
    {
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""Got new pushed email messages for account "" + account.getDescription()
                  + "", folder "" + remoteFolder.getName());

        final CountDownLatch latch = new CountDownLatch(1);
        putBackground(""Push messageArrived of account "" + account.getDescription()
                      + "", folder "" + remoteFolder.getName(), null, new Runnable()
        {
            public void run()
            {
                LocalFolder localFolder = null;
                try
                {
                    LocalStore localStore = account.getLocalStore();
                    localFolder= localStore.getFolder(remoteFolder.getName());
                    localFolder.open(OpenMode.READ_WRITE);

                    account.setRingNotified(false);
                    int newCount = downloadMessages(account, remoteFolder, localFolder, messages, flagSyncOnly);
                    int unreadMessageCount = setLocalUnreadCountToRemote(localFolder, remoteFolder,  messages.size());

                    setLocalFlaggedCountToRemote(localFolder, remoteFolder);

                    localFolder.setLastPush(System.currentTimeMillis());
                    localFolder.setStatus(null);

                    if (K9.DEBUG)
                        Log.i(K9.LOG_TAG, ""messagesArrived newCount = "" + newCount + "", unread count = "" + unreadMessageCount);

                    if (unreadMessageCount == 0)
                    {
                        notifyAccountCancel(mApplication, account);
                    }

                    for (MessagingListener l : getListeners())
                    {
                        l.folderStatusChanged(account, remoteFolder.getName(), unreadMessageCount);
                    }

                }
                catch (Exception e)
                {
                    String rootMessage = getRootCauseMessage(e);
                    String errorMessage = ""Push failed: "" + rootMessage;
                    try
                    {
                        localFolder.setStatus(errorMessage);
                    }
                    catch (Exception se)
                    {
                        Log.e(K9.LOG_TAG, ""Unable to set failed status on localFolder"", se);
                    }
                    for (MessagingListener l : getListeners())
                    {
                        l.synchronizeMailboxFailed(account, remoteFolder.getName(), errorMessage);
                    }
                    addErrorMessage(account, null, e);
                }
                finally
                {
                    if (localFolder != null)
                    {
                        try
                        {
                            localFolder.close();
                        }
                        catch (Exception e)
                        {
                            Log.e(K9.LOG_TAG, ""Unable to close localFolder"", e);
                        }
                    }
                    latch.countDown();
                }

            }
        });
        try
        {
            latch.await();
        }
        catch (Exception e)
        {
            Log.e(K9.LOG_TAG, ""Interrupted while awaiting latch release"", e);
        }
        if (K9.DEBUG)
            Log.i(K9.LOG_TAG, ""MessagingController.messagesArrivedLatch released"");
    }
    enum MemorizingState { STARTED, FINISHED, FAILED };

    class Memory
    {
        Account account;
        String folderName;
        MemorizingState syncingState = null;
        MemorizingState sendingState = null;
        MemorizingState pushingState = null;
        MemorizingState processingState = null;
        String failureMessage = null;

        int syncingTotalMessagesInMailbox;
        int syncingNumNewMessages;

        int folderCompleted = 0;
        int folderTotal = 0;
        String processingCommandTitle = null;

        Memory(Account nAccount, String nFolderName)
        {
            account = nAccount;
            folderName = nFolderName;
        }

        String getKey()
        {
            return getMemoryKey(account, folderName);
        }


    }
    static String getMemoryKey(Account taccount, String tfolderName)
    {
        return taccount.getDescription() + "":"" + tfolderName;
    }
    class MemorizingListener extends MessagingListener
    {
        HashMap<String, Memory> memories = new HashMap<String, Memory>(31);

        Memory getMemory(Account account, String folderName)
        {
            Memory memory = memories.get(getMemoryKey(account, folderName));
            if (memory == null)
            {
                memory = new Memory(account, folderName);
                memories.put(memory.getKey(), memory);
            }
            return memory;
        }

        @Override
        public synchronized void synchronizeMailboxStarted(Account account, String folder)
        {
            Memory memory = getMemory(account, folder);
            memory.syncingState = MemorizingState.STARTED;
            memory.folderCompleted = 0;
            memory.folderTotal = 0;
        }

        @Override
        public synchronized void synchronizeMailboxFinished(Account account, String folder,
                int totalMessagesInMailbox, int numNewMessages)
        {
            Memory memory = getMemory(account, folder);
            memory.syncingState = MemorizingState.FINISHED;
            memory.syncingTotalMessagesInMailbox = totalMessagesInMailbox;
            memory.syncingNumNewMessages = numNewMessages;
        }

        @Override
        public synchronized void synchronizeMailboxFailed(Account account, String folder,
                String message)
        {

            Memory memory = getMemory(account, folder);
            memory.syncingState = MemorizingState.FAILED;
            memory.failureMessage = message;
        }
        synchronized void refreshOther(MessagingListener other)
        {
            if (other != null)
            {

                Memory syncStarted = null;
                Memory sendStarted = null;
                Memory processingStarted = null;

                for (Memory memory : memories.values())
                {

                    if (memory.syncingState != null)
                    {
                        switch (memory.syncingState)
                        {
                            case STARTED:
                                syncStarted = memory;
                                break;
                            case FINISHED:
                                other.synchronizeMailboxFinished(memory.account, memory.folderName,
                                                                 memory.syncingTotalMessagesInMailbox, memory.syncingNumNewMessages);
                                break;
                            case FAILED:
                                other.synchronizeMailboxFailed(memory.account, memory.folderName,
                                                               memory.failureMessage);
                                break;
                        }
                    }

                    if (memory.sendingState != null)
                    {
                        switch (memory.sendingState)
                        {
                            case STARTED:
                                sendStarted = memory;
                                break;
                            case FINISHED:
                                other.sendPendingMessagesCompleted(memory.account);
                                break;
                            case FAILED:
                                other.sendPendingMessagesFailed(memory.account);
                                break;
                        }
                    }
                    if (memory.pushingState != null)
                    {
                        switch (memory.pushingState)
                        {
                            case STARTED:
                                other.setPushActive(memory.account, memory.folderName, true);
                                break;
                            case FINISHED:
                                other.setPushActive(memory.account, memory.folderName, false);
                                break;
                        }
                    }
                    if (memory.processingState != null)
                    {
                        switch (memory.processingState)
                        {
                            case STARTED:
                                processingStarted = memory;
                                break;
                            case FINISHED:
                            case FAILED:
                                other.pendingCommandsFinished(memory.account);
                                break;
                        }
                    }
                }
                Memory somethingStarted = null;
                if (syncStarted != null)
                {
                    other.synchronizeMailboxStarted(syncStarted.account, syncStarted.folderName);
                    somethingStarted = syncStarted;
                }
                if (sendStarted != null)
                {
                    other.sendPendingMessagesStarted(sendStarted.account);
                    somethingStarted = sendStarted;
                }
                if (processingStarted != null)
                {
                    other.pendingCommandsProcessing(processingStarted.account);
                    if (processingStarted.processingCommandTitle != null)
                    {
                        other.pendingCommandStarted(processingStarted.account, processingStarted.processingCommandTitle);

                    }
                    else
                    {
                        other.pendingCommandCompleted(processingStarted.account, processingStarted.processingCommandTitle);
                    }
                    somethingStarted = processingStarted;
                }
                if (somethingStarted != null && somethingStarted.folderTotal > 0)
                {
                    other.synchronizeMailboxProgress(somethingStarted.account, somethingStarted.folderName, somethingStarted.folderCompleted, somethingStarted.folderTotal);
                }

            }
        }
        @Override
        public synchronized void setPushActive(Account account, String folderName, boolean active)
        {
            Memory memory = getMemory(account, folderName);
            memory.pushingState = (active ? MemorizingState.STARTED : MemorizingState.FINISHED);
        }

        @Override
        public synchronized void sendPendingMessagesStarted(Account account)
        {
            Memory memory = getMemory(account, null);
            memory.sendingState = MemorizingState.STARTED;
            memory.folderCompleted = 0;
            memory.folderTotal = 0;
        }

        @Override
        public synchronized void sendPendingMessagesCompleted(Account account)
        {
            Memory memory = getMemory(account, null);
            memory.sendingState = MemorizingState.FINISHED;
        }

        @Override
        public synchronized void sendPendingMessagesFailed(Account account)
        {
            Memory memory = getMemory(account, null);
            memory.sendingState = MemorizingState.FAILED;
        }


        @Override
        public synchronized void synchronizeMailboxProgress(Account account, String folderName, int completed, int total)
        {
            Memory memory = getMemory(account, folderName);
            memory.folderCompleted = completed;
            memory.folderTotal = total;
        }


        @Override
        public synchronized void pendingCommandsProcessing(Account account)
        {
            Memory memory = getMemory(account, null);
            memory.processingState = MemorizingState.STARTED;
            memory.folderCompleted = 0;
            memory.folderTotal = 0;
        }
        @Override
        public synchronized void pendingCommandsFinished(Account account)
        {
            Memory memory = getMemory(account, null);
            memory.processingState = MemorizingState.FINISHED;
        }
        @Override
        public synchronized void pendingCommandStarted(Account account, String commandTitle)
        {
            Memory memory = getMemory(account, null);
            memory.processingCommandTitle = commandTitle;
        }

        @Override
        public synchronized void pendingCommandCompleted(Account account, String commandTitle)
        {
            Memory memory = getMemory(account, null);
            memory.processingCommandTitle = null;
        }

    }

    private void actOnMessages(Message[] messages, MessageActor actor)
    {
        Map<Account, Map<Folder, List<Message>>> accountMap = new HashMap<Account, Map<Folder, List<Message>>>();

        for (Message message : messages)
        {
            Folder folder = message.getFolder();
            Account account = folder.getAccount();

            Map<Folder, List<Message>> folderMap = accountMap.get(account);
            if (folderMap == null)
            {
                folderMap = new HashMap<Folder, List<Message>>();
                accountMap.put(account, folderMap);
            }
            List<Message> messageList = folderMap.get(folder);
            if (messageList == null)
            {
                messageList = new LinkedList<Message>();
                folderMap.put(folder, messageList);
            }

            messageList.add(message);
        }
        for (Map.Entry<Account, Map<Folder, List<Message>>> entry : accountMap.entrySet())
        {
            Account account = entry.getKey();

            //account.refresh(Preferences.getPreferences(K9.app));
            Map<Folder, List<Message>> folderMap = entry.getValue();
            for (Map.Entry<Folder, List<Message>> folderEntry : folderMap.entrySet())
            {
                Folder folder = folderEntry.getKey();
                List<Message> messageList = folderEntry.getValue();
                actor.act(account, folder, messageList);
            }
        }
    }

    interface MessageActor
    {
        public void act(final Account account, final Folder folder, final List<Message> messages);
    }
}
",True,217,1,1,7,61,14,29,L1
136,com.fsck.k9.controller.MessagingListener.java,"
package com.fsck.k9.controller;

import android.content.Context;
import com.fsck.k9.Account;
import com.fsck.k9.AccountStats;
import com.fsck.k9.BaseAccount;
import com.fsck.k9.mail.Folder;
import com.fsck.k9.mail.Message;
import com.fsck.k9.mail.Part;

import java.util.List;

/**
 * Defines the interface that MessagingController will use to callback to requesters. This class
 * is defined as non-abstract so that someone who wants to receive only a few messages can
 * do so without implementing the entire interface. It is highly recommended that users of
 * this interface use the @Override annotation in their implementations to avoid being caught by
 * changes in this class.
 */
public class MessagingListener
{
    public void searchStats(AccountStats stats) {}

    public void accountStatusChanged(BaseAccount account, AccountStats stats)
    {
    }

    public void accountSizeChanged(Account account, long oldSize, long newSize)
    {
    }

    public void listFoldersStarted(Account account)
    {
    }

    public void listFolders(Account account, Folder[] folders)
    {
    }

    public void listFoldersFailed(Account account, String message)
    {
    }

    public void listFoldersFinished(Account account)
    {
    }

    public void listLocalMessagesStarted(Account account, String folder)
    {
    }

    public void listLocalMessages(Account account, String folder, Message[] messages)
    {
    }

    public void listLocalMessagesAddMessages(Account account, String folder, List<Message> messages)
    {
    }

    public void listLocalMessagesUpdateMessage(Account account, String folder, Message message)
    {
    }

    public void listLocalMessagesRemoveMessage(Account account, String folder, Message message)
    {
    }

    public void listLocalMessagesFailed(Account account, String folder, String message)
    {
    }

    public void listLocalMessagesFinished(Account account, String folder)
    {
    }

    public void synchronizeMailboxStarted(Account account, String folder)
    {
    }

    public void synchronizeMailboxHeadersStarted(Account account, String folder)
    {
    }

    public void synchronizeMailboxHeadersProgress(Account account, String folder, int completed, int total)
    {
    }

    public void synchronizeMailboxHeadersFinished(Account account, String folder,
            int totalMessagesInMailbox, int numNewMessages)
    {
    }


    public void synchronizeMailboxProgress(Account account, String folder, int completed, int total)
    {}

    public void synchronizeMailboxNewMessage(Account account, String folder, Message message)
    {
    }

    public void synchronizeMailboxAddOrUpdateMessage(Account account, String folder, Message message)
    {
    }

    public void synchronizeMailboxRemovedMessage(Account account, String folder,Message message)
    {
    }

    public void synchronizeMailboxFinished(Account account, String folder,
                                           int totalMessagesInMailbox, int numNewMessages)
    {
    }

    public void synchronizeMailboxFailed(Account account, String folder,
                                         String message)
    {
    }

    public void loadMessageForViewStarted(Account account, String folder, String uid)
    {
    }

    public void loadMessageForViewHeadersAvailable(Account account, String folder, String uid,
            Message message)
    {
    }

    public void loadMessageForViewBodyAvailable(Account account, String folder, String uid,
            Message message)
    {
    }

    public void loadMessageForViewFinished(Account account, String folder, String uid,
                                           Message message)
    {
    }

    public void loadMessageForViewFailed(Account account, String folder, String uid, Throwable t)
    {
    }

    public void checkMailStarted(Context context, Account account)
    {
    }

    public void checkMailFinished(Context context, Account account)
    {
    }

    public void checkMailFailed(Context context, Account account, String reason)
    {
    }

    public void sendPendingMessagesStarted(Account account)
    {
    }

    public void sendPendingMessagesCompleted(Account account)
    {
    }

    public void sendPendingMessagesFailed(Account account)
    {
    }

    public void messageDeleted(Account account, String folder, Message message)
    {

    }
    public void emptyTrashCompleted(Account account)
    {
    }

    public void folderStatusChanged(Account account, String folderName, int unreadMessageCount)
    {
    }

    public void folderStatusChanged(Account account, String folderName)
    {
    }

    public void messageUidChanged(Account account, String folder, String oldUid, String newUid)
    {

    }

    public void setPushActive(Account account, String folderName, boolean enabled)
    {

    }

    public void loadAttachmentStarted(
        Account account,
        Message message,
        Part part,
        Object tag,
        boolean requiresDownload)
    {
    }

    public void loadAttachmentFinished(
        Account account,
        Message message,
        Part part,
        Object tag)
    {
    }

    public void loadAttachmentFailed(
        Account account,
        Message message,
        Part part,
        Object tag,
        String reason)
    {
    }

    public void pendingCommandsProcessing(Account account) {}
    public void pendingCommandsFinished(Account account) {}
    public void pendingCommandStarted(Account account, String commandTitle)
    {}

    public void pendingCommandCompleted(Account account, String commandTitle)
    {}

    /**
     * General notification messages subclasses can override to be notified that the controller
     * has completed a command. This is useful for turning off progress indicators that may have
     * been left over from previous commands.
     * @param moreCommandsToRun True if the controller will continue on to another command
     * immediately.
     */
    public void controllerCommandCompleted(boolean moreCommandsToRun)
    {

    }
}
",False,217,1,1,8,54,13,6,L1
