,file_path,source_code,is_vulnerable,id, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,org.eehouse.android.xw4.GamesList.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.ListActivity;
import android.app.Dialog;
import android.app.AlertDialog;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.DialogInterface;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.view.ContextMenu;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ContextMenu.ContextMenuInfo;
import android.widget.AdapterView;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.Button;
import android.view.MenuInflater;
import java.io.File;
import android.preference.PreferenceManager;
// import android.telephony.PhoneStateListener;
// import android.telephony.TelephonyManager;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;

public class GamesList extends XWListActivity 
    implements DispatchNotify.HandleRelaysIface,
               DBUtils.DBChangeListener,
               GameListAdapter.LoadItemCB {

    private static final int WARN_NODICT       = DlgDelegate.DIALOG_LAST + 1;
    private static final int WARN_NODICT_SUBST = WARN_NODICT + 1;
    private static final int SHOW_SUBST        = WARN_NODICT + 2;
    private static final int GET_NAME          = WARN_NODICT + 3;
    private static final int RENAME_GAME       = WARN_NODICT + 4;

    private static final String SAVE_ROWID = ""SAVE_ROWID"";

    private static final int NEW_NET_GAME_ACTION = 1;
    private static final int RESET_GAME_ACTION = 2;
    private static final int DELETE_GAME_ACTION = 3;
    private static final int DELETE_ALL_ACTION = 4;
    private static final int SYNC_MENU_ACTION = 5;
    private static final int DUPE_GAME_ACTION = 6;

    private GameListAdapter m_adapter;
    private String m_missingDict;
    private Handler m_handler;
    private String[] m_missingDictNames;
    private long m_missingDictRowId;
    private String[] m_sameLangDicts;
    private int m_missingDictLang;
    private long m_rowid;
    private String m_nameField;
    private NetLaunchInfo m_netLaunchInfo;

    @Override
    protected Dialog onCreateDialog( int id )
    {
        DialogInterface.OnClickListener lstnr;
        LinearLayout layout;

        Dialog dialog = super.onCreateDialog( id );
        if ( null == dialog ) {
            AlertDialog.Builder ab;
            switch ( id ) {
            case WARN_NODICT:
            case WARN_NODICT_SUBST:
                lstnr = new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dlg, int item ) {
                            for ( String name : m_missingDictNames ) {
                                DictsActivity.
                                    launchAndDownload( GamesList.this, 
                                                       m_missingDictLang,
                                                       name );
                                break; // just do one
                            }
                        }
                    };
                String message;
                String langName = 
                    DictLangCache.getLangName( this, m_missingDictLang );
                String gameName = GameUtils.getName( this, m_rowid );
                if ( WARN_NODICT == id ) {
                    message = String.format( getString( R.string.no_dictf ),
                                             gameName, langName );
                } else {
                    message = String.format( getString(R.string.no_dict_substf),
                                             gameName, m_missingDictNames[0], 
                                             langName );
                }

                ab = new AlertDialog.Builder( this )
                    .setTitle( R.string.no_dict_title )
                    .setMessage( message )
                    .setPositiveButton( R.string.button_ok, null )
                    .setNegativeButton( R.string.button_download, lstnr )
                    ;
                if ( WARN_NODICT_SUBST == id ) {
                    lstnr = new DialogInterface.OnClickListener() {
                            public void onClick( DialogInterface dlg, int item ) {
                                showDialog( SHOW_SUBST );
                            }
                        };
                    ab.setNeutralButton( R.string.button_substdict, lstnr );
                }
                dialog = ab.create();
                Utils.setRemoveOnDismiss( this, dialog, id );
                break;
            case SHOW_SUBST:
                m_sameLangDicts = 
                    DictLangCache.getHaveLangCounts( this, m_missingDictLang );
                lstnr = new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dlg,
                                             int which ) {
                            int pos = ((AlertDialog)dlg).getListView().
                                getCheckedItemPosition();
                            String dict = m_sameLangDicts[pos];
                            dict = DictLangCache.stripCount( dict );
                            GameUtils.replaceDicts( GamesList.this,
                                                    m_missingDictRowId,
                                                    m_missingDictNames[0],
                                                    dict );
                        }
                    };
                dialog = new AlertDialog.Builder( this )
                    .setTitle( R.string.subst_dict_title )
                    .setPositiveButton( R.string.button_substdict, lstnr )
                    .setNegativeButton( R.string.button_cancel, null )
                    .setSingleChoiceItems( m_sameLangDicts, 0, null )
                    .create();
                    ;
                // Force destruction so onCreateDialog() will get
                // called next time and we can insert a different
                // list.  There seems to be no way to change the list
                // inside onPrepareDialog().
                dialog.setOnDismissListener(new DialogInterface.
                                            OnDismissListener() {
                        public void onDismiss(DialogInterface dlg) {
                            removeDialog( SHOW_SUBST );
                        }
                    });
                break;

            case RENAME_GAME:
                layout =
                    (LinearLayout)Utils.inflate( this, R.layout.rename_game );
                lstnr = new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dlgi, int item ) {
                            Dialog dlg = (Dialog)dlgi;
                            EditText txt = 
                                (EditText)dlg.findViewById( R.id.name_edit );
                            String name = txt.getText().toString();
                            DBUtils.setName( GamesList.this, m_rowid, name );
                            m_adapter.inval( m_rowid );
                            onContentChanged();
                        }
                    };
                dialog = new AlertDialog.Builder( this )
                    .setTitle( R.string.game_rename_title )
                    .setNegativeButton( R.string.button_cancel, null )
                    .setPositiveButton( R.string.button_ok, lstnr )
                    .setView( layout )
                    .create();
                break;

            case GET_NAME:
                layout = 
                    (LinearLayout)Utils.inflate( this, R.layout.dflt_name );
                final EditText etext =
                    (EditText)layout.findViewById( R.id.name_edit );
                etext.setText( CommonPrefs.getDefaultPlayerName( this, 0, 
                                                                 true ) );
                dialog = new AlertDialog.Builder( this )
                    .setTitle( R.string.default_name_title )
                    .setMessage( R.string.default_name_message )
                    .setPositiveButton( R.string.button_ok, null )
                    .setView( layout )
                    .create();
                dialog.setOnDismissListener(new DialogInterface.
                                            OnDismissListener() {
                        public void onDismiss( DialogInterface dlg ) {
                            String name = etext.getText().toString();
                            if ( 0 == name.length() ) {
                                name = CommonPrefs.
                                    getDefaultPlayerName( GamesList.this,
                                                          0, true );
                            }
                            CommonPrefs.setDefaultPlayerName( GamesList.this,
                                                              name );
                        }
                    });
                break;
            default:
                // just drop it; super.onCreateDialog likely failed
                break;
            }
        }
        return dialog;
    } // onCreateDialog

    @Override
    public void onPrepareDialog( int id, Dialog dialog )
    {
        switch( id ) {
        case RENAME_GAME:
            String name = GameUtils.getName( this, m_rowid );
            EditText txt = (EditText)dialog.findViewById( R.id.name_edit );
            txt.setText( name );
            break;
        default:
            super.onPrepareDialog( id, dialog );
            break;
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) 
    {
        super.onCreate( savedInstanceState );
        getBundledData( savedInstanceState );

        m_handler = new Handler();

        setContentView(R.layout.game_list);
        registerForContextMenu( getListView() );
        DBUtils.setDBChangeListener( this );

        boolean isUpgrade = FirstRunDialog.show( this, false );
        PreferenceManager.setDefaultValues( this, R.xml.xwprefs, isUpgrade );

        // setDefaultKeyMode(DEFAULT_KEYS_SHORTCUT);

        Button newGameB = (Button)findViewById(R.id.new_game);
        newGameB.setOnClickListener( new View.OnClickListener() {
                @Override
                public void onClick( View v ) {
                    // addGame( false );
                    startNewGameActivity();
                    // showNotAgainDlg( R.string.not_again_newgame, 
                    //                  R.string.key_notagain_newgame );
                }
            });

        m_adapter = new GameListAdapter( this, this );
        setListAdapter( m_adapter );

        NetUtils.informOfDeaths( this );

        Intent intent = getIntent();
        startFirstHasDict( intent );
        startNewNetGame( intent );

        askDefaultNameIf();
    } // onCreate

    @Override
    // called when we're brought to the front (probably as a result of
    // notification)
    protected void onNewIntent( Intent intent )
    {
        super.onNewIntent( intent );
        Assert.assertNotNull( intent );
        invalRelayIDs( intent.
                       getStringArrayExtra( DispatchNotify.RELAYIDS_EXTRA ) );
        startFirstHasDict( intent );
        startNewNetGame( intent );
    }

    @Override
    protected void onStart()
    {
        super.onStart();
        DispatchNotify.SetRelayIDsHandler( this );

        boolean hide = CommonPrefs.getHideIntro( this );
        int hereOrGone = hide ? View.GONE : View.VISIBLE;
        for ( int id : new int[]{ R.id.empty_games_list, 
                                  R.id.new_game } ) {
            View view = findViewById( id );
            view.setVisibility( hereOrGone );
        }
        View empty = findViewById( R.id.empty_list_msg );
        empty.setVisibility( hide ? View.VISIBLE : View.GONE );
        getListView().setEmptyView( hide? empty : null );

        // TelephonyManager mgr = 
        //     (TelephonyManager)getSystemService( Context.TELEPHONY_SERVICE );
        // m_phoneStateListener = new XWPhoneStateListener();
        // mgr.listen( m_phoneStateListener,
        //             PhoneStateListener.LISTEN_DATA_CONNECTION_STATE );
    }

    @Override
    protected void onStop()
    {
        // TelephonyManager mgr = 
        //     (TelephonyManager)getSystemService( Context.TELEPHONY_SERVICE );
        // mgr.listen( m_phoneStateListener, PhoneStateListener.LISTEN_NONE );
        // m_phoneStateListener = null;
        DispatchNotify.SetRelayIDsHandler( null );

        super.onStop();
    }

    @Override
    protected void onDestroy()
    {
        DBUtils.clearDBChangeListener( this );
        super.onDestroy();
    }

    @Override
    protected void onSaveInstanceState( Bundle outState ) 
    {
        super.onSaveInstanceState( outState );
        outState.putLong( SAVE_ROWID, m_rowid );
        if ( null != m_netLaunchInfo ) {
            m_netLaunchInfo.putSelf( outState );
        }
    }

    private void getBundledData( Bundle bundle )
    {
        if ( null != bundle ) {
            m_rowid = bundle.getLong( SAVE_ROWID );
            m_netLaunchInfo = new NetLaunchInfo( bundle );
        }
    }

    @Override
    public void onWindowFocusChanged( boolean hasFocus )
    {
        super.onWindowFocusChanged( hasFocus );
        if ( hasFocus ) {
            updateField();
        }
    }

    // DispatchNotify.HandleRelaysIface interface
    public void HandleRelaysIDs( final String[] relayIDs )
    {
        m_handler.post( new Runnable() {
                public void run() {
                    invalRelayIDs( relayIDs );
                    startFirstHasDict( relayIDs );
                }
            } );
    }

    public void HandleInvite( final Uri invite )
    {
        final NetLaunchInfo nli = new NetLaunchInfo( invite );
        if ( nli.isValid() ) {
            m_handler.post( new Runnable() {
                    @Override
                    public void run() {
                        startNewNetGame( nli );
                    }
                } );
        }
    }

    // DBUtils.DBChangeListener interface
    public void gameSaved( final long rowid )
    {
        m_handler.post( new Runnable() {
                public void run() {
                    m_adapter.inval( rowid );
                    onContentChanged();
                }
            } );
    }

    // GameListAdapter.LoadItemCB interface
    public void itemLoaded( long rowid )
    {
        onContentChanged();
    }

    // DlgDelegate.DlgClickNotify interface
    @Override
    public void dlgButtonClicked( int id, int which )
    {
        if ( AlertDialog.BUTTON_POSITIVE == which ) {
            switch( id ) {
            case NEW_NET_GAME_ACTION:
                long rowid = GameUtils.makeNewNetGame( this, m_netLaunchInfo );
                GameUtils.launchGame( this, rowid, true );
                break;
            case RESET_GAME_ACTION:
                GameUtils.resetGame( this, m_rowid );
                break;
            case DELETE_GAME_ACTION:
                GameUtils.deleteGame( this, m_rowid, true );
                break;
            case DELETE_ALL_ACTION:
                long[] games = DBUtils.gamesList( this );
                for ( int ii = games.length - 1; ii >= 0; --ii ) {
                    GameUtils.deleteGame( this, games[ii], ii == 0  );
                    m_adapter.inval( games[ii] );
                }
                break;
            case SYNC_MENU_ACTION:
                doSyncMenuitem();
                break;
            case DUPE_GAME_ACTION:
                long newid = GameUtils.dupeGame( GamesList.this, m_rowid );
                if ( null != m_adapter ) {
                    m_adapter.inval( newid );
                }
                break;
            default:
                Assert.fail();
            }
        }
    }

    public void itemClicked( long rowid )
    {
        // We need a way to let the user get back to the basic-config
        // dialog in case it was dismissed.  That way it to check for
        // an empty room name.
        GameSummary summary = DBUtils.getSummary( this, rowid, true );
        if ( summary.conType == CommsAddrRec.CommsConnType.COMMS_CONN_RELAY
             && summary.roomName.length() == 0 ) {
            // If it's unconfigured and of the type RelayGameActivity
            // can handle send it there, otherwise use the full-on
            // config.
            Class clazz;
            if ( RelayGameActivity.isSimpleGame( summary ) ) {
                clazz = RelayGameActivity.class;
            } else {
                clazz = GameConfig.class;
            }
            GameUtils.doConfig( this, rowid, clazz );
        } else {
            if ( checkWarnNoDict( rowid ) ) {
                GameUtils.launchGame( this, rowid );
            }
        }
    }

    @Override
    public void onCreateContextMenu( ContextMenu menu, View view, 
                                     ContextMenuInfo menuInfo ) 
    {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.games_list_item_menu, menu );

        AdapterView.AdapterContextMenuInfo info = 
            (AdapterView.AdapterContextMenuInfo)menuInfo;
        int position = info.position;
        long rowid = DBUtils.gamesList( this )[position];
        String title = GameUtils.getName( this, rowid );
        String fmt = getString(R.string.game_item_menu_titlef );
        menu.setHeaderTitle( String.format( fmt, title ) );
    }
        
    @Override
    public boolean onContextItemSelected( MenuItem item ) 
    {
        AdapterView.AdapterContextMenuInfo info;
        try {
            info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
        } catch (ClassCastException e) {
            Utils.logf( ""bad menuInfo: %s"", e.toString() );
            return false;
        }

        return handleMenuItem( item.getItemId(), info.position );
    } // onContextItemSelected

    public boolean onCreateOptionsMenu( Menu menu )
    {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.games_list_menu, menu );
        return true;
    }

    public boolean onOptionsItemSelected( MenuItem item )
    {
        boolean handled = true;
        Intent intent;

        switch (item.getItemId()) {
        case R.id.gamel_menu_newgame:
            startNewGameActivity();
            break;

        case R.id.gamel_menu_delete_all:
            if ( DBUtils.gamesList( this ).length > 0 ) {
                showConfirmThen( R.string.confirm_delete_all, 
                                 R.string.button_delete, DELETE_ALL_ACTION );
            }
            handled = true;
            break;

        case R.id.gamel_menu_dicts:
            intent = new Intent( this, DictsActivity.class );
            startActivity( intent );
            break;

        case R.id.gamel_menu_checkmoves:
            showNotAgainDlgThen( R.string.not_again_sync,
                                 R.string.key_notagain_sync,
                                 SYNC_MENU_ACTION );
            break;

        case R.id.gamel_menu_prefs:
            intent = new Intent( this, PrefsActivity.class );
            startActivity( intent );
            break;

        case R.id.gamel_menu_about:
            showAboutDialog();
            break;

        // case R.id.gamel_menu_view_hidden:
        //     Utils.notImpl( this );
        //     break;
        default:
            handled = false;
        }

        return handled;
    }

    private boolean handleMenuItem( int menuID, int position ) 
    {
        boolean handled = true;
        DialogInterface.OnClickListener lstnr;

        m_rowid = DBUtils.gamesList( this )[position];
        
        if ( R.id.list_item_delete == menuID ) {
            showConfirmThen( R.string.confirm_delete, R.string.button_delete, 
                             DELETE_GAME_ACTION );
        } else {
            if ( checkWarnNoDict( m_rowid ) ) {
                switch ( menuID ) {
                case R.id.list_item_reset:
                    showConfirmThen( R.string.confirm_reset, 
                                     R.string.button_reset, RESET_GAME_ACTION );
                    break;
                case R.id.list_item_config:
                    GameUtils.doConfig( this, m_rowid, GameConfig.class );
                    break;
                case R.id.list_item_rename:
                    showDialog( RENAME_GAME );
                    break;

                case R.id.list_item_new_from:
                    showNotAgainDlgThen( R.string.not_again_newfrom,
                                         R.string.key_notagain_newfrom, 
                                         DUPE_GAME_ACTION );
                    break;

                case R.id.list_item_copy:
                    GameSummary summary = DBUtils.getSummary( this, 
                                                              m_rowid, true );
                    if ( summary.inNetworkGame() ) {
                        showOKOnlyDialog( R.string.no_copy_network );
                    } else {
                        byte[] stream = GameUtils.savedGame( this, m_rowid );
                        GameUtils.GameLock lock = 
                            GameUtils.saveNewGame( this, stream );
                        DBUtils.saveSummary( this, lock, summary );
                        lock.unlock();
                    }
                    break;

                    // These require some notion of predictable sort order.
                    // Maybe put off until I'm using a db?
                    // case R.id.list_item_hide:
                    // case R.id.list_item_move_up:
                    // case R.id.list_item_move_down:
                    // case R.id.list_item_move_to_top:
                    // case R.id.list_item_move_to_bottom:
                    // Utils.notImpl( this );
                    // break;
                default:
                    handled = false;
                    break;
                }
            }
        }

        return handled;
    } // handleMenuItem

    private boolean checkWarnNoDict( long rowid )
    {
        String[][] missingNames = new String[1][];
        int[] missingLang = new int[1];
        boolean hasDicts = GameUtils.gameDictsHere( this, rowid,
                                                    missingNames, 
                                                    missingLang );
        if ( !hasDicts ) {
            m_missingDictNames = missingNames[0];
            m_missingDictLang = missingLang[0];
            m_missingDictRowId = rowid;
            if ( 0 == DictLangCache.getLangCount( this, m_missingDictLang ) ) {
                showDialog( WARN_NODICT );
            } else {
                showDialog( WARN_NODICT_SUBST );
            }
        }
        return hasDicts;
    }

    private void invalRelayIDs( String[] relayIDs ) 
    {
        if ( null != relayIDs ) {
            for ( String relayID : relayIDs ) {
                long rowid = DBUtils.getRowIDFor( this, relayID );
                m_adapter.inval( rowid );
            }
            onContentChanged();
        }
    }

    // Launch the first of these for which there's a dictionary
    // present.
    private void startFirstHasDict( String[] relayIDs )
    {
        if ( null != relayIDs ) {
            for ( String relayID : relayIDs ) {
                long rowid = DBUtils.getRowIDFor( this, relayID );
                if ( -1 != rowid && GameUtils.gameDictsHere( this, rowid ) ) {
                    GameUtils.launchGame( this, rowid );
                    break;
                }
            }
        }
    }

    private void startFirstHasDict( Intent intent )
    {
        if ( null != intent ) {
            String[] relayIDs =
                intent.getStringArrayExtra( DispatchNotify.RELAYIDS_EXTRA );
            startFirstHasDict( relayIDs );
        }
    }

    private void startNewGameActivity()
    {
        startActivity( new Intent( this, NewGameActivity.class ) );
    }

    private void startNewNetGame( NetLaunchInfo info )
    {
        long rowid = DBUtils.getRowIDForOpen( this, info.room, info.lang, 
                                              info.nPlayers );

        if ( -1 != rowid ) {
            rowid = GameUtils.makeNewNetGame( this, info );
            GameUtils.launchGame( this, rowid, true );
        } else {
            String fmt = getString( R.string.dup_game_queryf );
            String msg = String.format( fmt, info.room );
            m_netLaunchInfo = info;
            showConfirmThen( msg, NEW_NET_GAME_ACTION );
        }
    } // startNewNetGame

    private void startNewNetGame( Intent intent )
    {
        Uri data = intent.getData();
        if ( null != data ) {
            NetLaunchInfo info = new NetLaunchInfo( data );
            if ( info.isValid() ) {
                startNewNetGame( info );
            }
        }
    } // startNewNetGame

    private void askDefaultNameIf()
    {
        if ( null == CommonPrefs.getDefaultPlayerName( this, 0, false ) ) {
            String name = CommonPrefs.getDefaultPlayerName( this, 0, true );
            CommonPrefs.setDefaultPlayerName( GamesList.this, name );
            showDialog( GET_NAME );
        }
    }

    private void updateField()
    {
        String newField = CommonPrefs.getSummaryField( this );
        if ( ! newField.equals( m_nameField ) ) {
            m_nameField = newField;
            m_adapter.setField( newField );
            onContentChanged();
        }
    }

}
",True,56,45,0,0,4,16,0,16,L3
1,org.eehouse.android.xw4.NewGameActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import java.util.Random;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.CurGameInfo;
import org.eehouse.android.xw4.jni.CommonPrefs;
import org.eehouse.android.xw4.jni.CommsAddrRec;
import org.eehouse.android.xw4.jni.XwJNI;


public class NewGameActivity extends XWActivity {

    private static final int NEW_GAME_ACTION = 1;

    @Override
    protected void onCreate(Bundle savedInstanceState) 
    {
        super.onCreate( savedInstanceState );

        setContentView( R.layout.new_game );

        TextView desc = (TextView)findViewById( R.id.newgame_local_desc );
        String fmt = getString( R.string.newgame_local_descf );
        String dict = CommonPrefs.getDefaultHumanDict( this );
        String lang = DictLangCache.getLangName( this, dict );
        desc.setText( String.format( fmt, lang ) );
        
        Button button = (Button)findViewById( R.id.newgame_local );
        button.setOnClickListener( new View.OnClickListener() {
                @Override
                public void onClick( View v ) {
                    makeNewGame( false, true );
                }
            } );
        button = (Button)findViewById( R.id.newgame_local_config );
        button.setOnClickListener( new View.OnClickListener() {
                @Override
                public void onClick( View v ) {
                    makeNewGame( false, false );
                }
            } );

        button = (Button)findViewById( R.id.newgame_invite );
        button.setOnClickListener( new View.OnClickListener() {
                @Override
                public void onClick( View v ) {
                    makeNewGame( true, true );
                }
            } );

        button = (Button)findViewById( R.id.newgame_net_config );
        button.setOnClickListener( new View.OnClickListener() {
                @Override
                public void onClick( View v ) {
                    makeNewGame( true, false );
                }
            } );

    }

    // DlgDelegate.DlgClickNotify interface
    @Override
    public void dlgButtonClicked( int id, int which )
    {
        switch( id ) {
        case NEW_GAME_ACTION:
            if ( DlgDelegate.DISMISS_BUTTON != which ) {
                makeNewGame( true, true, DlgDelegate.TEXT_BTN == which );
            }
            break;
        default:
            Assert.fail();
        }
    }

    private void makeNewGame( boolean networked, boolean launch )
    {
        if ( launch && networked ) {
            // Let 'em cancel before we make the game
            showTextOrHtmlThen( NEW_GAME_ACTION );
        } else {
            makeNewGame( networked, launch, false );
        }
    }

    private void makeNewGame( boolean networked, boolean launch,
                              boolean choseText )
    {
        String room = null;
        long rowid;
        int[] lang = {0};
        final int nPlayers = 2; // hard-coded for no-configure case

        if ( networked ) {
            Random random = new Random();
            room = String.format( ""%X"", random.nextInt() ).substring( 0, 4 );
            rowid = GameUtils.makeNewNetGame( this, room, lang, nPlayers, 1 );
        } else {
            rowid = GameUtils.saveNew( this, new CurGameInfo( this ) );
        }

        if ( launch ) {
            GameUtils.launchGame( this, rowid, networked );
            if ( networked ) {
                GameUtils.launchInviteActivity( this, choseText, room,
                                                lang[0], nPlayers );
            }
        } else {
            GameUtils.doConfig( this, rowid, GameConfig.class );
        }

        finish();
    }

}
",True,41,38,0,0,4,20,0,7,L3
2,org.eehouse.android.xw4.NetLaunchInfo.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2011 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.net.Uri;
import android.net.Uri.Builder;
import android.os.Bundle;
import java.net.URLEncoder;

import org.eehouse.android.xw4.jni.CommonPrefs;


public class NetLaunchInfo {
    public String room;
    public int lang;
    public int nPlayers;

    private static final String LANG = ""netlaunchinfo_lang"";
    private static final String ROOM = ""netlaunchinfo_room"";
    private static final String NPLAYERS = ""netlaunchinfo_nplayers"";
    private static final String VALID = ""netlaunchinfo_valid"";

    private boolean m_valid;

    public void putSelf( Bundle bundle )
    {
        bundle.putInt( LANG, lang );
        bundle.putString( ROOM, room );
        bundle.putInt( NPLAYERS, nPlayers );
        bundle.putBoolean( VALID, m_valid );
    }

    public NetLaunchInfo( Bundle bundle )
    {
        lang = bundle.getInt( LANG  );
        room = bundle.getString( ROOM );
        nPlayers = bundle.getInt( NPLAYERS  );
        m_valid = bundle.getBoolean( VALID  );
    }

    public static Uri makeLaunchUri( Context context, String room,
                                        int lang, int nPlayers )
    {
        Builder ub = new Builder();
        ub.scheme( ""http"" );
        String format = context.getString( R.string.game_url_pathf );
        ub.path( String.format( format,
                                CommonPrefs.getDefaultRedirHost( context ) ) );
        
        ub.appendQueryParameter( ""lang"", String.format(""%d"", lang ) );
        ub.appendQueryParameter( ""np"", String.format( ""%d"", nPlayers ) );
        ub.appendQueryParameter( ""room"", room );
        return ub.build();
    }

    public NetLaunchInfo( Uri data )
    {
        m_valid = false;
        if ( null != data ) {
            try {
                room = data.getQueryParameter( ""room"" );
                String langStr = data.getQueryParameter( ""lang"" );
                lang = Integer.decode( langStr );
                String np = data.getQueryParameter( ""np"" );
                nPlayers = Integer.decode( np );
                m_valid = true;
            } catch ( Exception e ) {
                Utils.logf( ""unable to parse \""%s\"""", data.toString() );
            }
        }
    }

    public boolean isValid()
    {
        return m_valid;
    }
}
",True,2,38,1,1,9,7,2,2,L1
3,org.eehouse.android.xw4.DictUtils.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Environment;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Arrays;
import android.content.res.AssetManager;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.concurrent.locks.Lock;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Random;
import android.text.Html;

import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class DictUtils {

    // keep in sync with loc_names string-array
    public enum DictLoc { UNKNOWN, BUILT_IN, INTERNAL, EXTERNAL, DOWNLOAD };
    public static final String INVITED = ""invited"";

    private static DictAndLoc[] s_dictListCache = null;

    static {
        MountEventReceiver.register( new MountEventReceiver.SDCardNotifiee() {
                public void cardMounted( boolean nowMounted )
                {
                    invalDictList();
                }
            } );
    }
 
    public static class DictPairs {
        public byte[][] m_bytes;
        public String[] m_paths;
        public DictPairs( byte[][] bytes, String[] paths ) {
            m_bytes = bytes; m_paths = paths;
        }

        public boolean anyMissing( final String[] names )
        {
            boolean missing = false;
            for ( int ii = 0; ii < m_paths.length; ++ii ) {
                if ( names[ii] != null ) {
                    // It's ok for there to be no dict IFF there's no
                    // name.  That's a player using the default dict.
                    if ( null == m_paths[ii] && null == m_bytes[ii] ) {
                        missing = true;
                        break;
                    }
                }
            }
            return missing;
        }
    } // DictPairs

    public static class DictAndLoc {
        public DictAndLoc( String pname, DictLoc ploc ) {
            name = removeDictExtn(pname); loc = ploc;
        }
        public String name;
        public DictLoc loc;

        @Override 
        public boolean equals( Object obj ) 
        {
            boolean result = false;
            if ( obj instanceof DictAndLoc ) {
                DictAndLoc other = (DictAndLoc)obj;
                
                result = name.equals( other.name )
                    && loc.equals( other.loc );
            }
            return result;
        }
    }
 
    public static void invalDictList()
    {
        s_dictListCache = null;
        // Should I have a list of folks who want to know when this
        // changes?
    }

    public static DictAndLoc[] dictList( Context context )
    {
        if ( null == s_dictListCache ) {
            ArrayList<DictAndLoc> al = new ArrayList<DictAndLoc>();

            for ( String file : getAssets( context ) ) {
                if ( isDict( file ) ) {
                    al.add( new DictAndLoc( removeDictExtn( file ), 
                                            DictLoc.BUILT_IN ) );
                }
            }

            for ( String file : context.fileList() ) {
                if ( isDict( file ) ) {
                    al.add( new DictAndLoc( removeDictExtn( file ),
                                            DictLoc.INTERNAL ) );
                }
            }

            File sdDir = getSDDir( context );
            if ( null != sdDir ) {
                for ( String file : sdDir.list() ) {
                    if ( isDict( file ) ) {
                        al.add( new DictAndLoc( removeDictExtn( file ),
                                                DictLoc.EXTERNAL ) );
                    }
                }
            }

            s_dictListCache = 
                al.toArray( new DictUtils.DictAndLoc[al.size()] );
        }
        return s_dictListCache;
    }

    public static DictLoc getDictLoc( Context context, String name )
    {
        DictLoc loc = null;
        name = addDictExtn( name );

        for ( String file : getAssets( context ) ) {
            if ( file.equals( name ) ) {
                loc = DictLoc.BUILT_IN;
                break;
            }
        }

        if ( null == loc ) {
            try {
                FileInputStream fis = context.openFileInput( name );
                fis.close();
                loc = DictLoc.INTERNAL;
            } catch ( java.io.FileNotFoundException fnf ) {
            } catch ( java.io.IOException ioe ) {
            }
        }

        if ( null == loc ) {
            File file = getSDPathFor( context, name );
            if ( null != file && file.exists() ) {
                loc = DictLoc.EXTERNAL;
            }
        }

        return loc;
    }

    public static boolean dictExists( Context context, String name )
    {
        return null != getDictLoc( context, name );
    }

    public static boolean dictIsBuiltin( Context context, String name )
    {
        return DictLoc.BUILT_IN == getDictLoc( context, name );
    }

    public static boolean moveDict( Context context, String name,
                                    DictLoc from, DictLoc to )
    {
        boolean success;
        name = addDictExtn( name );

        File toPath = getDictFile( context, name, to );
        if ( null != toPath && toPath.exists() ) {
            success = false;
        } else {
            success = copyDict( context, name, from, to );
            if ( success ) {
                deleteDict( context, name, from );
                invalDictList();
            }
        }
        return success;
    }

    private static boolean copyDict( Context context, String name,
                                     DictLoc from, DictLoc to )
    {
        boolean success = false;

        File file = getSDPathFor( context, name );
        if ( null != file ) {
            FileChannel channelIn = null;
            FileChannel channelOut = null;

            try {
                FileInputStream fis;
                FileOutputStream fos;
                if ( DictLoc.INTERNAL == from ) {
                    fis = context.openFileInput( name );
                    fos = new FileOutputStream( file );
                } else {
                    fis = new FileInputStream( file );
                    fos = context.openFileOutput( name, Context.MODE_PRIVATE );
                }

                channelIn = fis.getChannel();
                channelOut = fos.getChannel();

                channelIn.transferTo( 0, channelIn.size(), channelOut );
                success = true;

            } catch ( java.io.FileNotFoundException fnfe ) {
                Utils.logf( ""%s"", fnfe.toString() );
            } catch ( java.io.IOException ioe ) {
                Utils.logf( ""%s"", ioe.toString() );
            } finally {
                try {
                    // Order should match assignment order to above in
                    // case one or both null
                    channelIn.close();
                    channelOut.close();
                } catch ( Exception e ) {
                    Utils.logf( ""%s"", e.toString() );
                }
            }
        }
        return success;
    } // copyDict

    public static void deleteDict( Context context, String name, DictLoc loc )
    {
        name = addDictExtn( name );
        if ( DictLoc.EXTERNAL == loc ) {
            File onSD = getSDPathFor( context, name );
            if ( null != onSD ) {
                onSD.delete();
            } // otherwise what?
        } else {
            Assert.assertTrue( DictLoc.INTERNAL == loc );
            context.deleteFile( name );
        }
        invalDictList();
    }

    public static void deleteDict( Context context, String name )
    {
        deleteDict( context, name, getDictLoc( context, name ) );
    }

    private static byte[] openDict( Context context, String name, DictLoc loc )
    {
        byte[] bytes = null;

        name = addDictExtn( name );

        if ( loc == DictLoc.UNKNOWN || loc == DictLoc.BUILT_IN ) {
            try {
                AssetManager am = context.getAssets();
                InputStream dict = am.open( name, android.content.res.
                                            AssetManager.ACCESS_RANDOM );

                int len = dict.available(); // this may not be the
                                            // full length!
                bytes = new byte[len];
                int nRead = dict.read( bytes, 0, len );
                if ( nRead != len ) {
                    Utils.logf( ""**** warning ****; read only %d of %d bytes."",
                                nRead, len );
                }
                // check that with len bytes we've read the whole file
                Assert.assertTrue( -1 == dict.read() );
            } catch ( java.io.IOException ee ){
                Utils.logf( ""%s failed to open; likely not built-in"", name );
            }
        }

        // not an asset?  Try external and internal storage
        if ( null == bytes ) {
            try {
                FileInputStream fis = null;
                if ( loc == DictLoc.UNKNOWN || loc == DictLoc.EXTERNAL ) {
                    File sdFile = getSDPathFor( context, name );
                    if ( null != sdFile && sdFile.exists() ) {
                        Utils.logf( ""loading %s from SD"", name );
                        fis = new FileInputStream( sdFile );
                    }
                }
                if ( null == fis ) {
                    if ( loc == DictLoc.UNKNOWN || loc == DictLoc.INTERNAL ) {
                        Utils.logf( ""loading %s from private storage"", name );
                        fis = context.openFileInput( name );
                    }
                }
                int len = (int)fis.getChannel().size();
                bytes = new byte[len];
                fis.read( bytes, 0, len );
                fis.close();
                Utils.logf( ""Successfully loaded %s"", name );
            } catch ( java.io.FileNotFoundException fnf ) {
                Utils.logf( fnf.toString() );
            } catch ( java.io.IOException ioe ) {
                Utils.logf( ioe.toString() );
            }
        }
        
        return bytes;
    } // openDict

    private static byte[] openDict( Context context, String name )
    {
        return openDict( context, name, DictLoc.UNKNOWN );
    }

    private static String getDictPath( Context context, String name )
    {
        name = addDictExtn( name );

        File file = context.getFileStreamPath( name );
        if ( !file.exists() ) {
            file = getSDPathFor( context, name );
            if ( null != file && !file.exists() ) {
                file = null;
            }
        }
        String path = null == file? null : file.getPath();
        return path;
    }

    private static File getDictFile( Context context, String name, DictLoc to )
    {
        File path;
        switch ( to ) {
        case EXTERNAL:
            path = getSDPathFor( context, name );
            break;
        case INTERNAL:
            path = context.getFileStreamPath( name );
            break;
        default:
            Assert.fail();
            path = null;
        }
        return path;
    }

    public static DictPairs openDicts( Context context, String[] names )
    {
        byte[][] dictBytes = new byte[names.length][];
        String[] dictPaths = new String[names.length];

        HashMap<String,byte[]> seen = new HashMap<String,byte[]>();
        for ( int ii = 0; ii < names.length; ++ii ) {
            byte[] bytes = null;
            String path = null;
            String name = names[ii];
            if ( null != name ) {
                path = getDictPath( context, name );
                if ( null == path ) {
                    bytes = seen.get( name );
                    if ( null == bytes ) {
                        bytes = openDict( context, name );
                        seen.put( name, bytes );
                    }
                }
            }
            dictBytes[ii] = bytes;
            dictPaths[ii] = path;
        }
        return new DictPairs( dictBytes, dictPaths );
    }

    public static boolean saveDict( Context context, InputStream in,
                                    String name, DictLoc loc )
    {
        boolean success = false;
        File sdFile = null;
        boolean useSD = DictLoc.EXTERNAL == loc;
        if ( useSD ) {
            sdFile = getSDPathFor( context, name );
        }

        if ( null != sdFile || !useSD ) {
            try {
                FileOutputStream fos;
                if ( null != sdFile ) {
                    fos = new FileOutputStream( sdFile );
                } else {
                    fos = context.openFileOutput( name, Context.MODE_PRIVATE );
                }
                byte[] buf = new byte[1024];
                int nRead;
                while( 0 <= (nRead = in.read( buf, 0, buf.length )) ) {
                    fos.write( buf, 0, nRead );
                }
                fos.close();
                invalDictList();
                success = true;
            } catch ( java.io.FileNotFoundException fnf ) {
                Utils.logf( ""saveDict: FileNotFoundException: %s"", 
                            fnf.toString() );
            } catch ( java.io.IOException ioe ) {
                Utils.logf( ""saveDict: IOException: %s"", ioe.toString() );
                deleteDict( context, name );
            }
        }
        return success;
    } 

    private static boolean isGame( String file )
    {
        return file.endsWith( XWConstants.GAME_EXTN );
    }
 
    private static boolean isDict( String file )
    {
        return file.endsWith( XWConstants.DICT_EXTN );
    }

    public static String removeDictExtn( String str )
    {
        if ( str.endsWith( XWConstants.DICT_EXTN ) ) {
            int indx = str.lastIndexOf( XWConstants.DICT_EXTN );
            str = str.substring( 0, indx );
        }
        return str;
    }

    private static String addDictExtn( String str ) 
    {
        if ( ! str.endsWith( XWConstants.DICT_EXTN ) ) {
            str += XWConstants.DICT_EXTN;
        }
        return str;
    }

    private static String[] getAssets( Context context )
    {
        try {
            AssetManager am = context.getAssets();
            return am.list("""");
        } catch( java.io.IOException ioe ) {
            Utils.logf( ioe.toString() );
            return new String[0];
        }
    }
    
    public static boolean haveWriteableSD()
    {
        String state = Environment.getExternalStorageState();

        return state.equals( Environment.MEDIA_MOUNTED );
        // want this later? Environment.MEDIA_MOUNTED_READ_ONLY
    }

    private static File getSDDir( Context context )
    {
        File result = null;
        if ( haveWriteableSD() ) {
            File storage = Environment.getExternalStorageDirectory();
            if ( null != storage ) {
                String packdir = String.format( ""Android/data/%s/files/"",
                                                context.getPackageName() );
                result = new File( storage.getPath(), packdir );
                if ( !result.exists() ) {
                    result.mkdirs();
                    if ( !result.exists() ) {
                        Utils.logf( ""unable to create sd dir %s"", packdir );
                        result = null;
                    }
                }
            }
        }
        return result;
    }

    private static File getSDPathFor( Context context, String name )
    {
        File result = null;
        File dir = getSDDir( context );
        if ( dir != null ) {
            result = new File( dir, name );
        }
        return result;
    }
}
",True,50,42,2,3,8,7,8,4,L1
4,org.eehouse.android.xw4.PrefsActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;
import android.preference.PreferenceActivity;
import android.app.Dialog;
import android.app.AlertDialog;
import android.content.Intent;
import android.content.DialogInterface;
import android.os.Bundle;
import android.content.SharedPreferences;
import android.preference.Preference;
import android.preference.PreferenceManager;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MenuInflater;
import java.util.HashSet;

public class PrefsActivity extends PreferenceActivity 
    implements SharedPreferences.OnSharedPreferenceChangeListener {

    private static final int REVERT_COLORS = 1;
    private static final int REVERT_ALL = 2;

    private String m_keyLogging;

    @Override
    protected Dialog onCreateDialog( int id )
    {
        DialogInterface.OnClickListener lstnr = null;
        int confirmID = 0;

        switch( id ) {
        case REVERT_COLORS:
            confirmID = R.string.confirm_revert_colors;
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        SharedPreferences sp =
                            getPreferenceScreen().getSharedPreferences();
                        SharedPreferences.Editor editor = sp.edit();
                        int[] colorKeys = {
                            R.string.key_player0,
                            R.string.key_player1,
                            R.string.key_player2,
                            R.string.key_player3,
                            R.string.key_bonus_l2x,
                            R.string.key_bonus_l3x,
                            R.string.key_bonus_w2x,
                            R.string.key_bonus_w3x,
                            R.string.key_tile_back,
                            R.string.key_clr_crosshairs,
                            R.string.key_empty,
                            R.string.key_background,
                            R.string.key_clr_bonushint,
                        };
                        for ( int colorKey : colorKeys ) {
                            editor.remove( getString(colorKey) );
                        }
                        editor.commit();
                        relaunch();
                    }
                };
            break;
        case REVERT_ALL:
            confirmID = R.string.confirm_revert_all;
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        SharedPreferences sp =
                            getPreferenceScreen().getSharedPreferences();
                        SharedPreferences.Editor editor = sp.edit();
                        editor.clear();
                        editor.commit();
                        relaunch();
                    }
                };
            break;
        }

        Dialog dialog = null;
        if ( null != lstnr ) {
            dialog = new AlertDialog.Builder( this )
                .setTitle( R.string.query_title )
                .setMessage( confirmID )
                .setPositiveButton( R.string.button_ok, lstnr )
                .setNegativeButton( R.string.button_cancel, null )
                .create();
        }
        return dialog;
    }

    @Override
    protected void onCreate( Bundle savedInstanceState )
    {
        super.onCreate(savedInstanceState);

        // Load the preferences from an XML resource
        addPreferencesFromResource( R.xml.xwprefs );

        m_keyLogging = getString( R.string.key_logging_on );
    }
    
    @Override
    protected void onResume() 
    {
        super.onResume();
        getPreferenceScreen().getSharedPreferences().
            registerOnSharedPreferenceChangeListener(this);   
   }

    @Override
    protected void onPause() 
    {
        super.onPause();
        getPreferenceScreen().getSharedPreferences().
            unregisterOnSharedPreferenceChangeListener(this);
    }

    public void onSharedPreferenceChanged( SharedPreferences sp, String key ) 
    {
        if ( key.equals( m_keyLogging ) ) {
            Utils.logEnable( sp.getBoolean( key, false ) );
        }
    }

    @Override
    public boolean onCreateOptionsMenu( Menu menu )
    {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.prefs_menu, menu );
        return true;
    }

    @Override
    public boolean onOptionsItemSelected( MenuItem item )
    {
        int dlgID = 0;
        switch ( item.getItemId() ) {
        case R.id.menu_revert_all:
            dlgID = REVERT_ALL;
            break;
        case R.id.menu_revert_colors:
            dlgID = REVERT_COLORS;
            break;
        }

        boolean handled = 0 != dlgID;
        if ( handled ) {
            showDialog( dlgID );
        }
        return handled;
    }

    private void relaunch()
    {
        PreferenceManager.setDefaultValues( this, R.xml.xwprefs,
                                            false );

        // Now replace this activity with a new copy
        // so the new values get loaded.
        startActivity( new Intent( this, PrefsActivity.class ) );
        finish();
    }

}
",False,52,1,0,0,0,0,0,0,I0
5,org.eehouse.android.xw4.GameUtils.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Environment;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Arrays;
import android.content.res.AssetManager;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.concurrent.locks.Lock;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Random;
import android.text.Html;

import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class GameUtils {

    public static final String INVITED = ""invited"";

    // Implements read-locks and write-locks per game.  A read lock is
    // obtainable when other read locks are granted but not when a
    // write lock is.  Write-locks are exclusive.
    public static class GameLock {
        private long m_rowid;
        private boolean m_isForWrite;
        private int m_lockCount;
        // StackTraceElement[] m_lockTrace;

        // This will leak empty ReentrantReadWriteLock instances for
        // now.
        private static HashMap<Long, GameLock> 
            s_locks = new HashMap<Long,GameLock>();

        public GameLock( long rowid, boolean isForWrite ) 
        {
            m_rowid = rowid;
            m_isForWrite = isForWrite;
            m_lockCount = 0;
            // Utils.logf( ""GameLock.GameLock(%s,%s) done"", m_path, 
            //             m_isForWrite?""T"":""F"" );
        }

        // This could be written to allow multiple read locks.  Let's
        // see if not doing that causes problems.
        public boolean tryLock()
        {
            boolean gotIt = false;
            synchronized( s_locks ) {
                GameLock owner = s_locks.get( m_rowid );
                if ( null == owner ) { // unowned
                    Assert.assertTrue( 0 == m_lockCount );
                    s_locks.put( m_rowid, this );
                    ++m_lockCount;
                    gotIt = true;
                    
                    // StackTraceElement[] trace = Thread.currentThread().
                    //     getStackTrace();
                    // m_lockTrace = new StackTraceElement[trace.length];
                    // System.arraycopy( trace, 0, m_lockTrace, 0, trace.length );
                } else if ( this == owner && ! m_isForWrite ) {
                    Assert.assertTrue( 0 == m_lockCount );
                    ++m_lockCount;
                    gotIt = true;
                }
            }
            return gotIt;
        }
        
        public GameLock lock()
        {
            long stopTime = System.currentTimeMillis() + 1000;
            // Utils.logf( ""GameLock.lock(%s)"", m_path );
            // Utils.printStack();
            for ( ; ; ) {
                if ( tryLock() ) {
                    break;
                }
                // Utils.logf( ""GameLock.lock() failed; sleeping"" );
                // Utils.printStack();
                try {
                    Thread.sleep( 25 ); // milliseconds
                } catch( InterruptedException ie ) {
                    Utils.logf( ""GameLock.lock(): %s"", ie.toString() );
                    break;
                }
                if ( System.currentTimeMillis() >= stopTime ) {
                    // Utils.printStack( m_lockTrace );
                    Assert.fail();
                }
            }
            // Utils.logf( ""GameLock.lock(%s) done"", m_path );
            return this;
        }

        public void unlock()
        {
            // Utils.logf( ""GameLock.unlock(%s)"", m_path );
            synchronized( s_locks ) {
                Assert.assertTrue( this == s_locks.get(m_rowid) );
                if ( 1 == m_lockCount ) {
                    s_locks.remove( m_rowid );
                } else {
                    Assert.assertTrue( !m_isForWrite );
                }
                --m_lockCount;
            }
            // Utils.logf( ""GameLock.unlock(%s) done"", m_path );
        }

        public long getRowid() 
        {
            return m_rowid;
        }

        // used only for asserts
        public boolean canWrite()
        {
            return m_isForWrite && 1 == m_lockCount;
        }
    }

    private static Object s_syncObj = new Object();

    public static byte[] savedGame( Context context, long rowid )
    {
        GameLock lock = new GameLock( rowid, false ).lock();
        byte[] result = savedGame( context, lock );
        lock.unlock();
        return result;
    }

    public static byte[] savedGame( Context context, GameLock lock )
    {
        return DBUtils.loadGame( context, lock );
    } // savedGame

    /**
     * Open an existing game, and use its gi and comms addr as the
     * basis for a new one.
     */
    public static GameLock resetGame( Context context, GameLock lockSrc, 
                                      GameLock lockDest )
    {
        CurGameInfo gi = new CurGameInfo( context );
        CommsAddrRec addr = null;

        // loadMakeGame, if makinga new game, will add comms as long
        // as DeviceRole.SERVER_STANDALONE != gi.serverRole
        int gamePtr = loadMakeGame( context, gi, lockSrc );
        String[] dictNames = gi.dictNames();
        DictUtils.DictPairs pairs = DictUtils.openDicts( context, dictNames );
        
        if ( XwJNI.game_hasComms( gamePtr ) ) {
            addr = new CommsAddrRec( context );
            XwJNI.comms_getAddr( gamePtr, addr );
            if ( CommsAddrRec.CommsConnType.COMMS_CONN_NONE == addr.conType ) {
                String relayName = CommonPrefs.getDefaultRelayHost( context );
                int relayPort = CommonPrefs.getDefaultRelayPort( context );
                XwJNI.comms_getInitialAddr( addr, relayName, relayPort );
            }
        }
        XwJNI.game_dispose( gamePtr );

        gamePtr = XwJNI.initJNI();
        XwJNI.game_makeNewGame( gamePtr, gi, JNIUtilsImpl.get(), 
                                CommonPrefs.get( context ), dictNames,
                                pairs.m_bytes,  pairs.m_paths, gi.langName() );
                                
        if ( null != addr ) {
            XwJNI.comms_setAddr( gamePtr, addr );
        }

	if ( null == lockDest ) {
	    long rowid = saveNewGame( context, gamePtr, gi );
	    lockDest = new GameLock( rowid, true ).lock();
	} else {
	    saveGame( context, gamePtr, gi, lockDest, true );
	}
	summarizeAndClose( context, lockDest, gamePtr, gi );

	return lockDest;
    } // resetGame

    public static void resetGame( Context context, long rowidIn )
    {
        GameLock lock = new GameLock( rowidIn, true ).lock();
        tellRelayDied( context, lock, true );
        resetGame( context, lock, lock );
        lock.unlock();
    }

    private static GameSummary summarizeAndClose( Context context, 
                                                  GameLock lock,
                                                  int gamePtr, CurGameInfo gi )
    {
        return summarizeAndClose( context, lock, gamePtr, gi, null );
    }

    private static GameSummary summarizeAndClose( Context context, 
                                                  GameLock lock,
                                                  int gamePtr, CurGameInfo gi,
                                                  FeedUtilsImpl feedImpl )
    {
        GameSummary summary = new GameSummary( context, gi );
        XwJNI.game_summarize( gamePtr, summary );

        if ( null != feedImpl ) {
            if ( feedImpl.m_gotChat ) {
                summary.pendingMsgLevel |= GameSummary.MSG_FLAGS_CHAT;
            } 
            if ( feedImpl.m_gotMsg ) {
                summary.pendingMsgLevel |= GameSummary.MSG_FLAGS_TURN;
            }
            if ( feedImpl.m_gameOver ) {
                summary.pendingMsgLevel |= GameSummary.MSG_FLAGS_GAMEOVER;
            }
        }

        DBUtils.saveSummary( context, lock, summary );

        XwJNI.game_dispose( gamePtr );
        return summary;
    }

    public static GameSummary summarize( Context context, GameLock lock )
    {
        CurGameInfo gi = new CurGameInfo( context );
        int gamePtr = loadMakeGame( context, gi, lock );

        return summarizeAndClose( context, lock, gamePtr, gi );
    }

    public static long dupeGame( Context context, long rowidIn )
    {
        GameLock lockSrc = new GameLock( rowidIn, false ).lock();
        GameLock lockDest = resetGame( context, lockSrc, null );
        long rowid = lockDest.getRowid();
        lockDest.unlock();
        lockSrc.unlock();
        return rowid;
    }

    public static void deleteGame( Context context, long rowid, 
                                   boolean informNow )
    {
        // does this need to be synchronized?
        GameLock lock = new GameLock( rowid, true );
        if ( lock.tryLock() ) {
            tellRelayDied( context, lock, informNow );
            DBUtils.deleteGame( context, lock );
            lock.unlock();
        }
    }

    public static String getName( Context context, long rowid )
    {
        String result = DBUtils.getName( context, rowid );
        if ( null == result || 0 == result.length() ) {
            String fmt = context.getString( R.string.gamef );
            result = String.format( fmt, rowid );
        }
        return result;
    }

    public static int loadMakeGame( Context context, CurGameInfo gi, 
                                    GameLock lock )
    {
        return loadMakeGame( context, gi, null, lock );
    }

    public static int loadMakeGame( Context context, CurGameInfo gi, 
                                    UtilCtxt util, GameLock lock )
    {
        int gamePtr = 0;

        byte[] stream = savedGame( context, lock );
        XwJNI.gi_from_stream( gi, stream );
        String[] dictNames = gi.dictNames();
        DictUtils.DictPairs pairs = DictUtils.openDicts( context, dictNames );
        if ( pairs.anyMissing( dictNames ) ) {
            Utils.logf( ""loadMakeGame() failing: dict unavailable"" );
        } else {
            gamePtr = XwJNI.initJNI();

            String langName = gi.langName();
            boolean madeGame = XwJNI.game_makeFromStream( gamePtr, stream, 
                                                          JNIUtilsImpl.get(), gi, 
                                                          dictNames, pairs.m_bytes, 
                                                          pairs.m_paths, langName,
                                                          util, 
                                                          CommonPrefs.get(context));
            if ( !madeGame ) {
                XwJNI.game_makeNewGame( gamePtr, gi, JNIUtilsImpl.get(), 
                                        CommonPrefs.get(context), dictNames,
                                        pairs.m_bytes, pairs.m_paths, langName );
            }
        }
        return gamePtr;
    }

    public static long saveGame( Context context, int gamePtr, 
                                 CurGameInfo gi, GameLock lock,
                                 boolean setCreate )
    {
        byte[] stream = XwJNI.game_saveToStream( gamePtr, gi );
        return saveGame( context, stream, lock, setCreate );
    }

    public static long saveNewGame( Context context, int gamePtr,
				    CurGameInfo gi )
    {
        byte[] stream = XwJNI.game_saveToStream( gamePtr, gi );
        GameLock lock = DBUtils.saveNewGame( context, stream );
        long rowid = lock.getRowid();
        lock.unlock();
        return rowid;
    }

    public static long saveGame( Context context, byte[] bytes, 
                                 GameLock lock, boolean setCreate )
    {
        return DBUtils.saveGame( context, lock, bytes, setCreate );
    }

    public static GameLock saveNewGame( Context context, byte[] bytes )
    {
        return DBUtils.saveNewGame( context, bytes );
    }

    public static long saveNew( Context context, CurGameInfo gi )
    {
        long rowid = -1;
        byte[] bytes = XwJNI.gi_to_stream( gi );
        if ( null != bytes ) {
            GameLock lock = DBUtils.saveNewGame( context, bytes );
            rowid = lock.getRowid();
            lock.unlock();
        }
        return rowid;
    }

    public static long makeNewNetGame( Context context, String room, 
                                        int[] lang, int nPlayersT, 
                                        int nPlayersH )
    {
        long rowid = -1;
        CommsAddrRec addr = new CommsAddrRec( context );
        addr.ip_relay_invite = room;

        CurGameInfo gi = new CurGameInfo( context, true );
        gi.setLang( lang[0] );
        lang[0] = gi.dictLang;
        gi.setNPlayers( nPlayersT, nPlayersH );
        gi.juggle();
        // Will need to add a setNPlayers() method to gi to make this
        // work
        Assert.assertTrue( gi.nPlayers == nPlayersT );
        rowid = saveNew( context, gi );

        GameLock lock = new GameLock( rowid, true ).lock();
        applyChanges( context, gi, addr, lock, false );
        lock.unlock();

        return rowid;
    }

    public static long makeNewNetGame( Context context, String room, 
				       int lang, int nPlayers )
    {
        int[] langarr = { lang };
        return makeNewNetGame( context, room, langarr, nPlayers, 1 );
    }

    public static long makeNewNetGame( Context context, NetLaunchInfo info )
    {
        return makeNewNetGame( context, info.room, info.lang, 
                               info.nPlayers );
    }

    public static void launchInviteActivity( Context context, 
                                             boolean choseText,
                                             String room, 
                                             int lang, int nPlayers )
    {
        Random random = new Random();
        Uri gameUri = NetLaunchInfo.makeLaunchUri( context, room,
                                                   lang, nPlayers );

        if ( null != gameUri ) {
            Intent intent = new Intent( Intent.ACTION_SEND );
            intent.setType( choseText? ""text/plain"" : ""text/html"");
            intent.putExtra( Intent.EXTRA_SUBJECT, 
                             context.getString( R.string.invite_subject ) );

            int fmtId = choseText? R.string.invite_txtf : R.string.invite_htmf;
            String format = context.getString( fmtId );
            String message = String.format( format, gameUri.toString() );
            intent.putExtra( Intent.EXTRA_TEXT, 
                             choseText ? message : Html.fromHtml(message) );

            String chooserMsg = context.getString( R.string.invite_chooser );
            context.startActivity( Intent.createChooser( intent, chooserMsg ) );
        }
    }

    public static String[] dictNames( Context context, long rowid,
                                      int[] missingLang ) 
    {
        byte[] stream = savedGame( context, rowid );
        CurGameInfo gi = new CurGameInfo( context );
        XwJNI.gi_from_stream( gi, stream );
        if ( null != missingLang ) {
            missingLang[0] = gi.dictLang;
        }
        return gi.dictNames();
    }

    public static String[] dictNames( Context context, long rowid ) 
    {
        return dictNames( context, rowid, null );
    }
    
    public static boolean gameDictsHere( Context context, long rowid )
    {
        return gameDictsHere( context, rowid, null, null );
    }

    // Return true if all dicts present.  Return list of those that
    // are not.
    public static boolean gameDictsHere( Context context, long rowid,
                                         String[][] missingNames, 
                                         int[] missingLang )
    {
        String[] dictNames = dictNames( context, rowid, missingLang );
        HashSet<String> missingSet;
        DictUtils.DictAndLoc[] installed = DictUtils.dictList( context );

        missingSet = new HashSet<String>( Arrays.asList( dictNames ) );
        missingSet.remove( null );
        for ( DictUtils.DictAndLoc dal : installed ) {
            missingSet.remove( dal.name );
        }
        boolean allHere = 0 == missingSet.size();
        if ( null != missingNames ) {
            missingNames[0] = 
                missingSet.toArray( new String[missingSet.size()] );
        }

        return allHere;
    }

    public static boolean gameDictsHere( Context context, int indx, 
                                         String[][] name, int[] lang )
    {
        long rowid = DBUtils.gamesList( context )[indx];
        return gameDictsHere( context, rowid, name, lang );
    }

    public static String newName( Context context ) 
    {
        return ""untitled"";
        // String name = null;
        // Integer num = 1;
        // int ii;
        // long[] rowids = DBUtils.gamesList( context );
        // String fmt = context.getString( R.string.gamef );

        // while ( name == null ) {
        //     name = String.format( fmt + XWConstants.GAME_EXTN, num );
        //     for ( ii = 0; ii < files.length; ++ii ) {
        //         if ( files[ii].equals(name) ) {
        //             ++num;
        //             name = null;
        //         }
        //     }
        // }
        // return name;
    }

    private static boolean isGame( String file )
    {
        return file.endsWith( XWConstants.GAME_EXTN );
    }

    public static void launchGame( Activity activity, long rowid,
                                   boolean invited )
    {
        Intent intent = new Intent( activity, BoardActivity.class );
        intent.setAction( Intent.ACTION_EDIT );
        intent.putExtra( BoardActivity.INTENT_KEY_ROWID, rowid );
        if ( invited ) {
            intent.putExtra( INVITED, true );
        }
        activity.startActivity( intent );
    }

    public static void launchGame( Activity activity, long rowid)
    {
        launchGame( activity, rowid, false );
    }

    public static void launchGameAndFinish( Activity activity, long rowid )
    {
        launchGame( activity, rowid );
        activity.finish();
    }

    private static class FeedUtilsImpl extends UtilCtxtImpl {
        private Context m_context;
        private long m_rowid;
        public boolean m_gotMsg;
        public boolean m_gotChat;
        public boolean m_gameOver;

        public FeedUtilsImpl( Context context, long rowid )
        {
            super( context );
            m_context = context;
            m_rowid = rowid;
            m_gotMsg = false;
            m_gameOver = false;
        }
        public void showChat( String msg )
        {
            DBUtils.appendChatHistory( m_context, m_rowid, msg, false );
            m_gotChat = true;
        }
        public void turnChanged()
        {
            m_gotMsg = true;
        }

        public void notifyGameOver()
        {
            m_gameOver = true;
        }
    }

    public static boolean feedMessages( Context context, String relayID,
                                        byte[][] msgs )
    {
        boolean draw = false;
        long rowid = DBUtils.getRowIDFor( context, relayID );
        if ( -1 != rowid ) {
            CurGameInfo gi = new CurGameInfo( context );
            FeedUtilsImpl feedImpl = new FeedUtilsImpl( context, rowid );
            GameLock lock = new GameLock( rowid, true );
            if ( lock.tryLock() ) {
                int gamePtr = loadMakeGame( context, gi, feedImpl, lock );

                for ( byte[] msg : msgs ) {
                    draw = XwJNI.game_receiveMessage( gamePtr, msg ) || draw;
                }

                // update gi to reflect changes due to messages
                XwJNI.game_getGi( gamePtr, gi );
                saveGame( context, gamePtr, gi, lock, false );
                summarizeAndClose( context, lock, gamePtr, gi, feedImpl );

                int flags = GameSummary.MSG_FLAGS_NONE;
                if ( feedImpl.m_gotChat ) {
                    flags |= GameSummary.MSG_FLAGS_CHAT;
                } 
                if ( feedImpl.m_gotMsg ) {
                    flags |= GameSummary.MSG_FLAGS_TURN;
                }
                if ( feedImpl.m_gameOver ) {
                    flags |= GameSummary.MSG_FLAGS_GAMEOVER;
                }
                if ( GameSummary.MSG_FLAGS_NONE != flags ) {
                    draw = true;
                    DBUtils.setMsgFlags( rowid, flags );
                }
                lock.unlock();
            }
        }
        Utils.logf( ""feedMessages=>%b"", draw );
        return draw;
    }

    // This *must* involve a reset if the language is changing!!!
    // Which isn't possible right now, so make sure the old and new
    // dict have the same langauge code.
    public static void replaceDicts( Context context, long rowid,
                                     String oldDict, String newDict )
    {
        GameLock lock = new GameLock( rowid, true ).lock();
        byte[] stream = savedGame( context, lock );
        CurGameInfo gi = new CurGameInfo( context );
        XwJNI.gi_from_stream( gi, stream );

        // first time required so dictNames() will work
        gi.replaceDicts( newDict );

        String[] dictNames = gi.dictNames();
        DictUtils.DictPairs pairs = DictUtils.openDicts( context, dictNames );
        
        int gamePtr = XwJNI.initJNI();
        XwJNI.game_makeFromStream( gamePtr, stream, JNIUtilsImpl.get(), gi,
                                   dictNames, pairs.m_bytes, pairs.m_paths,
                                   gi.langName(), CommonPrefs.get( context ) );
        // second time required as game_makeFromStream can overwrite
        gi.replaceDicts( newDict );

        saveGame( context, gamePtr, gi, lock, false );

        summarizeAndClose( context, lock, gamePtr, gi );

        lock.unlock();
    }

    public static void applyChanges( Context context, CurGameInfo gi, 
                                     CommsAddrRec car, GameLock lock,
                                     boolean forceNew )
    {
        // This should be a separate function, commitChanges() or
        // somesuch.  But: do we have a way to save changes to a gi
        // that don't reset the game, e.g. player name for standalone
        // games?
        String[] dictNames = gi.dictNames();
        DictUtils.DictPairs pairs = DictUtils.openDicts( context, dictNames );
        String langName = gi.langName();
        int gamePtr = XwJNI.initJNI();
        boolean madeGame = false;
        CommonPrefs cp = CommonPrefs.get( context );

        if ( forceNew ) {
            tellRelayDied( context, lock, true );
        } else {
            byte[] stream = savedGame( context, lock );
            // Will fail if there's nothing in the stream but a gi.
            madeGame = XwJNI.game_makeFromStream( gamePtr, stream, 
                                                  JNIUtilsImpl.get(),
                                                  new CurGameInfo(context), 
                                                  dictNames, pairs.m_bytes,
                                                  pairs.m_paths,
                                                  langName, cp );
        }

        if ( forceNew || !madeGame ) {
            XwJNI.game_makeNewGame( gamePtr, gi, JNIUtilsImpl.get(), 
                                    cp, dictNames, pairs.m_bytes, 
                                    pairs.m_paths, langName );
        }

        if ( null != car ) {
            XwJNI.comms_setAddr( gamePtr, car );
        }

        saveGame( context, gamePtr, gi, lock, false );

        GameSummary summary = new GameSummary( context, gi );
        XwJNI.game_summarize( gamePtr, summary );
        DBUtils.saveSummary( context, lock, summary );

        XwJNI.game_dispose( gamePtr );
    } // applyChanges

    public static void doConfig( Activity activity, long rowid, Class clazz )
    {
        Intent intent = new Intent( activity, clazz );
        intent.setAction( Intent.ACTION_EDIT );
        intent.putExtra( BoardActivity.INTENT_KEY_ROWID, rowid );
        activity.startActivity( intent );
    }

    private static void tellRelayDied( Context context, GameLock lock,
                                       boolean informNow )
    {
        GameSummary summary = DBUtils.getSummary( context, lock );
        if ( null != summary.relayID ) {
            DBUtils.addDeceased( context, summary.relayID, summary.seed );
            if ( informNow ) {
                NetUtils.informOfDeaths( context );
            }
        }
    }


}
",True,1,43,1,6,3,15,10,15,L1
6,org.eehouse.android.xw4.MountEventReceiver.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import java.util.HashSet;
import java.util.Iterator;

public class MountEventReceiver extends BroadcastReceiver {

    public interface SDCardNotifiee {
        void cardMounted( boolean nowMounted );
    }

    private static HashSet<SDCardNotifiee> s_procs = new HashSet<SDCardNotifiee>();

    @Override
    public void onReceive( Context context, Intent intent )
    {
        Utils.logf( ""MountEventReceiver.onReceive(%s)"", intent.getAction() );
        synchronized( s_procs ) {
            do {
                if ( s_procs.isEmpty() ) {
                    break;
                }

                boolean mounted;
                String action = intent.getAction();
                if ( action.equals( Intent.ACTION_MEDIA_MOUNTED ) ) {
                    mounted = true;
                } else if ( action.equals( Intent.ACTION_MEDIA_EJECT ) ) {
                    mounted = false;
                } else {
                    break;
                }
                Iterator<SDCardNotifiee> iter = s_procs.iterator();
                while ( iter.hasNext() ) {
                    iter.next().cardMounted( mounted );
                }
            } while ( false );
        }
    }

    public static void register( SDCardNotifiee proc )
    {
        synchronized( s_procs ) {
            s_procs.add( proc );
        }
    }

    public static void unregister( SDCardNotifiee proc )
    {
        synchronized( s_procs ) {
            s_procs.remove( proc );
        }
    }
}
",False,23,37,4,21,1,1,2,1,L1
7,org.eehouse.android.xw4.CommsTransport.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.UnresolvedAddressException;
import java.nio.ByteBuffer;
import java.net.InetSocketAddress;
import java.util.Vector;
import java.util.Iterator;
import junit.framework.Assert;
import android.content.Context;
import android.os.Build;
import android.os.Handler;
import android.os.Message;

import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.JNIThread.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class CommsTransport implements TransportProcs, 
                                       NetStateCache.StateChangedIf {
    private Selector m_selector;
    private SocketChannel m_socketChannel;
    private int m_jniGamePtr;
    private CommsAddrRec m_addr;
    private JNIThread m_jniThread;
    private CommsThread m_thread;
    private TransportProcs.TPMsgHandler m_handler;
    private boolean m_done = false;

    private Vector<ByteBuffer> m_buffersOut;
    private ByteBuffer m_bytesOut;
    private ByteBuffer m_bytesIn;

    private Context m_context;

    // assembling inbound packet
    private byte[] m_packetIn;
    private int m_haveLen = -1;

    public CommsTransport( int jniGamePtr, Context context, 
                           TransportProcs.TPMsgHandler handler,
                           DeviceRole role )
    {
        m_jniGamePtr = jniGamePtr;
        m_context = context;
        m_handler = handler;
        m_buffersOut = new Vector<ByteBuffer>();
        m_bytesIn = ByteBuffer.allocate( 2048 );

        NetStateCache.register( context, this );
    }

    public class CommsThread extends Thread {

        @Override
        public void run()
        {
            m_done = false;
            boolean failed = true;
            try {   
                if ( Build.PRODUCT.contains(""sdk"") ) {
                    System.setProperty(""java.net.preferIPv6Addresses"", ""false"");
                }

                m_selector = Selector.open();

                failed = loop();

                closeSocket();
            } catch ( java.io.IOException ioe ) {
                Utils.logf( ioe.toString() );
            } catch ( UnresolvedAddressException uae ) {
                Utils.logf( ""bad address: name: %s; port: %s; exception: %s"",
                            m_addr.ip_relay_hostName, m_addr.ip_relay_port, 
                            uae.toString() );
            }

            m_thread = null;
            if ( failed ) {
                m_jniThread.handle( JNICmd.CMD_TRANSFAIL );
            }
        }

        private boolean loop()
        {
            boolean failed = false;
            outer_loop:
            while ( !m_done ) {
                try {
                    synchronized( this ) {

                        // if we have data and no socket, try to connect.
                        if ( null == m_socketChannel
                             && 0 < m_buffersOut.size() ) {
                            try {
                                m_socketChannel = SocketChannel.open();
                                m_socketChannel.configureBlocking( false );
                                Utils.logf( ""connecting to %s:%d"",
                                            m_addr.ip_relay_hostName, 
                                            m_addr.ip_relay_port );
                                InetSocketAddress isa = new 
                                    InetSocketAddress(m_addr.ip_relay_hostName,
                                                      m_addr.ip_relay_port );
                                m_socketChannel.connect( isa );
                            } catch ( java.io.IOException ioe ) {
                                Utils.logf( ioe.toString() );
                                failed = true;
                                break outer_loop;
                            }
                        }

                        if ( null != m_socketChannel ) {
                            int ops = figureOps();
                            // Utils.logf( ""calling with ops=%x"", ops );
                            m_socketChannel.register( m_selector, ops );
                        }
                    }
                    m_selector.select();
                } catch ( ClosedChannelException cce ) {
                    // we get this when relay goes down.  Need to notify!
                    failed = true;
                    closeSocket();
                    Utils.logf( ""exiting: %s"", cce.toString() );
                    break;          // don't try again
                } catch ( java.io.IOException ioe ) {
                    closeSocket();
                    Utils.logf( ""exiting: %s"", ioe.toString() );
                    Utils.logf( ioe.toString() );
                } catch ( java.nio.channels.NoConnectionPendingException ncp ) {
                    Utils.logf( ""%s"", ncp.toString() );
                    closeSocket();
                    break;
                }

                Iterator<SelectionKey> iter = m_selector.selectedKeys().iterator();
                while ( iter.hasNext() ) {
                    SelectionKey key = (SelectionKey)iter.next();
                    SocketChannel channel = (SocketChannel)key.channel();
                    iter.remove();
                    try { 
                        if (key.isValid() && key.isConnectable()) {
                            if ( !channel.finishConnect() ) {
                                key.cancel(); 
                            }
                        }
                        if (key.isValid() && key.isReadable()) {
                            m_bytesIn.clear(); // will wipe any pending data!
                            // Utils.logf( ""socket is readable; buffer has space for ""
                            //             + m_bytesIn.remaining() );
                            int nRead = channel.read( m_bytesIn );
                            if ( nRead == -1 ) {
                                channel.close();
                            } else {
                                addIncoming();
                            }
                        }
                        if (key.isValid() && key.isWritable()) {
                            getOut();
                            if ( null != m_bytesOut ) {
                                int nWritten = channel.write( m_bytesOut );
                                //Utils.logf( ""wrote "" + nWritten + "" bytes"" );
                            }
                        }
                    } catch ( java.io.IOException ioe ) {
                        Utils.logf( ""%s: cancelling key"", ioe.toString() );
                        key.cancel(); 
                        failed = true;
                        break outer_loop;
                    } catch ( java.nio.channels.
                              NoConnectionPendingException ncp ) {
                        Utils.logf( ""%s"", ncp.toString() );
                        break outer_loop;
                    }
                }
            }
            return failed;
        } // loop
    }
    
    public void setReceiver( JNIThread jnit )
    {
        m_jniThread = jnit;
    }

    public void waitToStop()
    {
        waitToStopImpl();
        NetStateCache.unregister( m_context, this );
    }

    // NetStateCache.StateChangedIf interface
    public void netAvail( boolean nowAvailable )
    {
        if ( !nowAvailable ) {
            waitToStopImpl();
            m_jniThread.handle( JNICmd.CMD_TRANSFAIL );
        }
    }

    private synchronized void putOut( final byte[] buf )
    {
        int len = buf.length;
        ByteBuffer netbuf = ByteBuffer.allocate( len + 2 );
        netbuf.putShort( (short)len );
        netbuf.put( buf );
        m_buffersOut.add( netbuf );
        Assert.assertEquals( netbuf.remaining(), 0 );

        if ( null != m_selector ) {
            m_selector.wakeup();    // tell it it's got some writing to do
        }
    }

    private synchronized void closeSocket()
    {
        if ( null != m_socketChannel ) {
            try {
                m_socketChannel.close();
            } catch ( Exception e ) {
                Utils.logf( ""closing socket: %s"", e.toString() );
            }
            m_socketChannel = null;
        }
    }

    private synchronized void getOut()
    {
        if ( null != m_bytesOut && m_bytesOut.remaining() == 0 ) {
            m_bytesOut = null;
        }

        if ( null == m_bytesOut && m_buffersOut.size() > 0 ) {
            m_bytesOut = m_buffersOut.remove(0);
            m_bytesOut.flip();
        }
    }

    private synchronized int figureOps() {
        int ops;
        if ( null == m_socketChannel ) {
            ops = 0;
        } else if ( m_socketChannel.isConnected() ) {
            ops = SelectionKey.OP_READ;
            if ( (null != m_bytesOut && m_bytesOut.hasRemaining())
                 || m_buffersOut.size() > 0 ) {
                ops |= SelectionKey.OP_WRITE;
            }
        } else {
            ops = SelectionKey.OP_CONNECT;
        }
        return ops;
    }

    private void addIncoming( )
    {
        m_bytesIn.flip();
        
        for ( ; ; ) {
            int len = m_bytesIn.remaining();
            if ( len <= 0 ) {
                break;
            }

            if ( null == m_packetIn ) { // we're not mid-packet
                Assert.assertTrue( len > 1 ); // tell me if I see this case
                if ( len == 1 ) {       // half a length byte...
                    break;              // can I leave it in the buffer?
                } else {                
                    m_packetIn = new byte[m_bytesIn.getShort()];
                    m_haveLen = 0;
                }
            } else {                    // we're mid-packet
                int wantLen = m_packetIn.length - m_haveLen;
                if ( wantLen > len ) {
                    wantLen = len;
                }
                m_bytesIn.get( m_packetIn, m_haveLen, wantLen );
                m_haveLen += wantLen;
                if ( m_haveLen == m_packetIn.length ) {
                    // send completed packet
                    m_jniThread.handle( JNICmd.CMD_RECEIVE, m_packetIn );
                    m_packetIn = null;
                }
            }
        }
    }

    private void waitToStopImpl()
    {
        m_done = true;          // this is in a race!
        if ( null != m_selector ) {
            m_selector.wakeup();
        }
        if ( null != m_thread ) {     // synchronized this?  Or use Thread method
            try {
                m_thread.join(100);   // wait up to 1/10 second
            } catch ( java.lang.InterruptedException ie ) {
                Utils.logf( ""got InterruptedException: %s"", ie.toString() );
            }
            m_thread = null;
        }
    }

    // TransportProcs interface
    public int transportSend( byte[] buf, final CommsAddrRec faddr )
    {
        //Utils.logf( ""CommsTransport::transportSend(nbytes=%d)"", buf.length );
        int nSent = -1;

        if ( null == m_addr ) {
            if ( null == faddr ) {
                m_addr = new CommsAddrRec( m_context );
                XwJNI.comms_getAddr( m_jniGamePtr, m_addr );
            } else {
                m_addr = new CommsAddrRec( faddr );
            }
        }

        switch ( m_addr.conType ) {
        case COMMS_CONN_RELAY:
            if ( NetStateCache.netAvail( m_context ) ) {
                putOut( buf );      // add to queue
                if ( null == m_thread ) {
                    m_thread = new CommsThread();
                    m_thread.start();
                }
                nSent = buf.length;
            }
            break;
        case COMMS_CONN_SMS:
            Assert.fail();
            // This code can't be here, even if unreachable, unless
            // app has permission to use SMS.  So put it in a separate
            // module and catch the error that'll come when it fails
            // to verify.  IFF the plan's to ship a version that
            // doesn't do SMS.

            // Utils.logf( ""sending via sms to  %s:%d"", 
            //             m_addr.sms_phone, m_addr.sms_port );
            // try {
            //     Intent intent = new Intent( m_context, StatusReceiver.class);
            //     PendingIntent pi
            //         = PendingIntent.getBroadcast( m_context, 0,
            //                                       intent, 0 );
            //     if ( 0 == m_addr.sms_port ) {
            //          SmsManager.getDefault().sendTextMessage( m_addr.sms_phone,
            //                                                   null, ""Hello world"",
            //                                                   pi, pi );
            //         Utils.logf( ""called sendTextMessage"" );
            //     } else {
            //         SmsManager.getDefault().
            //             sendDataMessage( m_addr.sms_phone, (String)null,
            //                              (short)m_addr.sms_port, 
            //                              buf, pi, pi );
            //         Utils.logf( ""called sendDataMessage"" );
            //     }
            //     nSent = buf.length;
            // } catch ( java.lang.IllegalArgumentException iae ) {
            //     Utils.logf( iae.toString() );
            // }
            break;
        case COMMS_CONN_BT:
        default:
            Assert.fail();
            break;
        }

        // Keep this while debugging why the resend_all that gets
        // fired on reconnect doesn't unstall a game but a manual
        // resend does.
        Utils.logf( ""transportSend(%d)=>%d"", buf.length, nSent );
        return nSent;
    } 

    public void relayStatus( CommsRelayState newState )
    {
        //Utils.logf( ""relayStatus called; state=%s"", newState.toString() );
        if ( null != m_jniThread ) {
            m_jniThread.handle( JNICmd.CMD_DRAW_CONNS_STATUS, newState );
        } else {
            Utils.logf( ""can't draw status yet"" );
        }
    }

    public void relayConnd( String room, int devOrder, boolean allHere, 
                            int nMissing )
    {
        m_handler.tpmRelayConnd( room, devOrder, allHere, nMissing );
    }

    public void relayErrorProc( XWRELAY_ERROR relayErr )
    {
        m_handler.tpmRelayErrorProc( relayErr );
    }
}
",True,18,37,0,0,5,13,1,6,L1
8,org.eehouse.android.xw4.DBUtils.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.Cursor;
import java.util.StringTokenizer;
import android.content.ContentValues;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;

import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;


public class DBUtils {

    private static final String DICTS_SEP = "","";

    private static final String ROW_ID = ""rowid"";
    private static final String ROW_ID_FMT = ""rowid=%d"";

    private static long s_cachedRowID = -1;
    private static byte[] s_cachedBytes = null;

    public static interface DBChangeListener {
        public void gameSaved( long rowid );
    }
    private static HashSet<DBChangeListener> s_listeners = 
        new HashSet<DBChangeListener>();

    private static SQLiteOpenHelper s_dbHelper = null;

    public static class Obit {
        public Obit( String relayID, int seed ) {
            m_relayID = relayID; m_seed = seed;
        }
        String m_relayID;
        int m_seed;
    }

    public static class HistoryPair {
        private HistoryPair( String p_msg, boolean p_sourceLocal )
        {
            msg = p_msg;
            sourceLocal = p_sourceLocal;
        }
        String msg;
        boolean sourceLocal;
    }

    public static GameSummary getSummary( Context context, long rowid,
                                          boolean wait )
    {
        GameSummary result = null;
        GameUtils.GameLock lock = new GameUtils.GameLock( rowid, false );
        if ( wait ) {
            result = getSummary( context, lock.lock() );
            lock.unlock();
        } else if ( lock.tryLock() ) {
            result = getSummary( context, lock );
            lock.unlock();
        }
        return result;
    }

    public static GameSummary getSummary( Context context, 
                                          GameUtils.GameLock lock )
    {
        initDB( context );
        GameSummary summary = null;

        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String[] columns = { ROW_ID,
                                 DBHelper.NUM_MOVES, DBHelper.NUM_PLAYERS,
                                 DBHelper.MISSINGPLYRS,
                                 DBHelper.GAME_OVER, DBHelper.PLAYERS,
                                 DBHelper.TURN, DBHelper.GIFLAGS,
                                 DBHelper.CONTYPE, DBHelper.SERVERROLE,
                                 DBHelper.ROOMNAME, DBHelper.RELAYID, 
                                 DBHelper.SMSPHONE, DBHelper.SEED, 
                                 DBHelper.DICTLANG, 
                                 DBHelper.SCORES, DBHelper.HASMSGS,
                                 DBHelper.LASTPLAY_TIME
            };
            String selection = String.format( ROW_ID_FMT, lock.getRowid() );

            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );
            if ( 1 == cursor.getCount() && cursor.moveToFirst() ) {
                summary = new GameSummary( context );
                summary.nMoves = cursor.getInt(cursor.
                                               getColumnIndex(DBHelper.NUM_MOVES));
                summary.nPlayers = 
                    cursor.getInt(cursor.
                                  getColumnIndex(DBHelper.NUM_PLAYERS));
                summary.missingPlayers = 
                    cursor.getInt(cursor.
                                  getColumnIndex(DBHelper.MISSINGPLYRS));
                summary.
                    setPlayerSummary( cursor.
                                      getString( cursor.
                                                 getColumnIndex( DBHelper.
                                                                 PLAYERS ) ) );
                summary.turn = 
                    cursor.getInt(cursor.
                                  getColumnIndex(DBHelper.TURN));
                summary.
                    setGiFlags( cursor.getInt(cursor.
                                              getColumnIndex(DBHelper.GIFLAGS))
                                );

                String players = cursor.
                    getString(cursor.getColumnIndex( DBHelper.PLAYERS ));
                summary.readPlayers( players );

                summary.dictLang = 
                    cursor.getInt(cursor.
                                  getColumnIndex(DBHelper.DICTLANG));
                summary.modtime = 
                    cursor.getLong(cursor.
                                   getColumnIndex(DBHelper.LASTPLAY_TIME));
                int tmp = cursor.getInt(cursor.
                                        getColumnIndex(DBHelper.GAME_OVER));
                summary.gameOver = tmp == 0 ? false : true;

                String scoresStr = 
                    cursor.getString( cursor.getColumnIndex(DBHelper.SCORES));
                int[] scores = new int[summary.nPlayers];
                if ( null != scoresStr && scoresStr.length() > 0 ) {
                    StringTokenizer st = new StringTokenizer( scoresStr );
                    for ( int ii = 0; ii < scores.length; ++ii ) {
                        Assert.assertTrue( st.hasMoreTokens() );
                        String token = st.nextToken();
                        scores[ii] = Integer.parseInt( token );
                    }
                } else {
                    for ( int ii = 0; ii < scores.length; ++ii ) {
                        scores[ii] = 0;
                    }
                }
                summary.scores = scores;

                int col = cursor.getColumnIndex( DBHelper.CONTYPE );
                if ( col >= 0 ) {
                    tmp = cursor.getInt( col );
                    summary.conType = CommsAddrRec.CommsConnType.values()[tmp];
                    col = cursor.getColumnIndex( DBHelper.ROOMNAME );
                    if ( col >= 0 ) {
                        summary.roomName = cursor.getString( col );
                    }
                    col = cursor.getColumnIndex( DBHelper.RELAYID );
                    if ( col >= 0 ) {
                        summary.relayID = cursor.getString( col );
                    }
                    col = cursor.getColumnIndex( DBHelper.SEED );
                    if ( col >= 0 ) {
                        summary.seed = cursor.getInt( col );
                    }
                    col = cursor.getColumnIndex( DBHelper.SMSPHONE );
                    if ( col >= 0 ) {
                        summary.smsPhone = cursor.getString( col );
                    }
                }

                col = cursor.getColumnIndex( DBHelper.SERVERROLE );
                tmp = cursor.getInt( col );
                summary.serverRole = CurGameInfo.DeviceRole.values()[tmp];

                col = cursor.getColumnIndex( DBHelper.HASMSGS );
                if ( col >= 0 ) {
                    summary.pendingMsgLevel = cursor.getInt( col );
                }
            }
            cursor.close();
            db.close();
        }

        if ( null == summary ) {
            summary = GameUtils.summarize( context, lock );
            saveSummary( context, lock, summary );
        }
        return summary;
    } // getSummary

    public static void saveSummary( Context context, GameUtils.GameLock lock,
                                    GameSummary summary )
    {
        Assert.assertTrue( lock.canWrite() );
        long rowid = lock.getRowid();
        String selection = String.format( ROW_ID_FMT, rowid );

        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();

            if ( null == summary ) {
                db.delete( DBHelper.TABLE_NAME_SUM, selection, null );
            } else {
                ContentValues values = new ContentValues();
                values.put( DBHelper.NUM_MOVES, summary.nMoves );
                values.put( DBHelper.NUM_PLAYERS, summary.nPlayers );
                values.put( DBHelper.MISSINGPLYRS, summary.missingPlayers );
                values.put( DBHelper.TURN, summary.turn );
                values.put( DBHelper.GIFLAGS, summary.giflags() );
                values.put( DBHelper.PLAYERS, 
                            summary.summarizePlayers() );
                values.put( DBHelper.DICTLANG, summary.dictLang );
                values.put( DBHelper.GAME_OVER, summary.gameOver );
                values.put( DBHelper.DICTLIST, summary.dictNames(DICTS_SEP) );

                if ( null != summary.scores ) {
                    StringBuffer sb = new StringBuffer();
                    for ( int score : summary.scores ) {
                        sb.append( String.format( ""%d "", score ) );
                    }
                    values.put( DBHelper.SCORES, sb.toString() );
                }

                if ( null != summary.conType ) {
                    values.put( DBHelper.CONTYPE, summary.conType.ordinal() );
                    values.put( DBHelper.ROOMNAME, summary.roomName );
                    values.put( DBHelper.RELAYID, summary.relayID );
                    values.put( DBHelper.SEED, summary.seed );
                    values.put( DBHelper.SMSPHONE, summary.smsPhone );
                }
                values.put( DBHelper.SERVERROLE, summary.serverRole.ordinal() );

                long result = db.update( DBHelper.TABLE_NAME_SUM,
                                         values, selection, null );
                Assert.assertTrue( result >= 0 );
            }
            notifyListeners( rowid );
            db.close();
        }
    } // saveSummary

    public static int countGamesUsingLang( Context context, int lang )
    {
        int result = 0;
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String selection = String.format( ""%s = %d"", DBHelper.DICTLANG,
                                              lang );
            // null for columns will return whole rows: bad
            String[] columns = { DBHelper.DICTLANG };
            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );

            result = cursor.getCount();
            cursor.close();
            db.close();
        }
        return result;
    }

    public static int countGamesUsingDict( Context context, String dict )
    {
        int result = 0;
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String pattern = String.format( ""%%%s%s%s%%"", 
                                            DICTS_SEP, dict, DICTS_SEP );
            String selection = String.format( ""%s LIKE '%s'"", 
                                              DBHelper.DICTLIST, pattern );
            // null for columns will return whole rows: bad.  But
            // might as well make it an int for speed
            String[] columns = { DBHelper.DICTLANG }; 
            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );
            result = cursor.getCount();
            cursor.close();
            db.close();
        }
        return result;
    }

    private static void setInt( long rowid, String column, int value )
    {
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();

            String selection = String.format( ROW_ID_FMT, rowid );
            ContentValues values = new ContentValues();
            values.put( column, value );

            int result = db.update( DBHelper.TABLE_NAME_SUM, 
                                    values, selection, null );
            Assert.assertTrue( result == 1 );
            db.close();
        }
    }

    public static void setMsgFlags( long rowid, int flags )
    {
        setInt( rowid, DBHelper.HASMSGS, flags );
        notifyListeners( rowid );
    }

    public static void setExpanded( long rowid, boolean expanded )
    {
        setInt( rowid, DBHelper.CONTRACTED, expanded?0:1 );
    }

    private static int getInt( Context context, long rowid, String column,
                               int dflt )
    {
        int result = dflt;
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String selection = String.format( ROW_ID_FMT, rowid );
            String[] columns = { column };
            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );
            if ( 1 == cursor.getCount() && cursor.moveToFirst() ) {
                result =
                    cursor.getInt( cursor.getColumnIndex(column));
            }
            cursor.close();
            db.close();
        }
        return result;
    }

    public static int getMsgFlags( Context context, long rowid )
    {
        return getInt( context, rowid, DBHelper.HASMSGS, 
                       GameSummary.MSG_FLAGS_NONE );
    }

    public static boolean getExpanded( Context context, long rowid )
    {
        return 0 == getInt( context, rowid, DBHelper.CONTRACTED, 0 );
    }

    public static long getRowIDFor( Context context, String relayID )
    {
        long result = -1;
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String[] columns = { ROW_ID };
            String selection = DBHelper.RELAYID + ""='"" + relayID + ""'"";
            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );
            if ( 1 == cursor.getCount() && cursor.moveToFirst() ) {
                result = cursor.getLong( cursor.getColumnIndex(ROW_ID) );
            }
            cursor.close();
            db.close();
        }
        return result;
    }

    public static long getRowIDForOpen( Context context, String room,
                                         int lang, int nPlayers )
    {
        long result = -1;
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String[] columns = { ROW_ID };
            String selection = DBHelper.ROOMNAME + ""='"" + room + ""' AND ""
                // + DBHelper.INVITEID + ""='"" + inviteID + ""' AND ""
                + DBHelper.DICTLANG + ""="" + lang + "" AND ""
                + DBHelper.NUM_PLAYERS + ""="" + nPlayers;
            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );
            if ( 1 == cursor.getCount() && cursor.moveToFirst() ) {
                result = cursor.getLong( cursor.getColumnIndex(ROW_ID) );
            }
            cursor.close();
            db.close();
        }
        return result;
    }

    public static String[] getRelayIDs( Context context, boolean noMsgs ) 
    {
        String[] result = null;
        initDB( context );
        ArrayList<String> ids = new ArrayList<String>();

        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String[] columns = { DBHelper.RELAYID };
            String selection = DBHelper.RELAYID + "" NOT null"";
            if ( noMsgs ) {
                selection += "" AND NOT "" + DBHelper.HASMSGS;
            }

            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );

            if ( 0 < cursor.getCount() ) {
                cursor.moveToFirst();
                for ( ; ; ) {
                    ids.add( cursor.
                             getString( cursor.
                                        getColumnIndex(DBHelper.RELAYID)) );
                    if ( cursor.isLast() ) {
                        break;
                    }
                    cursor.moveToNext();
                }
            }
            cursor.close();
            db.close();
        }

        if ( 0 < ids.size() ) {
            result = ids.toArray( new String[ids.size()] );
        }
        return result;
    }

    public static void addDeceased( Context context, String relayID, 
                                    int seed )
    {
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();

            ContentValues values = new ContentValues();
            values.put( DBHelper.RELAYID, relayID );
            values.put( DBHelper.SEED, seed );

            try {
                long result = db.replaceOrThrow( DBHelper.TABLE_NAME_OBITS,
                                                 """", values );
            } catch ( Exception ex ) {
                Utils.logf( ""ex: %s"", ex.toString() );
            }
            db.close();
        }
    }

    public static Obit[] listObits( Context context )
    {
        Obit[] result = null;
        ArrayList<Obit> al = new ArrayList<Obit>();

        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String[] columns = { DBHelper.RELAYID, DBHelper.SEED };
            Cursor cursor = db.query( DBHelper.TABLE_NAME_OBITS, columns, 
                                      null, null, null, null, null );
            if ( 0 < cursor.getCount() ) {
                cursor.moveToFirst();
                for ( ; ; ) {
                    int index = cursor.getColumnIndex( DBHelper.RELAYID );
                    String relayID = cursor.getString( index );
                    index = cursor.getColumnIndex( DBHelper.SEED );
                    int seed = cursor.getInt( index );
                    al.add( new Obit( relayID, seed ) );
                    if ( cursor.isLast() ) {
                        break;
                    }
                    cursor.moveToNext();
                }
            }
            cursor.close();
            db.close();
        }

        int siz = al.size();
        if ( siz > 0 ) {
            result = al.toArray( new Obit[siz] );
        }
        return result;
    }

    public static void clearObits( Context context, Obit[] obits )
    {
        String fmt = DBHelper.RELAYID + ""= \""%s\"" AND + "" 
            + DBHelper.SEED + "" = %d"";

        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();

            for ( Obit obit: obits ) {
                String selection = String.format( fmt, obit.m_relayID, 
                                                  obit.m_seed );
                db.delete( DBHelper.TABLE_NAME_OBITS, selection, null );
            }
            db.close();
        }
    }

    public static GameUtils.GameLock saveNewGame( Context context, byte[] bytes )
    {
        GameUtils.GameLock lock = null;

        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();

            ContentValues values = new ContentValues();
            values.put( DBHelper.SNAPSHOT, bytes );

            long timestamp = new Date().getTime();
            values.put( DBHelper.CREATE_TIME, timestamp );
            values.put( DBHelper.LASTPLAY_TIME, timestamp );

            long rowid = db.insert( DBHelper.TABLE_NAME_SUM, null, values );

            lock = new GameUtils.GameLock( rowid, true ).lock();

            notifyListeners( rowid );
        }

        return lock;
    }

    public static long saveGame( Context context, GameUtils.GameLock lock, 
                                 byte[] bytes, boolean setCreate )
    {
        Assert.assertTrue( lock.canWrite() );
        long rowid = lock.getRowid();
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();

            String selection = String.format( ROW_ID_FMT, rowid );
            ContentValues values = new ContentValues();
            values.put( DBHelper.SNAPSHOT, bytes );

            long timestamp = new Date().getTime();
            if ( setCreate ) {
                values.put( DBHelper.CREATE_TIME, timestamp );
            }
            values.put( DBHelper.LASTPLAY_TIME, timestamp );

            int result = db.update( DBHelper.TABLE_NAME_SUM, 
                                    values, selection, null );
            if ( 0 == result ) {
                Assert.fail();
                // values.put( DBHelper.FILE_NAME, path );
                // rowid = db.insert( DBHelper.TABLE_NAME_SUM, null, values );
                // Utils.logf( ""insert=>%d"", rowid );
                // Assert.assertTrue( row >= 0 );
            }
            db.close();
        }
        setCached( rowid, null ); // force reread

        if ( -1 != rowid ) {
            notifyListeners( rowid );
        }
        return rowid;
    }

    public static byte[] loadGame( Context context, GameUtils.GameLock lock )
    {
        long rowid = lock.getRowid();
        Assert.assertTrue( -1 != rowid );
        byte[] result = getCached( rowid );
        if ( null == result ) {
            initDB( context );
            synchronized( s_dbHelper ) {
                SQLiteDatabase db = s_dbHelper.getReadableDatabase();

                String[] columns = { DBHelper.SNAPSHOT };
                String selection = String.format( ROW_ID_FMT, rowid );
                Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                          selection, null, null, null, null );
                if ( 1 == cursor.getCount() && cursor.moveToFirst() ) {
                    result = cursor.getBlob( cursor
                                             .getColumnIndex(DBHelper.SNAPSHOT));
                }
                cursor.close();
                db.close();
            }
            setCached( rowid, result );
        }
        return result;
    }

    public static void deleteGame( Context context, GameUtils.GameLock lock )
    {
        Assert.assertTrue( lock.canWrite() );
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();
            String selection = String.format( ROW_ID_FMT, lock.getRowid() );
            db.delete( DBHelper.TABLE_NAME_SUM, selection, null );
            db.close();
        }
        notifyListeners( lock.getRowid() );
    }

    public static long[] gamesList( Context context )
    {
        long[] result = null;

        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();

            String[] columns = { ROW_ID };
            String orderBy = DBHelper.CREATE_TIME + "" DESC"";
            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      null, null, null, null, orderBy );
            int count = cursor.getCount();
            result = new long[count];
            if ( 0 < count ) {
                int index = cursor.getColumnIndex( ROW_ID );
                cursor.moveToFirst();
		
                for ( int ii = 0; ; ++ii ) {
                    result[ii] = cursor.getLong( index );
                    if ( cursor.isLast() ) {
                        break;
                    }
                    cursor.moveToNext();
                }
            }
            cursor.close();
            db.close();
        }

        return result;
    }

    // Get either the file name or game name, preferring the latter.
    public static String getName( Context context, long rowid )
    {
        String result = null;
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();

            String[] columns = { DBHelper.GAME_NAME };
            String selection = String.format( ROW_ID_FMT, rowid );
            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );
            if ( 1 == cursor.getCount() && cursor.moveToFirst() ) {
                result = cursor.getString( cursor
                                           .getColumnIndex(DBHelper.GAME_NAME));
            }
            cursor.close();
            db.close();
        }

        return result;
    }

    public static void setName( Context context, long rowid, String name )
    {
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();

            String selection = String.format( ROW_ID_FMT, rowid );
            ContentValues values = new ContentValues();
            values.put( DBHelper.GAME_NAME, name );

            int result = db.update( DBHelper.TABLE_NAME_SUM, 
                                    values, selection, null );
            db.close();
            if ( 0 == result ) {
                Utils.logf( ""setName(%d,%s) failed"", rowid, name );
            }
        }
    }

    public static HistoryPair[] getChatHistory( Context context, long rowid )
    {
        HistoryPair[] result = null;
        final String localPrefix = context.getString( R.string.chat_local_id );
        String history = getChatHistoryStr( context, rowid );
        if ( null != history ) {
            String[] msgs = history.split( ""\n"" );
            result = new HistoryPair[msgs.length];
            for ( int ii = 0; ii < result.length; ++ii ) {
                String msg = msgs[ii];
                boolean isLocal = msg.startsWith( localPrefix );
                result[ii] = new HistoryPair( msg, isLocal );
            }
        }
        return result;
    }

    private static String getChatHistoryStr( Context context, long rowid )
    {
        String result = null;
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();

            String[] columns = { DBHelper.CHAT_HISTORY };
            String selection = String.format( ROW_ID_FMT, rowid );
            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );
            if ( 1 == cursor.getCount() && cursor.moveToFirst() ) {
                result = 
                    cursor.getString( cursor
                                      .getColumnIndex(DBHelper.CHAT_HISTORY));
            }
            cursor.close();
            db.close();
        }
        return result;
    }

    public static void appendChatHistory( Context context, long rowid,
                                          String msg, boolean local )
    {
        Assert.assertNotNull( msg );
        int id = local ? R.string.chat_local_id : R.string.chat_other_id;
        msg = context.getString( id ) + msg;

        String cur = getChatHistoryStr( context, rowid );
        if ( null != cur ) {
            msg = cur + ""\n"" + msg;
        }

        saveChatHistory( context, rowid, msg );
    } // appendChatHistory

    public static void clearChatHistory( Context context, long rowid )
    {
        saveChatHistory( context, rowid, null );
    }

    public static void setDBChangeListener( DBChangeListener listener )
    {
        synchronized( s_listeners ) {
            Assert.assertNotNull( listener );
            s_listeners.add( listener );
        }
    }

    public static void clearDBChangeListener( DBChangeListener listener )
    {
        synchronized( s_listeners ) {
            Assert.assertTrue( s_listeners.contains( listener ) );
            s_listeners.remove( listener );
        }
    }

    // Chat is independent of the GameLock mechanism because it's not
    // touching the SNAPSHOT column.
    private static void saveChatHistory( Context context, long rowid,
                                         String history )
    {
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();

            String selection = String.format( ROW_ID_FMT, rowid );
            ContentValues values = new ContentValues();
            if ( null != history ) {
                values.put( DBHelper.CHAT_HISTORY, history );
            } else {
                values.putNull( DBHelper.CHAT_HISTORY );
            }

            long timestamp = new Date().getTime();
            values.put( DBHelper.LASTPLAY_TIME, timestamp );

            int result = db.update( DBHelper.TABLE_NAME_SUM, 
                                    values, selection, null );
            db.close();
        }
    }

    private static void initDB( Context context )
    {
        if ( null == s_dbHelper ) {
            s_dbHelper = new DBHelper( context );
        }
    }

    private static void notifyListeners( long rowid )
    {
        synchronized( s_listeners ) {
            Iterator<DBChangeListener> iter = s_listeners.iterator();
            while ( iter.hasNext() ) {
                iter.next().gameSaved( rowid );
            }
        }
    }

    // Trivial one-item cache.  Typically bytes are read three times
    // in a row, so this saves two DB accesses per game opened.  Could
    // use a HashMap, but then lots of half-K byte[] chunks would fail
    // to gc.  This is good enough.
    private static byte[] getCached( long rowid )
    {
        byte[] result = s_cachedRowID == rowid ? s_cachedBytes : null;
        return result;
    }

    private static void setCached( long rowid, byte[] bytes )
    {
        s_cachedRowID = rowid;
        s_cachedBytes = bytes;
    }

}
",True,21,42,2,4,4,12,9,6,L1
9,org.eehouse.android.xw4.BoardDims.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;


// Why does this have to be its own class...
public class BoardDims {
    public int width, height;       // of the bitmap
    public int left, top;
    public int scoreHt;
    public int boardHt;
    public int trayTop, trayHt;
    public int cellSize, maxCellSize;
    public int timerWidth;
}
",False,34,36,7,8,0,0,2,0,L1
10,org.eehouse.android.xw4.Utils.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.util.Log;
import java.lang.Thread;
import android.app.Activity;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.preference.PreferenceManager;
import android.widget.CheckBox;
import android.widget.Toast;
import android.widget.EditText;
import android.widget.TextView;
import android.view.LayoutInflater;
import android.view.View;
import android.text.format.Time;
import java.util.Formatter;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;

public class Utils {
    static final String TAG = ""XW4"";

    static final String DB_PATH = ""XW_GAMES"";

    static boolean s_doLog = true;

    private static Time s_time = new Time();

    private Utils() {}

    public static void logEnable( boolean enable )
    {
        s_doLog = enable;
    }

    public static void logEnable( Context context )
    {
        SharedPreferences sp
            = PreferenceManager.getDefaultSharedPreferences( context );
        String key = context.getString( R.string.key_logging_on );
        boolean on = sp.getBoolean( key, false );
        logEnable( on );
    }

    public static void logf( String msg ) 
    {
        if ( s_doLog ) {
            s_time.setToNow();
            String time = s_time.format(""[%H:%M:%S]"");
            long id = Thread.currentThread().getId();
            Log.d( TAG, time + ""-"" + id + ""-"" + msg );
        }
    } // logf

    public static void logf( String format, Object... args )
    {
        if ( s_doLog ) {
            Formatter formatter = new Formatter();
            logf( formatter.format( format, args ).toString() );
        }
    } // logf

    public static void showf( Context context, String format, Object... args )
    {
        Formatter formatter = new Formatter();
        String msg = formatter.format( format, args ).toString();
        Toast.makeText( context, msg, Toast.LENGTH_SHORT ).show();
    } // showf

    public static void printStack( StackTraceElement[] trace )
    {
        if ( s_doLog ) {
            for ( int ii = 0; ii < trace.length; ++ii ) {
                Utils.logf( ""ste %d: %s"", ii, trace[ii].toString() );
            }
        }
    }

    public static void printStack()
    {
        if ( s_doLog ) {
            printStack( Thread.currentThread().getStackTrace() );
        }
    }

    public static void notImpl( Context context ) 
    {
        CharSequence text = ""Feature coming soon"";
        Toast.makeText( context, text, Toast.LENGTH_SHORT).show();
    }

    public static void setRemoveOnDismiss( final Activity activity, 
                                           Dialog dialog, final int id )
    {
        dialog.setOnDismissListener( new DialogInterface.OnDismissListener() {
                public void onDismiss( DialogInterface di ) {
                    activity.removeDialog( id );
                }
            } );
    }

    public static View inflate( Context context, int layoutId )
    {
        LayoutInflater factory = LayoutInflater.from( context );
        return factory.inflate( layoutId, null );
    }

    public static void setChecked( Activity activity, int id, boolean value )
    {
        CheckBox cbx = (CheckBox)activity.findViewById( id );
        cbx.setChecked( value );
    }

    public static void setChecked( Dialog dialog, int id, boolean value )
    {
        CheckBox cbx = (CheckBox)dialog.findViewById( id );
        cbx.setChecked( value );
    }

    public static void setText( Dialog dialog, int id, String value )
    {
        EditText editText = (EditText)dialog.findViewById( id );
        if ( null != editText ) {
            editText.setText( value, TextView.BufferType.EDITABLE   );
        }
    }

    public static void setText( Activity activity, int id, String value )
    {
        EditText editText = (EditText)activity.findViewById( id );
        if ( null != editText ) {
            editText.setText( value, TextView.BufferType.EDITABLE   );
        }
    }

    public static void setInt( Dialog dialog, int id, int value )
    {
        String str = Integer.toString(value);
        setText( dialog, id, str );
    }

    public static void setInt( Activity activity, int id, int value )
    {
        String str = Integer.toString(value);
        setText( activity, id, str );
    }

    public static boolean getChecked( Activity activity, int id )
    {
        CheckBox cbx = (CheckBox)activity.findViewById( id );
        return cbx.isChecked();
    }

    public static boolean getChecked( Dialog dialog, int id )
    {
        CheckBox cbx = (CheckBox)dialog.findViewById( id );
        return cbx.isChecked();
    }

    public static String getText( Dialog dialog, int id )
    {
        EditText editText = (EditText)dialog.findViewById( id );
        return editText.getText().toString();
    }

    public static String getText( Activity activity, int id )
    {
        EditText editText = (EditText)activity.findViewById( id );
        return editText.getText().toString();
    }

    public static int getInt( Dialog dialog, int id )
    {
        String str = getText( dialog, id );
        try {
            return Integer.parseInt( str );
        } catch ( NumberFormatException nfe ) {
            return 0;
        }
    }

    public static int getInt( Activity activity, int id )
    {
        String str = getText( activity, id );
        try {
            return Integer.parseInt( str );
        } catch ( NumberFormatException nfe ) {
            return 0;
        }
    }
}
",True,22,45,2,31,0,0,31,0,L0
11,org.eehouse.android.xw4.XWApp.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 - 2011 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Application;

public class XWApp extends Application {

    @Override
    public void onCreate()
    {
        Utils.logEnable( this );
        Utils.logf( ""XWApp.onCreate(); svn_rev=%s"", getString(R.string.git_rev_gen) );
        super.onCreate();
    }
}
",False,10,2,0,0,1,1,0,1,L3
12,org.eehouse.android.xw4.DictListPreference.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.preference.ListPreference;
import android.content.Context;
import android.util.AttributeSet;

import junit.framework.Assert;

public class DictListPreference extends XWListPreference {

    public DictListPreference( Context context, AttributeSet attrs )
    {
        super( context, attrs );

        DictUtils.DictAndLoc[] dals = DictUtils.dictList( context  );
        String[] dictEntries = new String[dals.length];
        String[] values = new String[dals.length];
        for ( int ii = 0; ii < dals.length; ++ii ) {
            values[ii] = dals[ii].name;
            dictEntries[ii] = 
                DictLangCache.annotatedDictName( context, dals[ii] );
        }
        setEntries( dictEntries );
        setEntryValues( values );
    }
}
",False,25,39,0,0,7,8,0,3,L3
13,org.eehouse.android.xw4.XWListActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.ListActivity;
import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;

import junit.framework.Assert;

import org.eehouse.android.xw4.jni.CommonPrefs;

public class XWListActivity extends ListActivity 
    implements DlgDelegate.DlgClickNotify {

    private DlgDelegate m_delegate;

    @Override
    protected void onCreate( Bundle savedInstanceState ) 
    {
        Utils.logf( ""%s.onCreate(this=%H)"", getClass().getName(), this );
        super.onCreate( savedInstanceState );
        m_delegate = new DlgDelegate( this, this, savedInstanceState );
    }

    @Override
    protected void onStart()
    {
        Utils.logf( ""%s.onStart(this=%H)"", getClass().getName(), this );
        super.onStart();
        DispatchNotify.SetRunning( this );
    }

    @Override
    protected void onResume()
    {
        Utils.logf( ""%s.onResume(this=%H)"", getClass().getName(), this );
        super.onResume();
    }

    @Override
    protected void onPause()
    {
        Utils.logf( ""%s.onPause(this=%H)"", getClass().getName(), this );
        super.onPause();
    }

    @Override
    protected void onStop()
    {
        Utils.logf( ""%s.onStop(this=%H)"", getClass().getName(), this );
        DispatchNotify.ClearRunning( this );
        super.onStop();
    }

    @Override
    protected void onDestroy()
    {
        Utils.logf( ""%s.onDestroy(this=%H); isFinishing=%b"",
                    getClass().getName(), this, isFinishing() );
        super.onDestroy();
    }

    @Override
    protected void onSaveInstanceState( Bundle outState ) 
    {
        super.onSaveInstanceState( outState );
        m_delegate.onSaveInstanceState( outState );
    }

    @Override
    protected Dialog onCreateDialog( final int id )
    {
        Utils.logf( ""%s.onCreateDialog() called"", getClass().getName() );
        Dialog dialog = m_delegate.onCreateDialog( id );
        if ( null == dialog ) {
            dialog = super.onCreateDialog( id );
        }
        return dialog;
    }

    @Override
    protected void onPrepareDialog( int id, Dialog dialog )
    {
        super.onPrepareDialog( id, dialog );
        m_delegate.onPrepareDialog( id, dialog );
    }

    // It sucks that these must be duplicated here and XWActivity
    protected void showAboutDialog()
    {
        m_delegate.showAboutDialog();
    }

    protected void showNotAgainDlgThen( int msgID, int prefsKey,
                                        int action )
    {
        m_delegate.showNotAgainDlgThen( msgID, prefsKey, action );
    }

    protected void showNotAgainDlg( int msgID, int prefsKey )
    {
        m_delegate.showNotAgainDlgThen( msgID, prefsKey );
    }

    protected void showOKOnlyDialog( int msgID )
    {
        m_delegate.showOKOnlyDialog( msgID );
    }

    protected void showConfirmThen( String msg, int action )
    {
        m_delegate.showConfirmThen( msg, action );
    }

    protected void showConfirmThen( int msg, int action )
    {
        showConfirmThen( getString(msg), action );
    }

    protected void showConfirmThen( int msg, int posButton, int action )
    {
        m_delegate.showConfirmThen( getString(msg), posButton, action );
    }

    protected void doSyncMenuitem()
    {
        m_delegate.doSyncMenuitem();
    }

    // DlgDelegate.DlgClickNotify interface
    public void dlgButtonClicked( int id, int which )
    {
        Assert.fail();
    }

}
",False,19,39,1,1,6,8,1,4,L3
14,org.eehouse.android.xw4.XWListAdapter.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.ListActivity;
import android.widget.ListAdapter;
import android.content.Context;
import android.database.DataSetObserver;

/**
 * Let's see if we can implement a few of these methods just once.
 */
public abstract class XWListAdapter implements ListAdapter {
    private int m_count;

    public XWListAdapter( Context context, int count ) {
        m_count = count;
    }

    public boolean areAllItemsEnabled() { return true; }
    public boolean isEnabled( int position ) { return true; }
    public int getCount() { return m_count; }
    public long getItemId(int position) { return position; }
    public int getItemViewType(int position) { return 0; }
    public int getViewTypeCount() { return 1; }
    public boolean hasStableIds() { return true; }
    public boolean isEmpty() { return getCount() == 0; }
    public void registerDataSetObserver(DataSetObserver observer) {}
    public void unregisterDataSetObserver(DataSetObserver observer) {}
}",False,9,4,2,2,0,0,2,0,L2
15,org.eehouse.android.xw4.NBSReceiver.java,"// /* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
// /*
//  * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
//  * reserved.
//  *
//  * This program is free software; you can redistribute it and/or
//  * modify it under the terms of the GNU General Public License as
//  * published by the Free Software Foundation; either version 2 of the
//  * License, or (at your option) any later version.
//  *
//  * This program is distributed in the hope that it will be useful, but
//  * WITHOUT ANY WARRANTY; without even the implied warranty of
//  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  * General Public License for more details.
//  *
//  * You should have received a copy of the GNU General Public License
//  * along with this program; if not, write to the Free Software
//  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//  */

// package org.eehouse.android.xw4;

// import android.content.BroadcastReceiver;
// import android.content.Context;
// import android.content.Intent;

// import android.telephony.SmsManager;

// public class NBSReceiver extends BroadcastReceiver {

//     @Override
//     public void onReceive( Context context, Intent intent )
//     {
//         Utils.logf( ""NBSReceiver::onReceive(intent=%s)!!!!"",
//                     intent.toString() );
//     }

//     static void tryNBSMessage()
//     {
//         byte[] data = { 'a', 'b', 'c' };

//         SmsManager mgr = SmsManager.getDefault();

//         try {
//             mgr.sendDataMessage( ""123-456-7890"", null, (short)50009, 
//                                  data, null, null );
//             // PendingIntent sentIntent, 
//             // PendingIntent deliveryIntent );
//             Utils.logf( ""sendDataMessage finished"" );
//         } catch ( IllegalArgumentException iae ) {
//             Utils.logf( ""%s"", iae.toString() );
//         }
//     }
// }
",False,32,1,0,0,0,0,0,0,I0
16,org.eehouse.android.xw4.NetUtils.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import javax.net.SocketFactory;
import java.net.InetAddress;
import java.net.Socket;
import android.content.Context;

import java.io.InputStream;
import java.io.DataInputStream;
import java.io.OutputStream;
import java.io.DataOutputStream;
import java.util.ArrayList;

import org.eehouse.android.xw4.jni.CommonPrefs;

public class NetUtils {

    public static final byte PROTOCOL_VERSION = 0;
    // from xwrelay.h
    public static byte PRX_PUB_ROOMS = 1;
    public static byte PRX_HAS_MSGS = 2;
    public static byte PRX_DEVICE_GONE = 3;
    public static byte PRX_GET_MSGS = 4;
    
    public static Socket MakeProxySocket( Context context, 
                                          int timeoutMillis )
    {
        Socket socket = null;
        try {
            int port = CommonPrefs.getDefaultProxyPort( context );
            String host = CommonPrefs.getDefaultRelayHost( context );

            SocketFactory factory = SocketFactory.getDefault();
            InetAddress addr = InetAddress.getByName( host );
            socket = factory.createSocket( addr, port );
            socket.setSoTimeout( timeoutMillis );

        } catch ( java.net.UnknownHostException uhe ) {
            Utils.logf( uhe.toString() );
        } catch( java.io.IOException ioe ) {
            Utils.logf( ioe.toString() );
        }
        return socket;
    }

    private static class InformThread extends Thread {
        Context m_context;
        DBUtils.Obit[] m_obits;
        public InformThread( Context context, DBUtils.Obit[] obits )
        {
            m_context = context;
            m_obits = obits;
        }

        public void run() {
            Socket socket = MakeProxySocket( m_context, 10000 );
            if ( null != socket ) {
                int strLens = 0;
                for ( int ii = 0; ii < m_obits.length; ++ii ) {
                    strLens += m_obits[ii].m_relayID.length() + 1; // 1 for /n
                }

                try {
                    DataOutputStream outStream = 
                        new DataOutputStream( socket.getOutputStream() );
                    outStream.writeShort( 2 + 2 + (2*m_obits.length) + strLens );
                    outStream.writeByte( NetUtils.PROTOCOL_VERSION );
                    outStream.writeByte( NetUtils.PRX_DEVICE_GONE );
                    outStream.writeShort( m_obits.length );

                    for ( int ii = 0; ii < m_obits.length; ++ii ) {
                        outStream.writeShort( m_obits[ii].m_seed );
                        outStream.writeBytes( m_obits[ii].m_relayID );
                        outStream.write( '\n' );
                    }

                    outStream.flush();

                    DataInputStream dis = 
                        new DataInputStream( socket.getInputStream() );
                    short resLen = dis.readShort();
                    socket.close();

                    if ( resLen == 0 ) {
                        DBUtils.clearObits( m_context, m_obits );
                    }
                } catch ( java.io.IOException ioe ) {
                    Utils.logf( ioe.toString() );
                }
            }
        }
    }

    public static void informOfDeaths( Context context )
    {
        DBUtils.Obit[] obits = DBUtils.listObits( context );
        if ( null != obits && 0 < obits.length ) {
            InformThread thread = new InformThread( context, obits );
            thread.start();
        }
    }

    public static String[] QueryRelay( Context context )
    {
        String[] result = null;
        int[] nBytes = new int[1];
        String[] ids = collectIDs( context, nBytes );
        if ( null != ids && 0 < ids.length ) {
            try {
                Socket socket = MakeProxySocket( context, 8000 );
                DataOutputStream outStream = 
                    new DataOutputStream( socket.getOutputStream() );

                // total packet size
                outStream.writeShort( 2 + nBytes[0] + ids.length + 1 );

                outStream.writeByte( NetUtils.PROTOCOL_VERSION );
                outStream.writeByte( NetUtils.PRX_GET_MSGS );

                // number of ids
                outStream.writeShort( ids.length );

                for ( String id : ids ) {
                    outStream.writeBytes( id );
                    outStream.write( '\n' );
                }
                outStream.flush();

                DataInputStream dis = 
                    new DataInputStream(socket.getInputStream());
                short resLen = dis.readShort();
                short nameCount = dis.readShort();
                byte[][][] msgs = null;
                if ( nameCount == ids.length ) {
                    msgs = new byte[nameCount][][];
                    for ( int ii = 0; ii < nameCount; ++ii ) {
                        short countsThisGame = dis.readShort();
                        if ( countsThisGame > 0 ) {
                            msgs[ii] = new byte[countsThisGame][];
                            for ( int jj = 0; jj < countsThisGame; ++jj ) {
                                short len = dis.readShort();
                                if ( len > 0 ) {
                                    byte[] packet = new byte[len];
                                    dis.read( packet );
                                    msgs[ii][jj] = packet;
                                }
                            }
                        }
                    }
                }
                socket.close();

                if ( null != msgs ) {
                    ArrayList<String> idsWMsgs =
                        new ArrayList<String>( nameCount );
                    for ( int ii = 0; ii < nameCount; ++ii ) {
                        // if game has messages, open it and feed 'em
                        // to it.
                        if ( null != msgs[ii] ) {
                            if( GameUtils.feedMessages( context, ids[ii], 
                                                        msgs[ii] ) ) {
                                idsWMsgs.add( ids[ii] );
                            }
                        }
                    }
                    if ( 0 < idsWMsgs.size() ) {
                        ids = new String[idsWMsgs.size()];
                        result = idsWMsgs.toArray( ids );
                    }
                }

            } catch( java.net.UnknownHostException uhe ) {
                Utils.logf( uhe.toString() );
            } catch( java.io.IOException ioe ) {
                Utils.logf( ioe.toString() );
            } catch( NullPointerException npe ) {
                Utils.logf( npe.toString() );
            }
        }
        return result;
    } // QueryRelay

    private static String[] collectIDs( Context context, int[] nBytes )
    {
        String[] ids = DBUtils.getRelayIDs( context, false );
        int len = 0;
        if ( null != ids ) {
            for ( String id : ids ) {
                len += id.length();
            }
        }
        nBytes[0] = len;
        return ids;
    }
}
",True,45,41,2,3,4,13,4,3,L1
17,org.eehouse.android.xw4.DictsActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ExpandableListActivity;
import android.database.DataSetObserver;
import android.os.Bundle;
import android.os.Handler;
import android.widget.Button;
import android.widget.TextView;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.content.SharedPreferences;
import android.view.View;
import android.view.ViewGroup;
import android.view.ContextMenu;
import android.view.MenuItem;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.LayoutInflater;
import android.view.MenuInflater;
import android.widget.ExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.ExpandableListContextMenuInfo;
import android.widget.Toast;
import android.preference.PreferenceManager;
import android.net.Uri;
import java.util.HashMap;
import junit.framework.Assert;

import org.eehouse.android.xw4.DictUtils.DictAndLoc;
import org.eehouse.android.xw4.jni.XwJNI;
import org.eehouse.android.xw4.jni.JNIUtilsImpl;
import org.eehouse.android.xw4.jni.CommonPrefs;

public class DictsActivity extends ExpandableListActivity 
    implements View.OnClickListener, XWListItem.DeleteCallback,
               MountEventReceiver.SDCardNotifiee, DlgDelegate.DlgClickNotify {

    private static final String DICT_DOLAUNCH = ""do_launch"";
    private static final String DICT_LANG_EXTRA = ""use_lang"";
    private static final String DICT_NAME_EXTRA = ""use_dict"";
    private static final String PACKED_POSITION = ""packed_position"";
    private static final String DELETE_DICT = ""delete_dict"";
    private static final String NAME = ""name"";
    private static final String LANG = ""lang"";
    private static final String MOVEFROMLOC = ""movefromloc"";
    private static final String MOVETOLOC = ""movetoloc"";

    private static HashMap<String,Boolean> s_openStates =
        new HashMap<String,Boolean>();

    // For new callback alternative
    private static final int DELETE_DICT_ACTION = 1;

    private static final int PICK_STORAGE = DlgDelegate.DIALOG_LAST + 1;
    private static final int MOVE_DICT = DlgDelegate.DIALOG_LAST + 2;
    private static final int SET_DEFAULT = DlgDelegate.DIALOG_LAST + 3;
    private int m_lang = 0;
    private String[] m_langs;
    private String m_name = null;
    private String m_deleteDict = null;
    private String m_download;
    private ExpandableListView m_expView;
    private DlgDelegate m_delegate;
    private String[] m_locNames;
    private DictListAdapter m_adapter;

    private long m_packedPosition;
    private DictUtils.DictLoc m_moveFromLoc;
    private DictUtils.DictLoc m_moveToLoc;

    private LayoutInflater m_factory;

    private class DictListAdapter implements ExpandableListAdapter {
        private Context m_context;
        private XWListItem[][] m_cache;

        public DictListAdapter( Context context ) {
            m_context = context;
        }

        public boolean areAllItemsEnabled() { return false; }

        public Object getChild( int groupPosition, int childPosition )
        {
            return null;
        }

        public long getChildId( int groupPosition, int childPosition )
        {
            return childPosition;
        }

        public View getChildView( int groupPosition, int childPosition, 
                                  boolean isLastChild, View convertView, 
                                  ViewGroup parent)
        {
            return getChildView( groupPosition, childPosition );
        }

        private View getChildView( int groupPosition, int childPosition )
        {
            XWListItem view = null;
            if ( null != m_cache && null != m_cache[groupPosition] ) {
                view = m_cache[groupPosition][childPosition];
            }

            if ( null == view ) {
                view = (XWListItem)
                    m_factory.inflate( R.layout.list_item, null );

                int lang = (int)getGroupId( groupPosition );
                DictAndLoc[] dals = DictLangCache.getDALsHaveLang( m_context, 
                                                                   lang );

                if ( null != dals && childPosition < dals.length ) {
                    DictAndLoc dal;
                    dal = dals[childPosition];
                    view.setText( dal.name );

                    DictUtils.DictLoc loc = dal.loc;
                    view.setComment( m_locNames[loc.ordinal()] );
                    view.cache( loc );
                    if ( DictUtils.DictLoc.BUILT_IN != loc ) {
                        view.setDeleteCallback( DictsActivity.this );
                    }
                } else {
                    view.setText( m_download );
                }

                addToCache( groupPosition, childPosition, view );
            }
            return view;
        }

        public int getChildrenCount( int groupPosition )
        {
            int lang = (int)getGroupId( groupPosition );
            DictAndLoc[] dals = DictLangCache.getDALsHaveLang( m_context, lang );
            int result = 0; // 1;     // 1 for the download option
            if ( null != dals ) {
                result += dals.length;
            }
            return result;
        }

        public long getCombinedChildId( long groupId, long childId )
        {
            return groupId << 16 | childId;
        }

        public long getCombinedGroupId( long groupId )
        {
            return groupId;
        }

        public Object getGroup( int groupPosition )
        {
            return null;
        }

        public int getGroupCount()
        {
            return m_langs.length;
        }

        public long getGroupId( int groupPosition )
        {
            int lang = DictLangCache.getLangLangCode( m_context, 
                                                      m_langs[groupPosition] );
            return lang;
        }

        public View getGroupView( int groupPosition, boolean isExpanded, 
                                  View convertView, ViewGroup parent )
        {
            View row = 
                Utils.inflate(DictsActivity.this, 
                              android.R.layout.simple_expandable_list_item_1 );
            TextView view = (TextView)row.findViewById( android.R.id.text1 );
            view.setText( m_langs[groupPosition] );
            return view;
        }

        public boolean hasStableIds() { return false; }
        public boolean isChildSelectable( int groupPosition, 
                                          int childPosition ) { return true; }
        public boolean isEmpty() { return false; }
        public void onGroupCollapsed(int groupPosition)
        {
            s_openStates.put( m_langs[groupPosition], false );
        }
        public void onGroupExpanded(int groupPosition){
            s_openStates.put( m_langs[groupPosition], true );
        }
        public void registerDataSetObserver( DataSetObserver obs ){}
        public void unregisterDataSetObserver( DataSetObserver obs ){}

        protected XWListItem getSelChildView()
        {
            int groupPosition = 
                ExpandableListView.getPackedPositionGroup( m_packedPosition );
            int childPosition = 
                ExpandableListView.getPackedPositionChild( m_packedPosition );
            return (XWListItem)getChildView( groupPosition, childPosition );
        }

        private void addToCache( int group, int child, XWListItem view )
        {
            if ( null == m_cache ) {
                m_cache = new XWListItem[getGroupCount()][];
            }
            if ( null == m_cache[group] ) {
                m_cache[group] = new XWListItem[getChildrenCount(group)];
            }
            Assert.assertTrue( null == m_cache[group][child] );
            m_cache[group][child] = view;
        }
    }

    @Override
    protected Dialog onCreateDialog( int id )
    {
        DialogInterface.OnClickListener lstnr;
        Dialog dialog;
        String format;
        String message;
        boolean doRemove = true;

        switch( id ) {
        case PICK_STORAGE:
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        startDownload( m_lang, m_name, item != 
                                       DialogInterface.BUTTON_POSITIVE );
                    }
                };

            dialog = new AlertDialog.Builder( this )
                .setTitle( R.string.storeWhereTitle )
                .setMessage( R.string.storeWhereMsg )
                .setPositiveButton( R.string.button_internal, lstnr )
                .setNegativeButton( R.string.button_sd, lstnr )
                .create();
            break;
        case MOVE_DICT:
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        XWListItem rowView = m_adapter.getSelChildView();
                        if ( DictUtils.moveDict( DictsActivity.this,
                                                 rowView.getText(),
                                                 m_moveFromLoc,
                                                 m_moveToLoc ) ) {
                            rowView.
                                setComment( m_locNames[m_moveToLoc.ordinal()]);
                            rowView.cache( m_moveToLoc );
                            rowView.invalidate();
                        } else {
                            Utils.logf( ""moveDict failed"" );
                        }
                    }
                };
            format = getString( R.string.move_dictf );
            message = String.format( format, 
                                     m_adapter.getSelChildView().getText(),
                                     m_locNames[ m_moveFromLoc.ordinal() ],
                                     m_locNames[ m_moveToLoc.ordinal() ] );

            dialog = new AlertDialog.Builder( this )
                .setMessage( message )
                .setPositiveButton( R.string.button_ok, lstnr )
                .setNegativeButton( R.string.button_cancel, null )
                .create();
            break;
        case SET_DEFAULT:
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        if ( DialogInterface.BUTTON_NEGATIVE == item
                             || DialogInterface.BUTTON_POSITIVE == item ) {
                            setDefault( R.string.key_default_dict );
                        }
                        if ( DialogInterface.BUTTON_NEGATIVE == item 
                             || DialogInterface.BUTTON_NEUTRAL == item ) {
                            setDefault( R.string.key_default_robodict );
                        }
                    }
                };
            XWListItem rowView = m_adapter.getSelChildView();
            String lang = 
                DictLangCache.getLangName( this, rowView.getText() );
            format = getString( R.string.set_default_messagef );
            message = String.format( format, lang );
            dialog = new AlertDialog.Builder( this )
                .setTitle( R.string.query_title )
                .setMessage( message )
                .setPositiveButton( R.string.button_default_human, lstnr )
                .setNeutralButton( R.string.button_default_robot, lstnr )
                .setNegativeButton( R.string.button_default_both, lstnr )
                .create();
            break;
        default:
            dialog = m_delegate.onCreateDialog( id );
            doRemove = false;
            break;
        }

        if ( doRemove && null != dialog ) {
            Utils.setRemoveOnDismiss( this, dialog, id );
        }

        return dialog;
    } // onCreateDialog

    @Override
    protected void onPrepareDialog( int id, Dialog dialog )
    {
        super.onPrepareDialog( id, dialog );
        m_delegate.onPrepareDialog( id, dialog );
    }

    @Override
    protected void onCreate( Bundle savedInstanceState ) 
    {
        super.onCreate( savedInstanceState );
        getBundledData( savedInstanceState );

        Resources res = getResources();
        m_locNames = res.getStringArray( R.array.loc_names );

        m_delegate = new DlgDelegate( this, this, savedInstanceState );
        m_factory = LayoutInflater.from( this );

        m_download = getString( R.string.download_dicts );
            
        setContentView( R.layout.dict_browse );
        m_expView = getExpandableListView();
        registerForContextMenu( m_expView );

        Button download = (Button)findViewById( R.id.download );
        download.setOnClickListener( this );

        mkListAdapter();

        // showNotAgainDlg( R.string.not_again_dicts, 
        //                  R.string.key_notagain_dicts );

        Intent intent = getIntent();
        if ( null != intent ) {
            boolean downloadNow = intent.getBooleanExtra( DICT_DOLAUNCH, false );
            if ( downloadNow ) {
                int lang = intent.getIntExtra( DICT_LANG_EXTRA, 0 );
                String name = intent.getStringExtra( DICT_NAME_EXTRA );
                askStartDownload( lang, name );
            }
        }
    }

    @Override
    protected void onResume()
    {
        super.onResume();
        MountEventReceiver.register( this );

        mkListAdapter();
        expandGroups();
    }

    @Override
    protected void onSaveInstanceState( Bundle outState ) 
    {
        super.onSaveInstanceState( outState );
        m_delegate.onSaveInstanceState( outState );

        outState.putLong( PACKED_POSITION, m_packedPosition );
        outState.putString( NAME, m_name );
        outState.putInt( LANG, m_lang );
        outState.putString( DELETE_DICT, m_deleteDict );
        if ( null != m_moveFromLoc ) {
            outState.putInt( MOVEFROMLOC, m_moveFromLoc.ordinal() );
        }
        if ( null != m_moveToLoc ) {
            outState.putInt( MOVETOLOC, m_moveToLoc.ordinal() );
        }
    }

    private void getBundledData( Bundle savedInstanceState )
    {
        if ( null != savedInstanceState ) {
            m_packedPosition = savedInstanceState.getLong( PACKED_POSITION );
            m_name = savedInstanceState.getString( NAME );
            m_lang = savedInstanceState.getInt( LANG );
            m_deleteDict = savedInstanceState.getString( DELETE_DICT );

            int tmp = savedInstanceState.getInt( MOVEFROMLOC, -1 );
            if ( -1 != tmp ) {
                m_moveFromLoc = DictUtils.DictLoc.values()[tmp];
            }
            tmp = savedInstanceState.getInt( MOVETOLOC, -1 );
            if ( -1 != tmp ) {
                m_moveToLoc = DictUtils.DictLoc.values()[tmp];
            }
        }
    }

    @Override
    protected void onStop() {
        MountEventReceiver.unregister( this );
        super.onStop();
    }

    public void onClick( View v ) 
    {
        askStartDownload( 0, null );
    }

    @Override
    public void onCreateContextMenu( ContextMenu menu, View view, 
                                     ContextMenuInfo menuInfo ) 
    {
        super.onCreateContextMenu( menu, view, menuInfo );

        ExpandableListView.ExpandableListContextMenuInfo info
            = (ExpandableListView.ExpandableListContextMenuInfo)menuInfo;
        long packedPosition = info.packedPosition;
        int childPosition = ExpandableListView.
            getPackedPositionChild( packedPosition );
        // int groupPosition = ExpandableListView.
        //     getPackedPositionGroup( packedPosition );
        // Utils.logf( ""onCreateContextMenu: group: %d; child: %d"", 
        //             groupPosition, childPosition );

        // We don't have a menu yet for languages, just for their dict
        // children
        if ( childPosition >= 0 ) {
            MenuInflater inflater = getMenuInflater();
            inflater.inflate( R.menu.dicts_item_menu, menu );
            
            XWListItem row = (XWListItem)info.targetView;
            DictUtils.DictLoc loc = (DictUtils.DictLoc)row.getCached();
            if ( loc == DictUtils.DictLoc.BUILT_IN
                 || ! DictUtils.haveWriteableSD() ) {
                menu.removeItem( R.id.dicts_item_move );
            }

            String fmt = getString(R.string.game_item_menu_titlef );
            menu.setHeaderTitle( String.format( fmt, row.getText() ) );
        }
    }
   
    @Override
    public boolean onContextItemSelected( MenuItem item ) 
    {
        boolean handled = false;
        ExpandableListContextMenuInfo info = null;
        try {
            info = (ExpandableListContextMenuInfo)item.getMenuInfo();
        } catch (ClassCastException e) {
            Utils.logf( ""bad menuInfo: %s"", e.toString() );
            return false;
        }
        
        m_packedPosition = info.packedPosition;

        int id = item.getItemId();
        switch( id ) {
        case R.id.dicts_item_move:
            askMoveDict( (XWListItem)info.targetView );
            break;
        case R.id.dicts_item_select:
            showDialog( SET_DEFAULT );
            break;
        case R.id.dicts_item_details:
            Utils.notImpl( this );
            break;
        }

        return handled;
    }

    private void setDefault( int keyId )
    {
        XWListItem view = m_adapter.getSelChildView();
        SharedPreferences sp
            = PreferenceManager.getDefaultSharedPreferences( this );
        SharedPreferences.Editor editor = sp.edit();
        String key = getString( keyId );
        String name = view.getText();
        editor.putString( key, name );
        editor.commit();
    }

    // Move dict.  Put up dialog asking user to confirm move from XX
    // to YY.  So we need both XX and YY.  There may be several
    // options for YY?
    private void askMoveDict( XWListItem item )
    {
        m_moveFromLoc = (DictUtils.DictLoc)item.getCached();
        if ( m_moveFromLoc == DictUtils.DictLoc.INTERNAL ) {
            m_moveToLoc = DictUtils.DictLoc.EXTERNAL;
        } else {
            m_moveToLoc = DictUtils.DictLoc.INTERNAL;
        }

        showDialog( MOVE_DICT );
    }

    // XWListItem.DeleteCallback interface
    public void deleteCalled( XWListItem item )
    {
        String dict = item.getText();
        String msg = String.format( getString( R.string.confirm_delete_dictf ),
                                    dict );

        m_deleteDict = dict;
        m_moveFromLoc = (DictUtils.DictLoc)item.getCached();

        // When and what to warn about.  First off, if there's another
        // identical dict, simply confirm.  Or if nobody's using this
        // dict *and* it's not the last of a language that somebody's
        // using, simply confirm.  If somebody is using it, then we
        // want different warnings depending on whether it's the last
        // available dict in its language.

        if ( 1 < DictLangCache.getDictCount( this, dict ) ) {
            // there's another; do nothing
        } else {
            int fmtid = 0;
            int langcode = DictLangCache.getDictLangCode( this, dict );
            DictAndLoc[] langDals = DictLangCache.getDALsHaveLang( this, 
                                                                   langcode );
            int nUsingLang = DBUtils.countGamesUsingLang( this, langcode );

            if ( 1 == langDals.length ) { // last in this language?
                if ( 0 < nUsingLang ) {
                    fmtid = R.string.confirm_deleteonly_dictf;
                }
            } else if ( 0 < DBUtils.countGamesUsingDict( this, dict ) ) {
                fmtid = R.string.confirm_deletemore_dictf;
            }
            if ( 0 != fmtid ) {
                String fmt = getString( fmtid );
                msg += String.format( fmt, DictLangCache.
                                       getLangName( this, langcode ) );
            }
        }

        m_delegate.showConfirmThen( msg, R.string.button_delete, 
                                    DELETE_DICT_ACTION );
    }

    // MountEventReceiver.SDCardNotifiee interface
    public void cardMounted( boolean nowMounted )
    {
        Utils.logf( ""DictsActivity.cardMounted(%b)"", nowMounted );
        // post so other SDCardNotifiee implementations get a chance
        // to process first: avoid race conditions
        new Handler().post( new Runnable() {
                public void run() {
                    mkListAdapter();
                    expandGroups();
                }
            } );
    }

    // DlgDelegate.DlgClickNotify interface
    public void dlgButtonClicked( int id, int which )
    {
        switch( id ) {
        case DELETE_DICT_ACTION:
            if ( DialogInterface.BUTTON_POSITIVE == which ) {
                deleteDict( m_deleteDict, m_moveFromLoc );
            }
            break;
        default:
            Assert.fail();
        }
    }

    private void deleteDict( String dict, DictUtils.DictLoc loc )
    {
        DictUtils.deleteDict( this, dict, loc );
        DictLangCache.inval( this, dict, loc, false );
        mkListAdapter();
        expandGroups();
    }

    private void askStartDownload( int lang, String name )
    {
        if ( DictUtils.haveWriteableSD() ) {
            m_lang = lang;
            m_name = name;
            showDialog( PICK_STORAGE );
        } else {
            startDownload( lang, name, false );
        }
    }

    private void startDownload( int lang, String name, boolean toSD )
    {
        DictImportActivity.setUseSD( toSD );
        try {
            startActivity( mkDownloadIntent( this, lang, name ) );
        } catch ( android.content.ActivityNotFoundException anfe ) {
            Toast.makeText( this, R.string.no_download_warning, 
                            Toast.LENGTH_SHORT).show();
        }
    }

    private void mkListAdapter()
    {
        m_langs = DictLangCache.listLangs( this );
        m_adapter = new DictListAdapter( this );
        setListAdapter( m_adapter );
    }

    private void expandGroups()
    {
        for ( int ii = 0; ii < m_langs.length; ++ii ) {
            boolean open = true;
            String lang = m_langs[ii];
            if ( s_openStates.containsKey( lang ) ) {
                open = s_openStates.get( lang );
            }
            if ( open ) {
                m_expView.expandGroup( ii );
            }
        }
    }

    private static Intent mkDownloadIntent( Context context,
                                            int lang, String dict )
    {
        String dict_url = CommonPrefs.getDefaultDictURL( context );
        if ( 0 != lang ) {
            dict_url += ""/"" + DictLangCache.getLangName( context, lang );
        }
        if ( null != dict ) {
            dict_url += ""/"" + dict + XWConstants.DICT_EXTN;
        }
        Uri uri = Uri.parse( dict_url );
        Intent intent = new Intent( Intent.ACTION_VIEW, uri );
        intent.setFlags( Intent.FLAG_ACTIVITY_NEW_TASK );
        return intent;
    }

    public static void launchAndDownload( Activity activity, int lang, 
                                          String name )
    {
        Intent intent = new Intent( activity, DictsActivity.class );
        intent.putExtra( DICT_DOLAUNCH, true );
        if ( lang > 0 ) {
            intent.putExtra( DICT_LANG_EXTRA, lang );
        }
        if ( null != name ) {
            Assert.assertTrue( lang != 0 );
            intent.putExtra( DICT_NAME_EXTRA, name );
        }

        activity.startActivity( intent );
    }

    public static void launchAndDownload( Activity activity, int lang )
    {
        launchAndDownload( activity, lang, null );
    }

}",False,53,42,1,2,5,13,2,12,L2
18,org.eehouse.android.xw4.XWListPreference.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 - 2011 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.preference.ListPreference;
import android.content.Context;
import android.util.AttributeSet;

import junit.framework.Assert;

public class XWListPreference extends ListPreference {

    public XWListPreference( Context context, AttributeSet attrs )
    {
        super( context, attrs );
    }

    protected void onAttachedToActivity()
    {
        super.onAttachedToActivity();
        setSummary( getPersistedString( """" ) );
    }

    protected boolean persistString( String value )
    {
        setSummary( value );
        return super.persistString( value );
    }
}
",False,29,2,1,1,0,0,1,0,L3
19,org.eehouse.android.xw4.ReceiveNBS.java,"/* -*- compile-command: ""cd ../../../../../; ant reinstall""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.telephony.SmsMessage;

public class ReceiveNBS extends BroadcastReceiver {

    @Override
    public void onReceive( Context context, Intent intent ) 
    {
        Utils.logf( ""onReceive called: %s"", intent.toString() );

        Bundle bundle = intent.getExtras();        
        SmsMessage[] smsarr = null;
        if (bundle != null) {
            Object[] pdus = (Object[]) bundle.get(""pdus"");
            smsarr = new SmsMessage[pdus.length];            
            for ( int ii = 0; ii < pdus.length; ii++){
                smsarr[ii] = SmsMessage.createFromPdu((byte[])pdus[ii]);
                Utils.logf( ""from %s"",  smsarr[ii].getOriginatingAddress() );
                // buf.append( smsarr[ii].getMessageBody() );
                // XwJni.handle( XwJni.JNICmd.CMD_RECEIVE, 
                //               smsarr[ii].getMessageBody() );
            }
        }
    } // onReceive

}
",False,47,2,0,0,1,1,0,1,L3
20,org.eehouse.android.xw4.XWEditTextPreference.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.preference.EditTextPreference;
import android.content.Context;
import android.util.AttributeSet;

import junit.framework.Assert;

public class XWEditTextPreference extends EditTextPreference {

    public XWEditTextPreference( Context context, AttributeSet attrs )
    {
        super( context, attrs );
    }

    protected void onAttachedToActivity()
    {
        super.onAttachedToActivity();
        setSummary( getPersistedString( """" ) );
    }

    protected boolean persistString( String value )
    {
        setSummary( value );
        return super.persistString( value );
    }

}
",False,28,1,0,0,0,0,0,0,I0
21,org.eehouse.android.xw4.GameListAdapter.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.eehouse.android.xw4;

import android.widget.ListAdapter;
import android.content.Context;
import android.os.AsyncTask;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import android.database.DataSetObserver;
import android.view.LayoutInflater;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.LinearLayout;
import java.io.FileInputStream;
import java.util.Date;
import java.util.HashMap;       // class is not synchronized
import java.text.DateFormat;

import junit.framework.Assert;


import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class GameListAdapter extends XWListAdapter {
    private Context m_context;
    private LayoutInflater m_factory;
    private int m_fieldID;
    private static final int TURN_COLOR = 0x7F00FF00;

    private class ViewInfo implements View.OnClickListener {
        private View m_view;
        private View m_hideable;
        private View m_name;
        private boolean m_expanded, m_haveTurn;
        private long m_rowid;
        private ImageButton m_expandButton;
        public ViewInfo( View view, long rowid, boolean expanded, 
                         boolean haveTurn ) {
            m_view = view;
            m_rowid = rowid; 
            m_expanded = expanded;
            m_haveTurn = haveTurn;
            m_hideable = (LinearLayout)view.findViewById( R.id.hideable );
            m_name = (TextView)m_view.findViewById( R.id.game_name );
            m_expandButton = (ImageButton)view.findViewById( R.id.expander );
            m_expandButton.setOnClickListener( this );
            showHide();
        }

        private void showHide()
        {
            m_expandButton.setImageResource( m_expanded ?
                                             R.drawable.expander_ic_maximized :
                                             R.drawable.expander_ic_minimized);
            m_hideable.setVisibility( m_expanded? View.VISIBLE : View.GONE );

            m_name.setBackgroundColor( m_haveTurn && !m_expanded ? TURN_COLOR :
                                       android.R.color.transparent );
        }

        public void onClick( View view ) {
            m_expanded = !m_expanded;
            DBUtils.setExpanded( m_rowid, m_expanded );
            showHide();
        }
    }

    private HashMap<Long,ViewInfo> m_viewsCache;
    private DateFormat m_df;
    private LoadItemCB m_cb;


    public interface LoadItemCB {
        public void itemLoaded( long rowid );
        public void itemClicked( long rowid );
    }

    private class LoadItemTask extends AsyncTask<Void, Void, Void> {
        private long m_rowid;
        private Context m_context;
        // private int m_id;
        public LoadItemTask( Context context, long rowid/*, int id*/ )
        {
            m_context = context;
            m_rowid = rowid;
            // m_id = id;
        }

        @Override
        protected Void doInBackground( Void... unused ) 
        {
            // Utils.logf( ""doInBackground(id=%d)"", m_id );
            View layout = m_factory.inflate( R.layout.game_list_item, null );
            boolean hideTitle = false;//CommonPrefs.getHideTitleBar(m_context);
            GameSummary summary = DBUtils.getSummary( m_context, m_rowid, false );
            if ( null == summary ) {
                m_rowid = -1;
            } else {
                //Assert.assertNotNull( summary );

                String state = summary.summarizeState();

                TextView view = (TextView)layout.findViewById( R.id.game_name );
                if ( hideTitle ) {
                    view.setVisibility( View.GONE );
                } else {
                    String value = null;
                    switch ( m_fieldID ) {
                    case R.string.game_summary_field_empty:
                        break;
                    case R.string.game_summary_field_language:
                        value = 
                            DictLangCache.getLangName( m_context, 
                                                       summary.dictLang );
                        break;
                    case R.string.game_summary_field_opponents:
                        value = summary.playerNames();
                        break;
                    case R.string.game_summary_field_state:
                        value = state;
                        break;
                    }

                    String name = GameUtils.getName( m_context, m_rowid );
                    String format = 
                        m_context.getString( R.string.str_game_namef );

                    if ( null != value ) {
                        value = String.format( format, name, value );
                    } else {
                        value = name;
                    }
                        
                    view.setText( value );
                }

                layout.setOnClickListener( new View.OnClickListener() {
                        @Override
                        public void onClick( View v ) {
                            m_cb.itemClicked( m_rowid );
                        }
                    } );

                LinearLayout list =
                    (LinearLayout)layout.findViewById( R.id.player_list );
                boolean haveNetTurn = false;
                for ( int ii = 0; ii < summary.nPlayers; ++ii ) {
                    View tmp = m_factory.inflate( R.layout.player_list_elem, 
                                                  null );
                    view = (TextView)tmp.findViewById( R.id.item_name );
                    view.setText( summary.summarizePlayer( ii ) );
                    view = (TextView)tmp.findViewById( R.id.item_score );
                    view.setText( String.format( ""  %d"", summary.scores[ii] ) );
                    if ( summary.isNextToPlay( ii ) ) {
                        tmp.setBackgroundColor( TURN_COLOR );
                        if ( summary.isRelayGame() ) {
                            haveNetTurn = true;
                        }
                    }
                    list.addView( tmp, ii );
                }

                view = (TextView)layout.findViewById( R.id.state );
                view.setText( state );
                view = (TextView)layout.findViewById( R.id.modtime );
                view.setText( m_df.format( new Date( summary.modtime ) ) );

                int iconID;
                ImageView marker =
                    (ImageView)layout.findViewById( R.id.msg_marker );
                if ( summary.isRelayGame() ) {
                    if ( summary.pendingMsgLevel != GameSummary.MSG_FLAGS_NONE ) {
                        iconID = R.drawable.ic_popup_sync_1;
                    } else {
                        iconID = R.drawable.relaygame;
                    }
                } else {
                    iconID = R.drawable.sologame;
                }
                marker.setImageResource( iconID );

                view = (TextView)layout.findViewById( R.id.role );
                String roleSummary = summary.summarizeRole();
                if ( null != roleSummary ) {
                    view.setText( roleSummary );
                } else {
                    view.setVisibility( View.GONE );
                }

                boolean expanded = DBUtils.getExpanded( m_context, m_rowid );
                ViewInfo vi = new ViewInfo( layout, m_rowid, 
                                            expanded, haveNetTurn );

                synchronized( m_viewsCache ) {
                    m_viewsCache.put( m_rowid, vi );
                }
            }
            return null;
        } // doInBackground

        @Override
        protected void onPostExecute( Void unused )
        {
            // Utils.logf( ""onPostExecute(id=%d)"", m_id );
            if ( -1 != m_rowid ) {
                m_cb.itemLoaded( m_rowid );
            }
        }
    } // class LoadItemTask

    public GameListAdapter( Context context, LoadItemCB cb ) {
        super( context, DBUtils.gamesList(context).length );
        m_context = context;
        m_cb = cb;
        m_factory = LayoutInflater.from( context );
        m_df = DateFormat.getDateTimeInstance( DateFormat.SHORT, 
                                               DateFormat.SHORT );

        int sdk_int = 0;
        try {
            sdk_int = Integer.decode( android.os.Build.VERSION.SDK );
        } catch ( Exception ex ) {}

        m_viewsCache = new HashMap<Long,ViewInfo>();
    }
    
    public int getCount() {
        return DBUtils.gamesList(m_context).length;
    }
    
    public Object getItem( int position ) 
    {
        final long rowid = DBUtils.gamesList(m_context)[position];
        View layout;
        synchronized( m_viewsCache ) {
            ViewInfo vi = m_viewsCache.get( rowid );
            layout = null == vi? null : vi.m_view;
        }

        if ( null == layout ) {
            layout = m_factory.inflate( R.layout.game_list_item, null );
            final boolean hideTitle = 
                false;//CommonPrefs.getHideTitleBar( m_context );

            TextView view = (TextView)layout.findViewById( R.id.game_name );
            if ( hideTitle ) {
                view.setVisibility( View.GONE );
            } else {
                String text = GameUtils.getName( m_context, rowid );
                view.setText( text );
            }

            new LoadItemTask( m_context, rowid/*, ++m_taskCounter*/ ).execute();
        }

        // this doesn't work.  Rather, it breaks highlighting because
        // the background, if we don't set it, is a more complicated
        // object like @android:drawable/list_selector_background.  I
        // tried calling getBackground(), expecting to get a Drawable
        // I could then clone and modify, but null comes back.  So
        // layout must be inheriting its background from elsewhere or
        // it gets set later, during layout.
        // if ( (position%2) == 0 ) {
        //     layout.setBackgroundColor( 0xFF3F3F3F );
        // }

        return layout;
    } // getItem

    public View getView( int position, View convertView, ViewGroup parent ) {
        return (View)getItem( position );
    }

    public void inval( long rowid )
    {
        synchronized( m_viewsCache ) {
            m_viewsCache.remove( rowid );
        }
    }

    public void setField( String field )
    {
        int[] ids = {
            R.string.game_summary_field_empty
            ,R.string.game_summary_field_language
            ,R.string.game_summary_field_opponents
            ,R.string.game_summary_field_state
        };
        int result = -1;
        for ( int id : ids ) {
            if ( m_context.getString( id ).equals( field ) ) {
                result = id;
                break;
            }
        }
        if ( m_fieldID != result ) {
            m_viewsCache.clear();
            m_fieldID = result;
        }
    }

}",True,12,40,1,1,4,15,1,6,L3
22,org.eehouse.android.xw4.XWListItem.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.widget.LinearLayout;
import android.view.View;
import android.widget.TextView;
import android.widget.ImageButton;
import android.content.Context;
import android.util.AttributeSet;
import android.graphics.Rect;

public class XWListItem extends LinearLayout {
    private int m_position;
    private Context m_context;
    private Object m_cached;
    DeleteCallback m_cb;

    public interface DeleteCallback {
        void deleteCalled( XWListItem item );
    }

    public XWListItem( Context cx, AttributeSet as ) {
        super( cx, as );
        m_context = cx;
    }

    public int getPosition() { return m_position; }
    public void setPosition( int indx ) { m_position = indx; }

    public void setText( String text )
    {
        TextView view = (TextView)findViewById( R.id.text_item );
        view.setText( text );
    }

    public String getText()
    {
        TextView view = (TextView)findViewById( R.id.text_item );
        return view.getText().toString();
    }

    public void setComment( String text )
    {
        TextView view = (TextView)findViewById( R.id.text_item2 );
        view.setVisibility( View.VISIBLE );
        view.setText( text );
    }

    public void setDeleteCallback( DeleteCallback cb ) 
    {
        m_cb = cb;
        ImageButton button = (ImageButton)findViewById( R.id.del );
        button.setOnClickListener( new View.OnClickListener() {
                @Override
                public void onClick( View view ) {
                    m_cb.deleteCalled( XWListItem.this );
                }
            } );
        button.setVisibility( View.VISIBLE );
    }

    @Override
    public void setEnabled( boolean enabled ) 
    {
        ImageButton button = (ImageButton)findViewById( R.id.del );
        button.setEnabled( enabled );
        // calling super here means the list item can't be opened for
        // the user to inspect data.  Might want to reconsider this.
        // PENDING
        super.setEnabled( enabled );
    }

    // I can't just extend an object used in layout -- get a class
    // cast exception when inflating it and casting to the subclass.
    // So rather than create a subclass that knows about its purpose
    // I'll extend this with a general mechanism.  Hackery but ok.
    public void cache( Object obj )
    {
        m_cached = obj;
    }

    public Object getCached()
    {
        return m_cached;
    }

}
",True,42,4,2,2,0,0,2,0,L2
23,org.eehouse.android.xw4.XWConstants.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

public interface XWConstants {
    public static final String GAME_EXTN = "".xwg"";
    public static final String DICT_EXTN = "".xwd"";
}
",False,20,36,4,14,0,0,4,0,L1
24,org.eehouse.android.xw4.RelayGameActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

// This activity is for newbies.  Bring it up when network game
// created.  It explains they need only a room name -- that everything
// else is derived from defaults and configurable via the main config
// dialog (which offer to launch)

package org.eehouse.android.xw4;

import android.app.Activity;
import java.io.File;
import android.os.Bundle;
import android.widget.Button;
import android.widget.TextView;
import android.view.View;
import android.content.Intent;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;

public class RelayGameActivity extends XWActivity 
    implements View.OnClickListener {

    private long m_rowid;
    private CurGameInfo m_gi;
    private GameUtils.GameLock m_gameLock;
    private CommsAddrRec m_car;
    private Button m_playButton;
    private Button m_configButton;

    @Override
    public void onCreate( Bundle savedInstanceState ) 
    {
        super.onCreate( savedInstanceState );

        setContentView( R.layout.relay_game_config );

        m_rowid = getIntent().getLongExtra( BoardActivity.INTENT_KEY_ROWID, -1 );

        m_playButton = (Button)findViewById( R.id.play_button );
        m_playButton.setOnClickListener( this );

        m_configButton = (Button)findViewById( R.id.config_button );
        m_configButton.setOnClickListener( this );
    } // onCreate

    @Override
    protected void onStart()
    {
        super.onStart();

        m_gi = new CurGameInfo( this );
        m_gameLock = new GameUtils.GameLock( m_rowid, true ).lock();
        int gamePtr = GameUtils.loadMakeGame( this, m_gi, m_gameLock );
        m_car = new CommsAddrRec( this );
        if ( XwJNI.game_hasComms( gamePtr ) ) {
            XwJNI.comms_getAddr( gamePtr, m_car );
        } else {
            Assert.fail();
            // String relayName = CommonPrefs.getDefaultRelayHost( this );
            // int relayPort = CommonPrefs.getDefaultRelayPort( this );
            // XwJNI.comms_getInitialAddr( m_carOrig, relayName, relayPort );
        }
        XwJNI.game_dispose( gamePtr );

        String lang = DictLangCache.getLangName( this, m_gi.dictLang );
        String fmt = getString( R.string.relay_game_explainf );
        TextView text = (TextView)findViewById( R.id.explain );
        text.setText( String.format( fmt, lang ) );
    }

    @Override
    protected void onPause()
    {
        if ( null != m_gameLock ) {
            m_gameLock.unlock();
            m_gameLock = null;
        }
        super.onPause();
    }

    @Override
    public void onClick( View view ) 
    {
        String room = Utils.getText( this, R.id.room_edit ).trim();
        if ( view == m_playButton ) {
            if ( room.length() == 0 ) {
                showOKOnlyDialog( R.string.no_empty_rooms );
            } else {
                if ( saveRoomAndName( room ) ) {
                    GameUtils.launchGameAndFinish( this, m_rowid );
                }
            }
        } else if ( view == m_configButton ) {
            if ( saveRoomAndName( room ) ) {
                GameUtils.doConfig( this, m_rowid, GameConfig.class );
                finish();
            }
        }
    }

    public static boolean isSimpleGame( GameSummary summary )
    {
        return summary.nPlayers == 2;
    }

    private boolean saveRoomAndName( String room )
    {
        boolean canSave = null != m_gameLock;
        if ( canSave ) {
            String name = Utils.getText( this, R.id.local_name_edit );
            if ( name.length() > 0 ) { // don't wipe existing
                m_gi.setFirstLocalName( name );
            }
            m_car.ip_relay_invite = room;
            GameUtils.applyChanges( this, m_gi, m_car, m_gameLock, false );
            m_gameLock.unlock();
            m_gameLock = null;
        }
        return canSave;
    }

} // class RelayGameActivity
",True,44,39,1,1,3,21,1,6,L3
25,org.eehouse.android.xw4.DispatchNotify.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Intent;
import android.net.Uri;
import android.widget.Toast;
import android.os.Bundle;
import java.util.HashSet;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.CommonPrefs;

public class DispatchNotify extends Activity {

    public static final String RELAYIDS_EXTRA = ""relayids"";

    public interface HandleRelaysIface {
        void HandleRelaysIDs( final String[] relayIDs );
        void HandleInvite( final Uri invite );
    }

    private static HashSet<Activity> s_running = new HashSet<Activity>();
    private static HandleRelaysIface s_handler;

    @Override
    protected void onCreate( Bundle savedInstanceState ) 
    {
        boolean mustLaunch = false;
        super.onCreate( savedInstanceState );

        String[] relayIDs = getIntent().getStringArrayExtra( RELAYIDS_EXTRA );
        Uri data = getIntent().getData();

        if ( null != relayIDs ) {
            if ( !tryHandle( relayIDs ) ) {
                mustLaunch = true;
            }
        } else if ( null != data ) {
            if ( !tryHandle( data ) ) {
                mustLaunch = true;
            }
        }

        if ( mustLaunch ) {
            Utils.logf( ""DispatchNotify: nothing running"" );
            Intent intent = new Intent( this, GamesList.class );

            /* Flags.  Tried Intent.FLAG_ACTIVITY_NEW_TASK.  I don't
             * remember what it fixes, but what it breaks is easy to
             * duplicate.  Launch Crosswords from the home screen making
             * sure it's the only instance running.  Get a networked game
             * going, and with BoardActivity frontmost check the relay and
             * select a relay notification.  New BoardActivity will come
             * up, but if you hit home button then Crosswords icon you're
             * back to games list.  Hit back button and you're back to
             * BoardActivity, and back from there back to GamesList.
             * That's because a new activity came up from the activity
             * below thanks to the flag.
             */

            intent.setFlags( Intent.FLAG_ACTIVITY_CLEAR_TOP
                             // Intent.FLAG_ACTIVITY_NEW_TASK NO See above
                             );
            if ( null != relayIDs ) {
                intent.putExtra( RELAYIDS_EXTRA, relayIDs );
            } else if ( null != data ) {
                intent.setData( data );
            } else {
                Assert.fail();
            }
            startActivity( intent );
        }

        finish();
    }

    public static void SetRunning( Activity running )
    {
        s_running.add( running );
    }

    public static void ClearRunning( Activity running )
    {
        s_running.remove( running );
    }

    public static void SetRelayIDsHandler( HandleRelaysIface iface )
    {
        s_handler = iface;
    }

    private static boolean tryHandle( Uri data )
    {
        boolean handled = false;
        if ( null != s_handler ) {
            // This means the GamesList activity is frontmost
            s_handler.HandleInvite( data );
            handled = true;
        } else {
            for ( Activity activity : s_running ) {
                if ( activity instanceof DispatchNotify.HandleRelaysIface ) {
                    DispatchNotify.HandleRelaysIface iface =
                        (DispatchNotify.HandleRelaysIface)activity;
                    iface.HandleInvite( data );
                    handled = true;
                }
            }
        }
        return handled;
    }

    public static boolean tryHandle( String[] relayIDs )
    {
        boolean handled = false;
        if ( null != s_handler ) {
            // This means the GamesList activity is frontmost
            s_handler.HandleRelaysIDs( relayIDs );
            handled = true;
        } else {
            for ( Activity activity : s_running ) {
                if ( activity instanceof DispatchNotify.HandleRelaysIface ) {
                    DispatchNotify.HandleRelaysIface iface =
                        (DispatchNotify.HandleRelaysIface)activity;
                    iface.HandleRelaysIDs( relayIDs );
                    handled = true;
                }
            }
        }
        return handled;
    }
}
",False,5,40,1,3,9,7,4,2,L1
26,org.eehouse.android.xw4.RelayService.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 - 2011 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import javax.net.SocketFactory;
import java.net.InetAddress;
import java.net.Socket;
import java.io.InputStream;
import java.io.DataInputStream;
import java.io.OutputStream;
import java.io.DataOutputStream;
import java.util.ArrayList;

import org.eehouse.android.xw4.jni.GameSummary;
import org.eehouse.android.xw4.jni.CommonPrefs;

public class RelayService extends Service {

    @Override
    public void onCreate()
    {
        super.onCreate();
        
        Thread thread = new Thread( null, new Runnable() {
                public void run() {

                    String[] relayIDs = NetUtils.QueryRelay( RelayService.this );
                    if ( null != relayIDs ) {
                        if ( !DispatchNotify.tryHandle( relayIDs ) ) {
                            setupNotification( relayIDs );
                        }
                    }
                    RelayService.this.stopSelf();
                }
            }, getClass().getName() );
        thread.start();
    }

    @Override
    public IBinder onBind( Intent intent )
    {
        return null;
    }

    private void setupNotification( String[] relayIDs )
    {
        Intent intent = new Intent( this, DispatchNotify.class );
        intent.putExtra( DispatchNotify.RELAYIDS_EXTRA, relayIDs );

        PendingIntent pi = PendingIntent.
            getActivity( this, 0, intent, 
                         PendingIntent.FLAG_UPDATE_CURRENT );
        String title = getString(R.string.notify_title);
        Notification notification = 
            new Notification( R.drawable.icon48x48, title,
                              System.currentTimeMillis() );

        notification.flags |= Notification.FLAG_AUTO_CANCEL;
        if ( CommonPrefs.getSoundNotify( this ) ) {
            notification.defaults |= Notification.DEFAULT_SOUND;
        }
        if ( CommonPrefs.getVibrateNotify( this ) ) {
            notification.defaults |= Notification.DEFAULT_VIBRATE;
        }

        notification.
            setLatestEventInfo( this, title, 
                                getString(R.string.notify_body), pi );

        NotificationManager nm = (NotificationManager)
            getSystemService( Context.NOTIFICATION_SERVICE );
        nm.notify( R.string.notify_body, // unique id; any will do
                   notification );
    }
}
",True,11,38,0,0,5,10,0,4,L3
27,org.eehouse.android.xw4.DictLangCache.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.content.res.Resources;
import android.os.Handler;
import android.widget.ArrayAdapter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.Arrays;
import java.util.Comparator;
import junit.framework.Assert;

import org.eehouse.android.xw4.DictUtils.DictAndLoc;
import org.eehouse.android.xw4.jni.JNIUtilsImpl;
import org.eehouse.android.xw4.jni.XwJNI;
import org.eehouse.android.xw4.jni.DictInfo;
import org.eehouse.android.xw4.jni.CommonPrefs;

public class DictLangCache {
    private static final HashMap<DictAndLoc,DictInfo> s_nameToLang = 
        new HashMap<DictAndLoc,DictInfo>();
    private static String[] s_langNames;

    private static int m_adaptedLang = -1;
    private static ArrayAdapter<String> m_langsAdapter;
    private static ArrayAdapter<String> m_dictsAdapter;
    private static String s_last;
    private static Handler s_handler;
    private static Comparator<String> KeepLast = 
        new Comparator<String>() {
            public int compare( String str1, String str2 )
            {
                if ( s_last.equals( str1 ) ) {
                    return 1;
                } else if ( s_last.equals( str2 ) ) {
                    return -1;
                } else {
                    return str1.compareToIgnoreCase( str2 );
                }
            }
        };

    public static String annotatedDictName( Context context, DictAndLoc dal )
    {
        DictInfo info = getInfo( context, dal );
        int wordCount = info.wordCount;
            
        String langName = getLangName( context, dal.name );
        String result;
        if ( 0 == wordCount ) {
            result = String.format( ""%s (%s)"", dal.name, langName );
        } else {
            result = String.format( ""%s (%s/%d)"", dal.name, langName, 
                                    wordCount );
        }

        return result;
    }

    public static String annotatedDictName( Context context, String name,
                                            int lang )
    {
        return name + "" ("" + getLangName( context, lang ) + "")"";
    }

    public static String getLangName( Context context, int code )
    {
        String[] namesArray = getLangNames( context );
        if ( code < 0 || code >= namesArray.length ) {
            code = 0;
        }
        return namesArray[code];
    }

    // This populates the cache and will take significant time if it's
    // mostly empty and there are a lot of dicts.
    public static int getLangCount( Context context, int code )
    {
        int count = 0;
        DictAndLoc[] dals = DictUtils.dictList( context );
        for ( DictAndLoc dal : dals ) {
            if ( code == getDictLangCode( context, dal ) ) {
                ++count;
            }
        }
        return count;
    }

    private static DictInfo[] getInfosHaveLang( Context context, int code )
    {
        ArrayList<DictInfo> al = new ArrayList<DictInfo>();
        DictAndLoc[] dals = DictUtils.dictList( context );
        for ( DictAndLoc dal : dals ) {
            DictInfo info = getInfo( context, dal );
            if ( code == info.langCode ) {
                al.add( info );
            }
        }
        DictInfo[] result = al.toArray( new DictInfo[al.size()] );
        return result;
    }

    private static String[] getHaveLang( Context context, int code,
                                         Comparator<DictInfo> comp,
                                         boolean withCounts )
    {
        DictInfo[] infos = getInfosHaveLang( context, code );

        if ( null != comp ) {
            Arrays.sort( infos, comp );
        }

        ArrayList<String> al = new ArrayList<String>();
        String fmt = ""%s (%d)""; // must match stripCount below
        for ( DictInfo info : infos ) {
            String name = info.name;
            if ( withCounts ) {
                name = String.format( fmt, name, info.wordCount );
            }
            al.add( name );
        }
        String[] result = al.toArray( new String[al.size()] );
        if ( null == comp ) {
            Arrays.sort( result );
        }
        return result;
    }

    public static String[] getHaveLang( Context context, int code )
    {
        return getHaveLang( context, code, null, false );
    }

    public static DictAndLoc[] getDALsHaveLang( Context context, int code )
    {
        ArrayList<DictAndLoc> al = new ArrayList<DictAndLoc>();
        DictAndLoc[] dals = DictUtils.dictList( context );
        for ( DictAndLoc dal : dals ) {
            DictInfo info = getInfo( context, dal );
            if ( code == info.langCode ) {
                al.add( dal );
            }
        }
        DictAndLoc[] result = al.toArray( new DictAndLoc[al.size()] );
        return result;
    }

    private static Comparator<DictInfo> s_ByCount = 
        new Comparator<DictInfo>() {
            public int compare( DictInfo di1, DictInfo di2 )
            {
                return di2.wordCount - di1.wordCount;
            }
        };

    public static String[] getHaveLangByCount( Context context, int code )
    {
        return getHaveLang( context, code, s_ByCount, false );
    }

    public static String[] getHaveLangCounts( Context context, int code )
    {
        return getHaveLang( context, code, null, true );
    }

    public static String stripCount( String nameWithCount )
    {
        int indx = nameWithCount.lastIndexOf( "" ("" );
        return nameWithCount.substring( 0, indx );
    }

    public static int getDictLangCode( Context context, DictAndLoc dal )
    {
        return getInfo( context, dal ).langCode;
    }

    public static int getDictLangCode( Context context, String dict )
    {
        return getInfo( context, dict ).langCode;
    }

    public static int getLangLangCode( Context context, String lang )
    {
        int code = 0;
        String[] namesArray = getLangNames( context );
        for ( int ii = 0; ii < namesArray.length; ++ii ) {
            if ( namesArray[ii].equals( lang ) ) {
                code = ii;
                break;
            }
        }
        return code;
    }

    public static String getLangName( Context context, String dict )
    {
        int code = getDictLangCode( context, dict );
        return getLangName( context, code );
    }

    public static void inval( final Context context, String name,
                              DictUtils.DictLoc loc, boolean added )
    {
        DictAndLoc dal = new DictAndLoc( name, loc );
        s_nameToLang.remove( dal );
        if ( added ) {
            getInfo( context, dal );
        }

        if ( null != s_handler ) {
            s_handler.post( new Runnable() {
                    public void run() {
                        if ( null != m_dictsAdapter ) {
                            rebuildAdapter( m_dictsAdapter, 
                                            DictLangCache.
                                            getHaveLang( context, 
                                                         m_adaptedLang ) );
                        }
                        if ( null != m_langsAdapter ) {
                            rebuildAdapter( m_langsAdapter, 
                                            DictLangCache.listLangs( context ) );
                        }
                    }
                } );
        }
    }

    public static String[] listLangs( Context context )
    {
        return listLangs( context, DictUtils.dictList( context ) );
    }

    public static String[] listLangs( Context context, DictAndLoc[] dals )
    {
        HashSet<String> langs = new HashSet<String>();
        for ( DictAndLoc dal : dals ) {
            langs.add( getLangName( context, dal.name ) );
        }
        String[] result = new String[langs.size()];
        return langs.toArray( result );
    }

    public static String getBestDefault( Context context, int lang, 
                                         boolean human )
    {
        String dict = human? CommonPrefs.getDefaultHumanDict( context )
            : CommonPrefs.getDefaultRobotDict( context );
        if ( lang != DictLangCache.getDictLangCode( context, dict ) ) {
            String dicts[] = getHaveLangByCount( context, lang );
            if ( dicts.length > 0 ) {
                // Human gets biggest; robot gets smallest
                dict = dicts[ human ? 0 : dicts.length-1 ];
            } else {
                dict = null;
            }
        }
        return dict;
    }

    private static void rebuildAdapter( ArrayAdapter<String> adapter,
                                        String[] items )
    {
        adapter.clear();

        for ( String item : items ) {
            adapter.add( item );
        }
        if ( null != s_last ) {
            adapter.add( s_last );
        }
        adapter.sort( KeepLast );
    }

    public static void setLast( String lastItem )
    {
        s_last = lastItem;
        s_handler = new Handler();
    }

    public static ArrayAdapter<String> getLangsAdapter( Context context )
    {
        if ( null == m_langsAdapter ) {
            m_langsAdapter = 
                new ArrayAdapter<String>( context,
                                          android.R.layout.simple_spinner_item );
            rebuildAdapter( m_langsAdapter, listLangs( context ) );
        }
        return m_langsAdapter;
    }

    public static ArrayAdapter<String> getDictsAdapter( Context context, 
                                                        int lang )
    {
        if ( lang != m_adaptedLang ) {
            m_dictsAdapter = 
                new ArrayAdapter<String>( context,
                                          android.R.layout.simple_spinner_item );
            rebuildAdapter( m_dictsAdapter, getHaveLang( context, lang ) );
            m_adaptedLang = lang;
        }
        return m_dictsAdapter;
    }

    public static String[] getLangNames( Context context )
    {
        if ( null == s_langNames ) {
            Resources res = context.getResources();
            s_langNames = res.getStringArray( R.array.language_names );
        }
        return s_langNames;
    }

    public static int getDictCount( Context context, String name )
    {
        int result = 0;
        for ( DictAndLoc dal : DictUtils.dictList( context ) ) {
            if ( name.equals( dal.name ) ) {
                ++result;
            }
        }
        Assert.assertTrue( result > 0 );
        return result;
    }

    private static DictInfo getInfo( Context context, String name )
    {
        DictInfo result = null;
        Set<DictAndLoc> keys = s_nameToLang.keySet();
        for ( DictAndLoc key : keys ) {
            if ( key.name.equals(name) ) {
                result = s_nameToLang.get( key );
                break;
            }
        }

        if ( null == result ) {
            DictUtils.DictLoc loc = DictUtils.getDictLoc( context, name );
            result = getInfo( context, new DictAndLoc( name, loc ) );
        }
        return result;
    }

    private static DictInfo getInfo( Context context, DictAndLoc dal )
    {
        DictInfo info;
        if ( s_nameToLang.containsKey( dal ) ) {
            info = s_nameToLang.get( dal );
        } else {
            String[] names = { dal.name };
            DictUtils.DictPairs pairs = DictUtils.openDicts( context, names );

            info = new DictInfo();

            XwJNI.dict_getInfo( pairs.m_bytes[0], pairs.m_paths[0], 
                                JNIUtilsImpl.get(), info );

            info.name = dal.name;
            s_nameToLang.put( dal, info );
        }
        return info;
    }

}",True,38,44,1,7,6,11,8,5,L1
28,org.eehouse.android.xw4.BoardActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MenuInflater;
import android.view.KeyEvent;
import android.view.Window;
import android.os.Handler;
import android.os.Message;
import android.content.Intent;
import java.util.concurrent.Semaphore;
import java.util.ArrayList;
import java.util.Iterator;
import android.app.Dialog;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnDismissListener;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;
import junit.framework.Assert;
import android.content.res.Configuration;
import android.content.pm.ActivityInfo;

import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.JNIThread.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;


public class BoardActivity extends XWActivity 
    implements TransportProcs.TPMsgHandler, View.OnClickListener {

    public static final String INTENT_KEY_ROWID = ""rowid"";
    public static final String INTENT_KEY_CHAT = ""chat"";

    private static final int DLG_OKONLY = DlgDelegate.DIALOG_LAST + 1;
    private static final int DLG_BADWORDS = DLG_OKONLY + 1;
    private static final int QUERY_REQUEST_BLK = DLG_OKONLY + 2;
    private static final int QUERY_INFORM_BLK = DLG_OKONLY + 3;
    private static final int PICK_TILE_REQUEST_BLK = DLG_OKONLY + 4;
    private static final int ASK_PASSWORD_BLK = DLG_OKONLY + 5;
    private static final int DLG_RETRY = DLG_OKONLY + 6;
    private static final int QUERY_ENDGAME = DLG_OKONLY + 7;
    private static final int DLG_DELETED = DLG_OKONLY + 8;
    private static final int DLG_INVITE = DLG_OKONLY + 9;

    private static final int CHAT_REQUEST = 1;
    private static final int SCREEN_ON_TIME = 10 * 60 * 1000; // 10 mins

    private static final int UNDO_LAST_ACTION = 1;
    private static final int LAUNCH_INVITE_ACTION = 2;
    private static final int SYNC_ACTION = 3;
    private static final int COMMIT_ACTION = 4;
    private static final int SHOW_EXPL_ACTION = 5;
    private static final int PREV_HINT_ACTION = 6;
    private static final int NEXT_HINT_ACTION = 7;
    private static final int JUGGLE_ACTION = 8;
    private static final int FLIP_ACTION = 9;
    private static final int ZOOM_ACTION = 10;
    private static final int UNDO_ACTION = 11;
    private static final int CHAT_ACTION = 12;
    private static final int START_TRADE_ACTION = 13;

    private static final String DLG_TITLE = ""DLG_TITLE"";
    private static final String DLG_TITLESTR = ""DLG_TITLESTR"";
    private static final String DLG_BYTES = ""DLG_BYTES"";
    private static final String ROOM = ""ROOM"";
    private static final String TOASTSTR = ""TOASTSTR"";

    private BoardView m_view;
    private int m_jniGamePtr;
    private GameUtils.GameLock m_gameLock;
    private CurGameInfo m_gi;
    private CommsTransport m_xport;
    private Handler m_handler = null;
    private TimerRunnable[] m_timers;
    private Runnable m_screenTimer;
    private long m_rowid;
    private Toolbar m_toolbar;
    private View m_tradeButtons;
    private Button m_exchCommmitButton;
    private Button m_exchCancelButton;

    private ArrayList<String> m_pendingChats = new ArrayList<String>();

    private String m_dlgBytes = null;
    private EditText m_passwdEdit = null;
    private LinearLayout m_passwdLyt = null;
    private int m_dlgTitle;
    private String m_dlgTitleStr;
    private String[] m_texts;
    private boolean m_firingPrefs;
    private JNIUtils m_jniu;
    private boolean m_volKeysZoom;
    private boolean m_inTrade;  // save this in bundle?
    private BoardUtilCtxt m_utils;

    // call startActivityForResult synchronously
	private Semaphore m_forResultWait = new Semaphore(0);
    private int m_resultCode;

    private Thread m_blockingThread;
    private JNIThread m_jniThread;
    private JNIThread.GameStateInfo m_gsi;
    private boolean m_blockingDlgPosted = false;

    private String m_room;
    private String m_toastStr;
    private int m_missing;
    private boolean m_haveInvited = false;

    public class TimerRunnable implements Runnable {
        private int m_why;
        private int m_when;
        private int m_handle;
        private TimerRunnable( int why, int when, int handle ) {
            m_why = why;
            m_when = when;
            m_handle = handle;
        }
        public void run() {
            m_timers[m_why] = null;
            if ( null != m_jniThread ) {
                m_jniThread.handle( JNICmd.CMD_TIMER_FIRED, false,
                                    m_why, m_when, m_handle );
            }
        }
    } 

    @Override
    protected Dialog onCreateDialog( int id )
    {
        Dialog dialog = super.onCreateDialog( id );
        if ( null == dialog ) {
            DialogInterface.OnClickListener lstnr;
            AlertDialog.Builder ab;

            switch ( id ) {
            case DLG_OKONLY:
            case DLG_BADWORDS:
            case DLG_RETRY:
                ab = new AlertDialog.Builder( BoardActivity.this )
                    .setTitle( m_dlgTitle )
                    .setMessage( m_dlgBytes )
                    .setPositiveButton( R.string.button_ok, null );
                if ( DLG_RETRY == id ) {
                    lstnr = new DialogInterface.OnClickListener() {
                            public void onClick( DialogInterface dlg, 
                                                 int whichButton ) {
                                m_jniThread.handle( JNIThread.JNICmd.CMD_RESET );
                            }
                        };
                    ab.setNegativeButton( R.string.button_retry, lstnr );
                }
                dialog = ab.create();
                Utils.setRemoveOnDismiss( this, dialog, id );
                break;

            case DLG_DELETED:
                ab = new AlertDialog.Builder( BoardActivity.this )
                    .setTitle( R.string.query_title )
                    .setMessage( R.string.msg_dev_deleted )
                    .setPositiveButton( R.string.button_ok, null );
                lstnr = new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dlg, 
                                             int whichButton ) {

                            waitCloseGame( false );
                            GameUtils.deleteGame( BoardActivity.this,
                                                  m_rowid, false );
                            // Intent intent = new Intent();
                            // intent.putExtra( ""delete"", true );
                            // intent.putExtra( ""path"", m_path );
                            // setResult( Activity.RESULT_OK, intent );
                            finish();
                        }
                    };
                ab.setNegativeButton( R.string.button_discard, lstnr );
                dialog = ab.create();
                break;

            case QUERY_REQUEST_BLK:
            case QUERY_INFORM_BLK:
                ab = new AlertDialog.Builder( this )
                    .setMessage( m_dlgBytes );
                if ( 0 != m_dlgTitle ) {
                    ab.setTitle( m_dlgTitle );
                }
                lstnr = new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dialog, 
                                             int whichButton ) {
                            m_resultCode = 1;
                        }
                    };
                ab.setPositiveButton( QUERY_REQUEST_BLK == id ?
                                      R.string.button_yes : R.string.button_ok,
                                      lstnr );
                if ( QUERY_REQUEST_BLK == id ) {
                    lstnr = new DialogInterface.OnClickListener() {
                            public void onClick( DialogInterface dialog, 
                                                 int whichButton ) {
                                m_resultCode = 0;
                            }
                        };
                    ab.setNegativeButton( R.string.button_no, lstnr );
                }

                dialog = ab.create();
                dialog.setOnDismissListener( makeODLforBlocking( id ) );
                break;

            case PICK_TILE_REQUEST_BLK:
                ab = new AlertDialog.Builder( this )
                    .setTitle( R.string.title_tile_picker );
                lstnr = new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dialog, 
                                             int item ) {
                            m_resultCode = item;
                        }
                    };
                ab.setItems( m_texts, lstnr );

                dialog = ab.create();
                dialog.setOnDismissListener( makeODLforBlocking( id ) );
                break;

            case ASK_PASSWORD_BLK:
                m_passwdEdit.setText( """", TextView.BufferType.EDITABLE );
                ab = new AlertDialog.Builder( this )
                    .setTitle( m_dlgTitleStr )
                    .setView( m_passwdLyt )
                    .setPositiveButton( R.string.button_ok,
                                        new DialogInterface.OnClickListener() {
                                            public void 
                                                onClick( DialogInterface dlg,
                                                         int whichButton ) {
                                                m_resultCode = 1;
                                            }
                                        });
                dialog = ab.create();
                dialog.setOnDismissListener( makeODLforBlocking( id ) );
                break;

            case QUERY_ENDGAME:
                dialog = new AlertDialog.Builder( this )
                    .setTitle( R.string.query_title )
                    .setMessage( R.string.ids_endnow )
                    .setPositiveButton( R.string.button_yes,
                                        new DialogInterface.OnClickListener() {
                                            public void 
                                                onClick( DialogInterface dlg, 
                                                         int item ) {
                                                m_jniThread.
                                                    handle(JNICmd.CMD_ENDGAME);
                                            }
                                        })
                    .setNegativeButton( R.string.button_no, null )
                    .create();
                break;
            case DLG_INVITE:
                if ( null != m_room ) {
                    lstnr = new DialogInterface.OnClickListener() {
                            public void onClick( DialogInterface dialog, 
                                                 int item ) {
                                showTextOrHtmlThen( LAUNCH_INVITE_ACTION );
                            }
                        };
                    dialog = new AlertDialog.Builder( this )
                        .setTitle( R.string.query_title )
                        .setMessage( """" )
                        .setPositiveButton( R.string.button_yes, lstnr )
                        .setNegativeButton( R.string.button_no, null )
                        .create();
                }
                break;
            default:
                // just drop it; super.onCreateDialog likely failed
                break;
            }
        }
        return dialog;
    } // onCreateDialog

    @Override
    public void onPrepareDialog( int id, Dialog dialog )
    {
        switch( id ) {
        case DLG_INVITE:
            AlertDialog ad = (AlertDialog)dialog;
            String format = getString( R.string.invite_msgf );
            String message = String.format( format, m_missing );
            if ( m_missing > 1 ) {
                message += getString( R.string.invite_multiple );
            }
            ad.setMessage( message );
            break;
        default:
            super.onPrepareDialog( id, dialog );
            break;
        }
    }

    @Override
    protected void onCreate( Bundle savedInstanceState ) 
    {
        super.onCreate( savedInstanceState );
        getBundledData( savedInstanceState );

        if ( CommonPrefs.getHideTitleBar( this ) ) {
            requestWindowFeature( Window.FEATURE_NO_TITLE );
        }

        m_utils = new BoardUtilCtxt();
        m_jniu = JNIUtilsImpl.get();
        setContentView( R.layout.board );
        m_timers = new TimerRunnable[4]; // needs to be in sync with
                                         // XWTimerReason
        m_view = (BoardView)findViewById( R.id.board_view );
        m_tradeButtons = findViewById( R.id.exchange_buttons );
        m_exchCommmitButton = (Button)findViewById( R.id.exchange_commit );
        m_exchCommmitButton.setOnClickListener( this );
        m_exchCancelButton = (Button)findViewById( R.id.exchange_cancel );
        m_exchCancelButton.setOnClickListener( this );
        m_volKeysZoom = CommonPrefs.getVolKeysZoom( this );

        Intent intent = getIntent();
        m_rowid = intent.getLongExtra( INTENT_KEY_ROWID, -1 );
        m_haveInvited = intent.getBooleanExtra( GameUtils.INVITED, false );

        setBackgroundColor();
        setKeepScreenOn();
    } // onCreate

    @Override
    protected void onPause()
    {
        m_handler = null;
        waitCloseGame( true );
        super.onPause();
    }

    @Override
    protected void onResume()
    {
        super.onResume();
        m_handler = new Handler();
        m_blockingDlgPosted = false;

        setKeepScreenOn();

        loadGame();
    }

    @Override
    protected void onSaveInstanceState( Bundle outState ) 
    {
        super.onSaveInstanceState( outState );
        outState.putInt( DLG_TITLESTR, m_dlgTitle );
        outState.putString( DLG_TITLESTR, m_dlgTitleStr );
        outState.putString( DLG_BYTES, m_dlgBytes );
        outState.putString( ROOM, m_room );
        outState.putString( TOASTSTR, m_toastStr );
    }

    private void getBundledData( Bundle bundle )
    {
        if ( null != bundle ) {
            m_dlgTitleStr = bundle.getString( DLG_TITLESTR  );
            m_dlgTitle = bundle.getInt( DLG_TITLE  );
            m_dlgBytes = bundle.getString( DLG_BYTES );
            m_room = bundle.getString( ROOM );
            m_toastStr = bundle.getString( TOASTSTR );
        }
    }

    @Override
    protected void onActivityResult( int requestCode, int resultCode, Intent data )
    {
        if ( Activity.RESULT_CANCELED != resultCode ) {
            if ( CHAT_REQUEST == requestCode ) {
                String msg = data.getStringExtra( INTENT_KEY_CHAT );
                if ( null != msg && msg.length() > 0 ) {
                    m_pendingChats.add( msg );
                    trySendChats();
                }
            }
        }
    }

    @Override
    public void onWindowFocusChanged( boolean hasFocus )
    {
        super.onWindowFocusChanged( hasFocus );
        if ( hasFocus ) {
            if ( m_firingPrefs ) {
                m_firingPrefs = false;
                m_volKeysZoom = CommonPrefs.getVolKeysZoom( this );
                if ( null != m_jniThread ) {
                    m_jniThread.handle( JNIThread.JNICmd.CMD_PREFS_CHANGE );
                }
                // in case of change...
                setBackgroundColor();
                setKeepScreenOn();
            }
        }
    }

    @Override
    public boolean onKeyDown( int keyCode, KeyEvent event )
    {
        boolean handled = false;
        if ( null != m_jniThread ) {
            XwJNI.XP_Key xpKey = keyCodeToXPKey( keyCode );
            if ( XwJNI.XP_Key.XP_KEY_NONE != xpKey ) {
                m_jniThread.handle( JNIThread.JNICmd.CMD_KEYDOWN, xpKey );
            } else {
                switch( keyCode ) {
                case KeyEvent.KEYCODE_VOLUME_DOWN:
                case KeyEvent.KEYCODE_VOLUME_UP:
                    if ( m_volKeysZoom ) {
                        int zoomBy = KeyEvent.KEYCODE_VOLUME_DOWN == keyCode
                            ? -2 : 2;
                        handled = doZoom( zoomBy );
                    }
                    break;
                }
            }
        }
        return handled || super.onKeyDown( keyCode, event );
    }

    @Override
    public boolean onKeyUp( int keyCode, KeyEvent event )
    {
        if ( null != m_jniThread ) {
            XwJNI.XP_Key xpKey = keyCodeToXPKey( keyCode );
            if ( XwJNI.XP_Key.XP_KEY_NONE != xpKey ) {
                m_jniThread.handle( JNIThread.JNICmd.CMD_KEYUP, xpKey );
            }
        }
        return super.onKeyUp( keyCode, event );
    }

    @Override
    public boolean onCreateOptionsMenu( Menu menu ) 
    {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.board_menu, menu );

        // For now undo-last can crash the app or break a game in
        // networked case.  Disable until this is fixed.
        if ( m_gi.serverRole != DeviceRole.SERVER_STANDALONE ) {
            menu.removeItem( R.id.board_menu_undo_last );
        }
        return true;
    }

    @Override
    public boolean onPrepareOptionsMenu( Menu menu ) 
    {
        super.onPrepareOptionsMenu( menu );

        if ( null != m_gsi ) {
            boolean inTrade = m_gsi.inTrade;
            menu.setGroupVisible( R.id.group_done, !inTrade );
        }

        return true;
    }

    public boolean onOptionsItemSelected( MenuItem item ) 
    {
        boolean handled = true;
        JNIThread.JNICmd cmd = JNIThread.JNICmd.CMD_NONE;
        Runnable proc = null;

        int id = item.getItemId();
        switch ( id ) {
        case R.id.board_menu_done:
            showNotAgainDlgThen( R.string.not_again_done, 
                                 R.string.key_notagain_done, COMMIT_ACTION );
            break;
        // case R.id.board_menu_juggle:
        //     cmd = JNIThread.JNICmd.CMD_JUGGLE;
        //     break;
        // case R.id.board_menu_flip:
        //     cmd = JNIThread.JNICmd.CMD_FLIP;
        //     break;
        case R.id.board_menu_trade:
            showNotAgainDlgThen( R.string.not_again_trading, 
                                 R.string.key_notagain_trading,
                                 START_TRADE_ACTION );
            break;

        case R.id.board_menu_tray:
            cmd = JNIThread.JNICmd.CMD_TOGGLE_TRAY;
            break;
        // case R.id.board_menu_undo_current:
        //     cmd = JNIThread.JNICmd.CMD_UNDO_CUR;
        //     break;
        case R.id.board_menu_undo_last:
            showConfirmThen( R.string.confirm_undo_last, UNDO_LAST_ACTION );
            break;
        case R.id.board_menu_values:
            cmd = JNIThread.JNICmd.CMD_VALUES;
            break;

        case R.id.board_menu_game_counts:
            m_jniThread.handle( JNIThread.JNICmd.CMD_COUNTS_VALUES,
                                R.string.counts_values_title );
            break;
        case R.id.board_menu_game_left:
            m_jniThread.handle( JNIThread.JNICmd.CMD_REMAINING,
                                R.string.tiles_left_title );
            break;
        case R.id.board_menu_game_history:
            m_jniThread.handle( JNIThread.JNICmd.CMD_HISTORY,
                                R.string.history_title );
            break;

        case R.id.board_menu_game_final:
            m_jniThread.handle( JNIThread.JNICmd.CMD_FINAL,
                                R.string.history_title );
            break;

        case R.id.board_menu_game_resend:
            m_jniThread.handle( JNIThread.JNICmd.CMD_RESEND );
            break;

        case R.id.gamel_menu_checkmoves:
            showNotAgainDlgThen( R.string.not_again_sync,
                                 R.string.key_notagain_sync,
                                 SYNC_ACTION );
            break;

        case R.id.board_menu_file_prefs:
            m_firingPrefs = true;
            startActivity( new Intent( this, PrefsActivity.class ) );
            break;

        case R.id.board_menu_file_about:
            showAboutDialog();
            break;

        default:
            Utils.logf( ""menuitem %d not handled"", id );
            handled = false;
        }

        if ( handled && cmd != JNIThread.JNICmd.CMD_NONE ) {
            m_jniThread.handle( cmd );
        }
        return handled;
    }

    //////////////////////////////////////////////////
    // DlgDelegate.DlgClickNotify interface
    //////////////////////////////////////////////////
    @Override
    public void dlgButtonClicked( int id, int which )
    {
        if ( LAUNCH_INVITE_ACTION == id ) {
            if ( DlgDelegate.DISMISS_BUTTON != which ) {
                GameUtils.launchInviteActivity( BoardActivity.this,
                                                DlgDelegate.TEXT_BTN == which,
                                                m_room,
                                                m_gi.dictLang,
                                                m_gi.nPlayers );
            }
        } else if ( AlertDialog.BUTTON_POSITIVE == which ) {
            JNIThread.JNICmd cmd = JNIThread.JNICmd.CMD_NONE;
            switch ( id ) {
            case UNDO_LAST_ACTION:
                cmd = JNIThread.JNICmd.CMD_UNDO_LAST;
                break;
            case SYNC_ACTION:
                doSyncMenuitem();
                break;
            case COMMIT_ACTION:
                cmd = JNIThread.JNICmd.CMD_COMMIT;
                break;
            case SHOW_EXPL_ACTION:
                Toast.makeText( BoardActivity.this, m_toastStr, 
                                Toast.LENGTH_SHORT).show();
                m_toastStr = null;
                break;
            case PREV_HINT_ACTION:
                cmd = JNIThread.JNICmd.CMD_PREV_HINT;
                break;
            case NEXT_HINT_ACTION:
                cmd = JNIThread.JNICmd.CMD_NEXT_HINT;
                break;
            case JUGGLE_ACTION:
                cmd = JNIThread.JNICmd.CMD_JUGGLE;
                break;
            case FLIP_ACTION:
                cmd = JNIThread.JNICmd.CMD_FLIP;
                break;
            case ZOOM_ACTION:
                cmd = JNIThread.JNICmd.CMD_TOGGLEZOOM;
                break;
            case UNDO_ACTION:
                cmd = JNIThread.JNICmd.CMD_UNDO_CUR;
                break;
            case CHAT_ACTION:
                startChatActivity();
                break;
            case START_TRADE_ACTION:
                Toast.makeText( this, R.string.entering_trade,
                                Toast.LENGTH_SHORT).show();
                cmd = JNIThread.JNICmd.CMD_TRADE;
                break;
            default:
                Assert.fail();
            }

            if ( JNIThread.JNICmd.CMD_NONE != cmd ) {
                checkAndHandle( cmd );
            }
        }
    }

    //////////////////////////////////////////////////
    // View.OnClickListener interface
    //////////////////////////////////////////////////
    @Override
    public void onClick( View view ) 
    {
        if ( view == m_exchCommmitButton ) {
            m_jniThread.handle( JNIThread.JNICmd.CMD_COMMIT );
        } else if ( view == m_exchCancelButton ) {
            m_jniThread.handle( JNIThread.JNICmd.CMD_CANCELTRADE );
        }
    }

    //////////////////////////////////////////////////
    // TransportProcs.TPMsgHandler interface
    //////////////////////////////////////////////////

    public void tpmRelayConnd( final String room, final int devOrder,
                               final boolean allHere, final int nMissing )
    {
        post( new Runnable() {
                public void run() {
                    handleConndMessage( room, devOrder, allHere, nMissing );
                }
            } );
    }

    public void tpmRelayErrorProc( TransportProcs.XWRELAY_ERROR relayErr )
    {
        int strID = -1;
        int dlgID = -1;
        boolean doToast = false;

        switch ( relayErr ) {
        case TOO_MANY:
            strID = R.string.msg_too_many;
            dlgID = DLG_OKONLY;
            break;
        case NO_ROOM:
            strID = R.string.msg_no_room;
            dlgID = DLG_RETRY;
            break;
        case DUP_ROOM:
            strID = R.string.msg_dup_room;
            dlgID = DLG_OKONLY;
            break;
        case LOST_OTHER:
        case OTHER_DISCON:
            strID = R.string.msg_lost_other;
            doToast = true;
            break;

        case DEADGAME:
        case DELETED:
            strID = R.string.msg_dev_deleted;
            dlgID = DLG_DELETED;
            break;

        case OLDFLAGS:
        case BADPROTO:
        case RELAYBUSY:
        case SHUTDOWN:
        case TIMEOUT:
        case HEART_YOU:
        case HEART_OTHER:
            break;
        }

        if ( doToast ) {
            Toast.makeText( this, getString( strID ), 
                            Toast.LENGTH_SHORT).show();
        } else if ( dlgID >= 0 ) {
            final int strIDf = strID;
            final int dlgIDf = dlgID;
            post( new Runnable() {
                    public void run() {
                        m_dlgBytes = getString( strIDf );
                        m_dlgTitle = R.string.relay_alert;
                        showDialog( dlgIDf );
                    }
                });
        }
    }

    private XwJNI.XP_Key keyCodeToXPKey( int keyCode )
    {
        XwJNI.XP_Key xpKey = XwJNI.XP_Key.XP_KEY_NONE;
        switch( keyCode ) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            xpKey = XwJNI.XP_Key.XP_RETURN_KEY;
            break;
        case KeyEvent.KEYCODE_DPAD_DOWN:
            xpKey = XwJNI.XP_Key.XP_CURSOR_KEY_DOWN;
            break;
        case KeyEvent.KEYCODE_DPAD_LEFT:
            xpKey = XwJNI.XP_Key.XP_CURSOR_KEY_LEFT;
            break;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            xpKey = XwJNI.XP_Key.XP_CURSOR_KEY_RIGHT;
            break;
        case KeyEvent.KEYCODE_DPAD_UP:         
            xpKey = XwJNI.XP_Key.XP_CURSOR_KEY_UP;
            break;
        case KeyEvent.KEYCODE_SPACE:         
            xpKey = XwJNI.XP_Key.XP_RAISEFOCUS_KEY;
            break;
        }
        return xpKey;
    }

    // Blocking thread stuff: The problem this is solving occurs when
    // you have a blocking dialog up, meaning the jni thread is
    // blocked, and you hit the home button.  onPause() gets called
    // which wants to use jni calls to e.g. summarize.  For those to
    // succeed (the jni being non-reentrant and set up to assert if it
    // is reentered) the jni thread must first be unblocked and
    // allowed to return back through the jni.  We unblock using
    // Thread.interrupt method, the exception from which winds up
    // caught in waitBlockingDialog.  The catch dismisses the dialog
    // with the default/cancel value, but that takes us into the
    // onDismissListener which normally releases the semaphore.  But
    // if we've interrupted then we can't release it or blocking won't
    // work for as long as this activity lives.  Hence
    // releaseIfBlocking().  This feels really fragile but it does
    // work.
    private void setBlockingThread()
    {
        synchronized( this ) {
            Assert.assertTrue( null == m_blockingThread );
            m_blockingThread = Thread.currentThread();
        }
    }

    private void clearBlockingThread()
    {
        synchronized( this ) {
            Assert.assertTrue( null != m_blockingThread );
            m_blockingThread = null;
        }
    }

    private void interruptBlockingThread()
    {
        synchronized( this ) {
            if ( null != m_blockingThread ) {
                m_blockingThread.interrupt();
            }
        }
    }

    private void releaseIfBlocking()
    {
        synchronized( this ) {
            if ( null != m_blockingThread ) {
                m_forResultWait.release();
            }
        }
    }

    private void handleConndMessage( String room, int devOrder, // <- hostID
                                     boolean allHere, int nMissing )
    {
        int naMsg = 0;
        int naKey = 0;
        String str = null;
        if ( allHere ) {
            // All players have now joined the game.  The device that
            // created the room will assign tiles.  Then it will be
            // the first player's turn
            String fmt = getString( R.string.msg_relay_all_heref );
            str = String.format( fmt, room );
            if ( devOrder > 1 ) {
                naMsg = R.string.not_again_conndall;
                naKey = R.string.key_notagain_conndall;
            }
        } else if ( nMissing > 0 ) {

            // Let's only invite for two-person games for now.  Simple
            // case first....
            if ( !m_haveInvited ) {
                m_haveInvited = true;
                m_room = room;
                m_missing = nMissing;
                showDialog( DLG_INVITE );
            } else {
                String fmt = getString( R.string.msg_relay_waiting );
                str = String.format( fmt, devOrder,
                                     room, nMissing );
                if ( devOrder == 1 ) {
                    naMsg = R.string.not_again_conndfirst;
                    naKey = R.string.key_notagain_conndfirst;
                } else {
                    naMsg = R.string.not_again_conndmid;
                    naKey = R.string.key_notagain_conndmid;
                }
            }
        }

        if ( null != str ) {
            m_toastStr = str;
            if ( naMsg == 0 ) {
                dlgButtonClicked( SHOW_EXPL_ACTION, 
                                  AlertDialog.BUTTON_POSITIVE );
            } else {
                showNotAgainDlgThen( naMsg, naKey, SHOW_EXPL_ACTION );
            }
        }
    } // handleConndMessage

    private class BoardUtilCtxt extends UtilCtxtImpl {

        public BoardUtilCtxt()
        {
            super( BoardActivity.this );
        }

        public void requestTime() 
        {
            post( new Runnable() {
                    public void run() {
                        if ( null != m_jniThread ) {
                            m_jniThread.handle( JNIThread.JNICmd.CMD_DO, false );
                        }
                    }
                } );
        }

        public void remSelected() 
        {
            m_jniThread.handle( JNIThread.JNICmd.CMD_REMAINING,
                                R.string.tiles_left_title );
        }

        public void setIsServer( boolean isServer )
        {
            DeviceRole newRole = isServer? DeviceRole.SERVER_ISSERVER
                : DeviceRole.SERVER_ISCLIENT;
            if ( newRole != m_gi.serverRole ) {
                Utils.logf( ""new role: %s; old role: %s"", 
                            newRole.toString(), m_gi.serverRole.toString() );
                m_gi.serverRole = newRole;
                if ( !isServer ) {
                    m_jniThread.handle( JNIThread.JNICmd.CMD_SWITCHCLIENT );
                }
            }
        }

        @Override
        public void bonusSquareHeld( int bonus )
        {
            int id = 0;
            switch( bonus ) {
            case BONUS_DOUBLE_LETTER:
                id = R.string.bonus_l2x;
                break;
            case BONUS_DOUBLE_WORD:
                id = R.string.bonus_w2x;
                break;
            case BONUS_TRIPLE_LETTER:
                id = R.string.bonus_l3x;
                break;
            case BONUS_TRIPLE_WORD:
                id = R.string.bonus_w3x;
                break;
            default:
                Assert.fail();
            }

            if ( 0 != id ) {
                final String bonusStr = getString( id );
                post( new Runnable() {
                        public void run() {
                            Toast.makeText( BoardActivity.this, bonusStr,
                                            Toast.LENGTH_SHORT).show();
                        }
                    } );
            }
        }

        @Override
        public void playerScoreHeld( int player )
        {
            String expl = XwJNI.model_getPlayersLastScore( m_jniGamePtr, 
                                                            player );
            if ( expl.length() == 0 ) {
                expl = getString( R.string.no_moves_made );
            }
            String name = m_gi.players[player].name;
            final String text = String.format( ""%s\n%s"", name, expl );
            post( new Runnable() {
                    public void run() {
                        Toast.makeText( BoardActivity.this, text,
                                        Toast.LENGTH_SHORT).show();
                    }
                } );
        }

        public void setTimer( int why, int when, int handle )
        {
            if ( null != m_timers[why] ) {
                removeCallbacks( m_timers[why] );
            }

            m_timers[why] = new TimerRunnable( why, when, handle );

            int inHowLong;
            switch ( why ) {
            case UtilCtxt.TIMER_COMMS:
                inHowLong = when * 1000;
                break;
            case UtilCtxt.TIMER_TIMERTICK:
                inHowLong = 1000;   // when is 0 for TIMER_TIMERTICK
                break;
            default:
                inHowLong = 500;
            }
            postDelayed( m_timers[why], inHowLong );
        }

        public void clearTimer( int why ) 
        {
            if ( null != m_timers[why] ) {
                removeCallbacks( m_timers[why] );
                m_timers[why] = null;
            }
        }

        // This is supposed to be called from the jni thread
        public int userPickTile( int playerNum, String[] texts )
        {
            m_texts = texts;
            waitBlockingDialog( PICK_TILE_REQUEST_BLK, 0 );
            return m_resultCode;
        }

        public String askPassword( String name )
        {
            String fmt = getString( R.string.msg_ask_password );
            m_dlgTitleStr = String.format( fmt, name );

            if ( null == m_passwdEdit ) {
                m_passwdLyt = 
                    (LinearLayout)Utils.inflate( BoardActivity.this,
                                                  R.layout.passwd_view );
                m_passwdEdit = (EditText)m_passwdLyt.findViewById( R.id.edit );
            }
            waitBlockingDialog( ASK_PASSWORD_BLK, 0 );

            String result = null;      // means cancelled
            if ( 0 != m_resultCode ) {
                result = m_passwdEdit.getText().toString();
            }
            return result;
        }

        public void turnChanged()
        {
            post( new Runnable() {
                    public void run() {
                        showNotAgainDlgThen( R.string.not_again_turnchanged, 
                                             R.string.key_notagain_turnchanged );
                    }
                } );
            m_jniThread.handle( JNIThread.JNICmd. CMD_ZOOM, -8 );
        }

        public boolean engineProgressCallback()
        {
            return ! m_jniThread.busy();
        }

        public boolean userQuery( int id, String query )
        {
            boolean result;

            switch( id ) {
                // Though robot-move dialogs don't normally need to block,
                // if the player after this one is also a robot and we
                // don't block then a second dialog will replace this one.
                // So block.  Yuck.
            case UtilCtxt.QUERY_ROBOT_MOVE:
            case UtilCtxt.QUERY_ROBOT_TRADE:
                m_dlgBytes = query;
                m_dlgTitle = R.string.info_title;
                waitBlockingDialog( QUERY_INFORM_BLK, 0 );
                result = true;
                break;

                // These *are* blocking dialogs
            case UtilCtxt.QUERY_COMMIT_TRADE:
            case UtilCtxt.QUERY_COMMIT_TURN:
                if ( UtilCtxt.QUERY_COMMIT_TRADE == id ) {
                    m_dlgBytes = getString( R.string.query_trade );
                } else {
                    m_dlgBytes = query;
                }
                m_dlgTitle = R.string.query_title;
                result = 0 != waitBlockingDialog( QUERY_REQUEST_BLK, 0 );
                break;
            default:
                Assert.fail();
                result = false;
            }

            return result;
        }

        public void userError( int code )
        {
            int resid = 0;
            switch( code ) {
            case UtilCtxt.ERR_TILES_NOT_IN_LINE:
                resid = R.string.str_tiles_not_in_line;
                break;
            case UtilCtxt.ERR_NO_EMPTIES_IN_TURN:
                resid = R.string.str_no_empties_in_turn;
                break;
            case UtilCtxt.ERR_TWO_TILES_FIRST_MOVE:
                resid = R.string.str_two_tiles_first_move;
                break;
            case UtilCtxt.ERR_TILES_MUST_CONTACT:
                resid = R.string.str_tiles_must_contact;
                break;
            case UtilCtxt.ERR_NOT_YOUR_TURN:
                resid = R.string.str_not_your_turn;
                break;
            case UtilCtxt.ERR_NO_PEEK_ROBOT_TILES:
                resid = R.string.str_no_peek_robot_tiles;
                break;
            case UtilCtxt.ERR_NO_EMPTY_TRADE:
                // This should not be possible as the button's
                // disabled when no tiles selected.
                Assert.fail();
                break;
            case UtilCtxt.ERR_TOO_FEW_TILES_LEFT_TO_TRADE:
                resid = R.string.str_too_few_tiles_left_to_trade;
                break;
            case UtilCtxt.ERR_CANT_UNDO_TILEASSIGN:
                resid = R.string.str_cant_undo_tileassign;
                break;
            case UtilCtxt.ERR_CANT_HINT_WHILE_DISABLED:
                resid = R.string.str_cant_hint_while_disabled;
                break;
            case UtilCtxt.ERR_NO_PEEK_REMOTE_TILES:
                resid = R.string.str_no_peek_remote_tiles;
                break;
            case UtilCtxt.ERR_REG_UNEXPECTED_USER:
                resid = R.string.str_reg_unexpected_user;
                break;
            case UtilCtxt.ERR_SERVER_DICT_WINS:
                resid = R.string.str_server_dict_wins;
                break;
            case ERR_REG_SERVER_SANS_REMOTE:
                resid = R.string.str_reg_server_sans_remote;
                break;
            }

            if ( resid != 0 ) {
                nonBlockingDialog( DLG_OKONLY, getString( resid ) );
            }
        } // userError

        public void notifyGameOver()
        {
            m_jniThread.handle( JNIThread.JNICmd.CMD_POST_OVER );
        }

        // public void yOffsetChange( int maxOffset, int oldOffset, int newOffset )
        // {
        //     Utils.logf( ""yOffsetChange(maxOffset=%d)"", maxOffset );
        //     m_view.setVerticalScrollBarEnabled( maxOffset > 0 );
        // }

        public boolean warnIllegalWord( String[] words, int turn, 
                                        boolean turnLost )
        {
            Utils.logf( ""warnIllegalWord"" );
            boolean accept = turnLost;

            StringBuffer sb = new StringBuffer();
            for ( int ii = 0; ; ) {
                sb.append( words[ii] );
                if ( ++ii == words.length ) {
                    break;
                }
                sb.append( ""; "" );
            }
        
            String format = getString( R.string.ids_badwords );
            String message = String.format( format, sb.toString() );

            if ( turnLost ) {
                nonBlockingDialog( DLG_BADWORDS, 
                                   message + getString(R.string.badwords_lost) );
            } else {
                m_dlgBytes = message + getString( R.string.badwords_accept );
                m_dlgTitle = R.string.query_title;
                accept = 0 != waitBlockingDialog( QUERY_REQUEST_BLK, 0 );
            }

            Utils.logf( ""warnIllegalWord=>%b"", accept );
            return accept;
        }

        // Let's have this block in case there are multiple messages.  If
        // we don't block the jni thread will continue processing messages
        // and may stack dialogs on top of this one.  Including later
        // chat-messages.
        public void showChat( final String msg )
        {
            post( new Runnable() {
                    public void run() {
                        DBUtils.appendChatHistory( BoardActivity.this, 
                                                   m_rowid, msg, false );
                        startChatActivity();
                    }
                } );
        }
    } // class BoardUtilCtxt 

    private void loadGame()
    {
        if ( 0 == m_jniGamePtr ) {
            String[] dictNames = GameUtils.dictNames( this, m_rowid );
            DictUtils.DictPairs pairs = DictUtils.openDicts( this, dictNames );

            if ( pairs.anyMissing( dictNames ) ) {
                showDictGoneFinish();
            } else {
                Assert.assertNull( m_gameLock );
                m_gameLock = new GameUtils.GameLock( m_rowid, true ).lock();

                byte[] stream = GameUtils.savedGame( this, m_gameLock );
                m_gi = new CurGameInfo( this );
                XwJNI.gi_from_stream( m_gi, stream );
                String langName = m_gi.langName();

                m_jniGamePtr = XwJNI.initJNI();

                if ( m_gi.serverRole != DeviceRole.SERVER_STANDALONE ) {
                    m_xport = new CommsTransport( m_jniGamePtr, this, this, 
                                                  m_gi.serverRole );
                }

                CommonPrefs cp = CommonPrefs.get( this );
                if ( null == stream ||
                     ! XwJNI.game_makeFromStream( m_jniGamePtr, stream, 
                                                  m_gi, dictNames, pairs.m_bytes, 
                                                  pairs.m_paths, langName, m_utils,
                                                  m_jniu, m_view, cp, m_xport ) ) {
                    XwJNI.game_makeNewGame( m_jniGamePtr, m_gi, m_utils, m_jniu, 
                                            m_view, cp, m_xport, dictNames, 
                                            pairs.m_bytes, pairs.m_paths,
                                            langName );
                }

                Handler handler = new Handler() {
                        public void handleMessage( Message msg ) {
                            switch( msg.what ) {
                            case JNIThread.DRAW:
                                m_view.invalidate();
                                break;
                            case JNIThread.DIALOG:
                                m_dlgBytes = (String)msg.obj;
                                m_dlgTitle = msg.arg1;
                                showDialog( DLG_OKONLY );
                                break;
                            case JNIThread.QUERY_ENDGAME:
                                showDialog( QUERY_ENDGAME );
                                break;
                            case JNIThread.TOOLBAR_STATES:
                                if ( null != m_jniThread ) {
                                    m_gsi = 
                                        m_jniThread.getGameStateInfo();
                                    updateToolbar();
                                    if ( m_inTrade != m_gsi.inTrade ) {
                                        m_inTrade = m_gsi.inTrade;
                                        m_view.setInTrade( m_inTrade );
                                    }
                                    adjustTradeVisibility();
                                }
                                break;
                            }
                        }
                    };
                m_jniThread = new JNIThread( m_jniGamePtr, m_gi, m_view, 
                                             m_gameLock, this, handler );
                // see http://stackoverflow.com/questions/680180/where-to-stop-\
                // destroy-threads-in-android-service-class
                m_jniThread.setDaemon( true );
                m_jniThread.start();

                m_view.startHandling( this, m_jniThread, m_jniGamePtr, m_gi );
                if ( null != m_xport ) {
                    m_xport.setReceiver( m_jniThread );
                }
                m_jniThread.handle( JNICmd.CMD_START );

                if ( !CommonPrefs.getHideTitleBar( this ) ) {
                    setTitle( GameUtils.getName( this, m_rowid ) );
                }
                m_toolbar = new Toolbar( this, R.id.toolbar_horizontal );

                populateToolbar();
                adjustTradeVisibility();

                int flags = DBUtils.getMsgFlags( this, m_rowid );
                if ( 0 != (GameSummary.MSG_FLAGS_CHAT & flags) ) {
                    startChatActivity();
                }
                if ( 0 != (GameSummary.MSG_FLAGS_GAMEOVER & flags) ) {
                    m_jniThread.handle( JNIThread.JNICmd.CMD_POST_OVER );
                }
                if ( 0 != flags ) {
                    DBUtils.setMsgFlags( m_rowid, GameSummary.MSG_FLAGS_NONE );
                }

                trySendChats();
            }
        }
    } // loadGame

    private void checkAndHandle( JNIThread.JNICmd cmd )
    {
        if ( null != m_jniThread ) {
            m_jniThread.handle( cmd );
        }
    }

    private void populateToolbar()
    {
        m_toolbar.setListener( Toolbar.BUTTON_HINT_PREV, 
                               R.string.not_again_hintprev,
                               R.string.key_notagain_hintprev,
                               PREV_HINT_ACTION );
        m_toolbar.setListener( Toolbar.BUTTON_HINT_NEXT,
                               R.string.not_again_hintnext,
                               R.string.key_notagain_hintnext,
                               NEXT_HINT_ACTION );
        m_toolbar.setListener( Toolbar.BUTTON_JUGGLE,
                               R.string.not_again_juggle,
                               R.string.key_notagain_juggle,
                               JUGGLE_ACTION );
        m_toolbar.setListener( Toolbar.BUTTON_FLIP,
                               R.string.not_again_flip,
                               R.string.key_notagain_flip,
                               FLIP_ACTION );
        m_toolbar.setListener( Toolbar.BUTTON_ZOOM,
                               R.string.not_again_zoom,
                               R.string.key_notagain_zoom,
                               ZOOM_ACTION );
        m_toolbar.setListener( Toolbar.BUTTON_UNDO,
                               R.string.not_again_undo,
                               R.string.key_notagain_undo,
                               UNDO_ACTION );
        m_toolbar.setListener( Toolbar.BUTTON_CHAT,
                               R.string.not_again_chat, 
                               R.string.key_notagain_chat,
                               CHAT_ACTION );
    } // populateToolbar

    private OnDismissListener makeODLforBlocking( final int id )
    {
        return new OnDismissListener() {
            public void onDismiss( DialogInterface di ) {
                releaseIfBlocking();
                removeDialog( id );
            }
        };
    }

    private int waitBlockingDialog( final int dlgID, int cancelResult )
    {
        int result = cancelResult;
        if ( m_blockingDlgPosted ) { // this has been true; dunno why
            Utils.logf( ""waitBlockingDialog: dropping dlgID %d"", dlgID );
        } else {
            setBlockingThread();
            m_resultCode = cancelResult;

            if ( post( new Runnable() {
                    public void run() {
                        showDialog( dlgID );
                        m_blockingDlgPosted = true;
                    }
                } ) ) {

                try {
                    m_forResultWait.acquire();
                    m_blockingDlgPosted = false;
                } catch ( java.lang.InterruptedException ie ) {
                    Utils.logf( ""waitBlockingDialog: got %s"", ie.toString() );
                    if ( m_blockingDlgPosted ) {
                        dismissDialog( dlgID );
                        m_blockingDlgPosted = false;
                    }
                }
            }

            clearBlockingThread();
            result = m_resultCode;
        }
        return result;
    }

    private void nonBlockingDialog( final int dlgID, String txt ) 
    {
        switch ( dlgID ) {
        case DLG_OKONLY:
            m_dlgTitle = R.string.info_title;
            break;
        case DLG_BADWORDS:
            m_dlgTitle = R.string.badwords_title;
            break;
        default:
            Assert.fail();
        }

        m_dlgBytes = txt;
        post( new Runnable() {
                public void run() {
                    showDialog( dlgID );
                }
            } );
    }

    private boolean doZoom( int zoomBy )
    {
        boolean handled = null != m_jniThread;
        if ( handled ) {
            m_jniThread.handle( JNIThread.JNICmd.CMD_ZOOM, zoomBy );
        }
        return handled;
    }

    private void startChatActivity()
    {
        Intent intent = new Intent( this, ChatActivity.class );
        intent.putExtra( BoardActivity.INTENT_KEY_ROWID, m_rowid );
        startActivityForResult( intent, CHAT_REQUEST );
    }

    private void waitCloseGame( boolean save ) 
    {
        if ( 0 != m_jniGamePtr ) {
            if ( null != m_xport ) {
                m_xport.waitToStop();
                m_xport = null;
            }

            interruptBlockingThread();

            if ( null != m_jniThread ) {
                m_jniThread.waitToStop( save );
                m_jniThread = null;
            }

            XwJNI.game_dispose( m_jniGamePtr );
            m_jniGamePtr = 0;
            m_gi = null;

            m_gameLock.unlock();
            m_gameLock = null;
        }
    }

    private void trySendChats()
    {
        if ( null != m_jniThread ) {
            Iterator<String> iter = m_pendingChats.iterator();
            while ( iter.hasNext() ) {
                m_jniThread.handle( JNICmd.CMD_SENDCHAT, iter.next() );
            }
            m_pendingChats.clear();
        }
    }

    private void updateToolbar()
    {
        m_toolbar.update( Toolbar.BUTTON_FLIP, m_gsi.visTileCount > 1 );
        m_toolbar.update( Toolbar.BUTTON_JUGGLE, m_gsi.canShuffle );
        m_toolbar.update( Toolbar.BUTTON_UNDO, m_gsi.canRedo );
        m_toolbar.update( Toolbar.BUTTON_HINT_PREV, m_gsi.canHint );
        m_toolbar.update( Toolbar.BUTTON_HINT_NEXT, m_gsi.canHint );
        m_toolbar.update( Toolbar.BUTTON_CHAT, m_gsi.gameIsConnected );
    }

    private void adjustTradeVisibility()
    {
        m_toolbar.setVisibility( m_inTrade? View.GONE : View.VISIBLE );
        m_tradeButtons.setVisibility( m_inTrade? View.VISIBLE : View.GONE );
        if ( m_inTrade ) {
            m_exchCommmitButton.setEnabled( m_gsi.tradeTilesSelected );
        }
    }

    private void setBackgroundColor()
    {
        int back = CommonPrefs.get(this)
            .otherColors[CommonPrefs.COLOR_BACKGRND];
        m_view.getRootView().setBackgroundColor( back );
    }

    private void setKeepScreenOn()
    {
        boolean keepOn = CommonPrefs.getKeepScreenOn( this );
        m_view.setKeepScreenOn( keepOn );

        if ( keepOn ) {
            if ( null == m_screenTimer ) {
                m_screenTimer = new Runnable() {
                        public void run() {
                            Utils.logf( ""run() called for setKeepScreenOn()"" );
                            if ( null != m_view ) {
                                m_view.setKeepScreenOn( false );
                            }
                        }
                    };
            }
            removeCallbacks( m_screenTimer ); // needed?
            postDelayed( m_screenTimer, SCREEN_ON_TIME );
        }
    }

    private boolean post( Runnable runnable )
    {
        boolean canPost = null != m_handler;
        if ( canPost ) {
            m_handler.post( runnable );
        } else {
            Utils.logf( ""post: dropping because handler null"" );
        }
        return canPost;
    }

    private void postDelayed( Runnable runnable, int when )
    {
        if ( null != m_handler ) {
            m_handler.postDelayed( runnable, when );
        } else {
            Utils.logf( ""postDelayed: dropping %d because handler null"", when );
        }
    }

    private void removeCallbacks( Runnable which )
    {
        if ( null != m_handler ) {
            m_handler.removeCallbacks( which );
        } else {
            Utils.logf( ""removeCallbacks: dropping %h because handler null"", 
                        which );
        }
    }
} // class BoardActivity
",True,36,41,2,3,2,20,4,20,L1
29,org.eehouse.android.xw4.PollListPreference.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.preference.Preference;
import android.preference.ListPreference;
import android.content.Context;
import android.util.AttributeSet;
import junit.framework.Assert;


public class PollListPreference extends ListPreference
    implements Preference.OnPreferenceChangeListener {

    private Context m_context;

    public PollListPreference( Context context, AttributeSet attrs )
    {
        super( context, attrs );
        m_context = context;
        setOnPreferenceChangeListener( this );
    }

    @Override
    protected void onAttachedToActivity()
    {
        String val = getPersistedString( ""0"" );
        setSummaryToMatch( val );
    }

    // Preference.OnPreferenceChangeListener interface
    public boolean onPreferenceChange( Preference preference, Object newValue )
    {
        String valstr = (String)newValue;
        int val = Integer.parseInt(valstr);
        RelayReceiver.RestartTimer( m_context, val * 1000 );

        setSummaryToMatch( valstr );
        return true;
    }

    private void setSummaryToMatch( String value )
    {
        int index = findIndexOfValue( value );
        if ( 0 <= index ) {
            CharSequence entry = getEntries()[index];
            setSummary( entry );
        }
    }
}",False,51,39,0,0,10,7,0,1,L3
30,org.eehouse.android.xw4.ChatActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2011 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MenuInflater;
import android.widget.LinearLayout;

public class ChatActivity extends XWActivity implements View.OnClickListener {

    private long m_rowid;

    @Override
    public void onCreate( Bundle savedInstanceState ) 
    {
        super.onCreate( savedInstanceState );

        setContentView( R.layout.chat );

        m_rowid = getIntent().getLongExtra( BoardActivity.INTENT_KEY_ROWID, -1 );
     
        DBUtils.HistoryPair[] pairs = DBUtils.getChatHistory( this, m_rowid );
        if ( null != pairs ) {
            LinearLayout layout = (LinearLayout)findViewById( R.id.chat_history );
            LayoutInflater factory = LayoutInflater.from( this );

            for ( DBUtils.HistoryPair pair : pairs ) {
                TextView view = 
                    (TextView)factory.inflate( pair.sourceLocal
                                               ? R.layout.chat_history_local
                                               : R.layout.chat_history_remote, 
                                               null );
                view.setText( pair.msg );
                layout.addView( view );
            }
        }

        ((Button)findViewById( R.id.send_button )).setOnClickListener( this );

        String fmt = getString( R.string.chat_titlef );
        setTitle( String.format( fmt, GameUtils.getName( this, m_rowid ) ) );
    }

    @Override
    public boolean onCreateOptionsMenu( Menu menu )
    {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.chat_menu, menu );
        return true;
    }

    @Override
    public boolean onOptionsItemSelected( MenuItem item ) 
    {
        boolean handled = R.id.chat_menu_clear == item.getItemId();
        if ( handled ) {
            DBUtils.clearChatHistory( this, m_rowid );
            LinearLayout layout = 
                (LinearLayout)findViewById( R.id.chat_history );
            layout.removeAllViews();
        } else {
            handled = super.onOptionsItemSelected( item );
        }
        return handled;
    }

    @Override
    public void onClick( View view ) 
    {
        EditText edit = (EditText)findViewById( R.id.chat_edit );
        String text = edit.getText().toString();
        if ( null == text || text.length() == 0 ) {
            setResult( Activity.RESULT_CANCELED );
        } else {
            DBUtils.appendChatHistory( this, m_rowid, text, true );

            Intent result = new Intent();
            result.putExtra( BoardActivity.INTENT_KEY_CHAT, text );
            setResult( Activity.RESULT_OK, result );
        }
        finish();
    }

}
",True,54,38,0,0,3,23,0,4,L3
31,org.eehouse.android.xw4.FirstRunDialog.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.pm.PackageInfo;
import android.app.AlertDialog;
import android.webkit.WebView;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;

/* Put up a dialog greeting user after every upgrade.  Based on
 * similar feature in OpenSudoku, to whose author ""Thanks"".
 */

public class FirstRunDialog {
	private static final String HIDDEN_PREFS = ""xwprefs_hidden"";
    private static final String SHOWN_VERSION_KEY = ""SHOWN_VERSION_KEY"";

    static boolean show( Context context, boolean skipCheck )
    {
        int thisVersion = 0;
        int shownVersion = 0;

        if ( !skipCheck ) {
            try {
                thisVersion = context.getPackageManager()
                    .getPackageInfo(context.getPackageName(), 0)
                    .versionCode;
                Utils.logf( ""versionCode: %d"", thisVersion );
            } catch ( Exception e ) {
            }
        }

        SharedPreferences prefs = null;
        if ( thisVersion > 0 ) {
            prefs = context.getSharedPreferences( HIDDEN_PREFS, 
                                                  Context.MODE_PRIVATE );
            shownVersion = prefs.getInt( SHOWN_VERSION_KEY, 0 );
        }

        boolean isUpgrade = shownVersion < thisVersion;
        if ( skipCheck || isUpgrade ) {
            showDialog( context );
        
            if ( !skipCheck ) {
                Editor editor = prefs.edit();
                editor.putInt( SHOWN_VERSION_KEY, thisVersion );
                editor.commit();
            }
        }
        return isUpgrade;
    }

    private static void showDialog( Context context )
    {
        String page = null;
        InputStream inputStream = null;
		try {
            inputStream = context.getResources()
                .openRawResource(R.raw.changes);
			
			final char[] buf = new char[0x1000];
			StringBuilder stringBuilder = new StringBuilder();
			Reader reader = new InputStreamReader( inputStream, ""UTF-8"" );
			int nRead;
			do {
                nRead = reader.read( buf, 0, buf.length );
                if ( nRead > 0 ) {
                    stringBuilder.append( buf, 0, nRead );
                }
			} while ( nRead >= 0 );
			
			page = stringBuilder.toString();
		}
		catch ( IOException ioe ) {
			Utils.logf( ioe.toString() );
		}
		finally {
            // could just catch NPE....
			if ( null != inputStream ) {
				try {
					inputStream.close();
				} catch ( IOException ioe ) {
                    Utils.logf( ioe.toString() );
				}
			}
		}
		
        // This won't support e.g mailto refs.  Probably want to
        // launch the browser with an intent eventually.
		WebView view = new WebView( context );
		view.loadData( page, ""text/html"", ""utf-8"" );

		AlertDialog dialog = new AlertDialog.Builder( context )
            .setIcon(android.R.drawable.ic_menu_info_details)
            .setTitle( R.string.changes_title )
            .setView( view )
            .setPositiveButton( R.string.button_ok, null)
            .create();
		dialog.show();
    }
}
",True,49,37,10,7,1,1,2,1,L1
32,org.eehouse.android.xw4.DlgDelegate.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

import junit.framework.Assert;

import org.eehouse.android.xw4.jni.CommonPrefs;


public class DlgDelegate {

    public static final int DIALOG_ABOUT = 1;
    public static final int DIALOG_OKONLY = 2;
    public static final int DIALOG_NOTAGAIN = 3;
    public static final int CONFIRM_THEN = 4;
    public static final int TEXT_OR_HTML_THEN = 5;
    public static final int DLG_DICTGONE = 6;
    public static final int DIALOG_LAST = DLG_DICTGONE;

    public static final int TEXT_BTN = AlertDialog.BUTTON_POSITIVE;
    public static final int HTML_BTN = AlertDialog.BUTTON_NEGATIVE;
    public static final int DISMISS_BUTTON = 0;
    public static final int SKIP_CALLBACK = -1;

    private static final String MSG = ""msg"";
    private static final String CALLBACK = ""callback"";
    private static final String MSGID = ""msgid"";
    private static final String PREFSKEY = ""prefskey"";
    private static final String POSBUTTON = ""posbutton"";

    // Cache a couple of callback implementations that never change:
    private DialogInterface.OnClickListener m_cbkOnClickLstnr = null;
    private DialogInterface.OnDismissListener m_cbkOnDismissLstnr = null;

    public interface DlgClickNotify {
        void dlgButtonClicked( int id, int button );
    }

    private int m_msgID;
    private int m_posButton;
    private int m_cbckID = 0;   // if this can be set twice I have a
                                // problem.  See asserts below.
    private String m_msg;
    private int m_prefsKey;
    private Activity m_activity;
    private DlgClickNotify m_clickCallback;
    private String m_dictName = null;

    public DlgDelegate( Activity activity, DlgClickNotify callback,
                        Bundle bundle ) 
    {
        m_activity = activity;
        m_clickCallback = callback;

        if ( null != bundle ) {
            m_msg = bundle.getString( MSG );
            m_cbckID = bundle.getInt( CALLBACK );
            m_msgID = bundle.getInt( MSGID );
            m_posButton = bundle.getInt( POSBUTTON );
            m_prefsKey = bundle.getInt( PREFSKEY );
        }
    }

    public void onSaveInstanceState( Bundle outState ) 
    {
        outState.putString( MSG, m_msg );
        outState.putInt( CALLBACK, m_cbckID );
        outState.putInt( MSGID, m_msgID );
        outState.putInt( POSBUTTON, m_posButton );
        outState.putInt( PREFSKEY, m_prefsKey );
    }
    
    public Dialog onCreateDialog( int id )
    {
        Dialog dialog = null;
        switch( id ) {
        case DIALOG_ABOUT:
            dialog = createAboutDialog();
            break;
        case DIALOG_OKONLY:
            dialog = createOKDialog();
            break;
        case DIALOG_NOTAGAIN:
            dialog = createNotAgainDialog();
            break;
        case CONFIRM_THEN:
            dialog = createConfirmThenDialog();
            break;
        case TEXT_OR_HTML_THEN:
            dialog = createHtmlThenDialog();
            break;
        case DLG_DICTGONE:
            dialog = createDictGoneDialog();
            break;
        }
        return dialog;
    }

    public void onPrepareDialog( int id, Dialog dialog )
    {
        AlertDialog ad = (AlertDialog)dialog;
        DialogInterface.OnClickListener lstnr;

        switch( id ) {
        case DIALOG_ABOUT:
            break;
        case DIALOG_NOTAGAIN:
            // Don't think onclick listeners need to be reset.  They
            // reference instance vars that are changed each time
            // showNotAgainDlgThen() is called
            // FALLTHRU
        case DIALOG_OKONLY:
            ad.setMessage( m_activity.getString(m_msgID) );
            break;
        case CONFIRM_THEN:
            ad.getButton(AlertDialog.BUTTON_POSITIVE).
                setText( m_activity.getString( m_posButton ) );
            ad.setMessage( m_msg );
            break;
        }
    }

    public void showOKOnlyDialog( int msgID )
    {
        m_msgID = msgID;
        m_activity.showDialog( DIALOG_OKONLY );
    }

    public void showDictGoneFinish()
    {
        m_activity.showDialog( DLG_DICTGONE );
    }

    public void showAboutDialog()
    {
        m_activity.showDialog( DIALOG_ABOUT );
    }

    public void showNotAgainDlgThen( int msgID, int prefsKey,
                                     int callbackID )
    {
        boolean set = CommonPrefs.getPrefsBoolean( m_activity, prefsKey, false );
        if ( set || 0 != m_cbckID ) {
            // If it's set, do the action without bothering with the
            // dialog
            if ( SKIP_CALLBACK != callbackID ) {
                m_clickCallback.dlgButtonClicked( callbackID, 
                                                  AlertDialog.BUTTON_POSITIVE );
            }
        } else {
            m_msgID = msgID;
            Assert.assertTrue( 0 != callbackID );
            Assert.assertTrue( 0 == m_cbckID ); // fired
            m_cbckID = callbackID;
            m_prefsKey = prefsKey;
            m_activity.showDialog( DIALOG_NOTAGAIN );
        }
    }

    public void showNotAgainDlgThen( int msgID, int prefsKey )
    {
        showNotAgainDlgThen( msgID, prefsKey, SKIP_CALLBACK );
    }

    public void showConfirmThen( String msg, int callbackID )
    {
        showConfirmThen( msg, R.string.button_ok, callbackID );
    }

    public void showConfirmThen( String msg, int posButton, int callbackID )
    {
        m_msg = msg;
        m_posButton = posButton;
        Assert.assertTrue( 0 != callbackID );
        Assert.assertTrue( 0 == m_cbckID );
        m_cbckID = callbackID;
        m_activity.showDialog( CONFIRM_THEN );
    }

    public void showTextOrHtmlThen( int callbackID )
    {
        Assert.assertTrue( 0 != callbackID );
        Assert.assertTrue( 0 == m_cbckID );
        m_cbckID = callbackID;
        m_activity.showDialog( TEXT_OR_HTML_THEN );
    }

    public void doSyncMenuitem()
    {
        if ( null == DBUtils.getRelayIDs( m_activity, false ) ) {
            showOKOnlyDialog( R.string.no_games_to_refresh );
        } else {
            RelayReceiver.RestartTimer( m_activity, true );
            Toast.makeText( m_activity, 
                            m_activity.getString( R.string.msgs_progress ),
                            Toast.LENGTH_LONG ).show();
        }
    }

    private Dialog createAboutDialog()
    {
        final View view = Utils.inflate( m_activity, R.layout.about_dlg );
        TextView vers = (TextView)view.findViewById( R.id.version_string );
        vers.setText( String.format( m_activity.getString(R.string.about_versf), 
                                     m_activity.getString(R.string.app_version),
                                     GitVersion.VERS ) );

        TextView xlator = (TextView)view.findViewById( R.id.about_xlator );
        String str = m_activity.getString( R.string.xlator );
        if ( str.length() > 0 ) {
            xlator.setText( str );
        } else {
            xlator.setVisibility( View.GONE );
        }

        return new AlertDialog.Builder( m_activity )
            .setIcon( R.drawable.icon48x48 )
            .setTitle( R.string.app_name )
            .setView( view )
            .setPositiveButton( R.string.changes_button,
                                new DialogInterface.OnClickListener() {
                                    @Override
                                    public void onClick( DialogInterface dlg, 
                                                         int which )
                                    {
                                        FirstRunDialog.show( m_activity, true );
                                    }
                                } )
            .create();
    }

    private Dialog createOKDialog()
    {
        return new AlertDialog.Builder( m_activity )
            .setTitle( R.string.info_title )
            .setMessage( m_msgID )
            .setPositiveButton( R.string.button_ok, null )
            .create();
    }

    private Dialog createNotAgainDialog()
    {
        DialogInterface.OnClickListener lstnr_p = mkCallbackClickListener();

        DialogInterface.OnClickListener lstnr_n = 
            new DialogInterface.OnClickListener() {
                public void onClick( DialogInterface dlg, int item ) {
                    CommonPrefs.setPrefsBoolean( m_activity, m_prefsKey,
                                                 true );
                    if ( SKIP_CALLBACK != m_cbckID ) {
                        m_clickCallback.
                            dlgButtonClicked( m_cbckID, 
                                              AlertDialog.BUTTON_POSITIVE );
                    }
                }
            };

        Dialog dialog = new AlertDialog.Builder( m_activity )
            .setTitle( R.string.newbie_title )
            .setMessage( m_msgID )
            .setPositiveButton( R.string.button_ok, lstnr_p )
            .setNegativeButton( R.string.button_notagain, lstnr_n )
            .create();

        return setCallbackDismissListener( dialog );
    } // createNotAgainDialog

    private Dialog createConfirmThenDialog()
    {
        DialogInterface.OnClickListener lstnr = mkCallbackClickListener();

        Dialog dialog = new AlertDialog.Builder( m_activity )
            .setTitle( R.string.query_title )
            .setMessage( """" )
            .setPositiveButton( R.string.button_ok, lstnr )
            .setNegativeButton( R.string.button_cancel, lstnr )
            .create();
        
        return setCallbackDismissListener( dialog );
    }

    private Dialog createHtmlThenDialog()
    {
        DialogInterface.OnClickListener lstnr = mkCallbackClickListener();
        Dialog dialog = new AlertDialog.Builder( m_activity )
            .setTitle( R.string.query_title )
            .setMessage( R.string.text_or_html )
            .setPositiveButton( R.string.button_text, lstnr )
            .setNegativeButton( R.string.button_html, lstnr )
            .create();

        return setCallbackDismissListener( dialog );
    }

    private Dialog createDictGoneDialog()
    {
        Dialog dialog = new AlertDialog.Builder( m_activity )
            .setTitle( R.string.no_dict_title )
            .setMessage( R.string.no_dict_finish )
            .setPositiveButton( R.string.button_close_game, null )
            .create();

        dialog.setOnDismissListener( new DialogInterface.OnDismissListener() {
                public void onDismiss( DialogInterface di ) {
                    m_activity.finish();
                }
            } );

        return dialog;
    }

    private DialogInterface.OnClickListener mkCallbackClickListener()
    {
        if ( null == m_cbkOnClickLstnr ) {
            m_cbkOnClickLstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int button ) {
                        if ( SKIP_CALLBACK != m_cbckID ) {
                            m_clickCallback.dlgButtonClicked( m_cbckID, 
                                                              button );
                        }
                    }
                };
        }
        return m_cbkOnClickLstnr;
    }

    private Dialog setCallbackDismissListener( Dialog dialog )
    {
        if ( null == m_cbkOnDismissLstnr ) {
            m_cbkOnDismissLstnr = new DialogInterface.OnDismissListener() {
                    public void onDismiss( DialogInterface di ) {
                        if ( SKIP_CALLBACK != m_cbckID ) {
                            m_clickCallback.dlgButtonClicked( m_cbckID, 
                                                              DISMISS_BUTTON );
                        }
                        m_cbckID = 0;
                    }
                };
        }
        dialog.setOnDismissListener( m_cbkOnDismissLstnr );
        return dialog;
    }

}
",False,13,42,1,5,5,11,7,4,L1
33,org.eehouse.android.xw4.EditColorPreference.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.preference.DialogPreference;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.TypedArray;
import android.util.AttributeSet;
import android.view.View;
import android.widget.SeekBar;
import android.widget.EditText;
import android.app.Dialog;
import android.content.SharedPreferences;
import android.app.AlertDialog;
import android.text.TextWatcher;
import android.text.Editable;
import junit.framework.Assert;

public class EditColorPreference extends DialogPreference {

    private Context m_context;
    private int m_curColor;
    // m_updateText: prevent loop that resets edittext cursor
    private boolean m_updateText = true;
    private static final int m_seekbarIds[] = { R.id.seek_red, R.id.seek_green, 
                                                R.id.seek_blue };
    private static final int m_editIds[] = { R.id.edit_red, R.id.edit_green, 
                                             R.id.edit_blue };

    private class SBCL implements SeekBar.OnSeekBarChangeListener {
        int m_index;
        View m_sample;
        EditText m_editTxt;
        public SBCL( View parent, EditText editTxt, int indx )
        {
            m_index = indx;
            m_sample = parent.findViewById( R.id.color_edit_sample );
            m_editTxt = editTxt;
        }

        public void onProgressChanged( SeekBar seekBar, int progress, 
                                       boolean fromUser )
        {
            if ( m_updateText ) {
                m_editTxt.setText( String.format( ""%d"", progress ) );
            }

            int shift = 16 - (m_index * 8);
            // mask out the byte we're changing
            int color = m_curColor & ~(0xFF << shift);
            // add in the new version of the byte
            color |= progress << shift;
            m_curColor = color;
            m_sample.setBackgroundColor( m_curColor );
        }

        public void onStartTrackingTouch( SeekBar seekBar ) {}

        public void onStopTrackingTouch( SeekBar seekBar ) {}
    }

    private class TCL implements TextWatcher {
        private SeekBar m_seekBar;
        public TCL( SeekBar seekBar ) { m_seekBar = seekBar; }
        public void afterTextChanged( Editable s )
        {
        }

        public void beforeTextChanged( CharSequence s, int st, int cnt, int a ) 
        {
        }

        public void onTextChanged( CharSequence s, int start, 
                                   int before, int count )
        {
            int val;
            try {
                val = Integer.parseInt( s.toString() );
            } catch ( java.lang.NumberFormatException nfe ) {
                val = 0;
            }
            m_updateText = false; // don't call me recursively inside seekbar
            m_seekBar.setProgress( val );
            m_updateText = true;
        }
    }

    public EditColorPreference( Context context, AttributeSet attrs )
    {
        super( context, attrs );
        m_context = context;
        
        setWidgetLayoutResource( R.layout.color_display );
        setDialogLayoutResource( R.layout.color_edit );
    }

    @Override
    protected Object onGetDefaultValue(TypedArray a, int index) {
        return a.getInteger(index, 0);
    }

    @Override
    protected void onSetInitialValue(boolean restoreValue, Object defaultValue) {
        if ( !restoreValue ) {
            persistInt( (Integer)defaultValue );
        }
    }
    
    @Override
    protected void onBindView( View parent ) 
    {
        super.onBindView( parent );
        View sample = parent.findViewById( R.id.color_display_sample );
        sample.setBackgroundColor( getPersistedColor() );
    }

    @Override
    protected void onBindDialogView( View view )
    {
        m_curColor = getPersistedColor();
        setOneByte( view, 0 );
        setOneByte( view, 1 );
        setOneByte( view, 2 );

        View sample = (View)view.findViewById( R.id.color_edit_sample );
        sample.setBackgroundColor( m_curColor );
    }
    
    @Override
    protected void onPrepareDialogBuilder( AlertDialog.Builder builder )
    {
        DialogInterface.OnClickListener lstnr = 
            new DialogInterface.OnClickListener() {
                @Override
                public void onClick( DialogInterface dialog, int which )
                {
                    int color = (getOneByte( dialog, R.id.seek_red ) << 16)
                        | (getOneByte( dialog, R.id.seek_green ) << 8)
                        | getOneByte( dialog, R.id.seek_blue );

                    persistInt( color );
                    notifyChanged();
                }
            };
        builder.setPositiveButton( R.string.button_ok, lstnr );
        super.onPrepareDialogBuilder( builder );
    }

    private void setOneByte( View parent, int indx ) 
    {
        int shift = 16 - (indx*8);
        int byt = (m_curColor >> shift) & 0xFF;
        SeekBar seekbar = (SeekBar)parent.findViewById( m_seekbarIds[indx] );
        EditText edittext = (EditText)parent.findViewById( m_editIds[indx] );

        if ( null != seekbar ) {
            seekbar.setProgress( byt );

            seekbar.setOnSeekBarChangeListener( new SBCL( parent, edittext,
                                                          indx ) );
        }

        if ( null != edittext ) {
            edittext.setText( String.format( ""%d"", byt ) );
            edittext.addTextChangedListener( new TCL( seekbar ) );
        }
    }

    private int getOneByte( DialogInterface parent, int id ) {
        int val = 0;
        Dialog dialog = (Dialog)parent;
        SeekBar seekbar = (SeekBar)dialog.findViewById( id );
        if ( null != seekbar ) {
            val = seekbar.getProgress();
        }
        return val;
    }

    private int getPersistedColor()
    {
        return 0xFF000000 | getPersistedInt(0);
    }
}
",False,43,1,0,0,0,0,0,0,I0
34,org.eehouse.android.xw4.GameConfig.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import android.view.Gravity;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.TextView;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.app.Dialog;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.view.LayoutInflater;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.ImageButton;
import android.view.MenuInflater;
import android.view.KeyEvent;
import android.widget.Spinner;
import android.widget.ArrayAdapter;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.ListAdapter;
import android.widget.SpinnerAdapter;
import android.widget.Toast;
import android.database.DataSetObserver;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class GameConfig extends XWActivity 
    implements View.OnClickListener
               ,XWListItem.DeleteCallback
               ,RefreshNamesTask.NoNameFound {

    private static final int PLAYER_EDIT = DlgDelegate.DIALOG_LAST + 1;
    private static final int FORCE_REMOTE = PLAYER_EDIT + 1;
    private static final int CONFIRM_CHANGE = PLAYER_EDIT + 2;
    private static final int CONFIRM_CHANGE_PLAY = PLAYER_EDIT + 3;
    private static final int NO_NAME_FOUND = PLAYER_EDIT + 4;

    private static final String WHICH_PLAYER = ""WHICH_PLAYER"";
    private static final int LOCKED_CHANGE_ACTION = 1;

    private CheckBox m_joinPublicCheck;
    private CheckBox m_gameLockedCheck;
    private boolean m_isLocked;
    private LinearLayout m_publicRoomsSet;
    private LinearLayout m_privateRoomsSet;

    private boolean m_notNetworkedGame;
    private Button m_addPlayerButton;
    private Button m_jugglePlayersButton;
    private Button m_playButton;
    private ImageButton m_refreshRoomsButton;
    private View m_connectSet;  // really a LinearLayout
    private Spinner m_roomChoose;
    // private Button m_configureButton;
    private long m_rowid;
    private CurGameInfo m_gi;
    private CurGameInfo m_giOrig;
    private GameUtils.GameLock m_gameLock;
    private int m_whichPlayer;
    // private Spinner m_roleSpinner;
    // private Spinner m_connectSpinner;
    private Spinner m_phoniesSpinner;
    private Spinner m_langSpinner;
    private Spinner m_smartnessSpinner;
    private String m_browseText;
    private LinearLayout m_playerLayout;
    private CommsAddrRec m_carOrig;
    private CommsAddrRec m_car;
    private CommonPrefs m_cp;
    private boolean m_canDoSMS = false;
    private boolean m_canDoBT = false;
    private boolean m_gameStarted = false;
    private CommsAddrRec.CommsConnType[] m_types;
    private String[] m_connStrings;
    private static final int[] s_disabledWhenLocked = { R.id.juggle_players
                                                        ,R.id.add_player
                                                        ,R.id.lang_spinner
                                                        ,R.id.join_public_room_check
                                                        ,R.id.room_edit
                                                        ,R.id.advertise_new_room_check
                                                        ,R.id.room_spinner
                                                        ,R.id.refresh_button
                                                        ,R.id.hints_allowed
                                                        ,R.id.use_timer
                                                        ,R.id.timer_minutes_edit
                                                        ,R.id.smart_robot
                                                        ,R.id.phonies_spinner
    };

    class RemoteChoices extends XWListAdapter {
        public RemoteChoices() { super( GameConfig.this, m_gi.nPlayers ); }

        public Object getItem( int position) { return m_gi.players[position]; }
        public View getView( final int position, View convertView, 
                             ViewGroup parent ) {
            CompoundButton.OnCheckedChangeListener lstnr;
            lstnr = new CompoundButton.OnCheckedChangeListener() {
                    @Override
                    public void onCheckedChanged( CompoundButton buttonView, 
                                                 boolean isChecked )
                    {
                        m_gi.players[position].isLocal = !isChecked;
                    }
                };
            CheckBox cb = new CheckBox( GameConfig.this );
            LocalPlayer lp = m_gi.players[position];
            cb.setText( lp.name );
            cb.setChecked( !lp.isLocal );
            cb.setOnCheckedChangeListener( lstnr );
            return cb;
        }
    }

    @Override
    protected Dialog onCreateDialog( final int id )
    {
        Dialog dialog = super.onCreateDialog( id );
        if ( null == dialog ) {
            LayoutInflater factory;
            DialogInterface.OnClickListener dlpos;
            AlertDialog.Builder ab;

            switch (id) {
            case PLAYER_EDIT:
                View playerEditView
                    = Utils.inflate( this, R.layout.player_edit );

                dialog = new AlertDialog.Builder( this )
                    .setTitle(R.string.player_edit_title)
                    .setView(playerEditView)
                    .setPositiveButton( R.string.button_ok,
                                        new DialogInterface.OnClickListener() {
                                            public void 
                                                onClick( DialogInterface dlg, 
                                                                 int button ) {
                                                getPlayerSettings( dlg );
                                                loadPlayersList();
                                            }
                                        })
                    .setNegativeButton( R.string.button_cancel, null )
                    .create();
                break;
                // case ROLE_EDIT_RELAY:
                // case ROLE_EDIT_SMS:
                // case ROLE_EDIT_BT:
                //     dialog = new AlertDialog.Builder( this )
                //         .setTitle(titleForDlg(id))
                //         .setView( LayoutInflater.from(this)
                //                   .inflate( layoutForDlg(id), null ))
                //         .setPositiveButton( R.string.button_ok,
                //                             new DialogInterface.OnClickListener() {
                //                                 public void onClick( DialogInterface dlg, 
                //                                                      int whichButton ) {
                //                                     getRoleSettings();
                //                                 }
                //                             })
                //         .setNegativeButton( R.string.button_cancel, null )
                //         .create();
                //     break;

            case FORCE_REMOTE:
                dlpos = new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dlg, 
                                             int whichButton ) {
                            loadPlayersList();
                        }
                    };
                dialog = new AlertDialog.Builder( this )
                    .setTitle( R.string.force_title )
                    .setView( Utils.inflate( this, layoutForDlg(id) ) )
                    .setPositiveButton( R.string.button_ok, dlpos )
                    .create();
                DialogInterface.OnDismissListener dismiss = 
                    new DialogInterface.OnDismissListener() {
                        @Override
                        public void onDismiss( DialogInterface di ) 
                        {
                            if ( m_gi.forceRemoteConsistent() ) {
                                Toast.makeText( GameConfig.this, 
                                                R.string.forced_consistent,
                                                Toast.LENGTH_SHORT).show();
                                loadPlayersList();
                            }
                        }
                    };
                dialog.setOnDismissListener( dismiss );
                break;
            case CONFIRM_CHANGE_PLAY:
            case CONFIRM_CHANGE:
                dlpos = new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dlg, 
                                             int whichButton ) {
                            applyChanges( true );
                            if ( CONFIRM_CHANGE_PLAY == id ) {
                                launchGame();
                            }
                        }
                    };
                ab = new AlertDialog.Builder( this )
                    .setTitle( R.string.confirm_save_title )
                    .setMessage( R.string.confirm_save )
                    .setPositiveButton( R.string.button_save, dlpos );
                if ( CONFIRM_CHANGE_PLAY == id ) {
                    dlpos = new DialogInterface.OnClickListener() {
                            public void onClick( DialogInterface dlg, 
                                                 int whichButton ) {
                                launchGame();
                            }
                        };
                } else {
                    dlpos = null;
                }
                ab.setNegativeButton( R.string.button_discard, dlpos );
                dialog = ab.create();

                dialog.setOnDismissListener( new DialogInterface.
                                             OnDismissListener() {
                        public void onDismiss( DialogInterface di ) {
                            finish();
                        }
                    });
                break;
            case NO_NAME_FOUND:
                String format = getString( R.string.no_name_found_f );
                String msg = 
                    String.format( format, m_gi.nPlayers, DictLangCache.
                                   getLangName( this, m_gi.dictLang ) );
                dialog = new AlertDialog.Builder( this )
                    .setPositiveButton( R.string.button_ok, null )
                    // message added below since varies with language etc.
                    .setMessage( msg )
                    .create();
                break;
            }
        }
        return dialog;
    } // onCreateDialog

    @Override
    protected void onPrepareDialog( int id, Dialog dialog )
    { 
        switch ( id ) {
        case PLAYER_EDIT:
            setPlayerSettings( dialog );
            break;
        // case ROLE_EDIT_RELAY:
        // case ROLE_EDIT_SMS:
        // case ROLE_EDIT_BT:
        //     setRoleHints( id, dialog );
        //     setRoleSettings();
        //     break;
        case FORCE_REMOTE:
            ListView listview = (ListView)dialog.findViewById( R.id.players );
            listview.setAdapter( new RemoteChoices() );
            break;
        }
        super.onPrepareDialog( id, dialog );
    }

    private void setPlayerSettings( final Dialog dialog )
    {
        // Hide remote option if in standalone mode...
        boolean isServer = !m_notNetworkedGame;
        LocalPlayer lp = m_gi.players[m_whichPlayer];
        Utils.setText( dialog, R.id.player_name_edit, lp.name );
        Utils.setText( dialog, R.id.password_edit, lp.password );

        // Dicts spinner with label
        String langName = DictLangCache.getLangName( this, m_gi.dictLang );
        String label = String.format( getString( R.string.dict_lang_labelf ),
                                      langName );
        TextView text = (TextView)dialog.findViewById( R.id.dict_label );
        text.setText( label );
        configDictSpinner( dialog, lp );

        final View localSet = dialog.findViewById( R.id.local_player_set );

        CheckBox check = (CheckBox)
            dialog.findViewById( R.id.remote_check );
        if ( isServer ) {
            CompoundButton.OnCheckedChangeListener lstnr =
                new CompoundButton.OnCheckedChangeListener() {
                    public void onCheckedChanged( CompoundButton buttonView, 
                                                  boolean checked ) {
                        localSet.setVisibility( checked ? 
                                                View.GONE : View.VISIBLE );
                    }
                };
            check.setOnCheckedChangeListener( lstnr );
            check.setVisibility( View.VISIBLE );
        } else {
            check.setVisibility( View.GONE );
            localSet.setVisibility( View.VISIBLE );
        }

        check = (CheckBox)dialog.findViewById( R.id.robot_check );
        CompoundButton.OnCheckedChangeListener lstnr =
            new CompoundButton.OnCheckedChangeListener() {
                public void onCheckedChanged( CompoundButton buttonView, 
                                              boolean checked ) {
                    View view = dialog.findViewById( R.id.password_set );
                    view.setVisibility( checked ? View.GONE : View.VISIBLE );
                }
            };
        check.setOnCheckedChangeListener( lstnr );

        Utils.setChecked( dialog, R.id.robot_check, lp.isRobot() );
        Utils.setChecked( dialog, R.id.remote_check, ! lp.isLocal );
    }

    private void getPlayerSettings( DialogInterface di )
    {
        Dialog dialog = (Dialog)di;
        LocalPlayer lp = m_gi.players[m_whichPlayer];
        lp.name = Utils.getText( dialog, R.id.player_name_edit );
        lp.password = Utils.getText( dialog, R.id.password_edit );
        Spinner spinner =
            (Spinner)((Dialog)di).findViewById( R.id.dict_spinner );
        int position = spinner.getSelectedItemPosition();
        ArrayAdapter<String> adapter =
            (ArrayAdapter<String>)spinner.getAdapter();

        if ( position < adapter.getCount() ) {
            lp.dictName = adapter.getItem(position);
        }

        lp.setIsRobot( Utils.getChecked( dialog, R.id.robot_check ) );
        lp.isLocal = !Utils.getChecked( dialog, R.id.remote_check );
    }

    @Override
    public void onCreate( Bundle savedInstanceState )
    {
        super.onCreate(savedInstanceState);
        getBundledData( savedInstanceState );

        // 1.5 doesn't have SDK_INT.  So parse the string version.
        // int sdk_int = 0;
        // try {
        //     sdk_int = Integer.decode( android.os.Build.VERSION.SDK );
        // } catch ( Exception ex ) {}
        // m_canDoSMS = sdk_int >= android.os.Build.VERSION_CODES.DONUT;
        m_browseText = getString( R.string.download_dicts );
        DictLangCache.setLast( m_browseText );

        m_cp = CommonPrefs.get( this );

        Intent intent = getIntent();
        m_rowid = intent.getLongExtra( BoardActivity.INTENT_KEY_ROWID, -1 );

        setContentView(R.layout.game_config);

        m_connectSet = findViewById(R.id.connect_set);
        m_addPlayerButton = (Button)findViewById(R.id.add_player);
        m_addPlayerButton.setOnClickListener( this );
        m_jugglePlayersButton = (Button)findViewById(R.id.juggle_players);
        m_jugglePlayersButton.setOnClickListener( this );
        m_playButton = (Button)findViewById( R.id.play_button );
        m_playButton.setOnClickListener( this );

        m_playerLayout = (LinearLayout)findViewById( R.id.player_list );
        m_langSpinner = (Spinner)findViewById( R.id.lang_spinner );
        m_phoniesSpinner = (Spinner)findViewById( R.id.phonies_spinner );
        m_smartnessSpinner = (Spinner)findViewById( R.id.smart_robot );

        setTitle();
    } // onCreate

    @Override
    protected void onStart()
    {
        super.onStart();
        loadGame();
    }

    @Override
    protected void onResume()
    {
        super.onResume();
        loadGame();
    }

    @Override
    protected void onPause()
    {
        if ( null != m_gameLock ) {
            m_gameLock.unlock();
            m_gameLock = null;
        }
        m_giOrig = null;        // flag for onStart and onResume
        super.onPause();
    }

    @Override
    protected void onSaveInstanceState( Bundle outState ) 
    {
        super.onSaveInstanceState( outState );
        outState.putInt( WHICH_PLAYER, m_whichPlayer );
    }

    private void loadGame()
    {
        if ( null == m_giOrig ) {
            m_giOrig = new CurGameInfo( this );

            // Lock in case we're going to config.  We *could* re-get the
            // lock once the user decides to make changes.  PENDING.
            m_gameLock = new GameUtils.GameLock( m_rowid, true ).lock();
            int gamePtr = GameUtils.loadMakeGame( this, m_giOrig, m_gameLock );
            if ( 0 == gamePtr ) {
                showDictGoneFinish();
            } else {
                m_gameStarted = XwJNI.model_getNMoves( gamePtr ) > 0
                    || XwJNI.comms_isConnected( gamePtr );

                if ( m_gameStarted ) {
                    if ( null == m_gameLockedCheck ) {
                        m_gameLockedCheck = 
                            (CheckBox)findViewById( R.id.game_locked_check );
                        m_gameLockedCheck.setVisibility( View.VISIBLE );
                        m_gameLockedCheck.setChecked( true );
                        m_gameLockedCheck.setOnClickListener( this );
                    }
                    handleLockedChange();
                }

                if ( null == m_gi ) {
                    m_gi = new CurGameInfo( this, m_giOrig );
                }

                m_carOrig = new CommsAddrRec( this );
                if ( XwJNI.game_hasComms( gamePtr ) ) {
                    XwJNI.comms_getAddr( gamePtr, m_carOrig );
                } else {
                    String relayName = CommonPrefs.getDefaultRelayHost( this );
                    int relayPort = CommonPrefs.getDefaultRelayPort( this );
                    XwJNI.comms_getInitialAddr( m_carOrig, relayName, relayPort );
                }
                XwJNI.game_dispose( gamePtr );

                m_car = new CommsAddrRec( m_carOrig );

                m_notNetworkedGame = DeviceRole.SERVER_STANDALONE == m_gi.serverRole;
                setTitle();

                if ( !m_notNetworkedGame ) {
                    m_joinPublicCheck = 
                        (CheckBox)findViewById(R.id.join_public_room_check);
                    m_joinPublicCheck.setOnClickListener( this );
                    m_joinPublicCheck.setChecked( m_car.ip_relay_seeksPublicRoom );
                    Utils.setChecked( this, R.id.advertise_new_room_check, 
                                      m_car.ip_relay_advertiseRoom );
                    m_publicRoomsSet = 
                        (LinearLayout)findViewById(R.id.public_rooms_set );
                    m_privateRoomsSet = 
                        (LinearLayout)findViewById(R.id.private_rooms_set );

                    Utils.setText( this, R.id.room_edit, m_car.ip_relay_invite );
        
                    m_roomChoose = (Spinner)findViewById( R.id.room_spinner );

                    m_refreshRoomsButton = 
                        (ImageButton)findViewById( R.id.refresh_button );
                    m_refreshRoomsButton.setOnClickListener( this );

                    adjustConnectStuff();
                }

                loadPlayersList();
                configLangSpinner();

                m_phoniesSpinner.setSelection( m_gi.phoniesAction.ordinal() );

                setSmartnessSpinner();

                Utils.setChecked( this, R.id.hints_allowed, !m_gi.hintsNotAllowed );
                Utils.setInt( this, R.id.timer_minutes_edit, 
                              m_gi.gameSeconds/60/m_gi.nPlayers );

                CheckBox check = (CheckBox)findViewById( R.id.use_timer );
                CompoundButton.OnCheckedChangeListener lstnr =
                    new CompoundButton.OnCheckedChangeListener() {
                        public void onCheckedChanged( CompoundButton buttonView, 
                                                      boolean checked ) {
                            View view = findViewById( R.id.timer_set );
                            view.setVisibility( checked ? View.VISIBLE : View.GONE );
                        }
                    };
                check.setOnCheckedChangeListener( lstnr );
                Utils.setChecked( this, R.id.use_timer, m_gi.timerEnabled );
            }
        }
    } // loadGame

    private void getBundledData( Bundle bundle )
    {
        if ( null != bundle ) {
            m_whichPlayer = bundle.getInt( WHICH_PLAYER );
        }
    }

    // DeleteCallback interface
    public void deleteCalled( XWListItem item )
    {
        if ( m_gi.delete( item.getPosition() ) ) {
            loadPlayersList();
        }
    }

    // NoNameFound interface
    public void NoNameFound()
    {
        showDialog( NO_NAME_FOUND );
    }

    @Override
    public void dlgButtonClicked( int id, int button )
    {
        switch( id ) {
        case LOCKED_CHANGE_ACTION:
            if ( AlertDialog.BUTTON_POSITIVE == button ) {
                handleLockedChange();
            }
            break;
        default:
            Assert.fail();
        }
    }

    public void onClick( View view ) 
    {
        if ( m_addPlayerButton == view ) {
            int curIndex = m_gi.nPlayers;
            if ( curIndex < CurGameInfo.MAX_NUM_PLAYERS ) {
                m_gi.addPlayer(); // ups nPlayers
                loadPlayersList();
            }
        } else if ( m_jugglePlayersButton == view ) {
            m_gi.juggle();
            loadPlayersList();
        } else if ( m_joinPublicCheck == view ) {
            adjustConnectStuff();
        } else if ( m_gameLockedCheck == view ) {
            showNotAgainDlgThen( R.string.not_again_unlock, 
                                 R.string.key_notagain_unlock,
                                 LOCKED_CHANGE_ACTION );
        } else if ( m_refreshRoomsButton == view ) {
            refreshNames();
        } else if ( m_playButton == view ) {
            // Launch BoardActivity for m_name, but ONLY IF user
            // confirms any changes required.  So we either launch
            // from here if there's no confirmation needed, or launch
            // a new dialog whose OK button does the same thing.
            saveChanges();
            if ( !m_gameStarted ) { // no confirm needed 
                applyChanges( true );
                launchGame();
            } else if ( m_giOrig.changesMatter(m_gi) 
                        || (! m_notNetworkedGame
                            && m_carOrig.changesMatter(m_car) ) ) {
                showDialog( CONFIRM_CHANGE_PLAY );
            } else {
                applyChanges( false );
                launchGame();
            }

        } else {
            Utils.logf( ""unknown v: "" + view.toString() );
        }
    } // onClick

    @Override
    public boolean onKeyDown( int keyCode, KeyEvent event )
    {
        boolean consumed = false;
        if ( keyCode == KeyEvent.KEYCODE_BACK ) {
            saveChanges();
            if ( !m_gameStarted ) { // no confirm needed 
                applyChanges( true );
            } else if ( m_giOrig.changesMatter(m_gi) 
                        || (! m_notNetworkedGame
                            && m_carOrig.changesMatter(m_car) ) ) {
                showDialog( CONFIRM_CHANGE );
                consumed = true; // don't dismiss activity yet!
            } else {
                applyChanges( false );
            }
        }

        return consumed || super.onKeyDown( keyCode, event );
    }

    private void loadPlayersList()
    {
        m_playerLayout.removeAllViews();

        String[] names = m_gi.visibleNames( false );
        // only enable delete if one will remain (or two if networked)
        boolean canDelete = names.length > 2
            || (m_notNetworkedGame && names.length > 1);
        LayoutInflater factory = LayoutInflater.from(this);
        for ( int ii = 0; ii < names.length; ++ii ) {

            final XWListItem view
                = (XWListItem)factory.inflate( R.layout.list_item, null );
            view.setPosition( ii );
            view.setText( names[ii] );
            view.setGravity( Gravity.CENTER );
            if ( canDelete ) {
                view.setDeleteCallback( this );
            }

            view.setOnClickListener( new View.OnClickListener() {
                    @Override
                    public void onClick( View view ) {
                        m_whichPlayer = ((XWListItem)view).getPosition();
                        showDialog( PLAYER_EDIT );
                    }
                } );
            m_playerLayout.addView( view );
            view.setEnabled( !m_isLocked );

            View divider = factory.inflate( R.layout.divider_view, null );
            divider.setVisibility( View.VISIBLE );
            m_playerLayout.addView( divider );
        }

        m_addPlayerButton
            .setVisibility( names.length >= CurGameInfo.MAX_NUM_PLAYERS?
                            View.GONE : View.VISIBLE );
        m_jugglePlayersButton
            .setVisibility( names.length <= 1 ?
                            View.GONE : View.VISIBLE );
        m_connectSet.setVisibility( m_notNetworkedGame?
                                    View.GONE : View.VISIBLE );

        if ( ! m_notNetworkedGame
             && ((0 == m_gi.remoteCount() )
                 || (m_gi.nPlayers == m_gi.remoteCount()) ) ) {
            showDialog( FORCE_REMOTE );
        }
        adjustPlayersLabel();
    } // loadPlayersList

    private String[] buildListWithBrowse( String[] input )
    {
        Arrays.sort( input );
        int browsePosn = input.length;
        String[] result = new String[browsePosn+1];
        result[browsePosn] = getString( R.string.download_dicts );
        
        for ( int ii = 0; ii < browsePosn; ++ii ) {
            String lang = input[ii];
            result[ii] = lang;
        }
        return result;
    }

    private void configDictSpinner( final Dialog dialog, LocalPlayer lp )
    {
        Spinner dictsSpinner = 
            (Spinner)dialog.findViewById( R.id.dict_spinner );
        String fmt = getString( R.string.dicts_list_promptf );
        String lang = DictLangCache.getLangName( this, m_gi.dictLang );
        dictsSpinner.setPrompt(String.format( fmt, lang ) );

        OnItemSelectedListener onSel = 
            new OnItemSelectedListener() {
                @Override
                public void onItemSelected( AdapterView<?> parentView, 
                                            View selectedItemView, 
                                            int position, long id ) {
                    String chosen = 
                        (String)parentView.getItemAtPosition( position );

                    if ( chosen.equals( m_browseText ) ) {
                        DictsActivity.launchAndDownload( GameConfig.this, 
                                                         m_gi.dictLang );
                    }
                }

                @Override
                public void onNothingSelected(AdapterView<?> parentView) {}
            };

        ArrayAdapter<String> adapter = 
            DictLangCache.getDictsAdapter( this, m_gi.dictLang );
        configSpinnerWDownload( dictsSpinner, adapter, onSel, 
                                m_gi.dictName(lp) );
    }

    private void configLangSpinner()
    {
        OnItemSelectedListener onSel = 
            new OnItemSelectedListener() {
                @Override
                public void onItemSelected(AdapterView<?> parentView, 
                                           View selectedItemView, 
                                           int position, long id ) {
                    String chosen = 
                        (String)parentView.getItemAtPosition( position );
                    if ( chosen.equals( m_browseText ) ) {
                        DictsActivity.launchAndDownload( GameConfig.this, 0 );
                    } else {
                        m_gi.setLang( DictLangCache.
                                      getLangLangCode( GameConfig.this, 
                                                       chosen ) );
                    }
                }

                @Override
                    public void onNothingSelected(AdapterView<?> parentView) {}
            };

        ArrayAdapter<String> adapter = 
            DictLangCache.getLangsAdapter( this );
        String lang = DictLangCache.getLangName( this, m_gi.dictLang );
        configSpinnerWDownload( m_langSpinner, adapter, onSel, lang );
    }

    private void configSpinnerWDownload( Spinner spinner, 
                                         ArrayAdapter<String> adapter,
                                         OnItemSelectedListener onSel,
                                         String curSel )
    {
        int resID = android.R.layout.simple_spinner_dropdown_item;
        adapter.setDropDownViewResource( resID );
        spinner.setAdapter( adapter );
        spinner.setOnItemSelectedListener( onSel );
        setSpinnerSelection( spinner, adapter, curSel );
    }

    private void setSpinnerSelection( Spinner spinner, 
                                      ArrayAdapter<String> adapter,
                                      String sel )
    {
        for ( int ii = 0; ii < adapter.getCount(); ++ii ) {
            if ( sel.equals( adapter.getItem(ii) ) ) {
                spinner.setSelection( ii );
                break;
            }
        }
    }

    private void setSmartnessSpinner()
    {
        int setting = -1;
        switch ( m_gi.getRobotSmartness() ) {
        case 1:
            setting = 0;
            break;
        case 50:
            setting = 1;
            break;
        case 99:
        case 100:
            setting = 2;
            break;
        default:
            Utils.logf( ""setSmartnessSpinner got %d from getRobotSmartness()"", 
                        m_gi.getRobotSmartness() );
            Assert.fail();
        }
        m_smartnessSpinner.setSelection( setting );
    }

    // private void configConnectSpinner()
    // {
    //     m_connectSpinner = (Spinner)findViewById( R.id.connect_spinner );
    //     m_connStrings = makeXportStrings();
    //     ArrayAdapter<String> adapter = 
    //         new ArrayAdapter<String>( this,
    //                                   android.R.layout.simple_spinner_item,
    //                                   m_connStrings );
    //     adapter.setDropDownViewResource( android.R.layout
    //                                      .simple_spinner_dropdown_item );
    //     m_connectSpinner.setAdapter( adapter );
    //     m_connectSpinner.setSelection( connTypeToPos( m_car.conType ) );
    //     AdapterView.OnItemSelectedListener
    //         lstnr = new AdapterView.OnItemSelectedListener() {
    //                 @Override
    //                 public void onItemSelected(AdapterView<?> parentView, 
    //                                            View selectedItemView, 
    //                                            int position, 
    //                                            long id ) 
    //                 {
    //                     String fmt = getString( R.string.configure_rolef );
    //                     m_configureButton
    //                         .setText( String.format( fmt, 
    //                                                  m_connStrings[position] ));
    //                 }

    //                 @Override
    //                 public void onNothingSelected(AdapterView<?> parentView) 
    //                 {
    //                 }
    //             };
    //     m_connectSpinner.setOnItemSelectedListener( lstnr );

    // } // configConnectSpinner

    private void adjustPlayersLabel()
    {
        Utils.logf( ""adjustPlayersLabel()"" );
        String label;
        if ( m_notNetworkedGame ) {
            label = getString( R.string.players_label_standalone );
        } else {
            String fmt = getString( R.string.players_label_host );
            int remoteCount = m_gi.remoteCount();
            label = String.format( fmt, m_gi.nPlayers - remoteCount, 
                                   remoteCount );
        }
        ((TextView)findViewById( R.id.players_label )).setText( label );
    }

    private void adjustConnectStuff()
    {
        if ( m_joinPublicCheck.isChecked() ) {
            refreshNames();
            m_privateRoomsSet.setVisibility( View.GONE );
            m_publicRoomsSet.setVisibility( View.VISIBLE );

            // // make the room spinner match the saved value if present
            // String invite = m_car.ip_relay_invite;
            // ArrayAdapter<String> adapter = 
            //     (ArrayAdapter<String>)m_roomChoose.getAdapter();
            // if ( null != adapter ) {
            //     for ( int ii = 0; ii < adapter.getCount(); ++ii ) {
            //         if ( adapter.getItem(ii).equals( invite ) ) {
            //             m_roomChoose.setSelection( ii );
            //             break;
            //         }
            //     }
            // }

        } else {
            m_privateRoomsSet.setVisibility( View.VISIBLE );
            m_publicRoomsSet.setVisibility( View.GONE );
        }
    }

    // User's toggling whether everything's locked.  That should mean
    // we enable/disable a bunch of widgits.  And if we're going from
    // unlocked to locked we need to confirm that everything can be
    // reverted.
    private void handleLockedChange()
    {
        boolean locking = m_gameLockedCheck.isChecked();
        m_isLocked = locking;
        for ( int id : s_disabledWhenLocked ) {
            View view = findViewById( id );
            view.setEnabled( !m_isLocked );
        }
        if ( null != m_playerLayout ) {
            for ( int ii = m_playerLayout.getChildCount()-1; ii >= 0; --ii ) {
                View view = m_playerLayout.getChildAt( ii );
                view.setEnabled( !m_isLocked );
            }
        }
    }
    
    private int connTypeToPos( CommsAddrRec.CommsConnType typ )
    {
        switch( typ ) {
        case COMMS_CONN_RELAY:
            return 0;
        case COMMS_CONN_SMS:
            return 1;
        case COMMS_CONN_BT:
            return 2;
        }
        return -1;
    }

    private int layoutForDlg( int id ) 
    {
        switch( id ) {
        // case ROLE_EDIT_RELAY:
        //     return R.layout.role_edit_relay;
        // case ROLE_EDIT_SMS:
        //     return R.layout.role_edit_sms;
        // case ROLE_EDIT_BT:
        //     return R.layout.role_edit_bt;
        case FORCE_REMOTE:
            return R.layout.force_remote;
        }
        Assert.fail();
        return 0;
    }

    private int titleForDlg( int id ) 
    {
        switch( id ) {
        // case ROLE_EDIT_RELAY:
        //     return R.string.tab_relay;
        // case ROLE_EDIT_SMS:
        //     return R.string.tab_sms;
        // case ROLE_EDIT_BT:
        //     return R.string.tab_bluetooth;
        }
        Assert.fail();
        return -1;
    }

    private String[] makeXportStrings()
    {
        ArrayList<String> strings = new ArrayList<String>();
        ArrayList<CommsAddrRec.CommsConnType> types
            = new ArrayList<CommsAddrRec.CommsConnType>();

        strings.add( getString(R.string.tab_relay) );
        types.add( CommsAddrRec.CommsConnType.COMMS_CONN_RELAY );

        if ( m_canDoSMS ) {
            strings.add( getString(R.string.tab_sms) );
            types.add( CommsAddrRec.CommsConnType.COMMS_CONN_SMS );
        }
        if ( m_canDoBT ) {
            strings.add( getString(R.string.tab_bluetooth) );
            types.add( CommsAddrRec.CommsConnType.COMMS_CONN_BT );
        }
        m_types = types.toArray( new CommsAddrRec.CommsConnType[types.size()] );
        return strings.toArray( new String[strings.size()] );
    }

    private void saveChanges()
    {
        m_gi.hintsNotAllowed = !Utils.getChecked( this, R.id.hints_allowed );
        m_gi.timerEnabled = Utils.getChecked(  this, R.id.use_timer );
        m_gi.gameSeconds = 60 * m_gi.nPlayers *
            Utils.getInt(  this, R.id.timer_minutes_edit );

        int position = m_phoniesSpinner.getSelectedItemPosition();
        m_gi.phoniesAction = CurGameInfo.XWPhoniesChoice.values()[position];

        position = m_smartnessSpinner.getSelectedItemPosition();
        m_gi.setRobotSmartness(position * 49 + 1);

        if ( !m_notNetworkedGame ) {
            m_car.ip_relay_seeksPublicRoom = m_joinPublicCheck.isChecked();
            Utils.logf( ""ip_relay_seeksPublicRoom: %b"", 
                        m_car.ip_relay_seeksPublicRoom );
            m_car.ip_relay_advertiseRoom = 
                Utils.getChecked( this, R.id.advertise_new_room_check );
            if ( m_car.ip_relay_seeksPublicRoom ) {
                SpinnerAdapter adapter = m_roomChoose.getAdapter();
                if ( null != adapter ) {
                    int pos = m_roomChoose.getSelectedItemPosition();
                    if ( pos >= 0 && pos < adapter.getCount() ) {
                        m_car.ip_relay_invite = (String)adapter.getItem(pos);
                    }
                }
            } else {
                m_car.ip_relay_invite = 
                    Utils.getText( this, R.id.room_edit ).trim();
            }
        }

        // position = m_connectSpinner.getSelectedItemPosition();
        // m_car.conType = m_types[ position ];

        m_car.conType = m_notNetworkedGame
            ? CommsAddrRec.CommsConnType.COMMS_CONN_NONE
            : CommsAddrRec.CommsConnType.COMMS_CONN_RELAY;
    } // saveChanges

    private void applyChanges( boolean forceNew )
    {
        GameUtils.applyChanges( this, m_gi, m_car, m_gameLock, forceNew );
    }

    private void launchGame()
    {
        if ( m_notNetworkedGame || m_car.ip_relay_invite.length() > 0 ) {
            m_gameLock.unlock();
            m_gameLock = null;
            GameUtils.launchGameAndFinish( this, m_rowid );
        } else {
            showOKOnlyDialog( R.string.no_empty_rooms );            
        }
    }

    private void refreshNames()
    {
        if ( !m_isLocked ) {
            new RefreshNamesTask( this, this, m_gi.dictLang, 
                                  m_gi.nPlayers, m_roomChoose ).execute();
        }
    }

    private void setTitle()
    {
        String fmt = getString( m_notNetworkedGame ?
                                R.string.title_game_configf
                                : R.string.title_gamenet_configf );
        setTitle( String.format( fmt, GameUtils.getName( this, m_rowid ) ) );
    }

}
",True,6,43,0,0,3,21,0,14,L3
35,org.eehouse.android.xw4.StatusReceiver.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

public class StatusReceiver extends BroadcastReceiver {

    @Override
    public void onReceive( Context context, Intent intent ) 
    {
        Utils.logf( ""StatusReceiver.onReceive called: %s"", intent.toString() );
    }

}
",False,3,2,0,0,1,1,0,1,L3
36,org.eehouse.android.xw4.RefreshNamesTask.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.ProgressDialog;
import android.os.AsyncTask;
import android.content.Context;
import android.widget.ArrayAdapter;
import android.widget.Spinner;
import java.io.InputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.util.ArrayList;
import java.net.Socket;

public class RefreshNamesTask extends AsyncTask<Void, Void, String[]> {

    public interface NoNameFound {
        public void NoNameFound();
    };

    private Context m_context;
    private Spinner m_resultSpinner;
    private int m_lang;
    private int m_nInGame;
    private ProgressDialog m_progress;
    private NoNameFound m_nnf;

    public RefreshNamesTask( Context context, NoNameFound nnf,
                             int lang, int nInGame, 
                             Spinner getsResults )
    {
        super();
        m_context = context;
        m_nnf = nnf;
        m_resultSpinner = getsResults;
        m_lang = lang;
        m_nInGame = nInGame;

        String fmt = context.getString( R.string.public_names_progress );
        String msg = String.format( fmt, nInGame, 
                                    DictLangCache.getLangName(context,lang) );

        m_progress = ProgressDialog.show( context, msg, null, true, 
                                          true );
    }

    @Override
    protected String[] doInBackground( Void...unused ) 
    {
        ArrayList<String> names = new ArrayList<String>();
        Utils.logf( ""doInBackground()"" );

        try {
            Socket socket = NetUtils.MakeProxySocket( m_context, 15000 );
            if ( null != socket ) {
                DataOutputStream outStream = 
                    new DataOutputStream( socket.getOutputStream() );
        
                outStream.writeShort( 4 );                // total packet length
                outStream.writeByte( NetUtils.PROTOCOL_VERSION );
                outStream.writeByte( NetUtils.PRX_PUB_ROOMS );
                outStream.writeByte( (byte)m_lang );
                outStream.writeByte( (byte)m_nInGame );
                outStream.flush();

                // read result -- will block
                DataInputStream dis = 
                    new DataInputStream(socket.getInputStream());
                short len = dis.readShort();
                short nRooms = dis.readShort();
                Utils.logf( ""%s: got %d rooms"", ""doInBackground"", nRooms );

                // Can't figure out how to read a null-terminated string
                // from DataInputStream so parse it myself.
                byte[] bytes = new byte[len];
                dis.read( bytes );

                int index = -1;
                for ( int ii = 0; ii < nRooms; ++ii ) {
                    int lastIndex = ++index; // skip the null
                    while ( bytes[index] != '\n' ) {
                        ++index;
                    }
                    String name = new String( bytes, lastIndex, index - lastIndex );
                    Utils.logf( ""got public room name: %s"", name );
                    int indx = name.lastIndexOf( ""/"" );
                    indx = name.lastIndexOf( ""/"", indx-1 );
                    names.add( name.substring(0, indx ) );
                }
            }
        } catch ( java.io.IOException ioe ) {
            Utils.logf( ""%s"", ioe.toString() );
        }
        Utils.logf( ""doInBackground() returning"" );
        return names.toArray( new String[names.size()] );        
    }

     // protected void onProgressUpdate(Integer... progress) {
     //     setProgressPercent(progress[0]);
     // }

    @Override
     protected void onPostExecute( String[] result )
     {
         Utils.logf( ""onPostExecute()"" );
         ArrayAdapter<String> adapter = 
             new ArrayAdapter<String>( m_context,
                                       android.R.layout.simple_spinner_item,
                                       result );
         int resID = android.R.layout.simple_spinner_dropdown_item;
         adapter.setDropDownViewResource( resID );
         m_resultSpinner.setAdapter( adapter );

         m_progress.cancel();

         if ( result.length == 0 ) {
             m_nnf.NoNameFound();
         }

         Utils.logf( ""onPostExecute() done"" );
     }
}
",True,58,39,1,1,5,14,1,3,L3
37,org.eehouse.android.xw4.NetStateCache.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.NetworkInfo;
import android.net.ConnectivityManager;
import java.util.HashSet;
import java.util.Iterator;
import android.os.Build;
import junit.framework.Assert;

public class NetStateCache {

    public interface StateChangedIf {
        public void netAvail( boolean nowAvailable );
    }

    private static Boolean s_haveReceiver = new Boolean( false );
    private static HashSet<StateChangedIf> s_ifs;
    private static boolean s_netAvail = false;
    private static CommsBroadcastReceiver s_receiver;
    private static final boolean s_onSim = Build.PRODUCT.contains(""sdk"");

    public static void register( Context context, StateChangedIf proc )
    {
        initIfNot( context );
        synchronized( s_ifs ) {
            s_ifs.add( proc );
        }
    }

    public static void unregister( Context context, StateChangedIf proc )
    {
        initIfNot( context );
        synchronized( s_ifs ) {
            s_ifs.remove( proc );
        }
    }

    public static boolean netAvail( Context context )
    {
        initIfNot( context );
        return s_netAvail || s_onSim;
    }

    private static void initIfNot( Context context )
    {
        synchronized( s_haveReceiver ) {
            if ( !s_haveReceiver ) {
                // First figure out the current net state.  Note that
                // this doesn't seem to work on the emulator.

                ConnectivityManager connMgr = (ConnectivityManager)
                    context.getSystemService( Context.CONNECTIVITY_SERVICE );
                NetworkInfo ni = connMgr.getActiveNetworkInfo();

                s_netAvail = ni != null && ni.isAvailable() && ni.isConnected();

                s_receiver = new CommsBroadcastReceiver();
                IntentFilter filter = new IntentFilter();
                filter.addAction( ConnectivityManager.CONNECTIVITY_ACTION );

                Intent intent = context.getApplicationContext().
                    registerReceiver( s_receiver, filter );

                s_ifs = new HashSet<StateChangedIf>();
                s_haveReceiver = true;
            }
        }
    }

    private static class CommsBroadcastReceiver extends BroadcastReceiver {
        @Override
        public void onReceive( Context context, Intent intent ) 
        {
            if ( intent.getAction().
                 equals( ConnectivityManager.CONNECTIVITY_ACTION)) {

                NetworkInfo ni = (NetworkInfo)intent.
                    getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
                Utils.logf( ""CommsTransport::onReceive: %s"", 
                            ni.getState().toString() );

                boolean netAvail;
                switch ( ni.getState() ) {
                case CONNECTED:
                    netAvail = true;
                    break;
                case DISCONNECTED:
                    netAvail = false;
                    break;
                default:
                    // ignore everything else
                    netAvail = s_netAvail;
                    break;
                }

                if ( s_netAvail != netAvail ) {
                    Iterator<StateChangedIf> iter = s_ifs.iterator();
                    while ( iter.hasNext() ) {
                        StateChangedIf proc = iter.next();
                        proc.netAvail( netAvail );
                    }
                    s_netAvail = netAvail;
                }
            }
        }
    } // class CommsBroadcastReceiver

}

",True,8,37,10,7,1,1,1,1,L1
38,org.eehouse.android.xw4.BoardView.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.view.View;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.content.Context;
import android.util.AttributeSet;
import org.eehouse.android.xw4.jni.*;
import android.view.MotionEvent;
import android.graphics.drawable.Drawable;
import android.content.res.Resources;
import android.graphics.Paint.FontMetricsInt;
import android.os.Handler;
import java.nio.IntBuffer;

import junit.framework.Assert;

public class BoardView extends View implements DrawCtx, BoardHandler,
                                               SyncedDraw {
    private static final float MIN_FONT_DIPS = 14.0f;

    private static Bitmap s_bitmap;    // the board
    private static final int IN_TRADE_ALPHA = 0x3FFFFFFF;

    private Context m_context;
    private Paint m_drawPaint;
    private Paint m_fillPaint;
    private Paint m_strokePaint;
    private int m_defaultFontHt;
    private int m_mediumFontHt;
    private Paint m_tileStrokePaint;
    private int m_jniGamePtr;
    private CurGameInfo m_gi;
    private int m_layoutWidth;
    private int m_layoutHeight;
    private Canvas m_canvas;    // owns the bitmap
    private int m_trayOwner;
    private Rect m_valRect;
    private Rect m_letterRect;
    private Drawable m_rightArrow;
    private Drawable m_downArrow;
    private boolean m_blackArrow;
    private boolean m_inTrade = false;
    // m_backgroundUsed: alpha not set ensures inequality
    private int m_backgroundUsed = 0x00000000;
    private boolean m_darkOnLight;
    private Drawable m_origin;
    private int m_left, m_top;
    private JNIThread m_jniThread;
    private XWActivity m_parent;
    private String[][] m_scores;
    private String[] m_dictChars;
    private Rect m_boundsScratch;
    private String m_remText;
    private int m_dictPtr = 0;
    private int m_lastSecsLeft;
    private int m_lastTimerPlayer;
    private Handler m_viewHandler;

    // FontDims: exists to translate space available to the largest
    // font we can draw within that space taking advantage of our use
    // being limited to a known small subset of glyphs.  We need two
    // numbers from this: the textHeight to pass to Paint.setTextSize,
    // and the descent to use when drawing.  Both can be calculated
    // proportionally.  We know the ht we passed to Paint to get the
    // height we've now measured; that gives a percent to multiply any
    // future wantHt by.  Ditto for the descent
    private class FontDims {
        FontDims( float askedHt, int topRow, int bottomRow, float width ) {
            // Utils.logf( ""FontDims(): askedHt="" + askedHt );
            // Utils.logf( ""FontDims(): topRow="" + topRow );
            // Utils.logf( ""FontDims(): bottomRow="" + bottomRow );
            // Utils.logf( ""FontDims(): width="" + width );
            float gotHt = bottomRow - topRow + 1;
            m_htProportion = gotHt / askedHt;
            Assert.assertTrue( (bottomRow+1) >= askedHt );
            float descent = (bottomRow+1) - askedHt;
            // Utils.logf( ""descent: "" + descent );
            m_descentProportion = descent / askedHt;
            Assert.assertTrue( m_descentProportion >= 0 );
            m_widthProportion = width / askedHt;
            // Utils.logf( ""m_htProportion: "" + m_htProportion );
            // Utils.logf( ""m_descentProportion: "" + m_descentProportion );
        }
        private float m_htProportion;
        private float m_descentProportion;
        private float m_widthProportion;
        int heightFor( int ht ) { return (int)(ht / m_htProportion); }
        int descentFor( int ht ) { return (int)(ht * m_descentProportion); }
        int widthFor( int width ) { return (int)(width / m_widthProportion); }
    }
    private FontDims m_fontDims;

    private static final int BLACK = 0xFF000000;
    private static final int WHITE = 0xFFFFFFFF;
    private static final int FRAME_GREY = 0xFF101010;
    private int[] m_bonusColors;
    private int[] m_playerColors;
    private int[] m_otherColors;
    private String[] m_bonusSummaries;

    // called when inflating xml
    public BoardView( Context context, AttributeSet attrs ) 
    {
        super( context, attrs );

        m_context = context;
        final float scale = getResources().getDisplayMetrics().density;
        m_defaultFontHt = (int)(MIN_FONT_DIPS * scale + 0.5f);
        m_mediumFontHt = m_defaultFontHt * 3 / 2;

        m_drawPaint = new Paint();
        m_fillPaint = new Paint( Paint.ANTI_ALIAS_FLAG );
        m_strokePaint = new Paint();
        m_strokePaint.setStyle( Paint.Style.STROKE );
        m_tileStrokePaint = new Paint();
        m_tileStrokePaint.setStyle( Paint.Style.STROKE );
        float curWidth = m_tileStrokePaint.getStrokeWidth();
        curWidth *= 2;
        if ( curWidth < 2 ) {
            curWidth = 2;
        }
        m_tileStrokePaint.setStrokeWidth( curWidth );

        Resources res = getResources();
        m_origin = res.getDrawable( R.drawable.origin );

        m_boundsScratch = new Rect();

        CommonPrefs prefs = CommonPrefs.get(context);
        m_playerColors = prefs.playerColors;
        m_bonusColors = prefs.bonusColors;
        m_otherColors = prefs.otherColors;

        m_bonusSummaries = new String[5];
        int[] ids = { R.string.bonus_l2x_summary,
                      R.string.bonus_w2x_summary ,
                      R.string.bonus_l3x_summary,
                      R.string.bonus_w3x_summary };
        for ( int ii = 0; ii < ids.length; ++ii ) {
            m_bonusSummaries[ ii+1 ] = getResources().getString( ids[ii] );
        }

        m_viewHandler = new Handler();
    }

    public boolean onTouchEvent( MotionEvent event ) 
    {
        int action = event.getAction();
        int xx = (int)event.getX() - m_left;
        int yy = (int)event.getY() - m_top;
        
        switch ( action ) {
        case MotionEvent.ACTION_DOWN:
            m_jniThread.handle( JNIThread.JNICmd.CMD_PEN_DOWN, xx, yy );
            break;
        case MotionEvent.ACTION_MOVE:
            m_jniThread.handle( JNIThread.JNICmd.CMD_PEN_MOVE, xx, yy );
            break;
        case MotionEvent.ACTION_UP:
            m_jniThread.handle( JNIThread.JNICmd.CMD_PEN_UP, xx, yy );
            break;
        default:
            Utils.logf( ""unknown action: %d"", action );
            Utils.logf( event.toString() );
        }

        return true;             // required to get subsequent events
    }

    // This will be called from the UI thread
    @Override
    protected void onDraw( Canvas canvas ) 
    {
        synchronized( this ) {
            if ( layoutBoardOnce() ) {
                canvas.drawBitmap( s_bitmap, m_left, m_top, m_drawPaint );
            }
        }
    }

    private BoardDims figureBoardDims( int width, int height,
                                       CurGameInfo gi )
    {
        BoardDims result = new BoardDims();
        result.width = width;
        result.left = 0;

        int nCells = gi.boardSize;
        int cellSize = width / nCells;
        int maxCellSize = 3 * m_defaultFontHt;
        if ( cellSize > maxCellSize ) {
            cellSize = maxCellSize;

            int boardWidth = nCells * cellSize;
            result.left = (width - boardWidth) / 2;
            result.width = boardWidth;
        }
        result.maxCellSize = maxCellSize;

        result.trayHt = cellSize * 3;
        result.scoreHt = 2 * m_defaultFontHt;
        int wantHt = result.trayHt + result.scoreHt + (cellSize * nCells);
        int nToScroll = 0;
        if ( wantHt <= height ) {
            result.top = (height - wantHt) / 2;
        } else {
            int minTray = 3 * m_defaultFontHt;
            nToScroll = 
                nCells - ((height - minTray - result.scoreHt) / cellSize);
            result.trayHt = 
                height - result.scoreHt - (cellSize * (nCells-nToScroll));
            result.top = 0;
        }

        result.boardHt = cellSize * (nCells-nToScroll);
        result.trayTop = result.scoreHt + result.boardHt;
        result.height = result.scoreHt + result.boardHt + result.trayHt;
        result.cellSize = cellSize;

        if ( gi.timerEnabled ) {
            Paint paint = new Paint();
            paint.setTextSize( m_mediumFontHt );
            paint.getTextBounds( ""-00:00"", 0, 6, m_boundsScratch );
            result.timerWidth = m_boundsScratch.width();
        }

        return result;
    } // figureBoardDims

    private boolean layoutBoardOnce() 
    {
        final int width = getWidth();
        final int height = getHeight();
        boolean layoutDone = width == m_layoutWidth && height == m_layoutHeight;
        if ( layoutDone ) {
            // nothing to do
        } else if ( null == m_gi ) {
            // nothing to do either
        } else {
            m_layoutWidth = width;
            m_layoutHeight = height;
            m_fontDims = null; // force recalc of font
            m_letterRect = null;
            m_valRect = null;

            BoardDims dims = figureBoardDims( width, height, m_gi );
            m_left = dims.left;
            m_top = dims.top;
            
            if ( null == s_bitmap ) {
                s_bitmap = Bitmap.createBitmap( 1 + dims.width,
                                                1 + dims.height,
                                                Bitmap.Config.ARGB_8888 );
            }
            m_canvas = new Canvas( s_bitmap );

            // Clear it
            fillRect( new Rect( 0, 0, width, height ), WHITE );

            // need to synchronize??
            m_jniThread.handle( JNIThread.JNICmd.CMD_LAYOUT, dims );
            m_jniThread.handle( JNIThread.JNICmd.CMD_DRAW );
            layoutDone = true;
        }
        return layoutDone;
    } // layoutBoardOnce

    // BoardHandler interface implementation
    public void startHandling( XWActivity parent, JNIThread thread, 
                               int gamePtr, CurGameInfo gi ) 
    {
        m_parent = parent;
        m_jniThread = thread;
        m_jniGamePtr = gamePtr;
        m_gi = gi;
        m_layoutWidth = 0;
        m_layoutHeight = 0;
    }

    // SyncedDraw interface implementation
    public void doJNIDraw()
    {
        boolean drew;
        synchronized( this ) {
            drew = XwJNI.board_draw( m_jniGamePtr );
        }
        if ( !drew ) {
            Utils.logf( ""draw not complete"" );
        }
    }

    public void doIconDraw( int resID, final Rect rect )
    {
        synchronized( this ) {
            if ( null != m_canvas ) {
                if ( 0 == resID ) {
                    fillRectOther( rect, CommonPrefs.COLOR_BACKGRND );
                } else {
                    Drawable icon = getResources().getDrawable( resID );
                    icon.setBounds( rect );
                    icon.draw( m_canvas );
                }
            }
        }
    }

    public void setInTrade( boolean inTrade ) 
    {
        m_inTrade = inTrade;
        m_jniThread.handle( JNIThread.JNICmd.CMD_INVALALL );
    }

    // DrawCtxt interface implementation
    public boolean scoreBegin( Rect rect, int numPlayers, int[] scores, 
                               int remCount, int dfs )
    {
        fillRectOther( rect, CommonPrefs.COLOR_BACKGRND );
        m_canvas.save( Canvas.CLIP_SAVE_FLAG );
        m_canvas.clipRect(rect);
        m_scores = new String[numPlayers][];
        return true;
    }

    public void measureRemText( Rect r, int nTilesLeft, int[] width, 
                                int[] height ) 
    {
        if ( nTilesLeft > 0 ) {
            // should cache a formatter
            m_remText = String.format( ""%d"", nTilesLeft );
            m_fillPaint.setTextSize( m_mediumFontHt );
            m_fillPaint.getTextBounds( m_remText, 0, m_remText.length(), 
                                       m_boundsScratch );

            int minWidth = m_boundsScratch.width();
            if ( minWidth < 20 ) {
                minWidth = 20; // it's a button; make it bigger
            }
            width[0] = minWidth;
            height[0] = m_boundsScratch.height();
        } else {
            width[0] = height[0] = 0;
        }
    }

    public void drawRemText( Rect rInner, Rect rOuter, int nTilesLeft, 
                             boolean focussed )
    {
        int indx = focussed ? CommonPrefs.COLOR_FOCUS
            : CommonPrefs.COLOR_TILE_BACK;
        fillRectOther( rOuter, indx );

        m_fillPaint.setColor( adjustColor(BLACK) );
        drawCentered( m_remText, rInner, null );
    }

    public void measureScoreText( Rect r, DrawScoreInfo dsi, 
                                  int[] width, int[] height )
    {
        String[] scoreInfo = new String[dsi.isTurn?1:2];
        int indx = 0;
        StringBuffer sb = new StringBuffer();

        // If it's my turn I get one line.  Otherwise squeeze into
        // two.

        if ( dsi.isTurn ) {
            sb.append( dsi.name );
            sb.append( "":"" );
        } else {
            scoreInfo[indx++] = dsi.name;
        }
        sb.append( dsi.totalScore );
        if ( dsi.nTilesLeft >= 0 ) {
            sb.append( "":"" );
            sb.append( dsi.nTilesLeft );
        }
        scoreInfo[indx] = sb.toString();
        m_scores[dsi.playerNum] = scoreInfo;

        m_fillPaint.setTextSize( dsi.isTurn? r.height() : m_defaultFontHt );

        int needWidth = 0;
        for ( int ii = 0; ii < scoreInfo.length; ++ii ) {
            m_fillPaint.getTextBounds( scoreInfo[ii], 0, scoreInfo[ii].length(), 
                                       m_boundsScratch );
            if ( needWidth < m_boundsScratch.width() ) {
                needWidth = m_boundsScratch.width();
            }
        }
        if ( needWidth > r.width() ) {
            needWidth = r.width();
        }
        width[0] = needWidth;

        height[0] = r.height();
    }

    public void score_drawPlayer( Rect rInner, Rect rOuter, DrawScoreInfo dsi )
    {
        if ( 0 != (dsi.flags & CELL_ISCURSOR) ) {
            fillRectOther( rOuter, CommonPrefs.COLOR_FOCUS );
        }
        String[] texts = m_scores[dsi.playerNum];
        int color = m_playerColors[dsi.playerNum];
        if ( !CommonPrefs.get(m_context).allowPeek ) {
            color = adjustColor( color );
        }
        m_fillPaint.setColor( color );

        Rect rect = new Rect( rOuter );
        int height = rect.height() / texts.length;
        rect.bottom = rect.top + height;
        for ( String text : texts ) {
            drawCentered( text, rect, null );
            rect.offset( 0, height );
        }
    }

    public void drawTimer( Rect rect, int player, int secondsLeft )
    {
        if ( null != m_canvas && (m_lastSecsLeft != secondsLeft
                                  || m_lastTimerPlayer != player) ) {
            m_lastSecsLeft = secondsLeft;
            m_lastTimerPlayer = player;

            String negSign = secondsLeft < 0? ""-"":"""";
            secondsLeft = Math.abs( secondsLeft );
            String time = String.format( ""%s%d:%02d"", negSign, secondsLeft/60, 
                                         secondsLeft%60 );

            fillRectOther( rect, CommonPrefs.COLOR_BACKGRND );
            m_fillPaint.setColor( m_playerColors[player] );

            Rect shorter = new Rect( rect );
            shorter.inset( 0, shorter.height() / 5 );
            drawCentered( time, shorter, null );

            m_jniThread.handle( JNIThread.JNICmd.CMD_DRAW );
        }
    }

    public boolean boardBegin( Rect rect, int cellWidth, int cellHeight, 
                               int dfs )
    {
        return true;
    }

    public boolean drawCell( final Rect rect, String text, int tile, int owner, 
                             int bonus, int hintAtts, final int flags ) 
    {
        boolean canDraw = figureFontDims();
        if ( canDraw ) {
            int backColor;
            boolean empty = 0 != (flags & (CELL_DRAGSRC|CELL_ISEMPTY));
            boolean pending = 0 != (flags & CELL_HIGHLIGHT);
            String bonusStr = null;

            if ( m_inTrade ) {
                fillRectOther( rect, CommonPrefs.COLOR_BACKGRND );
            }

            if ( owner < 0 ) {
                owner = 0;
            }
            int foreColor = m_playerColors[owner];

            if ( 0 != (flags & CELL_ISCURSOR) ) {
                backColor = m_otherColors[CommonPrefs.COLOR_FOCUS];
            } else if ( empty ) {
                if ( 0 == bonus ) {
                    backColor = m_otherColors[CommonPrefs.COLOR_NOTILE];
                } else {
                    backColor = m_bonusColors[bonus];
                    bonusStr = m_bonusSummaries[bonus];
                }
            } else if ( pending ) {
                if ( darkOnLight() ) {
                    foreColor = WHITE;
                    backColor = BLACK;
                } else {
                    foreColor = BLACK;
                    backColor = WHITE;
                }
            } else {
                backColor = m_otherColors[CommonPrefs.COLOR_TILE_BACK];
            }

            fillRect( rect, adjustColor( backColor ) );

            if ( empty ) {
                if ( (CELL_ISSTAR & flags) != 0 ) {
                    m_origin.setBounds( rect );
                    m_origin.setAlpha( m_inTrade? IN_TRADE_ALPHA >> 24 : 255 );
                    m_origin.draw( m_canvas );
                } else if ( null != bonusStr ) {
                    int color = m_otherColors[CommonPrefs.COLOR_BONUSHINT];
                    m_fillPaint.setColor( adjustColor(color) );
                    Rect brect = new Rect( rect );
                    brect.inset( 0, brect.height()/10 );
                    drawCentered( bonusStr, brect, m_fontDims );
                }
            } else {
                m_fillPaint.setColor( adjustColor(foreColor) );
                drawCentered( text, rect, m_fontDims );
            }

            if ( (CELL_ISBLANK & flags) != 0 ) {
                markBlank( rect, backColor );
            }

            // frame the cell
            m_strokePaint.setColor( adjustColor(FRAME_GREY) );
            m_canvas.drawRect( rect, m_strokePaint );

            drawCrosshairs( rect, flags );
        }
        return canDraw;
    } // drawCell

    private boolean m_arrowHintShown = false;
    public void drawBoardArrow( Rect rect, int bonus, boolean vert, 
                                int hintAtts, int flags )
    {
        // figure out if the background is more dark than light
        boolean useDark = darkOnLight();
        if ( m_blackArrow != useDark ) {
            m_blackArrow = useDark;
            m_downArrow = m_rightArrow = null;
        }
        Drawable arrow;
        if ( vert ) {
            if ( null == m_downArrow ) {
                m_downArrow = loadAndRecolor( R.drawable.downarrow, useDark );
            }
            arrow = m_downArrow;
        } else {
            if ( null == m_rightArrow ) {
                m_rightArrow = loadAndRecolor( R.drawable.rightarrow, useDark );
            }
            arrow = m_rightArrow;
        }

        rect.inset( 2, 2 );
        arrow.setBounds( rect );
        arrow.draw( m_canvas );

        if ( !m_arrowHintShown ) {
            m_arrowHintShown = true;
            m_viewHandler.post( new Runnable() {
                    public void run() {
                        m_parent.
                            showNotAgainDlgThen( R.string.not_again_arrow, 
                                                 R.string.key_notagain_arrow );
                    }
                } );
        }
    }

    public boolean trayBegin ( Rect rect, int owner, int dfs ) 
    {
        m_trayOwner = owner;
        return true;
    }

    public void drawTile( Rect rect, String text, int val, int flags ) 
    {
        drawTileImpl( rect, text, val, flags, true );
    }

    public void drawTileMidDrag( Rect rect, String text, int val, int owner, 
                                 int flags ) 
    {
        drawTileImpl( rect, text, val, flags, false );
    }

    public void drawTileBack( Rect rect, int flags ) 
    {
        drawTileImpl( rect, ""?"", -1, flags, true );
    }

    public void drawTrayDivider( Rect rect, int flags ) 
    {
        boolean isCursor = 0 != (flags & CELL_ISCURSOR);
        boolean selected = 0 != (flags & CELL_HIGHLIGHT);

        int index = isCursor? CommonPrefs.COLOR_FOCUS : CommonPrefs.COLOR_BACKGRND;
        rect.inset( 0, 1 );
        fillRectOther( rect, index );

        rect.inset( rect.width()/4, 0 );
        if ( selected ) {
            m_canvas.drawRect( rect, m_strokePaint );
        } else {
            fillRect( rect, m_playerColors[m_trayOwner] );
        }
    }

    public void score_pendingScore( Rect rect, int score, int playerNum, 
                                    int flags ) 
    {
        String text = score >= 0? String.format( ""%d"", score ) : ""??"";
        int otherIndx = (0 == (flags & CELL_ISCURSOR)) 
            ? CommonPrefs.COLOR_BACKGRND : CommonPrefs.COLOR_FOCUS;
        ++rect.top;
        fillRectOther( rect, otherIndx );
        m_fillPaint.setColor( m_playerColors[playerNum] );

        rect.bottom -= rect.height() / 2;
        drawCentered( text, rect, null );

        rect.offset( 0, rect.height() );
        drawCentered( getResources().getString( R.string.pts ), rect, null );
    }

    public void objFinished( /*BoardObjectType*/int typ, Rect rect, int dfs )
    {
        if ( DrawCtx.OBJ_SCORE == typ ) {
            m_canvas.restoreToCount(1); // in case new canvas...
        }
    }

    public void dictChanged( int dictPtr )
    {
        if ( m_dictPtr != dictPtr ) {
            if ( 0 == dictPtr ) {
                m_fontDims = null;
                m_dictChars = null;
            } else if ( m_dictPtr == 0 || 
                        !XwJNI.dict_tilesAreSame( m_dictPtr, dictPtr ) ) {
                m_fontDims = null;
                m_dictChars = XwJNI.dict_getChars( dictPtr );
            }
            m_dictPtr = dictPtr;
        }
    }

    private void drawTileImpl( Rect rect, String text, int val, 
                               int flags, boolean clearBack )
    {
        // boolean valHidden = (flags & CELL_VALHIDDEN) != 0;
        boolean notEmpty = (flags & CELL_ISEMPTY) == 0;
        boolean isCursor = (flags & CELL_ISCURSOR) != 0;

        m_canvas.save( Canvas.CLIP_SAVE_FLAG );
        rect.top += 1;
        m_canvas.clipRect( rect );

        if ( clearBack ) {
            fillRectOther( rect, CommonPrefs.COLOR_BACKGRND );
        }

        if ( isCursor || notEmpty ) {
            int color = m_otherColors[isCursor? CommonPrefs.COLOR_FOCUS 
                                      : CommonPrefs.COLOR_TILE_BACK];
            if ( !clearBack ) {
                color &= 0x7FFFFFFF; // translucent if being dragged.
            }
            fillRect( rect, color );

            m_fillPaint.setColor( m_playerColors[m_trayOwner] );

            if ( notEmpty ) {
                positionDrawTile( rect, text, val );

                m_canvas.drawRect( rect, m_tileStrokePaint); // frame
                if ( 0 != (flags & CELL_HIGHLIGHT) ) {
                    rect.inset( 2, 2 );
                    m_canvas.drawRect( rect, m_tileStrokePaint ); // frame
                }
            }
        }
        m_canvas.restoreToCount(1); // in case new canvas....
    } // drawTileImpl

    private void drawCentered( String text, Rect rect, FontDims fontDims ) 
    {
        int descent = -1;
        int textSize;
        if ( null == fontDims ) {
            textSize = rect.height() - 2;
        } else {
            int height = rect.height() - 4; // borders and padding, 2 each 
            descent = fontDims.descentFor( height );
            textSize = fontDims.heightFor( height );
            // Utils.logf( ""using descent: "" + descent + "" and textSize: "" 
            //             + textSize + "" in height "" + height );
        }
        m_fillPaint.setTextSize( textSize );
        if ( descent == -1 ) {
            descent = m_fillPaint.getFontMetricsInt().descent;
        }
        descent += 2;

        m_fillPaint.getTextBounds( text, 0, text.length(), m_boundsScratch );
        if ( m_boundsScratch.width() > rect.width() ) {
            m_fillPaint.setTextAlign( Paint.Align.LEFT );
            drawScaled( text, rect, descent );
        } else {
            int bottom = rect.bottom - descent;
            int center = rect.left + ( rect.width() / 2 );
            m_fillPaint.setTextAlign( Paint.Align.CENTER );
            m_canvas.drawText( text, center, bottom, m_fillPaint );
        }
    } // drawCentered

    private void drawScaled( String text, final Rect rect, int descent )
    {
        Rect local = new Rect();
        m_fillPaint.getTextBounds( text, 0, text.length(), local );
        local.bottom = rect.height();

        Bitmap bitmap = Bitmap.createBitmap( local.width(),
                                             rect.height(), 
                                             Bitmap.Config.ARGB_8888 );

        Canvas canvas = new Canvas( bitmap );
        int bottom = local.bottom - descent;
        canvas.drawText( text, 0, bottom, m_fillPaint );

        m_canvas.drawBitmap( bitmap, null, rect, m_drawPaint );
    }

    private void positionDrawTile( final Rect rect, String text, int val )
    {
        if ( figureFontDims() ) {
            if ( null != text ) {
                if ( null == m_letterRect ) {
                    m_letterRect = new Rect( 0, 0, rect.width() * 3 / 4, 
                                             rect.height() * 3 / 4 );
                }
                m_letterRect.offsetTo( rect.left+2, rect.top+2 );
                drawCentered( text, m_letterRect, m_fontDims );
            }

            if ( val >= 0 ) {
                if ( null == m_valRect ) {
                    m_valRect = new Rect( 0, 0, rect.width() / 4, rect.height() / 4 );
                    m_valRect.inset( 2, 2 );
                }
                m_valRect.offsetTo( rect.right - (rect.width() / 4),
                                    rect.bottom - (rect.height() / 4) );
                text = String.format( ""%d"", val );
                m_fillPaint.setTextSize( m_valRect.height() );
                m_fillPaint.setTextAlign( Paint.Align.RIGHT );
                m_canvas.drawText( text, m_valRect.right, m_valRect.bottom, 
                                   m_fillPaint );
            }
        }
    }

    private void drawCrosshairs( final Rect rect, final int flags )
    {
        int color = m_otherColors[CommonPrefs.COLOR_FOCUS];
        if ( 0 != (flags & CELL_CROSSHOR) ) {
            Rect hairRect = new Rect( rect );
            hairRect.inset( 0, hairRect.height() / 3 );
            fillRect( hairRect, color );
        }
        if ( 0 != (flags & CELL_CROSSVERT) ) {
            Rect hairRect = new Rect( rect );
            hairRect.inset( hairRect.width() / 3, 0 );
            fillRect( hairRect, color );
        }
    }

    private void fillRectOther( Rect rect, int index )
    {
        fillRect( rect, m_otherColors[index] );
    }

    private void fillRect( Rect rect, int color )
    {
        m_fillPaint.setColor( color );
        m_canvas.drawRect( rect, m_fillPaint );
    }

    private boolean figureFontDims()
    {
        if ( null == m_fontDims && null != m_dictChars  ) {

            final int ht = 24;
            final int width = 20;

            Paint paint = new Paint(); // CommonPrefs.getFontFlags()??
            paint.setStyle( Paint.Style.STROKE );
            paint.setTextAlign( Paint.Align.LEFT );
            paint.setTextSize( ht );

            Bitmap bitmap = Bitmap.createBitmap( width, (ht*3)/2, 
                                                 Bitmap.Config.ARGB_8888 );
            Canvas canvas = new Canvas( bitmap );

            // FontMetrics fmi = paint.getFontMetrics();
            // Utils.logf( ""ascent: "" + fmi.ascent );
            // Utils.logf( ""bottom: "" + fmi.bottom );
            // Utils.logf( ""descent: "" + fmi.descent );
            // Utils.logf( ""leading: "" + fmi.leading );
            // Utils.logf( ""top : "" + fmi.top );

            // Utils.logf( ""using as baseline: "" + ht );

            Rect bounds = new Rect();
            int maxWidth = 0;
            for ( String str : m_dictChars ) {
                if ( str.length() == 1 && str.charAt(0) >= 32 ) {
                    canvas.drawText( str, 0, ht, paint );
                    paint.getTextBounds( str, 0, 1, bounds );
                    if ( maxWidth < bounds.right ) {
                        maxWidth = bounds.right;
                    }
                }
            }

            // for ( int row = 0; row < bitmap.getHeight(); ++row ) {
            //     StringBuffer sb = new StringBuffer( bitmap.getWidth() );
            //     for ( int col = 0; col < bitmap.getWidth(); ++col ) {
            //         int pixel = bitmap.getPixel( col, row );
            //         sb.append( pixel==0? ""."" : ""X"" );
            //     }
            //     Utils.logf( sb.append(row).toString() );
            // }

            int topRow = 0;
            findTop:
            for ( int row = 0; row < bitmap.getHeight(); ++row ) {
                for ( int col = 0; col < bitmap.getWidth(); ++col ) {
                    if ( 0 != bitmap.getPixel( col, row ) ){
                        topRow = row;
                        break findTop;
                    }
                }
            }

            int bottomRow = 0;
            findBottom:
            for ( int row = bitmap.getHeight() - 1; row > topRow; --row ) {
                for ( int col = 0; col < bitmap.getWidth(); ++col ) {
                    if ( 0 != bitmap.getPixel( col, row ) ){
                        bottomRow = row;
                        break findBottom;
                    }
                }
            }
        
            m_fontDims = new FontDims( ht, topRow, bottomRow, maxWidth );
        }
        return null != m_fontDims;
    } // figureFontDims

    private boolean isLightColor( int color )
    {
        int sum = 0;
        for ( int ii = 0; ii < 3; ++ii ) {
            sum += color & 0xFF;
            color >>= 8;
        }
        boolean result = sum > (127*3);
        return result;
    }

    private void markBlank( final Rect rect, int backColor )
    {
        RectF oval = new RectF( rect.left, rect.top, rect.right, rect.bottom );
        int curColor = 0;
        boolean whiteOnBlack = !isLightColor( backColor );
        if ( whiteOnBlack ) {
            curColor = m_strokePaint.getColor();
            m_strokePaint.setColor( WHITE );
        }
        m_canvas.drawArc( oval, 0, 360, false, m_strokePaint );
        if ( whiteOnBlack ) {
            m_strokePaint.setColor( curColor );
        }
    }

    private boolean darkOnLight()
    {
        int background = m_otherColors[ CommonPrefs.COLOR_NOTILE ];
        if ( background != m_backgroundUsed ) {
            m_backgroundUsed = background;
            m_darkOnLight = isLightColor( background );
        }
        return m_darkOnLight;
    }

    private Drawable loadAndRecolor( int resID, boolean useDark )
    {
         Resources res = getResources();
         Drawable arrow = res.getDrawable( resID );

         if ( !useDark ) {
             Bitmap src = ((BitmapDrawable)arrow).getBitmap();
             Bitmap bitmap = src.copy( Bitmap.Config.ARGB_8888, true );
             for ( int xx = 0; xx < bitmap.getWidth(); ++xx ) {
                 for( int yy = 0; yy < bitmap.getHeight(); ++yy ) {
                     if ( BLACK == bitmap.getPixel( xx, yy ) ) {
                         bitmap.setPixel( xx, yy, WHITE );
                     }
                 }
             }

             arrow = new BitmapDrawable(bitmap); 
         }
         return arrow;
    }

    private int adjustColor( int color )
    {
        if ( m_inTrade ) {
            color = color & IN_TRADE_ALPHA;
        }
        return color;
    }
}
",True,35,37,0,0,5,13,1,10,L1
39,org.eehouse.android.xw4.DictImportActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.os.Bundle;
import android.os.AsyncTask;
import android.content.Intent;
import android.net.Uri;
import android.view.Window;
import android.widget.ProgressBar;
import android.widget.TextView;
import java.io.InputStream;
import java.io.File;
import java.net.URI;

import junit.framework.Assert;

public class DictImportActivity extends XWActivity {

    private static DictUtils.DictLoc s_saveWhere = DictUtils.DictLoc.INTERNAL;

    public static void setUseSD( boolean useSD ) 
    {
        s_saveWhere = useSD ?
            DictUtils.DictLoc.EXTERNAL : DictUtils.DictLoc.INTERNAL;
    }

    private class DownloadFilesTask extends AsyncTask<Uri, Integer, Long> {
        private String m_saved = null;
        @Override
        protected Long doInBackground( Uri... uris )
        {
            m_saved = null;

            int count = uris.length;
            Assert.assertTrue( 1 == count );
            long totalSize = 0;
            for ( int ii = 0; ii < count; ii++ ) {
                Uri uri = uris[ii];
                Utils.logf( ""trying %s"", uri );

                try {
                    URI jUri = new URI( uri.getScheme(), 
                                        uri.getSchemeSpecificPart(), 
                                        uri.getFragment() );
                    InputStream is = jUri.toURL().openStream();
                    m_saved = saveDict( is, uri.getPath() );
                    is.close();
                } catch ( java.net.URISyntaxException use ) {
                    Utils.logf( ""URISyntaxException: %s"", use.toString() );
                } catch ( java.net.MalformedURLException mue ) {
                    Utils.logf( ""MalformedURLException: %s"", mue.toString() );
                } catch ( java.io.IOException ioe ) {
                    Utils.logf( ""IOException: %s"", ioe.toString() );
                }
            }
            return totalSize;
        }

        @Override
        protected void onPostExecute( Long result )
        {
            Utils.logf( ""onPostExecute passed %d"", result );
            if ( null != m_saved ) {
                DictLangCache.inval( DictImportActivity.this, m_saved, 
                                     s_saveWhere, true );
            }
            finish();
        }
    } // class DownloadFilesTask

	@Override
	protected void onCreate( Bundle savedInstanceState ) 
    {
		super.onCreate( savedInstanceState );

		requestWindowFeature( Window.FEATURE_LEFT_ICON );
		setContentView( R.layout.import_dict );
		getWindow().setFeatureDrawableResource( Window.FEATURE_LEFT_ICON,
                                                R.drawable.icon48x48 );

		ProgressBar progressBar = (ProgressBar)findViewById( R.id.progress_bar );

		Intent intent = getIntent();
		Uri uri = intent.getData();
		if ( null != uri) {
			if ( null != intent.getType() 
                 && intent.getType().equals( ""application/x-xwordsdict"" ) ) {
                Utils.logf( ""based on MIME type"" );
                new DownloadFilesTask().execute( uri );
            } else if ( uri.toString().endsWith( XWConstants.DICT_EXTN ) ) {
                String fmt = getString( R.string.downloading_dictf );
                String txt = String.format( fmt, basename( uri.getPath()) );
                TextView view = (TextView)findViewById( R.id.dwnld_message );
                view.setText( txt );
                new DownloadFilesTask().execute( uri );
			} else {
                Utils.logf( ""bogus intent: %s/%s"", intent.getType(), uri );
				finish();
			}
        }
	}

    private String saveDict( InputStream inputStream, String path )
    {
        String name = basename( path );
        if ( DictUtils.saveDict( this, inputStream, name, s_saveWhere ) ) {
            return name;
        } else {
            return null;
        }
    }

    private String basename( String path )
    {
        return new File(path).getName();
    }
}


",True,14,41,2,2,7,10,1,5,L2
40,org.eehouse.android.xw4.Toolbar.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.content.Context;
import android.content.DialogInterface;
import android.view.View;
import android.widget.LinearLayout;
import android.widget.ImageButton;

import org.eehouse.android.xw4.jni.*;

public class Toolbar {

    private static class TBButtonInfo {
        public TBButtonInfo( int id/*, int idVert*/ ) {
            m_id = id;
        }
        public int m_id;
    }

    public static final int BUTTON_HINT_PREV = 0;
    public static final int BUTTON_HINT_NEXT = 1;
    public static final int BUTTON_FLIP = 2;
    public static final int BUTTON_JUGGLE = 3;
    public static final int BUTTON_ZOOM = 4;
    public static final int BUTTON_UNDO = 5;
    public static final int BUTTON_CHAT = 6;

    private static TBButtonInfo[] s_buttonInfo = {
        // BUTTON_HINT_PREV
        new TBButtonInfo(R.id.prevhint_button_horizontal ),
        // BUTTON_HINT_NEXT
        new TBButtonInfo(R.id.nexthint_button_horizontal ),
        // BUTTON_FLIP
        new TBButtonInfo(R.id.flip_button_horizontal ),
        // BUTTON_JUGGLE
        new TBButtonInfo( R.id.shuffle_button_horizontal ),
        // BUTTON_ZOOM
        new TBButtonInfo( R.id.zoom_button_horizontal ),
        // BUTTON_UNDO
        new TBButtonInfo( R.id.undo_button_horizontal ),
        // BUTTON_CHAT
        new TBButtonInfo( R.id.chat_button_horizontal ),
    };

    private XWActivity m_activity;
    private View m_me;

    private enum ORIENTATION { ORIENT_UNKNOWN,
            ORIENT_PORTRAIT,
            ORIENT_LANDSCAPE,
            };
    private ORIENTATION m_curOrient = ORIENTATION.ORIENT_UNKNOWN;

    public Toolbar( XWActivity activity, int id )
    {
        m_activity = activity;
        m_me = activity.findViewById( id );
    }

    public void setVisibility( int vis )
    {
        m_me.setVisibility( vis );
    }

    public void setListener( int index, View.OnClickListener listener )
    {
        TBButtonInfo info = s_buttonInfo[index];
        ImageButton button = (ImageButton)m_activity.findViewById( info.m_id );
        button.setOnClickListener( listener );
    }

    public void setListener( int index, final int msgID, final int prefsKey, 
                             final int callback )
    {
        View.OnClickListener listener = new View.OnClickListener() {
                public void onClick( View view ) {
                    m_activity.showNotAgainDlgThen( msgID, prefsKey, callback );
                }
            };
        setListener( index, listener );
    }

    public void update( int index, boolean enable )
    {
        TBButtonInfo info = s_buttonInfo[index];
        int vis = enable ? View.VISIBLE : View.GONE;

        ImageButton button = (ImageButton)m_activity.findViewById( info.m_id );
        button.setVisibility( vis );
    }

}
",False,61,37,0,0,7,8,2,1,L1
41,org.eehouse.android.xw4.RelayReceiver.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.content.Intent;
import android.content.BroadcastReceiver;
import android.widget.Toast;
import android.app.AlarmManager;
import android.app.PendingIntent;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import java.net.Socket;
import java.io.InputStream;
import java.io.DataInputStream;
import java.io.OutputStream;
import java.io.DataOutputStream;
import java.util.ArrayList;

import org.eehouse.android.xw4.jni.CommonPrefs;

public class RelayReceiver extends BroadcastReceiver {

    @Override
    public void onReceive( Context context, Intent intent )
    {
        if ( null != intent && null != intent.getAction() 
             && intent.getAction().equals( Intent.ACTION_BOOT_COMPLETED ) ) {
            Utils.logf( ""launching timer on boot"" );
            RestartTimer( context );
        } else {
            // Utils.logf( ""RelayReceiver::onReceive()"" );
            // if ( XWConstants.s_showProxyToast ) {
            //     Toast.makeText(context, ""RelayReceiver: fired"", 
            //                    Toast.LENGTH_SHORT).show();
            // }
            Intent service = new Intent( context, RelayService.class );
            context.startService( service );
        }
    }

    public static void RestartTimer( Context context, boolean force )
    {
        RestartTimer( context, 
                      1000 * CommonPrefs.getProxyInterval( context ), force );
    }

    public static void RestartTimer( Context context )
    {
        RestartTimer( context, false );
    }

    public static void RestartTimer( Context context, long interval_millis, 
                                     boolean force )
    {
        AlarmManager am =
            (AlarmManager)context.getSystemService( Context.ALARM_SERVICE );

        Intent intent = new Intent( context, RelayReceiver.class );
        PendingIntent pi = PendingIntent.getBroadcast( context, 0, intent, 0 );

        if ( interval_millis > 0 || force ) {
            // Utils.logf( ""setting alarm for %d millis"", interval_millis );
            am.setInexactRepeating( AlarmManager.ELAPSED_REALTIME_WAKEUP, 
                                    0, // first firing
                                    interval_millis, pi );
        } else {
            am.cancel( pi );
        }
    }

    public static void RestartTimer( Context context, long interval_millis )
    {
        RestartTimer( context, interval_millis, false );
    }

}
",False,37,39,1,1,9,7,1,2,L3
42,org.eehouse.android.xw4.DBHelper.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteDatabase;

public class DBHelper extends SQLiteOpenHelper {

    public static final String TABLE_NAME_SUM = ""summaries"";
    public static final String TABLE_NAME_OBITS = ""obits"";
    private static final String DB_NAME = ""xwdb"";
    private static final int DB_VERSION = 10;

    public static final String GAME_NAME = ""GAME_NAME"";
    public static final String NUM_MOVES = ""NUM_MOVES"";
    public static final String TURN = ""TURN"";
    public static final String GIFLAGS = ""GIFLAGS"";

    public static final String PLAYERS = ""PLAYERS"";
    public static final String NUM_PLAYERS = ""NUM_PLAYERS"";
    public static final String MISSINGPLYRS = ""MISSINGPLYRS"";
    public static final String GAME_OVER = ""GAME_OVER"";
    public static final String IN_USE = ""IN_USE"";
    public static final String SCORES = ""SCORES"";
    public static final String CHAT_HISTORY = ""CHAT_HISTORY"";
    // GAMEID: this isn't used yet but we'll want it to look up games
    // for which messages arrive.  Add now while changing the DB
    // format
    public static final String GAMEID = ""GAMEID"";
    public static final String DICTLANG = ""DICTLANG"";
    public static final String DICTLIST = ""DICTLIST"";
    public static final String HASMSGS = ""HASMSGS"";
    public static final String CONTRACTED = ""CONTRACTED"";
    public static final String SNAPSHOT = ""SNAPSHOT"";
    public static final String CONTYPE = ""CONTYPE"";
    public static final String SERVERROLE = ""SERVERROLE"";
    public static final String ROOMNAME = ""ROOMNAME"";
    public static final String RELAYID = ""RELAYID"";
    public static final String SEED = ""SEED"";
    public static final String SMSPHONE = ""SMSPHONE"";
    // not used yet
    public static final String CREATE_TIME = ""CREATE_TIME"";
    // not used yet
    public static final String LASTPLAY_TIME = ""LASTPLAY_TIME"";


    public DBHelper( Context context )
    {
        super( context, DB_NAME, null, DB_VERSION );
    }

    private void onCreateSum( SQLiteDatabase db ) 
    {
        db.execSQL( ""CREATE TABLE "" + TABLE_NAME_SUM + "" (""
                    + GAME_NAME   + "" TEXT,""
                    + NUM_MOVES   + "" INTEGER,""
                    + TURN        + "" INTEGER,""
                    + GIFLAGS     + "" INTEGER,""

                    + NUM_PLAYERS + "" INTEGER,""
                    + MISSINGPLYRS + "" INTEGER,""
                    + PLAYERS     + "" TEXT,""
                    + GAME_OVER   + "" INTEGER,""

                    + SERVERROLE + "" INTEGER,""
                    + CONTYPE    + "" INTEGER,""
                    + ROOMNAME   + "" TEXT,""
                    + RELAYID    + "" TEXT,""
                    + SEED       + "" INTEGER,""
                    + DICTLANG   + "" INTEGER,""
                    + DICTLIST   + "" TEXT,""

                    + SMSPHONE   + "" TEXT,""
                    + SCORES     + "" TEXT,""
                    + CHAT_HISTORY   + "" TEXT,""
                    + GAMEID     + "" INTEGER,""
                    // HASMSGS: sqlite doesn't have bool; use 0 and 1
                    + HASMSGS    + "" INTEGER DEFAULT 0,""
                    + CONTRACTED + "" INTEGER DEFAULT 0,""

                    + CREATE_TIME + "" INTEGER,""
                    + LASTPLAY_TIME + "" INTEGER,""

                    + SNAPSHOT   + "" BLOB""
                    + "");"" );
    }

    private void onCreateObits( SQLiteDatabase db ) 
    {
        db.execSQL( ""CREATE TABLE "" + TABLE_NAME_OBITS + "" (""
                    + RELAYID    + "" TEXT,""
                    + SEED       + "" INTEGER""
                    + "");"" );
    }

    @Override
    public void onCreate( SQLiteDatabase db ) 
    {
        onCreateSum( db );
        onCreateObits( db );
    }

    @Override
    public void onUpgrade( SQLiteDatabase db, int oldVersion, int newVersion ) 
    {
        Utils.logf( ""onUpgrade: old: %d; new: %d"", oldVersion, newVersion );

        switch( oldVersion ) {
        case 5:
            onCreateObits(db);
        case 6:
            db.execSQL( ""ALTER TABLE "" + TABLE_NAME_SUM  +
                        "" ADD COLUMN "" + TURN + "" INTEGER;"" );
            db.execSQL( ""ALTER TABLE "" + TABLE_NAME_SUM  +
                        "" ADD COLUMN "" + GIFLAGS + "" INTEGER;"" );
            db.execSQL( ""ALTER TABLE "" + TABLE_NAME_SUM  +
                        "" ADD COLUMN "" + CHAT_HISTORY + "" TEXT;"" );
        case 7:
            db.execSQL( ""ALTER TABLE "" + TABLE_NAME_SUM  +
                        "" ADD COLUMN "" + MISSINGPLYRS + "" INTEGER;"" );
        case 8:
            db.execSQL( ""ALTER TABLE "" + TABLE_NAME_SUM  +
                        "" ADD COLUMN "" + GAME_NAME + "" TEXT;"" );
            db.execSQL( ""ALTER TABLE "" + TABLE_NAME_SUM  +
                        "" ADD COLUMN "" + CONTRACTED + "" INTEGER;"" );
        case 9:
            db.execSQL( ""ALTER TABLE "" + TABLE_NAME_SUM  +
                        "" ADD COLUMN "" + DICTLIST + "" TEXT;"" );
        case 10:
            // nothing yet
            break;
        default:
            db.execSQL( ""DROP TABLE "" + TABLE_NAME_SUM + "";"" );
            if ( oldVersion >= 6 ) {
                db.execSQL( ""DROP TABLE "" + TABLE_NAME_OBITS + "";"" );
            }
            onCreate( db );
        }
    }
}
",False,26,37,8,11,1,1,1,1,L1
43,org.eehouse.android.xw4.XWActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import junit.framework.Assert;
import android.view.View;
import android.widget.TextView;
import android.app.AlertDialog;
import android.os.Bundle;

import org.eehouse.android.xw4.jni.CommonPrefs;

public class XWActivity extends Activity
    implements DlgDelegate.DlgClickNotify {

    private DlgDelegate m_delegate;

    @Override
    protected void onCreate( Bundle savedInstanceState ) 
    {
        Utils.logf( ""%s.onCreate(this=%H)"", getClass().getName(), this );
        super.onCreate( savedInstanceState );
        m_delegate = new DlgDelegate( this, this, savedInstanceState );
    }

    @Override
    protected void onStart()
    {
        Utils.logf( ""%s.onStart(this=%H)"", getClass().getName(), this );
        super.onStart();
        DispatchNotify.SetRunning( this );
    }

    @Override
    protected void onResume()
    {
        Utils.logf( ""%s.onResume(this=%H)"", getClass().getName(), this );
        super.onResume();
    }

    @Override
    protected void onPause()
    {
        Utils.logf( ""%s.onPause(this=%H)"", getClass().getName(), this );
        super.onPause();
    }

    @Override
    protected void onStop()
    {
        Utils.logf( ""%s.onStop(this=%H)"", getClass().getName(), this );
        DispatchNotify.ClearRunning( this );
        super.onStop();
    }

    @Override
    protected void onDestroy()
    {
        Utils.logf( ""%s.onDestroy(this=%H); isFinishing=%b"",
                    getClass().getName(), this, isFinishing() );
        super.onDestroy();
    }

    @Override
    protected void onSaveInstanceState( Bundle outState ) 
    {
        super.onSaveInstanceState( outState );
        m_delegate.onSaveInstanceState( outState );
    }

    @Override
    protected Dialog onCreateDialog( int id )
    {
        Dialog dialog = super.onCreateDialog( id );
        if ( null == dialog ) {
            Utils.logf( ""%s.onCreateDialog() called"", getClass().getName() );
            dialog = m_delegate.onCreateDialog( id );
        }
        return dialog;
    }

    @Override
    protected void onPrepareDialog( int id, Dialog dialog )
    {
        super.onPrepareDialog( id, dialog ); // docs say should call through
        m_delegate.onPrepareDialog( id, dialog );
    }

    // these are duplicated in XWListActivity -- sometimes multiple
    // inheritance would be nice to have...
    protected void showAboutDialog()
    {
        m_delegate.showAboutDialog();
    }

    protected void showNotAgainDlgThen( int msgID, int prefsKey,
                                        int action )
    {
        m_delegate.showNotAgainDlgThen( msgID, prefsKey, action );
    }

    protected void showNotAgainDlgThen( int msgID, int prefsKey )
    {
        m_delegate.showNotAgainDlgThen( msgID, prefsKey );
    }

    protected void showOKOnlyDialog( int msgID )
    {
        m_delegate.showOKOnlyDialog( msgID );
    }

    protected void showDictGoneFinish()
    {
        m_delegate.showDictGoneFinish();
    }

    protected void showConfirmThen( int msgID, int action )
    {
        m_delegate.showConfirmThen( getString(msgID), action );
    }

    public void showTextOrHtmlThen( int action )
    {
        m_delegate.showTextOrHtmlThen( action );
    }

    protected void doSyncMenuitem()
    {
        m_delegate.doSyncMenuitem();
    }

    // DlgDelegate.DlgClickNotify interface
    public void dlgButtonClicked( int id, int which )
    {
        Assert.fail();
    }

}
",False,15,44,2,5,6,8,9,4,L1
44,org.eehouse.android.xw4.jni.DrawScoreInfo.java,"/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

public class DrawScoreInfo {
    public String name;
    public int playerNum;
    public int totalScore;
    public int nTilesLeft;   /* < 0 means don't use */
    public int flags;        // was CellFlags; use CELL_ constants above
    public boolean isTurn;
    public boolean selected;
    public boolean isRemote;
    public boolean isRobot;
};
",False,30,37,7,10,0,0,2,0,L1
45,org.eehouse.android.xw4.jni.CurGameInfo.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import java.util.Random;
import android.content.Context;
import java.util.HashSet;
import java.util.Arrays;
import junit.framework.Assert;

import org.eehouse.android.xw4.Utils;
import org.eehouse.android.xw4.DictUtils;
import org.eehouse.android.xw4.R;
import org.eehouse.android.xw4.DictLangCache;

public class CurGameInfo {

    public static final int MAX_NUM_PLAYERS = 4;

    public enum XWPhoniesChoice { PHONIES_IGNORE, PHONIES_WARN, PHONIES_DISALLOW };
    public enum DeviceRole { SERVER_STANDALONE, SERVER_ISSERVER, SERVER_ISCLIENT };

    public String dictName;
    public LocalPlayer[] players;
    public int dictLang;
    public int gameID;
    public int gameSeconds;
    public int nPlayers;
    public int boardSize;
    public DeviceRole serverRole;

    public boolean hintsNotAllowed;
    public boolean timerEnabled;
    public boolean allowPickTiles;
    public boolean allowHintRect;
    public XWPhoniesChoice phoniesAction;
    public boolean confirmBTConnect;   /* only used for BT */

    // private int[] m_visiblePlayers;
    // private int m_nVisiblePlayers;
    private int m_smartness;
    private Context m_context;

    public CurGameInfo( Context context )
    {
        this( context, false );
    }

    public CurGameInfo( Context context, boolean isNetworked )
    {
        m_context = context;
        nPlayers = 2;
        gameSeconds = 60 * nPlayers *
            CommonPrefs.getDefaultPlayerMinutes( context );
        boardSize = CommonPrefs.getDefaultBoardSize( context );
        players = new LocalPlayer[MAX_NUM_PLAYERS];
        serverRole = isNetworked ? DeviceRole.SERVER_ISCLIENT
            : DeviceRole.SERVER_STANDALONE;
        hintsNotAllowed = !CommonPrefs.getDefaultHintsAllowed( context );
        phoniesAction = CommonPrefs.getDefaultPhonies( context );
        timerEnabled = CommonPrefs.getDefaultTimerEnabled( context );
        allowPickTiles = false;
        allowHintRect = false;
        m_smartness = 0;        // needs to be set from players

        // Always create MAX_NUM_PLAYERS so jni code doesn't ever have
        // to cons up a LocalPlayer instance.
        for ( int ii = 0; ii < MAX_NUM_PLAYERS; ++ii ) {
            players[ii] = new LocalPlayer( context, ii );
        }
        if ( isNetworked ) {
            players[1].isLocal = false;
        } else {
            players[0].setRobotSmartness( 1 );
        }

        // name the local humans now
        int count = 0;
        for ( int ii = 0; ii < nPlayers; ++ii ) {
            LocalPlayer lp = players[ii];
            if ( lp.isLocal && !lp.isRobot() ) {
                lp.name = CommonPrefs.getDefaultPlayerName( context, count++ );
            }
        }

        if ( CommonPrefs.getAutoJuggle( context ) ) {
            juggle();
        }

        setLang( 0 );
    }

    public CurGameInfo( Context context, CurGameInfo src )
    {
        m_context = context;
        gameID = src.gameID;
        nPlayers = src.nPlayers;
        gameSeconds = src.gameSeconds;
        boardSize = src.boardSize;
        players = new LocalPlayer[MAX_NUM_PLAYERS];
        serverRole = src.serverRole;
        dictName = src.dictName;
        dictLang = src.dictLang;
        hintsNotAllowed = src.hintsNotAllowed;
        phoniesAction = src.phoniesAction;
        timerEnabled = src.timerEnabled;
        allowPickTiles = src.allowPickTiles;
        allowHintRect = src.allowHintRect;
        
        int ii;
        for ( ii = 0; ii < MAX_NUM_PLAYERS; ++ii ) {
            players[ii] = new LocalPlayer( src.players[ii] );
        }
    }

    public void setServerRole( DeviceRole newRole )
    {
        serverRole = newRole;
        Assert.assertTrue( nPlayers > 0 );
        if ( nPlayers == 0 ) { // must always be one visible player
            Assert.assertFalse( players[0].isLocal );
            players[0].isLocal = true;
        }
    }

    public void setLang( int lang )
    {
        if ( 0 == lang ) {
            String dictName = CommonPrefs.getDefaultHumanDict( m_context );
            lang = DictLangCache.getDictLangCode( m_context, dictName );
        }
        if ( dictLang != lang ) {
            dictLang = lang;
            assignDicts();
        }
    }

    public int getRobotSmartness()
    {
        if ( m_smartness == 0 ) {
            m_smartness = 1;    // default if no robots
            for ( int ii = 0; ii < nPlayers; ++ii ) {
                if ( players[ii].isRobot() ) {
                    m_smartness = players[ii].robotIQ;
                    break;      // should all be the same
                }
            }
        }
        return m_smartness;
    }

    public void setRobotSmartness( int smartness )
    {
        m_smartness = smartness;
        for ( int ii = 0; ii < nPlayers; ++ii ) {
            if ( players[ii].isRobot() ) {
                players[ii].robotIQ = smartness;
            }
        }
    }

    /** return true if any of the changes made would invalide a game
     * in progress, i.e. require that it be restarted with the new
     * params.  E.g. changing a player to a robot is harmless for a
     * local-only game but illegal for a connected one.
     */
    public boolean changesMatter( final CurGameInfo other )
    {
        boolean matter = nPlayers != other.nPlayers
            || serverRole != other.serverRole
            || dictLang != other.dictLang
            || boardSize != other.boardSize
            || hintsNotAllowed != other.hintsNotAllowed
            || allowPickTiles != other.allowPickTiles
            || phoniesAction != other.phoniesAction;

        if ( !matter && DeviceRole.SERVER_STANDALONE != serverRole ) {
            for ( int ii = 0; ii < nPlayers; ++ii ) {
                LocalPlayer me = players[ii];
                LocalPlayer him = other.players[ii];
                matter = me.isRobot() != him.isRobot()
                    || me.isLocal != him.isLocal
                    || !me.name.equals( him.name );
                if ( matter ) {
                    break;
                }
            }
        }

        return matter;
    }

    public int remoteCount()
    {
        int count = 0;
        for ( int ii = 0; ii < nPlayers; ++ii ) {
            if ( !players[ii].isLocal ) {
                ++count;
            }
        }
        Utils.logf( ""remoteCount()=>%d"", count );
        return count;
    }

    public boolean forceRemoteConsistent()
    {
        boolean consistent = serverRole == DeviceRole.SERVER_STANDALONE;
        if ( !consistent ) {
            if ( remoteCount() == 0 ) {
                players[0].isLocal = false;
            } else if ( remoteCount() == nPlayers ) {
                players[0].isLocal = true;
            } else {
                consistent = true; // nothing changed
            }
        }
        return !consistent;
    }

    public String[] visibleNames( boolean withDicts )
    {
        String nameFmt = withDicts? m_context.getString( R.string.name_dict_fmt )
            : ""%s"";
        String[] names = new String[nPlayers];
        for ( int ii = 0; ii < nPlayers; ++ii ) {
            LocalPlayer lp = players[ii];
            if ( lp.isLocal || serverRole == DeviceRole.SERVER_STANDALONE ) {
                String name;
                if ( lp.isRobot() ) {
                    String format = m_context.getString( R.string.robot_namef );
                    name = String.format( format, lp.name );
                } else {
                    name = lp.name;
                }
                names[ii] = String.format( nameFmt, name, dictName(lp) );
            } else {
                names[ii] = m_context.getString( R.string.guest_name );
            }
        }
        return names;
    }

    public String[] dictNames()
    {
        String[] result = new String[nPlayers+1];
        result[0] = dictName;
        for ( int ii = 0; ii < nPlayers; ++ii ) {
            result[ii+1] = players[ii].dictName;
        }
        return result;
    }

    // Replace any dict that doesn't exist with newDict
    public void replaceDicts( String newDict ) 
    {
        String[] dicts = 
            DictLangCache.getHaveLang( m_context, dictLang );
        HashSet<String> installed = new HashSet<String>( Arrays.asList(dicts) );

        if ( !installed.contains( dictName ) ) {
            dictName = newDict;
        }

        for ( int ii = 0; ii < nPlayers; ++ii ) {
            LocalPlayer lp = players[ii];
            if ( null == lp.dictName ) {
                // continue to inherit
            } else if ( !installed.contains( players[ii].dictName ) ) {
                players[ii].dictName = newDict;
            }
        }
    }

    public String langName()
    {
        return DictLangCache.getLangName( m_context, dictLang );
    }

    public String dictName( final LocalPlayer lp )
    {
        String dname = lp.dictName;
        if ( null == dname ) {
            dname = dictName;
        }
        return dname;
    }

    public boolean addPlayer() 
    {
        boolean added = nPlayers < MAX_NUM_PLAYERS;
        // We can add either by adding a player, if nPlayers <
        // MAX_NUM_PLAYERS, or by making an unusable player usable.
        if ( added ) {
            players[nPlayers].isLocal = 
                serverRole == DeviceRole.SERVER_STANDALONE;
            ++nPlayers;
        }
        return added;
    }

    public void setNPlayers( int nPlayersTotal, int nPlayersHere )
    {
        assert( nPlayersTotal < MAX_NUM_PLAYERS );
        assert( nPlayersHere < nPlayersTotal );

        nPlayers = nPlayersTotal;

        for ( int ii = 0; ii < nPlayersTotal; ++ii ) {
            players[ii].isLocal = ii < nPlayersHere;
            assert( !players[ii].isRobot() );
        }
    }

    public void setFirstLocalName( String name ) {
        for ( int ii = 0; ii < nPlayers; ++ii ) {
            if ( players[ii].isLocal ) {
                players[ii].name = name;
                break;
            }
        }
    }

    public boolean moveUp( int which )
    {
        boolean canMove = which > 0 && which < nPlayers;
        if ( canMove ) {
            LocalPlayer tmp = players[which-1];
            players[which-1] = players[which];
            players[which] = tmp;
        }
        return canMove;
    }

    public boolean moveDown( int which )
    {
        return moveUp( which + 1 );
    }

    public boolean delete( int which )
    {
        boolean canDelete = nPlayers > 0;
        if ( canDelete ) {
            LocalPlayer tmp = players[which];
            for ( int ii = which; ii < nPlayers - 1; ++ii ) {
                moveDown( ii );
            }
            --nPlayers;
            players[nPlayers] = tmp;
        }
        return canDelete;
    }

    public boolean juggle()
    {
        boolean canJuggle = nPlayers > 1;
        if ( canJuggle ) {
            // for each element, exchange with randomly chocsen from
            // range <= to self.
            Random rgen = new Random();

            for ( int ii = nPlayers - 1; ii > 0; --ii ) {
                // Contrary to docs, nextInt() comes back negative!
                int rand = Math.abs(rgen.nextInt()); 
                int indx = rand % (ii+1);
                if ( indx != ii ) {
                    LocalPlayer tmp = players[ii];
                    players[ii] = players[indx];
                    players[indx] = tmp;
                }
            }
        }
        return canJuggle;
    }

    private void assignDicts()
    {
        // For each player's dict, if non-null and language matches
        // leave it alone.  Otherwise replace with default if that
        // matches langauge.  Otherwise pick an arbitrary dict in the
        // right language.

        String humanDict = 
            DictLangCache.getBestDefault( m_context, dictLang, true );
        String robotDict = 
            DictLangCache.getBestDefault( m_context, dictLang, false );

        if ( null == dictName 
             || ! DictUtils.dictExists( m_context, dictName ) 
             || dictLang != DictLangCache.getDictLangCode( m_context, 
                                                           dictName ) ) {
            dictName = humanDict;
        }

        for ( int ii = 0; ii < nPlayers; ++ii ) {
            LocalPlayer lp = players[ii];

            if ( null != lp.dictName &&
                 dictLang != DictLangCache.getDictLangCode( m_context, 
                                                            lp.dictName ) ) {
                lp.dictName = null;
            }

            if ( null == lp.dictName ) {
                if ( lp.isRobot() ) {
                    if ( robotDict != dictName ) {
                        lp.dictName = robotDict;
                    } else if ( humanDict != dictName ) {
                        lp.dictName = humanDict;
                    }
                }
            }
        }
    }

}
",True,7,42,2,4,7,7,15,5,L1
46,org.eehouse.android.xw4.jni.GameSummary.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.content.Context;
import android.text.TextUtils;
import junit.framework.Assert;
import org.eehouse.android.xw4.R;
import org.eehouse.android.xw4.Utils;


/** Info we want to access when the game's closed that's not available
 * in CurGameInfo
 */
public class GameSummary {

    public static final int MSG_FLAGS_NONE = 0;
    public static final int MSG_FLAGS_TURN = 1;
    public static final int MSG_FLAGS_CHAT = 2;
    public static final int MSG_FLAGS_GAMEOVER = 4;
    public static final int MSG_FLAGS_ALL = 7;

    public int nMoves;
    public int turn;
    public int nPlayers;
    public int missingPlayers;
    public int[] scores;
    public boolean gameOver;
    public String[] players;
    public CommsAddrRec.CommsConnType conType;
    public String smsPhone;
    // relay-related fields
    public String roomName;
    public String relayID;
    public int seed;
    public int pendingMsgLevel;
    public long modtime;

    public int dictLang;
    public CurGameInfo.DeviceRole serverRole;

    private int m_giFlags;
    private String m_playersSummary;
    private CurGameInfo m_gi;
    private Context m_context;

    public GameSummary( Context context ) {
        m_context = context;
        pendingMsgLevel = 0;
    }

    public GameSummary( Context context, CurGameInfo gi )
    {
        this( context );
        nPlayers = gi.nPlayers;
        dictLang = gi.dictLang;
        serverRole = gi.serverRole;
        m_gi = gi;
    }

    public boolean inNetworkGame()
    {
        return null != relayID;
    }

    public String summarizePlayers()
    {
        String result;
        if ( null == m_gi ) {
            result = m_playersSummary;
        } else {
            String[] names = new String[nPlayers];
            for ( int ii = 0; ii < nPlayers; ++ii ) {
                names[ii] = m_gi.players[ii].name;
            }
            result = TextUtils.join( ""\n"", names );
            m_playersSummary = result;
        }
        return result;
    }

    public void readPlayers( String playersStr ) 
    {
        if ( null != playersStr ) {
            players = new String[nPlayers];
            String sep;
            if ( playersStr.contains(""\n"") ) {
                sep = ""\n"";
            } else {
                sep = m_context.getString( R.string.vs_join );
            }

            int ii, nxt;
            for ( ii = 0, nxt = 0; ; ++ii ) {
                int prev = nxt;
                nxt = playersStr.indexOf( sep, nxt );
                String name = -1 == nxt ?
                    playersStr.substring( prev ) : 
                    playersStr.substring( prev, nxt );
                players[ii] = name;
                if ( -1 == nxt ) {
                    break;
                }
                nxt += sep.length();
            }
        }
    }

    public void setPlayerSummary( String summary ) 
    {
        m_playersSummary = summary;
    }

    public String summarizeState()
    {
        String result = null;
        if ( gameOver ) {
            result = m_context.getString( R.string.gameOver );
        } else {
            result = String.format( m_context.getString(R.string.movesf),
                                    nMoves );
        }
        return result;
    }

    public String summarizeRole()
    {
        String result = null;
        if ( isRelayGame() ) {
            
            Assert.assertTrue( CommsAddrRec.CommsConnType.COMMS_CONN_RELAY
                               == conType );
            int fmtID;
            if ( null == relayID || 0 == relayID.length() ) {
                fmtID = R.string.summary_relay_conff;
            } else if ( anyMissing() ) {
                fmtID = R.string.summary_relay_waitf;
            } else {
                fmtID = R.string.summary_relay_connf;
            }
            result = String.format( m_context.getString(fmtID), roomName );
        }
        return result;
    }

    public boolean isRelayGame()
    {
        // This definition will expand as other transports are added
        return ( null != conType 
                 && serverRole != CurGameInfo.DeviceRole.SERVER_STANDALONE );
    }

    private boolean isLocal( int indx ) {
        int flag = 2 << (indx * 2);
        return 0 == (m_giFlags & flag);
    }

    private boolean isRobot( int indx ) {
        int flag = 1 << (indx * 2);
        boolean result = 0 != (m_giFlags & flag);
        return result;
    }

    private boolean anyMissing()
    {
        boolean missing = false;
        for ( int ii = 0; ii < nPlayers; ++ii ) {
            if ( !isLocal(ii) && (0 != ((1 << ii) & missingPlayers) ) ) {
                missing = true;
                break;
            }
        }
        return missing;
    }

    public int giflags() {
        int result;
        if ( null == m_gi ) {
            result = m_giFlags;
        } else {
            result = 0;
            for ( int ii = 0; ii < m_gi.nPlayers; ++ii ) {
                if ( ! m_gi.players[ii].isLocal ) {
                    result |= 2 << (ii * 2);
                }
                if ( m_gi.players[ii].isRobot() ) {
                    result |= 1 << (ii * 2);
                }
            }
        }
        return result;
    }

    public void setGiFlags( int flags ) 
    {
        m_giFlags = flags;
    }

    public String summarizePlayer( int indx ) 
    {
        String player = players[indx];
        int formatID = 0;
        if ( !isLocal(indx) ) {
            boolean isMissing = 0 != ((1 << indx) & missingPlayers);
            if ( isMissing ) {
                player = m_context.getString( R.string.missing_player );
            } else {
                formatID = R.string.str_nonlocal_namef;
            }
        } else if ( isRobot(indx) ) {
            formatID = R.string.robot_namef;
        }

        if ( 0 != formatID ) {
            String format = m_context.getString( formatID );
            player = String.format( format, player );
        }
        return player;
    }

    public String playerNames()
    {
        String[] names = null;
        if ( null != m_gi ) {
            names = m_gi.visibleNames( false );
        } else if ( null != m_playersSummary ) {
            names = TextUtils.split( m_playersSummary, ""\n"" );
        }

        String result = null;
        if ( null != names && 0 < names.length ) {
            String joiner = m_context.getString( R.string.vs_join );
            result = TextUtils.join( joiner, names );
        }

        return result;
    }

    public boolean isNextToPlay( int indx ) {
        return indx == turn && isLocal(indx);
    }

    public String dictNames( String separator ) 
    {
        String list = null;
        if ( null != m_gi ) {
            String[] names = m_gi.dictNames();
            list = TextUtils.join( separator, names );
        }
        return String.format( ""%s%s%s"", separator, list, separator );
    }

}
",False,48,41,1,4,8,6,9,4,L1
47,org.eehouse.android.xw4.jni.UtilCtxtImpl.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.content.Context;

import org.eehouse.android.xw4.Utils;
import org.eehouse.android.xw4.R;

public class UtilCtxtImpl implements UtilCtxt {
    private Context m_context;

    private UtilCtxtImpl() {}   // force subclasses to pass context

    public UtilCtxtImpl( Context context )
    {
        super();
        m_context = context;
    }

    public void requestTime() {
        subclassOverride( ""requestTime"" );
    }

    public int userPickTile( int playerNum, String[] texts )
    {
        subclassOverride( ""userPickTile"" );
        return 0;
    }

    public String askPassword( String name )
    {
        subclassOverride( ""askPassword"" );
        return null;
    }

    public void turnChanged()
    {
        subclassOverride( ""turnChanged"" );
    }

    public boolean engineProgressCallback()
    {
        subclassOverride( ""engineProgressCallback"" );
        return true;
    }

    public void setTimer( int why, int when, int handle )
    {
        subclassOverride( ""setTimer"" );
    }

    public void clearTimer( int why )
    {
        subclassOverride( ""clearTimer"" );
    }

    public void remSelected()
    {
        subclassOverride( ""remSelected"" );
    }

    public void setIsServer( boolean isServer )
    {
        subclassOverride( ""setIsServer"" );
    }

    public void bonusSquareHeld( int bonus )
    {
    }

    public void playerScoreHeld( int player )
    {
    }

    public String getUserString( int stringCode )
    {
        int id = 0;
        switch( stringCode ) {
        case UtilCtxt.STRD_ROBOT_TRADED:
            id = R.string.strd_robot_traded;
            break;
        case UtilCtxt.STR_ROBOT_MOVED:
            id = R.string.str_robot_moved;
            break;
        case UtilCtxt.STRS_VALUES_HEADER:
            id = R.string.strs_values_header;
            break;
        case UtilCtxt.STRD_REMAINING_TILES_ADD:
            id = R.string.strd_remaining_tiles_add;
            break;
        case UtilCtxt.STRD_UNUSED_TILES_SUB:
            id = R.string.strd_unused_tiles_sub;
            break;
        case UtilCtxt.STRS_REMOTE_MOVED:
            id = R.string.str_remote_movedf;
            break;
        case UtilCtxt.STRD_TIME_PENALTY_SUB:
            id = R.string.strd_time_penalty_sub;
            break;
        case UtilCtxt.STR_PASS:
            id = R.string.str_pass;
            break;
        case UtilCtxt.STRS_MOVE_ACROSS:
            id = R.string.strs_move_across;
            break;
        case UtilCtxt.STRS_MOVE_DOWN:
            id = R.string.strs_move_down;
            break;
        case UtilCtxt.STRS_TRAY_AT_START:
            id = R.string.strs_tray_at_start;
            break;
        case UtilCtxt.STRSS_TRADED_FOR:
            id = R.string.strss_traded_for;
            break;
        case UtilCtxt.STR_PHONY_REJECTED:
            id = R.string.str_phony_rejected;
            break;
        case UtilCtxt.STRD_CUMULATIVE_SCORE:
            id = R.string.strd_cumulative_score;
            break;
        case UtilCtxt.STRS_NEW_TILES:
            id = R.string.strs_new_tiles;
            break;
        case UtilCtxt.STR_PASSED:
            id = R.string.str_passed;
            break;
        case UtilCtxt.STRSD_SUMMARYSCORED:
            id = R.string.strsd_summaryscored;
            break;
        case UtilCtxt.STRD_TRADED:
            id = R.string.strd_traded;
            break;
        case UtilCtxt.STR_LOSTTURN:
            id = R.string.str_lostturn;
            break;
        case UtilCtxt.STR_COMMIT_CONFIRM:
            id = R.string.str_commit_confirm;
            break;
        case UtilCtxt.STR_BONUS_ALL:
            id = R.string.str_bonus_all;
            break;
        case UtilCtxt.STRD_TURN_SCORE:
            id = R.string.strd_turn_score;
            break;
        default:
            Utils.logf( ""no such stringCode: %d"", stringCode );
        }

        String result;
        if ( 0 == id ) {
            result = """";
        } else {
            result = m_context.getString( id );
        }
        return result;
    }

    public boolean userQuery( int id, String query )
    {
        subclassOverride( ""userQuery"" );
        return false;
    }

    public void userError( int id )
    {
        subclassOverride( ""userError"" );
    }

    // Probably want to cache the fact that the game over notification
    // showed up and then display it next time game's opened.
    public void notifyGameOver()
    {
        subclassOverride( ""notifyGameOver"" );
    }

    public boolean warnIllegalWord( String[] words, int turn, boolean turnLost )
    {
        subclassOverride( ""warnIllegalWord"" );
        return false;
    }

    // These need to go into some sort of chat DB, not dropped.
    public void showChat( String msg )
    {
        subclassOverride( ""showChat"" );
    }

    private void subclassOverride( String name ) {
        Utils.logf( ""%s::%s() called"", getClass().getName(), name );
    }

}
",False,27,38,8,9,1,2,2,2,L1
48,org.eehouse.android.xw4.jni.JNIUtilsImpl.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.graphics.drawable.BitmapDrawable;
import android.graphics.Bitmap;
import java.util.ArrayList;
import java.io.ByteArrayInputStream;
import java.io.InputStreamReader;

import org.eehouse.android.xw4.*;

public class JNIUtilsImpl implements JNIUtils {

    private static JNIUtils s_impl = null;

    private JNIUtilsImpl(){}

    public static JNIUtils get()
    {
        if ( null == s_impl ) {
            s_impl = new JNIUtilsImpl();
        }
        return s_impl;
    }

    /** Working around lack of utf8 support on the JNI side: given a
     * utf-8 string with embedded small number vals starting with 0,
     * convert into individual strings.  The 0 is the problem: it's
     * not valid utf8.  So turn it and the other nums into strings and
     * catch them on the other side.
     */
    public String[] splitFaces( byte[] chars, boolean isUTF8 )
    {
        ArrayList<String> al = new ArrayList<String>();
        ByteArrayInputStream bais = new ByteArrayInputStream( chars );
        InputStreamReader isr;
        try {
            isr = new InputStreamReader( bais, isUTF8? ""UTF8"" : ""ISO8859_1"" );
        } catch( java.io.UnsupportedEncodingException uee ) {
            Utils.logf( ""splitFaces: %s"", uee.toString() );
            isr = new InputStreamReader( bais );
        }
        
        int[] codePoints = new int[1];

        for ( ; ; ) {
            int chr = -1;
            try {
                chr = isr.read();
            } catch ( java.io.IOException ioe ) {
                Utils.logf( ioe.toString() );
            }
            if ( -1 == chr ) {
                break;
            } else {
                String letter;
                if ( chr < 32 ) {
                    letter = String.format( ""%d"", chr );
                } else {
                    codePoints[0] = chr;
                    letter = new String( codePoints, 0, 1 );
                }
                al.add( letter );
            }
        }
        
        String[] result = al.toArray( new String[al.size()] );
        return result;
    }
}",False,4,38,5,13,1,2,4,2,L1
49,org.eehouse.android.xw4.jni.BoardHandler.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import org.eehouse.android.xw4.XWActivity;

public interface BoardHandler {

    void startHandling( XWActivity parent, JNIThread thread, 
                        int gamePtr, CurGameInfo gi );

}
",False,33,37,0,0,5,15,1,3,L1
50,org.eehouse.android.xw4.jni.JNIUtils.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.graphics.drawable.BitmapDrawable;

public interface JNIUtils {

    // Stuff I can't do in C....
    String[] splitFaces( byte[] chars, boolean isUTF8 );
}",False,59,37,6,11,0,0,3,0,L1
51,org.eehouse.android.xw4.jni.LocalPlayer.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.content.Context;
import org.eehouse.android.xw4.R;
import junit.framework.Assert;

public class LocalPlayer {
    public String name;
    public String password;
    public String dictName;
    public int secondsUsed;
    public int robotIQ;
    public boolean isLocal;

    public LocalPlayer( Context context, int num )
    {
        isLocal = true;
        robotIQ = 0;            // human
        String fmt = context.getString( R.string.playerf );
        name = String.format( fmt, num + 1 );
        password = """";
    }

    public LocalPlayer( final LocalPlayer src )
    {
        isLocal = src.isLocal;
        robotIQ = src.robotIQ;
        name = src.name;
        password = src.password;
        dictName = src.dictName;
        secondsUsed = src.secondsUsed;
    }

    public boolean isRobot() 
    {
        return robotIQ > 0;
    }

    public void setIsRobot( boolean isRobot )
    {
        robotIQ = isRobot ? 1 : 0;
    }

    public void setRobotSmartness( int iq )
    {
        Assert.assertTrue( iq > 0 );
        robotIQ = iq;
    }
}

",True,17,36,4,15,0,0,4,0,L1
52,org.eehouse.android.xw4.jni.DictInfo.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

public class DictInfo {
    public int langCode;
    public int wordCount;
    public String name;
};
",False,60,36,5,12,0,0,2,0,L1
53,org.eehouse.android.xw4.jni.UtilCtxt.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

public interface UtilCtxt {
    static final int BONUS_NONE = 0;
    static final int BONUS_DOUBLE_LETTER = 1;
    static final int BONUS_DOUBLE_WORD = 2;
    static final int BONUS_TRIPLE_LETTER = 3;
    static final int BONUS_TRIPLE_WORD = 4;

    int userPickTile( /* PickInfo* pi, add once tile-picking is enabled */
                     int playerNum, String[] texts );

    String askPassword( String name );
    void turnChanged();

    boolean engineProgressCallback();

    // Values for why; should be enums
    public static final int TIMER_PENDOWN = 1;
    public static final int TIMER_TIMERTICK = 2;
    public static final int TIMER_COMMS = 3;
    public static final int TIMER_SLOWROBOT = 4;
    void setTimer( int why, int when, int handle );
    void clearTimer( int why );

    void requestTime();
    void remSelected();
    void setIsServer( boolean isServer );

    void bonusSquareHeld( int bonus );
    void playerScoreHeld( int player );

    static final int STRD_ROBOT_TRADED =                  1;
    static final int STR_ROBOT_MOVED =                    2;
    static final int STRS_VALUES_HEADER =                 3;
    static final int STRD_REMAINING_TILES_ADD =           4;
    static final int STRD_UNUSED_TILES_SUB =              5;
    static final int STRS_REMOTE_MOVED =                  6;
    static final int STRD_TIME_PENALTY_SUB =              7;
    static final int STR_PASS =                           8;
    static final int STRS_MOVE_ACROSS =                   9;
    static final int STRS_MOVE_DOWN =                    10;
    static final int STRS_TRAY_AT_START =                11;
    static final int STRSS_TRADED_FOR =                  12;
    static final int STR_PHONY_REJECTED =                13;
    static final int STRD_CUMULATIVE_SCORE =             14;
    static final int STRS_NEW_TILES =                    15;
    static final int STR_PASSED =                        16;
    static final int STRSD_SUMMARYSCORED =               17;
    static final int STRD_TRADED =                       18;
    static final int STR_LOSTTURN =                      19;
    static final int STR_COMMIT_CONFIRM =                20;
    static final int STR_BONUS_ALL =                     21;
    static final int STRD_TURN_SCORE =                   22;
    String getUserString( int stringCode );

    static final int QUERY_COMMIT_TURN = 0;
    static final int QUERY_COMMIT_TRADE = 1;
    static final int QUERY_ROBOT_MOVE = 2;
    static final int QUERY_ROBOT_TRADE = 3;
    boolean userQuery( int id, String query );


    // These oughtto be an enum but then I'd have to cons one up in C.
    static final int ERR_NONE = 0;
    static final int ERR_TILES_NOT_IN_LINE = 1;
    static final int ERR_NO_EMPTIES_IN_TURN = 2;
    static final int ERR_TWO_TILES_FIRST_MOVE = 3;
    static final int ERR_TILES_MUST_CONTACT = 4;
    static final int ERR_TOO_FEW_TILES_LEFT_TO_TRADE = 5;
    static final int ERR_NOT_YOUR_TURN = 6;
    static final int ERR_NO_PEEK_ROBOT_TILES = 7;
    static final int ERR_SERVER_DICT_WINS = 8;
    static final int ERR_NO_PEEK_REMOTE_TILES = 9;
    static final int ERR_REG_UNEXPECTED_USER = 10;
    static final int ERR_REG_SERVER_SANS_REMOTE = 11;
    static final int STR_NEED_BT_HOST_ADDR = 12;
    static final int ERR_NO_EMPTY_TRADE = 13;
    static final int ERR_CANT_UNDO_TILEASSIGN = 14;
    static final int ERR_CANT_HINT_WHILE_DISABLED = 15;
    static final int ERR_RELAY_BASE = 16;
    void userError( int id );

    void notifyGameOver();
    // Don't need this unless we have a scroll thumb to indicate position
    //void yOffsetChange( int maxOffset, int oldOffset, int newOffset );

    boolean warnIllegalWord( String[] words, int turn, boolean turnLost );

    void showChat( String msg );
}
",False,39,37,6,11,0,0,4,0,L1
54,org.eehouse.android.xw4.jni.CommonPrefs.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.content.Context;
import android.content.SharedPreferences;
import android.preference.PreferenceManager;
import android.graphics.Paint;
import android.content.res.Resources;
import junit.framework.Assert;

import org.eehouse.android.xw4.Utils;
import org.eehouse.android.xw4.R;
import org.eehouse.android.xw4.DictUtils;

public class CommonPrefs {
    public static final int COLOR_TILE_BACK = 0;
    public static final int COLOR_NOTILE = 1;
    public static final int COLOR_FOCUS = 2;
    public static final int COLOR_BACKGRND = 3;
    public static final int COLOR_BONUSHINT = 4;
    public static final int COLOR_LAST = 5;

    private static CommonPrefs s_cp = null;

    public boolean showBoardArrow;
    public boolean showRobotScores;
    public boolean hideTileValues; 
    public boolean skipCommitConfirm;
    public boolean showColors;
    public boolean sortNewTiles;
    public boolean allowPeek;

    public int[] playerColors;
    public int[] bonusColors;
    public int[] otherColors;

    private CommonPrefs()
    {
        playerColors = new int[4];
        bonusColors = new int[5];
        bonusColors[0] = 0xF0F0F0F0; // garbage
        otherColors = new int[COLOR_LAST];
    }

    private CommonPrefs refresh( Context context )
    {
        String key;
        SharedPreferences sp = PreferenceManager
            .getDefaultSharedPreferences( context );

        showBoardArrow = getBoolean( context, sp, R.string.key_show_arrow, 
                                     true );
        showRobotScores = getBoolean( context, sp, R.string.key_explain_robot, 
                                      false );
        hideTileValues = getBoolean( context, sp, R.string.key_hide_values, 
                                     false );
        skipCommitConfirm = getBoolean( context, sp, 
                                        R.string.key_skip_confirm, false );
        showColors = getBoolean( context, sp, R.string.key_color_tiles, true );
        sortNewTiles = getBoolean( context, sp, R.string.key_sort_tiles, true );
        allowPeek = getBoolean( context, sp, R.string.key_peek_other, false );

        int ids[] = { R.string.key_player0,
                      R.string.key_player1,
                      R.string.key_player2,
                      R.string.key_player3,
        };

        for ( int ii = 0; ii < ids.length; ++ii ) {
            playerColors[ii] = prefToColor( context, sp, ids[ii] );
        }

        int ids2[] = { R.string.key_bonus_l2x,
                       R.string.key_bonus_w2x,
                       R.string.key_bonus_l3x,
                       R.string.key_bonus_w3x,
        };
        for ( int ii = 0; ii < ids2.length; ++ii ) {
            bonusColors[ii+1] = prefToColor( context, sp, ids2[ii] );
        }

        int idsOther[] = { R.string.key_tile_back,
                           R.string.key_empty,
                           R.string.key_clr_crosshairs,
                           R.string.key_background,
                           R.string.key_clr_bonushint,
        };
        for ( int ii = 0; ii < idsOther.length; ++ii ) {
            otherColors[ii] = prefToColor( context, sp, idsOther[ii] );
        }

        return this;
    }

    private boolean getBoolean( Context context, SharedPreferences sp, 
                                int id, boolean dflt )
    {
        String key = context.getString( id );
        return sp.getBoolean( key, dflt );
    }

    private int prefToColor( Context context, SharedPreferences sp, int id )
    {
        String key = context.getString( id );
        return 0xFF000000 | sp.getInt( key, 0 );
    }

    /*
     * static methods
     */
    public static CommonPrefs get( Context context )
    {
        if ( null == s_cp ) {
            s_cp = new CommonPrefs();
        }
        return s_cp.refresh( context );
    }

    public static String getDefaultRelayHost( Context context )
    {
        return getString( context, R.string.key_relay_host );
    }

    public static String getDefaultRedirHost( Context context )
    {
        return getString( context, R.string.key_redir_host );
    }

    public static int getDefaultRelayPort( Context context )
    {
        String val = getString( context, R.string.key_relay_port );
        int result = 0;
        try {
            result = Integer.parseInt( val );
        } catch ( Exception ex ) {
        } 
        return result;
    }

    public static int getDefaultProxyPort( Context context )
    {
        String val = getString( context, R.string.key_proxy_port );
        int result = 0;
        try {
            result = Integer.parseInt( val );
        } catch ( Exception ex ) {
        } 
        // Utils.logf( ""getDefaultProxyPort=>%d"", result );
        return result;
    }

    public static String getDefaultDictURL( Context context )
    {
        return getString( context, R.string.key_dict_host );
    }

    public static boolean getVolKeysZoom( Context context )
    {
        return getPrefsBoolean( context, R.string.key_ringer_zoom, false );
    }

    public static int getDefaultBoardSize( Context context )
    {
        String value = getString( context, R.string.key_board_size );
        try {
            return Integer.parseInt( value.substring( 0, 2 ) );
        } catch ( Exception ex ) {
            return 15;
        } 
    }

    public static int getDefaultPlayerMinutes( Context context )
    {
        String value = getString( context, R.string.key_initial_player_minutes );
        try {
            return Integer.parseInt( value );
        } catch ( Exception ex ) {
            return 25;
        }
    }

    public static long getProxyInterval( Context context )
    {
        String value = getString( context, R.string.key_connect_frequency );
        try {
            return Long.parseLong( value );
        } catch ( Exception ex ) {
            return -1;
        }
    }

    public static String getDefaultHumanDict( Context context )
    {
        String value = getString( context, R.string.key_default_dict );
        if ( value.equals("""") || !DictUtils.dictExists( context, value ) ) {
            value = DictUtils.dictList( context )[0].name;
        }
        return value;
    }

    public static String getDefaultRobotDict( Context context )
    {
        String value = getString( context, R.string.key_default_robodict );
        if ( value.equals("""") || !DictUtils.dictExists( context, value ) ) {
            value = getDefaultHumanDict( context );
        }
        return value;
    }
    
    public static String getDefaultPlayerName( Context context, int num,
                                               boolean force )
    {
        int id = 0;
        switch( num ) {
        case 0: id = R.string.key_player1_name; break;
        case 1: id = R.string.key_player2_name; break;
        case 2: id = R.string.key_player3_name; break;
        case 3: id = R.string.key_player4_name; break;
        }
        String result = getString( context, id );
        if ( null != result && 0 == result.length() ) {
            result = null;      // be consistent
        }
        if ( force && null == result ) {
            String fmt = context.getString( R.string.playerf );
            result = String.format( fmt, num + 1 );
        }
        return result;
    }

    public static String getDefaultPlayerName( Context context, int num )
    {
        return getDefaultPlayerName( context, num, true );
    }

    public static void setDefaultPlayerName( Context context, String value )
    {
        setPrefsString( context, R.string.key_player1_name, value );
    }

    public static CurGameInfo.XWPhoniesChoice 
        getDefaultPhonies( Context context )
    {
        String value = getString( context, R.string.key_default_phonies );

        CurGameInfo.XWPhoniesChoice result = 
            CurGameInfo.XWPhoniesChoice.PHONIES_IGNORE;
        Resources res = context.getResources();
        String[] names = res.getStringArray( R.array.phony_names );
        for ( int ii = 0; ii < names.length; ++ii ) {
            String name = names[ii];
            if ( name.equals( value ) ) {
                result = CurGameInfo.XWPhoniesChoice.values()[ii];
                break;
            }
        }
        return result;
    }
    
    public static boolean getDefaultTimerEnabled( Context context )
    {
        return getPrefsBoolean( context, R.string.key_default_timerenabled, 
                                false );
    }

    public static boolean getDefaultHintsAllowed( Context context )
    {
        return getPrefsBoolean( context, R.string.key_init_hintsallowed, 
                                true );
    }

    public static boolean getAutoJuggle( Context context )
    {
        return getPrefsBoolean( context, R.string.key_init_autojuggle, false );
    }

    public static boolean getHideTitleBar( Context context )
    {
        return getPrefsBoolean( context, R.string.key_hide_title, true );
    }

    public static boolean getSoundNotify( Context context )
    {
        return getPrefsBoolean( context, R.string.key_notify_sound, true );
    }

    public static boolean getVibrateNotify( Context context )
    {
        return getPrefsBoolean( context, R.string.key_notify_vibrate, false );
    }

    public static boolean getHideIntro( Context context )
    {
        return getPrefsBoolean( context, R.string.key_hide_intro, false );
    }

    public static boolean getKeepScreenOn( Context context )
    {
        return getPrefsBoolean( context, R.string.key_keep_screenon, false );
    }

    public static String getSummaryField( Context context )
    {
        return getString( context, R.string.key_summary_field );
    }

    public static boolean getPrefsBoolean( Context context, int keyID,
                                           boolean defaultValue )
    {
        String key = context.getString( keyID );
        SharedPreferences sp = PreferenceManager
            .getDefaultSharedPreferences( context );
        return sp.getBoolean( key, defaultValue );
    }

    public static void setPrefsBoolean( Context context, int keyID, 
                                        boolean newValue )
    {
        SharedPreferences sp = PreferenceManager
            .getDefaultSharedPreferences( context );
        SharedPreferences.Editor editor = sp.edit();
        String key = context.getString( keyID );
        editor.putBoolean( key, newValue );
        editor.commit();
    }

    private static String getString( Context context, int keyID )
    {
        String key = context.getString( keyID );
        SharedPreferences sp = PreferenceManager
            .getDefaultSharedPreferences( context );
        return sp.getString( key, """" );
    }

    private static void setPrefsString( Context context, int keyID, 
                                        String newValue )
    {
        SharedPreferences sp = PreferenceManager
            .getDefaultSharedPreferences( context );
        SharedPreferences.Editor editor = sp.edit();
        String key = context.getString( keyID );
        editor.putString( key, newValue );
        editor.commit();
    }

}
",True,57,45,2,7,8,7,20,3,L1
55,org.eehouse.android.xw4.jni.TransportProcs.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

public interface TransportProcs {
    int transportSend( byte[] buf, final CommsAddrRec addr );

    enum CommsRelayState { COMMS_RELAYSTATE_UNCONNECTED
            , COMMS_RELAYSTATE_DENIED
            , COMMS_RELAYSTATE_CONNECT_PENDING
            , COMMS_RELAYSTATE_CONNECTED
            , COMMS_RELAYSTATE_RECONNECTED
            , COMMS_RELAYSTATE_ALLCONNECTED
    };
    void relayStatus( CommsRelayState newState );

    void relayConnd( String room, int devOrder, boolean allHere, int nMissing );

    public static enum XWRELAY_ERROR { NONE
            ,OLDFLAGS 
            ,BADPROTO
            ,RELAYBUSY
            ,SHUTDOWN
            ,TIMEOUT 
            ,HEART_YOU
            ,HEART_OTHER
            ,LOST_OTHER
            ,OTHER_DISCON
            ,NO_ROOM
            ,DUP_ROOM
            ,TOO_MANY
            ,DELETED
            ,NORECONN
            ,DEADGAME
    };
    void relayErrorProc( XWRELAY_ERROR relayErr );

    public interface TPMsgHandler {
        public void tpmRelayConnd( String room, int devOrder, boolean allHere, 
                                   int nMissing );
        public void tpmRelayErrorProc( XWRELAY_ERROR relayErr );
    }
}
",False,40,37,0,0,10,6,4,1,L1
56,org.eehouse.android.xw4.jni.JNIThread.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */


package org.eehouse.android.xw4.jni;

import org.eehouse.android.xw4.Utils;
import android.content.Context;
import java.lang.InterruptedException;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.Iterator;
import android.os.Handler;
import android.os.Message;
import android.graphics.Paint;
import android.graphics.Rect;

import org.eehouse.android.xw4.R;
import org.eehouse.android.xw4.BoardDims;
import org.eehouse.android.xw4.GameUtils;
import org.eehouse.android.xw4.DBUtils;
import org.eehouse.android.xw4.Toolbar;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class JNIThread extends Thread {

    public enum JNICmd { CMD_NONE,
            CMD_DRAW,
            CMD_INVALALL,
            CMD_LAYOUT,
            CMD_START,
            CMD_SWITCHCLIENT,
            CMD_RESET,
            CMD_SAVE,
            CMD_DO,
            CMD_RECEIVE,
            CMD_TRANSFAIL,
            CMD_PREFS_CHANGE,
            CMD_PEN_DOWN,
            CMD_PEN_MOVE,
            CMD_PEN_UP,
            CMD_KEYDOWN,
            CMD_KEYUP,
            CMD_TIMER_FIRED,
            CMD_COMMIT,
            CMD_JUGGLE,
            CMD_FLIP,
            CMD_TOGGLE_TRAY,
            CMD_TRADE,
            CMD_CANCELTRADE,
            CMD_UNDO_CUR,
            CMD_UNDO_LAST,
            CMD_HINT,
            CMD_ZOOM,
            CMD_TOGGLEZOOM,
            CMD_PREV_HINT,
            CMD_NEXT_HINT,
            CMD_VALUES,
            CMD_COUNTS_VALUES,
            CMD_REMAINING,
            CMD_RESEND,
            CMD_HISTORY,
            CMD_FINAL,
            CMD_ENDGAME,
            CMD_POST_OVER,
            CMD_SENDCHAT,
            CMD_DRAW_CONNS_STATUS,
            };

    public static final int RUNNING = 1;
    public static final int DRAW = 2;
    public static final int DIALOG = 3;
    public static final int QUERY_ENDGAME = 4;
    public static final int TOOLBAR_STATES = 5;

    public class GameStateInfo implements Cloneable {
        public int visTileCount;
        public boolean canHint;
        public boolean canRedo;
        public boolean inTrade;
        public boolean tradeTilesSelected;
        public boolean gameIsConnected;
        public boolean canShuffle;
        public GameStateInfo clone() {
            GameStateInfo obj = null;
            try {
                obj = (GameStateInfo)super.clone();
            } catch ( CloneNotSupportedException cnse ) {
            }
            return obj;
        }
    }

    private GameStateInfo m_gsi = new GameStateInfo();

    private boolean m_stopped = false;
    private boolean m_saveOnStop = false;
    private int m_jniGamePtr;
    private GameUtils.GameLock m_lock;
    private Context m_context;
    private CurGameInfo m_gi;
    private Handler m_handler;
    private SyncedDraw m_drawer;
    private static final int kMinDivWidth = 10;
    private Rect m_connsIconRect;
    private int m_connsIconID = 0;

    LinkedBlockingQueue<QueueElem> m_queue;

    private class QueueElem {
        protected QueueElem( JNICmd cmd, boolean isUI, Object[] args )
        {
            m_cmd = cmd; m_isUIEvent = isUI; m_args = args;
        }
        boolean m_isUIEvent;
        JNICmd m_cmd;
        Object[] m_args;
    }

    public JNIThread( int gamePtr, CurGameInfo gi, SyncedDraw drawer, 
                      GameUtils.GameLock lock, Context context, Handler handler ) 
    {
        m_jniGamePtr = gamePtr;
        m_gi = gi;
        m_drawer = drawer;
        m_lock = lock;
        m_context = context;
        m_handler = handler;

        m_queue = new LinkedBlockingQueue<QueueElem>();
    }

    public void waitToStop( boolean save )
    {
        synchronized ( this ) {
            m_stopped = true;
            m_saveOnStop = save;
        }
        handle( JNICmd.CMD_NONE );     // tickle it
        try {
            // Can't pass timeout to join.  There's no way to kill
            // this thread unless it's doing something interruptable
            // (like blocking on a socket) so might as well let it
            // take however log it takes.  If that's too long, fix it.
            join();
            // Assert.assertFalse( isAlive() );
        } catch ( java.lang.InterruptedException ie ) {
            Utils.logf( ""JNIThread.waitToStop() got %s"",  ie.toString() );
        }
    }

    public boolean busy()
    {                           // synchronize this!!!
        boolean result = false;
        Iterator<QueueElem> iter = m_queue.iterator();
        while ( iter.hasNext() ) {
            if ( iter.next().m_isUIEvent ) {
                result = true;
                break;
            }
        }
        return result;
    }

    public void setInBackground( boolean inBack )
    {
        if ( inBack ) {
            handle( JNICmd.CMD_SAVE );
        }
    }

    public GameStateInfo getGameStateInfo()
    {
        synchronized( m_gsi ) {
            return m_gsi.clone();
        }
    }

    private boolean toggleTray() {
        boolean draw;
        int state = XwJNI.board_getTrayVisState( m_jniGamePtr );
        if ( state == XwJNI.TRAY_REVEALED ) {
            draw = XwJNI.board_hideTray( m_jniGamePtr );
        } else {
            draw = XwJNI.board_showTray( m_jniGamePtr );
        }
        return draw;
    }

    private void sendForDialog( int titleArg, String text )
    {
        Message.obtain( m_handler, DIALOG, titleArg, 0, text ).sendToTarget();
    }

    private void doLayout( BoardDims dims )
    {
        int scoreWidth = dims.width;

        if ( DeviceRole.SERVER_STANDALONE != m_gi.serverRole ) {
            scoreWidth -= dims.cellSize;
            m_connsIconRect = 
                new Rect( scoreWidth, 0, scoreWidth + dims.cellSize, 
                          dims.scoreHt );
        }

        if ( m_gi.timerEnabled ) {
            scoreWidth -= dims.timerWidth;
            XwJNI.board_setTimerLoc( m_jniGamePtr, scoreWidth, 0, 
                                     dims.timerWidth, dims.scoreHt );
        } 
        XwJNI.board_setScoreboardLoc( m_jniGamePtr, 0, 0, scoreWidth, 
                                      dims.scoreHt, true );

        XwJNI.board_setPos( m_jniGamePtr, 0, dims.scoreHt, 
                            dims.width-1, dims.boardHt, dims.maxCellSize, 
                            false );

        XwJNI.board_setTrayLoc( m_jniGamePtr, 0, dims.trayTop,
                                dims.width-1, dims.trayHt, kMinDivWidth );

        XwJNI.board_invalAll( m_jniGamePtr );
    }

    private boolean nextSame( JNICmd cmd ) 
    {
        QueueElem nextElem = m_queue.peek();
        return null != nextElem && nextElem.m_cmd == cmd;
    }

    private boolean processKeyEvent( JNICmd cmd, XwJNI.XP_Key xpKey,
                                     boolean[] barr )
    {
        boolean draw = false;
        return draw;
    } // processKeyEvent

    private void checkButtons()
    {
        synchronized( m_gsi ) {
            XwJNI.game_getState( m_jniGamePtr, m_gsi );
        }
        Message.obtain( m_handler, TOOLBAR_STATES ).sendToTarget();
    }

    private void save_jni()
    {
        // If server has any work to do, e.g. clean up after showing a
        // remote- or robot-moved dialog, let it do so before saving
        // state.  In some cases it'll otherwise drop the move.
        XwJNI.server_do( m_jniGamePtr );

        XwJNI.game_getGi( m_jniGamePtr, m_gi );
        GameSummary summary = new GameSummary( m_context, m_gi );
        XwJNI.game_summarize( m_jniGamePtr, summary );
        byte[] state = XwJNI.game_saveToStream( m_jniGamePtr, null );
        GameUtils.saveGame( m_context, state, m_lock, false );
        DBUtils.saveSummary( m_context, m_lock, summary );
    }

    public void run() 
    {
        boolean[] barr = new boolean[2]; // scratch boolean
        for ( ; ; ) {
            synchronized ( this ) {
                if ( m_stopped ) {
                    break;
                }
            }

            QueueElem elem;
            Object[] args;
            try {
                elem = m_queue.take();
            } catch ( InterruptedException ie ) {
                Utils.logf( ""interrupted; killing thread"" );
                break;
            }
            boolean draw = false;
            args = elem.m_args;
            switch( elem.m_cmd ) {

            case CMD_SAVE:
                if ( nextSame( JNICmd.CMD_SAVE ) ) {
                    continue;
                }
                save_jni();
                break;

            case CMD_DRAW:
                if ( nextSame( JNICmd.CMD_DRAW ) ) {
                    continue;
                }
                draw = true;
                break;

            case CMD_INVALALL:
                XwJNI.board_invalAll( m_jniGamePtr );
                draw = true;
                break;

            case CMD_LAYOUT:
                doLayout( (BoardDims)args[0] );
                draw = true;
                // check and disable zoom button at limit
                handle( JNICmd.CMD_ZOOM, 0 );
                break;

            case CMD_RESET:
                XwJNI.comms_resetSame( m_jniGamePtr );
                // FALLTHRU
            case CMD_START:
                XwJNI.comms_start( m_jniGamePtr );
                if ( m_gi.serverRole == DeviceRole.SERVER_ISCLIENT ) {
                    XwJNI.server_initClientConnection( m_jniGamePtr );
                }
                draw = XwJNI.server_do( m_jniGamePtr );
                break;

            case CMD_SWITCHCLIENT:
                XwJNI.server_reset( m_jniGamePtr );
                XwJNI.server_initClientConnection( m_jniGamePtr );
                draw = XwJNI.server_do( m_jniGamePtr );
                break;

            case CMD_DO:
                if ( nextSame( JNICmd.CMD_DO ) ) {
                    continue;
                }
                draw = XwJNI.server_do( m_jniGamePtr );
                break;

            case CMD_RECEIVE:
                draw = XwJNI.game_receiveMessage( m_jniGamePtr, 
                                                  (byte[])args[0] );
                handle( JNICmd.CMD_DO );
                if ( draw ) {
                    handle( JNICmd.CMD_SAVE );
                }
                break;

            case CMD_TRANSFAIL:
                XwJNI.comms_transportFailed( m_jniGamePtr );
                break;

            case CMD_PREFS_CHANGE:
                // need to inval all because some of prefs,
                // e.g. colors, aren't known by common code so
                // board_prefsChanged's return value isn't enough.
                XwJNI.board_invalAll( m_jniGamePtr );
                XwJNI.board_server_prefsChanged( m_jniGamePtr, 
                                                 CommonPrefs.get( m_context ) );
                draw = true;
                break;

            case CMD_PEN_DOWN:
                draw = XwJNI.board_handlePenDown( m_jniGamePtr, 
                                                  ((Integer)args[0]).intValue(),
                                                  ((Integer)args[1]).intValue(),
                                                  barr );
                break;
            case CMD_PEN_MOVE:
                if ( nextSame( JNICmd.CMD_PEN_MOVE ) ) {
                    continue;
                }
                draw = XwJNI.board_handlePenMove( m_jniGamePtr, 
                                                  ((Integer)args[0]).intValue(),
                                                  ((Integer)args[1]).intValue() );
                break;
            case CMD_PEN_UP:
                draw = XwJNI.board_handlePenUp( m_jniGamePtr, 
                                                ((Integer)args[0]).intValue(),
                                                ((Integer)args[1]).intValue() );
                break;

            case CMD_KEYDOWN:
            case CMD_KEYUP:
                draw = processKeyEvent( elem.m_cmd, (XwJNI.XP_Key)args[0], barr );
                break;

            case CMD_COMMIT:
                draw = XwJNI.board_commitTurn( m_jniGamePtr );
                break;

            case CMD_JUGGLE:
                draw = XwJNI.board_juggleTray( m_jniGamePtr );
                break;
            case CMD_FLIP:
                draw = XwJNI.board_flip( m_jniGamePtr );
                break;
            case CMD_TOGGLE_TRAY:
                draw = toggleTray();
                break;
            case CMD_TRADE:
                draw = XwJNI.board_beginTrade( m_jniGamePtr );
                break;
            case CMD_CANCELTRADE:
                draw = XwJNI.board_endTrade( m_jniGamePtr );
                break;
            case CMD_UNDO_CUR:
                draw = XwJNI.board_replaceTiles( m_jniGamePtr )
                    || XwJNI.board_redoReplacedTiles( m_jniGamePtr );
                break;
            case CMD_UNDO_LAST:
                XwJNI.server_handleUndo( m_jniGamePtr );
                draw = true;
                break;

            case CMD_HINT:
                XwJNI.board_resetEngine( m_jniGamePtr );
                handle( JNICmd.CMD_NEXT_HINT );
                break;

            case CMD_NEXT_HINT:
            case CMD_PREV_HINT:
                if ( nextSame( elem.m_cmd ) ) {
                    continue;
                }
                draw = XwJNI.board_requestHint( m_jniGamePtr, false, 
                                                JNICmd.CMD_PREV_HINT==elem.m_cmd,
                                                barr );
                if ( barr[0] ) {
                    handle( elem.m_cmd );
                    draw = false;
                }
                break;

            case CMD_TOGGLEZOOM:
                XwJNI.board_zoom( m_jniGamePtr, 0 , barr );
                int zoomBy = 0;
                if ( barr[1] ) { // always go out if possible
                    zoomBy = -5;
                } else if ( barr[0] ) {
                    zoomBy = 5;
                }
                draw = XwJNI.board_zoom( m_jniGamePtr, zoomBy, barr );
                break;
            case CMD_ZOOM:
                draw = XwJNI.board_zoom( m_jniGamePtr, 
                                         ((Integer)args[0]).intValue(),
                                         barr );
                break;

            case CMD_VALUES:
                draw = XwJNI.board_toggle_showValues( m_jniGamePtr );
                break;

            case CMD_COUNTS_VALUES:
                sendForDialog( ((Integer)args[0]).intValue(),
                               XwJNI.server_formatDictCounts( m_jniGamePtr, 3 )
                               );
                break;
            case CMD_REMAINING:
                sendForDialog( ((Integer)args[0]).intValue(),
                               XwJNI.board_formatRemainingTiles( m_jniGamePtr )
                               );
                break;

            case CMD_RESEND:
                XwJNI.comms_resendAll( m_jniGamePtr );
                break;

            case CMD_HISTORY:
                boolean gameOver = XwJNI.server_getGameIsOver( m_jniGamePtr );
                sendForDialog( ((Integer)args[0]).intValue(),
                               XwJNI.model_writeGameHistory( m_jniGamePtr, 
                                                             gameOver ) );
                break;

            case CMD_FINAL:
                if ( XwJNI.server_getGameIsOver( m_jniGamePtr ) ) {
                    handle( JNICmd.CMD_POST_OVER );
                } else {
                    Message.obtain( m_handler, QUERY_ENDGAME ).sendToTarget();
                }
                break;

            case CMD_ENDGAME:
                XwJNI.server_endGame( m_jniGamePtr );
                draw = true;
                break;

            case CMD_POST_OVER:
                if ( XwJNI.server_getGameIsOver( m_jniGamePtr ) ) {
                    sendForDialog( R.string.finalscores_title,
                                   XwJNI.server_writeFinalScores( m_jniGamePtr ) );
                }
                break;

            case CMD_SENDCHAT:
                XwJNI.server_sendChat( m_jniGamePtr, (String)args[0] );
                break;

            case CMD_DRAW_CONNS_STATUS:
                int newID = 0;
                switch( (TransportProcs.CommsRelayState)(args[0]) ) {
                case COMMS_RELAYSTATE_UNCONNECTED:
                case COMMS_RELAYSTATE_DENIED:
                case COMMS_RELAYSTATE_CONNECT_PENDING:
                    newID = R.drawable.netarrow_unconn;
                    break;
                case COMMS_RELAYSTATE_CONNECTED: 
                case COMMS_RELAYSTATE_RECONNECTED: 
                    newID = R.drawable.netarrow_someconn;
                    break;
                case COMMS_RELAYSTATE_ALLCONNECTED:
                    newID = R.drawable.netarrow_allconn;
                    break;
                default:
                    newID = 0;
                }
                if ( m_connsIconID != newID ) {
                    draw = true;
                    m_connsIconID = newID;
                }
                break;

            case CMD_TIMER_FIRED:
                draw = XwJNI.timerFired( m_jniGamePtr, 
                                         ((Integer)args[0]).intValue(),
                                         ((Integer)args[1]).intValue(),
                                         ((Integer)args[2]).intValue() );
                break;
            }

            if ( draw ) {
                // do the drawing in this thread but in BoardView
                // where it can be synchronized with that class's use
                // of the same bitmap for blitting.
                m_drawer.doJNIDraw();
                if ( null != m_connsIconRect ) {
                    m_drawer.doIconDraw( m_connsIconID, m_connsIconRect );
                }

                // main UI thread has to invalidate view as it created
                // it.
                Message.obtain( m_handler, DRAW ).sendToTarget();

                checkButtons();
            }
        } // for

        if ( m_saveOnStop ) {
            save_jni();
        }
    } // run

    public void handle( JNICmd cmd, boolean isUI, Object... args )
    {
        QueueElem elem = new QueueElem( cmd, isUI, args );
        // Utils.logf( ""adding: %s"", cmd.toString() );
        m_queue.add( elem );
    }

    public void handle( JNICmd cmd, Object... args )
    {
        handle( cmd, true, args );
    }

}
",True,31,37,0,0,4,16,5,11,L1
57,org.eehouse.android.xw4.jni.SyncedDraw.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.graphics.Rect;

public interface SyncedDraw {
    void doJNIDraw();
    void doIconDraw( int resID, final Rect rect );
}
",False,16,36,7,8,0,0,2,0,L1
58,org.eehouse.android.xw4.jni.XwJNI.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

// Collection of native methods
public class XwJNI {


    // This needs to be called before the first attempt to use the
    // jni.  I figure this class has to be loaded before that cna
    // happen.  Doing this in GamesList isn't enough because sometimes
    // BoardActivity is the first Activity loaded.
    static {
        System.loadLibrary(""xwjni"");
    }
    
    /* XW_TrayVisState enum */
    public static final int TRAY_HIDDEN = 0;
    public static final int TRAY_REVERSED = 1;
    public static final int TRAY_REVEALED = 2;

    // Methods not part of the common interface but necessitated by
    // how java/jni work (or perhaps my limited understanding of it.)

    // callback into jni from java when timer set here fires.
    public static native boolean timerFired( int gamePtr, int why, 
                                             int when, int handle );

    // Stateless methods
    public static native byte[] gi_to_stream( CurGameInfo gi );
    public static native void gi_from_stream( CurGameInfo gi, byte[] stream );
    public static native void comms_getInitialAddr( CommsAddrRec addr,
                                                    String relayHost,
                                                    int relayPort );

    // Game methods
    public static native int initJNI();
    public static native void game_makeNewGame( int gamePtr,
                                                CurGameInfo gi, 
                                                UtilCtxt util,
                                                JNIUtils jniu,
                                                DrawCtx draw, CommonPrefs cp, 
                                                TransportProcs procs, 
                                                String[] dictNames,
                                                byte[][] dictBytes, 
                                                String[] dictPaths, 
                                                String langName );

    public static native boolean game_makeFromStream( int gamePtr,
                                                      byte[] stream, 
                                                      CurGameInfo gi, 
                                                      String[] dictNames,
                                                      byte[][] dictBytes, 
                                                      String[] dictPaths, 
                                                      String langName,
                                                      UtilCtxt util, 
                                                      JNIUtils jniu,
                                                      DrawCtx draw,
                                                      CommonPrefs cp,
                                                      TransportProcs procs );

    // leave out options params for when game won't be rendered or
    // played
    public static void game_makeNewGame( int gamePtr, CurGameInfo gi,
                                         JNIUtils jniu, CommonPrefs cp, 
                                         String[] dictNames, byte[][] dictBytes, 
                                         String[] dictPaths, String langName ) {
        game_makeNewGame( gamePtr, gi, (UtilCtxt)null, jniu,
                          (DrawCtx)null, cp, (TransportProcs)null, 
                          dictNames, dictBytes, dictPaths, langName );
    }

    public static boolean game_makeFromStream( int gamePtr,
                                               byte[] stream, 
                                               JNIUtils jniu,
                                               CurGameInfo gi, 
                                               String[] dictNames,
                                               byte[][] dictBytes, 
                                               String[] dictPaths,
                                               String langName,
                                               CommonPrefs cp ) {
        return game_makeFromStream( gamePtr, stream, gi, dictNames, dictBytes,
                                    dictPaths, langName, (UtilCtxt)null, jniu,
                                    (DrawCtx)null, cp, (TransportProcs)null );
    }

    public static boolean game_makeFromStream( int gamePtr,
                                               byte[] stream, 
                                               JNIUtils jniu,
                                               CurGameInfo gi, 
                                               String[] dictNames,
                                               byte[][] dictBytes, 
                                               String[] dictPaths,
                                               String langName,
                                               UtilCtxt util,
                                               CommonPrefs cp ) {
        return game_makeFromStream( gamePtr, stream, gi, dictNames, dictBytes,
                                    dictPaths, langName, util, jniu, 
                                    (DrawCtx)null, cp, (TransportProcs)null );
    }

    public static native boolean game_receiveMessage( int gamePtr, 
                                                      byte[] stream );
    public static native void game_summarize( int gamePtr, GameSummary summary );
    public static native byte[] game_saveToStream( int gamePtr,
                                                   CurGameInfo gi  );
    public static native void game_getGi( int gamePtr, CurGameInfo gi );
    public static native void game_getState( int gamePtr, 
                                             JNIThread.GameStateInfo gsi );
    public static native boolean game_hasComms( int gamePtr );
    public static native void game_dispose( int gamePtr );

    // Board methods
    public static native void board_invalAll( int gamePtr );
    public static native boolean board_draw( int gamePtr );
    public static native void board_setPos( int gamePtr, int left, int top,
                                            int width, int height, 
                                            int maxCellHt, boolean lefty );
    public static native boolean board_zoom( int gamePtr, int zoomBy, 
                                             boolean[] canZoom );
    public static native void board_setScoreboardLoc( int gamePtr, int left, 
                                                      int top, int width, 
                                                      int height,
                                                      boolean divideHorizontally );
    public static native void board_setTrayLoc( int gamePtr, int left, 
                                                int top, int width, 
                                                int height, int minDividerWidth );
    public static native void board_setTimerLoc( int gamePtr,
                                                 int timerLeft, int timerTop,
                                                 int timerWidth, int timerHeight );

    public static native boolean board_handlePenDown( int gamePtr, 
                                                      int xx, int yy, 
                                                      boolean[] handled );
    public static native boolean board_handlePenMove( int gamePtr, 
                                                      int xx, int yy );
    public static native boolean board_handlePenUp( int gamePtr, 
                                                    int xx, int yy );

    public static native boolean board_juggleTray( int gamePtr );
    public static native int board_getTrayVisState( int gamePtr );
    public static native boolean board_hideTray( int gamePtr );
    public static native boolean board_showTray( int gamePtr );
    public static native boolean board_toggle_showValues( int gamePtr );
    public static native boolean board_commitTurn( int gamePtr );
    public static native boolean board_flip( int gamePtr );
    public static native boolean board_replaceTiles( int gamePtr );
    public static native boolean board_redoReplacedTiles( int gamePtr );
    public static native void board_resetEngine( int gamePtr );
    public static native boolean board_requestHint( int gamePtr, 
                                                    boolean useTileLimits,
                                                    boolean goBackwards,
                                                    boolean[] workRemains );
    public static native boolean board_beginTrade( int gamePtr );
    public static native boolean board_endTrade( int gamePtr );

    public static native String board_formatRemainingTiles( int gamePtr );

    public enum XP_Key {
        XP_KEY_NONE,
        XP_CURSOR_KEY_DOWN,
        XP_CURSOR_KEY_ALTDOWN,
        XP_CURSOR_KEY_RIGHT,
        XP_CURSOR_KEY_ALTRIGHT,
        XP_CURSOR_KEY_UP,
        XP_CURSOR_KEY_ALTUP,
        XP_CURSOR_KEY_LEFT,
        XP_CURSOR_KEY_ALTLEFT,

        XP_CURSOR_KEY_DEL,
        XP_RAISEFOCUS_KEY,
        XP_RETURN_KEY,

        XP_KEY_LAST
    };
    public static native boolean board_handleKey( int gamePtr, XP_Key key, 
                                                  boolean up, boolean[] handled );
    // public static native boolean board_handleKeyDown( XP_Key key, 
    //                                                   boolean[] handled );
    // public static native boolean board_handleKeyRepeat( XP_Key key, 
    //                                                     boolean[] handled );

    // Model
    public static native String model_writeGameHistory( int gamePtr, 
                                                        boolean gameOver );
    public static native int model_getNMoves( int gamePtr );
    public static native String model_getPlayersLastScore( int gamePtr, int player );

    // Server
    public static native void server_reset( int gamePtr );
    public static native void server_handleUndo( int gamePtr );
    public static native boolean server_do( int gamePtr );
    public static native String server_formatDictCounts( int gamePtr, int nCols );
    public static native boolean server_getGameIsOver( int gamePtr );
    public static native String server_writeFinalScores( int gamePtr );
    public static native void server_initClientConnection( int gamePtr );
    public static native void server_endGame( int gamePtr );
    public static native void server_sendChat( int gamePtr, String msg );

    // hybrid to save work
    public static native boolean board_server_prefsChanged( int gamePtr, 
                                                            CommonPrefs cp );

    // Comms
    public static native void comms_start( int gamePtr );
    public static native void comms_resetSame( int gamePtr );
    public static native void comms_getAddr( int gamePtr, CommsAddrRec addr );
    public static native void comms_setAddr( int gamePtr, CommsAddrRec addr );
    public static native void comms_resendAll( int gamePtr );
    public static native void comms_transportFailed( int gamePtr );
    public static native boolean comms_isConnected( int gamePtr );

    // Dicts
    public static native boolean dict_tilesAreSame( int dictPtr1, int dictPtr2 );
    public static native String[] dict_getChars( int dictPtr );
    public static native void dict_getInfo( byte[] dict, String path, 
                                            JNIUtils jniu, DictInfo info );
    public static native int dict_getTileValue( int dictPtr, int tile );
}
",True,55,41,2,2,5,10,6,10,L1
59,org.eehouse.android.xw4.jni.DrawCtx.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.graphics.Rect;

public interface DrawCtx {
    static final int CELL_NONE = 0x00;
    static final int CELL_ISBLANK = 0x01;
    static final int CELL_HIGHLIGHT = 0x02;
    static final int CELL_ISSTAR = 0x04;
    static final int CELL_ISCURSOR = 0x08;
    static final int CELL_ISEMPTY = 0x10;       /* of a tray tile slot */
    static final int CELL_VALHIDDEN = 0x20;     /* show letter only, not value */
    static final int CELL_DRAGSRC = 0x40;       /* where drag originated */
    static final int CELL_DRAGCUR = 0x80;       /* where drag is now */
    static final int CELL_CROSSVERT = 0x100;
    static final int CELL_CROSSHOR = 0x200;
    static final int CELL_ALL = 0x3FF;

    /* BoardObjectType */
    static final int OBJ_NONE = 0;
    static final int OBJ_BOARD = 1;
    static final int OBJ_SCORE = 2;
    static final int OBJ_TRAY = 3;


    boolean scoreBegin( Rect rect, int numPlayers, int[] scores, int remCount,
                        int dfs );
    void measureRemText( Rect r, int nTilesLeft, int[] width, int[] height );
    void measureScoreText( Rect r, DrawScoreInfo dsi, int[] width, int[] height );
    void drawRemText( Rect rInner, Rect rOuter, int nTilesLeft, boolean focussed );
    void score_drawPlayer( Rect rInner, Rect rOuter, DrawScoreInfo dsi );
    void drawTimer( Rect rect, int player, int secondsLeft );
    boolean boardBegin( Rect rect, int cellWidth, int cellHeight, 
                        int dfs );

    boolean drawCell( Rect rect, String text, int tile, 
                      int owner, int bonus, int hintAtts, int flags );
    void drawBoardArrow ( Rect rect, int bonus, boolean vert, int hintAtts,
                          int flags );
    boolean trayBegin ( Rect rect, int owner, int dfs );
    void drawTile( Rect rect, String text, int val, int flags );
    void drawTileMidDrag ( Rect rect, String text, int val, int owner, 
                           int flags );
    void drawTileBack( Rect rect, int flags );
    void drawTrayDivider( Rect rect, int flags );
    void score_pendingScore( Rect rect, int score, int playerNum, int flags );

    public static final int BONUS_NONE = 0;
    public static final int BONUS_DOUBLE_LETTER = 1;
    public static final int BONUS_DOUBLE_WORD = 2;
    public static final int BONUS_TRIPLE_LETTER = 3;
    public static final int BONUS_TRIPLE_WORD = 4;
    public static final int INTRADE_MW_TEXT = 5;

    void objFinished( /*BoardObjectType*/int typ, Rect rect, int dfs );

    void dictChanged( int dictPtr );

}
",False,46,37,6,13,1,1,2,1,L1
60,org.eehouse.android.xw4.jni.CommsAddrRec.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import java.net.InetAddress;
import android.content.Context;

import org.eehouse.android.xw4.Utils;

public class CommsAddrRec {

    public enum CommsConnType { COMMS_CONN_NONE,
            COMMS_CONN_IR,
            COMMS_CONN_IP_DIRECT,
            COMMS_CONN_RELAY,
            COMMS_CONN_BT,
            COMMS_CONN_SMS,
    };

    // The C equivalent of this struct uses a union for the various
    // data sets below.  So don't assume that any fields will be valid
    // except those for the current conType.
    public CommsConnType conType;

    // relay case
    public String ip_relay_invite;
    public String ip_relay_hostName;
    public InetAddress ip_relay_ipAddr;    // a cache, maybe unused in java
    public int ip_relay_port;
    public boolean ip_relay_seeksPublicRoom;
    public boolean ip_relay_advertiseRoom;

    // sms case
    public String sms_phone;
    public int sms_port;                   // NBS port, if they still use those

    public CommsAddrRec( Context context ) 
    {
        conType = CommsConnType.COMMS_CONN_RELAY;
        ip_relay_hostName = CommonPrefs.getDefaultRelayHost( context );
        ip_relay_port = CommonPrefs.getDefaultRelayPort( context );
        ip_relay_seeksPublicRoom = false;
        ip_relay_advertiseRoom = false;
    }

    public CommsAddrRec( final CommsAddrRec src ) 
    {
        this.copyFrom( src );
    }

    public boolean changesMatter( final CommsAddrRec other )
    {
        boolean matter = conType != other.conType;
        if ( !matter ) {
            matter = ! ip_relay_invite.equals( other.ip_relay_invite )
                || ! ip_relay_hostName.equals( other.ip_relay_hostName )
                || ip_relay_port != other.ip_relay_port;
        }
        return matter;
    }

    private void copyFrom( CommsAddrRec src )
    {
        conType = src.conType;
        ip_relay_invite = src.ip_relay_invite;
        ip_relay_hostName = src.ip_relay_hostName;
        ip_relay_port = src.ip_relay_port;
        ip_relay_seeksPublicRoom = src.ip_relay_seeksPublicRoom;
        ip_relay_advertiseRoom = src.ip_relay_advertiseRoom;
    }
}
",False,24,41,1,4,9,6,10,2,L1
