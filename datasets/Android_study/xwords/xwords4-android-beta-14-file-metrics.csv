,file_path,source_code,is_vulnerable,id, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,org.eehouse.android.xw4.GamesList.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.ListActivity;
import android.app.Dialog;
import android.app.AlertDialog;
import android.content.Intent;
import android.content.DialogInterface;
import android.net.Uri;
import android.os.Bundle;
import android.view.ContextMenu;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ContextMenu.ContextMenuInfo;
import android.widget.AdapterView;
import android.widget.ListView;
import android.widget.Button;
import android.view.MenuInflater;
import java.io.File;
import android.preference.PreferenceManager;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;

public class GamesList extends ListActivity {
    private static final int WARN_NODICT = Utils.DIALOG_LAST + 1;
    private static final int CONFIRM_DELETE_ALL = Utils.DIALOG_LAST + 2;

    private GameListAdapter m_adapter;
    private String m_invalPath = null;
    private String m_missingDict;

    @Override
    protected Dialog onCreateDialog( int id )
    {
        Dialog dialog = null;
        switch( id ) {
        case WARN_NODICT:
            dialog = new AlertDialog.Builder( this )
                .setTitle( R.string.no_dict_title )
                .setMessage( """" ) // required to get to change it later
                .setPositiveButton( R.string.button_ok, null )
                .setNegativeButton( R.string.button_download,
                    new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dlg, int item ) {
                            Intent intent = 
                                Utils.mkDownloadActivity(GamesList.this);
                            startActivity( intent );
                        }
                    })
                .create();
            break;
        case CONFIRM_DELETE_ALL:
            DialogInterface.OnClickListener lstnr = 
                new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        for( String game:GameUtils.gamesList(GamesList.this)) {
                            GameUtils.deleteGame( GamesList.this, game  );
                        }
                        m_adapter = new GameListAdapter( GamesList.this );
                        setListAdapter( m_adapter );
                    }
                };
            dialog = new AlertDialog.Builder( this )
                .setTitle( R.string.query_title )
                .setMessage( R.string.confirm_delete_all )
                .setPositiveButton( R.string.button_ok, lstnr )
                .setNegativeButton( R.string.button_cancel, null )
                .create();
            break;
        default:
            dialog = Utils.onCreateDialog( this, id );
        }
        return dialog;
    }

    @Override
    protected void onPrepareDialog( int id, Dialog dialog )
    {
        if ( WARN_NODICT == id ) {
            String format = getString( R.string.no_dictf );
            String msg = String.format( format, m_missingDict );
            ((AlertDialog)dialog).setMessage( msg );
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        PreferenceManager.setDefaultValues( this, R.xml.xwprefs, false );

        setContentView(R.layout.game_list);

        // setDefaultKeyMode(DEFAULT_KEYS_SHORTCUT);

        registerForContextMenu( getListView() );

        Button newGameB = (Button)findViewById(R.id.new_game);
        newGameB.setOnClickListener( new View.OnClickListener() {
                @Override
                public void onClick( View v ) {
                    saveNew( new CurGameInfo( GamesList.this ) );
                    onContentChanged();
                }
            } );

        m_adapter = new GameListAdapter( this );
        setListAdapter( m_adapter );

        FirstRunDialog.show( this, false );
    }

    @Override
    public void onWindowFocusChanged( boolean hasFocus )
    {
        super.onWindowFocusChanged( hasFocus );
        if ( hasFocus && null != m_invalPath ) {
            m_adapter.inval( m_invalPath );
            m_invalPath = null;
            onContentChanged();
        }
    }

    @Override
    public void onCreateContextMenu( ContextMenu menu, View view, 
                                     ContextMenuInfo menuInfo ) 
    {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.games_list_item_menu, menu );
        if ( CommonPrefs.getClickLaunches( this ) ) {
            menu.removeItem( R.id.list_item_play );
        }
    }
        
    @Override
    public boolean onContextItemSelected( MenuItem item ) 
    {
        AdapterView.AdapterContextMenuInfo info;
        try {
            info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
        } catch (ClassCastException e) {
            Utils.logf( ""bad menuInfo:"" + e.toString() );
            return false;
        }

        return handleMenuItem( item.getItemId(), info.position );
    } // onContextItemSelected

    public boolean onCreateOptionsMenu( Menu menu )
    {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.games_list_menu, menu );
        return true;
    }

    public boolean onOptionsItemSelected( MenuItem item )
    {
        boolean handled = true;
        Intent intent;

        switch (item.getItemId()) {
        case R.id.gamel_menu_delete_all:
            if ( GameUtils.gamesList( this ).length > 0 ) {
                showDialog( CONFIRM_DELETE_ALL );
            }
            handled = true;
            break;

        case R.id.gamel_menu_dicts:
            intent = new Intent( this, DictsActivity.class );
            startActivity( intent );
            break;

        case R.id.gamel_menu_prefs:
            intent = new Intent( this, PrefsActivity.class );
            startActivity( intent );
            break;

        case R.id.gamel_menu_about:
            showDialog( Utils.DIALOG_ABOUT );
            break;

        // case R.id.gamel_menu_view_hidden:
        //     Utils.notImpl( this );
        //     break;
        default:
            handled = false;
        }

        return handled;
    }

    @Override
    protected void onListItemClick( ListView l, View v, int position, long id )
    {
        super.onListItemClick( l, v, position, id );

        if ( CommonPrefs.getClickLaunches( this ) ) {
            handleMenuItem( R.id.list_item_play, position );
        } else {
            v.showContextMenu();
        }
    }

    private boolean handleMenuItem( int menuID, int position ) 
    {
        boolean handled = true;
        byte[] stream;
        String invalPath = null;

        String path = GameUtils.gamesList( this )[position];
    
        if ( R.id.list_item_delete == menuID ) {
            GameUtils.deleteGame( this, path );
            invalPath = path;
        } else {
            String[] missingName = new String[1];
            boolean hasDict = GameUtils.gameDictHere( this, path, missingName );
            if ( !hasDict ) {
                m_missingDict = missingName[0];
                showDialog( WARN_NODICT );
            } else {
                switch ( menuID ) {
                case R.id.list_item_play:
                    File file = new File( path );
                    Uri uri = Uri.fromFile( file );
                    Intent intent = new Intent( Intent.ACTION_EDIT, uri,
                                                this, BoardActivity.class );
                    startActivity( intent );
                    m_invalPath = path;
                    break;

                case R.id.list_item_config:
                    doConfig( path );
                    m_invalPath = path;
                    break;

                case R.id.list_item_reset:
                    GameUtils.resetGame( this, path, path );
                    invalPath = path;
                    break;
                case R.id.list_item_new_from:
                    String newName = GameUtils.resetGame( this, path );  
                    invalPath = newName;
                    break;

                case R.id.list_item_copy:
                    stream = GameUtils.savedGame( this, path );
                    newName = GameUtils.saveGame( this, stream );
                    DBUtils.saveSummary( newName, 
                                         DBUtils.getSummary( this, path ) );
                    break;

                    // These require some notion of predictable sort order.
                    // Maybe put off until I'm using a db?
                    // case R.id.list_item_hide:
                    // case R.id.list_item_move_up:
                    // case R.id.list_item_move_down:
                    // case R.id.list_item_move_to_top:
                    // case R.id.list_item_move_to_bottom:
                    // Utils.notImpl( this );
                    // break;
                default:
                    handled = false;
                    break;
                }
            }
        }

        if ( null != invalPath ) {
            m_adapter.inval( invalPath );
        }

        if ( handled ) {
            onContentChanged();
        }

        return handled;
    } // handleMenuItem

    private void doConfig( String path )
    {
        Uri uri = Uri.fromFile( new File(path) );
        
        Intent intent = new Intent( Intent.ACTION_EDIT, uri,
                                    this, GameConfig.class );
        startActivity( intent );
    }

    private void saveNew( CurGameInfo gi )
    {
        byte[] bytes = XwJNI.gi_to_stream( gi );
        if ( null != bytes ) {
            GameUtils.saveGame( this, bytes );
        } else {
            Utils.logf( ""gi_to_stream=>null"" );
        }
    }
}
",True,35,21,0,0,4,8,0,7,L1
1,org.eehouse.android.xw4.PrefsActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;
import android.preference.PreferenceActivity;
import android.app.Dialog;
import android.app.AlertDialog;
import android.content.Intent;
import android.content.DialogInterface;
import android.os.Bundle;
import android.content.SharedPreferences;
import android.preference.Preference;
import android.preference.PreferenceManager;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MenuInflater;

public class PrefsActivity extends PreferenceActivity 
    implements SharedPreferences.OnSharedPreferenceChangeListener {

    private static final int REVERT_COLORS = 1;
    private static final int REVERT_ALL = 2;

    private String[] m_keys;

    @Override
    protected Dialog onCreateDialog( int id )
    {
        DialogInterface.OnClickListener lstnr = null;
        int confirmID = 0;

        switch( id ) {
        case REVERT_COLORS:
            confirmID = R.string.confirm_revert_colors;
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        SharedPreferences sp =
                            getPreferenceScreen().getSharedPreferences();
                        SharedPreferences.Editor editor = sp.edit();
                        int[] colorKeys = {
                            R.string.key_player0,
                            R.string.key_player1,
                            R.string.key_player2,
                            R.string.key_player3,
                            R.string.key_bonus_l2x,
                            R.string.key_bonus_l3x,
                            R.string.key_bonus_w2x,
                            R.string.key_bonus_w3x,
                            R.string.key_tile_back,
                            R.string.key_clr_crosshairs,
                            R.string.key_empty,
                        };
                        for ( int colorKey : colorKeys ) {
                            editor.remove( getString(colorKey) );
                        }
                        editor.commit();
                        relaunch();
                    }
                };
            break;
        case REVERT_ALL:
            confirmID = R.string.confirm_revert_all;
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        SharedPreferences sp =
                            getPreferenceScreen().getSharedPreferences();
                        SharedPreferences.Editor editor = sp.edit();
                        editor.clear();
                        editor.commit();
                        relaunch();
                    }
                };
            break;
        }

        Dialog dialog = null;
        if ( null != lstnr ) {
            dialog = new AlertDialog.Builder( this )
                .setTitle( R.string.query_title )
                .setMessage( confirmID )
                .setPositiveButton( R.string.button_ok, lstnr )
                .setNegativeButton( R.string.button_cancel, null )
                .create();
        }
        return dialog;
    }

    @Override
    protected void onCreate( Bundle savedInstanceState )
    {
        super.onCreate(savedInstanceState);

        // Load the preferences from an XML resource
        addPreferencesFromResource( R.xml.xwprefs );

        int[] textKeyIds = { R.string.key_relay_host,
                             R.string.key_relay_port,
                             // R.string.key_sms_port,
                             R.string.key_dict_host,
                             R.string.key_board_size,
                             R.string.key_initial_player_minutes,
                             R.string.key_default_dict,
                             R.string.key_default_phonies,
        };

        SharedPreferences sp
            = PreferenceManager.getDefaultSharedPreferences( this );
        m_keys = new String[ textKeyIds.length ];
        for ( int ii = 0; ii < textKeyIds.length; ++ii ) {
            int id  = textKeyIds[ii];
            String key = getString( id );
            setSummary( sp, key );
            m_keys[ii] = key;
        }
    }
    
    @Override
    protected void onResume() 
    {
        super.onResume();
        getPreferenceScreen().getSharedPreferences().
            registerOnSharedPreferenceChangeListener(this);   
   }

    @Override
    protected void onPause() 
    {
        super.onPause();
        getPreferenceScreen().getSharedPreferences().
            unregisterOnSharedPreferenceChangeListener(this);
    }

    public void onSharedPreferenceChanged( SharedPreferences sp, String key ) 
    {
        for ( String akey : m_keys ) {
            if ( akey.equals( key ) ) {
                setSummary( sp, key );
                break;
            }
        }
    }

    @Override
    public boolean onCreateOptionsMenu( Menu menu )
    {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.prefs_menu, menu );
        return true;
    }

    @Override
    public boolean onOptionsItemSelected( MenuItem item )
    {
        int dlgID = 0;
        switch ( item.getItemId() ) {
        case R.id.menu_revert_all:
            dlgID = REVERT_ALL;
            break;
        case R.id.menu_revert_colors:
            dlgID = REVERT_COLORS;
            break;
        }

        boolean handled = 0 != dlgID;
        if ( handled ) {
            showDialog( dlgID );
        }
        return handled;
    }

    private void setSummary( SharedPreferences sp, String key )
    {
        Preference pref = getPreferenceScreen().findPreference( key );
        String value = sp.getString( key, """" );
        if ( ! value.equals("""") ) {
            pref.setSummary( value );
        }
    }


    private void relaunch()
    {
        PreferenceManager.setDefaultValues( this, R.xml.xwprefs,
                                            false );

        // Now replace this activity with a new copy
        // so the new values get loaded.
        startActivity( new Intent( this, PrefsActivity.class ) );
        finish();
    }

}
",False,31,1,0,0,0,0,0,0,I0
2,org.eehouse.android.xw4.GameUtils.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.ArrayList;
import android.content.res.AssetManager;

import org.eehouse.android.xw4.jni.*;

public class GameUtils {

    private static Object s_syncObj = new Object();

    public static byte[] savedGame( Context context, String path )
    {
        byte[] stream = null;
        try {
            synchronized( s_syncObj ) {
                FileInputStream in = context.openFileInput( path );
                int len = in.available();
                stream = new byte[len];
                in.read( stream, 0, len );
                in.close();
            }
        } catch ( java.io.FileNotFoundException fnf ) {
            Utils.logf( fnf.toString() );
            stream = null;
        } catch ( java.io.IOException io ) {
            Utils.logf( io.toString() );
            stream = null;
        }
        return stream;
    } // savedGame

    /**
     * Open an existing game, and use its gi and comms addr as the
     * basis for a new one.
     */
    public static void resetGame( Context context, String pathIn, 
                                  String pathOut )
    {
        int gamePtr = XwJNI.initJNI();
        CurGameInfo gi = new CurGameInfo( context );
        CommsAddrRec addr = null;

        loadMakeGame( context, gamePtr, gi, pathIn );
        byte[] dictBytes = GameUtils.openDict( context, gi.dictName );
        
        if ( XwJNI.game_hasComms( gamePtr ) ) {
            addr = new CommsAddrRec( context );
            XwJNI.comms_getAddr( gamePtr, addr );
        }
        XwJNI.game_dispose( gamePtr );

        gi.setInProgress( false );
        gi.fixup();

        gamePtr = XwJNI.initJNI();
        XwJNI.game_makeNewGame( gamePtr, gi, JNIUtilsImpl.get(), 
                                CommonPrefs.get( context ), dictBytes, 
                                gi.dictName );
        if ( null != addr ) {
            XwJNI.comms_setAddr( gamePtr, addr );
        }
        saveGame( context, gamePtr, gi, pathOut );

        GameSummary summary = new GameSummary();
        XwJNI.game_summarize( gamePtr, gi.nPlayers, summary );
        DBUtils.saveSummary( pathOut, summary );

        XwJNI.game_dispose( gamePtr );
    } // resetGame

    public static String[] gamesList( Context context )
    {
        ArrayList<String> al = new ArrayList<String>();
        for ( String file : context.fileList() ) {
            if ( isGame( file ) ){
                al.add( file );
            }
        }
        return al.toArray( new String[al.size()] );
    }

    public static String resetGame( Context context, String pathIn )
    {
        String newName = newName( context );
        resetGame( context, pathIn, newName );
        return newName;
    }

    public static void deleteGame( Context context, String path )
    {
        // does this need to be synchronized?
        context.deleteFile( path );
        DBUtils.saveSummary( path, null );
    }

    public static void loadMakeGame( Context context, int gamePtr, 
                                     CurGameInfo gi, String path )
    {
        byte[] stream = savedGame( context, path );
        XwJNI.gi_from_stream( gi, stream );
        byte[] dictBytes = GameUtils.openDict( context, gi.dictName );

        boolean madeGame = XwJNI.game_makeFromStream( gamePtr, stream, 
                                                      JNIUtilsImpl.get(), gi, 
                                                      dictBytes, gi.dictName,
                                                      CommonPrefs.get(context));
        if ( !madeGame ) {
            XwJNI.game_makeNewGame( gamePtr, gi, JNIUtilsImpl.get(), 
                                    CommonPrefs.get(context), dictBytes, 
                                    gi.dictName );
        }
    }

    public static void saveGame( Context context, int gamePtr, 
                                 CurGameInfo gi, String path )
    {
        byte[] stream = XwJNI.game_saveToStream( gamePtr, gi );
        saveGame( context, stream, path );
    }

    public static void saveGame( Context context, int gamePtr, 
                                 CurGameInfo gi )
    {
        saveGame( context, gamePtr, gi, newName( context ) );
    }

    public static void saveGame( Context context, byte[] bytes, String path )
    {
        try {
            synchronized( s_syncObj ) {
                FileOutputStream out =
                    context.openFileOutput( path, Context.MODE_PRIVATE );
                out.write( bytes );
                out.close();
            }
        } catch ( java.io.IOException ex ) {
            Utils.logf( ""got IOException: "" + ex.toString() );
        }
    }

    public static String saveGame( Context context, byte[] bytes )
    {
        String name = newName( context );
        saveGame( context, bytes, name );
        return name;
    }

    public static boolean gameDictHere( Context context, String path, 
                                        String[] missingName )
    {
        byte[] stream = savedGame( context, path );
        CurGameInfo gi = new CurGameInfo( context );
        XwJNI.gi_from_stream( gi, stream );
        String dictName = removeExtn( gi.dictName );
        missingName[0] = dictName;

        boolean exists = false;
        for ( String name : dictList( context ) ) {
            if ( name.equals( dictName ) ){
                exists = true;
                break;
            }
        }
        return exists;
    }

    public static boolean gameDictHere( Context context, int indx, 
                                        String[] name )
    {
        String path = GameUtils.gamesList( context )[indx];
        return gameDictHere( context, path, name );
    }

    public static String newName( Context context ) 
    {
        String name = null;
        Integer num = 1;
        int ii;
        String[] files = context.fileList();
        String fmt = context.getString( R.string.gamef );

        while ( name == null ) {
            name = String.format( fmt + XWConstants.GAME_EXTN, num );
            for ( ii = 0; ii < files.length; ++ii ) {
                if ( files[ii].equals(name) ) {
                    ++num;
                    name = null;
                }
            }
        }
        return name;
    }

    public static String[] dictList( Context context )
    {
        ArrayList<String> al = new ArrayList<String>();

        for ( String file : getAssets( context ) ) {
            if ( isDict( file ) ) {
                al.add( removeExtn( file ) );
            }
        }

        for ( String file : context.fileList() ) {
            if ( isDict( file ) ) {
                al.add( removeExtn( file ) );
            }
        }

        return al.toArray( new String[al.size()] );
    }

    public static boolean dictIsBuiltin( Context context, String name )
    {
        boolean builtin = false;
        name = addDictExtn( name );

        for ( String file : getAssets( context ) ) {
            if ( file.equals( name ) ) {
                builtin = true;
                break;
            }
        }

        return builtin;
    }

    public static void deleteDict( Context context, String name )
    {
        context.deleteFile( addDictExtn( name ) );
    }

    public static byte[] openDict( Context context, String name )
    {
        byte[] bytes = null;
        InputStream dict = null;

        name = addDictExtn( name );

        AssetManager am = context.getAssets();
        try {
            dict = am.open( name, 
                            android.content.res.AssetManager.ACCESS_RANDOM );

            int len = dict.available();
            bytes = new byte[len];
            int nRead = dict.read( bytes, 0, len );
            if ( nRead != len ) {
                Utils.logf( ""**** warning ****; read only "" + nRead + "" of "" 
                            + len + "" bytes."" );
            }
        } catch ( java.io.IOException ee ){
            Utils.logf( ""%s failed to open; likely not built-in"", name );
        }

        // not an asset?  Try storage
        if ( null == bytes ) {
            try {
                FileInputStream fis = context.openFileInput( name );
                int len = fis.available();
                bytes = new byte[len];
                fis.read( bytes, 0, len );
                fis.close();
            } catch ( java.io.FileNotFoundException fnf ) {
                Utils.logf( fnf.toString() );
            } catch ( java.io.IOException ioe ) {
                Utils.logf( ioe.toString() );
            }
        }
        
        return bytes;
    }

    public static void saveDict( Context context, String name, InputStream in )
    {
        int totalRead = 0;
        try {
            FileOutputStream fos = context.openFileOutput( name,
                                                           Context.MODE_PRIVATE );
            byte[] buf = new byte[1024];
            int nRead;
            while( 0 <= (nRead = in.read( buf, 0, buf.length )) ) {
                fos.write( buf, 0, nRead );
                totalRead += nRead;
            }
            fos.close();
        } catch ( java.io.FileNotFoundException fnf ) {
            Utils.logf( ""saveDict: FileNotFoundException: %s"", fnf.toString() );
        } catch ( java.io.IOException ioe ) {
            Utils.logf( ""saveDict: IOException: %s"", ioe.toString() );
        }
    } 

    private static boolean isGame( String file )
    {
        return file.endsWith( XWConstants.GAME_EXTN );
    }

    private static boolean isDict( String file )
    {
        return file.endsWith( XWConstants.DICT_EXTN );
    }

    public static String gameName( Context context, String path )
    {
        return path.substring( 0, path.lastIndexOf( XWConstants.GAME_EXTN ) );
    }

    private static String removeExtn( String str )
    {
        if ( str.endsWith( XWConstants.DICT_EXTN ) ) {
            int indx = str.lastIndexOf( XWConstants.DICT_EXTN );
            str = str.substring( 0, indx );
        }
        return str;
    }

    private static String addDictExtn( String str ) 
    {
        if ( ! str.endsWith( XWConstants.DICT_EXTN ) ) {
            str += XWConstants.DICT_EXTN;
        }
        return str;
    }

    private static String[] getAssets( Context context )
    {
        try {
            AssetManager am = context.getAssets();
            return am.list("""");
        } catch( java.io.IOException ioe ) {
            Utils.logf( ioe.toString() );
            return new String[0];
        }
    }
}
",True,2,29,2,8,3,9,10,9,L0
3,org.eehouse.android.xw4.CommsTransport.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.UnresolvedAddressException;
import java.nio.ByteBuffer;
import java.net.InetSocketAddress;
import java.util.Vector;
import java.util.Iterator;
import junit.framework.Assert;
import android.telephony.SmsManager;
import android.content.Intent;
import android.app.PendingIntent;
import android.content.Context;
import android.os.Handler;
import android.os.Message;

import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.JNIThread.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class CommsTransport extends Thread implements TransportProcs {

    public static final int DIALOG = 0;
    public static final int DIALOG_RETRY = 1;
    public static final int TOAST = 2;

    private Selector m_selector;
    private SocketChannel m_socketChannel;
    private int m_jniGamePtr;
    private boolean m_running = false;
    private CommsAddrRec m_addr;
    private JNIThread m_jniThread;
    private Handler m_handler;
    private boolean m_done = false;

    private Vector<ByteBuffer> m_buffersOut;
    private ByteBuffer m_bytesOut;
    private ByteBuffer m_bytesIn;

    private Context m_context;

    // assembling inbound packet
    private byte[] m_packetIn;
    private int m_haveLen = -1;

    public CommsTransport( int jniGamePtr, Context context, Handler handler,
                           DeviceRole role )
    {
        m_jniGamePtr = jniGamePtr;
        m_context = context;
        m_handler = handler;
        m_buffersOut = new Vector<ByteBuffer>();
        m_bytesIn = ByteBuffer.allocate( 2048 );
    }
    
    public void setReceiver( JNIThread jnit )
    {
        m_jniThread = jnit;
    }

    public void waitToStop()
    {
        m_done = true;
        if ( null != m_selector ) {
            m_selector.wakeup();
        }
        if ( m_running ) {      // synchronized this?  Or use Thread method
            try {
                join(100);          // wait up to 1/10 second
            } catch ( java.lang.InterruptedException ie ) {
                Utils.logf( ""got InterruptedException: "" + ie.toString() );
            }
        }
    }

    @Override
    public void run() 
    {
        try {
            m_selector = Selector.open();

            loop();

            closeSocket();
        } catch ( java.io.IOException ioe ) {
            Utils.logf( ioe.toString() );
        } catch ( UnresolvedAddressException uae ) {
            Utils.logf( ""bad address: name: %s; port: %s; exception: %s"",
                        m_addr.ip_relay_hostName, m_addr.ip_relay_port, 
                        uae.toString() );
        }
    }

    private void loop()
    {
        while ( !m_done ) {
            try {
                synchronized( this ) {

                    // if we have data and no socket, try to connect.
                    if ( null == m_socketChannel
                         && 0 < m_buffersOut.size() ) {
                        try {
                            m_socketChannel = SocketChannel.open();
                            m_socketChannel.configureBlocking( false );
                            InetSocketAddress isa
                                = new InetSocketAddress( m_addr.ip_relay_hostName, 
                                                         m_addr.ip_relay_port );
                            m_socketChannel.connect( isa );
                        } catch ( java.io.IOException ioe ) {
                            Utils.logf( ioe.toString() );
                        }
                    }

                    if ( null != m_socketChannel ) {
                        int ops = figureOps();
                        // Utils.logf( ""calling with ops=%x"", ops );
                        m_socketChannel.register( m_selector, ops );
                    }
                }
                m_selector.select();
            } catch ( ClosedChannelException cce ) {
                // we get this when relay goes down.  Need to notify!
                m_jniThread.handle( JNICmd.CMD_TRANSFAIL );
                closeSocket();
                Utils.logf( ""exiting: "" + cce.toString() );
            } catch ( java.io.IOException ioe ) {
                closeSocket();
                Utils.logf( ""exiting: "" + ioe.toString() );
                Utils.logf( ioe.toString() );
            }

            Iterator<SelectionKey> iter = m_selector.selectedKeys().iterator();
            while ( iter.hasNext() ) {
                SelectionKey key = (SelectionKey)iter.next();
                SocketChannel channel = (SocketChannel)key.channel();
                iter.remove();
                try { 
                    if (key.isValid() && key.isConnectable()) {
                        if ( !channel.finishConnect() ) {
                            key.cancel(); 
                        }
                    }
                    if (key.isValid() && key.isReadable()) {
                        m_bytesIn.clear(); // will wipe any pending data!
                        // Utils.logf( ""socket is readable; buffer has space for ""
                        //             + m_bytesIn.remaining() );
                        int nRead = channel.read( m_bytesIn );
                        if ( nRead == -1 ) {
                            channel.close();
                        } else {
                            addIncoming();
                        }
                    }
                    if (key.isValid() && key.isWritable()) {
                        getOut();
                        if ( null != m_bytesOut ) {
                            int nWritten = channel.write( m_bytesOut );
                            //Utils.logf( ""wrote "" + nWritten + "" bytes"" );
                        }
                    }
                } catch ( java.io.IOException ioe ) {
                    key.cancel(); 
                }
            }
        }
    } // loop

    private synchronized void putOut( final byte[] buf )
    {
        int len = buf.length;
        ByteBuffer netbuf = ByteBuffer.allocate( len + 2 );
        netbuf.putShort( (short)len );
        netbuf.put( buf );
        m_buffersOut.add( netbuf );
        Assert.assertEquals( netbuf.remaining(), 0 );

        if ( null != m_selector ) {
            m_selector.wakeup();    // tell it it's got some writing to do
        }
    }

    private synchronized void closeSocket()
    {
        if ( null != m_socketChannel ) {
            try {
                m_socketChannel.close();
            } catch ( Exception e ) {
                Utils.logf( ""closing socket: %s"", e.toString() );
            }
            m_socketChannel = null;
        }
    }

    private synchronized void getOut()
    {
        if ( null != m_bytesOut && m_bytesOut.remaining() == 0 ) {
            m_bytesOut = null;
        }

        if ( null == m_bytesOut && m_buffersOut.size() > 0 ) {
            m_bytesOut = m_buffersOut.remove(0);
            m_bytesOut.flip();
        }
    }

    private synchronized int figureOps() {
        int ops;
        if ( null == m_socketChannel ) {
            ops = 0;
        } else if ( m_socketChannel.isConnected() ) {
            ops = SelectionKey.OP_READ;
            if ( (null != m_bytesOut && m_bytesOut.hasRemaining())
                 || m_buffersOut.size() > 0 ) {
                ops |= SelectionKey.OP_WRITE;
            }
        } else {
            ops = SelectionKey.OP_CONNECT;
        }
        return ops;
    }

    private void addIncoming( )
    {
        m_bytesIn.flip();
        
        for ( ; ; ) {
            int len = m_bytesIn.remaining();
            if ( len <= 0 ) {
                break;
            }

            if ( null == m_packetIn ) { // we're not mid-packet
                Assert.assertTrue( len > 1 ); // tell me if I see this case
                if ( len == 1 ) {       // half a length byte...
                    break;              // can I leave it in the buffer?
                } else {                
                    m_packetIn = new byte[m_bytesIn.getShort()];
                    m_haveLen = 0;
                }
            } else {                    // we're mid-packet
                int wantLen = m_packetIn.length - m_haveLen;
                if ( wantLen > len ) {
                    wantLen = len;
                }
                m_bytesIn.get( m_packetIn, m_haveLen, wantLen );
                m_haveLen += wantLen;
                if ( m_haveLen == m_packetIn.length ) {
                    // send completed packet
                    m_jniThread.handle( JNICmd.CMD_RECEIVE, m_packetIn );
                    m_packetIn = null;
                }
            }
        }
    }

    // TransportProcs interface
    public int transportSend( byte[] buf, final CommsAddrRec faddr )
    {
        int nSent = -1;

        if ( null == m_addr ) {
            if ( null == faddr ) {
                m_addr = new CommsAddrRec( m_context );
                XwJNI.comms_getAddr( m_jniGamePtr, m_addr );
            } else {
                m_addr = new CommsAddrRec( faddr );
            }
        }

        switch ( m_addr.conType ) {
        case COMMS_CONN_RELAY:
            putOut( buf );      // add to queue
            if ( !m_running ) {
                m_running = true;
                start();
            }
            nSent = buf.length;
            break;
        case COMMS_CONN_SMS:
            Assert.fail();
            // This code can't be here, even if unreachable, unless
            // app has permission to use SMS.  So put it in a separate
            // module and catch the error that'll come when it fails
            // to verify.  IFF the plan's to ship a version that
            // doesn't do SMS.

            // Utils.logf( ""sending via sms to  %s:%d"", 
            //             m_addr.sms_phone, m_addr.sms_port );
            // try {
            //     Intent intent = new Intent( m_context, StatusReceiver.class);
            //     PendingIntent pi
            //         = PendingIntent.getBroadcast( m_context, 0,
            //                                       intent, 0 );
            //     if ( 0 == m_addr.sms_port ) {
            //          SmsManager.getDefault().sendTextMessage( m_addr.sms_phone,
            //                                                   null, ""Hello world"",
            //                                                   pi, pi );
            //         Utils.logf( ""called sendTextMessage"" );
            //     } else {
            //         SmsManager.getDefault().
            //             sendDataMessage( m_addr.sms_phone, (String)null,
            //                              (short)m_addr.sms_port, 
            //                              buf, pi, pi );
            //         Utils.logf( ""called sendDataMessage"" );
            //     }
            //     nSent = buf.length;
            // } catch ( java.lang.IllegalArgumentException iae ) {
            //     Utils.logf( iae.toString() );
            // }
            break;
        case COMMS_CONN_BT:
            break;
        }

        return nSent;
    } 

    public void relayStatus( CommsRelayState newState )
    {
        //Utils.logf( ""relayStatus called; state=%s"", newState.toString() );
        if ( null != m_jniThread ) {
            m_jniThread.handle( JNICmd.CMD_DRAW_CONNS_STATUS, newState );
        } else {
            Utils.logf( ""can't draw status yet"" );
        }
    }

    public void relayConnd( boolean allHere, int nMissing )
    {
        String message = null;
        if ( allHere ) {
            message = m_context.getString( R.string.msg_relay_all_here );
        } else if ( nMissing > 0 ) {
            String fmt = m_context.getString( R.string.msg_relay_waiting );
            message = String.format( fmt, nMissing );
        }
        if ( null != message ) {
            Message.obtain( m_handler, TOAST, message ).sendToTarget();
        }
    }

    public void relayErrorProc( XWRELAY_ERROR relayErr )
    {
        //Utils.logf( ""relayErrorProc called; got "" + relayErr.toString() );

        int strID = 0;
        int how = TOAST;

        switch ( relayErr ) {
        case TOO_MANY: 
            strID = R.string.msg_too_many;
            how = DIALOG;
            break;
        case NO_ROOM:
            strID = R.string.msg_no_room;
            how = DIALOG_RETRY;
            break;
        case DUP_ROOM:
            strID = R.string.msg_dup_room;
            how = DIALOG;
            break;
        case LOST_OTHER:
        case OTHER_DISCON:
            strID = R.string.msg_lost_other;
            break;

        case OLDFLAGS:
        case BADPROTO:
        case RELAYBUSY:
        case SHUTDOWN:
        case TIMEOUT:
        case HEART_YOU:
        case HEART_OTHER:
            break;
        }

        if ( 0 != strID ) {
            String str = m_context.getString( strID );
            Message.obtain( m_handler, how, R.string.relay_alert, 
                            0, str ).sendToTarget();
        }
    }
}
",True,17,24,1,1,4,11,1,5,L1
4,org.eehouse.android.xw4.DBUtils.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.Cursor;
import java.util.StringTokenizer;
import android.content.ContentValues;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;


public class DBUtils {

    private static SQLiteOpenHelper s_dbHelper = null;

    public static GameSummary getSummary( Context context, String file )
    {
        initDB( context );
        GameSummary summary = new GameSummary();

        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String[] columns = { DBHelper.NUM_MOVES, DBHelper.GAME_OVER,
                                 DBHelper.CONTYPE, DBHelper.ROOMNAME,
                                 DBHelper.SMSPHONE, DBHelper.SCORES
            };
            String selection = DBHelper.FILE_NAME + ""=\"""" + file + ""\"""";

            Cursor cursor = db.query( DBHelper.TABLE_NAME, columns, selection, 
                                      null, null, null, null );
            if ( 1 == cursor.getCount() && cursor.moveToFirst() ) {
                summary = new GameSummary();
                summary.nMoves = cursor.getInt(cursor.
                                               getColumnIndex(DBHelper.NUM_MOVES));
                int tmp = cursor.getInt(cursor.
                                        getColumnIndex(DBHelper.GAME_OVER));
                summary.gameOver = tmp == 0 ? false : true;

                String scoresStr = 
                    cursor.getString( cursor.getColumnIndex(DBHelper.SCORES));
                if ( null != scoresStr ) {
                    StringTokenizer st = new StringTokenizer( scoresStr );
                    int[] scores = new int[st.countTokens()];
                    for ( int ii = 0; ii < scores.length; ++ii ) {
                        Assert.assertTrue( st.hasMoreTokens() );
                        String token = st.nextToken();
                        scores[ii] = Integer.parseInt( token );
                    }
                    summary.scores = scores;
                }

                int col = cursor.getColumnIndex( DBHelper.CONTYPE );
                if ( col >= 0 ) {
                    tmp = cursor.getInt( col );
                    summary.conType = CommsAddrRec.CommsConnType.values()[tmp];
                    col = cursor.getColumnIndex( DBHelper.ROOMNAME );
                    if ( col >= 0 ) {
                        summary.roomName = cursor.getString( col );
                    }
                    col = cursor.getColumnIndex( DBHelper.SMSPHONE );
                    if ( col >= 0 ) {
                        summary.smsPhone = cursor.getString( col );
                    }
                }
            }
            cursor.close();
            db.close();
        }
        return summary;
    }

    public static void saveSummary( String path, GameSummary summary )
    {
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();

            if ( null == summary ) {
                String selection = DBHelper.FILE_NAME + ""=\"""" + path + ""\"""";
                db.delete( DBHelper.TABLE_NAME, selection, null );
            } else {
                ContentValues values = new ContentValues();
                values.put( DBHelper.FILE_NAME, path );
                values.put( DBHelper.NUM_MOVES, summary.nMoves );
                values.put( DBHelper.GAME_OVER, summary.gameOver );

                if ( null != summary.scores ) {
                    StringBuffer sb = new StringBuffer();
                    for ( int score : summary.scores ) {
                        sb.append( String.format( ""%d "", score ) );
                    }
                    values.put( DBHelper.SCORES, sb.toString() );
                }

                if ( null != summary.conType ) {
                    values.put( DBHelper.CONTYPE, summary.conType.ordinal() );
                    values.put( DBHelper.ROOMNAME, summary.roomName );
                    values.put( DBHelper.SMSPHONE, summary.smsPhone );
                }

                Utils.logf( ""saveSummary: nMoves=%d"", summary.nMoves );

                try {
                    long result = db.replaceOrThrow( DBHelper.TABLE_NAME, """", 
                                                     values );
                } catch ( Exception ex ) {
                    Utils.logf( ""ex: %s"", ex.toString() );
                }
            }
            db.close();
        }
    }

    private static void initDB( Context context )
    {
        if ( null == s_dbHelper ) {
            s_dbHelper = new DBHelper( context );
        }
    }

}
",True,24,26,2,4,6,4,5,4,L0
5,org.eehouse.android.xw4.BoardDims.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;


// Why does this have to be its own class...
public class BoardDims {
    public int width, height;       // of the bitmap
    public int left, top;
    public int scoreHt;
    public int boardHt;
    public int trayTop, trayHt;
    public int cellSize, maxCellSize;
    public int timerWidth;
}
",False,11,6,2,3,0,0,2,0,L1
6,org.eehouse.android.xw4.Utils.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.util.Log;
import java.lang.Thread;
import android.widget.Toast;
import android.content.Context;
import android.content.Intent;
import android.content.DialogInterface;
import android.widget.CheckBox;
import android.app.Activity;
import android.app.Dialog;
import android.app.AlertDialog;
import android.widget.EditText;
import android.widget.TextView;
import android.view.View;
import android.text.format.Time;
import java.util.Formatter;
import android.view.LayoutInflater;
import android.net.Uri;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;

public class Utils {
    static final String TAG = ""XW4"";

    static final int DIALOG_ABOUT = 1;
    static final int DIALOG_LAST = DIALOG_ABOUT;
    static final String DB_PATH = ""XW_GAMES"";

    private static Time s_time = new Time();

    private Utils() {}

    public static void logf( String msg ) 
    {
        s_time.setToNow();
        String time = s_time.format(""[%H:%M:%S]"");
        long id = Thread.currentThread().getId();
        Log.d( TAG, time + ""-"" + id + ""-"" + msg );
    } // logf

    public static void logf( String format, Object... args )
    {
        Formatter formatter = new Formatter();
        logf( formatter.format( format, args ).toString() );
    } // logf

    public static void notImpl( Context context ) 
    {
        CharSequence text = ""Feature coming soon"";
        Toast.makeText( context, text, Toast.LENGTH_SHORT).show();
    }

    static Dialog onCreateDialog( final Context context, int id )
    {
        Assert.assertTrue( DIALOG_ABOUT == id );
        LayoutInflater factory = LayoutInflater.from( context );
        final View view = factory.inflate( R.layout.about_dlg, null );
        TextView vers = (TextView)view.findViewById( R.id.version_string );
        vers.setText( String.format( context.getString(R.string.about_versf), 
                                     XWConstants.VERSION_STR, 
                                     GitVersion.VERS ) );

        TextView xlator = (TextView)view.findViewById( R.id.about_xlator );
        String str = context.getString( R.string.xlator );
        if ( str.length() > 0 ) {
            xlator.setText( str );
        } else {
            xlator.setVisibility( View.GONE );
        }

        return new AlertDialog.Builder( context )
            .setIcon( R.drawable.icon48x48 )
            .setTitle( R.string.app_name )
            .setView( view )
            .setPositiveButton( R.string.changes_button,
                                new DialogInterface.OnClickListener() {
                                    @Override
                                    public void onClick( DialogInterface dlg, 
                                                         int which )
                                    {
                                        FirstRunDialog.show( context, true );
                                    }
                                } )
            .create();
    }

    public static Intent mkDownloadActivity( Context context )
    {
        String dict_url = CommonPrefs.getDefaultDictURL( context );
        Uri uri = Uri.parse( dict_url );
        Intent intent = new Intent( Intent.ACTION_VIEW, uri );
        intent.setFlags( Intent.FLAG_ACTIVITY_NEW_TASK );
        return intent;
    }

    public static void setChecked( Activity activity, int id, boolean value )
    {
        CheckBox cbx = (CheckBox)activity.findViewById( id );
        cbx.setChecked( value );
    }

    public static void setChecked( Dialog dialog, int id, boolean value )
    {
        CheckBox cbx = (CheckBox)dialog.findViewById( id );
        cbx.setChecked( value );
    }

    public static void setText( Dialog dialog, int id, String value )
    {
        EditText editText = (EditText)dialog.findViewById( id );
        if ( null != editText ) {
            editText.setText( value, TextView.BufferType.EDITABLE   );
        }
    }

    public static void setText( Activity activity, int id, String value )
    {
        EditText editText = (EditText)activity.findViewById( id );
        if ( null != editText ) {
            editText.setText( value, TextView.BufferType.EDITABLE   );
        }
    }

    public static void setInt( Dialog dialog, int id, int value )
    {
        String str = Integer.toString(value);
        setText( dialog, id, str );
    }

    public static void setInt( Activity activity, int id, int value )
    {
        String str = Integer.toString(value);
        setText( activity, id, str );
    }

    public static boolean getChecked( Activity activity, int id )
    {
        CheckBox cbx = (CheckBox)activity.findViewById( id );
        return cbx.isChecked();
    }

    public static boolean getChecked( Dialog dialog, int id )
    {
        CheckBox cbx = (CheckBox)dialog.findViewById( id );
        return cbx.isChecked();
    }

    public static String getText( Dialog dialog, int id )
    {
        EditText editText = (EditText)dialog.findViewById( id );
        return editText.getText().toString();
    }

    public static String getText( Activity activity, int id )
    {
        EditText editText = (EditText)activity.findViewById( id );
        return editText.getText().toString();
    }

    public static int getInt( Dialog dialog, int id )
    {
        String str = getText( dialog, id );
        try {
            return Integer.parseInt( str );
        } catch ( NumberFormatException nfe ) {
            return 0;
        }
    }

    public static int getInt( Activity activity, int id )
    {
        String str = getText( activity, id );
        try {
            return Integer.parseInt( str );
        } catch ( NumberFormatException nfe ) {
            return 0;
        }
    }
}
",True,26,30,2,11,5,6,19,3,L0
7,org.eehouse.android.xw4.DictListPreference.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.preference.ListPreference;
import android.content.Context;
import android.util.AttributeSet;

import junit.framework.Assert;

public class DictListPreference extends ListPreference {

    public DictListPreference( Context context, AttributeSet attrs )
    {
        super( context, attrs );

        String[] dicts = GameUtils.dictList( context  );
        setEntries( dicts );
        setEntryValues( dicts );
    }
}
",False,30,19,0,0,4,9,0,1,L1
8,org.eehouse.android.xw4.XWListAdapter.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.ListActivity;
import android.widget.ListAdapter;
import android.content.Context;
import android.database.DataSetObserver;

/**
 * Let's see if we can implement a few of these methods just once.
 */
public abstract class XWListAdapter implements ListAdapter {
    private int m_count;

    public XWListAdapter( Context context, int count ) {
        m_count = count;
    }

    public boolean areAllItemsEnabled() { return true; }
    public boolean isEnabled( int position ) { return true; }
    public int getCount() { return m_count; }
    public long getItemId(int position) { return position; }
    public int getItemViewType(int position) { return 0; }
    public int getViewTypeCount() { return 1; }
    public boolean hasStableIds() { return true; }
    public boolean isEmpty() { return getCount() == 0; }
    public void registerDataSetObserver(DataSetObserver observer) {}
    public void unregisterDataSetObserver(DataSetObserver observer) {}
}",False,9,5,2,3,0,0,3,0,L0
9,org.eehouse.android.xw4.DictsActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.ListActivity;
import android.os.Bundle;
import android.widget.Button;
import android.widget.TextView;
import android.widget.AdapterView;
import android.content.Context;
import android.view.View;
import android.view.ViewGroup;
import android.view.ContextMenu;
import android.view.MenuItem;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.LayoutInflater;
import android.view.MenuInflater;
import android.preference.PreferenceManager;
import android.content.SharedPreferences;

import junit.framework.Assert;

public class DictsActivity extends ListActivity 
    implements View.OnClickListener,
               XWListItem.DeleteCallback {
    String[] m_dicts;

    private class DictListAdapter extends XWListAdapter {
        Context m_context;

        public DictListAdapter( Context context ) {
            super( context, m_dicts.length );
            m_context = context;
        }

        public Object getItem( int position) { return m_dicts[position]; }
        public View getView( final int position, View convertView, 
                             ViewGroup parent ) {
            LayoutInflater factory = LayoutInflater.from( DictsActivity.this );
            final XWListItem view
                = (XWListItem)factory.inflate( R.layout.list_item, null );
            view.setPosition( position );
            view.setText( m_dicts[position] );

            if ( !GameUtils.dictIsBuiltin( DictsActivity.this,
                                           m_dicts[position] ) ) {
                view.setDeleteCallback( DictsActivity.this );
            }

            return view;
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate( savedInstanceState );

        setContentView( R.layout.dict_browse );
        registerForContextMenu( getListView() );

        Button download = (Button)findViewById( R.id.download );
        download.setOnClickListener( this );

        mkListAdapter();
    }

    @Override
    protected void onResume()
    {
        super.onResume();
        mkListAdapter();
    }

    public void onClick( View v ) {
        startActivity( Utils.mkDownloadActivity( this ) );
    }

    @Override
    public void onCreateContextMenu( ContextMenu menu, View view, 
                                     ContextMenuInfo menuInfo ) 
    {
        super.onCreateContextMenu( menu, view, menuInfo );

        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.dicts_item_menu, menu );

        AdapterView.AdapterContextMenuInfo info
            = (AdapterView.AdapterContextMenuInfo)menuInfo;
    }
   
    @Override
    public boolean onContextItemSelected( MenuItem item ) 
    {
        boolean handled = false;
        AdapterView.AdapterContextMenuInfo info;
        try {
            info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
        } catch (ClassCastException e) {
            Utils.logf( ""bad menuInfo:"" + e.toString() );
            return false;
        }
        
        int id = item.getItemId();
        switch( id ) {
        case R.id.dicts_item_select:
            SharedPreferences sp
                = PreferenceManager.getDefaultSharedPreferences( this );
            SharedPreferences.Editor editor = sp.edit();
            String key = getString( R.string.key_default_dict );
            editor.putString( key, m_dicts[info.position] );
            editor.commit();
            break;
        case R.id.dicts_item_details:
            Utils.notImpl( this );
            break;
        }

        return handled;
    }

    // DeleteCallback interface
    public void deleteCalled( int myPosition )
    {
        GameUtils.deleteDict( this, m_dicts[myPosition] );
        mkListAdapter();
    }

    private void mkListAdapter()
    {
        m_dicts = GameUtils.dictList( this );
        setListAdapter( new DictListAdapter( this ) );
    }

}",False,33,21,0,0,4,9,0,4,L1
10,org.eehouse.android.xw4.ReceiveNBS.java,"/* -*- compile-command: ""cd ../../../../../; ant reinstall""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.telephony.SmsMessage;

public class ReceiveNBS extends BroadcastReceiver {

    @Override
    public void onReceive( Context context, Intent intent ) 
    {
        Utils.logf( ""onReceive called: "" + intent.toString() );

        Bundle bundle = intent.getExtras();        
        SmsMessage[] smsarr = null;
        if (bundle != null) {
            Object[] pdus = (Object[]) bundle.get(""pdus"");
            smsarr = new SmsMessage[pdus.length];            
            for ( int ii = 0; ii < pdus.length; ii++){
                smsarr[ii] = SmsMessage.createFromPdu((byte[])pdus[ii]);
                Utils.logf( ""from "" + smsarr[ii].getOriginatingAddress() );
                // buf.append( smsarr[ii].getMessageBody() );
                // XwJni.handle( XwJni.JNICmd.CMD_RECEIVE, 
                //               smsarr[ii].getMessageBody() );
            }
        }
    } // onReceive

}
",False,25,19,0,0,6,6,0,1,L1
11,org.eehouse.android.xw4.GameListAdapter.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.eehouse.android.xw4;

import android.widget.ListAdapter;
import android.content.Context;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import android.database.DataSetObserver;
import java.io.FileInputStream;
import java.util.HashMap;
import android.view.LayoutInflater;
import junit.framework.Assert;


import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class GameListAdapter extends XWListAdapter {
    private Context m_context;
    private LayoutInflater m_factory;
    private int m_layoutId;
    private HashMap<String,View> m_viewsCache;

    public GameListAdapter( Context context ) {
        super( context, GameUtils.gamesList(context).length );
        m_context = context;
        m_factory = LayoutInflater.from( context );

        int sdk_int = 0;
        try {
            sdk_int = Integer.decode( android.os.Build.VERSION.SDK );
        } catch ( Exception ex ) {}

        m_layoutId = sdk_int >= android.os.Build.VERSION_CODES.DONUT
            ? R.layout.game_list_item : R.layout.game_list_item_onefive;

        m_viewsCache = new HashMap<String,View>();
    }
    
    public int getCount() {
        return GameUtils.gamesList(m_context).length;
    }
    
    public Object getItem( int position ) 
    {
        final String path = GameUtils.gamesList(m_context)[position];
        View layout = m_viewsCache.get( path );

        if ( null == layout ) {
            Utils.logf( ""creating new list elem for %s"", path );
            layout = m_factory.inflate( m_layoutId, null );
            byte[] stream = GameUtils.savedGame( m_context, path );
            if ( null != stream ) {
                CurGameInfo gi = new CurGameInfo( m_context );
                XwJNI.gi_from_stream( gi, stream );

                GameSummary summary = DBUtils.getSummary( m_context, path );

                TextView view = (TextView)layout.findViewById( R.id.players );
                String gameName = GameUtils.gameName( m_context, path );
                view.setText( String.format( ""%s: %s"", gameName,
                                             gi.summarizePlayers( m_context, 
                                                                  summary ) ) );

                view = (TextView)layout.findViewById( R.id.state );
                view.setText( gi.summarizeState( m_context, summary ) );
                view = (TextView)layout.findViewById( R.id.dict );
                view.setText( gi.summarizeDict( m_context ) );

                view = (TextView)layout.findViewById( R.id.role );
                String roleSummary = gi.summarizeRole( m_context, summary );
                if ( null != roleSummary ) {
                    view.setText( roleSummary );
                } else {
                    view.setVisibility( View.GONE );
                }
            }
            m_viewsCache.put( path, layout );
        }
        return layout;
    }

    public View getView( int position, View convertView, ViewGroup parent ) {
        return (View)getItem( position );
    }

    public void inval( String key ) 
    {
        m_viewsCache.remove( key );
    }
}",True,10,21,1,1,4,8,1,6,L1
12,org.eehouse.android.xw4.XWListItem.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.widget.LinearLayout;
import android.view.View;
import android.widget.TextView;
import android.widget.ImageButton;
import android.content.Context;
import android.util.AttributeSet;
import android.graphics.Rect;

public class XWListItem extends LinearLayout {
    private int m_position;
    private ImageButton m_button;
    private Context m_context;
    DeleteCallback m_cb;

    public interface DeleteCallback {
        void deleteCalled( int myPosition );
    }

    public XWListItem( Context cx, AttributeSet as ) {
        super( cx, as );
        m_context = cx;
    }

    public int getPosition() { return m_position; }
    public void setPosition( int indx ) { m_position = indx; }

    public void setText( String text )
    {
        TextView view = (TextView)getChildAt( 0 );
        view.setText( text );
    }

    public void setDeleteCallback( DeleteCallback cb ) 
    {
        m_cb = cb;
        ImageButton button = (ImageButton)getChildAt( 1 );
        button.setOnClickListener( new View.OnClickListener() {
                @Override
                    public void onClick( View view ) {
                    m_cb.deleteCalled( m_position );
                }
            } );
        button.setVisibility( View.VISIBLE );
    }
}
",True,20,3,1,2,0,0,2,0,L0
13,org.eehouse.android.xw4.XWConstants.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

public interface XWConstants {
    public static final String GAME_EXTN = "".xwg"";
    public static final String DICT_EXTN = "".xwd"";
    public static final String VERSION_STR = ""4.4 beta 14"";
}
",False,23,26,3,19,0,0,2,0,L0
14,org.eehouse.android.xw4.BoardActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MenuInflater;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Window;
import android.os.Handler;
import android.os.Message;
import android.content.Intent;
import java.util.concurrent.Semaphore;
import android.net.Uri;
import android.app.Dialog;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.widget.ImageButton;
import android.widget.Toast;
import android.widget.EditText;
import android.widget.TextView;
import junit.framework.Assert;
import android.content.res.Configuration;
import android.content.pm.ActivityInfo;

import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.JNIThread.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;


public class BoardActivity extends Activity implements UtilCtxt {

    private static final int DLG_OKONLY = Utils.DIALOG_LAST + 1;
    private static final int DLG_BADWORDS = Utils.DIALOG_LAST + 2;
    private static final int QUERY_REQUEST_BLK = Utils.DIALOG_LAST + 3;
    private static final int QUERY_INFORM_BLK = Utils.DIALOG_LAST + 4;
    private static final int PICK_TILE_REQUEST_BLK = Utils.DIALOG_LAST + 5;
    private static final int QUERY_ENDGAME = Utils.DIALOG_LAST + 6;
    private static final int ASK_PASSWORD_BLK = Utils.DIALOG_LAST + 7;
    private static final int DLG_RETRY = Utils.DIALOG_LAST + 8;

    private BoardView m_view;
    private int m_jniGamePtr;
    private CurGameInfo m_gi;
    CommsTransport m_xport;
    private Handler m_handler;
    private TimerRunnable[] m_timers;
    private String m_path;
    private int m_currentOrient;
    private Toolbar m_toolbar;

    private String m_dlgBytes = null;
    private EditText m_passwdEdit = null;
    private int m_dlgTitle;
    private String m_dlgTitleStr;
    private String[] m_texts;
    private boolean m_firingPrefs;
    private JNIUtils m_jniu;
    private boolean m_volKeysZoom;

    // call startActivityForResult synchronously
	private Semaphore m_forResultWait = new Semaphore(0);
    private int m_resultCode;

    private Thread m_blockingThread;
    private JNIThread m_jniThread;

    private ProgressDialog m_progress;
    private boolean m_isVisible;

    public class TimerRunnable implements Runnable {
        private int m_why;
        private int m_when;
        private int m_handle;
        private TimerRunnable( int why, int when, int handle ) {
            m_why = why;
            m_when = when;
            m_handle = handle;
        }
        public void run() {
            m_timers[m_why] = null;
            if ( null != m_jniThread ) {
                m_jniThread.handle( JNICmd.CMD_TIMER_FIRED,
                                    m_why, m_when, m_handle );
            }
        }
    } 

    @Override
    protected Dialog onCreateDialog( int id )
    {
        Dialog dialog = null;
        DialogInterface.OnClickListener lstnr;
        AlertDialog.Builder ab;

        switch ( id ) {
        case DLG_OKONLY:
        case DLG_BADWORDS:
        case DLG_RETRY:
            ab = new AlertDialog.Builder( BoardActivity.this )
                //.setIcon( R.drawable.alert_dialog_icon )
                .setTitle( m_dlgTitle )
                .setMessage( m_dlgBytes )
                .setPositiveButton( R.string.button_ok, null );
            if ( DLG_RETRY == id ) {
                lstnr = new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dlg, 
                                             int whichButton ) {
                            m_jniThread.handle( JNIThread.JNICmd.CMD_RESET );
                        }
                    };
                ab.setNegativeButton( R.string.button_retry, lstnr );
            }
            dialog = ab.create();
            break;

        case QUERY_REQUEST_BLK:
        case QUERY_INFORM_BLK:
            ab = new AlertDialog.Builder( this )
                .setTitle( m_dlgTitle )
                .setMessage( m_dlgBytes );
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dialog, 
                                         int whichButton ) {
                        m_resultCode = 1;
                    }
                };
            ab.setPositiveButton( R.string.button_yes, lstnr );
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dialog, 
                                         int whichButton ) {
                        m_resultCode = 0;
                    }
                };
            if ( QUERY_INFORM_BLK != id ) {
                ab.setNegativeButton( R.string.button_no, lstnr );
            }

            dialog = ab.create();
            dialog.setOnDismissListener( makeODLforBlocking() );
            break;

        case PICK_TILE_REQUEST_BLK:
            ab = new AlertDialog.Builder( this )
                .setTitle( R.string.title_tile_picker );
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dialog, 
                                         int item ) {
                        m_resultCode = item;
                    }
                };
            ab.setItems( m_texts, lstnr );

            dialog = ab.create();
            dialog.setOnDismissListener( makeODLforBlocking() );
            break;

        case ASK_PASSWORD_BLK:
            ab = new AlertDialog.Builder( this )
                .setTitle( m_dlgTitleStr )
                .setView( m_passwdEdit )
                .setPositiveButton( R.string.button_ok,
                                    new DialogInterface.OnClickListener() {
                                        public void onClick( DialogInterface dlg,
                                                             int whichButton ) {
                                            m_resultCode = 1;
                                        }
                                    });
            dialog = ab.create();
            dialog.setOnDismissListener( makeODLforBlocking() );
            break;

        case QUERY_ENDGAME:
            dialog = new AlertDialog.Builder( this )
                .setTitle( R.string.query_title )
                .setMessage( R.string.ids_endnow )
                .setPositiveButton( R.string.button_yes,
                                    new DialogInterface.OnClickListener() {
                                        public void onClick( DialogInterface dlg, 
                                                             int item ) {
                                            m_jniThread.handle(JNICmd.CMD_ENDGAME);
                                        }
                                    })
                .setNegativeButton( R.string.button_no,
                                    new DialogInterface.OnClickListener() {
                                        public void onClick( DialogInterface dlg, 
                                                             int item ) {
                                            // do nothing
                                        }
                                    })
                .create();
            break;
        default:
            dialog = Utils.onCreateDialog( this, id );
            Assert.assertTrue( null != dialog );
        }
        return dialog;
    } // onCreateDialog

    @Override
    protected void onPrepareDialog( int id, Dialog dialog )
    {
        Utils.logf( ""onPrepareDialog(id="" + id + "")"" );
        switch( id ) {
        case DLG_OKONLY:
            dialog.setTitle( m_dlgTitle );
            // FALLTHRU
        case DLG_BADWORDS:
        case QUERY_REQUEST_BLK:
        case QUERY_INFORM_BLK:
            ((AlertDialog)dialog).setMessage( m_dlgBytes );
            break;
        case ASK_PASSWORD_BLK:
            m_passwdEdit.setText( """", TextView.BufferType.EDITABLE );
            dialog.setTitle( m_dlgTitleStr );
            break;
        }
        super.onPrepareDialog( id, dialog );
    }

    @Override
    protected void onCreate( Bundle savedInstanceState ) 
    {
        Utils.logf( ""BoardActivity::onCreate()"" );
        super.onCreate( savedInstanceState );

        if ( CommonPrefs.getHideTitleBar( this ) ) {
            requestWindowFeature( Window.FEATURE_NO_TITLE );
        }

        m_jniu = JNIUtilsImpl.get();
        setContentView( R.layout.board );
        m_handler = new Handler();
        m_timers = new TimerRunnable[4]; // needs to be in sync with
                                         // XWTimerReason
        m_gi = new CurGameInfo( this );

        m_view = (BoardView)findViewById( R.id.board_view );
        m_volKeysZoom = CommonPrefs.getVolKeysZoom( this );

        Intent intent = getIntent();
        Uri uri = intent.getData();
        m_path = uri.getPath();
        if ( m_path.charAt(0) == '/' ) {
            m_path = m_path.substring( 1 );
        }

    } // onCreate

    @Override
    protected void onStart()
    {
        Utils.logf( ""BoardActivity::onStart"" );
        loadGame();
        super.onStart();
    }

    @Override
    protected void onRestart()
    {
        Utils.logf( ""BoardActivity::onRestart"" );
        super.onRestart();
    }

    @Override
    protected void onPause()
    {
        Utils.logf( ""BoardActivity::onPause()"" );
        if ( null != m_jniThread ) {
            m_jniThread.setInBackground( true );
        }
        m_isVisible = false;
        super.onPause();
    }

    @Override
    protected void onResume()
    {
        Utils.logf( ""BoardActivity::onResume()"" );
        if ( null != m_jniThread ) {
            m_jniThread.setInBackground( false );
        }
        m_isVisible = true;
        super.onResume();
    }

    @Override
    protected void onStop()
    {
        Utils.logf( ""BoardActivity::onStop()"" );
        super.onStop();
    }

    @Override
    protected void onDestroy()
    {
        Utils.logf( ""BoardActivity::onDestroy()"" );
        if ( 0 != m_jniGamePtr ) {
            if ( null != m_xport ) {
                m_xport.waitToStop();
                m_xport = null;
            }

            interruptBlockingThread();

            if ( null != m_jniThread ) {
                // one last command
                m_jniThread.handle( JNIThread.JNICmd.CMD_SAVE );
                m_jniThread.waitToStop();
                m_jniThread = null;
            }

            XwJNI.game_dispose( m_jniGamePtr );
            m_jniGamePtr = 0;
        }
        super.onDestroy();
    }

    @Override
    public void onWindowFocusChanged( boolean hasFocus )
    {
        super.onWindowFocusChanged( hasFocus );
        if ( hasFocus ) {
            if ( m_firingPrefs ) {
                m_firingPrefs = false;
                m_volKeysZoom = CommonPrefs.getVolKeysZoom( this );
                if ( null != m_jniThread ) {
                    m_jniThread.handle( JNIThread.JNICmd.CMD_PREFS_CHANGE );
                }
            }
        }
    }

    @Override
    public void onConfigurationChanged( Configuration newConfig )
    {
        m_currentOrient = newConfig.orientation;
        if ( null != m_toolbar ) {
            boolean landscape = 
                m_currentOrient == Configuration.ORIENTATION_LANDSCAPE;
            m_toolbar.orientChanged( landscape );
        }
        super.onConfigurationChanged( newConfig );
    }

    @Override
    public boolean onKeyDown( int keyCode, KeyEvent event )
    {
        boolean handled = false;
        if ( null != m_jniThread ) {
            XwJNI.XP_Key xpKey = keyCodeToXPKey( keyCode );
            if ( XwJNI.XP_Key.XP_KEY_NONE != xpKey ) {
                m_jniThread.handle( JNIThread.JNICmd.CMD_KEYDOWN, xpKey );
            } else {
                switch( keyCode ) {
                case KeyEvent.KEYCODE_VOLUME_DOWN:
                case KeyEvent.KEYCODE_VOLUME_UP:
                    if ( m_volKeysZoom ) {
                        int zoomBy = KeyEvent.KEYCODE_VOLUME_DOWN == keyCode
                            ? -2 : 2;
                        handled = doZoom( zoomBy );
                    }
                    break;
                }
            }
        }
        return handled || super.onKeyDown( keyCode, event );
    }

    @Override
    public boolean onKeyUp( int keyCode, KeyEvent event )
    {
        if ( null != m_jniThread ) {
            XwJNI.XP_Key xpKey = keyCodeToXPKey( keyCode );
            if ( XwJNI.XP_Key.XP_KEY_NONE != xpKey ) {
                m_jniThread.handle( JNIThread.JNICmd.CMD_KEYUP, xpKey );
            }
        }
        return super.onKeyUp( keyCode, event );
    }

    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.board_menu, menu );
        return true;
    }

    public boolean onOptionsItemSelected( MenuItem item ) 
    {
        boolean handled = true;
        JNIThread.JNICmd cmd = JNIThread.JNICmd.CMD_NONE;

        int id = item.getItemId();
        switch ( id ) {
        case R.id.board_menu_done:
            cmd = JNIThread.JNICmd.CMD_COMMIT;
            break;
        // case R.id.board_menu_juggle:
        //     cmd = JNIThread.JNICmd.CMD_JUGGLE;
        //     break;
        // case R.id.board_menu_flip:
        //     cmd = JNIThread.JNICmd.CMD_FLIP;
        //     break;
        case R.id.board_menu_trade:
            cmd = JNIThread.JNICmd.CMD_TOGGLE_TRADE;
            break;
        case R.id.board_menu_tray:
            cmd = JNIThread.JNICmd.CMD_TOGGLE_TRAY;
            break;
        // case R.id.board_menu_undo_current:
        //     cmd = JNIThread.JNICmd.CMD_UNDO_CUR;
        //     break;
        case R.id.board_menu_undo_last:
            cmd = JNIThread.JNICmd.CMD_UNDO_LAST;
            break;
        case R.id.board_menu_hint:
            cmd = JNIThread.JNICmd.CMD_HINT;
            break;
        case R.id.board_menu_hint_next:
            cmd = JNIThread.JNICmd.CMD_NEXT_HINT;
            break;
        case R.id.board_menu_values:
            cmd = JNIThread.JNICmd.CMD_VALUES;
            break;

        case R.id.board_menu_game_counts:
            m_jniThread.handle( JNIThread.JNICmd.CMD_COUNTS_VALUES,
                                R.string.counts_values_title );
            break;
        case R.id.board_menu_game_left:
            m_jniThread.handle( JNIThread.JNICmd.CMD_REMAINING,
                                R.string.tiles_left_title );
            break;
        case R.id.board_menu_game_history:
            m_jniThread.handle( JNIThread.JNICmd.CMD_HISTORY,
                                R.string.history_title );
            break;

        case R.id.board_menu_game_final:
            m_jniThread.handle( JNIThread.JNICmd.CMD_FINAL,
                                R.string.history_title );
            break;

        case R.id.board_menu_game_resend:
            m_jniThread.handle( JNIThread.JNICmd.CMD_RESEND );
            break;
        case R.id.board_menu_file_prefs:
            m_firingPrefs = true;
            startActivity( new Intent( this, PrefsActivity.class ) );
            break;
        case R.id.board_menu_file_about:
            showDialog( Utils.DIALOG_ABOUT );
            break;

        default:
            Utils.logf( ""menuitem "" + item.getItemId() + "" not handled"" );
            handled = false;
        }

        if ( handled && cmd != JNIThread.JNICmd.CMD_NONE ) {
            m_jniThread.handle( cmd );
        }
        return handled;
    }

    private XwJNI.XP_Key keyCodeToXPKey( int keyCode )
    {
        XwJNI.XP_Key xpKey = XwJNI.XP_Key.XP_KEY_NONE;
        switch( keyCode ) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            xpKey = XwJNI.XP_Key.XP_RETURN_KEY;
            break;
        case KeyEvent.KEYCODE_DPAD_DOWN:
            xpKey = XwJNI.XP_Key.XP_CURSOR_KEY_DOWN;
            break;
        case KeyEvent.KEYCODE_DPAD_LEFT:
            xpKey = XwJNI.XP_Key.XP_CURSOR_KEY_LEFT;
            break;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            xpKey = XwJNI.XP_Key.XP_CURSOR_KEY_RIGHT;
            break;
        case KeyEvent.KEYCODE_DPAD_UP:         
            xpKey = XwJNI.XP_Key.XP_CURSOR_KEY_UP;
            break;
        case KeyEvent.KEYCODE_SPACE:         
            xpKey = XwJNI.XP_Key.XP_RAISEFOCUS_KEY;
            break;
        }
        return xpKey;
    }

    // Blocking thread stuff: The problem this is solving occurs when
    // you have a blocking dialog up, meaning the jni thread is
    // blocked, and you hit the home button.  onPause() gets called
    // which wants to use jni calls to e.g. summarize.  For those to
    // succeed (the jni being non-reentrant and set up to assert if it
    // is reentered) the jni thread must first be unblocked and
    // allowed to return back through the jni.  We unblock using
    // Thread.interrupt method, the exception from which winds up
    // caught in waitBlockingDialog.  The catch dismisses the dialog
    // with the default/cancel value, but that takes us into the
    // onDismissListener which normally releases the semaphore.  But
    // if we've interrupted then we can't release it or blocking won't
    // work for as long as this activity lives.  Hence
    // releaseIfBlocking().  This feels really fragile but it does
    // work.
    private void setBlockingThread()
    {
        synchronized( this ) {
            Assert.assertTrue( null == m_blockingThread );
            m_blockingThread = Thread.currentThread();
        }
    }

    private void clearBlockingThread()
    {
        synchronized( this ) {
            Assert.assertTrue( null != m_blockingThread );
            m_blockingThread = null;
        }
    }

    private void interruptBlockingThread()
    {
        synchronized( this ) {
            if ( null != m_blockingThread ) {
                m_blockingThread.interrupt();
            }
        }
    }

    private void releaseIfBlocking()
    {
        synchronized( this ) {
            if ( null != m_blockingThread ) {
                m_forResultWait.release();
            }
        }
    }

    //////////////////////////////////////////
    // XW_UtilCtxt interface implementation //
    //////////////////////////////////////////
    static final int[][] s_buttsBoard = { 
        { BONUS_TRIPLE_WORD,  BONUS_NONE,         BONUS_NONE,BONUS_DOUBLE_LETTER,BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_TRIPLE_WORD },
        { BONUS_NONE,         BONUS_DOUBLE_WORD,  BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_TRIPLE_LETTER,BONUS_NONE,BONUS_NONE },

        { BONUS_NONE,         BONUS_NONE,         BONUS_DOUBLE_WORD,BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_DOUBLE_LETTER,BONUS_NONE },
        { BONUS_DOUBLE_LETTER,BONUS_NONE,         BONUS_NONE,BONUS_DOUBLE_WORD,BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_DOUBLE_LETTER },
                            
        { BONUS_NONE,         BONUS_NONE,         BONUS_NONE,BONUS_NONE,BONUS_DOUBLE_WORD,BONUS_NONE,BONUS_NONE,BONUS_NONE },
        { BONUS_NONE,         BONUS_TRIPLE_LETTER,BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_TRIPLE_LETTER,BONUS_NONE,BONUS_NONE },
                            
        { BONUS_NONE,         BONUS_NONE,         BONUS_DOUBLE_LETTER,BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_DOUBLE_LETTER,BONUS_NONE },
        { BONUS_TRIPLE_WORD,  BONUS_NONE,         BONUS_NONE,BONUS_DOUBLE_LETTER,BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_DOUBLE_WORD },
    }; /* buttsBoard */

    public int getSquareBonus( int col, int row ) 
    {
        int half = m_gi.boardSize / 2;
        if ( col > half ) { col = (half*2) - col; }
        if ( row > half ) { row = (half*2) - row; }
        return s_buttsBoard[row][col];
    }

    public void requestTime() 
    {
        m_handler.post( new Runnable() {
                public void run() {
                    if ( null != m_jniThread ) {
                        m_jniThread.handle( JNIThread.JNICmd.CMD_DO, false );
                    }
                }
            } );
    }

    public void remSelected() 
    {
        m_jniThread.handle( JNIThread.JNICmd.CMD_REMAINING,
                            R.string.tiles_left_title );
    }

    public void setTimer( int why, int when, int handle )
    {
        if ( null != m_timers[why] ) {
            m_handler.removeCallbacks( m_timers[why] );
        }

        m_timers[why] = new TimerRunnable( why, when, handle );

        int inHowLong;
        switch ( why ) {
        case UtilCtxt.TIMER_COMMS:
            inHowLong = when * 1000;
            break;
        case UtilCtxt.TIMER_TIMERTICK:
            inHowLong = 1000;   // when is 0 for TIMER_TIMERTICK
            break;
        default:
            inHowLong = 500;
        }
        m_handler.postDelayed( m_timers[why], inHowLong );
    }

    public void clearTimer( int why ) 
    {
        Utils.logf( ""clearTimer called"" );
        if ( null != m_timers[why] ) {
            m_handler.removeCallbacks( m_timers[why] );
            m_timers[why] = null;
        }
    }

    private void loadGame()
    {
        if ( 0 == m_jniGamePtr ) {
            byte[] stream = GameUtils.savedGame( this, m_path );
            XwJNI.gi_from_stream( m_gi, stream );

            Utils.logf( ""loadGame: dict name: %s"", m_gi.dictName );
            byte[] dictBytes = GameUtils.openDict( this, m_gi.dictName );
            if ( null == dictBytes ) {
                Assert.fail();
                finish();
            } else {
                m_jniGamePtr = XwJNI.initJNI();

                if ( m_gi.serverRole != DeviceRole.SERVER_STANDALONE ) {
                    Handler handler = new Handler() {
                            public void handleMessage( Message msg ) {
                                switch( msg.what ) {
                                case CommsTransport.DIALOG:
                                case CommsTransport.DIALOG_RETRY:
                                    m_dlgBytes = (String)msg.obj;
                                    m_dlgTitle = msg.arg1;
                                    showDialog( CommsTransport.DIALOG==msg.what
                                                ? DLG_OKONLY : DLG_RETRY );
                                    break;
                                case CommsTransport.TOAST:
                                    Toast.makeText( BoardActivity.this,
                                                    (CharSequence)(msg.obj),
                                                    Toast.LENGTH_SHORT).show();
                                    break;
                                }
                            }
                        };
                    m_xport = new CommsTransport( m_jniGamePtr, this, handler, 
                                                  m_gi.serverRole );
                }

                CommonPrefs cp = CommonPrefs.get( this );
                if ( null == stream ||
                     ! XwJNI.game_makeFromStream( m_jniGamePtr, stream, 
                                                  m_gi, dictBytes, 
                                                  m_gi.dictName,this, m_jniu, 
                                                  m_view, cp, m_xport ) ) {
                    XwJNI.game_makeNewGame( m_jniGamePtr, m_gi, this, m_jniu, 
                                            m_view, cp, m_xport, 
                                            dictBytes, m_gi.dictName );
                }

                m_jniThread = new 
                    JNIThread( m_jniGamePtr, m_gi, m_view, m_path, this,
                               new Handler() {
                                   public void handleMessage( Message msg ) {
                                       switch( msg.what ) {
                                       case JNIThread.DRAW:
                                           m_view.invalidate();
                                           break;
                                       case JNIThread.DIALOG:
                                           m_dlgBytes = (String)msg.obj;
                                           m_dlgTitle = msg.arg1;
                                           showDialog( DLG_OKONLY );
                                           break;
                                       case JNIThread.QUERY_ENDGAME:
                                           showDialog( QUERY_ENDGAME );
                                           break;
                                       case JNIThread.TOOLBAR_STATES:
                                           m_toolbar.update( msg.arg1, msg.arg2 );
                                       }
                                   }
                               } );
                m_jniThread.start();

                m_view.startHandling( m_jniThread, m_jniGamePtr, m_gi );
                if ( null != m_xport ) {
                    m_xport.setReceiver( m_jniThread );
                }
                m_jniThread.handle( JNICmd.CMD_START );

                // setTitle( GameUtils.gameName( this, m_path ) );
                m_toolbar = 
                    new Toolbar( this, findViewById( R.id.toolbar_horizontal ),
                                 findViewById( R.id.toolbar_vertical ) );

                boolean isLandscape = 
                    getResources().getConfiguration().orientation
                    == Configuration.ORIENTATION_LANDSCAPE;
                m_toolbar.orientChanged( isLandscape );
                populateToolbar();
            }
        }
    } // loadGame

    private void populateToolbar()
    {
        m_toolbar.setListener( Toolbar.BUTTON_HINT_PREV, 
                               new View.OnClickListener() {
                                   @Override
                                       public void onClick( View view ) {
                                       m_jniThread.handle( JNIThread.JNICmd
                                                           .CMD_PREV_HINT );
                                   }
                               } );
        m_toolbar.setListener( Toolbar.BUTTON_HINT_NEXT,
                               new View.OnClickListener() {
                                   @Override
                                   public void onClick( View view ) {
                                       m_jniThread.handle( JNIThread.JNICmd
                                                           .CMD_NEXT_HINT );
                                   }
                               } );
        m_toolbar.setListener( Toolbar.BUTTON_JUGGLE,
                               new View.OnClickListener() {
                                   @Override
                                   public void onClick( View view ) {
                                       m_jniThread.handle( JNIThread.JNICmd
                                                           .CMD_JUGGLE );
                                   }
                               } );
        m_toolbar.setListener( Toolbar.BUTTON_FLIP,
                               new View.OnClickListener() {
                                   @Override
                                   public void onClick( View view ) {
                                       m_jniThread.handle( JNIThread.JNICmd
                                                           .CMD_FLIP );
                                   }
                               } );
        m_toolbar.setListener( Toolbar.BUTTON_ZOOM,
                               new View.OnClickListener() {
                                   @Override
                                   public void onClick( View view ) {
                                       m_jniThread.handle( JNIThread.JNICmd
                                                           .CMD_TOGGLEZOOM );
                                   }
                               } );
        m_toolbar.setListener( Toolbar.BUTTON_UNDO,
                               new View.OnClickListener() {
                                   @Override
                                   public void onClick( View view ) {
                                       m_jniThread.handle( JNIThread.JNICmd
                                                           .CMD_UNDO_CUR );
                                   }
                               }) ;
        m_toolbar.setListener( Toolbar.BUTTON_VALUES,
                               new View.OnClickListener() {
                                   @Override
                                   public void onClick( View view ) {
                                       m_jniThread.handle( JNIThread.JNICmd
                                                           .CMD_VALUES );
                                   }
                               }) ;
    } // populateToolbar

    private DialogInterface.OnDismissListener makeODLforBlocking()
    {
        return new DialogInterface.OnDismissListener() {
            public void onDismiss( DialogInterface di ) {
                setRequestedOrientation( ActivityInfo.SCREEN_ORIENTATION_SENSOR );
                releaseIfBlocking();
            }
        };
    }

    private int waitBlockingDialog( final int dlgID, int cancelResult )
    {
        setBlockingThread();
        int orient = m_currentOrient == Configuration.ORIENTATION_LANDSCAPE
            ? ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
            : ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
        setRequestedOrientation( orient );

        m_handler.post( new Runnable() {
                public void run() {
                    showDialog( dlgID );
                }
            } );

        try {
            m_forResultWait.acquire();
        } catch ( java.lang.InterruptedException ie ) {
            m_resultCode = cancelResult;
            dismissDialog( dlgID );
            Utils.logf( ""waitBlockingDialog: got "" + ie.toString() );
        }
        clearBlockingThread();
        return m_resultCode;
    }

    private void nonBlockingDialog( final int dlgID, String txt ) 
    {
        switch ( dlgID ) {
        case DLG_OKONLY:
            m_dlgTitle = R.string.info_title;
            break;
        case DLG_BADWORDS:
            m_dlgTitle = R.string.badwords_title;
            break;
        default:
            Assert.fail();
        }

        m_dlgBytes = txt;
        m_handler.post( new Runnable() {
                public void run() {
                    showDialog( dlgID );
                }
            } );
    }

    private boolean doZoom( int zoomBy )
    {
        boolean handled = null != m_jniThread;
        if ( handled ) {
            m_jniThread.handle( JNIThread.JNICmd.CMD_ZOOM, zoomBy );
        }
        return handled;
    }

    // This is supposed to be called from the jni thread
    public int userPickTile( int playerNum, String[] texts )
    {
        m_texts = texts;
        waitBlockingDialog( PICK_TILE_REQUEST_BLK, 0 );
        return m_resultCode;
    }

    public String askPassword( String name )
    {
        String fmt = getString( R.string.msg_ask_password );
        m_dlgTitleStr = String.format( fmt, name );

        if ( null == m_passwdEdit ) {
            LayoutInflater factory = LayoutInflater.from( this );
            m_passwdEdit = (EditText)factory.inflate( R.layout.passwd_view, null );
        }
        waitBlockingDialog( ASK_PASSWORD_BLK, 0 );

        String result = null;      // means cancelled
        if ( 0 != m_resultCode ) {
            result = m_passwdEdit.getText().toString();
        }
        return result;
    }

    public void turnChanged()
    {
        m_jniThread.handle( JNIThread.JNICmd.CMD_ZOOM, -8 );
    }

    public boolean engineProgressCallback()
    {
        return ! m_jniThread.busy();
    }

    public void engineStarting( int nBlanks )
    {
        Utils.logf( ""engineStarting(%d)"", nBlanks );
        if ( nBlanks > 0 ) {
            m_handler.post( new Runnable() {
                    // Need to keep this from running after activity dies!!
                    public void run() {
                        if ( m_isVisible ) {
                            String title = getString( R.string.progress_title );
                            m_progress = ProgressDialog.show( BoardActivity.this,
                                                              title, null, true, 
                                                              true );
                        }
                    }
                } );
        }
    }

    public void engineStopping()
    {
        Utils.logf( ""engineStopping"" );
        m_handler.post( new Runnable() {
                public void run() {
                    if ( null != m_progress ) {
                        m_progress.cancel();
                        m_progress = null;
                    }
                }
            } );
    }

    public String getUserString( int stringCode )
    {
        int id = 0;
        switch( stringCode ) {
        case UtilCtxt.STRD_ROBOT_TRADED:
            id = R.string.strd_robot_traded;
            break;
        case UtilCtxt.STR_ROBOT_MOVED:
            id = R.string.str_robot_moved;
            break;
        case UtilCtxt.STRS_VALUES_HEADER:
            id = R.string.strs_values_header;
            break;
        case UtilCtxt.STRD_REMAINING_TILES_ADD:
            id = R.string.strd_remaining_tiles_add;
            break;
        case UtilCtxt.STRD_UNUSED_TILES_SUB:
            id = R.string.strd_unused_tiles_sub;
            break;
        case UtilCtxt.STR_REMOTE_MOVED:
            id = R.string.str_remote_moved;
            break;
        case UtilCtxt.STRD_TIME_PENALTY_SUB:
            id = R.string.strd_time_penalty_sub;
            break;
        case UtilCtxt.STR_PASS:
            id = R.string.str_pass;
            break;
        case UtilCtxt.STRS_MOVE_ACROSS:
            id = R.string.strs_move_across;
            break;
        case UtilCtxt.STRS_MOVE_DOWN:
            id = R.string.strs_move_down;
            break;
        case UtilCtxt.STRS_TRAY_AT_START:
            id = R.string.strs_tray_at_start;
            break;
        case UtilCtxt.STRSS_TRADED_FOR:
            id = R.string.strss_traded_for;
            break;
        case UtilCtxt.STR_PHONY_REJECTED:
            id = R.string.str_phony_rejected;
            break;
        case UtilCtxt.STRD_CUMULATIVE_SCORE:
            id = R.string.strd_cumulative_score;
            break;
        case UtilCtxt.STRS_NEW_TILES:
            id = R.string.strs_new_tiles;
            break;
        case UtilCtxt.STR_PASSED:
            id = R.string.str_passed;
            break;
        case UtilCtxt.STRSD_SUMMARYSCORED:
            id = R.string.strsd_summaryscored;
            break;
        case UtilCtxt.STRD_TRADED:
            id = R.string.strd_traded;
            break;
        case UtilCtxt.STR_LOSTTURN:
            id = R.string.str_lostturn;
            break;
        case UtilCtxt.STR_COMMIT_CONFIRM:
            id = R.string.str_commit_confirm;
            break;
        case UtilCtxt.STR_LOCAL_NAME:
            id = R.string.str_local_name;
            break;
        case UtilCtxt.STR_NONLOCAL_NAME:
            id = R.string.str_nonlocal_name;
            break;
        case UtilCtxt.STR_BONUS_ALL:
            id = R.string.str_bonus_all;
            break;
        case UtilCtxt.STRD_TURN_SCORE:
            id = R.string.strd_turn_score;
            break;
        default:
            Utils.logf( ""no such stringCode: "" + stringCode );
        }

        String result;
        if ( 0 == id ) {
            result = """";
        } else {
            result = getString( id );
        }
        return result;
    }

    public boolean userQuery( int id, String query )
    {
        boolean result;

        switch( id ) {
            // Though robot-move dialogs don't normally need to block,
            // if the player after this one is also a robot and we
            // don't block then a second dialog will replace this one.
            // So block.  Yuck.
        case UtilCtxt.QUERY_ROBOT_MOVE:
        case UtilCtxt.QUERY_ROBOT_TRADE:
            m_dlgBytes = query;
            m_dlgTitle = R.string.info_title;
            waitBlockingDialog( QUERY_INFORM_BLK, 0 );
            result = true;
            break;

            // These *are* blocking dialogs
        case UtilCtxt.QUERY_COMMIT_TRADE:
        case UtilCtxt.QUERY_COMMIT_TURN:
            if ( UtilCtxt.QUERY_COMMIT_TRADE == id ) {
                m_dlgBytes = getString( R.string.query_trade );
            } else {
                m_dlgBytes = query;
            }
            m_dlgTitle = R.string.query_title;
            result = 0 != waitBlockingDialog( QUERY_REQUEST_BLK, 0 );
            break;
        default:
            Assert.fail();
            result = false;
        }

        return result;
    }

    public void userError( int code )
    {
        int resid = 0;
        switch( code ) {
        case ERR_TILES_NOT_IN_LINE:
            resid = R.string.str_tiles_not_in_line;
            break;
        case ERR_NO_EMPTIES_IN_TURN:
            resid = R.string.str_no_empties_in_turn;
            break;
        case ERR_TWO_TILES_FIRST_MOVE:
            resid = R.string.str_two_tiles_first_move;
            break;
        case ERR_TILES_MUST_CONTACT:
            resid = R.string.str_tiles_must_contact;
            break;
        case ERR_NOT_YOUR_TURN:
            resid = R.string.str_not_your_turn;
            break;
        case ERR_NO_PEEK_ROBOT_TILES:
            resid = R.string.str_no_peek_robot_tiles;
            break;
        case ERR_CANT_TRADE_MID_MOVE:
            resid = R.string.str_cant_trade_mid_move;
            break;
        case ERR_TOO_FEW_TILES_LEFT_TO_TRADE:
            resid = R.string.str_too_few_tiles_left_to_trade;
            break;
        case ERR_CANT_UNDO_TILEASSIGN:
            resid = R.string.str_cant_undo_tileassign;
            break;
        case ERR_CANT_HINT_WHILE_DISABLED:
            resid = R.string.str_cant_hint_while_disabled;
            break;
        case ERR_NO_PEEK_REMOTE_TILES:
            resid = R.string.str_no_peek_remote_tiles;
            break;
        case ERR_REG_UNEXPECTED_USER:
            resid = R.string.str_reg_unexpected_user;
            break;
        case ERR_SERVER_DICT_WINS:
            resid = R.string.str_server_dict_wins;
            break;
        case ERR_REG_SERVER_SANS_REMOTE:
            resid = R.string.str_reg_server_sans_remote;
            break;
        }

        if ( resid != 0 ) {
            nonBlockingDialog( DLG_OKONLY, getString( resid ) );
        }
    } // userError

    public void notifyGameOver()
    {
        m_jniThread.handle( JNIThread.JNICmd.CMD_POST_OVER );
    }

    // public void yOffsetChange( int maxOffset, int oldOffset, int newOffset )
    // {
    //     Utils.logf( ""yOffsetChange(maxOffset=%d)"", maxOffset );
    //     m_view.setVerticalScrollBarEnabled( maxOffset > 0 );
    // }

    public boolean warnIllegalWord( String[] words, int turn, boolean turnLost )
    {
        Utils.logf( ""warnIllegalWord"" );
        boolean accept = turnLost;

        StringBuffer sb = new StringBuffer();
        for ( int ii = 0; ; ) {
            sb.append( words[ii] );
            if ( ++ii == words.length ) {
                break;
            }
            sb.append( ""; "" );
        }
        
        String format = getString( R.string.ids_badwords );
        String message = String.format( format, sb.toString() );

        if ( turnLost ) {
            nonBlockingDialog( DLG_BADWORDS, 
                               message + getString(R.string.badwords_lost) );
        } else {
            m_dlgBytes = message + getString( R.string.badwords_accept );
            m_dlgTitle = R.string.query_title;
            accept = 0 != waitBlockingDialog( QUERY_REQUEST_BLK, 0 );
        }

        Utils.logf( ""warnIllegalWord=>"" + accept );
        return accept;
    }

} // class BoardActivity
",True,15,26,0,0,3,12,0,12,L1
15,org.eehouse.android.xw4.FirstRunDialog.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.pm.PackageInfo;
import android.app.AlertDialog;
import android.webkit.WebView;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;

/* Put up a dialog greeting user after every upgrade.  Based on
 * similar feature in OpenSudoku, to whose author ""Thanks"".
 */

public class FirstRunDialog {
	private static final String HIDDEN_PREFS = ""xwprefs_hidden"";
    private static final String SHOWN_VERSION_KEY = ""SHOWN_VERSION_KEY"";

    static void show( Context context, boolean skipCheck )
    {
        int thisVersion = 0;
        int shownVersion = 0;

        if ( !skipCheck ) {
            try {
                thisVersion = context.getPackageManager()
                    .getPackageInfo(context.getPackageName(), 0)
                    .versionCode;
                Utils.logf( ""versionCode: %d"", thisVersion );
            } catch ( Exception e ) {
            }
        }

        SharedPreferences prefs = null;
        if ( thisVersion > 0 ) {
            prefs = context.getSharedPreferences( HIDDEN_PREFS, 
                                                  Context.MODE_PRIVATE );
            shownVersion = prefs.getInt( SHOWN_VERSION_KEY, 0 );
        }

        if ( skipCheck || shownVersion < thisVersion ) {
            showDialog( context );
        
            if ( !skipCheck ) {
                Editor editor = prefs.edit();
                editor.putInt( SHOWN_VERSION_KEY, thisVersion );
                editor.commit();
            }
        }
    }

    private static void showDialog( Context context )
    {
        String page = null;
        InputStream inputStream = null;
		try {
            inputStream = context.getResources()
                .openRawResource(R.raw.changes);
			
			final char[] buf = new char[0x1000];
			StringBuilder stringBuilder = new StringBuilder();
			Reader reader = new InputStreamReader( inputStream, ""UTF-8"" );
			int nRead;
			do {
                nRead = reader.read( buf, 0, buf.length );
                if ( nRead > 0 ) {
                    stringBuilder.append( buf, 0, nRead );
                }
			} while ( nRead >= 0 );
			
			page = stringBuilder.toString();
		}
		catch ( IOException ioe ) {
			Utils.logf( ioe.toString() );
		}
		finally {
            // could just catch NPE....
			if ( null != inputStream ) {
				try {
					inputStream.close();
				} catch ( IOException ioe ) {
                    Utils.logf( ioe.toString() );
				}
			}
		}
		
        // This won't support e.g mailto refs.  Probably want to
        // launch the browser with an intent eventually.
		WebView view = new WebView( context );
		view.loadData( page, ""text/html"", ""utf-8"" );

		AlertDialog dialog = new AlertDialog.Builder( context )
            .setIcon(android.R.drawable.ic_menu_info_details)
            .setTitle( R.string.changes_title )
            .setView( view )
            .setPositiveButton( R.string.button_ok, null)
            .create();
		dialog.show();
    }
}
",True,28,19,1,1,6,6,2,1,L0
16,org.eehouse.android.xw4.EditColorPreference.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.preference.DialogPreference;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.TypedArray;
import android.util.AttributeSet;
import android.view.View;
import android.widget.SeekBar;
import android.widget.EditText;
import android.app.Dialog;
import android.content.SharedPreferences;
import android.app.AlertDialog;
import android.text.TextWatcher;
import android.text.Editable;
import junit.framework.Assert;

public class EditColorPreference extends DialogPreference {

    private Context m_context;
    private int m_curColor;
    // m_updateText: prevent loop that resets edittext cursor
    private boolean m_updateText = true;
    private static final int m_seekbarIds[] = { R.id.seek_red, R.id.seek_green, 
                                                R.id.seek_blue };
    private static final int m_editIds[] = { R.id.edit_red, R.id.edit_green, 
                                             R.id.edit_blue };

    private class SBCL implements SeekBar.OnSeekBarChangeListener {
        int m_index;
        View m_sample;
        EditText m_editTxt;
        public SBCL( View parent, EditText editTxt, int indx )
        {
            m_index = indx;
            m_sample = parent.findViewById( R.id.color_edit_sample );
            m_editTxt = editTxt;
        }

        public void onProgressChanged( SeekBar seekBar, int progress, 
                                       boolean fromUser )
        {
            if ( m_updateText ) {
                m_editTxt.setText( String.format( ""%d"", progress ) );
            }

            int shift = 16 - (m_index * 8);
            // mask out the byte we're changing
            int color = m_curColor & ~(0xFF << shift);
            // add in the new version of the byte
            color |= progress << shift;
            m_curColor = color;
            m_sample.setBackgroundColor( m_curColor );
        }

        public void onStartTrackingTouch( SeekBar seekBar ) {}

        public void onStopTrackingTouch( SeekBar seekBar ) {}
    }

    private class TCL implements TextWatcher {
        private SeekBar m_seekBar;
        public TCL( SeekBar seekBar ) { m_seekBar = seekBar; }
        public void afterTextChanged( Editable s )
        {
        }

        public void beforeTextChanged( CharSequence s, int st, int cnt, int a ) 
        {
        }

        public void onTextChanged( CharSequence s, int start, 
                                   int before, int count )
        {
            int val;
            try {
                val = Integer.parseInt( s.toString() );
            } catch ( java.lang.NumberFormatException nfe ) {
                val = 0;
            }
            m_updateText = false; // don't call me recursively inside seekbar
            m_seekBar.setProgress( val );
            m_updateText = true;
        }
    }

    public EditColorPreference( Context context, AttributeSet attrs )
    {
        super( context, attrs );
        m_context = context;
        
        setWidgetLayoutResource( R.layout.color_display );
        setDialogLayoutResource( R.layout.color_edit );
    }

    @Override
    protected Object onGetDefaultValue(TypedArray a, int index) {
        return a.getInteger(index, 0);
    }

    @Override
    protected void onSetInitialValue(boolean restoreValue, Object defaultValue) {
        if ( !restoreValue ) {
            persistInt( (Integer)defaultValue );
        }
    }
    
    @Override
    protected void onBindView( View parent ) 
    {
        super.onBindView( parent );
        View sample = parent.findViewById( R.id.color_display_sample );
        sample.setBackgroundColor( getPersistedColor() );
    }

    @Override
    protected void onBindDialogView( View view )
    {
        m_curColor = getPersistedColor();
        setOneByte( view, 0 );
        setOneByte( view, 1 );
        setOneByte( view, 2 );

        View sample = (View)view.findViewById( R.id.color_edit_sample );
        sample.setBackgroundColor( m_curColor );
    }
    
    @Override
    protected void onPrepareDialogBuilder( AlertDialog.Builder builder )
    {
        DialogInterface.OnClickListener lstnr = 
            new DialogInterface.OnClickListener() {
                @Override
                public void onClick( DialogInterface dialog, int which )
                {
                    int color = (getOneByte( dialog, R.id.seek_red ) << 16)
                        | (getOneByte( dialog, R.id.seek_green ) << 8)
                        | getOneByte( dialog, R.id.seek_blue );

                    persistInt( color );
                    notifyChanged();
                }
            };
        builder.setPositiveButton( R.string.button_ok, lstnr );
        super.onPrepareDialogBuilder( builder );
    }

    private void setOneByte( View parent, int indx ) 
    {
        int shift = 16 - (indx*8);
        int byt = (m_curColor >> shift) & 0xFF;
        SeekBar seekbar = (SeekBar)parent.findViewById( m_seekbarIds[indx] );
        EditText edittext = (EditText)parent.findViewById( m_editIds[indx] );

        if ( null != seekbar ) {
            seekbar.setProgress( byt );

            seekbar.setOnSeekBarChangeListener( new SBCL( parent, edittext,
                                                          indx ) );
        }

        if ( null != edittext ) {
            edittext.setText( String.format( ""%d"", byt ) );
            edittext.addTextChangedListener( new TCL( seekbar ) );
        }
    }

    private int getOneByte( DialogInterface parent, int id ) {
        int val = 0;
        Dialog dialog = (Dialog)parent;
        SeekBar seekbar = (SeekBar)dialog.findViewById( id );
        if ( null != seekbar ) {
            val = seekbar.getProgress();
        }
        return val;
    }

    private int getPersistedColor()
    {
        return 0xFF000000 | getPersistedInt(0);
    }
}
",False,21,1,0,0,0,0,0,0,I0
17,org.eehouse.android.xw4.GameConfig.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import java.util.ArrayList;
import android.view.Gravity;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.app.Dialog;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.view.LayoutInflater;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.view.MenuInflater;
import android.view.KeyEvent;
import android.widget.Spinner;
import android.widget.ArrayAdapter;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.ListAdapter;
import android.database.DataSetObserver;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class GameConfig extends Activity implements View.OnClickListener,
                                                    XWListItem.DeleteCallback {

    private static final int PLAYER_EDIT = 1;
    private static final int ROLE_EDIT_RELAY = 2;
    private static final int ROLE_EDIT_SMS = 3;
    private static final int ROLE_EDIT_BT = 4;
    private static final int FORCE_REMOTE = 5;
    private static final int CONFIRM_CHANGE = 6;

    private Button m_addPlayerButton;
    private Button m_jugglePlayersButton;
    private Button m_configureButton;
    private String m_path;
    private CurGameInfo m_gi;
    private CurGameInfo m_giOrig;
    private int m_whichPlayer;
    private Dialog m_curDialog;
    private Spinner m_roleSpinner;
    private Spinner m_connectSpinner;
    private Spinner m_phoniesSpinner;
    private Spinner m_dictSpinner;
    private String[] m_dicts;
    private int m_browsePosition;
    private LinearLayout m_playerLayout;
    private CommsAddrRec m_carOrig;
    private CommsAddrRec m_car;
    private CommonPrefs m_cp;
    private boolean m_canDoSMS = false;
    private boolean m_canDoBT = false;
    private int m_nMoves = 0;
    private CommsAddrRec.CommsConnType[] m_types;
    private String[] m_connStrings;

    class RemoteChoices extends XWListAdapter {
        public RemoteChoices() { super( GameConfig.this, m_gi.nPlayers ); }

        public Object getItem( int position) { return m_gi.players[position]; }
        public View getView( final int position, View convertView, 
                             ViewGroup parent ) {
            CompoundButton.OnCheckedChangeListener lstnr;
            lstnr = new CompoundButton.OnCheckedChangeListener() {
                    @Override
                    public void onCheckedChanged( CompoundButton buttonView, 
                                                 boolean isChecked )
                    {
                        m_gi.players[position].isLocal = !isChecked;
                    }
                };
            CheckBox cb = new CheckBox( GameConfig.this );
            LocalPlayer lp = m_gi.players[position];
            cb.setText( lp.name );
            cb.setChecked( !lp.isLocal );
            cb.setOnCheckedChangeListener( lstnr );
            return cb;
        }
    }

    @Override
    protected Dialog onCreateDialog( int id )
    {
        Dialog dialog = null;
        LayoutInflater factory;
        DialogInterface.OnClickListener dlpos;
        AlertDialog.Builder ab;

        switch (id) {
        case PLAYER_EDIT:
            factory = LayoutInflater.from(this);
            final View playerEditView
                = factory.inflate( R.layout.player_edit, null );

            dialog = new AlertDialog.Builder( this )
                .setTitle(R.string.player_edit_title)
                .setView(playerEditView)
                .setPositiveButton( R.string.button_ok,
                                    new DialogInterface.OnClickListener() {
                                        public void onClick( DialogInterface dlg, 
                                                             int whichButton ) {
                                            getPlayerSettings();
                                            loadPlayers();
                                        }
                                    })
                .setNegativeButton( R.string.button_cancel, null )
                .create();
            break;
        case ROLE_EDIT_RELAY:
        case ROLE_EDIT_SMS:
        case ROLE_EDIT_BT:
            dialog = new AlertDialog.Builder( this )
                .setTitle(titleForDlg(id))
                .setView( LayoutInflater.from(this)
                          .inflate( layoutForDlg(id), null ))
                .setPositiveButton( R.string.button_ok,
                                    new DialogInterface.OnClickListener() {
                                        public void onClick( DialogInterface dlg, 
                                                             int whichButton ) {
                                            getRoleSettings();
                                        }
                                    })
                .setNegativeButton( R.string.button_cancel, null )
                .create();
            break;

        case FORCE_REMOTE:
            dialog = new AlertDialog.Builder( this )
                .setTitle( R.string.force_title )
                .setView( LayoutInflater.from(this)
                          .inflate( layoutForDlg(id), null ) )
                .setPositiveButton( R.string.button_ok,
                                    new DialogInterface.OnClickListener() {
                                        public void onClick( DialogInterface dlg, 
                                                             int whichButton ) {
                                            loadPlayers();
                                        }
                                    })
                .setNegativeButton( R.string.button_cancel, null )
                .create();
            dialog.setOnDismissListener( new DialogInterface.OnDismissListener() {
                    @Override
                    public void onDismiss( DialogInterface di ) 
                    {
                        if ( m_gi.remoteCount() == 0 ) {
                            // force one to remote -- or make it
                            // standalone???
                            m_gi.players[0].isLocal = false;
                            loadPlayers();
                        }
                    }
                });
            break;
        case CONFIRM_CHANGE:
            dialog = new AlertDialog.Builder( this )
                .setTitle( R.string.confirm_save_title )
                .setMessage( R.string.confirm_save )
                .setPositiveButton( R.string.button_save,
                                    new DialogInterface.OnClickListener() {
                                        public void onClick( DialogInterface dlg, 
                                                             int whichButton ) {
                                            applyChanges( true );
                                            finish();
                                        }
                                    })
                .setNegativeButton( R.string.button_discard, 
                                    new DialogInterface.OnClickListener() {
                                        public void onClick( DialogInterface dlg, 
                                                             int whichButton ) {
                                            finish();
                                        }
                                    })
                .create();
            break;
        }
        return dialog;
    }

    @Override
    protected void onPrepareDialog( int id, Dialog dialog )
    { 
        m_curDialog = dialog;

        switch ( id ) {
        case PLAYER_EDIT:
            setPlayerSettings();
            break;
        case ROLE_EDIT_RELAY:
        case ROLE_EDIT_SMS:
        case ROLE_EDIT_BT:
            setRoleHints( id, dialog );
            setRoleSettings();
            break;
        case FORCE_REMOTE:
            ListView listview = (ListView)dialog.findViewById( R.id.players );
            listview.setAdapter( new RemoteChoices() );
            break;
        }
        super.onPrepareDialog( id, dialog );
    }

    private void setPlayerSettings()
    {
        // Hide remote option if in standalone mode...
        boolean isServer = DeviceRole.SERVER_ISSERVER == curRole();

        LocalPlayer lp = m_gi.players[m_whichPlayer];
        Utils.setText( m_curDialog, R.id.player_name_edit, lp.name );
        Utils.setText( m_curDialog, R.id.password_edit, lp.password );

        CheckBox check = (CheckBox)
            m_curDialog.findViewById( R.id.remote_check );
        if ( isServer ) {
            CompoundButton.OnCheckedChangeListener lstnr =
                new CompoundButton.OnCheckedChangeListener() {
                    public void onCheckedChanged( CompoundButton buttonView, 
                                                  boolean checked ) {
                        View view
                            = m_curDialog.findViewById( R.id.local_player_set );
                        view.setVisibility( checked ? View.GONE : View.VISIBLE );
                    }
                };
            check.setOnCheckedChangeListener( lstnr );
            check.setVisibility( View.VISIBLE );
        } else {
            check.setVisibility( View.GONE );
        }

        check = (CheckBox)m_curDialog.findViewById( R.id.robot_check );
        CompoundButton.OnCheckedChangeListener lstnr =
            new CompoundButton.OnCheckedChangeListener() {
                public void onCheckedChanged( CompoundButton buttonView, 
                                              boolean checked ) {
                    View view = m_curDialog.findViewById( R.id.password_set );
                    view.setVisibility( checked ? View.GONE : View.VISIBLE );
                }
            };
        check.setOnCheckedChangeListener( lstnr );

        Utils.setChecked( m_curDialog, R.id.robot_check, lp.isRobot );
        Utils.setChecked( m_curDialog, R.id.remote_check, ! lp.isLocal );
    }

    private void setRoleHints( int id, Dialog dialog )
    {
        int[] guestHints = null;
        int[] hostHints = null;
        switch( id ) {
        case ROLE_EDIT_RELAY:
            // Can these be in an array in a resource?
            guestHints = new int[] { R.id.room_edit_hint_guest };
            hostHints = new int[] { R.id.room_edit_hint_host };
            break;
        case ROLE_EDIT_SMS:
        case ROLE_EDIT_BT:
        }

        DeviceRole role = m_gi.serverRole;
        if ( null != guestHints ) {
            for ( int hintID : guestHints ) {
                View view = dialog.findViewById( hintID );
                view.setVisibility( DeviceRole.SERVER_ISCLIENT == role ?
                                    View.VISIBLE : View.GONE );
            }
        }
        if ( null != hostHints ) {
            for ( int hintID : hostHints ) {
                View view = dialog.findViewById( hintID );
                view.setVisibility( DeviceRole.SERVER_ISSERVER == role ?
                                    View.VISIBLE : View.GONE );
            }
        }
    }

    private void setRoleSettings()
    {
        switch( m_types[m_connectSpinner.getSelectedItemPosition()] ) {
        case COMMS_CONN_RELAY:
            Utils.setText( m_curDialog, R.id.room_edit, m_car.ip_relay_invite );
            break;
        case COMMS_CONN_SMS:
            Utils.setText( m_curDialog, R.id.sms_phone_edit, m_car.sms_phone );
            Utils.logf( ""set phone: "" + m_car.sms_phone );
            Utils.setInt( m_curDialog, R.id.sms_port_edit, m_car.sms_port );
            break;
        case COMMS_CONN_BT:
        }
    }

    private void getRoleSettings()
    {
        m_car.conType = m_types[ m_connectSpinner.getSelectedItemPosition() ];
        switch ( m_car.conType ) {
        case COMMS_CONN_RELAY:
            m_car.ip_relay_invite = Utils.getText( m_curDialog, R.id.room_edit );
            break;
        case COMMS_CONN_SMS:
            m_car.sms_phone = Utils.getText( m_curDialog, R.id.sms_phone_edit );
            Utils.logf( ""grabbed phone: "" + m_car.sms_phone );
            m_car.sms_port = (short)Utils.getInt( m_curDialog, 
                                                  R.id.sms_port_edit );
            break;
        case COMMS_CONN_BT:
            break;
        }
    }

    private void getPlayerSettings()
    {
        LocalPlayer lp = m_gi.players[m_whichPlayer];
        lp.name = Utils.getText( m_curDialog, R.id.player_name_edit );
        lp.password = Utils.getText( m_curDialog, R.id.password_edit );

        lp.isRobot = Utils.getChecked( m_curDialog, R.id.robot_check );
        lp.isLocal = !Utils.getChecked( m_curDialog, R.id.remote_check );
    }

    @Override
    public void onCreate( Bundle savedInstanceState )
    {
        super.onCreate(savedInstanceState);

        // 1.5 doesn't have SDK_INT.  So parse the string version.
        // int sdk_int = 0;
        // try {
        //     sdk_int = Integer.decode( android.os.Build.VERSION.SDK );
        // } catch ( Exception ex ) {}
        // m_canDoSMS = sdk_int >= android.os.Build.VERSION_CODES.DONUT;

        m_cp = CommonPrefs.get( this );

        Intent intent = getIntent();
        Uri uri = intent.getData();
        m_path = uri.getPath();
        if ( m_path.charAt(0) == '/' ) {
            m_path = m_path.substring( 1 );
        }

        int gamePtr = XwJNI.initJNI();
        m_giOrig = new CurGameInfo( this );
        GameUtils.loadMakeGame( this, gamePtr, m_giOrig, m_path );
        m_nMoves = XwJNI.model_getNMoves( gamePtr );
        m_giOrig.setInProgress( 0 < m_nMoves );
        m_gi = new CurGameInfo( m_giOrig );

        int curSel = listAvailableDicts( m_gi.dictName );

        m_carOrig = new CommsAddrRec( this );
        if ( XwJNI.game_hasComms( gamePtr ) ) {
            XwJNI.comms_getAddr( gamePtr, m_carOrig );
        } else {
            String relayName = CommonPrefs.getDefaultRelayHost( this );
            int relayPort = CommonPrefs.getDefaultRelayPort( this );
            XwJNI.comms_getInitialAddr( m_carOrig, relayName, relayPort );
        }
        XwJNI.game_dispose( gamePtr );

        m_car = new CommsAddrRec( m_carOrig );

        setContentView(R.layout.game_config);

        m_addPlayerButton = (Button)findViewById(R.id.add_player);
        m_addPlayerButton.setOnClickListener( this );
        m_jugglePlayersButton = (Button)findViewById(R.id.juggle_players);
        m_jugglePlayersButton.setOnClickListener( this );
        m_configureButton = (Button)findViewById(R.id.configure_role);
        m_configureButton.setOnClickListener( this );

        m_playerLayout = (LinearLayout)findViewById( R.id.player_list );
        loadPlayers();

        m_dictSpinner = (Spinner)findViewById( R.id.dict_spinner );
        configDictSpinner();

        m_roleSpinner = (Spinner)findViewById( R.id.role_spinner );
        m_roleSpinner.setSelection( m_gi.serverRole.ordinal() );
        m_roleSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {
                @Override
                public void onItemSelected(AdapterView<?> parentView, 
                                           View selectedItemView, int position, 
                                           long id ) {
                    m_gi.setServerRole( DeviceRole.values()[position] );
                    adjustVisibility();
                    loadPlayers();
                }

                @Override
                public void onNothingSelected(AdapterView<?> parentView) {
                }
            });

        configConnectSpinner();

        m_phoniesSpinner = (Spinner)findViewById( R.id.phonies_spinner );
        m_phoniesSpinner.setSelection( m_gi.phoniesAction.ordinal() );

        Utils.setChecked( this, R.id.hints_allowed, !m_gi.hintsNotAllowed );
        Utils.setInt( this, R.id.timer_minutes_edit, 
                      m_gi.gameSeconds/60/m_gi.nPlayers );

        CheckBox check = (CheckBox)findViewById( R.id.use_timer );
        CompoundButton.OnCheckedChangeListener lstnr =
            new CompoundButton.OnCheckedChangeListener() {
                public void onCheckedChanged( CompoundButton buttonView, 
                                              boolean checked ) {
                    View view = findViewById( R.id.timer_set );
                    view.setVisibility( checked ? View.VISIBLE : View.GONE );
                }
            };
        check.setOnCheckedChangeListener( lstnr );
        Utils.setChecked( this, R.id.use_timer, m_gi.timerEnabled );

        Utils.setChecked( this, R.id.smart_robot, 0 < m_gi.robotSmartness );

        adjustVisibility();

        String fmt = getString( R.string.title_game_configf );
        setTitle( String.format( fmt, GameUtils.gameName( this, m_path ) ) );
    } // onCreate

    // DeleteCallback interface
    public void deleteCalled( int myPosition )
    {
        if ( m_gi.delete( myPosition ) ) {
            loadPlayers();
        }
    }

    public void onClick( View view ) 
    {
        if ( m_addPlayerButton == view ) {
            int curIndex = m_gi.nPlayers;
            if ( curIndex < CurGameInfo.MAX_NUM_PLAYERS ) {
                m_gi.addPlayer(); // ups nPlayers
                loadPlayers();
            }
        } else if ( m_jugglePlayersButton == view ) {
            m_gi.juggle();
            loadPlayers();
        } else if ( m_configureButton == view ) {
            int position = m_connectSpinner.getSelectedItemPosition();
            switch ( m_types[ position ] ) {
            case COMMS_CONN_RELAY:
                showDialog( ROLE_EDIT_RELAY );
                break;
            case COMMS_CONN_SMS:
                showDialog( ROLE_EDIT_SMS );
                break;
            case COMMS_CONN_BT:
                showDialog( ROLE_EDIT_BT );
                break;
            }
        } else {
            Utils.logf( ""unknown v: "" + view.toString() );
        }
    } // onClick

    @Override
    public boolean onKeyDown( int keyCode, KeyEvent event )
    {
        boolean consumed = false;
        if ( keyCode == KeyEvent.KEYCODE_BACK ) {
            saveChanges();
            if ( 0 >= m_nMoves ) { // no confirm needed 
                applyChanges( true );
            } else if ( m_giOrig.changesMatter(m_gi) 
                        || m_carOrig.changesMatter(m_car) ) {
                showDialog( CONFIRM_CHANGE );
                consumed = true; // don't dismiss activity yet!
            } else {
                applyChanges( false );
            }
        }

        return consumed || super.onKeyDown( keyCode, event );
    }

    @Override
    protected void onResume()
    {
        configDictSpinner();
        super.onResume();
    }

    private void loadPlayers()
    {
        m_playerLayout.removeAllViews();

        String[] names = m_gi.visibleNames( this );
        LayoutInflater factory = LayoutInflater.from(this);
        for ( int ii = 0; ii < names.length; ++ii ) {

            final XWListItem view
                = (XWListItem)factory.inflate( R.layout.list_item, null );
            view.setPosition( ii );
            view.setText( names[ii] );
            view.setGravity( Gravity.CENTER );
            // only enable delete if one will remain
            if ( 1 < names.length ) {
                view.setDeleteCallback( this );
            }

            view.setOnClickListener( new View.OnClickListener() {
                    @Override
                    public void onClick( View view ) {
                        m_whichPlayer = ((XWListItem)view).getPosition();
                        showDialog( PLAYER_EDIT );
                    }
                } );
            m_playerLayout.addView( view );

            View divider = factory.inflate( R.layout.divider_view, null );
            divider.setVisibility( View.VISIBLE );
            m_playerLayout.addView( divider );
        }

        m_addPlayerButton
            .setVisibility( names.length >= CurGameInfo.MAX_NUM_PLAYERS?
                            View.GONE : View.VISIBLE );
        m_jugglePlayersButton
            .setVisibility( names.length <= 1 ?
                            View.GONE : View.VISIBLE );

        if ( DeviceRole.SERVER_ISSERVER == m_gi.serverRole
             && 0 == m_gi.remoteCount() ) {
            showDialog( FORCE_REMOTE );
        }
    } // loadPlayers

    private int listAvailableDicts( String curDict )
    {
        int curSel = -1;

        String[] list = GameUtils.dictList( this );

        m_browsePosition = list.length;
        m_dicts = new String[m_browsePosition+1];
        m_dicts[m_browsePosition] = getString( R.string.download_dicts );
        
        for ( int ii = 0; ii < m_browsePosition; ++ii ) {
            String dict = list[ii];
            m_dicts[ii] = dict;
            if ( dict.equals( curDict ) ) {
                curSel = ii;
            }
        }

        return curSel;
    }

    private void configDictSpinner()
    {
        int curSel = listAvailableDicts( m_gi.dictName );

        ArrayAdapter<String> adapter = 
            new ArrayAdapter<String>( this,
                                      android.R.layout.simple_spinner_item,
                                      m_dicts );
        int resID = android.R.layout.simple_spinner_dropdown_item;
        adapter.setDropDownViewResource( resID );
        m_dictSpinner.setAdapter( adapter );
        if ( curSel >= 0 ) {
            m_dictSpinner.setSelection( curSel );
        } 

        m_dictSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parentView, 
                                       View selectedItemView, 
                                       int position, long id ) {
                if ( position == m_browsePosition ) {
                    startActivity( Utils.mkDownloadActivity(GameConfig.this) );
                } else {
                    m_gi.dictName = m_dicts[position];
                    Utils.logf( ""assigned dictName: "" + m_gi.dictName );
                }
            }

            @Override
            public void onNothingSelected(AdapterView<?> parentView) {}
            });
    }

    private void configConnectSpinner()
    {
        m_connectSpinner = (Spinner)findViewById( R.id.connect_spinner );
        m_connStrings = makeXportStrings();
        ArrayAdapter<String> adapter = 
            new ArrayAdapter<String>( this,
                                      android.R.layout.simple_spinner_item,
                                      m_connStrings );
        adapter.setDropDownViewResource( android.R.layout
                                         .simple_spinner_dropdown_item );
        m_connectSpinner.setAdapter( adapter );
        m_connectSpinner.setSelection( connTypeToPos( m_car.conType ) );
        AdapterView.OnItemSelectedListener
            lstnr = new AdapterView.OnItemSelectedListener() {
                    @Override
                    public void onItemSelected(AdapterView<?> parentView, 
                                               View selectedItemView, 
                                               int position, 
                                               long id ) 
                    {
                        String fmt = getString( R.string.configure_rolef );
                        m_configureButton
                            .setText( String.format( fmt, 
                                                     m_connStrings[position] ));
                    }

                    @Override
                    public void onNothingSelected(AdapterView<?> parentView) 
                    {
                    }
                };
        m_connectSpinner.setOnItemSelectedListener( lstnr );

    } // configConnectSpinner

    private void adjustVisibility()
    {
        // compiler insists these be initialized, so set 'em for
        // SERVER_STANDALONE
        int vis = View.GONE;
        int labelId = R.string.players_label_standalone;

        switch ( curRole() ) {
        case SERVER_ISSERVER:
            vis = View.VISIBLE;
            labelId = R.string.players_label_host;
            break;
        case SERVER_ISCLIENT:
            vis = View.VISIBLE;
            labelId = R.string.players_label_guest;
            break;
        }

        int[] ids = { R.id.connection_label,
                      R.id.connect_spinner, 
                      R.id.configure_role };
        for ( int id : ids ) {
            findViewById( id ).setVisibility( vis );
        }

        ((TextView)findViewById( R.id.players_label )).
            setText( getString(labelId) );
    }
    
    private int connTypeToPos( CommsAddrRec.CommsConnType typ )
    {
        switch( typ ) {
        case COMMS_CONN_RELAY:
            return 0;
        case COMMS_CONN_SMS:
            return 1;
        case COMMS_CONN_BT:
            return 2;
        }
        return -1;
    }

    private int layoutForDlg( int id ) 
    {
        switch( id ) {
        case ROLE_EDIT_RELAY:
            return R.layout.role_edit_relay;
        case ROLE_EDIT_SMS:
            return R.layout.role_edit_sms;
        case ROLE_EDIT_BT:
            return R.layout.role_edit_bt;
        case FORCE_REMOTE:
            return R.layout.force_remote;
        }
        Assert.fail();
        return 0;
    }

    private int titleForDlg( int id ) 
    {
        switch( id ) {
        case ROLE_EDIT_RELAY:
            return R.string.tab_relay;
        case ROLE_EDIT_SMS:
            return R.string.tab_sms;
        case ROLE_EDIT_BT:
            return R.string.tab_bluetooth;
        }
        Assert.fail();
        return -1;
    }

    private String[] makeXportStrings()
    {
        ArrayList<String> strings = new ArrayList<String>();
        ArrayList<CommsAddrRec.CommsConnType> types
            = new ArrayList<CommsAddrRec.CommsConnType>();

        strings.add( getString(R.string.tab_relay) );
        types.add( CommsAddrRec.CommsConnType.COMMS_CONN_RELAY );

        if ( m_canDoSMS ) {
            strings.add( getString(R.string.tab_sms) );
            types.add( CommsAddrRec.CommsConnType.COMMS_CONN_SMS );
        }
        if ( m_canDoBT ) {
            strings.add( getString(R.string.tab_bluetooth) );
            types.add( CommsAddrRec.CommsConnType.COMMS_CONN_BT );
        }
        m_types = types.toArray( new CommsAddrRec.CommsConnType[types.size()] );
        return strings.toArray( new String[strings.size()] );
    }

    private DeviceRole curRole()
    {
        int position = m_roleSpinner.getSelectedItemPosition();
        return DeviceRole.values()[position];
    }

    private void saveChanges()
    {
        m_gi.hintsNotAllowed = !Utils.getChecked( this, R.id.hints_allowed );
        m_gi.timerEnabled = Utils.getChecked(  this, R.id.use_timer );
        m_gi.gameSeconds = 60 * m_gi.nPlayers *
            Utils.getInt(  this, R.id.timer_minutes_edit );
        m_gi.robotSmartness
            = Utils.getChecked( this, R.id.smart_robot ) ? 1 : 0;

        int position = m_phoniesSpinner.getSelectedItemPosition();
        m_gi.phoniesAction = CurGameInfo.XWPhoniesChoice.values()[position];

        m_gi.fixup();

        position = m_connectSpinner.getSelectedItemPosition();
        m_car.conType = m_types[ position ];
    }

    private void applyChanges( boolean forceNew )
    {
        // This should be a separate function, commitChanges() or
        // somesuch.  But: do we have a way to save changes to a gi
        // that don't reset the game, e.g. player name for standalone
        // games?
        byte[] dictBytes = GameUtils.openDict( this, m_gi.dictName );
        int gamePtr = XwJNI.initJNI();
        boolean madeGame = false;

        if ( !forceNew ) {
            byte[] stream = GameUtils.savedGame( this, m_path );
            // Will fail if there's nothing in the stream but a gi.
            madeGame = XwJNI.game_makeFromStream( gamePtr, stream, 
                                                  JNIUtilsImpl.get(),
                                                  new CurGameInfo(this), 
                                                  dictBytes, m_gi.dictName, 
                                                  m_cp );
        }

        if ( forceNew || !madeGame ) {
            m_gi.setInProgress( false );
            m_gi.fixup();
            XwJNI.game_makeNewGame( gamePtr, m_gi, JNIUtilsImpl.get(), 
                                    m_cp, dictBytes, m_gi.dictName );
        }

        if ( null != m_car ) {
            XwJNI.comms_setAddr( gamePtr, m_car );
        }

        GameUtils.saveGame( this, gamePtr, m_gi, m_path );

        GameSummary summary = new GameSummary();
        XwJNI.game_summarize( gamePtr, m_gi.nPlayers, summary );
        DBUtils.saveSummary( m_path, summary );

        XwJNI.game_dispose( gamePtr );
    }

}
",True,6,21,0,0,3,12,0,12,L1
18,org.eehouse.android.xw4.StatusReceiver.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

public class StatusReceiver extends BroadcastReceiver {

    @Override
    public void onReceive( Context context, Intent intent ) 
    {
        Utils.logf( ""StatusReceiver::onReceive called: "" + intent.toString() );
    }

}
",False,4,19,0,0,6,6,0,1,L1
19,org.eehouse.android.xw4.BoardView.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.view.View;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.Bitmap;
import android.content.Context;
import android.util.AttributeSet;
import org.eehouse.android.xw4.jni.*;
import android.view.MotionEvent;
import android.graphics.drawable.Drawable;
import android.content.res.Resources;
import android.graphics.Paint.FontMetricsInt;
import android.os.Handler;
import java.nio.IntBuffer;

import junit.framework.Assert;

public class BoardView extends View implements DrawCtx, BoardHandler,
                                               SyncedDraw {
    private static final int k_miniTextSize = 24;
    private static final int k_miniPaddingH = 2;
    private static final int k_miniPaddingV = 2;
    private static final float MIN_FONT_DIPS = 14.0f;

    private Context m_context;
    private Paint m_drawPaint;
    private Paint m_fillPaint;
    private Paint m_strokePaint;
    private int m_defaultFontHt;
    private int m_mediumFontHt;
    private Paint m_tileStrokePaint;
    private int m_jniGamePtr;
    private CurGameInfo m_gi;
    private int m_layoutWidth;
    private int m_layoutHeight;
    private Bitmap m_bitmap;    // the board
    private Canvas m_canvas;    // owns the bitmap
    private int m_trayOwner;
    private Rect m_valRect;
    private Rect m_letterRect;
    private Drawable m_rightArrow;
    private Drawable m_downArrow;
    private Drawable m_origin;
    private int m_left, m_top;
    private JNIThread m_jniThread;
    private String[][] m_scores;
    private String[] m_dictChars;
    private Rect m_boundsScratch;
    private String m_remText;
    private int m_dictPtr = 0;
    private int m_lastSecsLeft;
    private Handler m_viewHandler;

    // FontDims: exists to translate space available to the largest
    // font we can draw within that space taking advantage of our use
    // being limited to a known small subset of glyphs.  We need two
    // numbers from this: the textHeight to pass to Paint.setTextSize,
    // and the descent to use when drawing.  Both can be calculated
    // proportionally.  We know the ht we passed to Paint to get the
    // height we've now measured; that gives a percent to multiply any
    // future wantHt by.  Ditto for the descent
    private class FontDims {
        FontDims( float askedHt, int topRow, int bottomRow, float width ) {
            // Utils.logf( ""FontDims(): askedHt="" + askedHt );
            // Utils.logf( ""FontDims(): topRow="" + topRow );
            // Utils.logf( ""FontDims(): bottomRow="" + bottomRow );
            // Utils.logf( ""FontDims(): width="" + width );
            float gotHt = bottomRow - topRow + 1;
            m_htProportion = gotHt / askedHt;
            Assert.assertTrue( (bottomRow+1) >= askedHt );
            float descent = (bottomRow+1) - askedHt;
            Utils.logf( ""descent: "" + descent );
            m_descentProportion = descent / askedHt;
            Assert.assertTrue( m_descentProportion >= 0 );
            m_widthProportion = width / askedHt;
            // Utils.logf( ""m_htProportion: "" + m_htProportion );
            // Utils.logf( ""m_descentProportion: "" + m_descentProportion );
        }
        private float m_htProportion;
        private float m_descentProportion;
        private float m_widthProportion;
        int heightFor( int ht ) { return (int)(ht / m_htProportion); }
        int descentFor( int ht ) { return (int)(ht * m_descentProportion); }
        int widthFor( int width ) { return (int)(width / m_widthProportion); }
    }
    FontDims m_fontDims;

    private static final int BLACK = 0xFF000000;
    private static final int WHITE = 0xFFFFFFFF;
    private static final int GREY = 0xFF7F7F7F;
    private int[] m_bonusColors;
    private int[] m_playerColors;
    private int[] m_otherColors;
    private String[] m_bonusSummaries;

    // called when inflating xml
    public BoardView( Context context, AttributeSet attrs ) 
    {
        super( context, attrs );
        init( context );
    }

    public boolean onTouchEvent( MotionEvent event ) 
    {
        int action = event.getAction();
        int xx = (int)event.getX() - m_left;
        int yy = (int)event.getY() - m_top;
        
        switch ( action ) {
        case MotionEvent.ACTION_DOWN:
            m_jniThread.handle( JNIThread.JNICmd.CMD_PEN_DOWN, xx, yy );
            break;
        case MotionEvent.ACTION_MOVE:
            m_jniThread.handle( JNIThread.JNICmd.CMD_PEN_MOVE, xx, yy );
            break;
        case MotionEvent.ACTION_UP:
            m_jniThread.handle( JNIThread.JNICmd.CMD_PEN_UP, xx, yy );
            break;
        default:
            Utils.logf( ""unknown action: "" + action );
            Utils.logf( event.toString() );
        }

        return true;             // required to get subsequent events
    }

    // This will be called from the UI thread
    @Override
    protected void onDraw( Canvas canvas ) 
    {
        synchronized( this ) {
            if ( layoutBoardOnce() ) {
                canvas.drawBitmap( m_bitmap, m_left, m_top, m_drawPaint );
            }
        }
    }

    private void init( Context context )
    {
        m_context = context;
        final float scale = getResources().getDisplayMetrics().density;
        m_defaultFontHt = (int)(MIN_FONT_DIPS * scale + 0.5f);
        m_mediumFontHt = m_defaultFontHt * 3 / 2;

        m_drawPaint = new Paint();
        m_fillPaint = new Paint( Paint.ANTI_ALIAS_FLAG );
        m_strokePaint = new Paint();
        m_strokePaint.setStyle( Paint.Style.STROKE );
        m_tileStrokePaint = new Paint();
        m_tileStrokePaint.setStyle( Paint.Style.STROKE );
        Utils.logf( ""stroke starts at "" + m_tileStrokePaint.getStrokeWidth() );
        float curWidth = m_tileStrokePaint.getStrokeWidth();
        curWidth *= 2;
        if ( curWidth < 2 ) {
            curWidth = 2;
        }
        m_tileStrokePaint.setStrokeWidth( curWidth );

        Resources res = getResources();
        m_rightArrow = res.getDrawable( R.drawable.rightarrow );
        m_downArrow = res.getDrawable( R.drawable.downarrow );
        m_origin = res.getDrawable( R.drawable.origin );

        m_boundsScratch = new Rect();

        CommonPrefs prefs = CommonPrefs.get(context);
        m_playerColors = prefs.playerColors;
        m_bonusColors = prefs.bonusColors;
        m_otherColors = prefs.otherColors;

        m_bonusSummaries = new String[5];
        int[] ids = { R.string.bonus_l2x_summary,
                      R.string.bonus_w2x_summary ,
                      R.string.bonus_l3x_summary,
                      R.string.bonus_w3x_summary };
        for ( int ii = 0; ii < ids.length; ++ii ) {
            m_bonusSummaries[ ii+1 ] = getResources().getString( ids[ii] );
        }

        m_viewHandler = new Handler();
    }

    private BoardDims figureBoardDims( int width, int height,
                                       CurGameInfo gi )
    {
        BoardDims result = new BoardDims();
        result.width = width;
        result.left = 0;

        int nCells = gi.boardSize;
        int cellSize = width / nCells;
        int maxCellSize = 3 * m_defaultFontHt;
        if ( cellSize > maxCellSize ) {
            cellSize = maxCellSize;

            int boardWidth = nCells * cellSize;
            result.left = (width - boardWidth) / 2;
            result.width = boardWidth;
        }
        result.maxCellSize = maxCellSize;

        result.trayHt = cellSize * 3;
        result.scoreHt = 2 * m_defaultFontHt;
        int wantHt = result.trayHt + result.scoreHt + (cellSize * nCells);
        int nToScroll = 0;
        if ( wantHt <= height ) {
            result.top = (height - wantHt) / 2;
        } else {
            int minTray = 3 * m_defaultFontHt;
            nToScroll = 
                nCells - ((height - minTray - result.scoreHt) / cellSize);
            result.trayHt = 
                height - result.scoreHt - (cellSize * (nCells-nToScroll));
            result.top = 0;
        }

        result.boardHt = cellSize * (nCells-nToScroll);
        result.trayTop = result.scoreHt + result.boardHt;
        result.height = result.scoreHt + result.boardHt + result.trayHt;
        result.cellSize = cellSize;

        if ( gi.timerEnabled ) {
            Paint paint = new Paint();
            paint.setTextSize( m_mediumFontHt );
            paint.getTextBounds( ""-00:00"", 0, 6, m_boundsScratch );
            result.timerWidth = m_boundsScratch.width();
        }

        return result;
    } // figureBoardDims

    private boolean layoutBoardOnce() 
    {
        final int width = getWidth();
        final int height = getHeight();
        boolean layoutDone = width == m_layoutWidth && height == m_layoutHeight;
        if ( layoutDone ) {
            // nothing to do
        } else if ( null == m_gi ) {
            // nothing to do either
        } else {
            m_layoutWidth = width;
            m_layoutHeight = height;
            m_fontDims = null; // force recalc of font
            m_letterRect = null;
            m_valRect = null;

            BoardDims dims = figureBoardDims( width, height, m_gi );
            m_left = dims.left;
            m_top = dims.top;
            
            m_bitmap = Bitmap.createBitmap( 1 + dims.width,
                                            1 + dims.height,
                                            Bitmap.Config.ARGB_8888 );
            m_canvas = new Canvas( m_bitmap );

            // need to synchronize??
            m_jniThread.handle( JNIThread.JNICmd.CMD_LAYOUT, dims );
            m_jniThread.handle( JNIThread.JNICmd.CMD_DRAW );
            layoutDone = true;
        }
        return layoutDone;
    } // layoutBoardOnce

    // BoardHandler interface implementation
    public void startHandling( JNIThread thread, int gamePtr, CurGameInfo gi ) 
    {
        m_jniThread = thread;
        m_jniGamePtr = gamePtr;
        m_gi = gi;
        m_layoutWidth = 0;
        m_layoutHeight = 0;
    }

    // SyncedDraw interface implementation
    public void doJNIDraw()
    {
        boolean drew;
        synchronized( this ) {
            drew = XwJNI.board_draw( m_jniGamePtr );
        }
        if ( !drew ) {
            Utils.logf( ""draw not complete"" );
        }
    }

    public void doIconDraw( int resID, final Rect rect )
    {
        synchronized( this ) {
            if ( null != m_canvas ) {
                if ( 0 == resID ) {
                    clearToBack( rect );
                } else {
                    Drawable icon = getResources().getDrawable( resID );
                    icon.setBounds( rect );
                    icon.draw( m_canvas );
                }
            }
        }
    }

    // DrawCtxt interface implementation
    public boolean scoreBegin( Rect rect, int numPlayers, int[] scores, 
                               int remCount, int dfs )
    {
        clearToBack( rect );
        m_canvas.save( Canvas.CLIP_SAVE_FLAG );
        m_canvas.clipRect(rect);
        m_scores = new String[numPlayers][];
        return true;
    }

    public void measureRemText( Rect r, int nTilesLeft, int[] width, 
                                int[] height ) 
    {
        if ( nTilesLeft > 0 ) {
            // should cache a formatter
            m_remText = String.format( ""%d"", nTilesLeft );
            m_fillPaint.setTextSize( m_mediumFontHt );
            m_fillPaint.getTextBounds( m_remText, 0, m_remText.length(), 
                                       m_boundsScratch );

            int minWidth = m_boundsScratch.width();
            if ( minWidth < 20 ) {
                minWidth = 20; // it's a button; make it bigger
            }
            width[0] = minWidth;
            height[0] = m_boundsScratch.height();
        } else {
            width[0] = height[0] = 0;
        }
    }

    public void drawRemText( Rect rInner, Rect rOuter, int nTilesLeft, 
                             boolean focussed )
    {
        int indx = focussed ? CommonPrefs.COLOR_FOCUS
            : CommonPrefs.COLOR_TILE_BACK;
        fillRect( rOuter, m_otherColors[indx] );

        m_fillPaint.setColor( BLACK );
        drawCentered( m_remText, rInner, null );
    }

    public void measureScoreText( Rect r, DrawScoreInfo dsi, 
                                  int[] width, int[] height )
    {
        String[] scoreInfo = new String[dsi.isTurn?1:2];
        int indx = 0;
        StringBuffer sb = new StringBuffer();

        // If it's my turn I get one line.  Otherwise squeeze into
        // two.

        if ( dsi.isTurn ) {
            sb.append( dsi.name );
            sb.append( "":"" );
        } else {
            scoreInfo[indx++] = dsi.name;
        }
        sb.append( dsi.totalScore );
        if ( dsi.nTilesLeft >= 0 ) {
            sb.append( "":"" );
            sb.append( dsi.nTilesLeft );
        }
        scoreInfo[indx] = sb.toString();
        m_scores[dsi.playerNum] = scoreInfo;

        m_fillPaint.setTextSize( dsi.isTurn? r.height() : m_defaultFontHt );

        int needWidth = 0;
        for ( int ii = 0; ii < scoreInfo.length; ++ii ) {
            m_fillPaint.getTextBounds( scoreInfo[ii], 0, scoreInfo[ii].length(), 
                                       m_boundsScratch );
            if ( needWidth < m_boundsScratch.width() ) {
                needWidth = m_boundsScratch.width();
            }
        }
        if ( needWidth > r.width() ) {
            needWidth = r.width();
        }
        width[0] = needWidth;

        height[0] = r.height();
    }

    public void score_drawPlayer( Rect rInner, Rect rOuter, DrawScoreInfo dsi )
    {
        if ( 0 != (dsi.flags & CELL_ISCURSOR) ) {
            fillRect( rOuter, m_otherColors[CommonPrefs.COLOR_FOCUS] );
        }
        String[] texts = m_scores[dsi.playerNum];
        m_fillPaint.setColor( m_playerColors[dsi.playerNum] );

        Rect rect = new Rect( rOuter );
        int height = rect.height() / texts.length;
        rect.bottom = rect.top + height;
        for ( String text : texts ) {
            drawCentered( text, rect, null );
            rect.offset( 0, height );
        }
    }

    public void drawTimer( Rect rect, int player, int secondsLeft )
    {
        if ( null != m_canvas && m_lastSecsLeft != secondsLeft ) {
            m_lastSecsLeft = secondsLeft;

            String negSign = secondsLeft < 0? ""-"":"""";
            secondsLeft = Math.abs( secondsLeft );
            String time = String.format( ""%s%d:%02d"", negSign, secondsLeft/60, 
                                         secondsLeft%60 );

            clearToBack( rect );
            m_fillPaint.setColor( m_playerColors[player] );

            Rect shorter = new Rect( rect );
            shorter.inset( 0, shorter.height() / 5 );
            drawCentered( time, shorter, null );

            m_jniThread.handle( JNIThread.JNICmd.CMD_DRAW );
        }
    }

    public boolean drawCell( final Rect rect, String text, int tile, int owner, 
                             int bonus, int hintAtts, final int flags ) 
    {
        int backColor;
        boolean empty = 0 != (flags & (CELL_DRAGSRC|CELL_ISEMPTY));
        boolean pending = 0 != (flags & CELL_HIGHLIGHT);
        String bonusStr = null;

        figureFontDims();

        if ( owner < 0 ) {
            owner = 0;
        }
        int foreColor = m_playerColors[owner];

        if ( 0 != (flags & CELL_ISCURSOR) ) {
            backColor = m_otherColors[CommonPrefs.COLOR_FOCUS];
        } else if ( empty ) {
            if ( 0 == bonus ) {
                backColor = m_otherColors[CommonPrefs.COLOR_BKGND];
            } else {
                backColor = m_bonusColors[bonus];
                if ( CommonPrefs.getShowBonusSumms(m_context) ) {
                    bonusStr = m_bonusSummaries[bonus];
                }
            }
        } else if ( pending ) {
            backColor = BLACK;
            foreColor = WHITE;
        } else {
            backColor = m_otherColors[CommonPrefs.COLOR_TILE_BACK];
        }

        fillRect( rect, backColor );

        if ( empty ) {
            if ( (CELL_ISSTAR & flags) != 0 ) {
                m_origin.setBounds( rect );
                m_origin.draw( m_canvas );
            } else if ( null != bonusStr ) {
                m_fillPaint.setColor( GREY );
                Rect brect = new Rect( rect );
                brect.inset( 0, (brect.height() - m_defaultFontHt)/2 );
                drawCentered( bonusStr, brect, m_fontDims );
            }
        } else {
            m_fillPaint.setColor( foreColor );
            drawCentered( text, rect, m_fontDims );
        }

        if ( (CELL_ISBLANK & flags) != 0 ) {
            markBlank( rect, pending );
        }
        // frame the cell
        m_canvas.drawRect( rect, m_strokePaint );

        drawCrosshairs( rect, flags );
        
        return true;
    } // drawCell

    public void drawBoardArrow( Rect rect, int bonus, boolean vert, 
                                int hintAtts, int flags )
    {
        rect.inset( 2, 2 );
        Drawable arrow = vert? m_downArrow : m_rightArrow;
        arrow.setBounds( rect );
        arrow.draw( m_canvas );
    }

    public boolean trayBegin ( Rect rect, int owner, int dfs ) 
    {
        m_trayOwner = owner;
        return true;
    }

    public void drawTile( Rect rect, String text, int val, int flags ) 
    {
        drawTileImpl( rect, text, val, flags, true );
    }

    public void drawTileMidDrag( Rect rect, String text, int val, int owner, 
                                 int flags ) 
    {
        drawTileImpl( rect, text, val, flags, false );
    }

    public void drawTileBack( Rect rect, int flags ) 
    {
        drawTileImpl( rect, ""?"", -1, flags, true );
    }

    public void drawTrayDivider( Rect rect, int flags ) 
    {
        boolean isCursor = 0 != (flags & CELL_ISCURSOR);
        boolean selected = 0 != (flags & CELL_HIGHLIGHT);

        int backColor = isCursor? m_otherColors[CommonPrefs.COLOR_FOCUS]:WHITE;
        rect.inset( 0, 1 );
        fillRect( rect, backColor );

        rect.inset( rect.width()/4, 0 );
        if ( selected ) {
            m_canvas.drawRect( rect, m_strokePaint );
        } else {
            fillRect( rect, BLACK );
        }
    }

    public void score_pendingScore( Rect rect, int score, int playerNum, 
                                    int flags ) 
    {
        String text = score >= 0? String.format( ""%d"", score ) : ""??"";
        ++rect.top;
        fillRect( rect, (0 == (flags & CELL_ISCURSOR)) 
                  ? WHITE : m_otherColors[CommonPrefs.COLOR_FOCUS] );
        m_fillPaint.setColor( m_playerColors[playerNum] );

        rect.bottom -= rect.height() / 2;
        drawCentered( text, rect, null );

        rect.offset( 0, rect.height() );
        drawCentered( getResources().getString( R.string.pts ), rect, null );
    }

    public String getMiniWText ( int textHint )
    {
        int id = 0;
        switch( textHint ) {
        case BONUS_DOUBLE_LETTER:
            id = R.string.bonus_l2x;
            break;
        case BONUS_DOUBLE_WORD:
            id = R.string.bonus_w2x;
            break;
        case BONUS_TRIPLE_LETTER:
            id = R.string.bonus_l3x;
            break;
        case BONUS_TRIPLE_WORD:
            id = R.string.bonus_w3x;
            break;
        case INTRADE_MW_TEXT:
            id = R.string.trading_text;
            break;
        default:
            Assert.fail();
        }
        return getResources().getString( id );
    }

    public void measureMiniWText( String str, int[] width, int[] height )
    {
        m_fillPaint.setTextSize( k_miniTextSize );
        FontMetricsInt fmi = m_fillPaint.getFontMetricsInt();
        int lineHeight = -fmi.top + fmi.leading;
        
        String[] lines = str.split(""\n"");
        height[0] = (lines.length * lineHeight) + (2 * k_miniPaddingV);

        int maxWidth = 0;
        for ( String line : lines ) {
            m_fillPaint.getTextBounds( line, 0, line.length(), m_boundsScratch );
            int thisWidth = m_boundsScratch.width();
            if ( maxWidth < thisWidth ) {
                maxWidth = thisWidth;
            }
        }
        width[0] = maxWidth + (k_miniPaddingH * 2);
    }

    public void drawMiniWindow( String text, Rect rect )
    {
        clearToBack( rect );

        m_fillPaint.setTextSize( k_miniTextSize );
        m_fillPaint.setTextAlign( Paint.Align.CENTER );
        m_fillPaint.setColor( BLACK );

        String[] lines = text.split(""\n"");
        int lineHt = rect.height() / lines.length;
        int bottom = rect.top + lineHt
            - m_fillPaint.getFontMetricsInt().descent;
        int center = rect.left + (rect.width() / 2);

        for ( String line : lines ) {
            m_canvas.drawText( line, center, bottom, m_fillPaint );
            bottom += lineHt;
        }

        m_canvas.drawRect( rect, m_strokePaint );

        // Unlike other draw methods, this one is usually called from
        // outside board_draw and so doesn't benefit from the canvas
        // getting moved to the board.  Set that up manually.  Sending
        // DRAW cmd as I used to do draws *everything* and may well
        // overwrite the miniwindow.
        m_viewHandler.post( new Runnable() {
                public void run() {
                    BoardView.this.invalidate();
                }
            } );
    }

    public void objFinished( /*BoardObjectType*/int typ, Rect rect, int dfs )
    {
        if ( DrawCtx.OBJ_SCORE == typ ) {
            m_canvas.restoreToCount(1); // in case new canvas...
        }
    }

    public void dictChanged( int dictPtr )
    {
        if ( m_dictPtr != dictPtr ) {
            if ( m_dictPtr == 0 || 
                 !XwJNI.dict_tilesAreSame( m_dictPtr, dictPtr ) ) {
                m_fontDims = null;
                m_dictChars = XwJNI.dict_getChars( dictPtr );
            }
            m_dictPtr = dictPtr;
        }
    }

    private void drawTileImpl( Rect rect, String text, int val, 
                               int flags, boolean clearBack )
    {
        // boolean valHidden = (flags & CELL_VALHIDDEN) != 0;
        boolean notEmpty = (flags & CELL_ISEMPTY) == 0;
        boolean isCursor = (flags & CELL_ISCURSOR) != 0;

        m_canvas.save( Canvas.CLIP_SAVE_FLAG );
        rect.top += 1;
        m_canvas.clipRect( rect );

        if ( clearBack ) {
            clearToBack( rect );
        }

        if ( isCursor || notEmpty ) {

            if ( clearBack ) {
                int indx = isCursor? CommonPrefs.COLOR_FOCUS 
                    : CommonPrefs.COLOR_TILE_BACK;
                fillRect( rect, m_otherColors[indx] );
            }

            m_fillPaint.setColor( m_playerColors[m_trayOwner] );

            if ( notEmpty ) {
                positionDrawTile( rect, text, val );

                m_canvas.drawRect( rect, m_tileStrokePaint); // frame
                if ( 0 != (flags & CELL_HIGHLIGHT) ) {
                    rect.inset( 2, 2 );
                    m_canvas.drawRect( rect, m_tileStrokePaint ); // frame
                }
            }
        }
        m_canvas.restoreToCount(1); // in case new canvas....
    } // drawTileImpl

    private void drawCentered( String text, Rect rect, FontDims fontDims ) 
    {
        int descent = -1;
        int textSize;
        if ( null == fontDims ) {
            textSize = rect.height() - 2;
        } else {
            int height = rect.height() - 4; // borders and padding, 2 each 
            descent = fontDims.descentFor( height );
            textSize = fontDims.heightFor( height );
            // Utils.logf( ""using descent: "" + descent + "" and textSize: "" 
            //             + textSize + "" in height "" + height );
        }
        m_fillPaint.setTextSize( textSize );
        if ( descent == -1 ) {
            descent = m_fillPaint.getFontMetricsInt().descent;
        }
        descent += 2;

        m_fillPaint.getTextBounds( text, 0, text.length(), m_boundsScratch );
        if ( m_boundsScratch.width() > rect.width() ) {
            m_fillPaint.setTextAlign( Paint.Align.LEFT );
            drawScaled( text, rect, descent );
        } else {
            int bottom = rect.bottom - descent;
            int center = rect.left + ( rect.width() / 2 );
            m_fillPaint.setTextAlign( Paint.Align.CENTER );
            m_canvas.drawText( text, center, bottom, m_fillPaint );
        }
    }

    private void drawScaled( String text, final Rect rect, int descent )
    {
        Rect local = new Rect();
        m_fillPaint.getTextBounds( text, 0, text.length(), local );
        local.bottom = rect.height();

        Bitmap bitmap = Bitmap.createBitmap( local.width(),
                                             rect.height(), 
                                             Bitmap.Config.ARGB_8888 );

        Canvas canvas = new Canvas( bitmap );
        int bottom = local.bottom - descent;
        canvas.drawText( text, 0, bottom, m_fillPaint );

        m_canvas.drawBitmap( bitmap, local, rect, m_drawPaint );
    }

    private void positionDrawTile( final Rect rect, String text, int val )
    {
        figureFontDims();

        if ( null != text ) {
            if ( null == m_letterRect ) {
                m_letterRect = new Rect( 0, 0, rect.width() * 3 / 4, 
                                         rect.height() * 3 / 4 );
            }
            m_letterRect.offsetTo( rect.left+2, rect.top+2 );
            drawCentered( text, m_letterRect, m_fontDims );
        }

        if ( val >= 0 ) {
            if ( null == m_valRect ) {
                m_valRect = new Rect( 0, 0, rect.width() / 4, rect.height() / 4 );
                m_valRect.inset( 2, 2 );
            }
            m_valRect.offsetTo( rect.right - (rect.width() / 4),
                                rect.bottom - (rect.height() / 4) );
            text = String.format( ""%d"", val );
            m_fillPaint.setTextSize( m_valRect.height() );
            m_fillPaint.setTextAlign( Paint.Align.RIGHT );
            m_canvas.drawText( text, m_valRect.right, m_valRect.bottom, 
                               m_fillPaint );
        }
    }

    private void drawCrosshairs( final Rect rect, final int flags )
    {
        int color = m_otherColors[CommonPrefs.COLOR_FOCUS];
        if ( 0 != (flags & CELL_CROSSHOR) ) {
            Rect hairRect = new Rect( rect );
            hairRect.inset( 0, hairRect.height() / 3 );
            fillRect( hairRect, color );
        }
        if ( 0 != (flags & CELL_CROSSVERT) ) {
            Rect hairRect = new Rect( rect );
            hairRect.inset( hairRect.width() / 3, 0 );
            fillRect( hairRect, color );
        }
    }

    private void fillRect( Rect rect, int color )
    {
        m_fillPaint.setColor( color );
        m_canvas.drawRect( rect, m_fillPaint );
    }

    private void clearToBack( Rect rect ) 
    {
        fillRect( rect, m_otherColors[CommonPrefs.COLOR_BKGND] );
    }

    private void figureFontDims()
    {
        if ( null == m_fontDims ) {
            final int ht = 24;
            final int width = 20;

            Paint paint = new Paint(); // CommonPrefs.getFontFlags()??
            paint.setStyle( Paint.Style.STROKE );
            paint.setTextAlign( Paint.Align.LEFT );
            paint.setTextSize( ht );

            Bitmap bitmap = Bitmap.createBitmap( width, (ht*3)/2, 
                                                 Bitmap.Config.ARGB_8888 );
            Canvas canvas = new Canvas( bitmap );

            // FontMetrics fmi = paint.getFontMetrics();
            // Utils.logf( ""ascent: "" + fmi.ascent );
            // Utils.logf( ""bottom: "" + fmi.bottom );
            // Utils.logf( ""descent: "" + fmi.descent );
            // Utils.logf( ""leading: "" + fmi.leading );
            // Utils.logf( ""top : "" + fmi.top );

            // Utils.logf( ""using as baseline: "" + ht );

            Rect bounds = new Rect();
            int maxWidth = 0;
            for ( String str : m_dictChars ) {
                if ( str.length() == 1 && str.charAt(0) >= 32 ) {
                    canvas.drawText( str, 0, ht, paint );
                    paint.getTextBounds( str, 0, 1, bounds );
                    if ( maxWidth < bounds.right ) {
                        maxWidth = bounds.right;
                    }
                }
            }

            // for ( int row = 0; row < bitmap.getHeight(); ++row ) {
            //     StringBuffer sb = new StringBuffer( bitmap.getWidth() );
            //     for ( int col = 0; col < bitmap.getWidth(); ++col ) {
            //         int pixel = bitmap.getPixel( col, row );
            //         sb.append( pixel==0? ""."" : ""X"" );
            //     }
            //     Utils.logf( sb.append(row).toString() );
            // }

            int topRow = 0;
            findTop:
            for ( int row = 0; row < bitmap.getHeight(); ++row ) {
                for ( int col = 0; col < bitmap.getWidth(); ++col ) {
                    if ( 0 != bitmap.getPixel( col, row ) ){
                        topRow = row;
                        break findTop;
                    }
                }
            }

            int bottomRow = 0;
            findBottom:
            for ( int row = bitmap.getHeight() - 1; row > topRow; --row ) {
                for ( int col = 0; col < bitmap.getWidth(); ++col ) {
                    if ( 0 != bitmap.getPixel( col, row ) ){
                        bottomRow = row;
                        break findBottom;
                    }
                }
            }
        
            m_fontDims = new FontDims( ht, topRow, bottomRow, maxWidth );
        }
    } // figureFontDims

    private void markBlank( final Rect rect, boolean whiteOnBlack )
    {
        RectF oval = new RectF( rect.left, rect.top, rect.right, rect.bottom );
        int curColor = 0;
        if ( whiteOnBlack ) {
            curColor = m_strokePaint.getColor();
            m_strokePaint.setColor( WHITE );
        }
        m_canvas.drawArc( oval, 0, 360, false, m_strokePaint );
        if ( whiteOnBlack ) {
            m_strokePaint.setColor( curColor );
        }
    }
}",True,13,25,1,1,3,10,1,9,L1
20,org.eehouse.android.xw4.DictImportActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.os.Bundle;
import android.os.AsyncTask;
import android.content.Intent;
import android.net.Uri;
import android.view.Window;
import android.widget.ProgressBar;
import android.widget.TextView;
import java.io.InputStream;
import java.io.File;
import java.net.URI;

import junit.framework.Assert;

public class DictImportActivity extends Activity {

    private class DownloadFilesTask extends AsyncTask<Uri, Integer, Long> {
        @Override
        protected Long doInBackground( Uri... uris )
        {
            int count = uris.length;
            Assert.assertTrue( 1 == count );
            long totalSize = 0;
            for ( int ii = 0; ii < count; ii++ ) {
                Uri uri = uris[ii];
                Utils.logf( ""trying %s"", uri );

                try {
                    URI jUri = new URI( uri.getScheme(), 
                                        uri.getSchemeSpecificPart(), 
                                        uri.getFragment() );
                    InputStream is = jUri.toURL().openStream();
                    saveDict( is, uri.getPath() );
                } catch ( java.net.URISyntaxException use ) {
                    Utils.logf( ""URISyntaxException: %s"" + use.toString() );
                } catch ( java.net.MalformedURLException mue ) {
                    Utils.logf( ""MalformedURLException: %s"" + mue.toString() );
                } catch ( java.io.IOException ioe ) {
                    Utils.logf( ""IOException: %s"" + ioe.toString() );
                }
            }
            return totalSize;
        }

        @Override
        protected void onPostExecute( Long result )
        {
            Utils.logf( ""onPostExecute passed %d"", result );
            finish();
        }
    } // class DownloadFilesTask

	@Override
	protected void onCreate( Bundle savedInstanceState ) 
    {
		super.onCreate( savedInstanceState );

		requestWindowFeature( Window.FEATURE_LEFT_ICON );
		setContentView( R.layout.import_dict );
		getWindow().setFeatureDrawableResource( Window.FEATURE_LEFT_ICON,
                                                R.drawable.icon48x48 );

		ProgressBar progressBar = (ProgressBar)findViewById( R.id.progress_bar );

		Intent intent = getIntent();
		Uri uri = intent.getData();
		if ( null != uri) {
			if ( null != intent.getType() 
                 && intent.getType().equals( ""application/x-xwordsdict"" ) ) {
                Utils.logf( ""based on MIME type"" );
                new DownloadFilesTask().execute( uri );
            } else if ( uri.toString().endsWith( "".xwd"" ) ) {
                String fmt = getString( R.string.downloading_dictf );
                String txt = String.format( fmt, basename( uri.getPath()) );
                TextView view = (TextView)findViewById( R.id.dwnld_message );
                view.setText( txt );
                new DownloadFilesTask().execute( uri );
			} else {
                Utils.logf( ""bogus intent: %s/%s"", intent.getType(), uri );
				finish();
			}
        }
	}

    private void saveDict( InputStream inputStream, String path )
    {
        try {
            GameUtils.saveDict( this, basename(path), inputStream );
            inputStream.close();
        } catch ( java.io.IOException ioe ) {
            Utils.logf( ""IOException: %s"" + ioe.toString() );
        }
    }

    private String basename( String path )
    {
        return new File(path).getName();
    }
}


",True,12,19,0,0,4,9,0,2,L1
21,org.eehouse.android.xw4.Toolbar.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.content.Context;
import android.view.View;
import android.widget.LinearLayout;
import android.widget.ImageButton;
//import android.view.LayoutInflater;
//import java.util.HashMap;
//import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;

public class Toolbar {

    private static class TBButtonInfo {
        public TBButtonInfo( int... ids ) {
            m_ids = ids;
        }
        public int m_ids[];
    }

    public static final int BUTTON_HINT_PREV = 0;
    public static final int BUTTON_HINT_NEXT = 1;
    public static final int BUTTON_FLIP = 2;
    public static final int BUTTON_JUGGLE = 3;
    public static final int BUTTON_ZOOM = 4;
    public static final int BUTTON_UNDO = 5;
    public static final int BUTTON_VALUES = 6;

    private static TBButtonInfo[] s_buttonInfo = {
        // BUTTON_HINT_PREV
        new TBButtonInfo(R.id.prevhint_button_horizontal, 
                         R.id.prevhint_button_vertical),
        // BUTTON_HINT_NEXT
        new TBButtonInfo(R.id.nexthint_button_horizontal, 
                         R.id.nexthint_button_vertical),
        // BUTTON_FLIP
        new TBButtonInfo(R.id.flip_button_horizontal,
                         R.id.flip_button_vertical),
        // BUTTON_JUGGLE
        new TBButtonInfo( R.id.shuffle_button_horizontal,
                          R.id.shuffle_button_vertical ),
        // BUTTON_ZOOM
        new TBButtonInfo( R.id.zoom_button_horizontal,
                          R.id.zoom_button_vertical ),
        // BUTTON_UNDO
        new TBButtonInfo( R.id.undo_button_horizontal,
                          R.id.undo_button_vertical ),
        // BUTTON_VALUES
        new TBButtonInfo( R.id.values_button_horizontal,
                          R.id.values_button_vertical ),
    };

    private Activity m_activity;
    private LinearLayout m_horLayout;
    private LinearLayout m_vertLayout;

    private enum ORIENTATION { ORIENT_UNKNOWN,
            ORIENT_PORTRAIT,
            ORIENT_LANDSCAPE,
            };
    private ORIENTATION m_curOrient = ORIENTATION.ORIENT_UNKNOWN;

    public Toolbar( Activity activity, View horLayout, View vertLayout )
    {
        m_activity = activity;
        m_horLayout = (LinearLayout)horLayout;
        m_vertLayout = (LinearLayout)vertLayout;
    }

    public void setListener( int index, View.OnClickListener listener )
    {
        TBButtonInfo info = s_buttonInfo[index];
        for ( int id : info.m_ids ) {
            ImageButton button = (ImageButton)m_activity.findViewById( id );
            button.setOnClickListener( listener );
        }
    }

    public void orientChanged( boolean landscape )
    {
        if ( landscape && m_curOrient == ORIENTATION.ORIENT_LANDSCAPE ) {
            // do nothing
        } else if ( !landscape && m_curOrient == ORIENTATION.ORIENT_PORTRAIT ) {
            // do nothing
        } else {
            LinearLayout prevLayout, nextLayout;
            if ( landscape ) {
                m_curOrient = ORIENTATION.ORIENT_LANDSCAPE;
                prevLayout = m_horLayout;
                nextLayout = m_vertLayout;
            } else {
                m_curOrient = ORIENTATION.ORIENT_PORTRAIT;
                prevLayout = m_vertLayout;
                nextLayout = m_horLayout;
            }

            prevLayout.setVisibility( View.GONE );
            nextLayout.setVisibility( View.VISIBLE );
        }
    }

    public void update( int index, int enable )
    {
        boolean show = enable!=0;
        TBButtonInfo info = s_buttonInfo[index];
        int vis = enable != 0 ? View.VISIBLE : View.GONE;

        ImageButton button;
        for ( int id : info.m_ids ) {
            button = (ImageButton)m_activity.findViewById( id );
            button.setVisibility( vis );
        }
    }

}
",True,38,6,2,3,0,0,2,0,L1
22,org.eehouse.android.xw4.DBHelper.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteDatabase;

public class DBHelper extends SQLiteOpenHelper {

    public static final String TABLE_NAME = ""summaries"";
    private static final String DB_NAME = ""xwdb"";
    private static final int DB_VERSION = 3;

    public static final String FILE_NAME = ""FILE_NAME"";
    public static final String NUM_MOVES = ""NUM_MOVES"";
    public static final String GAME_OVER = ""GAME_OVER"";
    public static final String SCORES = ""SCORES"";
    // GAMEID: this isn't used yet but we'll want it to look up games
    // for which messages arrive.  Add now while changing the DB
    // format
    public static final String GAMEID = ""GAMEID"";
    public static final String SNAPSHOT = ""SNAPSHOT"";
    public static final String CONTYPE = ""CONTYPE"";
    public static final String ROOMNAME = ""ROOMNAME"";
    public static final String SMSPHONE = ""SMSPHONE"";
    // not used yet
    public static final String CREATE_TIME = ""CREATE_TIME"";
    // not used yet
    public static final String LASTPLAY_TIME = ""LASTPLAY_TIME"";


    public DBHelper( Context context )
    {
        super( context, DB_NAME, null, DB_VERSION );
    }

    @Override
    public void onCreate( SQLiteDatabase db ) 
    {
        db.execSQL( ""CREATE TABLE "" + TABLE_NAME + "" (""
                    + FILE_NAME + "" TEXT PRIMARY KEY,""
                    + NUM_MOVES + "" INTEGER,""
                    + GAME_OVER + "" INTEGER,""

                    + CONTYPE    + "" INTEGER,""
                    + ROOMNAME   + "" TEXT,""
                    + SMSPHONE   + "" TEXT,""
                    + SCORES     + "" TEXT,""
                    + GAMEID     + "" INTEGER,""

                    + CREATE_TIME + "" INTEGER,""
                    + LASTPLAY_TIME + "" INTEGER,""

                    + SNAPSHOT   + "" BLOB""
                    + "");"" );
    }

    @Override
    public void onUpgrade( SQLiteDatabase db, int oldVersion, int newVersion ) 
    {
        Utils.logf( ""onUpgrade: old: %d; new: %d"", oldVersion, newVersion );
        db.execSQL( ""DROP TABLE "" + TABLE_NAME + "";"" );
        onCreate( db );
    }
}
",False,32,18,0,0,6,6,1,1,L0
23,org.eehouse.android.xw4.jni.DrawScoreInfo.java,"/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

public class DrawScoreInfo {
    public String name;
    public int playerNum;
    public int totalScore;
    public int nTilesLeft;   /* < 0 means don't use */
    public int flags;        // was CellFlags; use CELL_ constants above
    public boolean isTurn;
    public boolean selected;
    public boolean isRemote;
    public boolean isRobot;
};
",False,1,27,6,9,0,0,2,0,L0
24,org.eehouse.android.xw4.jni.CurGameInfo.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import java.util.Random;
import android.content.Context;
import junit.framework.Assert;

import org.eehouse.android.xw4.Utils;
import org.eehouse.android.xw4.GameUtils;
import org.eehouse.android.xw4.R;

public class CurGameInfo {

    public static final int MAX_NUM_PLAYERS = 4;

    public enum XWPhoniesChoice { PHONIES_IGNORE, PHONIES_WARN, PHONIES_DISALLOW };
    public enum DeviceRole { SERVER_STANDALONE, SERVER_ISSERVER, SERVER_ISCLIENT };

    public String dictName;
    public LocalPlayer[] players;
    public int gameID;
    public int gameSeconds;
    public int nPlayers;
    public int boardSize;
    public DeviceRole serverRole;

    public boolean hintsNotAllowed;
    public boolean timerEnabled;
    public boolean allowPickTiles;
    public boolean allowHintRect;
    public int robotSmartness;
    public XWPhoniesChoice phoniesAction;
    public boolean confirmBTConnect;   /* only used for BT */

    private int[] m_visiblePlayers;
    private int m_nVisiblePlayers;
    private boolean m_inProgress;

    public CurGameInfo( Context context ) {
        m_inProgress = false;
        nPlayers = 2;
        gameSeconds = 60 * nPlayers *
            CommonPrefs.getDefaultPlayerMinutes( context );
        boardSize = CommonPrefs.getDefaultBoardSize( context );
        players = new LocalPlayer[MAX_NUM_PLAYERS];
        serverRole = DeviceRole.SERVER_STANDALONE;
        dictName = CommonPrefs.getDefaultDict( context );
        hintsNotAllowed = false;
        phoniesAction = CommonPrefs.getDefaultPhonies( context );
        timerEnabled = CommonPrefs.getDefaultTimerEnabled( context );
        allowPickTiles = false;
        allowHintRect = false;
        robotSmartness = 1;

        // Always create MAX_NUM_PLAYERS so jni code doesn't ever have
        // to cons up a LocalPlayer instance.
        int ii;
        for ( ii = 0; ii < MAX_NUM_PLAYERS; ++ii ) {
            players[ii] = new LocalPlayer( context, ii );
        }

        figureVisible();
    }

    public CurGameInfo( CurGameInfo src )
    {
        m_inProgress = src.m_inProgress;
        gameID = src.gameID;
        nPlayers = src.nPlayers;
        gameSeconds = src.gameSeconds;
        boardSize = src.boardSize;
        players = new LocalPlayer[MAX_NUM_PLAYERS];
        serverRole = src.serverRole;
        dictName = src.dictName;
        hintsNotAllowed = src.hintsNotAllowed;
        phoniesAction = src.phoniesAction;
        timerEnabled = src.timerEnabled;
        allowPickTiles = src.allowPickTiles;
        allowHintRect = src.allowHintRect;
        robotSmartness = src.robotSmartness;
        
        int ii;
        for ( ii = 0; ii < MAX_NUM_PLAYERS; ++ii ) {
            players[ii] = new LocalPlayer( src.players[ii] );
        }

        figureVisible();
    }

    public void setServerRole( DeviceRole newRole )
    {
        serverRole = newRole;
        figureVisible();
        if ( m_nVisiblePlayers == 0 ) { // must always be one visible player
            Assert.assertFalse( players[0].isLocal );
            players[0].isLocal = true;
            figureVisible();
        }
    }

    public void setInProgress( boolean inProgress )
    {
        m_inProgress = inProgress;
        figureVisible();
    }

    /** return true if any of the changes made would invalide a game
     * in progress, i.e. require that it be restarted with the new
     * params.  E.g. changing a player to a robot is harmless for a
     * local-only game but illegal for a connected one.
     */
    public boolean changesMatter( final CurGameInfo other )
    {
        boolean matter = nPlayers != other.nPlayers
            || serverRole != other.serverRole
            || !dictName.equals( other.dictName )
            || boardSize != other.boardSize
            || hintsNotAllowed != other.hintsNotAllowed
            || allowPickTiles != other.allowPickTiles
            || phoniesAction != other.phoniesAction;

        if ( !matter && DeviceRole.SERVER_STANDALONE != serverRole ) {
            for ( int ii = 0; ii < nPlayers; ++ii ) {
                LocalPlayer me = players[ii];
                LocalPlayer him = other.players[ii];
                matter = me.isRobot != him.isRobot
                    || me.isLocal != him.isLocal
                    || !me.name.equals( him.name );
                if ( matter ) {
                    break;
                }
            }
        }

        return matter;
    }

    public int remoteCount()
    {
        figureVisible();
        int count = 0;
        for ( int ii = 0; ii < m_nVisiblePlayers; ++ii ) {
            if ( !players[m_visiblePlayers[ii]].isLocal ) {
                ++count;
            }
        }
        return count;
    }

    /**
     * fixup: if we're pretending some players don't exist, move them
     * up and make externally (i.e. in the jni world) visible fields
     * consistent.
     */
    public void fixup()
    {
        if ( m_nVisiblePlayers < nPlayers ) {
            Assert.assertTrue( serverRole == DeviceRole.SERVER_ISCLIENT );
            
            for ( int ii = 0; ii < m_nVisiblePlayers; ++ii ) {
                Assert.assertTrue( m_visiblePlayers[ii] >= ii );
                if ( m_visiblePlayers[ii] != ii ) {
                    LocalPlayer tmp = players[ii];
                    players[ii] = players[m_visiblePlayers[ii]];
                    players[m_visiblePlayers[ii]] = tmp;
                    m_visiblePlayers[ii] = ii;
                }
            }

            nPlayers = m_nVisiblePlayers;
        }

        if ( !m_inProgress && serverRole != DeviceRole.SERVER_ISSERVER ) {
            for ( int ii = 0; ii < nPlayers; ++ii ) {
                players[ii].isLocal = true;
            }
        }
    }

    public String[] visibleNames( Context context )
    {
        String[] names = new String[m_nVisiblePlayers];
        for ( int ii = 0; ii < m_nVisiblePlayers; ++ii ) {
            LocalPlayer lp = players[m_visiblePlayers[ii]];
            if ( lp.isLocal || serverRole == DeviceRole.SERVER_STANDALONE ) {
                names[ii] = lp.name;
                if ( lp.isRobot ) {
                    names[ii] += context.getString( R.string.robot_name );
                }
            } else {
                names[ii] = context.getString( R.string.guest_name );
            }
        }
        return names;
    }

    public String summarizePlayers( Context context, GameSummary summary )
    {
        StringBuffer sb = new StringBuffer();
        String vsString = context.getString( R.string.vs );
        for ( int ii = 0; ; ) {

            int score = 0;
            try {
                // scores can be null, but I've seen array OOB too.
                score = summary.scores[ii];
            } catch ( Exception ex ){}

            sb.append( String.format( ""%s(%d)"", players[ii].name, score ) );
            if ( ++ii >= nPlayers ) {
                break;
            }
            sb.append( String.format( "" %s "", vsString ) );
        }
        return sb.toString();
    }

    public String summarizeRole( Context context, GameSummary summary )
    {
        String result = null;
        if ( null != summary ) {
            DeviceRole role = serverRole;
            if ( role != DeviceRole.SERVER_STANDALONE ) {
                if ( null != summary.conType ) {
                    boolean isHost = role == DeviceRole.SERVER_ISSERVER;
                    boolean justListening = false;
                    int roleID = isHost ? R.string.role_host : R.string.role_guest;
                    String via;
                    int summaryID;
                    switch ( summary.conType ) {
                    case COMMS_CONN_RELAY:
                        via = summary.roomName;
                        summaryID = R.string.summary_fmt_relay;
                        break;
                    case COMMS_CONN_SMS:
                        via = summary.smsPhone;
                        summaryID = R.string.summary_fmt_sms;
                        justListening = isHost;
                        break;
                    default:
                        summaryID = 0;
                        via = null;
                        Assert.fail();
                    }
                    String fmt = context.getString( justListening?
                                                    R.string.summary_fmt_listening
                                                    : summaryID );
                    String roleStr = context.getString( roleID );
                    if ( justListening ) {
                        result = String.format( fmt, roleStr );
                    } else {
                        result = String.format( fmt, roleStr, via );
                    }
                }
            }
        }
        return result;
    }

    public String summarizeState( Context context, GameSummary summary )
    {
        String result = null;
        if ( summary.gameOver ) {
            result = context.getString( R.string.gameOver );
        } else {
            result = String.format( context.getString(R.string.movesf),
                                    summary.nMoves );
        }
        return result;
    }

    public String summarizeDict( Context context )
    {
        String label = context.getString( R.string.dictionary );
        return label + "" "" + dictName;
    }

    public boolean addPlayer() 
    {
        boolean added = false;
        // We can add either by adding a player, if nPlayers <
        // MAX_NUM_PLAYERS, or by making an unusable player usable.
        if ( nPlayers < MAX_NUM_PLAYERS ) {
            ++nPlayers;
            added = true;
        } else if ( serverRole == DeviceRole.SERVER_ISCLIENT ) {
            for ( int ii = 0; ii < players.length; ++ii ) {
                if ( !players[ii].isLocal ) {
                    players[ii].isLocal = true;
                    added = true;
                    break;
                }
            }
        }
        if ( added ) {
            figureVisible();
        }
        return added;
    }

    public boolean moveUp( int which )
    {
        boolean canMove = which > 0 && which < nPlayers;
        if ( canMove ) {
            LocalPlayer tmp = players[which-1];
            players[which-1] = players[which];
            players[which] = tmp;
        }
        return canMove;
    }

    public boolean moveDown( int which )
    {
        return moveUp( which + 1 );
    }

    public boolean delete( int which )
    {
        boolean canDelete = m_nVisiblePlayers > 1;
        if ( canDelete ) {
            which = m_visiblePlayers[which]; // translate
            LocalPlayer tmp = players[which];
            for ( int ii = which; ii < nPlayers - 1; ++ii ) {
                moveDown( ii );
            }
            --nPlayers;
            players[nPlayers] = tmp;
            figureVisible();
        }
        return canDelete;
    }

    public boolean juggle()
    {
        boolean canJuggle = m_nVisiblePlayers > 1;
        if ( canJuggle ) {
            // for each element, exchange with randomly chocsen from
            // range <= to self.
            Random rgen = new Random();

            for ( int ii = m_nVisiblePlayers - 1; ii > 0; --ii ) {
                // Contrary to docs, nextInt() comes back negative!
                int rand = Math.abs(rgen.nextInt()); 
                int indx = rand % (ii+1);
                if ( indx != ii ) {
                    LocalPlayer tmp = players[m_visiblePlayers[ii]];
                    players[m_visiblePlayers[ii]] 
                        = players[m_visiblePlayers[indx]];
                    players[m_visiblePlayers[indx]] = tmp;
                }
            }
        }
        return canJuggle;
    }

    private void figureVisible()
    {
        if ( null == m_visiblePlayers ) {
            m_visiblePlayers = new int[MAX_NUM_PLAYERS];
        }

        m_nVisiblePlayers = 0;
        for ( int ii = 0; ii < nPlayers; ++ii ) {
            if ( m_inProgress
                 || serverRole != DeviceRole.SERVER_ISCLIENT
                 || players[ii].isLocal ) {
                m_visiblePlayers[m_nVisiblePlayers++] = ii;
            }
        }
    }
}
",True,7,26,1,8,4,6,11,6,L0
25,org.eehouse.android.xw4.jni.GameSummary.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;


/** Info we want to access when the game's closed that's not available
 * in CurGameInfo
 */
public class GameSummary {
    public int nMoves;
    public int[] scores;
    public boolean gameOver;
    public CommsAddrRec.CommsConnType conType;
    public String roomName;
    public String smsPhone;
}
",False,27,26,2,5,6,5,7,1,L0
26,org.eehouse.android.xw4.jni.JNIUtilsImpl.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.graphics.drawable.BitmapDrawable;
import android.graphics.Bitmap;
import java.util.ArrayList;
import java.io.ByteArrayInputStream;
import java.io.InputStreamReader;

import org.eehouse.android.xw4.*;

public class JNIUtilsImpl implements JNIUtils {

    private static JNIUtils s_impl = null;

    private JNIUtilsImpl(){}

    public static JNIUtils get()
    {
        if ( null == s_impl ) {
            s_impl = new JNIUtilsImpl();
        }
        return s_impl;
    }

    /** Working around lack of utf8 support on the JNI side: given a
     * utf-8 string with embedded small number vals starting with 0,
     * convert into individual strings.  The 0 is the problem: it's
     * not valid utf8.  So turn it and the other nums into strings and
     * catch them on the other side.
     */
    public String[] splitFaces( byte[] chars, boolean isUTF8 )
    {
        ArrayList<String> al = new ArrayList<String>();
        ByteArrayInputStream bais = new ByteArrayInputStream( chars );
        InputStreamReader isr;
        try {
            isr = new InputStreamReader( bais, isUTF8? ""UTF8"" : ""ISO8859_1"" );
        } catch( java.io.UnsupportedEncodingException uee ) {
            Utils.logf( ""splitFaces: %s"", uee.toString() );
            isr = new InputStreamReader( bais );
        }
        
        int[] codePoints = new int[1];

        for ( ; ; ) {
            int chr = -1;
            try {
                chr = isr.read();
            } catch ( java.io.IOException ioe ) {
                Utils.logf( ioe.toString() );
            }
            if ( -1 == chr ) {
                break;
            } else {
                String letter;
                if ( chr < 32 ) {
                    letter = String.format( ""%d"", chr );
                } else {
                    codePoints[0] = chr;
                    letter = new String( codePoints, 0, 1 );
                }
                al.add( letter );
            }
        }
        
        String[] result = al.toArray( new String[al.size()] );
        return result;
    }
}",False,5,20,1,2,6,5,3,2,L0
27,org.eehouse.android.xw4.jni.BoardHandler.java,"/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

public interface BoardHandler {

    void startHandling( JNIThread thread, int gamePtr, CurGameInfo gi );

}
",False,8,25,2,1,4,12,1,2,L1
28,org.eehouse.android.xw4.jni.JNIUtils.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.graphics.drawable.BitmapDrawable;

public interface JNIUtils {

    // Stuff I can't do in C....
    String[] splitFaces( byte[] chars, boolean isUTF8 );
}",False,37,26,5,10,0,0,3,0,L0
29,org.eehouse.android.xw4.jni.LocalPlayer.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.content.Context;
import org.eehouse.android.xw4.R;

public class LocalPlayer {
    public String name;
    public String password;
    public int secondsUsed;
    public boolean isRobot;
    public boolean isLocal;

    public LocalPlayer( Context context, int num )
    {
        isLocal = true;
        isRobot = num == 0;     // 1st player is a robot by default
        String fmt = context.getString( R.string.playerf );
        name = String.format( fmt, num + 1 );
        password = """";
    }

    public LocalPlayer( final LocalPlayer src )
    {
        isLocal = src.isLocal;
        isRobot = src.isRobot;
        if ( null != src.name ) {
            name = new String(src.name);
        }
        if ( null != src.password ) {
            password = new String(src.password);
        }
        secondsUsed = src.secondsUsed;
    }
}

",True,16,26,4,10,0,0,2,0,L0
30,org.eehouse.android.xw4.jni.UtilCtxt.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

public interface UtilCtxt {
    static final int BONUS_NONE = 0;
    static final int BONUS_DOUBLE_LETTER = 1;
    static final int BONUS_DOUBLE_WORD = 2;
    static final int BONUS_TRIPLE_LETTER = 3;
    static final int BONUS_TRIPLE_WORD = 4;

    int getSquareBonus( int col, int row );
    int userPickTile( /* PickInfo* pi, add once tile-picking is enabled */
                     int playerNum, String[] texts );

    String askPassword( String name );
    void turnChanged();

    boolean engineProgressCallback();
    void engineStarting( int nBlanks );
    void engineStopping();

    // Values for why; should be enums
    public static final int TIMER_PENDOWN = 1;
    public static final int TIMER_TIMERTICK = 2;
    public static final int TIMER_COMMS = 3;
    public static final int TIMER_SLOWROBOT = 4;
    void setTimer( int why, int when, int handle );
    void clearTimer( int why );
    void requestTime();
    void remSelected();


    static final int STRD_ROBOT_TRADED =                  1;
    static final int STR_ROBOT_MOVED =                    2;
    static final int STRS_VALUES_HEADER =                 3;
    static final int STRD_REMAINING_TILES_ADD =           4;
    static final int STRD_UNUSED_TILES_SUB =              5;
    static final int STR_REMOTE_MOVED =                   6;
    static final int STRD_TIME_PENALTY_SUB =              7;
    static final int STR_PASS =                           8;
    static final int STRS_MOVE_ACROSS =                   9;
    static final int STRS_MOVE_DOWN =                    10;
    static final int STRS_TRAY_AT_START =                11;
    static final int STRSS_TRADED_FOR =                  12;
    static final int STR_PHONY_REJECTED =                13;
    static final int STRD_CUMULATIVE_SCORE =             14;
    static final int STRS_NEW_TILES =                    15;
    static final int STR_PASSED =                        16;
    static final int STRSD_SUMMARYSCORED =               17;
    static final int STRD_TRADED =                       18;
    static final int STR_LOSTTURN =                      19;
    static final int STR_COMMIT_CONFIRM =                20;
    static final int STR_LOCAL_NAME =                    21;
    static final int STR_NONLOCAL_NAME =                 22;
    static final int STR_BONUS_ALL =                     23;
    static final int STRD_TURN_SCORE =                   24;
    String getUserString( int stringCode );

    static final int QUERY_COMMIT_TURN = 0;
    static final int QUERY_COMMIT_TRADE = 1;
    static final int QUERY_ROBOT_MOVE = 2;
    static final int QUERY_ROBOT_TRADE = 3;
    boolean userQuery( int id, String query );


    // These oughtto be an enum but then I'd have to cons one up in C.
    static final int ERR_NONE = 0;
    static final int ERR_TILES_NOT_IN_LINE = 1;
    static final int ERR_NO_EMPTIES_IN_TURN = 2;
    static final int ERR_TWO_TILES_FIRST_MOVE = 3;
    static final int ERR_TILES_MUST_CONTACT = 4;
    static final int ERR_TOO_FEW_TILES_LEFT_TO_TRADE = 5;
    static final int ERR_NOT_YOUR_TURN = 6;
    static final int ERR_NO_PEEK_ROBOT_TILES = 7;
    static final int ERR_SERVER_DICT_WINS = 8;
    static final int ERR_NO_PEEK_REMOTE_TILES = 9;
    static final int ERR_REG_UNEXPECTED_USER = 10;
    static final int ERR_REG_SERVER_SANS_REMOTE = 11;
    static final int STR_NEED_BT_HOST_ADDR = 12;
    static final int ERR_CANT_TRADE_MID_MOVE = 13;
    static final int ERR_CANT_UNDO_TILEASSIGN = 14;
    static final int ERR_CANT_HINT_WHILE_DISABLED = 15;
    static final int ERR_RELAY_BASE = 16;
    void userError( int id );

    void notifyGameOver();
    // Don't need this unless we have a scroll thumb to indicate position
    //void yOffsetChange( int maxOffset, int oldOffset, int newOffset );

    boolean warnIllegalWord( String[] words, int turn, boolean turnLost );
}
",False,18,26,5,10,0,0,2,0,L0
31,org.eehouse.android.xw4.jni.CommonPrefs.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.content.Context;
import android.content.SharedPreferences;
import android.preference.PreferenceManager;
import android.graphics.Paint;
import android.content.res.Resources;
import junit.framework.Assert;

import org.eehouse.android.xw4.Utils;
import org.eehouse.android.xw4.R;
import org.eehouse.android.xw4.GameUtils;

public class CommonPrefs {
    public static final int COLOR_TILE_BACK = 0;
    public static final int COLOR_BKGND = 1;
    public static final int COLOR_FOCUS = 2;
    public static final int COLOR_LAST = 3;

    private static CommonPrefs s_cp = null;

    public boolean showBoardArrow;
    public boolean showRobotScores;
    public boolean hideTileValues; 
    public boolean skipCommitConfirm;
    public boolean showColors;
    public boolean sortNewTiles;
    public boolean allowPeek;

    public int[] playerColors;
    public int[] bonusColors;
    public int[] otherColors;

    static {
        Utils.logf( ""CommonPrefs class initialized"" );
    }

    private CommonPrefs()
    {
        playerColors = new int[4];
        bonusColors = new int[5];
        bonusColors[0] = 0xF0F0F0F0; // garbage
        otherColors = new int[COLOR_LAST];
    }

    private CommonPrefs refresh( Context context )
    {
        String key;
        SharedPreferences sp = PreferenceManager
            .getDefaultSharedPreferences( context );

        showBoardArrow = getBoolean( context, sp, R.string.key_show_arrow, 
                                     true );
        showRobotScores = getBoolean( context, sp, R.string.key_explain_robot, 
                                      false );
        hideTileValues = getBoolean( context, sp, R.string.key_hide_values, 
                                     false );
        skipCommitConfirm = getBoolean( context, sp, 
                                        R.string.key_skip_confirm, false );
        showColors = getBoolean( context, sp, R.string.key_color_tiles, true );
        sortNewTiles = getBoolean( context, sp, R.string.key_sort_tiles, true );
        allowPeek = getBoolean( context, sp, R.string.key_peek_other, false );

        int ids[] = { R.string.key_player0,
                      R.string.key_player1,
                      R.string.key_player2,
                      R.string.key_player3,
        };

        for ( int ii = 0; ii < ids.length; ++ii ) {
            playerColors[ii] = prefToColor( context, sp, ids[ii] );
        }

        int ids2[] = { R.string.key_bonus_l2x,
                       R.string.key_bonus_w2x,
                       R.string.key_bonus_l3x,
                       R.string.key_bonus_w3x,
        };
        for ( int ii = 0; ii < ids2.length; ++ii ) {
            bonusColors[ii+1] = prefToColor( context, sp, ids2[ii] );
        }

        int idsOther[] = { R.string.key_tile_back,
                           R.string.key_empty,
                           R.string.key_clr_crosshairs,
        };
        for ( int ii = 0; ii < idsOther.length; ++ii ) {
            otherColors[ii] = prefToColor( context, sp, idsOther[ii] );
        }

        return this;
    }

    private boolean getBoolean( Context context, SharedPreferences sp, 
                                int id, boolean dflt )
    {
        String key = context.getString( id );
        return sp.getBoolean( key, dflt );
    }

    private int prefToColor( Context context, SharedPreferences sp, int id )
    {
        String key = context.getString( id );
        return 0xFF000000 | sp.getInt( key, 0 );
    }

    /*
     * static methods
     */
    public static CommonPrefs get( Context context )
    {
        if ( null == s_cp ) {
            s_cp = new CommonPrefs();
        }
        return s_cp.refresh( context );
    }

    public static String getDefaultRelayHost( Context context )
    {
        return getString( context, R.string.key_relay_host );
    }

    public static int getDefaultRelayPort( Context context )
    {
        String val = getString( context, R.string.key_relay_port );
        int result = 0;
        try {
            return Integer.parseInt( val );
        } catch ( Exception ex ) {
            return 0;
        } 
    }

    public static String getDefaultDictURL( Context context )
    {
        return getString( context, R.string.key_dict_host );
    }

    public static boolean getVolKeysZoom( Context context )
    {
        return getBoolean( context, R.string.key_ringer_zoom, false );
    }

    public static int getDefaultBoardSize( Context context )
    {
        String value = getString( context, R.string.key_board_size );
        try {
            return Integer.parseInt( value.substring( 0, 2 ) );
        } catch ( Exception ex ) {
            return 15;
        } 
    }

    public static int getDefaultPlayerMinutes( Context context )
    {
        String value = getString( context, R.string.key_initial_player_minutes );
        try {
            return Integer.parseInt( value );
        } catch ( Exception ex ) {
            return 25;
        }
    }

    public static String getDefaultDict( Context context )
    {
        String value = getString( context, R.string.key_default_dict );
        if ( value.equals("""") ) {
            value = GameUtils.dictList( context )[0];
        }
        return value;
    }

    public static CurGameInfo.XWPhoniesChoice 
        getDefaultPhonies( Context context )
    {
        String value = getString( context, R.string.key_default_phonies );

        CurGameInfo.XWPhoniesChoice result = 
            CurGameInfo.XWPhoniesChoice.PHONIES_IGNORE;
        Resources res = context.getResources();
        String[] names = res.getStringArray( R.array.phony_names );
        for ( int ii = 0; ii < names.length; ++ii ) {
            String name = names[ii];
            if ( name.equals( value ) ) {
                result = CurGameInfo.XWPhoniesChoice.values()[ii];
                break;
            }
        }
        return result;
    }
    
    public static boolean getDefaultTimerEnabled( Context context )
    {
        return getBoolean( context, R.string.key_default_timerenabled, false );
    }

    public static boolean getHideTitleBar( Context context )
    {
        return getBoolean( context, R.string.key_hide_title, true );
    }

    public static boolean getClickLaunches( Context context )
    {
        return getBoolean( context, R.string.key_click_launches, false );
    }

    public static boolean getShowBonusSumms( Context context )
    {
        return getBoolean( context, R.string.key_show_bonussum, false );
    }

    private static boolean getBoolean( Context context, int keyID,
                                       boolean defaultValue )
    {
        String key = context.getString( keyID );
        SharedPreferences sp = PreferenceManager
            .getDefaultSharedPreferences( context );
        return sp.getBoolean( key, defaultValue );
    }

    private static String getString( Context context, int keyID )
    {
        String key = context.getString( keyID );
        SharedPreferences sp = PreferenceManager
            .getDefaultSharedPreferences( context );
        return sp.getString( key, """" );
    }

}
",True,36,25,2,5,4,8,10,3,L0
32,org.eehouse.android.xw4.jni.TransportProcs.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

public interface TransportProcs {
    int transportSend( byte[] buf, final CommsAddrRec addr );

    enum CommsRelayState { COMMS_RELAYSTATE_UNCONNECTED
            , COMMS_RELAYSTATE_DENIED
            , COMMS_RELAYSTATE_CONNECT_PENDING
            , COMMS_RELAYSTATE_CONNECTED
            , COMMS_RELAYSTATE_RECONNECTED
            , COMMS_RELAYSTATE_ALLCONNECTED
    };
    void relayStatus( CommsRelayState newState );

    void relayConnd( boolean allHere, int nMissing );

    public static enum XWRELAY_ERROR { NONE
            ,OLDFLAGS 
            ,BADPROTO
            ,RELAYBUSY
            ,SHUTDOWN
            ,TIMEOUT 
            ,HEART_YOU
            ,HEART_OTHER
            ,LOST_OTHER
            ,OTHER_DISCON
            ,NO_ROOM
            ,DUP_ROOM
            ,TOO_MANY
    };
    void relayErrorProc( XWRELAY_ERROR relayErr );
}
",False,19,23,2,3,6,5,3,1,L0
33,org.eehouse.android.xw4.jni.JNIThread.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */


package org.eehouse.android.xw4.jni;

import org.eehouse.android.xw4.Utils;
import android.content.Context;
import java.lang.InterruptedException;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.Iterator;
import android.os.Handler;
import android.os.Message;
import android.graphics.Paint;
import android.graphics.Rect;

import org.eehouse.android.xw4.R;
import org.eehouse.android.xw4.BoardDims;
import org.eehouse.android.xw4.GameUtils;
import org.eehouse.android.xw4.DBUtils;
import org.eehouse.android.xw4.Toolbar;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class JNIThread extends Thread {

    public enum JNICmd { CMD_NONE,
            CMD_DRAW,
            CMD_LAYOUT,
            CMD_START,
            CMD_RESET,
            CMD_SAVE,
            CMD_DO,
            CMD_RECEIVE,
            CMD_TRANSFAIL,
            CMD_PREFS_CHANGE,
            CMD_PEN_DOWN,
            CMD_PEN_MOVE,
            CMD_PEN_UP,
            CMD_KEYDOWN,
            CMD_KEYUP,
            CMD_TIMER_FIRED,
            CMD_COMMIT,
            CMD_JUGGLE,
            CMD_FLIP,
            CMD_TOGGLE_TRAY,
            CMD_TOGGLE_TRADE,
            CMD_UNDO_CUR,
            CMD_UNDO_LAST,
            CMD_HINT,
            CMD_ZOOM,
            CMD_TOGGLEZOOM,
            CMD_PREV_HINT,
            CMD_NEXT_HINT,
            CMD_VALUES,
            CMD_COUNTS_VALUES,
            CMD_REMAINING,
            CMD_RESEND,
            CMD_HISTORY,
            CMD_FINAL,
            CMD_ENDGAME,
            CMD_POST_OVER,
            CMD_DRAW_CONNS_STATUS,
            };

    public static final int RUNNING = 1;
    public static final int DRAW = 2;
    public static final int DIALOG = 3;
    public static final int QUERY_ENDGAME = 4;
    public static final int TOOLBAR_STATES = 5;

    private boolean m_stopped = false;
    private int m_jniGamePtr;
    private String m_path;
    private Context m_context;
    private CurGameInfo m_gi;
    private Handler m_handler;
    private SyncedDraw m_drawer;
    private static final int kMinDivWidth = 10;
    private Rect m_connsIconRect;
    private int m_connsIconID = 0;
    private boolean m_inBack = false;

    LinkedBlockingQueue<QueueElem> m_queue;

    private class QueueElem {
        protected QueueElem( JNICmd cmd, boolean isUI, Object[] args )
        {
            m_cmd = cmd; m_isUIEvent = isUI; m_args = args;
        }
        boolean m_isUIEvent;
        JNICmd m_cmd;
        Object[] m_args;
    }

    public JNIThread( int gamePtr, CurGameInfo gi, SyncedDraw drawer, 
                      String path, Context context, Handler handler ) 
    {
        m_jniGamePtr = gamePtr;
        m_gi = gi;
        m_drawer = drawer;
        m_path = path;
        m_context = context;
        m_handler = handler;

        m_queue = new LinkedBlockingQueue<QueueElem>();
    }

    public void waitToStop() {
        m_stopped = true;
        handle( JNICmd.CMD_NONE );     // tickle it
        try {
            join(200);          // wait up to 2/10 second
        } catch ( java.lang.InterruptedException ie ) {
            Utils.logf( ""got InterruptedException: "" + ie.toString() );
        }
    }

    public boolean busy()
    {                           // synchronize this!!!
        boolean result = false;
        Iterator<QueueElem> iter = m_queue.iterator();
        while ( iter.hasNext() ) {
            if ( iter.next().m_isUIEvent ) {
                result = true;
                break;
            }
        }
        return result;
    }

    public void setInBackground( boolean inBack )
    {
        m_inBack = inBack;
        if ( inBack ) {
            handle( JNICmd.CMD_SAVE );
        }
    }

    private boolean toggleTray() {
        boolean draw;
        int state = XwJNI.board_getTrayVisState( m_jniGamePtr );
        if ( state == XwJNI.TRAY_REVEALED ) {
            draw = XwJNI.board_hideTray( m_jniGamePtr );
        } else {
            draw = XwJNI.board_showTray( m_jniGamePtr );
        }
        return draw;
    }

    private void sendForDialog( int titleArg, String text )
    {
        Message.obtain( m_handler, DIALOG, titleArg, 0, text ).sendToTarget();
    }

    private void doLayout( BoardDims dims )
    {
        int scoreWidth = dims.width;

        if ( DeviceRole.SERVER_STANDALONE != m_gi.serverRole ) {
            scoreWidth -= dims.cellSize;
            m_connsIconRect = 
                new Rect( scoreWidth, 0, scoreWidth + dims.cellSize, 
                          dims.cellSize );
        }

        if ( m_gi.timerEnabled ) {
            scoreWidth -= dims.timerWidth;
            XwJNI.board_setTimerLoc( m_jniGamePtr, scoreWidth, 0, 
                                     dims.timerWidth, dims.scoreHt );
        } 
        XwJNI.board_setScoreboardLoc( m_jniGamePtr, 0, 0, scoreWidth, 
                                      dims.scoreHt, true );

        XwJNI.board_setPos( m_jniGamePtr, 0, dims.scoreHt, 
                            dims.width-1, dims.boardHt, dims.maxCellSize, 
                            false );

        XwJNI.board_setTrayLoc( m_jniGamePtr, 0, dims.trayTop,
                                dims.width-1, dims.trayHt, kMinDivWidth );

        XwJNI.board_invalAll( m_jniGamePtr );
    }

    private boolean nextSame( JNICmd cmd ) 
    {
        QueueElem nextElem = m_queue.peek();
        return null != nextElem && nextElem.m_cmd == cmd;
    }

    private boolean processKeyEvent( JNICmd cmd, XwJNI.XP_Key xpKey,
                                     boolean[] barr )
    {
        boolean draw = false;
        return draw;
    } // processKeyEvent

    private void checkButtons()
    {
        int visTileCount = XwJNI.board_visTileCount( m_jniGamePtr );
        int canFlip = visTileCount > 1 ? 1 : 0;
        Message.obtain( m_handler, TOOLBAR_STATES, Toolbar.BUTTON_FLIP,
                        canFlip ).sendToTarget();
        int canValues = visTileCount > 0 ? 1 : 0;
        Message.obtain( m_handler, TOOLBAR_STATES, Toolbar.BUTTON_VALUES,
                        canValues ).sendToTarget();

        int canShuffle = XwJNI.board_canShuffle( m_jniGamePtr ) ? 1 : 0;
        Message.obtain( m_handler, TOOLBAR_STATES, Toolbar.BUTTON_JUGGLE,
                        canShuffle ).sendToTarget();

        int canRedo = XwJNI.board_canTogglePending( m_jniGamePtr ) ? 1 : 0;
        Message.obtain( m_handler, TOOLBAR_STATES, Toolbar.BUTTON_UNDO,
                        canRedo ).sendToTarget();

        int canHint = XwJNI.board_canHint( m_jniGamePtr ) ? 1 : 0;
        Message.obtain( m_handler, TOOLBAR_STATES, Toolbar.BUTTON_HINT_PREV,
                        canHint ).sendToTarget();
        Message.obtain( m_handler, TOOLBAR_STATES, Toolbar.BUTTON_HINT_NEXT,
                        canHint ).sendToTarget();
    }

    public void run() 
    {
        boolean[] barr = new boolean[2]; // scratch boolean
        while ( !m_stopped ) {
            QueueElem elem;
            Object[] args;
            try {
                elem = m_queue.take();
            } catch ( InterruptedException ie ) {
                Utils.logf( ""interrupted; killing thread"" );
                break;
            }
            boolean draw = false;
            args = elem.m_args;
            switch( elem.m_cmd ) {

            case CMD_SAVE:
                if ( nextSame( JNICmd.CMD_SAVE ) ) {
                    continue;
                }
                GameSummary summary = new GameSummary();
                XwJNI.game_summarize( m_jniGamePtr, m_gi.nPlayers, summary );
                byte[] state = XwJNI.game_saveToStream( m_jniGamePtr, null );
                GameUtils.saveGame( m_context, state, m_path );
                DBUtils.saveSummary( m_path, summary );
                break;

            case CMD_DRAW:
                if ( nextSame( JNICmd.CMD_DRAW ) ) {
                    continue;
                }
                draw = true;
                break;

            case CMD_LAYOUT:
                doLayout( (BoardDims)args[0] );
                draw = true;
                // check and disable zoom button at limit
                handle( JNICmd.CMD_ZOOM, 0 );
                break;

            case CMD_RESET:
                XwJNI.comms_resetSame( m_jniGamePtr );
                // FALLTHRU
            case CMD_START:
                XwJNI.comms_start( m_jniGamePtr );
                if ( m_gi.serverRole == DeviceRole.SERVER_ISCLIENT ) {
                    XwJNI.server_initClientConnection( m_jniGamePtr );
                }
                draw = XwJNI.server_do( m_jniGamePtr );
                break;
            case CMD_DO:
                if ( nextSame( JNICmd.CMD_DO ) ) {
                    continue;
                }
                draw = XwJNI.server_do( m_jniGamePtr );
                break;

            case CMD_RECEIVE:
                draw = XwJNI.game_receiveMessage( m_jniGamePtr, 
                                                  (byte[])args[0] );
                handle( JNICmd.CMD_DO );
                if ( m_inBack ) {
                    handle( JNICmd.CMD_SAVE );
                }
                break;

            case CMD_TRANSFAIL:
                XwJNI.comms_transportFailed( m_jniGamePtr );
                break;

            case CMD_PREFS_CHANGE:
                // need to inval all because some of prefs,
                // e.g. colors, aren't known by common code so
                // board_prefsChanged's return value isn't enough.
                XwJNI.board_invalAll( m_jniGamePtr );
                XwJNI.board_server_prefsChanged( m_jniGamePtr, 
                                                 CommonPrefs.get( m_context ) );
                draw = true;
                break;

            case CMD_PEN_DOWN:
                draw = XwJNI.board_handlePenDown( m_jniGamePtr, 
                                                  ((Integer)args[0]).intValue(),
                                                  ((Integer)args[1]).intValue(),
                                                  barr );
                break;
            case CMD_PEN_MOVE:
                if ( nextSame( JNICmd.CMD_PEN_MOVE ) ) {
                    continue;
                }
                draw = XwJNI.board_handlePenMove( m_jniGamePtr, 
                                                  ((Integer)args[0]).intValue(),
                                                  ((Integer)args[1]).intValue() );
                break;
            case CMD_PEN_UP:
                draw = XwJNI.board_handlePenUp( m_jniGamePtr, 
                                                ((Integer)args[0]).intValue(),
                                                ((Integer)args[1]).intValue() );
                break;

            case CMD_KEYDOWN:
            case CMD_KEYUP:
                draw = processKeyEvent( elem.m_cmd, (XwJNI.XP_Key)args[0], barr );
                break;

            case CMD_COMMIT:
                draw = XwJNI.board_commitTurn( m_jniGamePtr );
                break;

            case CMD_JUGGLE:
                draw = XwJNI.board_juggleTray( m_jniGamePtr );
                break;
            case CMD_FLIP:
                draw = XwJNI.board_flip( m_jniGamePtr );
                break;
            case CMD_TOGGLE_TRAY:
                draw = toggleTray();
                break;
            case CMD_TOGGLE_TRADE:
                draw = XwJNI.board_beginTrade( m_jniGamePtr );
                break;
            case CMD_UNDO_CUR:
                draw = XwJNI.board_replaceTiles( m_jniGamePtr )
                    || XwJNI.board_redoReplacedTiles( m_jniGamePtr );
                break;
            case CMD_UNDO_LAST:
                XwJNI.server_handleUndo( m_jniGamePtr );
                draw = true;
                break;

            case CMD_HINT:
                XwJNI.board_resetEngine( m_jniGamePtr );
                handle( JNICmd.CMD_NEXT_HINT );
                break;

            case CMD_NEXT_HINT:
            case CMD_PREV_HINT:
                if ( nextSame( elem.m_cmd ) ) {
                    continue;
                }
                draw = XwJNI.board_requestHint( m_jniGamePtr, false, 
                                                JNICmd.CMD_PREV_HINT==elem.m_cmd,
                                                barr );
                if ( barr[0] ) {
                    handle( elem.m_cmd );
                    draw = false;
                }
                break;

            case CMD_TOGGLEZOOM:
                XwJNI.board_zoom( m_jniGamePtr, 0 , barr );
                int zoomBy = 0;
                if ( barr[1] ) { // always go out if possible
                    zoomBy = -4;
                } else if ( barr[0] ) {
                    zoomBy = 4;
                }
                draw = XwJNI.board_zoom( m_jniGamePtr, zoomBy, barr );
                break;
            case CMD_ZOOM:
                draw = XwJNI.board_zoom( m_jniGamePtr, 
                                         ((Integer)args[0]).intValue(),
                                         barr );
                break;

            case CMD_VALUES:
                draw = XwJNI.board_toggle_showValues( m_jniGamePtr );
                break;

            case CMD_COUNTS_VALUES:
                sendForDialog( ((Integer)args[0]).intValue(),
                               XwJNI.server_formatDictCounts( m_jniGamePtr, 3 )
                               );
                break;
            case CMD_REMAINING:
                sendForDialog( ((Integer)args[0]).intValue(),
                               XwJNI.board_formatRemainingTiles( m_jniGamePtr )
                               );
                break;

            case CMD_RESEND:
                XwJNI.comms_resendAll( m_jniGamePtr );
                break;

            case CMD_HISTORY:
                boolean gameOver = XwJNI.server_getGameIsOver( m_jniGamePtr );
                sendForDialog( ((Integer)args[0]).intValue(),
                               XwJNI.model_writeGameHistory( m_jniGamePtr, 
                                                             gameOver ) );
                break;

            case CMD_FINAL:
                if ( XwJNI.server_getGameIsOver( m_jniGamePtr ) ) {
                    handle( JNICmd.CMD_POST_OVER );
                } else {
                    Message.obtain( m_handler, QUERY_ENDGAME ).sendToTarget();
                }
                break;

            case CMD_ENDGAME:
                XwJNI.server_endGame( m_jniGamePtr );
                draw = true;
                break;

            case CMD_POST_OVER:
                sendForDialog( R.string.finalscores_title,
                               XwJNI.server_writeFinalScores( m_jniGamePtr ) );
                break;

            case CMD_DRAW_CONNS_STATUS:
                int newID = 0;
                switch( (TransportProcs.CommsRelayState)(args[0]) ) {
                case COMMS_RELAYSTATE_UNCONNECTED:
                case COMMS_RELAYSTATE_DENIED:
                case COMMS_RELAYSTATE_CONNECT_PENDING:
                    newID = R.drawable.netarrow_unconn;
                    break;
                case COMMS_RELAYSTATE_CONNECTED: 
                case COMMS_RELAYSTATE_RECONNECTED: 
                    newID = R.drawable.netarrow_someconn;
                    break;
                case COMMS_RELAYSTATE_ALLCONNECTED:
                    newID = R.drawable.netarrow_allconn;
                    break;
                default:
                    newID = 0;
                }
                if ( m_connsIconID != newID ) {
                    draw = true;
                    m_connsIconID = newID;
                }
                break;

            case CMD_TIMER_FIRED:
                draw = XwJNI.timerFired( m_jniGamePtr, 
                                         ((Integer)args[0]).intValue(),
                                         ((Integer)args[1]).intValue(),
                                         ((Integer)args[2]).intValue() );
                break;
            }

            if ( draw ) {
                // do the drawing in this thread but in BoardView
                // where it can be synchronized with that class's use
                // of the same bitmap for blitting.
                m_drawer.doJNIDraw();
                if ( null != m_connsIconRect ) {
                    m_drawer.doIconDraw( m_connsIconID, m_connsIconRect );
                }

                // main UI thread has to invalidate view as it created
                // it.
                Message.obtain( m_handler, DRAW ).sendToTarget();

                checkButtons();
            }
        }
        Utils.logf( ""run exiting"" );
    } // run

    public void handle( JNICmd cmd, boolean isUI, Object... args )
    {
        QueueElem elem = new QueueElem( cmd, isUI, args );
        // Utils.logf( ""adding: "" + cmd.toString() );
        m_queue.add( elem );
    }

    public void handle( JNICmd cmd, Object... args )
    {
        handle( cmd, true, args );
    }

}
",True,3,26,1,4,3,11,4,11,L1
34,org.eehouse.android.xw4.jni.SyncedDraw.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.graphics.Rect;

public interface SyncedDraw {
    void doJNIDraw();
    void doIconDraw( int resID, final Rect rect );
}
",False,14,6,2,3,0,0,2,0,L1
35,org.eehouse.android.xw4.jni.XwJNI.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

// Collection of native methods
public class XwJNI {


    // This needs to be called before the first attempt to use the
    // jni.  I figure this class has to be loaded before that cna
    // happen.  Doing this in GamesList isn't enough because sometimes
    // BoardActivity is the first Activity loaded.
    static {
        System.loadLibrary(""xwjni"");
    }
    
    /* XW_TrayVisState enum */
    public static final int TRAY_HIDDEN = 0;
    public static final int TRAY_REVERSED = 1;
    public static final int TRAY_REVEALED = 2;

    // Methods not part of the common interface but necessitated by
    // how java/jni work (or perhaps my limited understanding of it.)

    // callback into jni from java when timer set here fires.
    public static native boolean timerFired( int gamePtr, int why, 
                                             int when, int handle );

    // Stateless methods
    public static native byte[] gi_to_stream( CurGameInfo gi );
    public static native void gi_from_stream( CurGameInfo gi, byte[] stream );
    public static native void comms_getInitialAddr( CommsAddrRec addr,
                                                    String relayHost,
                                                    int relayPort );

    // Game methods
    public static native int initJNI();
    public static native void game_makeNewGame( int gamePtr,
                                                CurGameInfo gi, 
                                                UtilCtxt util,
                                                JNIUtils jniu,
                                                DrawCtx draw, CommonPrefs cp, 
                                                TransportProcs procs, 
                                                byte[] dict, String dictName );

    public static native boolean game_makeFromStream( int gamePtr,
                                                      byte[] stream, 
                                                      CurGameInfo gi, 
                                                      byte[] dict, 
                                                      String dictName,
                                                      UtilCtxt util, 
                                                      JNIUtils jniu,
                                                      DrawCtx draw,
                                                      CommonPrefs cp,
                                                      TransportProcs procs );

    // leave out options params for when game won't be rendered or
    // played
    public static void game_makeNewGame( int gamePtr, CurGameInfo gi,
                                         JNIUtils jniu, CommonPrefs cp, 
                                         byte[] dict, String dictName ) {
        game_makeNewGame( gamePtr, gi, (UtilCtxt)null, jniu,
                          (DrawCtx)null, cp, (TransportProcs)null, 
                          dict, dictName );
    }

    public static boolean game_makeFromStream( int gamePtr,
                                               byte[] stream, 
                                               JNIUtils jniu,
                                               CurGameInfo gi, 
                                               byte[] dict, String dictName,
                                               CommonPrefs cp ) {
        return game_makeFromStream( gamePtr, stream, gi, dict, dictName,
                                    (UtilCtxt)null, jniu, (DrawCtx)null, cp, 
                                    (TransportProcs)null );
    }

    public static native boolean game_receiveMessage( int gamePtr, 
                                                      byte[] stream );
    public static native void game_summarize( int gamePtr, int nPlayers,
                                              GameSummary summary );
    public static native byte[] game_saveToStream( int gamePtr,
                                                   CurGameInfo gi  );
    public static native boolean game_hasComms( int gamePtr );
    public static native void game_dispose( int gamePtr );

    // Board methods
    public static native void board_invalAll( int gamePtr );
    public static native boolean board_draw( int gamePtr );
    public static native void board_setPos( int gamePtr, int left, int top,
                                            int width, int height, 
                                            int maxCellHt, boolean lefty );
    public static native boolean board_zoom( int gamePtr, int zoomBy, 
                                             boolean[] canZoom );
    public static native void board_setScoreboardLoc( int gamePtr, int left, 
                                                      int top, int width, 
                                                      int height,
                                                      boolean divideHorizontally );
    public static native void board_setTrayLoc( int gamePtr, int left, 
                                                int top, int width, 
                                                int height, int minDividerWidth );
    public static native void board_setTimerLoc( int gamePtr,
                                                 int timerLeft, int timerTop,
                                                 int timerWidth, int timerHeight );

    public static native boolean board_handlePenDown( int gamePtr, 
                                                      int xx, int yy, 
                                                      boolean[] handled );
    public static native boolean board_handlePenMove( int gamePtr, 
                                                      int xx, int yy );
    public static native boolean board_handlePenUp( int gamePtr, 
                                                    int xx, int yy );

    public static native boolean board_juggleTray( int gamePtr );
    public static native int board_getTrayVisState( int gamePtr );
    public static native boolean board_hideTray( int gamePtr );
    public static native boolean board_showTray( int gamePtr );
    public static native boolean board_toggle_showValues( int gamePtr );
    public static native boolean board_commitTurn( int gamePtr );
    public static native boolean board_flip( int gamePtr );
    public static native boolean board_replaceTiles( int gamePtr );
    public static native boolean board_redoReplacedTiles( int gamePtr );
    public static native void board_resetEngine( int gamePtr );
    public static native boolean board_requestHint( int gamePtr, 
                                                    boolean useTileLimits,
                                                    boolean goBackwards,
                                                    boolean[] workRemains );
    public static native boolean board_beginTrade( int gamePtr );

    public static native String board_formatRemainingTiles( int gamePtr );

    public static native int board_visTileCount( int gamePtr );
    public static native boolean board_canHint( int gamePtr );
    public static native boolean board_canShuffle( int gamePtr );
    public static native boolean board_canTogglePending( int gamePtr );

    public enum XP_Key {
        XP_KEY_NONE,
        XP_CURSOR_KEY_DOWN,
        XP_CURSOR_KEY_ALTDOWN,
        XP_CURSOR_KEY_RIGHT,
        XP_CURSOR_KEY_ALTRIGHT,
        XP_CURSOR_KEY_UP,
        XP_CURSOR_KEY_ALTUP,
        XP_CURSOR_KEY_LEFT,
        XP_CURSOR_KEY_ALTLEFT,

        XP_CURSOR_KEY_DEL,
        XP_RAISEFOCUS_KEY,
        XP_RETURN_KEY,

        XP_KEY_LAST
    };
    public static native boolean board_handleKey( int gamePtr, XP_Key key, 
                                                  boolean up, boolean[] handled );
    // public static native boolean board_handleKeyDown( XP_Key key, 
    //                                                   boolean[] handled );
    // public static native boolean board_handleKeyRepeat( XP_Key key, 
    //                                                     boolean[] handled );

    // Model
    public static native String model_writeGameHistory( int gamePtr, 
                                                        boolean gameOver );
    public static native int model_getNMoves( int gamePtr );

    // Server
    public static native void server_handleUndo( int gamePtr );
    public static native boolean server_do( int gamePtr );
    public static native String server_formatDictCounts( int gamePtr, int nCols );
    public static native boolean server_getGameIsOver( int gamePtr );
    public static native String server_writeFinalScores( int gamePtr );
    public static native void server_initClientConnection( int gamePtr );
    public static native void server_endGame( int gamePtr );

    // hybrid to save work
    public static native boolean board_server_prefsChanged( int gamePtr, 
                                                            CommonPrefs cp );

    // Comms
    public static native void comms_start( int gamePtr );
    public static native void comms_resetSame( int gamePtr );
    public static native void comms_getAddr( int gamePtr, CommsAddrRec addr );
    public static native void comms_setAddr( int gamePtr, CommsAddrRec addr );
    public static native void comms_resendAll( int gamePtr );
    public static native void comms_transportFailed( int gamePtr );

    // Dicts
    public static native boolean dict_tilesAreSame( int dictPtr1, int dictPtr2 );
    public static native String[] dict_getChars( int dictPtr );
}
",True,34,24,2,3,4,8,4,8,L0
36,org.eehouse.android.xw4.jni.DrawCtx.java,"/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.graphics.Rect;

public interface DrawCtx {
    static final int CELL_NONE = 0x00;
    static final int CELL_ISBLANK = 0x01;
    static final int CELL_HIGHLIGHT = 0x02;
    static final int CELL_ISSTAR = 0x04;
    static final int CELL_ISCURSOR = 0x08;
    static final int CELL_ISEMPTY = 0x10;       /* of a tray tile slot */
    static final int CELL_VALHIDDEN = 0x20;     /* show letter only, not value */
    static final int CELL_DRAGSRC = 0x40;       /* where drag originated */
    static final int CELL_DRAGCUR = 0x80;       /* where drag is now */
    static final int CELL_CROSSVERT = 0x100;
    static final int CELL_CROSSHOR = 0x200;
    static final int CELL_ALL = 0x3FF;

    /* BoardObjectType */
    static final int OBJ_NONE = 0;
    static final int OBJ_BOARD = 1;
    static final int OBJ_SCORE = 2;
    static final int OBJ_TRAY = 3;


    boolean scoreBegin( Rect rect, int numPlayers, int[] scores, int remCount,
                        int dfs );
    void measureRemText( Rect r, int nTilesLeft, int[] width, int[] height );
    void measureScoreText( Rect r, DrawScoreInfo dsi, int[] width, int[] height );
    void drawRemText( Rect rInner, Rect rOuter, int nTilesLeft, boolean focussed );
    void score_drawPlayer( Rect rInner, Rect rOuter, DrawScoreInfo dsi );
    void drawTimer( Rect rect, int player, int secondsLeft );

    boolean drawCell( Rect rect, String text, int tile, 
                      int owner, int bonus, int hintAtts, int flags );
    void drawBoardArrow ( Rect rect, int bonus, boolean vert, int hintAtts,
                          int flags );
    boolean trayBegin ( Rect rect, int owner, int dfs );
    void drawTile( Rect rect, String text, int val, int flags );
    void drawTileMidDrag ( Rect rect, String text, int val, int owner, 
                           int flags );
    void drawTileBack( Rect rect, int flags );
    void drawTrayDivider( Rect rect, int flags );
    void score_pendingScore( Rect rect, int score, int playerNum, int flags );

    public static final int BONUS_NONE = 0;
    public static final int BONUS_DOUBLE_LETTER = 1;
    public static final int BONUS_DOUBLE_WORD = 2;
    public static final int BONUS_TRIPLE_LETTER = 3;
    public static final int BONUS_TRIPLE_WORD = 4;
    public static final int INTRADE_MW_TEXT = 5;
    String getMiniWText ( int textHint );
    void measureMiniWText( String text, int[] width, int[] height );
    void drawMiniWindow( String text, Rect rect );

    void objFinished( /*BoardObjectType*/int typ, Rect rect, int dfs );

    void dictChanged( int dictPtr );

}
",False,22,27,5,9,1,1,2,1,L0
37,org.eehouse.android.xw4.jni.CommsAddrRec.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import java.net.InetAddress;
import android.content.Context;

import org.eehouse.android.xw4.Utils;

public class CommsAddrRec {

    public enum CommsConnType { COMMS_CONN_NONE,
            COMMS_CONN_IR,
            COMMS_CONN_IP_DIRECT,
            COMMS_CONN_RELAY,
            COMMS_CONN_BT,
            COMMS_CONN_SMS,
    };

    // The C equivalent of this struct uses a union for the various
    // data sets below.  So don't assume that any fields will be valid
    // except those for the current conType.
    public CommsConnType conType;

    // relay case
    public String ip_relay_invite;
    public String ip_relay_hostName;
    public InetAddress ip_relay_ipAddr;    // a cache, maybe unused in java
    public int ip_relay_port;

    // sms case
    public String sms_phone;
    public int sms_port;                   // NBS port, if they still use those

    public CommsAddrRec( Context context ) 
    {
        Utils.logf( ""CommsAddrRec() called "" );
        conType = CommsConnType.COMMS_CONN_RELAY;
        ip_relay_invite = ""Room 1"";
        ip_relay_hostName = CommonPrefs.getDefaultRelayHost( context );
        ip_relay_port = CommonPrefs.getDefaultRelayPort( context );
    }

    public CommsAddrRec( final CommsAddrRec src ) 
    {
        this.copyFrom( src );
    }

    public boolean changesMatter( final CommsAddrRec other )
    {
        boolean matter = conType != other.conType;
        if ( !matter ) {
            matter = ! ip_relay_invite.equals( other.ip_relay_invite )
                || ! ip_relay_hostName.equals( other.ip_relay_hostName )
                || ip_relay_port != other.ip_relay_port;
        }
        return matter;
    }

    private void copyFrom( CommsAddrRec src )
    {
        conType = src.conType;
        ip_relay_invite = src.ip_relay_invite;
        ip_relay_hostName = src.ip_relay_hostName;
        ip_relay_port = src.ip_relay_port;
    }
}
",False,29,21,2,2,5,5,8,2,L0
