,file_path,source_code,is_vulnerable,id, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,org.eehouse.android.xw4.RefreshMsgsTask.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.os.AsyncTask;
import android.content.Context;
import android.app.ProgressDialog;

public class RefreshMsgsTask extends AsyncTask<Void, Void, String[]> {

    public interface RefreshMsgsIface {
        public void RefreshMsgsResults( String[] relayIDs );
    };

    private Context m_context;
    private ProgressDialog m_progress;
    private RefreshMsgsIface m_iface;


    public RefreshMsgsTask( Context context, RefreshMsgsIface iface )
    {
        m_context = context;
        m_iface = iface;

        String msg = context.getString( R.string.msgs_progress );
        m_progress = ProgressDialog.show( context, msg, null, true, 
                                          true );
    }

    protected String[] doInBackground( Void...unused ) 
    {
        return NetUtils.QueryRelay( m_context );
    }

    protected void onPostExecute( String[] result )
    {
        m_progress.cancel();
        m_iface.RefreshMsgsResults( result );
    }
}
",False,19,22,1,1,6,7,1,1,L3
1,org.eehouse.android.xw4.GamesList.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.ListActivity;
import android.app.Dialog;
import android.app.AlertDialog;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.DialogInterface;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.view.ContextMenu;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ContextMenu.ContextMenuInfo;
import android.widget.AdapterView;
import android.widget.ListView;
import android.widget.Button;
import android.view.MenuInflater;
import java.io.File;
import android.preference.PreferenceManager;
// import android.telephony.PhoneStateListener;
// import android.telephony.TelephonyManager;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;

public class GamesList extends XWListActivity 
    implements DispatchNotify.HandleRelaysIface,
               RefreshMsgsTask.RefreshMsgsIface {

    private static final int WARN_NODICT       = DlgDelegate.DIALOG_LAST + 1;
    private static final int WARN_NODICT_SUBST = WARN_NODICT + 1;
    private static final int SHOW_SUBST        = WARN_NODICT + 2;

    private GameListAdapter m_adapter;
    private String m_invalPath = null;
    private String m_missingDict;
    private Handler m_handler;
    private String m_missingDictName;
    private String m_missingDictPath;
    private String[] m_sameLangDicts;
    private int m_missingDictLang;

    // private XWPhoneStateListener m_phoneStateListener;
    // private class XWPhoneStateListener extends PhoneStateListener {
    //     @Override
    //     public void onDataConnectionStateChanged( int state )
    //     {
    //         Utils.logf( ""onDataConnectionStateChanged(%d)"", state );
    //         if ( TelephonyManager.DATA_CONNECTED == state ) {
    //             NetUtils.informOfDeaths( GamesList.this );
    //         }
    //     }
    // }

    @Override
    protected Dialog onCreateDialog( int id )
    {
        Dialog dialog = super.onCreateDialog( id );
        if ( null == dialog ) {
            AlertDialog.Builder ab;
            switch ( id ) {
            case WARN_NODICT:
            case WARN_NODICT_SUBST:
                ab = new AlertDialog.Builder( this )
                    .setTitle( R.string.no_dict_title )
                    .setMessage( """" ) // required to get to change it later
                    .setPositiveButton( R.string.button_ok, null )
                    .setNegativeButton( R.string.button_download, null ) // change
                    ;
                if ( WARN_NODICT_SUBST == id ) {
                    DialogInterface.OnClickListener lstnr = 
                        new DialogInterface.OnClickListener() {
                            public void onClick( DialogInterface dlg, int item ) {
                                showDialog( SHOW_SUBST );
                            }
                        };
                    ab.setNeutralButton( R.string.button_substdict, lstnr );
                }
                dialog = ab.create();
                break;
            case SHOW_SUBST:
                m_sameLangDicts = 
                    DictLangCache.getHaveLangCounts( this, m_missingDictLang );
                ab = new AlertDialog.Builder( this )
                    .setTitle( R.string.subst_dict_title )
                    .setNegativeButton( R.string.button_cancel, null )
                    .setItems( m_sameLangDicts,
                               new DialogInterface.OnClickListener() {
                                   public void onClick( DialogInterface dlg,
                                                        int which ) {
                                       String dict = m_sameLangDicts[which];
                                       dict = DictLangCache.stripCount( dict );
                                       GameUtils.replaceDict( GamesList.this,
                                                              m_missingDictPath,
                                                              dict );
                                   }
                               })
                    ;
                dialog = ab.create();
                // Force destruction so onCreateDialog() will get
                // called next time and we can insert a different
                // list.  There seems to be no way to change the list
                // inside onPrepareDialog().
                dialog.setOnDismissListener(new DialogInterface.
                                            OnDismissListener() {
                        public void onDismiss(DialogInterface dlg) {
                            removeDialog( SHOW_SUBST );
                        }
                    });
                break;
            default:
                Assert.fail();
                break;
            }
        }
        return dialog;
    }

    @Override
    protected void onPrepareDialog( int id, Dialog dialog )
    {
        DialogInterface.OnClickListener lstnr;
        AlertDialog ad;
        
        switch( id ) {
        case WARN_NODICT:
        case WARN_NODICT_SUBST:
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        Intent intent = 
                            Utils.mkDownloadActivity( GamesList.this,
                                                      m_missingDictName,
                                                      m_missingDictLang );
                        startActivity( intent );
                    }
                };
            ad = (AlertDialog)dialog;
            ad.setButton( AlertDialog.BUTTON_NEGATIVE, 
                          getString( R.string.button_download ), lstnr );
            int fmtId = WARN_NODICT == id? R.string.no_dictf
                : R.string.no_dict_substf;
            ad.setMessage( String.format( getString( fmtId ),
                                          m_missingDictName ) );
            break;
        default:
            super.onPrepareDialog( id, dialog );
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) 
    {
        super.onCreate(savedInstanceState);

        m_handler = new Handler();

        setContentView(R.layout.game_list);
        ListView listView = getListView();
        listView.setEmptyView( findViewById( R.id.empty_games_list ) );
        registerForContextMenu( listView );

        boolean isUpgrade = FirstRunDialog.show( this, false );
        PreferenceManager.setDefaultValues( this, R.xml.xwprefs, isUpgrade );

        // setDefaultKeyMode(DEFAULT_KEYS_SHORTCUT);

        Button newGameB = (Button)findViewById(R.id.new_game);
        newGameB.setOnClickListener( new View.OnClickListener() {
                @Override
                public void onClick( View v ) {
                    addGame( false );
                    showNotAgainDlg( R.string.not_again_newgame, 
                                     R.string.key_notagain_newgame );
                }
            });
        newGameB = (Button)findViewById(R.id.new_game_net);
        newGameB.setOnClickListener( new View.OnClickListener() {
                @Override
                public void onClick( View v ) {
                    String path = addGame( true );
                    GameUtils.doConfig( GamesList.this, path, 
                                        RelayGameActivity.class );
                    m_invalPath = path;
                }
            });

        GameConverter.convert( this );

        m_adapter = new GameListAdapter( this );
        setListAdapter( m_adapter );

        RelayReceiver.RestartTimer( this );
        NetUtils.informOfDeaths( this );
    }

    @Override
    protected void onStart()
    {
        super.onStart();
        DispatchNotify.SetRelayIDsHandler( this );

        // TelephonyManager mgr = 
        //     (TelephonyManager)getSystemService( Context.TELEPHONY_SERVICE );
        // m_phoneStateListener = new XWPhoneStateListener();
        // mgr.listen( m_phoneStateListener,
        //             PhoneStateListener.LISTEN_DATA_CONNECTION_STATE );
    }

    @Override
    protected void onStop()
    {
        // TelephonyManager mgr = 
        //     (TelephonyManager)getSystemService( Context.TELEPHONY_SERVICE );
        // mgr.listen( m_phoneStateListener, PhoneStateListener.LISTEN_NONE );
        // m_phoneStateListener = null;

        DispatchNotify.SetRelayIDsHandler( null );

        super.onStop();
    }

    // DispatchNotify.HandleRelaysIface interface
    public void HandleRelaysIDs( final String[] relayIDs )
    {
        m_handler.post( new Runnable() {
                public void run() {
                    if ( null == relayIDs ) {
                        Utils.logf( ""relayIDs null"" );
                    } else if ( relayIDs.length == 0 ) {
                        Utils.logf( ""relayIDs empty"" );
                    } else {
                        for ( String relayID : relayIDs ) {
                            Utils.logf( ""HandleRelaysIDs: got %s"", relayID );
                            String path = DBUtils.getPathFor( GamesList.this,
                                                              relayID );
                            m_adapter.inval( path );
                        }
                        onContentChanged();
                    }
                }
            } );
    }

    // RefreshMsgsTask.RefreshMsgsIface interface
    public void RefreshMsgsResults( String[] relayIDs )
    {
        HandleRelaysIDs( relayIDs );
    }

    // @Override
    // protected void onNewIntent( Intent intent )
    // {
    //     RelayService.CancelNotification();

    //     Utils.logf( ""onNewIntent called"" );
    //     String[] relayIDs = intent.
    //         getStringArrayExtra( getString(R.string.relayids_extra) );
    //     HandleRelaysIDs( relayIDs );
    // }

    @Override
    public void onWindowFocusChanged( boolean hasFocus )
    {
        super.onWindowFocusChanged( hasFocus );
        if ( hasFocus && null != m_invalPath ) {
            m_adapter.inval( m_invalPath );
            m_invalPath = null;
            onContentChanged();
        }
    }

    @Override
    public void onCreateContextMenu( ContextMenu menu, View view, 
                                     ContextMenuInfo menuInfo ) 
    {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.games_list_item_menu, menu );
    }
        
    @Override
    public boolean onContextItemSelected( MenuItem item ) 
    {
        AdapterView.AdapterContextMenuInfo info;
        try {
            info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
        } catch (ClassCastException e) {
            Utils.logf( ""bad menuInfo:"" + e.toString() );
            return false;
        }

        return handleMenuItem( item.getItemId(), info.position );
    } // onContextItemSelected

    public boolean onCreateOptionsMenu( Menu menu )
    {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.games_list_menu, menu );
        return true;
    }

    private void doSyncMenuitem()
    {
        if ( null == DBUtils.getRelayIDNoMsgs( this ) ) {
            showOKOnlyDialog( R.string.no_games_to_refresh );
        } else {
            new RefreshMsgsTask( this, this ).execute();
        }
    }

    public boolean onOptionsItemSelected( MenuItem item )
    {
        boolean handled = true;
        Intent intent;

        switch (item.getItemId()) {
        case R.id.gamel_menu_delete_all:
            if ( DBUtils.gamesList( this ).length > 0 ) {
                DialogInterface.OnClickListener lstnr =
                    new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dlg, int item ) {
                            String[] games = 
                                DBUtils.gamesList( GamesList.this );
                            for ( int ii = games.length - 1; ii >= 0; --ii ) {
                                GameUtils.deleteGame( GamesList.this, games[ii], 
                                                      ii == 0  );
                            }
                            m_adapter = new GameListAdapter( GamesList.this );
                            setListAdapter( m_adapter );
                        }
                    };
                showConfirmThen( R.string.confirm_delete_all, lstnr );
            }
            handled = true;
            break;

        case R.id.gamel_menu_dicts:
            intent = new Intent( this, DictsActivity.class );
            startActivity( intent );
            break;

        case R.id.gamel_menu_checkmoves:
            showNotAgainDlgThen( R.string.not_again_sync,
                                 R.string.key_notagain_sync,
                                 new Runnable() {
                                     public void run() {
                                         doSyncMenuitem();
                                     }
                                 } );
            break;

        case R.id.gamel_menu_prefs:
            intent = new Intent( this, PrefsActivity.class );
            startActivity( intent );
            break;

        case R.id.gamel_menu_about:
            showAboutDialog();
            break;

        // case R.id.gamel_menu_view_hidden:
        //     Utils.notImpl( this );
        //     break;
        default:
            handled = false;
        }

        return handled;
    }

    @Override
    protected void onListItemClick( ListView l, View v, int position, long id )
    {
        super.onListItemClick( l, v, position, id );
        String path = DBUtils.gamesList( this )[position];

        // We need a way to let the user get back to the basic-config
        // dialog in case it was dismissed.  That way it to check for
        // an empty room name.
        GameSummary summary = DBUtils.getSummary( this, path );
        if ( summary.conType == CommsAddrRec.CommsConnType.COMMS_CONN_RELAY
             && summary.roomName.length() == 0 ) {
            // If it's unconfigured and of the type RelayGameActivity
            // can handle send it there, otherwise use the full-on
            // config.
            Class clazz;
            if ( RelayGameActivity.isSimpleGame( summary ) ) {
                clazz = RelayGameActivity.class;
            } else {
                clazz = GameConfig.class;
            }
            GameUtils.doConfig( this, path, clazz );
        } else {
            if ( checkWarnNoDict( path ) ) {
                File file = new File( path );
                Uri uri = Uri.fromFile( file );
                Intent intent = new Intent( Intent.ACTION_EDIT, uri,
                                            this, BoardActivity.class );
                startActivity( intent );
            }
        }
        m_invalPath = path;
    }

    private boolean handleMenuItem( int menuID, int position ) 
    {
        boolean handled = true;
        DialogInterface.OnClickListener lstnr;

        final String path = DBUtils.gamesList( this )[position];
    
        if ( R.id.list_item_delete == menuID ) {
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int ii ) {
                        GameUtils.deleteGame( GamesList.this, path, true );
                        m_adapter.inval( path );
                        onContentChanged();
                    }
                };
            showConfirmThen( R.string.confirm_delete, lstnr );
        } else {
            String invalPath = null;
            if ( checkWarnNoDict( path ) ) {
                switch ( menuID ) {
                case R.id.list_item_reset:
                    lstnr = new DialogInterface.OnClickListener() {
                            public void onClick( DialogInterface dlg, int ii ) {
                                GameUtils.resetGame( GamesList.this, path );
                                m_adapter.inval( path );
                                onContentChanged();
                            }
                        };
                    showConfirmThen( R.string.confirm_reset, lstnr );
                    break;
                case R.id.list_item_config:
                    GameUtils.doConfig( this, path, GameConfig.class );
                    m_invalPath = path;
                    break;

                case R.id.list_item_new_from:
                    String newName = GameUtils.dupeGame( this, path );  
                    invalPath = newName;
                    break;

                case R.id.list_item_copy:
                    GameSummary summary = DBUtils.getSummary( this, path );
                    if ( summary.inNetworkGame() ) {
                        showOKOnlyDialog( R.string.no_copy_network );
                    } else {
                        byte[] stream = GameUtils.savedGame( this, path );
                        newName = GameUtils.saveGame( this, stream );
                        DBUtils.saveSummary( this, newName, summary );
                    }
                    break;

                    // These require some notion of predictable sort order.
                    // Maybe put off until I'm using a db?
                    // case R.id.list_item_hide:
                    // case R.id.list_item_move_up:
                    // case R.id.list_item_move_down:
                    // case R.id.list_item_move_to_top:
                    // case R.id.list_item_move_to_bottom:
                    // Utils.notImpl( this );
                    // break;
                default:
                    handled = false;
                    break;
                }
            }

            if ( null != invalPath ) {
                m_adapter.inval( invalPath );
            }
            if ( handled ) {
                onContentChanged();
            }
        }

        return handled;
    } // handleMenuItem

    private boolean checkWarnNoDict( String path )
    {
        String[] missingName = new String[1];
        int[] missingLang = new int[1];
        boolean hasDict = GameUtils.gameDictHere( this, path, 
                                                  missingName, missingLang );
        if ( !hasDict ) {
            m_missingDictName = missingName[0];
            m_missingDictLang = missingLang[0];
            m_missingDictPath = path;
            if ( 0 == DictLangCache.getLangCount( this, m_missingDictLang ) ) {
                showDialog( WARN_NODICT );
            } else {
                showDialog( WARN_NODICT_SUBST );
            }
        }
        return hasDict;
    }

    private String saveNew( CurGameInfo gi )
    {
        String path = null;
        byte[] bytes = XwJNI.gi_to_stream( gi );
        if ( null != bytes ) {
            path = GameUtils.saveGame( this, bytes );
        }
        return path;
    }

    private String addGame( boolean networked )
    {
        String path = saveNew( new CurGameInfo( this, networked ) );
        GameUtils.resetGame( this, path );
        onContentChanged();
        return path;
    }
}
",True,47,32,0,0,4,17,0,17,L3
2,org.eehouse.android.xw4.PrefsActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;
import android.preference.PreferenceActivity;
import android.app.Dialog;
import android.app.AlertDialog;
import android.content.Intent;
import android.content.DialogInterface;
import android.os.Bundle;
import android.content.SharedPreferences;
import android.preference.Preference;
import android.preference.PreferenceManager;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MenuInflater;

public class PrefsActivity extends PreferenceActivity 
    implements SharedPreferences.OnSharedPreferenceChangeListener {

    private static final int REVERT_COLORS = 1;
    private static final int REVERT_ALL = 2;

    private String[] m_keys;

    @Override
    protected Dialog onCreateDialog( int id )
    {
        DialogInterface.OnClickListener lstnr = null;
        int confirmID = 0;

        switch( id ) {
        case REVERT_COLORS:
            confirmID = R.string.confirm_revert_colors;
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        SharedPreferences sp =
                            getPreferenceScreen().getSharedPreferences();
                        SharedPreferences.Editor editor = sp.edit();
                        int[] colorKeys = {
                            R.string.key_player0,
                            R.string.key_player1,
                            R.string.key_player2,
                            R.string.key_player3,
                            R.string.key_bonus_l2x,
                            R.string.key_bonus_l3x,
                            R.string.key_bonus_w2x,
                            R.string.key_bonus_w3x,
                            R.string.key_tile_back,
                            R.string.key_clr_crosshairs,
                            R.string.key_empty,
                        };
                        for ( int colorKey : colorKeys ) {
                            editor.remove( getString(colorKey) );
                        }
                        editor.commit();
                        relaunch();
                    }
                };
            break;
        case REVERT_ALL:
            confirmID = R.string.confirm_revert_all;
            lstnr = new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        SharedPreferences sp =
                            getPreferenceScreen().getSharedPreferences();
                        SharedPreferences.Editor editor = sp.edit();
                        editor.clear();
                        editor.commit();
                        relaunch();
                    }
                };
            break;
        }

        Dialog dialog = null;
        if ( null != lstnr ) {
            dialog = new AlertDialog.Builder( this )
                .setTitle( R.string.query_title )
                .setMessage( confirmID )
                .setPositiveButton( R.string.button_ok, lstnr )
                .setNegativeButton( R.string.button_cancel, null )
                .create();
        }
        return dialog;
    }

    @Override
    protected void onCreate( Bundle savedInstanceState )
    {
        super.onCreate(savedInstanceState);

        // Load the preferences from an XML resource
        addPreferencesFromResource( R.xml.xwprefs );

        int[] textKeyIds = { R.string.key_relay_host,
                             R.string.key_relay_port,
                             R.string.key_proxy_port,
                             R.string.key_dict_host,
                             R.string.key_board_size,
                             R.string.key_initial_player_minutes,
                             R.string.key_default_dict,
                             R.string.key_default_phonies,
        };

        SharedPreferences sp
            = PreferenceManager.getDefaultSharedPreferences( this );
        m_keys = new String[ textKeyIds.length ];
        for ( int ii = 0; ii < textKeyIds.length; ++ii ) {
            int id  = textKeyIds[ii];
            String key = getString( id );
            setSummary( sp, key );
            m_keys[ii] = key;
        }
    }
    
    @Override
    protected void onResume() 
    {
        super.onResume();
        getPreferenceScreen().getSharedPreferences().
            registerOnSharedPreferenceChangeListener(this);   
   }

    @Override
    protected void onPause() 
    {
        super.onPause();
        getPreferenceScreen().getSharedPreferences().
            unregisterOnSharedPreferenceChangeListener(this);
    }

    public void onSharedPreferenceChanged( SharedPreferences sp, String key ) 
    {
        for ( String akey : m_keys ) {
            if ( akey.equals( key ) ) {
                setSummary( sp, key );
                break;
            }
        }
    }

    @Override
    public boolean onCreateOptionsMenu( Menu menu )
    {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.prefs_menu, menu );
        return true;
    }

    @Override
    public boolean onOptionsItemSelected( MenuItem item )
    {
        int dlgID = 0;
        switch ( item.getItemId() ) {
        case R.id.menu_revert_all:
            dlgID = REVERT_ALL;
            break;
        case R.id.menu_revert_colors:
            dlgID = REVERT_COLORS;
            break;
        }

        boolean handled = 0 != dlgID;
        if ( handled ) {
            showDialog( dlgID );
        }
        return handled;
    }

    private void setSummary( SharedPreferences sp, String key )
    {
        Preference pref = getPreferenceScreen().findPreference( key );
        String value = sp.getString( key, """" );
        if ( ! value.equals("""") ) {
            if ( pref instanceof android.preference.ListPreference ) {
                Utils.logf( ""%s: want to do lookup of user string here"",
                            key );
            }
            pref.setSummary( value );
        }
    }


    private void relaunch()
    {
        PreferenceManager.setDefaultValues( this, R.xml.xwprefs,
                                            false );

        // Now replace this activity with a new copy
        // so the new values get loaded.
        startActivity( new Intent( this, PrefsActivity.class ) );
        finish();
    }

}
",False,42,21,0,0,5,9,0,1,L3
3,org.eehouse.android.xw4.GameUtils.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import android.net.Uri;
import java.util.ArrayList;
import android.content.res.AssetManager;

import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class GameUtils {

    private static Object s_syncObj = new Object();

    public static byte[] savedGame( Context context, String path )
    {
        return DBUtils.loadGame( context, path );
    } // savedGame

    /**
     * Open an existing game, and use its gi and comms addr as the
     * basis for a new one.
     */
    public static void resetGame( Context context, String pathIn, 
                                  String pathOut )
    {
        int gamePtr = XwJNI.initJNI();
        CurGameInfo gi = new CurGameInfo( context );
        CommsAddrRec addr = null;

        // loadMakeGame, if makinga new game, will add comms as long
        // as DeviceRole.SERVER_STANDALONE != gi.serverRole
        loadMakeGame( context, gamePtr, gi, pathIn );
        byte[] dictBytes = GameUtils.openDict( context, gi.dictName );
        
        if ( XwJNI.game_hasComms( gamePtr ) ) {
            addr = new CommsAddrRec( context );
            XwJNI.comms_getAddr( gamePtr, addr );
            if ( CommsAddrRec.CommsConnType.COMMS_CONN_NONE == addr.conType ) {
                String relayName = CommonPrefs.getDefaultRelayHost( context );
                int relayPort = CommonPrefs.getDefaultRelayPort( context );
                XwJNI.comms_getInitialAddr( addr, relayName, relayPort );
            }
        }
        XwJNI.game_dispose( gamePtr );

        gi.setInProgress( false );

        gamePtr = XwJNI.initJNI();
        XwJNI.game_makeNewGame( gamePtr, gi, JNIUtilsImpl.get(), 
                                CommonPrefs.get( context ), dictBytes, 
                                gi.dictName );
        if ( null != addr ) {
            XwJNI.comms_setAddr( gamePtr, addr );
        }
        saveGame( context, gamePtr, gi, pathOut );

        GameSummary summary = new GameSummary( gi );
        XwJNI.game_summarize( gamePtr, summary );
        DBUtils.saveSummary( context, pathOut, summary );

        XwJNI.game_dispose( gamePtr );
    } // resetGame

    public static void resetGame( Context context, String pathIn )
    {
        tellRelayDied( context, pathIn, true );
        resetGame( context, pathIn, pathIn );
    }

    public static GameSummary summarize( Context context, String path )
    {
        int gamePtr = XwJNI.initJNI();
        CurGameInfo gi = new CurGameInfo( context );
        loadMakeGame( context, gamePtr, gi, path );

        GameSummary summary = new GameSummary( gi );
        XwJNI.game_summarize( gamePtr, summary );
        DBUtils.saveSummary( context, path, summary );

        XwJNI.game_dispose( gamePtr );
        return summary;
    }

    public static String dupeGame( Context context, String pathIn )
    {
        String newName = newName( context );
        resetGame( context, pathIn, newName );
        return newName;
    }

    public static void deleteGame( Context context, String path,
                                   boolean informNow )
    {
        // does this need to be synchronized?
        tellRelayDied( context, path, informNow );
        DBUtils.deleteGame( context, path );
    }

    public static void loadMakeGame( Context context, int gamePtr, 
                                     CurGameInfo gi, String path )
    {
        byte[] stream = savedGame( context, path );
        XwJNI.gi_from_stream( gi, stream );
        byte[] dictBytes = GameUtils.openDict( context, gi.dictName );

        boolean madeGame = XwJNI.game_makeFromStream( gamePtr, stream, 
                                                      JNIUtilsImpl.get(), gi, 
                                                      dictBytes, gi.dictName,
                                                      CommonPrefs.get(context));
        if ( !madeGame ) {
            XwJNI.game_makeNewGame( gamePtr, gi, JNIUtilsImpl.get(), 
                                    CommonPrefs.get(context), dictBytes, 
                                    gi.dictName );
        }
    }

    public static void saveGame( Context context, int gamePtr, 
                                 CurGameInfo gi, String path )
    {
        byte[] stream = XwJNI.game_saveToStream( gamePtr, gi );
        saveGame( context, stream, path );
    }

    public static void saveGame( Context context, int gamePtr, 
                                 CurGameInfo gi )
    {
        saveGame( context, gamePtr, gi, newName( context ) );
    }

    public static void saveGame( Context context, byte[] bytes, String path )
    {
        DBUtils.saveGame( context, path, bytes );
    }

    public static String saveGame( Context context, byte[] bytes )
    {
        String name = newName( context );
        saveGame( context, bytes, name );
        return name;
    }

    public static boolean gameDictHere( Context context, String path, 
                                        String[] missingName, 
                                        int[] missingLang )
    {
        byte[] stream = savedGame( context, path );
        CurGameInfo gi = new CurGameInfo( context );
        XwJNI.gi_from_stream( gi, stream );
        String dictName = removeDictExtn( gi.dictName );
        missingName[0] = dictName;
        missingLang[0] = gi.dictLang;

        boolean exists = false;
        for ( String name : dictList( context ) ) {
            if ( name.equals( dictName ) ){
                exists = true;
                break;
            }
        }
        return exists;
    }

    public static boolean gameDictHere( Context context, int indx, 
                                        String[] name, int[] lang )
    {
        String path = DBUtils.gamesList( context )[indx];
        return gameDictHere( context, path, name, lang );
    }

    public static String newName( Context context ) 
    {
        String name = null;
        Integer num = 1;
        int ii;
        String[] files = DBUtils.gamesList( context );
        String fmt = context.getString( R.string.gamef );

        while ( name == null ) {
            name = String.format( fmt + XWConstants.GAME_EXTN, num );
            for ( ii = 0; ii < files.length; ++ii ) {
                if ( files[ii].equals(name) ) {
                    ++num;
                    name = null;
                }
            }
        }
        return name;
    }

    public static String[] dictList( Context context )
    {
        ArrayList<String> al = new ArrayList<String>();

        for ( String file : getAssets( context ) ) {
            if ( isDict( file ) ) {
                al.add( removeDictExtn( file ) );
            }
        }

        for ( String file : context.fileList() ) {
            if ( isDict( file ) ) {
                al.add( removeDictExtn( file ) );
            }
        }

        return al.toArray( new String[al.size()] );
    }

    public static boolean dictExists( Context context, String name )
    {
        boolean exists = dictIsBuiltin( context, name );
        if ( !exists ) {
            name = addDictExtn( name );
            try {
                FileInputStream fis = context.openFileInput( name );
                fis.close();
                exists = true;
            } catch ( java.io.FileNotFoundException fnf ) {
            } catch ( java.io.IOException ioe ) {
            }
        }
        return exists;
    }

    public static boolean dictIsBuiltin( Context context, String name )
    {
        boolean builtin = false;
        name = addDictExtn( name );

        for ( String file : getAssets( context ) ) {
            if ( file.equals( name ) ) {
                builtin = true;
                break;
            }
        }

        return builtin;
    }

    public static void deleteDict( Context context, String name )
    {
        context.deleteFile( addDictExtn( name ) );
    }

    public static byte[] openDict( Context context, String name )
    {
        byte[] bytes = null;
        InputStream dict = null;

        name = addDictExtn( name );

        AssetManager am = context.getAssets();
        try {
            dict = am.open( name, 
                            android.content.res.AssetManager.ACCESS_RANDOM );

            int len = dict.available();
            bytes = new byte[len];
            int nRead = dict.read( bytes, 0, len );
            if ( nRead != len ) {
                Utils.logf( ""**** warning ****; read only "" + nRead + "" of "" 
                            + len + "" bytes."" );
            }
        } catch ( java.io.IOException ee ){
            Utils.logf( ""%s failed to open; likely not built-in"", name );
        }

        // not an asset?  Try storage
        if ( null == bytes ) {
            try {
                FileInputStream fis = context.openFileInput( name );
                int len = fis.available();
                bytes = new byte[len];
                fis.read( bytes, 0, len );
                fis.close();
            } catch ( java.io.FileNotFoundException fnf ) {
                Utils.logf( fnf.toString() );
            } catch ( java.io.IOException ioe ) {
                Utils.logf( ioe.toString() );
            }
        }
        
        return bytes;
    }

    public static void saveDict( Context context, String name, InputStream in )
    {
        int totalRead = 0;
        try {
            FileOutputStream fos = context.openFileOutput( name,
                                                           Context.MODE_PRIVATE );
            byte[] buf = new byte[1024];
            int nRead;
            while( 0 <= (nRead = in.read( buf, 0, buf.length )) ) {
                fos.write( buf, 0, nRead );
                totalRead += nRead;
            }
            fos.close();
        } catch ( java.io.FileNotFoundException fnf ) {
            Utils.logf( ""saveDict: FileNotFoundException: %s"", fnf.toString() );
        } catch ( java.io.IOException ioe ) {
            Utils.logf( ""saveDict: IOException: %s"", ioe.toString() );
        }
    } 

    private static boolean isGame( String file )
    {
        return file.endsWith( XWConstants.GAME_EXTN );
    }

    private static boolean isDict( String file )
    {
        return file.endsWith( XWConstants.DICT_EXTN );
    }

    public static String gameName( Context context, String path )
    {
        return path.substring( 0, path.lastIndexOf( XWConstants.GAME_EXTN ) );
    }

    public static void launchGame( Activity activity, String path )
    {
        File file = new File( path );
        Uri uri = Uri.fromFile( file );
        Intent intent = new Intent( Intent.ACTION_EDIT, uri,
                                    activity, BoardActivity.class );
        activity.startActivity( intent );
        activity.finish();
    }

    // This *must* involve a reset if the language is changing!!!
    // Which isn't possible right now, so make sure the old and new
    // dict have the same langauge code.
    public static void replaceDict( Context context, String path,
                                    String dict )
    {
        byte[] stream = savedGame( context, path );
        CurGameInfo gi = new CurGameInfo( context );
        byte[] dictBytes = GameUtils.openDict( context, dict );

        int gamePtr = XwJNI.initJNI();
        XwJNI.game_makeFromStream( gamePtr, stream, 
                                   JNIUtilsImpl.get(), gi,
                                   dictBytes, dict,         
                                   CommonPrefs.get( context ) );
        gi.dictName = dict;

        saveGame( context, gamePtr, gi, path );

        GameSummary summary = new GameSummary( gi );
        XwJNI.game_summarize( gamePtr, summary );
        DBUtils.saveSummary( context, path, summary );

        XwJNI.game_dispose( gamePtr );
    }

    public static void applyChanges( Context context, CurGameInfo gi, 
                                     CommsAddrRec car, String path, 
                                     boolean forceNew )
    {
        // This should be a separate function, commitChanges() or
        // somesuch.  But: do we have a way to save changes to a gi
        // that don't reset the game, e.g. player name for standalone
        // games?
        byte[] dictBytes = GameUtils.openDict( context, gi.dictName );
        int gamePtr = XwJNI.initJNI();
        boolean madeGame = false;
        CommonPrefs cp = CommonPrefs.get( context );

        if ( forceNew ) {
            tellRelayDied( context, path, true );
        } else {
            byte[] stream = GameUtils.savedGame( context, path );
            // Will fail if there's nothing in the stream but a gi.
            madeGame = XwJNI.game_makeFromStream( gamePtr, stream, 
                                                  JNIUtilsImpl.get(),
                                                  new CurGameInfo(context), 
                                                  dictBytes, gi.dictName, cp );
        }

        if ( forceNew || !madeGame ) {
            gi.setInProgress( false );
            XwJNI.game_makeNewGame( gamePtr, gi, JNIUtilsImpl.get(), 
                                    cp, dictBytes, gi.dictName );
        }

        if ( null != car ) {
            XwJNI.comms_setAddr( gamePtr, car );
        }

        GameUtils.saveGame( context, gamePtr, gi, path );

        GameSummary summary = new GameSummary( gi );
        XwJNI.game_summarize( gamePtr, summary );
        DBUtils.saveSummary( context, path, summary );

        XwJNI.game_dispose( gamePtr );
    } // applyChanges

    public static void doConfig( Activity activity, String path, Class clazz )
    {
        Uri uri = Uri.fromFile( new File(path) );
        Intent intent = new Intent( Intent.ACTION_EDIT, uri, activity, clazz );
        activity.startActivity( intent );
    }

    public static String removeDictExtn( String str )
    {
        if ( str.endsWith( XWConstants.DICT_EXTN ) ) {
            int indx = str.lastIndexOf( XWConstants.DICT_EXTN );
            str = str.substring( 0, indx );
        }
        return str;
    }

    private static String addDictExtn( String str ) 
    {
        if ( ! str.endsWith( XWConstants.DICT_EXTN ) ) {
            str += XWConstants.DICT_EXTN;
        }
        return str;
    }

    private static String[] getAssets( Context context )
    {
        try {
            AssetManager am = context.getAssets();
            return am.list("""");
        } catch( java.io.IOException ioe ) {
            Utils.logf( ioe.toString() );
            return new String[0];
        }
    }
    
    private static void tellRelayDied( Context context, String path,
                                       boolean informNow )
    {
        GameSummary summary = DBUtils.getSummary( context, path );
        if ( null != summary.relayID ) {
            DBUtils.addDeceased( context, summary.relayID, summary.seed );
            if ( informNow ) {
                NetUtils.informOfDeaths( context );
            }
        }
    }

}
",True,1,32,2,9,3,10,13,10,L0
4,org.eehouse.android.xw4.GameConverter.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import java.io.FileInputStream;
import java.util.ArrayList;

// Rip this out a month or so after releasing...
public class GameConverter {

    public static void convert( Context context )
    {
        String[] games = gamesList( context );
        if ( null == games ) {
            Utils.logf( ""GameConverter::convert() no old games found"" );
        } else {
            for ( String game : games ) {
                Utils.logf( ""GameConverter::convert() converting %s"",
                            game );
                byte[] bytes = savedGame( context, game );
                DBUtils.saveGame( context, game, bytes );
                context.deleteFile( game );
            }
        }
    }

    private static byte[] savedGame( Context context, String path )
    {
        byte[] stream = null;
        try {
            FileInputStream in = context.openFileInput( path );
            int len = in.available();
            stream = new byte[len];
            in.read( stream, 0, len );
            in.close();
        } catch ( java.io.FileNotFoundException fnf ) {
            Utils.logf( fnf.toString() );
            stream = null;
        } catch ( java.io.IOException io ) {
            Utils.logf( io.toString() );
            stream = null;
        }
        return stream;
    }

    private static String[] gamesList( Context context )
    {
        ArrayList<String> al = new ArrayList<String>();
        for ( String file : context.fileList() ) {
            if ( file.endsWith( XWConstants.GAME_EXTN ) ) {
                al.add( file );
            }
        }

        int siz = al.size();
        String[] result = null;
        if ( siz > 0 ) {
            result = al.toArray( new String[siz] );
        }
        return result;
    }
}
",True,20,22,1,1,5,7,1,3,L3
5,org.eehouse.android.xw4.CommsTransport.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.UnresolvedAddressException;
import java.nio.ByteBuffer;
import java.net.InetSocketAddress;
import java.util.Vector;
import java.util.Iterator;
import junit.framework.Assert;
import android.telephony.SmsManager;
import android.content.BroadcastReceiver;
import android.content.Intent;
import android.content.IntentFilter;
import android.app.PendingIntent;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Build;
import android.os.Handler;
import android.os.Message;

import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.JNIThread.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class CommsTransport implements TransportProcs {

    public static final int DIALOG = 0;
    public static final int DIALOG_RETRY = 1;
    public static final int TOAST = 2;
    public static final int RELAY_COND = 3;

    public static final int RELAY_CONNND_ALLHERE = 0;
    public static final int RELAY_CONNND_MISSING = 1;

    public class ConndMsg {
        ConndMsg( String room, int devOrder, boolean allHere, int nMissing )
        {
            m_room = room;
            m_devOrder = devOrder;
            m_allHere = allHere;
            m_nMissing = nMissing;
        }
        public String m_room;
        public int m_devOrder;
        public boolean m_allHere;
        public int m_nMissing;
    }

    private Selector m_selector;
    private SocketChannel m_socketChannel;
    private int m_jniGamePtr;
    private CommsAddrRec m_addr;
    private JNIThread m_jniThread;
    private CommsThread m_thread;
    private Handler m_handler;
    private boolean m_done = false;

    private Vector<ByteBuffer> m_buffersOut;
    private ByteBuffer m_bytesOut;
    private ByteBuffer m_bytesIn;

    private Context m_context;
    private BroadcastReceiver m_receiver;
    private boolean m_netAvail = true;

    // assembling inbound packet
    private byte[] m_packetIn;
    private int m_haveLen = -1;

    public CommsTransport( int jniGamePtr, Context context, Handler handler,
                           DeviceRole role )
    {
        m_jniGamePtr = jniGamePtr;
        m_context = context;
        m_handler = handler;
        m_buffersOut = new Vector<ByteBuffer>();
        m_bytesIn = ByteBuffer.allocate( 2048 );

        buildNetAvailReceiver();
    }

    public class CommsThread extends Thread {

        @Override
        public void run()
        {
            m_done = false;
            boolean failed = true;
            try {   
                if ( Build.PRODUCT.contains(""sdk"") ) {
                    System.setProperty(""java.net.preferIPv6Addresses"", ""false"");
                }

                m_selector = Selector.open();

                failed = loop();

                closeSocket();
            } catch ( java.io.IOException ioe ) {
                Utils.logf( ioe.toString() );
            } catch ( UnresolvedAddressException uae ) {
                Utils.logf( ""bad address: name: %s; port: %s; exception: %s"",
                            m_addr.ip_relay_hostName, m_addr.ip_relay_port, 
                            uae.toString() );
            }

            m_thread = null;
            if ( failed ) {
                m_jniThread.handle( JNICmd.CMD_TRANSFAIL );
            }
        }

        private boolean loop()
        {
            boolean failed = false;
            outer_loop:
            while ( !m_done ) {
                try {
                    synchronized( this ) {

                        // if we have data and no socket, try to connect.
                        if ( null == m_socketChannel
                             && 0 < m_buffersOut.size() ) {
                            try {
                                m_socketChannel = SocketChannel.open();
                                m_socketChannel.configureBlocking( false );
                                Utils.logf( ""connecting to %s:%d"",
                                            m_addr.ip_relay_hostName, 
                                            m_addr.ip_relay_port );
                                InetSocketAddress isa = new 
                                    InetSocketAddress(m_addr.ip_relay_hostName,
                                                      m_addr.ip_relay_port );
                                m_socketChannel.connect( isa );
                            } catch ( java.io.IOException ioe ) {
                                Utils.logf( ioe.toString() );
                                failed = true;
                                break outer_loop;
                            }
                        }

                        if ( null != m_socketChannel ) {
                            int ops = figureOps();
                            // Utils.logf( ""calling with ops=%x"", ops );
                            m_socketChannel.register( m_selector, ops );
                        }
                    }
                    m_selector.select();
                } catch ( ClosedChannelException cce ) {
                    // we get this when relay goes down.  Need to notify!
                    failed = true;
                    closeSocket();
                    Utils.logf( ""exiting: "" + cce.toString() );
                    break;          // don't try again
                } catch ( java.io.IOException ioe ) {
                    closeSocket();
                    Utils.logf( ""exiting: "" + ioe.toString() );
                    Utils.logf( ioe.toString() );
                } catch ( java.nio.channels.NoConnectionPendingException ncp ) {
                    Utils.logf( ""%s"", ncp.toString() );
                    closeSocket();
                    break;
                }

                Iterator<SelectionKey> iter = m_selector.selectedKeys().iterator();
                while ( iter.hasNext() ) {
                    SelectionKey key = (SelectionKey)iter.next();
                    SocketChannel channel = (SocketChannel)key.channel();
                    iter.remove();
                    try { 
                        if (key.isValid() && key.isConnectable()) {
                            if ( !channel.finishConnect() ) {
                                key.cancel(); 
                            }
                        }
                        if (key.isValid() && key.isReadable()) {
                            m_bytesIn.clear(); // will wipe any pending data!
                            // Utils.logf( ""socket is readable; buffer has space for ""
                            //             + m_bytesIn.remaining() );
                            int nRead = channel.read( m_bytesIn );
                            if ( nRead == -1 ) {
                                channel.close();
                            } else {
                                addIncoming();
                            }
                        }
                        if (key.isValid() && key.isWritable()) {
                            getOut();
                            if ( null != m_bytesOut ) {
                                int nWritten = channel.write( m_bytesOut );
                                //Utils.logf( ""wrote "" + nWritten + "" bytes"" );
                            }
                        }
                    } catch ( java.io.IOException ioe ) {
                        Utils.logf( ""%s: cancelling key"", ioe.toString() );
                        key.cancel(); 
                        failed = true;
                        break outer_loop;
                    } catch ( java.nio.channels.
                              NoConnectionPendingException ncp ) {
                        Utils.logf( ""%s"", ncp.toString() );
                        break outer_loop;
                    }
                }
            }
            return failed;
        } // loop
    }
    
    public void setReceiver( JNIThread jnit )
    {
        m_jniThread = jnit;
    }

    public void waitToStop()
    {
        waitToStopImpl();
        if ( null != m_receiver ) {
            m_context.unregisterReceiver( m_receiver );
            m_receiver = null;
        }
    }

    private synchronized void putOut( final byte[] buf )
    {
        int len = buf.length;
        ByteBuffer netbuf = ByteBuffer.allocate( len + 2 );
        netbuf.putShort( (short)len );
        netbuf.put( buf );
        m_buffersOut.add( netbuf );
        Assert.assertEquals( netbuf.remaining(), 0 );

        if ( null != m_selector ) {
            m_selector.wakeup();    // tell it it's got some writing to do
        }
    }

    private synchronized void closeSocket()
    {
        if ( null != m_socketChannel ) {
            try {
                m_socketChannel.close();
            } catch ( Exception e ) {
                Utils.logf( ""closing socket: %s"", e.toString() );
            }
            m_socketChannel = null;
        }
    }

    private synchronized void getOut()
    {
        if ( null != m_bytesOut && m_bytesOut.remaining() == 0 ) {
            m_bytesOut = null;
        }

        if ( null == m_bytesOut && m_buffersOut.size() > 0 ) {
            m_bytesOut = m_buffersOut.remove(0);
            m_bytesOut.flip();
        }
    }

    private synchronized int figureOps() {
        int ops;
        if ( null == m_socketChannel ) {
            ops = 0;
        } else if ( m_socketChannel.isConnected() ) {
            ops = SelectionKey.OP_READ;
            if ( (null != m_bytesOut && m_bytesOut.hasRemaining())
                 || m_buffersOut.size() > 0 ) {
                ops |= SelectionKey.OP_WRITE;
            }
        } else {
            ops = SelectionKey.OP_CONNECT;
        }
        return ops;
    }

    private void addIncoming( )
    {
        m_bytesIn.flip();
        
        for ( ; ; ) {
            int len = m_bytesIn.remaining();
            if ( len <= 0 ) {
                break;
            }

            if ( null == m_packetIn ) { // we're not mid-packet
                Assert.assertTrue( len > 1 ); // tell me if I see this case
                if ( len == 1 ) {       // half a length byte...
                    break;              // can I leave it in the buffer?
                } else {                
                    m_packetIn = new byte[m_bytesIn.getShort()];
                    m_haveLen = 0;
                }
            } else {                    // we're mid-packet
                int wantLen = m_packetIn.length - m_haveLen;
                if ( wantLen > len ) {
                    wantLen = len;
                }
                m_bytesIn.get( m_packetIn, m_haveLen, wantLen );
                m_haveLen += wantLen;
                if ( m_haveLen == m_packetIn.length ) {
                    // send completed packet
                    m_jniThread.handle( JNICmd.CMD_RECEIVE, m_packetIn );
                    m_packetIn = null;
                }
            }
        }
    }

    private class CommsBroadcastReceiver extends BroadcastReceiver {
        @Override
        public void onReceive( Context context, Intent intent ) 
        {
            if ( intent.getAction().
                 equals( ConnectivityManager.CONNECTIVITY_ACTION)) {

                NetworkInfo ni = (NetworkInfo)intent.
                    getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
                boolean netAvail = NetworkInfo.State.CONNECTED == ni.getState();

                boolean netAvailDet = NetworkInfo.DetailedState.CONNECTED == 
                    ni.getDetailedState();

                Utils.logf( ""CommsTransport::onReceive: netAvail=%s;netAvailDet=%s"",
                            netAvail?""true"":""false"", netAvailDet?""true"":""false"" );
                m_netAvail = netAvail;
                if ( !netAvail ) {
                    waitToStopImpl();
                    m_jniThread.handle( JNICmd.CMD_TRANSFAIL );
                }
            }
        }
    }

    private void buildNetAvailReceiver()
    {
        m_receiver = new CommsBroadcastReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction( ConnectivityManager.CONNECTIVITY_ACTION );
        Intent intent = m_context.registerReceiver( m_receiver, filter );
    }

    private void waitToStopImpl()
    {
        m_done = true;          // this is in a race!
        if ( null != m_selector ) {
            m_selector.wakeup();
        }
        if ( null != m_thread ) {     // synchronized this?  Or use Thread method
            try {
                m_thread.join(100);   // wait up to 1/10 second
            } catch ( java.lang.InterruptedException ie ) {
                Utils.logf( ""got InterruptedException: "" + ie.toString() );
            }
            m_thread = null;
        }
    }

    // TransportProcs interface
    public int transportSend( byte[] buf, final CommsAddrRec faddr )
    {
        //Utils.logf( ""CommsTransport::transportSend(nbytes=%d)"", buf.length );
        int nSent = -1;

        if ( null == m_addr ) {
            if ( null == faddr ) {
                m_addr = new CommsAddrRec( m_context );
                XwJNI.comms_getAddr( m_jniGamePtr, m_addr );
            } else {
                m_addr = new CommsAddrRec( faddr );
            }
        }

        switch ( m_addr.conType ) {
        case COMMS_CONN_RELAY:
            if ( m_netAvail ) {
                putOut( buf );      // add to queue
                if ( null == m_thread ) {
                    m_thread = new CommsThread();
                    m_thread.start();
                }
                nSent = buf.length;
            }
            break;
        case COMMS_CONN_SMS:
            Assert.fail();
            // This code can't be here, even if unreachable, unless
            // app has permission to use SMS.  So put it in a separate
            // module and catch the error that'll come when it fails
            // to verify.  IFF the plan's to ship a version that
            // doesn't do SMS.

            // Utils.logf( ""sending via sms to  %s:%d"", 
            //             m_addr.sms_phone, m_addr.sms_port );
            // try {
            //     Intent intent = new Intent( m_context, StatusReceiver.class);
            //     PendingIntent pi
            //         = PendingIntent.getBroadcast( m_context, 0,
            //                                       intent, 0 );
            //     if ( 0 == m_addr.sms_port ) {
            //          SmsManager.getDefault().sendTextMessage( m_addr.sms_phone,
            //                                                   null, ""Hello world"",
            //                                                   pi, pi );
            //         Utils.logf( ""called sendTextMessage"" );
            //     } else {
            //         SmsManager.getDefault().
            //             sendDataMessage( m_addr.sms_phone, (String)null,
            //                              (short)m_addr.sms_port, 
            //                              buf, pi, pi );
            //         Utils.logf( ""called sendDataMessage"" );
            //     }
            //     nSent = buf.length;
            // } catch ( java.lang.IllegalArgumentException iae ) {
            //     Utils.logf( iae.toString() );
            // }
            break;
        case COMMS_CONN_BT:
        default:
            Assert.fail();
            break;
        }

        return nSent;
    } 

    public void relayStatus( CommsRelayState newState )
    {
        //Utils.logf( ""relayStatus called; state=%s"", newState.toString() );
        if ( null != m_jniThread ) {
            m_jniThread.handle( JNICmd.CMD_DRAW_CONNS_STATUS, newState );
        } else {
            Utils.logf( ""can't draw status yet"" );
        }
    }

    public void relayConnd( String room, int devOrder, boolean allHere, 
                            int nMissing )
    {
        ConndMsg cndmsg = new ConndMsg( room, devOrder, allHere, nMissing );
        Message.obtain( m_handler, RELAY_COND, cndmsg ).sendToTarget();
    }

    public void relayErrorProc( XWRELAY_ERROR relayErr )
    {
        //Utils.logf( ""relayErrorProc called; got "" + relayErr.toString() );

        int strID = 0;
        int how = TOAST;

        switch ( relayErr ) {
        case TOO_MANY: 
            strID = R.string.msg_too_many;
            how = DIALOG;
            break;
        case NO_ROOM:
            strID = R.string.msg_no_room;
            how = DIALOG_RETRY;
            break;
        case DUP_ROOM:
            strID = R.string.msg_dup_room;
            how = DIALOG;
            break;
        case LOST_OTHER:
        case OTHER_DISCON:
            strID = R.string.msg_lost_other;
            break;

        case DELETED:
            strID = R.string.msg_dev_deleted;
            how = DIALOG;
            break;

        case OLDFLAGS:
        case BADPROTO:
        case RELAYBUSY:
        case SHUTDOWN:
        case TIMEOUT:
        case HEART_YOU:
        case HEART_OTHER:
            break;
        }

        if ( 0 != strID ) {
            String str = m_context.getString( strID );
            Message.obtain( m_handler, how, R.string.relay_alert, 
                            0, str ).sendToTarget();
        }
    }
}
",True,14,30,1,1,5,11,1,5,L3
6,org.eehouse.android.xw4.DBUtils.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.Cursor;
import java.util.StringTokenizer;
import android.content.ContentValues;
import java.util.ArrayList;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;


public class DBUtils {

    private static SQLiteOpenHelper s_dbHelper = null;

    public static class Obit {
        public Obit( String relayID, int seed ) {
            m_relayID = relayID; m_seed = seed;
        }
        String m_relayID;
        int m_seed;
    }

    public static GameSummary getSummary( Context context, String file )
    {
        initDB( context );
        GameSummary summary = null;

        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String[] columns = { DBHelper.NUM_MOVES, DBHelper.NUM_PLAYERS,
                                 DBHelper.GAME_OVER, DBHelper.PLAYERS,
                                 DBHelper.CONTYPE, DBHelper.SERVERROLE,
                                 DBHelper.ROOMNAME, DBHelper.RELAYID, 
                                 DBHelper.SMSPHONE, DBHelper.SEED, 
                                 DBHelper.DICTLANG, DBHelper.DICTNAME,
                                 DBHelper.SCORES, DBHelper.HASMSGS
            };
            String selection = DBHelper.FILE_NAME + ""=\"""" + file + ""\"""";

            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );
            if ( 1 == cursor.getCount() && cursor.moveToFirst() ) {
                summary = new GameSummary();
                summary.nMoves = cursor.getInt(cursor.
                                               getColumnIndex(DBHelper.NUM_MOVES));
                summary.nPlayers = 
                    cursor.getInt(cursor.
                                  getColumnIndex(DBHelper.NUM_PLAYERS));
                summary.players = 
                    cursor.getString(cursor.
                                  getColumnIndex(DBHelper.PLAYERS));
                summary.dictLang = 
                    cursor.getInt(cursor.
                                  getColumnIndex(DBHelper.DICTLANG));
                summary.dictName = 
                    cursor.getString(cursor.
                                     getColumnIndex(DBHelper.DICTNAME));
                int tmp = cursor.getInt(cursor.
                                        getColumnIndex(DBHelper.GAME_OVER));
                summary.gameOver = tmp == 0 ? false : true;

                String scoresStr = 
                    cursor.getString( cursor.getColumnIndex(DBHelper.SCORES));
                if ( null != scoresStr ) {
                    StringTokenizer st = new StringTokenizer( scoresStr );
                    int[] scores = new int[st.countTokens()];
                    for ( int ii = 0; ii < scores.length; ++ii ) {
                        Assert.assertTrue( st.hasMoreTokens() );
                        String token = st.nextToken();
                        scores[ii] = Integer.parseInt( token );
                    }
                    summary.scores = scores;
                }

                int col = cursor.getColumnIndex( DBHelper.CONTYPE );
                if ( col >= 0 ) {
                    tmp = cursor.getInt( col );
                    summary.conType = CommsAddrRec.CommsConnType.values()[tmp];
                    col = cursor.getColumnIndex( DBHelper.ROOMNAME );
                    if ( col >= 0 ) {
                        summary.roomName = cursor.getString( col );
                    }
                    col = cursor.getColumnIndex( DBHelper.RELAYID );
                    if ( col >= 0 ) {
                        summary.relayID = cursor.getString( col );
                    }
                    col = cursor.getColumnIndex( DBHelper.SEED );
                    if ( col >= 0 ) {
                        summary.seed = cursor.getInt( col );
                    }
                    col = cursor.getColumnIndex( DBHelper.SMSPHONE );
                    if ( col >= 0 ) {
                        summary.smsPhone = cursor.getString( col );
                    }
                }

                col = cursor.getColumnIndex( DBHelper.SERVERROLE );
                tmp = cursor.getInt( col );
                summary.serverRole = CurGameInfo.DeviceRole.values()[tmp];
                
                col = cursor.getColumnIndex( DBHelper.HASMSGS );
                if ( col >= 0 ) {
                    summary.msgsPending = 0 != cursor.getInt( col );
                }
            }
            cursor.close();
            db.close();
        }

        if ( null == summary ) {
            summary = GameUtils.summarize( context, file );
            saveSummary( context, file, summary );
        }
        return summary;
    }

    public static void saveSummary( Context context, String path, 
                                    GameSummary summary )
    {
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();

            if ( null == summary ) {
                String selection = DBHelper.FILE_NAME + ""=\"""" + path + ""\"""";
                db.delete( DBHelper.TABLE_NAME_SUM, selection, null );
            } else {
                ContentValues values = new ContentValues();
                values.put( DBHelper.NUM_MOVES, summary.nMoves );
                values.put( DBHelper.NUM_PLAYERS, summary.nPlayers );
                values.put( DBHelper.PLAYERS, 
                            summary.summarizePlayers(context) );
                values.put( DBHelper.DICTLANG, summary.dictLang );
                values.put( DBHelper.DICTNAME, summary.dictName );
                values.put( DBHelper.GAME_OVER, summary.gameOver );
                values.put( DBHelper.HASMSGS, 0 );

                if ( null != summary.scores ) {
                    StringBuffer sb = new StringBuffer();
                    for ( int score : summary.scores ) {
                        sb.append( String.format( ""%d "", score ) );
                    }
                    values.put( DBHelper.SCORES, sb.toString() );
                }

                if ( null != summary.conType ) {
                    values.put( DBHelper.CONTYPE, summary.conType.ordinal() );
                    values.put( DBHelper.ROOMNAME, summary.roomName );
                    values.put( DBHelper.RELAYID, summary.relayID );
                    values.put( DBHelper.SEED, summary.seed );
                    values.put( DBHelper.SMSPHONE, summary.smsPhone );
                }
                values.put( DBHelper.SERVERROLE, summary.serverRole.ordinal() );

                Utils.logf( ""saveSummary: nMoves=%d"", summary.nMoves );

                String selection = DBHelper.FILE_NAME + ""=\"""" + path + ""\"""";
                long result = db.update( DBHelper.TABLE_NAME_SUM,
                                         values, selection, null );
                Assert.assertTrue( result >= 0 );
            }
            db.close();
        }
    } // saveSummary

    public static int countGamesUsing( Context context, String dict )
    {
        int result = 0;
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String selection = DBHelper.DICTNAME + "" LIKE \'"" 
                + dict + ""\'"";
            // null for columns will return whole rows: bad
            String[] columns = { DBHelper.DICTNAME };
            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );

            result = cursor.getCount();
            cursor.close();
            db.close();
        }
        return result;
    }

    public static void setHasMsgs( String relayID )
    {
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();
            
            String selection = DBHelper.RELAYID + ""=\'"" + relayID + ""\'"";
            ContentValues values = new ContentValues();
            values.put( DBHelper.HASMSGS, 1 );
            
            int result = db.update( DBHelper.TABLE_NAME_SUM, 
                                    values, selection, null );
            Assert.assertTrue( result == 1 );
            db.close();
        }
    }

    public static String getPathFor( Context context, String relayID )
    {
        String result = null;
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String[] columns = { DBHelper.FILE_NAME };
            String selection = DBHelper.RELAYID + ""='"" + relayID + ""'"";
            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );
            if ( 1 == cursor.getCount() && cursor.moveToFirst() ) {
                result = cursor.getString( cursor
                                           .getColumnIndex(DBHelper.FILE_NAME));

            }
            cursor.close();
            db.close();
        }
        return result;
    }

    public static String[] getRelayIDNoMsgs( Context context )
    {
        String[] result = null;
        initDB( context );
        ArrayList<String> ids = new ArrayList<String>();

        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String[] columns = { DBHelper.RELAYID };
            String selection = DBHelper.RELAYID + "" NOT null AND "" 
                + ""NOT "" + DBHelper.HASMSGS;

            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );

            if ( 0 < cursor.getCount() ) {
                cursor.moveToFirst();
                for ( ; ; ) {
                    ids.add( cursor.
                             getString( cursor.
                                        getColumnIndex(DBHelper.RELAYID)) );
                    if ( cursor.isLast() ) {
                        break;
                    }
                    cursor.moveToNext();
                }
            }
            cursor.close();
            db.close();
        }

        if ( 0 < ids.size() ) {
            result = ids.toArray( new String[ids.size()] );
        }
        return result;
    }

    public static void addDeceased( Context context, String relayID, 
                                    int seed )
    {
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();

            ContentValues values = new ContentValues();
            values.put( DBHelper.RELAYID, relayID );
            values.put( DBHelper.SEED, seed );

            try {
                long result = db.replaceOrThrow( DBHelper.TABLE_NAME_OBITS,
                                                 """", values );
            } catch ( Exception ex ) {
                Utils.logf( ""ex: %s"", ex.toString() );
            }
            db.close();
        }
    }

    public static Obit[] listObits( Context context )
    {
        Obit[] result = null;
        ArrayList<Obit> al = new ArrayList<Obit>();

        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();
            String[] columns = { DBHelper.RELAYID, DBHelper.SEED };
            Cursor cursor = db.query( DBHelper.TABLE_NAME_OBITS, columns, 
                                      null, null, null, null, null );
            if ( 0 < cursor.getCount() ) {
                cursor.moveToFirst();
                for ( ; ; ) {
                    int index = cursor.getColumnIndex( DBHelper.RELAYID );
                    String relayID = cursor.getString( index );
                    index = cursor.getColumnIndex( DBHelper.SEED );
                    int seed = cursor.getInt( index );
                    al.add( new Obit( relayID, seed ) );
                    if ( cursor.isLast() ) {
                        break;
                    }
                    cursor.moveToNext();
                }
            }
            cursor.close();
            db.close();
        }

        int siz = al.size();
        if ( siz > 0 ) {
            result = al.toArray( new Obit[siz] );
        }
        return result;
    }

    public static void clearObits( Context context, Obit[] obits )
    {
        String fmt = DBHelper.RELAYID + ""= \""%s\"" AND + "" 
            + DBHelper.SEED + "" = %d"";

        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();

            for ( Obit obit: obits ) {
                String selection = String.format( fmt, obit.m_relayID, 
                                                  obit.m_seed );
                db.delete( DBHelper.TABLE_NAME_OBITS, selection, null );
            }
            db.close();
        }
    }

    public static void saveGame( Context context, String path, byte[] bytes )
    {
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();

            String selection = DBHelper.FILE_NAME + ""=\"""" + path + ""\"""";
            ContentValues values = new ContentValues();
            values.put( DBHelper.SNAPSHOT, bytes );

            int result = db.update( DBHelper.TABLE_NAME_SUM, 
                                    values, selection, null );
            if ( 0 == result ) {
                values.put( DBHelper.FILE_NAME, path );
                long row = db.insert( DBHelper.TABLE_NAME_SUM, null, values );
                Assert.assertTrue( row >= 0 );
            }
            db.close();
        }
    }

    public static byte[] loadGame( Context context, String path )
    {
        Assert.assertNotNull( path );
        byte[] result = null;
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();

            String[] columns = { DBHelper.SNAPSHOT };
            String selection = DBHelper.FILE_NAME + ""=\"""" + path + ""\"""";
            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      selection, null, null, null, null );
            if ( 1 == cursor.getCount() && cursor.moveToFirst() ) {
                result = cursor.getBlob( cursor
                                         .getColumnIndex(DBHelper.SNAPSHOT));
            }
            cursor.close();
            db.close();
        }
        return result;
    }

    public static void deleteGame( Context context, String path )
    {
        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getWritableDatabase();
            String selection = DBHelper.FILE_NAME + ""=\"""" + path + ""\"""";
            db.delete( DBHelper.TABLE_NAME_SUM, selection, null );
            db.close();
        }
    }

    public static String[] gamesList( Context context )
    {
        ArrayList<String> al = new ArrayList<String>();

        initDB( context );
        synchronized( s_dbHelper ) {
            SQLiteDatabase db = s_dbHelper.getReadableDatabase();

            String[] columns = { DBHelper.FILE_NAME };
            Cursor cursor = db.query( DBHelper.TABLE_NAME_SUM, columns, 
                                      null, null, null, null, null );
            if ( 0 < cursor.getCount() ) {
                cursor.moveToFirst();
                for ( ; ; ) {
                    int index = cursor.getColumnIndex( DBHelper.FILE_NAME );
                    String name = cursor.getString( index );
                    al.add( cursor.getString( index ) );
                    if ( cursor.isLast() ) {
                        break;
                    }
                    cursor.moveToNext();
                }
            }
            cursor.close();
            db.close();
        }

        return al.toArray( new String[al.size()] );
    }

    private static void initDB( Context context )
    {
        if ( null == s_dbHelper ) {
            s_dbHelper = new DBHelper( context );
        }
    }

}
",True,18,29,2,5,4,7,7,6,L0
7,org.eehouse.android.xw4.BoardDims.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;


// Why does this have to be its own class...
public class BoardDims {
    public int width, height;       // of the bitmap
    public int left, top;
    public int scoreHt;
    public int boardHt;
    public int trayTop, trayHt;
    public int cellSize, maxCellSize;
    public int timerWidth;
}
",False,27,6,2,3,0,0,2,0,L3
8,org.eehouse.android.xw4.Utils.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.util.Log;
import java.lang.Thread;
import android.widget.Toast;
import android.content.Context;
import android.content.Intent;
import android.widget.CheckBox;
import android.app.Activity;
import android.app.Dialog;
import android.widget.EditText;
import android.widget.TextView;
import android.view.View;
import android.text.format.Time;
import java.util.Formatter;
import android.net.Uri;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;

public class Utils {
    static final String TAG = ""XW4"";

    static final String DB_PATH = ""XW_GAMES"";

    private static Time s_time = new Time();

    private Utils() {}

    public static void logf( String msg ) 
    {
        s_time.setToNow();
        String time = s_time.format(""[%H:%M:%S]"");
        long id = Thread.currentThread().getId();
        Log.d( TAG, time + ""-"" + id + ""-"" + msg );
    } // logf

    public static void logf( String format, Object... args )
    {
        Formatter formatter = new Formatter();
        logf( formatter.format( format, args ).toString() );
    } // logf

    public static void notImpl( Context context ) 
    {
        CharSequence text = ""Feature coming soon"";
        Toast.makeText( context, text, Toast.LENGTH_SHORT).show();
    }

    public static Intent mkDownloadActivity( Context context,
                                             String dict, int lang )
    {
        String dict_url = CommonPrefs.getDefaultDictURL( context );
        if ( null != dict ) {
            dict_url += ""/"" + DictLangCache.getLangName( context, lang )
                + ""/"" + dict + XWConstants.DICT_EXTN;
        }
        Uri uri = Uri.parse( dict_url );
        Intent intent = new Intent( Intent.ACTION_VIEW, uri );
        intent.setFlags( Intent.FLAG_ACTIVITY_NEW_TASK );
        return intent;
    }

    public static Intent mkDownloadActivity( Context context )
    {
        return mkDownloadActivity( context, null, 0 );
    }

    public static void setChecked( Activity activity, int id, boolean value )
    {
        CheckBox cbx = (CheckBox)activity.findViewById( id );
        cbx.setChecked( value );
    }

    public static void setChecked( Dialog dialog, int id, boolean value )
    {
        CheckBox cbx = (CheckBox)dialog.findViewById( id );
        cbx.setChecked( value );
    }

    public static void setText( Dialog dialog, int id, String value )
    {
        EditText editText = (EditText)dialog.findViewById( id );
        if ( null != editText ) {
            editText.setText( value, TextView.BufferType.EDITABLE   );
        }
    }

    public static void setText( Activity activity, int id, String value )
    {
        EditText editText = (EditText)activity.findViewById( id );
        if ( null != editText ) {
            editText.setText( value, TextView.BufferType.EDITABLE   );
        }
    }

    public static void setInt( Dialog dialog, int id, int value )
    {
        String str = Integer.toString(value);
        setText( dialog, id, str );
    }

    public static void setInt( Activity activity, int id, int value )
    {
        String str = Integer.toString(value);
        setText( activity, id, str );
    }

    public static boolean getChecked( Activity activity, int id )
    {
        CheckBox cbx = (CheckBox)activity.findViewById( id );
        return cbx.isChecked();
    }

    public static boolean getChecked( Dialog dialog, int id )
    {
        CheckBox cbx = (CheckBox)dialog.findViewById( id );
        return cbx.isChecked();
    }

    public static String getText( Dialog dialog, int id )
    {
        EditText editText = (EditText)dialog.findViewById( id );
        return editText.getText().toString();
    }

    public static String getText( Activity activity, int id )
    {
        EditText editText = (EditText)activity.findViewById( id );
        return editText.getText().toString();
    }

    public static int getInt( Dialog dialog, int id )
    {
        String str = getText( dialog, id );
        try {
            return Integer.parseInt( str );
        } catch ( NumberFormatException nfe ) {
            return 0;
        }
    }

    public static int getInt( Activity activity, int id )
    {
        String str = getText( activity, id );
        try {
            return Integer.parseInt( str );
        } catch ( NumberFormatException nfe ) {
            return 0;
        }
    }
}
",True,17,44,3,19,4,9,27,3,L0
9,org.eehouse.android.xw4.DictListPreference.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.preference.ListPreference;
import android.content.Context;
import android.util.AttributeSet;

import junit.framework.Assert;

public class DictListPreference extends ListPreference {

    public DictListPreference( Context context, AttributeSet attrs )
    {
        super( context, attrs );

        String[] dicts = GameUtils.dictList( context  );
        String[] dictEntries = new String[dicts.length];
        for ( int ii = 0; ii < dicts.length; ++ii ) {
            dictEntries[ii] = 
                DictLangCache.annotatedDictName( context, dicts[ii] );
        }
        setEntries( dictEntries );
        setEntryValues( dicts );
    }
}
",False,22,21,0,0,4,11,0,2,L3
10,org.eehouse.android.xw4.XWListActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.ListActivity;
import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;

import org.eehouse.android.xw4.jni.CommonPrefs;

public class XWListActivity extends ListActivity {
    private DlgDelegate m_delegate;

    @Override
    protected void onCreate( Bundle savedInstanceState ) 
    {
        super.onCreate( savedInstanceState );
        m_delegate = new DlgDelegate( this );
    }

    @Override
    protected void onStart()
    {
        Utils.logf( ""XWListActivity::onStart"" );
        super.onStart();
        DispatchNotify.SetRunning( this );
    }

    @Override
    protected void onStop()
    {
        Utils.logf( ""XWListActivity::onStop"" );
        super.onStop();
        DispatchNotify.ClearRunning( this );
    }

    @Override
    protected Dialog onCreateDialog( int id )
    {
        Dialog dialog = m_delegate.onCreateDialog( id );
        if ( null == dialog ) {
            dialog = super.onCreateDialog( id );
        }
        return dialog;
    }

    @Override
    protected void onPrepareDialog( int id, Dialog dialog )
    {
        m_delegate.onPrepareDialog( id, dialog );
    }

    // It sucks that these must be duplicated here and XWActivity
    protected void showAboutDialog()
    {
        m_delegate.showAboutDialog();
    }

    protected void showNotAgainDlgThen( int msgID, int prefsKey,
                                        Runnable proc )
    {
        m_delegate.showNotAgainDlgThen( msgID, prefsKey, proc );
    }

    protected void showNotAgainDlg( int msgID, int prefsKey )
    {
        m_delegate.showNotAgainDlgThen( msgID, prefsKey, null );
    }

    protected void showOKOnlyDialog( int msgID )
    {
        m_delegate.showOKOnlyDialog( msgID );
    }

    protected void showConfirmThen( String msg,
                                    DialogInterface.OnClickListener action )
    {
        m_delegate.showConfirmThen( msg, action );
    }

    protected void showConfirmThen( int msgID, 
                                    DialogInterface.OnClickListener action )
    {
        showConfirmThen( getString(msgID), action );
    }

}
",False,15,26,1,2,5,8,2,4,L2
11,org.eehouse.android.xw4.XWListAdapter.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.ListActivity;
import android.widget.ListAdapter;
import android.content.Context;
import android.database.DataSetObserver;

/**
 * Let's see if we can implement a few of these methods just once.
 */
public abstract class XWListAdapter implements ListAdapter {
    private int m_count;

    public XWListAdapter( Context context, int count ) {
        m_count = count;
    }

    public boolean areAllItemsEnabled() { return true; }
    public boolean isEnabled( int position ) { return true; }
    public int getCount() { return m_count; }
    public long getItemId(int position) { return position; }
    public int getItemViewType(int position) { return 0; }
    public int getViewTypeCount() { return 1; }
    public boolean hasStableIds() { return true; }
    public boolean isEmpty() { return getCount() == 0; }
    public void registerDataSetObserver(DataSetObserver observer) {}
    public void unregisterDataSetObserver(DataSetObserver observer) {}
}",False,7,5,2,3,0,0,3,0,L0
12,org.eehouse.android.xw4.NetUtils.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import javax.net.SocketFactory;
import java.net.InetAddress;
import java.net.Socket;
import android.content.Context;

import java.io.InputStream;
import java.io.DataInputStream;
import java.io.OutputStream;
import java.io.DataOutputStream;
import java.util.ArrayList;

import org.eehouse.android.xw4.jni.CommonPrefs;

public class NetUtils {

    public static final byte PROTOCOL_VERSION = 0;
    // from xwrelay.h
    public static byte PRX_PUB_ROOMS = 1;
    public static byte PRX_HAS_MSGS = 2;
    public static byte PRX_DEVICE_GONE = 3;

    public static Socket MakeProxySocket( Context context, 
                                          int timeoutMillis )
    {
        Socket socket = null;
        try {
            int port = CommonPrefs.getDefaultProxyPort( context );
            String host = CommonPrefs.getDefaultRelayHost( context );

            SocketFactory factory = SocketFactory.getDefault();
            InetAddress addr = InetAddress.getByName( host );
            socket = factory.createSocket( addr, port );
            socket.setSoTimeout( timeoutMillis );

        } catch ( java.net.UnknownHostException uhe ) {
            Utils.logf( uhe.toString() );
        } catch( java.io.IOException ioe ) {
            Utils.logf( ioe.toString() );
        }
        Utils.logf( ""MakeProxySocket=>%s"", null != socket
                    ? socket.toString():""null"" );
        return socket;
    }

    private static class InformThread extends Thread {
        Context m_context;
        private Socket m_socket;
        DBUtils.Obit[] m_obits;
        public InformThread( Context context, DBUtils.Obit[] obits, 
                             Socket socket )
        {
            m_context = context;
            m_obits = obits;
            m_socket = socket;
        }

        public void run() {

            int strLens = 0;
            for ( int ii = 0; ii < m_obits.length; ++ii ) {
                strLens += m_obits[ii].m_relayID.length() + 1; // 1 for /n
            }

            try {
                DataOutputStream outStream = 
                    new DataOutputStream( m_socket.getOutputStream() );
                outStream.writeShort( 2 + 2 + (2*m_obits.length) + strLens );
                outStream.writeByte( NetUtils.PROTOCOL_VERSION );
                outStream.writeByte( NetUtils.PRX_DEVICE_GONE );
                outStream.writeShort( m_obits.length );

                for ( int ii = 0; ii < m_obits.length; ++ii ) {
                    outStream.writeShort( m_obits[ii].m_seed );
                    outStream.writeBytes( m_obits[ii].m_relayID );
                    outStream.write( '\n' );
                }

                outStream.flush();

                DataInputStream dis = 
                    new DataInputStream( m_socket.getInputStream() );
                short resLen = dis.readShort();
                m_socket.close();

                if ( resLen == 0 ) {
                    DBUtils.clearObits( m_context, m_obits );
                }
            } catch ( java.io.IOException ioe ) {
                Utils.logf( ioe.toString() );
            }

        }
    }

    public static void informOfDeaths( Context context )
    {
        DBUtils.Obit[] obits = DBUtils.listObits( context );
        if ( null != obits && 0 < obits.length ) {
            Socket socket = MakeProxySocket( context, 10000 );
            if ( null != socket ) {
                InformThread thread = new InformThread( context, obits, socket );
                thread.start();
            }
        }
    }

    public static String[] QueryRelay( Context context )
    {
        String[] result = null;
        int[] nBytes = new int[1];
        String[] ids = collectIDs( context, nBytes );
        if ( null != ids && 0 < ids.length ) {
            try {
                Socket socket = MakeProxySocket( context, 8000 );
                DataOutputStream outStream = 
                    new DataOutputStream( socket.getOutputStream() );

                // total packet size
                outStream.writeShort( 2 + nBytes[0] + ids.length + 1 );
                Utils.logf( ""total packet size: %d"",
                            2 + nBytes[0] + ids.length );

                outStream.writeByte( NetUtils.PROTOCOL_VERSION );
                outStream.writeByte( NetUtils.PRX_HAS_MSGS );

                // number of ids
                outStream.writeShort( ids.length );
                Utils.logf( ""wrote count %d to proxy socket"",
                            ids.length );

                for ( String id : ids ) {
                    outStream.writeBytes( id );
                    outStream.write( '\n' );
                }
                outStream.flush();

                DataInputStream dis = 
                    new DataInputStream(socket.getInputStream());
                Utils.logf( ""reading from proxy socket"" );
                short resLen = dis.readShort();
                short nameCount = dis.readShort();
                short[] msgCounts = null;
                if ( nameCount == ids.length ) {
                    msgCounts = new short[nameCount];
                    for ( int ii = 0; ii < nameCount; ++ii ) {
                        msgCounts[ii] = dis.readShort();
                        Utils.logf( ""msgCounts[%d]=%d"", ii, 
                                    msgCounts[ii] );
                    }
                }
                socket.close();
                Utils.logf( ""closed proxy socket"" );

                if ( null == msgCounts ) {
                    Utils.logf( ""relay has no messages"" );
                } else {
                    ArrayList<String> idsWMsgs =
                        new ArrayList<String>( nameCount );
                    for ( int ii = 0; ii < nameCount; ++ii ) {
                        if ( msgCounts[ii] > 0 ) {
                            String msg = 
                                String.format(""%d messages for %s"",
                                              msgCounts[ii], 
                                              ids[ii] );
                            Utils.logf( msg );
                            DBUtils.setHasMsgs( ids[ii] );
                            idsWMsgs.add( ids[ii] );
                        }
                    }
                    if ( 0 < idsWMsgs.size() ) {
                        ids = new String[idsWMsgs.size()];
                        result = idsWMsgs.toArray( ids );
                    }
                }

            } catch( java.net.UnknownHostException uhe ) {
                Utils.logf( uhe.toString() );
            } catch( java.io.IOException ioe ) {
                Utils.logf( ioe.toString() );
            } catch( NullPointerException npe ) {
                Utils.logf( npe.toString() );
            }
        }
        return result;
    }

    private static String[] collectIDs( Context context, int[] nBytes )
    {
        String[] ids = DBUtils.getRelayIDNoMsgs( context );
        int len = 0;
        if ( null != ids ) {
            for ( String id : ids ) {
                Utils.logf( ""got relayID: %s"", id );
                len += id.length();
            }
        }
        nBytes[0] = len;
        return ids;
    }
}
",True,37,26,2,4,5,7,5,3,L0
13,org.eehouse.android.xw4.DictsActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.ListActivity;
import android.os.Bundle;
import android.widget.Button;
import android.widget.TextView;
import android.widget.AdapterView;
import android.content.Context;
import android.content.DialogInterface;
import android.view.View;
import android.view.ViewGroup;
import android.view.ContextMenu;
import android.view.MenuItem;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.LayoutInflater;
import android.view.MenuInflater;
import android.preference.PreferenceManager;
import android.content.SharedPreferences;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.XwJNI;
import org.eehouse.android.xw4.jni.JNIUtilsImpl;

public class DictsActivity extends XWListActivity 
    implements View.OnClickListener,
               XWListItem.DeleteCallback {
    String[] m_dicts;

    private class DictListAdapter extends XWListAdapter {
        private Context m_context;

        public DictListAdapter( Context context ) {
            super( context, m_dicts.length );
            m_context = context;
        }

        public Object getItem( int position) { return m_dicts[position]; }
        public View getView( final int position, View convertView, 
                             ViewGroup parent ) {
            LayoutInflater factory = LayoutInflater.from( DictsActivity.this );
            final XWListItem view
                = (XWListItem)factory.inflate( R.layout.list_item, null );
            view.setPosition( position );

            // append language name
            view.setText( DictLangCache.
                          annotatedDictName( DictsActivity.this, 
                                             m_dicts[position] ) );
            if ( !GameUtils.dictIsBuiltin( DictsActivity.this,
                                           m_dicts[position] ) ) {
                view.setDeleteCallback( DictsActivity.this );
            }

            return view;
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate( savedInstanceState );

        setContentView( R.layout.dict_browse );
        registerForContextMenu( getListView() );

        Button download = (Button)findViewById( R.id.download );
        download.setOnClickListener( this );

        mkListAdapter();

        showNotAgainDlg( R.string.not_again_dicts, 
                         R.string.key_notagain_dicts );
    }

    @Override
    protected void onResume()
    {
        super.onResume();
        mkListAdapter();
    }

    public void onClick( View v ) {
        startActivity( Utils.mkDownloadActivity( this ) );
    }

    @Override
    public void onCreateContextMenu( ContextMenu menu, View view, 
                                     ContextMenuInfo menuInfo ) 
    {
        super.onCreateContextMenu( menu, view, menuInfo );

        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.dicts_item_menu, menu );

        AdapterView.AdapterContextMenuInfo info
            = (AdapterView.AdapterContextMenuInfo)menuInfo;
    }
   
    @Override
    public boolean onContextItemSelected( MenuItem item ) 
    {
        boolean handled = false;
        AdapterView.AdapterContextMenuInfo info;
        try {
            info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
        } catch (ClassCastException e) {
            Utils.logf( ""bad menuInfo:"" + e.toString() );
            return false;
        }
        
        int id = item.getItemId();
        switch( id ) {
        case R.id.dicts_item_select:
            SharedPreferences sp
                = PreferenceManager.getDefaultSharedPreferences( this );
            SharedPreferences.Editor editor = sp.edit();
            String key = getString( R.string.key_default_dict );
            editor.putString( key, m_dicts[info.position] );
            editor.commit();
            break;
        case R.id.dicts_item_details:
            Utils.notImpl( this );
            break;
        }

        return handled;
    }

    // DeleteCallback interface
    public void deleteCalled( final int myPosition )
    {
        final String dict = m_dicts[myPosition];
        int nGames = DBUtils.countGamesUsing( this, dict );
        if ( nGames == 0 ) {
            deleteDict( dict );
        } else {
            DialogInterface.OnClickListener action = 
                new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        deleteDict( dict );
                    }
                };
            String fmt = getString( R.string.confirm_delete_dictf );
            String msg = String.format( fmt, dict, nGames );
            showConfirmThen( msg, action );
        }
    }

    private void deleteDict( String dict )
    {
        GameUtils.deleteDict( this, dict );
        mkListAdapter();
    }

    private void mkListAdapter()
    {
        m_dicts = GameUtils.dictList( this );
        setListAdapter( new DictListAdapter( this ) );
    }

}",False,44,27,0,0,3,14,0,9,L3
14,org.eehouse.android.xw4.ReceiveNBS.java,"/* -*- compile-command: ""cd ../../../../../; ant reinstall""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.telephony.SmsMessage;

public class ReceiveNBS extends BroadcastReceiver {

    @Override
    public void onReceive( Context context, Intent intent ) 
    {
        Utils.logf( ""onReceive called: "" + intent.toString() );

        Bundle bundle = intent.getExtras();        
        SmsMessage[] smsarr = null;
        if (bundle != null) {
            Object[] pdus = (Object[]) bundle.get(""pdus"");
            smsarr = new SmsMessage[pdus.length];            
            for ( int ii = 0; ii < pdus.length; ii++){
                smsarr[ii] = SmsMessage.createFromPdu((byte[])pdus[ii]);
                Utils.logf( ""from "" + smsarr[ii].getOriginatingAddress() );
                // buf.append( smsarr[ii].getMessageBody() );
                // XwJni.handle( XwJni.JNICmd.CMD_RECEIVE, 
                //               smsarr[ii].getMessageBody() );
            }
        }
    } // onReceive

}
",False,39,21,0,0,5,9,0,1,L3
15,org.eehouse.android.xw4.GameListAdapter.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.eehouse.android.xw4;

import android.widget.ListAdapter;
import android.content.Context;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import android.database.DataSetObserver;
import java.io.FileInputStream;
import java.util.HashMap;
import android.view.LayoutInflater;
import junit.framework.Assert;


import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class GameListAdapter extends XWListAdapter {
    private Context m_context;
    private LayoutInflater m_factory;
    private int m_layoutId;
    private HashMap<String,View> m_viewsCache;

    public GameListAdapter( Context context ) {
        super( context, DBUtils.gamesList(context).length );
        m_context = context;
        m_factory = LayoutInflater.from( context );

        int sdk_int = 0;
        try {
            sdk_int = Integer.decode( android.os.Build.VERSION.SDK );
        } catch ( Exception ex ) {}

        m_layoutId = R.layout.game_list_item;

        m_viewsCache = new HashMap<String,View>();
    }
    
    public int getCount() {
        return DBUtils.gamesList(m_context).length;
    }
    
    public Object getItem( int position ) 
    {
        final String path = DBUtils.gamesList(m_context)[position];
        View layout = m_viewsCache.get( path );

        if ( null == layout ) {
            Utils.logf( ""creating new list elem for %s"", path );
            layout = m_factory.inflate( m_layoutId, null );

            GameSummary summary = DBUtils.getSummary( m_context, path );

            TextView view = (TextView)layout.findViewById( R.id.players );
            String gameName = GameUtils.gameName( m_context, path );
            view.setText( String.format( ""%s: %s"", gameName,
                                         summary.players ) );

            view = (TextView)layout.findViewById( R.id.state );
            view.setText( summary.summarizeState( m_context ) );
            view = (TextView)layout.findViewById( R.id.dict );
            view.setText( summary.dictName );

            view = (TextView)layout.findViewById( R.id.role );
            String roleSummary = summary.summarizeRole( m_context );
            if ( null != roleSummary ) {
                view.setText( roleSummary );
            } else {
                view.setVisibility( View.GONE );
            }

            View marker = layout.findViewById( R.id.msg_marker );
            marker.setVisibility( summary.msgsPending? 
                                  View.VISIBLE : View.GONE );
            m_viewsCache.put( path, layout );
        }
        return layout;
    } // getItem

    public View getView( int position, View convertView, ViewGroup parent ) {
        return (View)getItem( position );
    }

    public void inval( String key ) 
    {
        m_viewsCache.remove( key );
    }
}",True,8,23,1,1,4,9,1,6,L3
16,org.eehouse.android.xw4.XWListItem.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.widget.LinearLayout;
import android.view.View;
import android.widget.TextView;
import android.widget.ImageButton;
import android.content.Context;
import android.util.AttributeSet;
import android.graphics.Rect;

public class XWListItem extends LinearLayout {
    private int m_position;
    private Context m_context;
    DeleteCallback m_cb;

    public interface DeleteCallback {
        void deleteCalled( int myPosition );
    }

    public XWListItem( Context cx, AttributeSet as ) {
        super( cx, as );
        m_context = cx;
    }

    public int getPosition() { return m_position; }
    public void setPosition( int indx ) { m_position = indx; }

    public void setText( String text )
    {
        TextView view = (TextView)getChildAt( 0 );
        view.setText( text );
    }

    public void setDeleteCallback( DeleteCallback cb ) 
    {
        m_cb = cb;
        ImageButton button = (ImageButton)getChildAt( 1 );
        button.setOnClickListener( new View.OnClickListener() {
                @Override
                    public void onClick( View view ) {
                    m_cb.deleteCalled( m_position );
                }
            } );
        button.setVisibility( View.VISIBLE );
    }

    @Override
    public void setEnabled( boolean enabled ) 
    {
        ImageButton button = (ImageButton)getChildAt( 1 );
        button.setEnabled( enabled );
        // calling super here means the list item can't be opened for
        // the user to inspect data.  Might want to reconsider this.
        // PENDING
        super.setEnabled( enabled );
    }
}
",False,34,3,1,2,0,0,2,0,L0
17,org.eehouse.android.xw4.XWConstants.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

public interface XWConstants {
    public static final String GAME_EXTN = "".xwg"";
    public static final String DICT_EXTN = "".xwd"";
    public static final String VERSION_STR = ""4.4 beta 20"";
}
",False,16,40,3,27,0,0,5,0,L0
18,org.eehouse.android.xw4.RelayGameActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

// This activity is for newbies.  Bring it up when network game
// created.  It explains they need only a room name -- that everything
// else is derived from defaults and configurable via the main config
// dialog (which offer to launch)

package org.eehouse.android.xw4;

import android.app.Activity;
import java.io.File;
import android.os.Bundle;
import android.net.Uri;
import android.widget.Button;
import android.widget.TextView;
import android.view.View;
import android.content.Intent;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;

public class RelayGameActivity extends XWActivity 
    implements View.OnClickListener {

    private String m_path;
    private CurGameInfo m_gi;
    private CommsAddrRec m_car;
    private Button m_playButton;
    private Button m_configButton;

    @Override
    public void onCreate( Bundle savedInstanceState ) 
    {
        super.onCreate( savedInstanceState );

        setContentView( R.layout.relay_game_config );

        Uri uri = getIntent().getData();
        m_path = uri.getPath();
        if ( m_path.charAt(0) == '/' ) {
            m_path = m_path.substring( 1 );
        }

        int gamePtr = XwJNI.initJNI();
        m_gi = new CurGameInfo( this );
        GameUtils.loadMakeGame( this, gamePtr, m_gi, m_path );
        m_car = new CommsAddrRec( this );
        if ( XwJNI.game_hasComms( gamePtr ) ) {
            XwJNI.comms_getAddr( gamePtr, m_car );
        } else {
            Assert.fail();
            // String relayName = CommonPrefs.getDefaultRelayHost( this );
            // int relayPort = CommonPrefs.getDefaultRelayPort( this );
            // XwJNI.comms_getInitialAddr( m_carOrig, relayName, relayPort );
        }
        XwJNI.game_dispose( gamePtr );

        String lang = DictLangCache.getLangName( this, m_gi.dictName );
        String fmt = getString( R.string.relay_game_explainf );
        TextView text = (TextView)findViewById( R.id.explain );
        text.setText( String.format( fmt, lang ) );

        m_playButton = (Button)findViewById( R.id.play_button );
        m_playButton.setOnClickListener( this );

        m_configButton = (Button)findViewById( R.id.config_button );
        m_configButton.setOnClickListener( this );
    } // onCreate

    @Override
    public void onClick( View view ) 
    {
        String room = Utils.getText( this, R.id.room_edit ).trim();
        if ( view == m_playButton ) {
            if ( room.length() == 0 ) {
                showOKOnlyDialog( R.string.no_empty_rooms );
            } else {
                saveRoomAndName( room );
                GameUtils.launchGame( this, m_path );
            }
        } else if ( view == m_configButton ) {
            saveRoomAndName( room );
            GameUtils.doConfig( this, m_path, GameConfig.class );
            finish();
        }
    }

    public static boolean isSimpleGame( GameSummary summary )
    {
        return summary.nPlayers == 2;
    }

    private void saveRoomAndName( String room )
    {
        String name = Utils.getText( this, R.id.local_name_edit );
        if ( name.length() > 0 ) { // don't wipe existing
            m_gi.setFirstLocalName( name );
        }
        m_car.ip_relay_invite = room;
        GameUtils.applyChanges( this, m_gi, m_car, m_path, false );
    }

} // class RelayGameActivity
",True,36,26,1,1,4,11,1,5,L3
19,org.eehouse.android.xw4.DispatchNotify.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.content.Intent;
import android.content.Context;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.widget.Toast;
import android.os.Bundle;
import java.util.HashSet;

import org.eehouse.android.xw4.jni.CommonPrefs;

public class DispatchNotify extends Activity {

    public interface HandleRelaysIface {
        void HandleRelaysIDs( final String[] relayIDs );
    }

    private static HashSet<Activity> s_running = new HashSet<Activity>();
    private static HandleRelaysIface s_handler;

    @Override
    protected void onCreate( Bundle savedInstanceState ) 
    {
        Utils.logf( ""DispatchNotify.onCreate()"" );
        super.onCreate( savedInstanceState );

        Intent intent = getIntent();
        String[] relayIDs = 
            intent.getStringArrayExtra( getString(R.string.relayids_extra) );

        if ( null != s_handler ) {
            Utils.logf( ""calling s_handler"" );
            s_handler.HandleRelaysIDs( relayIDs );
        } else if ( s_running.isEmpty() ) {
            Utils.logf( ""DispatchNotify: nothing running"" );
            startActivity( new Intent( this, GamesList.class ) );
        } else {
            Utils.logf( ""DispatchNotify: something running"" );

            String ids = ""new moves available; need to inval"";
            for ( String id : relayIDs ) {
                ids += "" "" + id ;
            }

            // Toast.makeText( this, ids, Toast.LENGTH_SHORT).show();

            // for ( Activity activity : s_running ) {
            //     if ( activity instanceof DispatchNotify.HandleRelaysIface ) {
            //         DispatchNotify.HandleRelaysIface iface =
            //             (DispatchNotify.HandleRelaysIface)activity;
            //         iface.HandleRelaysIDs( relayIDs );
            //     }
            // }
        }

        finish();
    }

    @Override
    protected void onNewIntent( Intent intent )
    {
        Utils.logf( ""DispatchNotify.onNewIntent() called"" );
    }

    public static void SetRunning( Activity running )
    {
        s_running.add( running );
    }

    public static void ClearRunning( Activity running )
    {
        s_running.remove( running );
    }

    public static void SetRelayIDsHandler( HandleRelaysIface iface )
    {
        s_handler = iface;
    }
}
",False,4,34,4,6,5,8,3,2,L1
20,org.eehouse.android.xw4.DictLangCache.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.content.res.Resources;
import java.util.ArrayList;
import java.util.HashMap;

import org.eehouse.android.xw4.jni.JNIUtilsImpl;
import org.eehouse.android.xw4.jni.XwJNI;
import org.eehouse.android.xw4.jni.DictInfo;

public class DictLangCache {
    private static final HashMap<String,DictInfo> s_nameToLang = 
        new HashMap<String,DictInfo>();
    private static String[] s_langNames;

    public static String annotatedDictName( Context context, String name )
    {
        DictInfo info = getInfo( context, name );
        int wordCount = info.wordCount;
            
        String langName = getLangName( context, name );
        String result;
        if ( 0 == wordCount ) {
            result = String.format( ""%s (%s)"", name, langName );
        } else {
            result = String.format( ""%s (%s/%d)"", name, langName, wordCount );
        }

        return result;
    }

    public static String annotatedDictName( Context context, String name,
                                            int lang )
    {
        return name + "" ("" + getLangName( context, lang ) + "")"";
    }

    public static String getLangName( Context context, int code )
    {
        String[] namesArray = getNamesArray( context );
        if ( code < 0 || code >= namesArray.length ) {
            code = 0;
        }
        return namesArray[code];
    }

    // This populates the cache and will take significant time if it's
    // mostly empty and there are a lot of dicts.
    public static int getLangCount( Context context, int code )
    {
        int count = 0;
        String[] dicts = GameUtils.dictList( context );
        for ( String dict : dicts ) {
            if ( code == getLangCode( context, dict ) ) {
                ++count;
            }
        }
        return count;
    }

    private static String[] getHaveLang( Context context, int code,
                                         boolean withCounts )
    {
        ArrayList<String> al = new ArrayList<String>();
        String[] dicts = GameUtils.dictList( context );
        String fmt = ""%s (%d)""; // must match stripCount below
        for ( String dict : dicts ) {
            DictInfo info = getInfo( context, dict );
            if ( code == info.langCode ) {
                if ( withCounts ) {
                    dict = String.format( fmt, dict, info.wordCount );
                }
                al.add( dict );
            }
        }
        return al.toArray( new String[al.size()] );
    }

    public static String[] getHaveLang( Context context, int code )
    {
        return getHaveLang( context, code, false );
    }

    public static String[] getHaveLangCounts( Context context, int code )
    {
        return getHaveLang( context, code, true );
    }

    public static String stripCount( String nameWithCount )
    {
        int indx = nameWithCount.lastIndexOf( "" ("" );
        return nameWithCount.substring( 0, indx );
    }

    public static int getLangCode( Context context, String name )
    {
        return getInfo( context, name ).langCode;
    }

    public static String getLangName( Context context, String name )
    {
        int code = getLangCode( context, name );
        return getLangName( context, code );
    }

    public static void inval( String name )
    {
        s_nameToLang.remove( name );
    }

    private static String[] getNamesArray( Context context )
    {
        if ( null == s_langNames ) {
            Resources res = context.getResources();
            s_langNames = res.getStringArray( R.array.language_names );
        }
        return s_langNames;
    }

    private static DictInfo getInfo( Context context, String name )
    {
        DictInfo info;
        if ( s_nameToLang.containsKey( name ) ) {
            info = s_nameToLang.get( name );
        } else {
            byte[] dict = GameUtils.openDict( context, name );
            info = new DictInfo();
            XwJNI.dict_getInfo( dict, JNIUtilsImpl.get(), info );
            s_nameToLang.put( name, info );
        }
        return info;
    }

}",True,32,26,1,6,3,12,8,4,L0
21,org.eehouse.android.xw4.BoardActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MenuInflater;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Window;
import android.os.Handler;
import android.os.Message;
import android.content.Intent;
import java.util.concurrent.Semaphore;
import android.net.Uri;
import android.app.Dialog;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.widget.ImageButton;
import android.widget.Toast;
import android.widget.EditText;
import android.widget.TextView;
import junit.framework.Assert;
import android.content.res.Configuration;
import android.content.pm.ActivityInfo;

import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.JNIThread.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;


public class BoardActivity extends XWActivity implements UtilCtxt {

    private static final int DLG_OKONLY = DlgDelegate.DIALOG_LAST + 1;
    private static final int DLG_BADWORDS = DLG_OKONLY + 1;
    private static final int QUERY_REQUEST_BLK = DLG_OKONLY + 2;
    private static final int QUERY_INFORM_BLK = DLG_OKONLY + 3;
    private static final int PICK_TILE_REQUEST_BLK = DLG_OKONLY + 4;
    private static final int GOT_MESSAGE_BLK = DLG_OKONLY + 5;
    private static final int ASK_PASSWORD_BLK = DLG_OKONLY + 6;
    private static final int DLG_RETRY = DLG_OKONLY + 7;
    private static final int GET_MESSAGE = DLG_OKONLY + 8;
    private static final int QUERY_ENDGAME = DLG_OKONLY + 9;

    private BoardView m_view;
    private int m_jniGamePtr;
    private CurGameInfo m_gi;
    CommsTransport m_xport;
    private Handler m_handler;
    private TimerRunnable[] m_timers;
    private String m_path;
    private int m_currentOrient;
    private Toolbar m_toolbar;

    private String m_dlgBytes = null;
    private EditText m_passwdEdit = null;
    private EditText m_chatMsg = null;
    private int m_dlgTitle;
    private String m_dlgTitleStr;
    private String[] m_texts;
    private boolean m_firingPrefs;
    private JNIUtils m_jniu;
    private boolean m_volKeysZoom;

    // call startActivityForResult synchronously
	private Semaphore m_forResultWait = new Semaphore(0);
    private int m_resultCode;

    private Thread m_blockingThread;
    private JNIThread m_jniThread;

    private ProgressDialog m_progress;
    private boolean m_isVisible;

    public class TimerRunnable implements Runnable {
        private int m_why;
        private int m_when;
        private int m_handle;
        private TimerRunnable( int why, int when, int handle ) {
            m_why = why;
            m_when = when;
            m_handle = handle;
        }
        public void run() {
            m_timers[m_why] = null;
            if ( null != m_jniThread ) {
                m_jniThread.handle( JNICmd.CMD_TIMER_FIRED, false,
                                    m_why, m_when, m_handle );
            }
        }
    } 

    @Override
    protected Dialog onCreateDialog( int id )
    {
        Dialog dialog = super.onCreateDialog( id );
        if ( null == dialog ) {
            DialogInterface.OnClickListener lstnr;
            AlertDialog.Builder ab;

            switch ( id ) {
            case DLG_OKONLY:
            case DLG_BADWORDS:
            case DLG_RETRY:
                ab = new AlertDialog.Builder( BoardActivity.this )
                    //.setIcon( R.drawable.alert_dialog_icon )
                    .setTitle( m_dlgTitle )
                    .setMessage( m_dlgBytes )
                    .setPositiveButton( R.string.button_ok, null );
                if ( DLG_RETRY == id ) {
                    lstnr = new DialogInterface.OnClickListener() {
                            public void onClick( DialogInterface dlg, 
                                                 int whichButton ) {
                                m_jniThread.handle( JNIThread.JNICmd.CMD_RESET );
                            }
                        };
                    ab.setNegativeButton( R.string.button_retry, lstnr );
                }
                dialog = ab.create();
                break;

            case QUERY_REQUEST_BLK:
            case QUERY_INFORM_BLK:
            case GOT_MESSAGE_BLK:
                ab = new AlertDialog.Builder( this )
                    .setTitle( m_dlgTitle )
                    .setMessage( m_dlgBytes );
                lstnr = new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dialog, 
                                             int whichButton ) {
                            m_resultCode = 1;
                        }
                    };
                ab.setPositiveButton( QUERY_REQUEST_BLK == id ?
                                      R.string.button_yes : R.string.button_ok,
                                      lstnr );
                if ( QUERY_REQUEST_BLK == id ) {
                    lstnr = new DialogInterface.OnClickListener() {
                            public void onClick( DialogInterface dialog, 
                                                 int whichButton ) {
                                m_resultCode = 0;
                            }
                        };
                    ab.setNegativeButton( R.string.button_no, lstnr );
                } else if ( GOT_MESSAGE_BLK == id ) {
                    lstnr = new DialogInterface.OnClickListener() {
                            public void onClick( DialogInterface dlg, 
                                                 int whichButton ) {
                                showDialog( GET_MESSAGE );
                            }
                        };
                    ab.setNegativeButton( R.string.button_reply, lstnr );
                }

                dialog = ab.create();
                dialog.setOnDismissListener( makeODLforBlocking() );
                break;

            case PICK_TILE_REQUEST_BLK:
                ab = new AlertDialog.Builder( this )
                    .setTitle( R.string.title_tile_picker );
                lstnr = new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dialog, 
                                             int item ) {
                            m_resultCode = item;
                        }
                    };
                ab.setItems( m_texts, lstnr );

                dialog = ab.create();
                dialog.setOnDismissListener( makeODLforBlocking() );
                break;

            case ASK_PASSWORD_BLK:
                ab = new AlertDialog.Builder( this )
                    .setTitle( m_dlgTitleStr )
                    .setView( m_passwdEdit )
                    .setPositiveButton( R.string.button_ok,
                                        new DialogInterface.OnClickListener() {
                                            public void onClick( DialogInterface dlg,
                                                                 int whichButton ) {
                                                m_resultCode = 1;
                                            }
                                        });
                dialog = ab.create();
                dialog.setOnDismissListener( makeODLforBlocking() );
                break;

            case QUERY_ENDGAME:
                dialog = new AlertDialog.Builder( this )
                    .setTitle( R.string.query_title )
                    .setMessage( R.string.ids_endnow )
                    .setPositiveButton( R.string.button_yes,
                                        new DialogInterface.OnClickListener() {
                                            public void onClick( DialogInterface dlg, 
                                                                 int item ) {
                                                m_jniThread.handle(JNICmd.CMD_ENDGAME);
                                            }
                                        })
                    .setNegativeButton( R.string.button_no,
                                        new DialogInterface.OnClickListener() {
                                            public void onClick( DialogInterface dlg, 
                                                                 int item ) {
                                                // do nothing
                                            }
                                        })
                    .create();
                break;

            case GET_MESSAGE:
                if ( null == m_chatMsg ) {
                    m_chatMsg = new EditText( this );
                }
                lstnr = new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dlg, 
                                             int item ) {
                            String msg = m_chatMsg.getText().toString();
                            if ( msg.length() > 0 ) {
                                m_jniThread.handle( JNICmd.CMD_SENDCHAT, msg );
                            }
                                                                   
                        }
                    };
                dialog = new AlertDialog.Builder( this )
                    .setMessage( R.string.compose_chat )
                    .setPositiveButton(R.string.button_send, lstnr )
                    .setNegativeButton( R.string.button_cancel, null )
                    .setView( m_chatMsg )
                    .create();
                break;

            default:
                Assert.assertTrue( false );
            }
        }
        return dialog;
    } // onCreateDialog

    @Override
    protected void onPrepareDialog( int id, Dialog dialog )
    {
        switch( id ) {
        case DLG_OKONLY:
            dialog.setTitle( m_dlgTitle );
            // FALLTHRU
        case GOT_MESSAGE_BLK:
        case DLG_BADWORDS:
        case QUERY_REQUEST_BLK:
        case QUERY_INFORM_BLK:
            ((AlertDialog)dialog).setMessage( m_dlgBytes );
            break;
        case ASK_PASSWORD_BLK:
            m_passwdEdit.setText( """", TextView.BufferType.EDITABLE );
            dialog.setTitle( m_dlgTitleStr );
            break;
        case GET_MESSAGE:
            m_chatMsg.setText("""");
            break;
        default:
            super.onPrepareDialog( id, dialog );
            break;
        }
    }

    @Override
    protected void onCreate( Bundle savedInstanceState ) 
    {
        Utils.logf( ""BoardActivity::onCreate()"" );
        super.onCreate( savedInstanceState );

        if ( CommonPrefs.getHideTitleBar( this ) ) {
            requestWindowFeature( Window.FEATURE_NO_TITLE );
        }

        m_jniu = JNIUtilsImpl.get();
        setContentView( R.layout.board );
        m_handler = new Handler();
        m_timers = new TimerRunnable[4]; // needs to be in sync with
                                         // XWTimerReason
        m_gi = new CurGameInfo( this );

        m_view = (BoardView)findViewById( R.id.board_view );
        m_volKeysZoom = CommonPrefs.getVolKeysZoom( this );

        Intent intent = getIntent();
        Uri uri = intent.getData();
        m_path = uri.getPath();
        if ( m_path.charAt(0) == '/' ) {
            m_path = m_path.substring( 1 );
        }
    } // onCreate

    @Override
    protected void onStart()
    {
        Utils.logf( ""BoardActivity::onStart"" );
        loadGame();
        super.onStart();
    }

    @Override
    protected void onRestart()
    {
        Utils.logf( ""BoardActivity::onRestart"" );
        super.onRestart();
    }

    @Override
    protected void onPause()
    {
        Utils.logf( ""BoardActivity::onPause()"" );
        if ( null != m_jniThread ) {
            m_jniThread.setInBackground( true );
        }
        m_isVisible = false;
        super.onPause();
    }

    @Override
    protected void onResume()
    {
        Utils.logf( ""BoardActivity::onResume()"" );
        if ( null != m_jniThread ) {
            m_jniThread.setInBackground( false );
        }
        m_isVisible = true;
        super.onResume();
    }

    @Override
    protected void onStop()
    {
        Utils.logf( ""BoardActivity::onStop()"" );
        super.onStop();
    }

    @Override
    protected void onDestroy()
    {
        Utils.logf( ""BoardActivity::onDestroy()"" );
        if ( 0 != m_jniGamePtr ) {
            if ( null != m_xport ) {
                m_xport.waitToStop();
                m_xport = null;
            }

            interruptBlockingThread();

            if ( null != m_jniThread ) {
                // one last command
                m_jniThread.handle( JNIThread.JNICmd.CMD_SAVE );
                m_jniThread.waitToStop();
                m_jniThread = null;
            }

            XwJNI.game_dispose( m_jniGamePtr );
            m_jniGamePtr = 0;
        }
        super.onDestroy();
    }

    @Override
    public void onWindowFocusChanged( boolean hasFocus )
    {
        super.onWindowFocusChanged( hasFocus );
        if ( hasFocus ) {
            if ( m_firingPrefs ) {
                m_firingPrefs = false;
                m_volKeysZoom = CommonPrefs.getVolKeysZoom( this );
                if ( null != m_jniThread ) {
                    m_jniThread.handle( JNIThread.JNICmd.CMD_PREFS_CHANGE );
                }
            }
        }
    }

    @Override
    public void onConfigurationChanged( Configuration newConfig )
    {
        m_currentOrient = newConfig.orientation;
        if ( null != m_toolbar ) {
            boolean landscape = 
                m_currentOrient == Configuration.ORIENTATION_LANDSCAPE;
            m_toolbar.orientChanged( landscape );
        }
        super.onConfigurationChanged( newConfig );
    }

    @Override
    public boolean onKeyDown( int keyCode, KeyEvent event )
    {
        boolean handled = false;
        if ( null != m_jniThread ) {
            XwJNI.XP_Key xpKey = keyCodeToXPKey( keyCode );
            if ( XwJNI.XP_Key.XP_KEY_NONE != xpKey ) {
                m_jniThread.handle( JNIThread.JNICmd.CMD_KEYDOWN, xpKey );
            } else {
                switch( keyCode ) {
                case KeyEvent.KEYCODE_VOLUME_DOWN:
                case KeyEvent.KEYCODE_VOLUME_UP:
                    if ( m_volKeysZoom ) {
                        int zoomBy = KeyEvent.KEYCODE_VOLUME_DOWN == keyCode
                            ? -2 : 2;
                        handled = doZoom( zoomBy );
                    }
                    break;
                }
            }
        }
        return handled || super.onKeyDown( keyCode, event );
    }

    @Override
    public boolean onKeyUp( int keyCode, KeyEvent event )
    {
        if ( null != m_jniThread ) {
            XwJNI.XP_Key xpKey = keyCodeToXPKey( keyCode );
            if ( XwJNI.XP_Key.XP_KEY_NONE != xpKey ) {
                m_jniThread.handle( JNIThread.JNICmd.CMD_KEYUP, xpKey );
            }
        }
        return super.onKeyUp( keyCode, event );
    }

    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate( R.menu.board_menu, menu );
        return true;
    }

    public boolean onOptionsItemSelected( MenuItem item ) 
    {
        boolean handled = true;
        JNIThread.JNICmd cmd = JNIThread.JNICmd.CMD_NONE;
        Runnable proc = null;

        int id = item.getItemId();
        switch ( id ) {
        case R.id.board_menu_done:
            proc = new Runnable() {
                    public void run() {
                        m_jniThread.handle( JNIThread.JNICmd.CMD_COMMIT );
                    }
                };
            showNotAgainDlgThen( R.string.not_again_done, 
                                 R.string.key_notagain_done, proc );
            break;
        // case R.id.board_menu_juggle:
        //     cmd = JNIThread.JNICmd.CMD_JUGGLE;
        //     break;
        // case R.id.board_menu_flip:
        //     cmd = JNIThread.JNICmd.CMD_FLIP;
        //     break;
        case R.id.board_menu_trade:
            cmd = JNIThread.JNICmd.CMD_TRADE;
            break;
        case R.id.board_menu_tray:
            cmd = JNIThread.JNICmd.CMD_TOGGLE_TRAY;
            break;
        // case R.id.board_menu_undo_current:
        //     cmd = JNIThread.JNICmd.CMD_UNDO_CUR;
        //     break;
        case R.id.board_menu_undo_last:
            cmd = JNIThread.JNICmd.CMD_UNDO_LAST;
            break;
        case R.id.board_menu_hint:
            cmd = JNIThread.JNICmd.CMD_HINT;
            break;
        case R.id.board_menu_hint_next:
            cmd = JNIThread.JNICmd.CMD_NEXT_HINT;
            break;
        case R.id.board_menu_values:
            cmd = JNIThread.JNICmd.CMD_VALUES;
            break;

        case R.id.board_menu_game_counts:
            m_jniThread.handle( JNIThread.JNICmd.CMD_COUNTS_VALUES,
                                R.string.counts_values_title );
            break;
        case R.id.board_menu_game_left:
            m_jniThread.handle( JNIThread.JNICmd.CMD_REMAINING,
                                R.string.tiles_left_title );
            break;
        case R.id.board_menu_game_history:
            m_jniThread.handle( JNIThread.JNICmd.CMD_HISTORY,
                                R.string.history_title );
            break;

        case R.id.board_menu_game_final:
            m_jniThread.handle( JNIThread.JNICmd.CMD_FINAL,
                                R.string.history_title );
            break;

        case R.id.board_menu_game_resend:
            m_jniThread.handle( JNIThread.JNICmd.CMD_RESEND );
            break;

        case R.id.board_menu_file_prefs:
            m_firingPrefs = true;
            startActivity( new Intent( this, PrefsActivity.class ) );
            break;

        case R.id.board_menu_file_about:
            showAboutDialog();
            break;

        default:
            Utils.logf( ""menuitem "" + item.getItemId() + "" not handled"" );
            handled = false;
        }

        if ( handled && cmd != JNIThread.JNICmd.CMD_NONE ) {
            m_jniThread.handle( cmd );
        }
        return handled;
    }

    private XwJNI.XP_Key keyCodeToXPKey( int keyCode )
    {
        XwJNI.XP_Key xpKey = XwJNI.XP_Key.XP_KEY_NONE;
        switch( keyCode ) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            xpKey = XwJNI.XP_Key.XP_RETURN_KEY;
            break;
        case KeyEvent.KEYCODE_DPAD_DOWN:
            xpKey = XwJNI.XP_Key.XP_CURSOR_KEY_DOWN;
            break;
        case KeyEvent.KEYCODE_DPAD_LEFT:
            xpKey = XwJNI.XP_Key.XP_CURSOR_KEY_LEFT;
            break;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            xpKey = XwJNI.XP_Key.XP_CURSOR_KEY_RIGHT;
            break;
        case KeyEvent.KEYCODE_DPAD_UP:         
            xpKey = XwJNI.XP_Key.XP_CURSOR_KEY_UP;
            break;
        case KeyEvent.KEYCODE_SPACE:         
            xpKey = XwJNI.XP_Key.XP_RAISEFOCUS_KEY;
            break;
        }
        return xpKey;
    }

    // Blocking thread stuff: The problem this is solving occurs when
    // you have a blocking dialog up, meaning the jni thread is
    // blocked, and you hit the home button.  onPause() gets called
    // which wants to use jni calls to e.g. summarize.  For those to
    // succeed (the jni being non-reentrant and set up to assert if it
    // is reentered) the jni thread must first be unblocked and
    // allowed to return back through the jni.  We unblock using
    // Thread.interrupt method, the exception from which winds up
    // caught in waitBlockingDialog.  The catch dismisses the dialog
    // with the default/cancel value, but that takes us into the
    // onDismissListener which normally releases the semaphore.  But
    // if we've interrupted then we can't release it or blocking won't
    // work for as long as this activity lives.  Hence
    // releaseIfBlocking().  This feels really fragile but it does
    // work.
    private void setBlockingThread()
    {
        synchronized( this ) {
            Assert.assertTrue( null == m_blockingThread );
            m_blockingThread = Thread.currentThread();
        }
    }

    private void clearBlockingThread()
    {
        synchronized( this ) {
            Assert.assertTrue( null != m_blockingThread );
            m_blockingThread = null;
        }
    }

    private void interruptBlockingThread()
    {
        synchronized( this ) {
            if ( null != m_blockingThread ) {
                m_blockingThread.interrupt();
            }
        }
    }

    private void releaseIfBlocking()
    {
        synchronized( this ) {
            if ( null != m_blockingThread ) {
                m_forResultWait.release();
            }
        }
    }

    // You have started a game in a new room.  Once the remaining
    // devices have joined your room and you have assigned them tiles
    // (which Crosswords does for you) the game can begin.

    // You have joined a game on the relay.  Once the remaining
    // devices have joined your room the game can begin.

    // You have joined a game on the relay and the room is now full.
    // Next you will receive your initial tiles from the device that
    // created the room and play can begin.

    private void handleConndMessage( Message msg )
    {
        CommsTransport.ConndMsg cndmsg = 
            (CommsTransport.ConndMsg)msg.obj;

        int naMsg = 0;
        int naKey = 0;
        String str = null;
        if ( cndmsg.m_allHere ) {
            // All players have now joined the game.  The device that
            // created the room will assign tiles.  Then it will be
            // the first player's turn
            String fmt = getString( R.string.msg_relay_all_heref );
            str = String.format( fmt, cndmsg.m_room );
            if ( cndmsg.m_devOrder > 1 ) {
                naMsg = R.string.not_again_conndall;
                naKey = R.string.key_notagain_conndall;
            }
        } else if ( cndmsg.m_nMissing > 0 ) {
            String fmt = getString( R.string.msg_relay_waiting );
            str = String.format( fmt, cndmsg.m_devOrder,
                                 cndmsg.m_room, cndmsg.m_nMissing );
            if ( cndmsg.m_devOrder == 1 ) {
                naMsg = R.string.not_again_conndfirst;
                naKey = R.string.key_notagain_conndfirst;
            } else {
                naMsg = R.string.not_again_conndmid;
                naKey = R.string.key_notagain_conndmid;
            }
        }

        if ( null != str ) {
            final String fstr = str;
            Runnable proc = new Runnable() {
                    public void run() {
                        Toast.makeText( BoardActivity.this, fstr,
                                        Toast.LENGTH_SHORT).show();
                    }
                };
            if ( naMsg == 0 ) {
                proc.run();
            } else {
                showNotAgainDlgThen( naMsg, naKey, proc );
            }
        }
    } // handleConndMessage

    //////////////////////////////////////////
    // XW_UtilCtxt interface implementation //
    //////////////////////////////////////////
    static final int[][] s_buttsBoard = { 
        { BONUS_TRIPLE_WORD,  BONUS_NONE,         BONUS_NONE,BONUS_DOUBLE_LETTER,BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_TRIPLE_WORD },
        { BONUS_NONE,         BONUS_DOUBLE_WORD,  BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_TRIPLE_LETTER,BONUS_NONE,BONUS_NONE },

        { BONUS_NONE,         BONUS_NONE,         BONUS_DOUBLE_WORD,BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_DOUBLE_LETTER,BONUS_NONE },
        { BONUS_DOUBLE_LETTER,BONUS_NONE,         BONUS_NONE,BONUS_DOUBLE_WORD,BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_DOUBLE_LETTER },
                            
        { BONUS_NONE,         BONUS_NONE,         BONUS_NONE,BONUS_NONE,BONUS_DOUBLE_WORD,BONUS_NONE,BONUS_NONE,BONUS_NONE },
        { BONUS_NONE,         BONUS_TRIPLE_LETTER,BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_TRIPLE_LETTER,BONUS_NONE,BONUS_NONE },
                            
        { BONUS_NONE,         BONUS_NONE,         BONUS_DOUBLE_LETTER,BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_DOUBLE_LETTER,BONUS_NONE },
        { BONUS_TRIPLE_WORD,  BONUS_NONE,         BONUS_NONE,BONUS_DOUBLE_LETTER,BONUS_NONE,BONUS_NONE,BONUS_NONE,BONUS_DOUBLE_WORD },
    }; /* buttsBoard */

    public int getSquareBonus( int col, int row ) 
    {
        int half = m_gi.boardSize / 2;
        if ( col > half ) { col = (half*2) - col; }
        if ( row > half ) { row = (half*2) - row; }
        return s_buttsBoard[row][col];
    }

    public void requestTime() 
    {
        m_handler.post( new Runnable() {
                public void run() {
                    if ( null != m_jniThread ) {
                        m_jniThread.handle( JNIThread.JNICmd.CMD_DO, false );
                    }
                }
            } );
    }

    public void remSelected() 
    {
        m_jniThread.handle( JNIThread.JNICmd.CMD_REMAINING,
                            R.string.tiles_left_title );
    }

    public void setIsServer( boolean isServer )
    {
        Utils.logf( ""setIsServer(%s)"", isServer?""true"":""false"" );
        DeviceRole newRole = isServer? DeviceRole.SERVER_ISSERVER
            : DeviceRole.SERVER_ISCLIENT;
        if ( newRole != m_gi.serverRole ) {
            Utils.logf( ""new role: %s; old role: %s"", 
                        newRole.toString(), m_gi.serverRole.toString() );
            m_gi.serverRole = newRole;
            if ( !isServer ) {
                m_jniThread.handle( JNIThread.JNICmd.CMD_SWITCHCLIENT );
            }
        }
    }

    public void setTimer( int why, int when, int handle )
    {
        if ( null != m_timers[why] ) {
            m_handler.removeCallbacks( m_timers[why] );
        }

        m_timers[why] = new TimerRunnable( why, when, handle );

        int inHowLong;
        switch ( why ) {
        case UtilCtxt.TIMER_COMMS:
            inHowLong = when * 1000;
            break;
        case UtilCtxt.TIMER_TIMERTICK:
            inHowLong = 1000;   // when is 0 for TIMER_TIMERTICK
            break;
        default:
            inHowLong = 500;
        }
        m_handler.postDelayed( m_timers[why], inHowLong );
    }

    public void clearTimer( int why ) 
    {
        Utils.logf( ""clearTimer called"" );
        if ( null != m_timers[why] ) {
            m_handler.removeCallbacks( m_timers[why] );
            m_timers[why] = null;
        }
    }

    private void loadGame()
    {
        if ( 0 == m_jniGamePtr ) {
            byte[] stream = GameUtils.savedGame( this, m_path );
            XwJNI.gi_from_stream( m_gi, stream );

            Utils.logf( ""loadGame: dict name: %s"", m_gi.dictName );
            byte[] dictBytes = GameUtils.openDict( this, m_gi.dictName );
            Assert.assertNotNull( dictBytes );
            m_jniGamePtr = XwJNI.initJNI();

            if ( m_gi.serverRole != DeviceRole.SERVER_STANDALONE ) {
                Handler handler = new Handler() {
                        public void handleMessage( Message msg ) {
                            switch( msg.what ) {
                            case CommsTransport.DIALOG:
                            case CommsTransport.DIALOG_RETRY:
                                m_dlgBytes = (String)msg.obj;
                                m_dlgTitle = msg.arg1;
                                showDialog( CommsTransport.DIALOG==msg.what
                                            ? DLG_OKONLY : DLG_RETRY );
                                break;
                            case CommsTransport.TOAST:
                                Toast.makeText( BoardActivity.this,
                                                (CharSequence)(msg.obj),
                                                Toast.LENGTH_SHORT).show();
                                break;
                            case CommsTransport.RELAY_COND:
                                handleConndMessage( msg );
                                break;
                            }
                        }
                    };
                m_xport = new CommsTransport( m_jniGamePtr, this, handler, 
                                              m_gi.serverRole );
            }

            CommonPrefs cp = CommonPrefs.get( this );
            if ( null == stream ||
                 ! XwJNI.game_makeFromStream( m_jniGamePtr, stream, 
                                              m_gi, dictBytes, 
                                              m_gi.dictName,this, m_jniu, 
                                              m_view, cp, m_xport ) ) {
                XwJNI.game_makeNewGame( m_jniGamePtr, m_gi, this, m_jniu, 
                                        m_view, cp, m_xport, 
                                        dictBytes, m_gi.dictName );
            }

            m_jniThread = new 
                JNIThread( m_jniGamePtr, m_gi, m_view, m_path, this,
                           new Handler() {
                               public void handleMessage( Message msg ) {
                                   switch( msg.what ) {
                                   case JNIThread.DRAW:
                                       m_view.invalidate();
                                       break;
                                   case JNIThread.DIALOG:
                                       m_dlgBytes = (String)msg.obj;
                                       m_dlgTitle = msg.arg1;
                                       showDialog( DLG_OKONLY );
                                       break;
                                   case JNIThread.QUERY_ENDGAME:
                                       showDialog( QUERY_ENDGAME );
                                       break;
                                   case JNIThread.TOOLBAR_STATES:
                                       m_toolbar.update( msg.arg1, msg.arg2 );
                                   }
                               }
                           } );
            m_jniThread.start();

            m_view.startHandling( m_jniThread, m_jniGamePtr, m_gi );
            if ( null != m_xport ) {
                m_xport.setReceiver( m_jniThread );
            }
            m_jniThread.handle( JNICmd.CMD_START );

            if ( !CommonPrefs.getHideTitleBar( this ) ) {
                setTitle( GameUtils.gameName( this, m_path ) );
            }
            m_toolbar = 
                new Toolbar( this, findViewById( R.id.toolbar_horizontal ),
                             findViewById( R.id.toolbar_vertical ) );

            boolean isLandscape = 
                getResources().getConfiguration().orientation
                == Configuration.ORIENTATION_LANDSCAPE;
            m_toolbar.orientChanged( isLandscape );
            populateToolbar();
        }
    } // loadGame

    private void populateToolbar()
    {
        m_toolbar.setListener( Toolbar.BUTTON_HINT_PREV, 
                               R.string.not_again_hintprev,
                               R.string.key_notagain_hintprev,
                               new Runnable() {
                                   public void run() {
                                       m_jniThread.handle( JNIThread.JNICmd
                                                           .CMD_PREV_HINT );
                                   }
                               } );
        m_toolbar.setListener( Toolbar.BUTTON_HINT_NEXT,
                               R.string.not_again_hintnext,
                               R.string.key_notagain_hintnext,
                               new Runnable() {
                                   @Override
                                   public void run() {
                                       m_jniThread.handle( JNIThread.JNICmd
                                                           .CMD_NEXT_HINT );
                                   }
                               } );
        m_toolbar.setListener( Toolbar.BUTTON_JUGGLE,
                               R.string.not_again_juggle,
                               R.string.key_notagain_juggle,
                               new Runnable() {
                                   @Override
                                   public void run() {
                                       m_jniThread.handle( JNIThread.JNICmd
                                                           .CMD_JUGGLE );
                                   }
                               } );
        m_toolbar.setListener( Toolbar.BUTTON_FLIP,
                               R.string.not_again_flip,
                               R.string.key_notagain_flip,
                               new Runnable() {
                                   @Override
                                   public void run() {
                                       m_jniThread.handle( JNIThread.JNICmd
                                                           .CMD_FLIP );
                                   }
                               } );
        m_toolbar.setListener( Toolbar.BUTTON_ZOOM,
                               R.string.not_again_zoom,
                               R.string.key_notagain_zoom,
                               new Runnable() {
                                   @Override
                                   public void run() {
                                       m_jniThread.handle( JNIThread.JNICmd
                                                           .CMD_TOGGLEZOOM );
                                   }
                               } );
        m_toolbar.setListener( Toolbar.BUTTON_UNDO,
                               R.string.not_again_undo,
                               R.string.key_notagain_undo,
                               new Runnable() {
                                   @Override
                                   public void run() {
                                       m_jniThread.handle( JNIThread.JNICmd
                                                           .CMD_UNDO_CUR );
                                   }
                               });
        m_toolbar.setListener( Toolbar.BUTTON_CHAT,
                               R.string.not_again_chat, 
                               R.string.key_notagain_chat,
                               new Runnable() {
                                   @Override
                                   public void run() {
                                       showDialog( GET_MESSAGE );
                                   }
                               });
    } // populateToolbar

    private DialogInterface.OnDismissListener makeODLforBlocking()
    {
        return new DialogInterface.OnDismissListener() {
            public void onDismiss( DialogInterface di ) {
                setRequestedOrientation( ActivityInfo.SCREEN_ORIENTATION_SENSOR );
                releaseIfBlocking();
            }
        };
    }

    private int waitBlockingDialog( final int dlgID, int cancelResult )
    {
        setBlockingThread();
        int orient = m_currentOrient == Configuration.ORIENTATION_LANDSCAPE
            ? ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
            : ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
        setRequestedOrientation( orient );

        m_handler.post( new Runnable() {
                public void run() {
                    showDialog( dlgID );
                }
            } );

        try {
            m_forResultWait.acquire();
        } catch ( java.lang.InterruptedException ie ) {
            m_resultCode = cancelResult;
            dismissDialog( dlgID );
            Utils.logf( ""waitBlockingDialog: got "" + ie.toString() );
        }
        clearBlockingThread();
        return m_resultCode;
    }

    private void nonBlockingDialog( final int dlgID, String txt ) 
    {
        switch ( dlgID ) {
        case DLG_OKONLY:
            m_dlgTitle = R.string.info_title;
            break;
        case DLG_BADWORDS:
            m_dlgTitle = R.string.badwords_title;
            break;
        default:
            Assert.fail();
        }

        m_dlgBytes = txt;
        m_handler.post( new Runnable() {
                public void run() {
                    showDialog( dlgID );
                }
            } );
    }

    private boolean doZoom( int zoomBy )
    {
        boolean handled = null != m_jniThread;
        if ( handled ) {
            m_jniThread.handle( JNIThread.JNICmd.CMD_ZOOM, zoomBy );
        }
        return handled;
    }

    // This is supposed to be called from the jni thread
    public int userPickTile( int playerNum, String[] texts )
    {
        m_texts = texts;
        waitBlockingDialog( PICK_TILE_REQUEST_BLK, 0 );
        return m_resultCode;
    }

    public String askPassword( String name )
    {
        String fmt = getString( R.string.msg_ask_password );
        m_dlgTitleStr = String.format( fmt, name );

        if ( null == m_passwdEdit ) {
            LayoutInflater factory = LayoutInflater.from( this );
            m_passwdEdit = (EditText)factory.inflate( R.layout.passwd_view, null );
        }
        waitBlockingDialog( ASK_PASSWORD_BLK, 0 );

        String result = null;      // means cancelled
        if ( 0 != m_resultCode ) {
            result = m_passwdEdit.getText().toString();
        }
        return result;
    }

    public void turnChanged()
    {
        m_jniThread.handle( JNIThread.JNICmd.CMD_ZOOM, -8 );
    }

    public boolean engineProgressCallback()
    {
        return ! m_jniThread.busy();
    }

    public void engineStarting( int nBlanks )
    {
        if ( nBlanks > 0 ) {
            m_handler.post( new Runnable() {
                    // Need to keep this from running after activity dies!!
                    public void run() {
                        if ( m_isVisible ) {
                            String title = getString( R.string.progress_title );
                            m_progress = ProgressDialog.show( BoardActivity.this,
                                                              title, null, true, 
                                                              true );
                        }
                    }
                } );
        }
    }

    public void engineStopping()
    {
        m_handler.post( new Runnable() {
                public void run() {
                    if ( null != m_progress ) {
                        m_progress.cancel();
                        m_progress = null;
                    }
                }
            } );
    }

    public String getUserString( int stringCode )
    {
        int id = 0;
        switch( stringCode ) {
        case UtilCtxt.STRD_ROBOT_TRADED:
            id = R.string.strd_robot_traded;
            break;
        case UtilCtxt.STR_ROBOT_MOVED:
            id = R.string.str_robot_moved;
            break;
        case UtilCtxt.STRS_VALUES_HEADER:
            id = R.string.strs_values_header;
            break;
        case UtilCtxt.STRD_REMAINING_TILES_ADD:
            id = R.string.strd_remaining_tiles_add;
            break;
        case UtilCtxt.STRD_UNUSED_TILES_SUB:
            id = R.string.strd_unused_tiles_sub;
            break;
        case UtilCtxt.STR_REMOTE_MOVED:
            id = R.string.str_remote_moved;
            break;
        case UtilCtxt.STRD_TIME_PENALTY_SUB:
            id = R.string.strd_time_penalty_sub;
            break;
        case UtilCtxt.STR_PASS:
            id = R.string.str_pass;
            break;
        case UtilCtxt.STRS_MOVE_ACROSS:
            id = R.string.strs_move_across;
            break;
        case UtilCtxt.STRS_MOVE_DOWN:
            id = R.string.strs_move_down;
            break;
        case UtilCtxt.STRS_TRAY_AT_START:
            id = R.string.strs_tray_at_start;
            break;
        case UtilCtxt.STRSS_TRADED_FOR:
            id = R.string.strss_traded_for;
            break;
        case UtilCtxt.STR_PHONY_REJECTED:
            id = R.string.str_phony_rejected;
            break;
        case UtilCtxt.STRD_CUMULATIVE_SCORE:
            id = R.string.strd_cumulative_score;
            break;
        case UtilCtxt.STRS_NEW_TILES:
            id = R.string.strs_new_tiles;
            break;
        case UtilCtxt.STR_PASSED:
            id = R.string.str_passed;
            break;
        case UtilCtxt.STRSD_SUMMARYSCORED:
            id = R.string.strsd_summaryscored;
            break;
        case UtilCtxt.STRD_TRADED:
            id = R.string.strd_traded;
            break;
        case UtilCtxt.STR_LOSTTURN:
            id = R.string.str_lostturn;
            break;
        case UtilCtxt.STR_COMMIT_CONFIRM:
            id = R.string.str_commit_confirm;
            break;
        case UtilCtxt.STR_LOCAL_NAME:
            id = R.string.str_local_name;
            break;
        case UtilCtxt.STR_NONLOCAL_NAME:
            id = R.string.str_nonlocal_name;
            break;
        case UtilCtxt.STR_BONUS_ALL:
            id = R.string.str_bonus_all;
            break;
        case UtilCtxt.STRD_TURN_SCORE:
            id = R.string.strd_turn_score;
            break;
        default:
            Utils.logf( ""no such stringCode: "" + stringCode );
        }

        String result;
        if ( 0 == id ) {
            result = """";
        } else {
            result = getString( id );
        }
        return result;
    }

    public boolean userQuery( int id, String query )
    {
        boolean result;

        switch( id ) {
            // Though robot-move dialogs don't normally need to block,
            // if the player after this one is also a robot and we
            // don't block then a second dialog will replace this one.
            // So block.  Yuck.
        case UtilCtxt.QUERY_ROBOT_MOVE:
        case UtilCtxt.QUERY_ROBOT_TRADE:
            m_dlgBytes = query;
            m_dlgTitle = R.string.info_title;
            waitBlockingDialog( QUERY_INFORM_BLK, 0 );
            result = true;
            break;

            // These *are* blocking dialogs
        case UtilCtxt.QUERY_COMMIT_TRADE:
        case UtilCtxt.QUERY_COMMIT_TURN:
            if ( UtilCtxt.QUERY_COMMIT_TRADE == id ) {
                m_dlgBytes = getString( R.string.query_trade );
            } else {
                m_dlgBytes = query;
            }
            m_dlgTitle = R.string.query_title;
            result = 0 != waitBlockingDialog( QUERY_REQUEST_BLK, 0 );
            break;
        default:
            Assert.fail();
            result = false;
        }

        return result;
    }

    public void userError( int code )
    {
        int resid = 0;
        switch( code ) {
        case ERR_TILES_NOT_IN_LINE:
            resid = R.string.str_tiles_not_in_line;
            break;
        case ERR_NO_EMPTIES_IN_TURN:
            resid = R.string.str_no_empties_in_turn;
            break;
        case ERR_TWO_TILES_FIRST_MOVE:
            resid = R.string.str_two_tiles_first_move;
            break;
        case ERR_TILES_MUST_CONTACT:
            resid = R.string.str_tiles_must_contact;
            break;
        case ERR_NOT_YOUR_TURN:
            resid = R.string.str_not_your_turn;
            break;
        case ERR_NO_PEEK_ROBOT_TILES:
            resid = R.string.str_no_peek_robot_tiles;
            break;
        case ERR_CANT_TRADE_MID_MOVE:
            resid = R.string.str_cant_trade_mid_move;
            break;
        case ERR_TOO_FEW_TILES_LEFT_TO_TRADE:
            resid = R.string.str_too_few_tiles_left_to_trade;
            break;
        case ERR_CANT_UNDO_TILEASSIGN:
            resid = R.string.str_cant_undo_tileassign;
            break;
        case ERR_CANT_HINT_WHILE_DISABLED:
            resid = R.string.str_cant_hint_while_disabled;
            break;
        case ERR_NO_PEEK_REMOTE_TILES:
            resid = R.string.str_no_peek_remote_tiles;
            break;
        case ERR_REG_UNEXPECTED_USER:
            resid = R.string.str_reg_unexpected_user;
            break;
        case ERR_SERVER_DICT_WINS:
            resid = R.string.str_server_dict_wins;
            break;
        case ERR_REG_SERVER_SANS_REMOTE:
            resid = R.string.str_reg_server_sans_remote;
            break;
        }

        if ( resid != 0 ) {
            nonBlockingDialog( DLG_OKONLY, getString( resid ) );
        }
    } // userError

    public void notifyGameOver()
    {
        m_jniThread.handle( JNIThread.JNICmd.CMD_POST_OVER );
    }

    // public void yOffsetChange( int maxOffset, int oldOffset, int newOffset )
    // {
    //     Utils.logf( ""yOffsetChange(maxOffset=%d)"", maxOffset );
    //     m_view.setVerticalScrollBarEnabled( maxOffset > 0 );
    // }

    public boolean warnIllegalWord( String[] words, int turn, boolean turnLost )
    {
        Utils.logf( ""warnIllegalWord"" );
        boolean accept = turnLost;

        StringBuffer sb = new StringBuffer();
        for ( int ii = 0; ; ) {
            sb.append( words[ii] );
            if ( ++ii == words.length ) {
                break;
            }
            sb.append( ""; "" );
        }
        
        String format = getString( R.string.ids_badwords );
        String message = String.format( format, sb.toString() );

        if ( turnLost ) {
            nonBlockingDialog( DLG_BADWORDS, 
                               message + getString(R.string.badwords_lost) );
        } else {
            m_dlgBytes = message + getString( R.string.badwords_accept );
            m_dlgTitle = R.string.query_title;
            accept = 0 != waitBlockingDialog( QUERY_REQUEST_BLK, 0 );
        }

        Utils.logf( ""warnIllegalWord=>"" + accept );
        return accept;
    }

    // Let's have this block in case there are multiple messages.  If
    // we don't block the jni thread will continue processing messages
    // and may stack dialogs on top of this one.  Including later
    // chat-messages.
    public void showChat( String msg )
    {
        m_dlgBytes = msg;
        m_dlgTitle = R.string.chat_received;
        waitBlockingDialog( GOT_MESSAGE_BLK, 0 );
    }
} // class BoardActivity
",True,30,32,0,0,3,16,0,14,L3
22,org.eehouse.android.xw4.PollListPreference.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.preference.Preference;
import android.preference.ListPreference;
import android.content.Context;
import android.util.AttributeSet;
import junit.framework.Assert;


public class PollListPreference extends ListPreference
    implements Preference.OnPreferenceChangeListener {

    private Context m_context;

    public PollListPreference( Context context, AttributeSet attrs )
    {
        super( context, attrs );
        m_context = context;
        setOnPreferenceChangeListener( this );
    }

    @Override
    protected void onAttachedToActivity()
    {
        String val = getPersistedString( ""0"" );
        setSummaryToMatch( val );
    }

    // Preference.OnPreferenceChangeListener interface
    public boolean onPreferenceChange( Preference preference, Object newValue )
    {
        String valstr = (String)newValue;
        int val = Integer.parseInt(valstr);
        RelayReceiver.RestartTimer( m_context, val * 1000 );

        setSummaryToMatch( valstr );
        return true;
    }

    private void setSummaryToMatch( String value )
    {
        int index = findIndexOfValue( value );
        if ( 0 <= index ) {
            CharSequence entry = getEntries()[index];
            setSummary( entry );
        }
    }
}",False,43,22,0,0,6,7,0,1,L3
23,org.eehouse.android.xw4.FirstRunDialog.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.pm.PackageInfo;
import android.app.AlertDialog;
import android.webkit.WebView;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;

/* Put up a dialog greeting user after every upgrade.  Based on
 * similar feature in OpenSudoku, to whose author ""Thanks"".
 */

public class FirstRunDialog {
	private static final String HIDDEN_PREFS = ""xwprefs_hidden"";
    private static final String SHOWN_VERSION_KEY = ""SHOWN_VERSION_KEY"";

    static boolean show( Context context, boolean skipCheck )
    {
        int thisVersion = 0;
        int shownVersion = 0;

        if ( !skipCheck ) {
            try {
                thisVersion = context.getPackageManager()
                    .getPackageInfo(context.getPackageName(), 0)
                    .versionCode;
                Utils.logf( ""versionCode: %d"", thisVersion );
            } catch ( Exception e ) {
            }
        }

        SharedPreferences prefs = null;
        if ( thisVersion > 0 ) {
            prefs = context.getSharedPreferences( HIDDEN_PREFS, 
                                                  Context.MODE_PRIVATE );
            shownVersion = prefs.getInt( SHOWN_VERSION_KEY, 0 );
        }

        boolean isUpgrade = shownVersion < thisVersion;
        if ( skipCheck || isUpgrade ) {
            showDialog( context );
        
            if ( !skipCheck ) {
                Editor editor = prefs.edit();
                editor.putInt( SHOWN_VERSION_KEY, thisVersion );
                editor.commit();
            }
        }
        return isUpgrade;
    }

    private static void showDialog( Context context )
    {
        String page = null;
        InputStream inputStream = null;
		try {
            inputStream = context.getResources()
                .openRawResource(R.raw.changes);
			
			final char[] buf = new char[0x1000];
			StringBuilder stringBuilder = new StringBuilder();
			Reader reader = new InputStreamReader( inputStream, ""UTF-8"" );
			int nRead;
			do {
                nRead = reader.read( buf, 0, buf.length );
                if ( nRead > 0 ) {
                    stringBuilder.append( buf, 0, nRead );
                }
			} while ( nRead >= 0 );
			
			page = stringBuilder.toString();
		}
		catch ( IOException ioe ) {
			Utils.logf( ioe.toString() );
		}
		finally {
            // could just catch NPE....
			if ( null != inputStream ) {
				try {
					inputStream.close();
				} catch ( IOException ioe ) {
                    Utils.logf( ioe.toString() );
				}
			}
		}
		
        // This won't support e.g mailto refs.  Probably want to
        // launch the browser with an intent eventually.
		WebView view = new WebView( context );
		view.loadData( page, ""text/html"", ""utf-8"" );

		AlertDialog dialog = new AlertDialog.Builder( context )
            .setIcon(android.R.drawable.ic_menu_info_details)
            .setTitle( R.string.changes_title )
            .setView( view )
            .setPositiveButton( R.string.button_ok, null)
            .create();
		dialog.show();
    }
}
",True,41,35,5,4,5,9,2,1,L1
24,org.eehouse.android.xw4.DlgDelegate.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.view.LayoutInflater;
import android.net.Uri;
import junit.framework.Assert;
import android.view.View;
import android.widget.TextView;
import android.app.AlertDialog;

import org.eehouse.android.xw4.jni.CommonPrefs;


public class DlgDelegate {

    public static final int DIALOG_ABOUT = 1;
    public static final int DIALOG_OKONLY = 2;
    public static final int DIALOG_NOTAGAIN = 3;
    public static final int CONFIRM_THEN = 4;
    public static final int DIALOG_LAST = CONFIRM_THEN;

    private int m_msgID;
    private String m_msg;
    private Runnable m_proc = null;
    private int m_prefsKey;
    private Activity m_activity;
    private String m_dictName = null;
    DialogInterface.OnClickListener m_then;

    public DlgDelegate( Activity activity ) {
        m_activity = activity;
    }
    
    public Dialog onCreateDialog( int id )
    {
        Dialog dialog = null;
        switch( id ) {
        case DIALOG_ABOUT:
            dialog = createAboutDialog();
            break;
        case DIALOG_OKONLY:
            dialog = createOKDialog();
            break;
        case DIALOG_NOTAGAIN:
            dialog = createNotAgainDialog();
            break;
        case CONFIRM_THEN:
            dialog = createConfirmThenDialog();
            break;
        }
        return dialog;
    }

    public void onPrepareDialog( int id, Dialog dialog )
    {
        AlertDialog ad = (AlertDialog)dialog;
        switch( id ) {
        case DIALOG_ABOUT:
            break;
        case DIALOG_NOTAGAIN:
            // Don't think onclick listeners need to be reset.  They
            // reference instance vars that are changed each time
            // showNotAgainDlgThen() is called
            // FALLTHRU
        case DIALOG_OKONLY:
            ad.setMessage( m_activity.getString(m_msgID) );
            break;
        case CONFIRM_THEN:
            // I'm getting an occasional 0 here on device only.  May
            // be related to screen orientation changes.  Let's be safe
            ad.setMessage( m_msg );
            ad.setButton( AlertDialog.BUTTON_POSITIVE, 
                          m_activity.getString( R.string.button_ok ), m_then );
            break;
        }
    }

    public void showOKOnlyDialog( int msgID )
    {
        m_msgID = msgID;
        m_activity.showDialog( DIALOG_OKONLY );
    }

    public void showAboutDialog()
    {
        m_activity.showDialog( DIALOG_ABOUT );
    }

    public void showNotAgainDlgThen( int msgID, int prefsKey,
                                     Runnable proc )
    {
        boolean set = CommonPrefs.getPrefsBoolean( m_activity, prefsKey, false );
        if ( set ) {
            Utils.logf( ""showNotAgainDlgThen: skipping message"" );
            if ( null != proc ) {
                proc.run();
            } 
        } else {
            Utils.logf( ""showNotAgainDlgThen: setting message: %d"", msgID );
            m_msgID = msgID;
            m_proc = proc;
            m_prefsKey = prefsKey;
            m_activity.showDialog( DIALOG_NOTAGAIN );
        }
    }

    public void showConfirmThen( String msg, DialogInterface.OnClickListener then )
    {
        m_msg = msg;
        m_then = then;
        m_activity.showDialog( CONFIRM_THEN );
    }

    private Dialog createAboutDialog()
    {
        LayoutInflater factory = LayoutInflater.from( m_activity );
        final View view = factory.inflate( R.layout.about_dlg, null );
        TextView vers = (TextView)view.findViewById( R.id.version_string );
        vers.setText( String.format( m_activity.getString(R.string.about_versf), 
                                     XWConstants.VERSION_STR, 
                                     GitVersion.VERS ) );

        TextView xlator = (TextView)view.findViewById( R.id.about_xlator );
        String str = m_activity.getString( R.string.xlator );
        if ( str.length() > 0 ) {
            xlator.setText( str );
        } else {
            xlator.setVisibility( View.GONE );
        }

        return new AlertDialog.Builder( m_activity )
            .setIcon( R.drawable.icon48x48 )
            .setTitle( R.string.app_name )
            .setView( view )
            .setPositiveButton( R.string.changes_button,
                                new DialogInterface.OnClickListener() {
                                    @Override
                                    public void onClick( DialogInterface dlg, 
                                                         int which )
                                    {
                                        FirstRunDialog.show( m_activity, true );
                                    }
                                } )
            .create();
    }

    private Dialog createOKDialog()
    {
        return new AlertDialog.Builder( m_activity )
            .setTitle( R.string.info_title )
            .setMessage( m_msgID )
            .setPositiveButton( R.string.button_ok, null )
            .create();
    }

    private Dialog createNotAgainDialog()
    {
        Dialog dialog = null;
        if ( 0 != m_msgID ) {
            DialogInterface.OnClickListener lstnr_p = 
                new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        if ( null != m_proc ) {
                            m_proc.run();
                        }
                    }
                };

            DialogInterface.OnClickListener lstnr_n = 
                new DialogInterface.OnClickListener() {
                    public void onClick( DialogInterface dlg, int item ) {
                        CommonPrefs.setPrefsBoolean( m_activity, m_prefsKey, 
                                                     true );
                        if ( null != m_proc ) {
                            m_proc.run();
                        }
                    }
                };

            dialog = new AlertDialog.Builder( m_activity )
                .setTitle( R.string.newbie_title )
                .setMessage( m_msgID )
                .setPositiveButton( R.string.button_ok, lstnr_p )
                .setNegativeButton( R.string.button_notagain, lstnr_n )
                .create();
        }
        return dialog;
    } // createNotAgainDialog

    private Dialog createConfirmThenDialog()
    {
        Dialog dialog = new AlertDialog.Builder( m_activity )
            .setTitle( R.string.query_title )
            .setMessage( """" )
            .setPositiveButton( R.string.button_ok, null ) // will change
            .setNegativeButton( R.string.button_cancel, null )
            .create();
        return dialog;
    }
}
",True,10,35,4,5,5,8,5,4,L1
25,org.eehouse.android.xw4.EditColorPreference.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.preference.DialogPreference;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.TypedArray;
import android.util.AttributeSet;
import android.view.View;
import android.widget.SeekBar;
import android.widget.EditText;
import android.app.Dialog;
import android.content.SharedPreferences;
import android.app.AlertDialog;
import android.text.TextWatcher;
import android.text.Editable;
import junit.framework.Assert;

public class EditColorPreference extends DialogPreference {

    private Context m_context;
    private int m_curColor;
    // m_updateText: prevent loop that resets edittext cursor
    private boolean m_updateText = true;
    private static final int m_seekbarIds[] = { R.id.seek_red, R.id.seek_green, 
                                                R.id.seek_blue };
    private static final int m_editIds[] = { R.id.edit_red, R.id.edit_green, 
                                             R.id.edit_blue };

    private class SBCL implements SeekBar.OnSeekBarChangeListener {
        int m_index;
        View m_sample;
        EditText m_editTxt;
        public SBCL( View parent, EditText editTxt, int indx )
        {
            m_index = indx;
            m_sample = parent.findViewById( R.id.color_edit_sample );
            m_editTxt = editTxt;
        }

        public void onProgressChanged( SeekBar seekBar, int progress, 
                                       boolean fromUser )
        {
            if ( m_updateText ) {
                m_editTxt.setText( String.format( ""%d"", progress ) );
            }

            int shift = 16 - (m_index * 8);
            // mask out the byte we're changing
            int color = m_curColor & ~(0xFF << shift);
            // add in the new version of the byte
            color |= progress << shift;
            m_curColor = color;
            m_sample.setBackgroundColor( m_curColor );
        }

        public void onStartTrackingTouch( SeekBar seekBar ) {}

        public void onStopTrackingTouch( SeekBar seekBar ) {}
    }

    private class TCL implements TextWatcher {
        private SeekBar m_seekBar;
        public TCL( SeekBar seekBar ) { m_seekBar = seekBar; }
        public void afterTextChanged( Editable s )
        {
        }

        public void beforeTextChanged( CharSequence s, int st, int cnt, int a ) 
        {
        }

        public void onTextChanged( CharSequence s, int start, 
                                   int before, int count )
        {
            int val;
            try {
                val = Integer.parseInt( s.toString() );
            } catch ( java.lang.NumberFormatException nfe ) {
                val = 0;
            }
            m_updateText = false; // don't call me recursively inside seekbar
            m_seekBar.setProgress( val );
            m_updateText = true;
        }
    }

    public EditColorPreference( Context context, AttributeSet attrs )
    {
        super( context, attrs );
        m_context = context;
        
        setWidgetLayoutResource( R.layout.color_display );
        setDialogLayoutResource( R.layout.color_edit );
    }

    @Override
    protected Object onGetDefaultValue(TypedArray a, int index) {
        return a.getInteger(index, 0);
    }

    @Override
    protected void onSetInitialValue(boolean restoreValue, Object defaultValue) {
        if ( !restoreValue ) {
            persistInt( (Integer)defaultValue );
        }
    }
    
    @Override
    protected void onBindView( View parent ) 
    {
        super.onBindView( parent );
        View sample = parent.findViewById( R.id.color_display_sample );
        sample.setBackgroundColor( getPersistedColor() );
    }

    @Override
    protected void onBindDialogView( View view )
    {
        m_curColor = getPersistedColor();
        setOneByte( view, 0 );
        setOneByte( view, 1 );
        setOneByte( view, 2 );

        View sample = (View)view.findViewById( R.id.color_edit_sample );
        sample.setBackgroundColor( m_curColor );
    }
    
    @Override
    protected void onPrepareDialogBuilder( AlertDialog.Builder builder )
    {
        DialogInterface.OnClickListener lstnr = 
            new DialogInterface.OnClickListener() {
                @Override
                public void onClick( DialogInterface dialog, int which )
                {
                    int color = (getOneByte( dialog, R.id.seek_red ) << 16)
                        | (getOneByte( dialog, R.id.seek_green ) << 8)
                        | getOneByte( dialog, R.id.seek_blue );

                    persistInt( color );
                    notifyChanged();
                }
            };
        builder.setPositiveButton( R.string.button_ok, lstnr );
        super.onPrepareDialogBuilder( builder );
    }

    private void setOneByte( View parent, int indx ) 
    {
        int shift = 16 - (indx*8);
        int byt = (m_curColor >> shift) & 0xFF;
        SeekBar seekbar = (SeekBar)parent.findViewById( m_seekbarIds[indx] );
        EditText edittext = (EditText)parent.findViewById( m_editIds[indx] );

        if ( null != seekbar ) {
            seekbar.setProgress( byt );

            seekbar.setOnSeekBarChangeListener( new SBCL( parent, edittext,
                                                          indx ) );
        }

        if ( null != edittext ) {
            edittext.setText( String.format( ""%d"", byt ) );
            edittext.addTextChangedListener( new TCL( seekbar ) );
        }
    }

    private int getOneByte( DialogInterface parent, int id ) {
        int val = 0;
        Dialog dialog = (Dialog)parent;
        SeekBar seekbar = (SeekBar)dialog.findViewById( id );
        if ( null != seekbar ) {
            val = seekbar.getProgress();
        }
        return val;
    }

    private int getPersistedColor()
    {
        return 0xFF000000 | getPersistedInt(0);
    }
}
",False,35,1,0,0,0,0,0,0,I0
26,org.eehouse.android.xw4.GameConfig.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import java.io.File;
import java.util.ArrayList;
import android.view.Gravity;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.TextView;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.app.Dialog;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.view.LayoutInflater;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.ImageButton;
import android.view.MenuInflater;
import android.view.KeyEvent;
import android.widget.Spinner;
import android.widget.ArrayAdapter;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.ListAdapter;
import android.widget.SpinnerAdapter;
import android.widget.Toast;
import android.database.DataSetObserver;
import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class GameConfig extends XWActivity 
    implements View.OnClickListener
               ,XWListItem.DeleteCallback
               ,RefreshNamesTask.NoNameFound {

    private static final int PLAYER_EDIT = DlgDelegate.DIALOG_LAST + 1;
    private static final int FORCE_REMOTE = PLAYER_EDIT + 1;
    private static final int CONFIRM_CHANGE = PLAYER_EDIT + 2;
    private static final int CONFIRM_CHANGE_PLAY = PLAYER_EDIT + 3;
    private static final int NO_NAME_FOUND = PLAYER_EDIT + 4;

    private CheckBox m_joinPublicCheck;
    private CheckBox m_gameLockedCheck;
    private boolean m_isLocked;
    private LinearLayout m_publicRoomsSet;
    private LinearLayout m_privateRoomsSet;

    private boolean m_notNetworkedGame;
    private Button m_addPlayerButton;
    private Button m_jugglePlayersButton;
    private Button m_playButton;
    private ImageButton m_refreshRoomsButton;
    private View m_connectSet;  // really a LinearLayout
    private Spinner m_roomChoose;
    // private Button m_configureButton;
    private String m_path;
    private CurGameInfo m_gi;
    private CurGameInfo m_giOrig;
    private int m_whichPlayer;
    private Dialog m_curDialog;
    // private Spinner m_roleSpinner;
    // private Spinner m_connectSpinner;
    private Spinner m_phoniesSpinner;
    private Spinner m_dictSpinner;
    private String[] m_dictItems;
    private String[] m_dicts;
    private int m_browsePosition;
    private LinearLayout m_playerLayout;
    private CommsAddrRec m_carOrig;
    private CommsAddrRec m_car;
    private CommonPrefs m_cp;
    private boolean m_canDoSMS = false;
    private boolean m_canDoBT = false;
    private boolean m_gameStarted = false;
    private CommsAddrRec.CommsConnType[] m_types;
    private String[] m_connStrings;
    private static final int[] s_disabledWhenLocked = { R.id.juggle_players
                                                        ,R.id.add_player
                                                        ,R.id.dict_spinner
                                                        ,R.id.join_public_room_check
                                                        ,R.id.room_edit
                                                        ,R.id.advertise_new_room_check
                                                        ,R.id.room_spinner
                                                        ,R.id.refresh_button
                                                        ,R.id.hints_allowed
                                                        ,R.id.use_timer
                                                        ,R.id.timer_minutes_edit
                                                        ,R.id.smart_robot
                                                        ,R.id.phonies_spinner
    };

    class RemoteChoices extends XWListAdapter {
        public RemoteChoices() { super( GameConfig.this, m_gi.nPlayers ); }

        public Object getItem( int position) { return m_gi.players[position]; }
        public View getView( final int position, View convertView, 
                             ViewGroup parent ) {
            CompoundButton.OnCheckedChangeListener lstnr;
            lstnr = new CompoundButton.OnCheckedChangeListener() {
                    @Override
                    public void onCheckedChanged( CompoundButton buttonView, 
                                                 boolean isChecked )
                    {
                        m_gi.players[position].isLocal = !isChecked;
                    }
                };
            CheckBox cb = new CheckBox( GameConfig.this );
            LocalPlayer lp = m_gi.players[position];
            cb.setText( lp.name );
            cb.setChecked( !lp.isLocal );
            cb.setOnCheckedChangeListener( lstnr );
            return cb;
        }
    }

    @Override
    protected Dialog onCreateDialog( final int id )
    {
        Dialog dialog = super.onCreateDialog( id );
        if ( null == dialog ) {
            LayoutInflater factory;
            DialogInterface.OnClickListener dlpos;
            AlertDialog.Builder ab;

            switch (id) {
            case PLAYER_EDIT:
                factory = LayoutInflater.from(this);
                final View playerEditView
                    = factory.inflate( R.layout.player_edit, null );

                dialog = new AlertDialog.Builder( this )
                    .setTitle(R.string.player_edit_title)
                    .setView(playerEditView)
                    .setPositiveButton( R.string.button_ok,
                                        new DialogInterface.OnClickListener() {
                                            public void onClick( DialogInterface dlg, 
                                                                 int whichButton ) {
                                                getPlayerSettings();
                                                loadPlayers();
                                            }
                                        })
                    .setNegativeButton( R.string.button_cancel, null )
                    .create();
                break;
                // case ROLE_EDIT_RELAY:
                // case ROLE_EDIT_SMS:
                // case ROLE_EDIT_BT:
                //     dialog = new AlertDialog.Builder( this )
                //         .setTitle(titleForDlg(id))
                //         .setView( LayoutInflater.from(this)
                //                   .inflate( layoutForDlg(id), null ))
                //         .setPositiveButton( R.string.button_ok,
                //                             new DialogInterface.OnClickListener() {
                //                                 public void onClick( DialogInterface dlg, 
                //                                                      int whichButton ) {
                //                                     getRoleSettings();
                //                                 }
                //                             })
                //         .setNegativeButton( R.string.button_cancel, null )
                //         .create();
                //     break;

            case FORCE_REMOTE:
                dialog = new AlertDialog.Builder( this )
                    .setTitle( R.string.force_title )
                    .setView( LayoutInflater.from(this)
                              .inflate( layoutForDlg(id), null ) )
                    .setPositiveButton( R.string.button_ok,
                                        new DialogInterface.OnClickListener() {
                                            public void onClick( DialogInterface dlg, 
                                                                 int whichButton ) {
                                                loadPlayers();
                                            }
                                        })
                    .create();
                dialog.setOnDismissListener( new DialogInterface.OnDismissListener() {
                        @Override
                            public void onDismiss( DialogInterface di ) 
                        {
                            if ( m_gi.forceRemoteConsistent() ) {
                                Toast.makeText( GameConfig.this, 
                                                R.string.forced_consistent,
                                                Toast.LENGTH_SHORT).show();
                                loadPlayers();
                            }
                        }
                    });
                break;
            case CONFIRM_CHANGE_PLAY:
            case CONFIRM_CHANGE:
                dlpos = new DialogInterface.OnClickListener() {
                        public void onClick( DialogInterface dlg, 
                                             int whichButton ) {
                            applyChanges( true );
                            if ( CONFIRM_CHANGE_PLAY == id ) {
                                launchGame();
                            }
                        }
                    };
                ab = new AlertDialog.Builder( this )
                    .setTitle( R.string.confirm_save_title )
                    .setMessage( R.string.confirm_save )
                    .setPositiveButton( R.string.button_save, dlpos );
                if ( CONFIRM_CHANGE_PLAY == id ) {
                    dlpos = new DialogInterface.OnClickListener() {
                            public void onClick( DialogInterface dlg, 
                                                 int whichButton ) {
                                launchGame();
                            }
                        };
                } else {
                    dlpos = null;
                }
                ab.setNegativeButton( R.string.button_discard, dlpos );
                dialog = ab.create();

                dialog.setOnDismissListener( new DialogInterface.
                                             OnDismissListener() {
                        public void onDismiss( DialogInterface di ) {
                            finish();
                        }
                    });
                break;
            case NO_NAME_FOUND:
                dialog = new AlertDialog.Builder( this )
                    .setPositiveButton( R.string.button_ok, null )
                    // message added below since varies with language etc.
                    .setMessage("""") // if not set here can't change later
                    .create();
                break;
            }
        }
        return dialog;
    } // onCreateDialog

    @Override
    protected void onPrepareDialog( int id, Dialog dialog )
    { 
        m_curDialog = dialog;

        switch ( id ) {
        case PLAYER_EDIT:
            setPlayerSettings();
            break;
        // case ROLE_EDIT_RELAY:
        // case ROLE_EDIT_SMS:
        // case ROLE_EDIT_BT:
        //     setRoleHints( id, dialog );
        //     setRoleSettings();
        //     break;
        case FORCE_REMOTE:
            ListView listview = (ListView)dialog.findViewById( R.id.players );
            listview.setAdapter( new RemoteChoices() );
            break;
        case NO_NAME_FOUND:
            String format = getString( R.string.no_name_found_f );
            String msg = String.format( format, m_gi.nPlayers, DictLangCache.
                                        getLangName( this, m_gi.dictLang ) );
            ((AlertDialog)dialog).setMessage( msg );
            break;
        }
        super.onPrepareDialog( id, dialog );
    }

    private void setPlayerSettings()
    {
        // Hide remote option if in standalone mode...
        boolean isServer = !m_notNetworkedGame;
        LocalPlayer lp = m_gi.players[m_whichPlayer];
        Utils.setText( m_curDialog, R.id.player_name_edit, lp.name );
        Utils.setText( m_curDialog, R.id.password_edit, lp.password );

        final View localSet = m_curDialog.findViewById( R.id.local_player_set );

        CheckBox check = (CheckBox)
            m_curDialog.findViewById( R.id.remote_check );
        if ( isServer ) {
            CompoundButton.OnCheckedChangeListener lstnr =
                new CompoundButton.OnCheckedChangeListener() {
                    public void onCheckedChanged( CompoundButton buttonView, 
                                                  boolean checked ) {
                        localSet.setVisibility( checked ? 
                                                View.GONE : View.VISIBLE );
                    }
                };
            check.setOnCheckedChangeListener( lstnr );
            check.setVisibility( View.VISIBLE );
        } else {
            check.setVisibility( View.GONE );
            localSet.setVisibility( View.VISIBLE );
        }

        check = (CheckBox)m_curDialog.findViewById( R.id.robot_check );
        CompoundButton.OnCheckedChangeListener lstnr =
            new CompoundButton.OnCheckedChangeListener() {
                public void onCheckedChanged( CompoundButton buttonView, 
                                              boolean checked ) {
                    View view = m_curDialog.findViewById( R.id.password_set );
                    view.setVisibility( checked ? View.GONE : View.VISIBLE );
                }
            };
        check.setOnCheckedChangeListener( lstnr );

        Utils.setChecked( m_curDialog, R.id.robot_check, lp.isRobot );
        Utils.setChecked( m_curDialog, R.id.remote_check, ! lp.isLocal );
    }

    private void getPlayerSettings()
    {
        LocalPlayer lp = m_gi.players[m_whichPlayer];
        lp.name = Utils.getText( m_curDialog, R.id.player_name_edit );
        lp.password = Utils.getText( m_curDialog, R.id.password_edit );

        lp.isRobot = Utils.getChecked( m_curDialog, R.id.robot_check );
        lp.isLocal = !Utils.getChecked( m_curDialog, R.id.remote_check );
    }

    @Override
    public void onCreate( Bundle savedInstanceState )
    {
        super.onCreate(savedInstanceState);

        // 1.5 doesn't have SDK_INT.  So parse the string version.
        // int sdk_int = 0;
        // try {
        //     sdk_int = Integer.decode( android.os.Build.VERSION.SDK );
        // } catch ( Exception ex ) {}
        // m_canDoSMS = sdk_int >= android.os.Build.VERSION_CODES.DONUT;

        m_cp = CommonPrefs.get( this );

        Intent intent = getIntent();
        Uri uri = intent.getData();
        m_path = uri.getPath();
        if ( m_path.charAt(0) == '/' ) {
            m_path = m_path.substring( 1 );
        }

        setContentView(R.layout.game_config);

        int gamePtr = XwJNI.initJNI();
        m_giOrig = new CurGameInfo( this );
        GameUtils.loadMakeGame( this, gamePtr, m_giOrig, m_path );
        m_gameStarted = XwJNI.model_getNMoves( gamePtr ) > 0
            || XwJNI.comms_isConnected( gamePtr );
        m_giOrig.setInProgress( m_gameStarted );

        if ( m_gameStarted ) {
            m_gameLockedCheck = (CheckBox)findViewById( R.id.game_locked_check );
            m_gameLockedCheck.setVisibility( View.VISIBLE );
            m_gameLockedCheck.setChecked( true );
            m_gameLockedCheck.setOnClickListener( this );
            handleLockedChange();
        }

        int curSel = listAvailableDicts( m_giOrig.dictName );
        m_giOrig.dictLang = 
            DictLangCache.getLangCode( this, 
                                       GameUtils.dictList( this )[curSel] );
        m_gi = new CurGameInfo( m_giOrig );

        m_carOrig = new CommsAddrRec( this );
        if ( XwJNI.game_hasComms( gamePtr ) ) {
            XwJNI.comms_getAddr( gamePtr, m_carOrig );
        } else {
            String relayName = CommonPrefs.getDefaultRelayHost( this );
            int relayPort = CommonPrefs.getDefaultRelayPort( this );
            XwJNI.comms_getInitialAddr( m_carOrig, relayName, relayPort );
        }
        XwJNI.game_dispose( gamePtr );

        m_car = new CommsAddrRec( m_carOrig );

        m_notNetworkedGame = DeviceRole.SERVER_STANDALONE == m_gi.serverRole;

        if ( !m_notNetworkedGame ) {
            m_joinPublicCheck = 
                (CheckBox)findViewById(R.id.join_public_room_check);
            m_joinPublicCheck.setOnClickListener( this );
            m_joinPublicCheck.setChecked( m_car.ip_relay_seeksPublicRoom );
            Utils.setChecked( this, R.id.advertise_new_room_check, 
                              m_car.ip_relay_advertiseRoom );
            m_publicRoomsSet = 
                (LinearLayout)findViewById(R.id.public_rooms_set );
            m_privateRoomsSet = 
                (LinearLayout)findViewById(R.id.private_rooms_set );

            Utils.setText( this, R.id.room_edit, m_car.ip_relay_invite );
        
            m_roomChoose = (Spinner)findViewById( R.id.room_spinner );

            m_refreshRoomsButton = 
                (ImageButton)findViewById( R.id.refresh_button );
            m_refreshRoomsButton.setOnClickListener( this );

            adjustConnectStuff();
        }

        m_connectSet = findViewById(R.id.connect_set);

        m_addPlayerButton = (Button)findViewById(R.id.add_player);
        m_addPlayerButton.setOnClickListener( this );
        m_jugglePlayersButton = (Button)findViewById(R.id.juggle_players);
        m_jugglePlayersButton.setOnClickListener( this );
        m_playButton = (Button)findViewById( R.id.play_button );
        m_playButton.setOnClickListener( this );

        m_playerLayout = (LinearLayout)findViewById( R.id.player_list );
        loadPlayers();

        m_dictSpinner = (Spinner)findViewById( R.id.dict_spinner );
        configDictSpinner();

        m_phoniesSpinner = (Spinner)findViewById( R.id.phonies_spinner );
        m_phoniesSpinner.setSelection( m_gi.phoniesAction.ordinal() );

        Utils.setChecked( this, R.id.hints_allowed, !m_gi.hintsNotAllowed );
        Utils.setInt( this, R.id.timer_minutes_edit, 
                      m_gi.gameSeconds/60/m_gi.nPlayers );

        CheckBox check = (CheckBox)findViewById( R.id.use_timer );
        CompoundButton.OnCheckedChangeListener lstnr =
            new CompoundButton.OnCheckedChangeListener() {
                public void onCheckedChanged( CompoundButton buttonView, 
                                              boolean checked ) {
                    View view = findViewById( R.id.timer_set );
                    view.setVisibility( checked ? View.VISIBLE : View.GONE );
                }
            };
        check.setOnCheckedChangeListener( lstnr );
        Utils.setChecked( this, R.id.use_timer, m_gi.timerEnabled );

        Utils.setChecked( this, R.id.smart_robot, 0 < m_gi.robotSmartness );

        String fmt = getString( m_notNetworkedGame ?
                                R.string.title_game_configf
                                : R.string.title_gamenet_configf );
        setTitle( String.format( fmt, GameUtils.gameName( this, m_path ) ) );
    } // onCreate

    // DeleteCallback interface
    public void deleteCalled( int myPosition )
    {
        if ( m_gi.delete( myPosition ) ) {
            loadPlayers();
        }
    }

    // NoNameFound interface
    public void NoNameFound()
    {
        showDialog( NO_NAME_FOUND );
    }

    public void onClick( View view ) 
    {
        if ( m_addPlayerButton == view ) {
            int curIndex = m_gi.nPlayers;
            if ( curIndex < CurGameInfo.MAX_NUM_PLAYERS ) {
                m_gi.addPlayer(); // ups nPlayers
                loadPlayers();
            }
        } else if ( m_jugglePlayersButton == view ) {
            m_gi.juggle();
            loadPlayers();
        } else if ( m_joinPublicCheck == view ) {
            adjustConnectStuff();
        } else if ( m_gameLockedCheck == view ) {
            showNotAgainDlgThen( R.string.not_again_unlock, 
                                 R.string.key_notagain_unlock,
                                 new Runnable() {
                                     public void run() {
                                         handleLockedChange();
                                     }
                                 });
        } else if ( m_refreshRoomsButton == view ) {
            refreshNames();
        } else if ( m_playButton == view ) {
            // Launch BoardActivity for m_path, but ONLY IF user
            // confirms any changes required.  So we either launch
            // from here if there's no confirmation needed, or launch
            // a new dialog whose OK button does the same thing.
            saveChanges();
            if ( !m_gameStarted ) { // no confirm needed 
                applyChanges( true );
                launchGame();
            } else if ( m_giOrig.changesMatter(m_gi) 
                        || (! m_notNetworkedGame
                            && m_carOrig.changesMatter(m_car) ) ) {
                showDialog( CONFIRM_CHANGE_PLAY );
            } else {
                applyChanges( false );
                launchGame();
            }

        } else {
            Utils.logf( ""unknown v: "" + view.toString() );
        }
    } // onClick

    @Override
    public boolean onKeyDown( int keyCode, KeyEvent event )
    {
        boolean consumed = false;
        if ( keyCode == KeyEvent.KEYCODE_BACK ) {
            saveChanges();
            if ( !m_gameStarted ) { // no confirm needed 
                applyChanges( true );
            } else if ( m_giOrig.changesMatter(m_gi) 
                        || (! m_notNetworkedGame
                            && m_carOrig.changesMatter(m_car) ) ) {
                showDialog( CONFIRM_CHANGE );
                consumed = true; // don't dismiss activity yet!
            } else {
                applyChanges( false );
            }
        }

        return consumed || super.onKeyDown( keyCode, event );
    }

    @Override
    protected void onResume()
    {
        configDictSpinner();
        super.onResume();
    }

    private void loadPlayers()
    {
        m_playerLayout.removeAllViews();

        String[] names = m_gi.visibleNames( this );
        // only enable delete if one will remain (or two if networked)
        boolean canDelete = names.length > 2
            || (m_notNetworkedGame && names.length > 1);
        LayoutInflater factory = LayoutInflater.from(this);
        for ( int ii = 0; ii < names.length; ++ii ) {

            final XWListItem view
                = (XWListItem)factory.inflate( R.layout.list_item, null );
            view.setPosition( ii );
            view.setText( names[ii] );
            view.setGravity( Gravity.CENTER );
            if ( canDelete ) {
                view.setDeleteCallback( this );
            }

            view.setOnClickListener( new View.OnClickListener() {
                    @Override
                    public void onClick( View view ) {
                        m_whichPlayer = ((XWListItem)view).getPosition();
                        showDialog( PLAYER_EDIT );
                    }
                } );
            m_playerLayout.addView( view );
            view.setEnabled( !m_isLocked );

            View divider = factory.inflate( R.layout.divider_view, null );
            divider.setVisibility( View.VISIBLE );
            m_playerLayout.addView( divider );
        }

        m_addPlayerButton
            .setVisibility( names.length >= CurGameInfo.MAX_NUM_PLAYERS?
                            View.GONE : View.VISIBLE );
        m_jugglePlayersButton
            .setVisibility( names.length <= 1 ?
                            View.GONE : View.VISIBLE );
        m_connectSet.setVisibility( m_notNetworkedGame?
                                    View.GONE : View.VISIBLE );

        if ( ! m_notNetworkedGame
             && ((0 == m_gi.remoteCount() )
                 || (m_gi.nPlayers == m_gi.remoteCount()) ) ) {
            showDialog( FORCE_REMOTE );
        }
        adjustPlayersLabel();
    } // loadPlayers

    private int listAvailableDicts( String curDict )
    {
        int curSel = -1;

        String[] list = GameUtils.dictList( this );

        m_browsePosition = list.length;
        m_dictItems = new String[m_browsePosition+1];
        m_dictItems[m_browsePosition] = getString( R.string.download_dicts );
        m_dicts = new String[m_browsePosition];
        
        for ( int ii = 0; ii < m_browsePosition; ++ii ) {
            String dict = list[ii];
            m_dicts[ii] = dict;
            m_dictItems[ii] = DictLangCache.annotatedDictName( this, dict );
            if ( dict.equals( curDict ) ) {
                curSel = ii;
            }
        }

        return curSel;
    }

    private void configDictSpinner()
    {
        int curSel = listAvailableDicts( m_gi.dictName );

        ArrayAdapter<String> adapter = 
            new ArrayAdapter<String>( this,
                                      android.R.layout.simple_spinner_item,
                                      m_dictItems );
        int resID = android.R.layout.simple_spinner_dropdown_item;
        adapter.setDropDownViewResource( resID );
        m_dictSpinner.setAdapter( adapter );
        if ( curSel >= 0 ) {
            m_dictSpinner.setSelection( curSel );
        } 

        m_dictSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parentView, 
                                       View selectedItemView, 
                                       int position, long id ) {
                if ( position == m_browsePosition ) {
                    startActivity( Utils.mkDownloadActivity(GameConfig.this) );
                } else {
                    m_gi.dictName = m_dicts[position];
                    Utils.logf( ""assigned dictName: "" + m_gi.dictName );
                    m_gi.dictLang = DictLangCache.getLangCode( GameConfig.this, 
                                                               m_gi.dictName );
                }
            }

            @Override
            public void onNothingSelected(AdapterView<?> parentView) {}
            });
    }

    // private void configConnectSpinner()
    // {
    //     m_connectSpinner = (Spinner)findViewById( R.id.connect_spinner );
    //     m_connStrings = makeXportStrings();
    //     ArrayAdapter<String> adapter = 
    //         new ArrayAdapter<String>( this,
    //                                   android.R.layout.simple_spinner_item,
    //                                   m_connStrings );
    //     adapter.setDropDownViewResource( android.R.layout
    //                                      .simple_spinner_dropdown_item );
    //     m_connectSpinner.setAdapter( adapter );
    //     m_connectSpinner.setSelection( connTypeToPos( m_car.conType ) );
    //     AdapterView.OnItemSelectedListener
    //         lstnr = new AdapterView.OnItemSelectedListener() {
    //                 @Override
    //                 public void onItemSelected(AdapterView<?> parentView, 
    //                                            View selectedItemView, 
    //                                            int position, 
    //                                            long id ) 
    //                 {
    //                     String fmt = getString( R.string.configure_rolef );
    //                     m_configureButton
    //                         .setText( String.format( fmt, 
    //                                                  m_connStrings[position] ));
    //                 }

    //                 @Override
    //                 public void onNothingSelected(AdapterView<?> parentView) 
    //                 {
    //                 }
    //             };
    //     m_connectSpinner.setOnItemSelectedListener( lstnr );

    // } // configConnectSpinner

    private void adjustPlayersLabel()
    {
        Utils.logf( ""adjustPlayersLabel()"" );
        String label;
        if ( m_notNetworkedGame ) {
            label = getString( R.string.players_label_standalone );
        } else {
            String fmt = getString( R.string.players_label_host );
            int remoteCount = m_gi.remoteCount();
            label = String.format( fmt, m_gi.nPlayers - remoteCount, 
                                   remoteCount );
        }
        ((TextView)findViewById( R.id.players_label )).setText( label );
    }

    private void adjustConnectStuff()
    {
        if ( m_joinPublicCheck.isChecked() ) {
            refreshNames();
            m_privateRoomsSet.setVisibility( View.GONE );
            m_publicRoomsSet.setVisibility( View.VISIBLE );

            // // make the room spinner match the saved value if present
            // String invite = m_car.ip_relay_invite;
            // ArrayAdapter<String> adapter = 
            //     (ArrayAdapter<String>)m_roomChoose.getAdapter();
            // if ( null != adapter ) {
            //     for ( int ii = 0; ii < adapter.getCount(); ++ii ) {
            //         if ( adapter.getItem(ii).equals( invite ) ) {
            //             m_roomChoose.setSelection( ii );
            //             break;
            //         }
            //     }
            // }

        } else {
            m_privateRoomsSet.setVisibility( View.VISIBLE );
            m_publicRoomsSet.setVisibility( View.GONE );
        }
    }

    // User's toggling whether everything's locked.  That should mean
    // we enable/disable a bunch of widgits.  And if we're going from
    // unlocked to locked we need to confirm that everything can be
    // reverted.
    private void handleLockedChange()
    {
        boolean locking = m_gameLockedCheck.isChecked();
        m_isLocked = locking;
        for ( int id : s_disabledWhenLocked ) {
            View view = findViewById( id );
            view.setEnabled( !m_isLocked );
        }
        if ( null != m_playerLayout ) {
            for ( int ii = m_playerLayout.getChildCount()-1; ii >= 0; --ii ) {
                View view = m_playerLayout.getChildAt( ii );
                view.setEnabled( !m_isLocked );
            }
        }
    }
    
    private int connTypeToPos( CommsAddrRec.CommsConnType typ )
    {
        switch( typ ) {
        case COMMS_CONN_RELAY:
            return 0;
        case COMMS_CONN_SMS:
            return 1;
        case COMMS_CONN_BT:
            return 2;
        }
        return -1;
    }

    private int layoutForDlg( int id ) 
    {
        switch( id ) {
        // case ROLE_EDIT_RELAY:
        //     return R.layout.role_edit_relay;
        // case ROLE_EDIT_SMS:
        //     return R.layout.role_edit_sms;
        // case ROLE_EDIT_BT:
        //     return R.layout.role_edit_bt;
        case FORCE_REMOTE:
            return R.layout.force_remote;
        }
        Assert.fail();
        return 0;
    }

    private int titleForDlg( int id ) 
    {
        switch( id ) {
        // case ROLE_EDIT_RELAY:
        //     return R.string.tab_relay;
        // case ROLE_EDIT_SMS:
        //     return R.string.tab_sms;
        // case ROLE_EDIT_BT:
        //     return R.string.tab_bluetooth;
        }
        Assert.fail();
        return -1;
    }

    private String[] makeXportStrings()
    {
        ArrayList<String> strings = new ArrayList<String>();
        ArrayList<CommsAddrRec.CommsConnType> types
            = new ArrayList<CommsAddrRec.CommsConnType>();

        strings.add( getString(R.string.tab_relay) );
        types.add( CommsAddrRec.CommsConnType.COMMS_CONN_RELAY );

        if ( m_canDoSMS ) {
            strings.add( getString(R.string.tab_sms) );
            types.add( CommsAddrRec.CommsConnType.COMMS_CONN_SMS );
        }
        if ( m_canDoBT ) {
            strings.add( getString(R.string.tab_bluetooth) );
            types.add( CommsAddrRec.CommsConnType.COMMS_CONN_BT );
        }
        m_types = types.toArray( new CommsAddrRec.CommsConnType[types.size()] );
        return strings.toArray( new String[strings.size()] );
    }

    private void saveChanges()
    {
        m_gi.hintsNotAllowed = !Utils.getChecked( this, R.id.hints_allowed );
        m_gi.timerEnabled = Utils.getChecked(  this, R.id.use_timer );
        m_gi.gameSeconds = 60 * m_gi.nPlayers *
            Utils.getInt(  this, R.id.timer_minutes_edit );
        m_gi.robotSmartness
            = Utils.getChecked( this, R.id.smart_robot ) ? 1 : 0;

        int position = m_phoniesSpinner.getSelectedItemPosition();
        m_gi.phoniesAction = CurGameInfo.XWPhoniesChoice.values()[position];

        if ( !m_notNetworkedGame ) {
            m_car.ip_relay_seeksPublicRoom = m_joinPublicCheck.isChecked();
            Utils.logf( ""ip_relay_seeksPublicRoom: %s"", 
                        m_car.ip_relay_seeksPublicRoom?""true"":""false"" );
            m_car.ip_relay_advertiseRoom = 
                Utils.getChecked( this, R.id.advertise_new_room_check );
            if ( m_car.ip_relay_seeksPublicRoom ) {
                SpinnerAdapter adapter = m_roomChoose.getAdapter();
                if ( null != adapter ) {
                    int pos = m_roomChoose.getSelectedItemPosition();
                    if ( pos >= 0 && pos < adapter.getCount() ) {
                        m_car.ip_relay_invite = (String)adapter.getItem(pos);
                    }
                }
            } else {
                m_car.ip_relay_invite = 
                    Utils.getText( this, R.id.room_edit ).trim();
            }
        }

        // position = m_connectSpinner.getSelectedItemPosition();
        // m_car.conType = m_types[ position ];

        m_car.conType = m_notNetworkedGame
            ? CommsAddrRec.CommsConnType.COMMS_CONN_NONE
            : CommsAddrRec.CommsConnType.COMMS_CONN_RELAY;
    } // saveChanges

    private void applyChanges( boolean forceNew )
    {
        GameUtils.applyChanges( this, m_gi, m_car, m_path, forceNew );
    }

    private void launchGame()
    {
        if ( m_notNetworkedGame || m_car.ip_relay_invite.length() > 0 ) {
            GameUtils.launchGame( this, m_path );
        } else {
            showOKOnlyDialog( R.string.no_empty_rooms );            
        }
    }

    private void refreshNames()
    {
        new RefreshNamesTask( this, this, m_gi.dictLang, 
                              m_gi.nPlayers, m_roomChoose ).execute();
    }

}
",True,6,28,0,0,4,12,0,12,L3
27,org.eehouse.android.xw4.StatusReceiver.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

public class StatusReceiver extends BroadcastReceiver {

    @Override
    public void onReceive( Context context, Intent intent ) 
    {
        Utils.logf( ""StatusReceiver::onReceive called: "" + intent.toString() );
    }

}
",False,2,21,0,0,5,9,0,1,L3
28,org.eehouse.android.xw4.RefreshNamesTask.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.ProgressDialog;
import android.os.AsyncTask;
import android.content.Context;
import android.widget.ArrayAdapter;
import android.widget.Spinner;
import java.io.InputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.util.ArrayList;
import java.net.Socket;

public class RefreshNamesTask extends AsyncTask<Void, Void, String[]> {

    public interface NoNameFound {
        public void NoNameFound();
    };

    private Context m_context;
    private Spinner m_resultSpinner;
    private int m_lang;
    private int m_nInGame;
    private ProgressDialog m_progress;
    private NoNameFound m_nnf;

    public RefreshNamesTask( Context context, NoNameFound nnf,
                             int lang, int nInGame, 
                             Spinner getsResults )
    {
        super();
        m_context = context;
        m_nnf = nnf;
        m_resultSpinner = getsResults;
        m_lang = lang;
        m_nInGame = nInGame;

        String fmt = context.getString( R.string.public_names_progress );
        String msg = String.format( fmt, nInGame, 
                                    DictLangCache.getLangName(context,lang) );

        m_progress = ProgressDialog.show( context, msg, null, true, 
                                          true );
    }

    @Override
    protected String[] doInBackground( Void...unused ) 
    {
        ArrayList<String> names = new ArrayList<String>();
        Utils.logf( ""doInBackground()"" );

        try {
            Socket socket = NetUtils.MakeProxySocket( m_context, 15000 );
            if ( null != socket ) {
                DataOutputStream outStream = 
                    new DataOutputStream( socket.getOutputStream() );
        
                outStream.writeShort( 4 );                // total packet length
                outStream.writeByte( NetUtils.PROTOCOL_VERSION );
                outStream.writeByte( NetUtils.PRX_PUB_ROOMS );
                outStream.writeByte( (byte)m_lang );
                outStream.writeByte( (byte)m_nInGame );
                outStream.flush();

                // read result -- will block
                DataInputStream dis = 
                    new DataInputStream(socket.getInputStream());
                short len = dis.readShort();
                short nRooms = dis.readShort();
                Utils.logf( ""%s: got %d rooms"", ""doInBackground"", nRooms );

                // Can't figure out how to read a null-terminated string
                // from DataInputStream so parse it myself.
                byte[] bytes = new byte[len];
                dis.read( bytes );

                int index = -1;
                for ( int ii = 0; ii < nRooms; ++ii ) {
                    int lastIndex = ++index; // skip the null
                    while ( bytes[index] != '\n' ) {
                        ++index;
                    }
                    String name = new String( bytes, lastIndex, index - lastIndex );
                    Utils.logf( ""got public room name: %s"", name );
                    int indx = name.lastIndexOf( ""/"" );
                    indx = name.lastIndexOf( ""/"", indx-1 );
                    names.add( name.substring(0, indx ) );
                }
            }
        } catch ( java.io.IOException ioe ) {
            Utils.logf( ""%s"", ioe.toString() );
        }
        Utils.logf( ""doInBackground() returning"" );
        return names.toArray( new String[names.size()] );        
    }

     // protected void onProgressUpdate(Integer... progress) {
     //     setProgressPercent(progress[0]);
     // }

    @Override
     protected void onPostExecute( String[] result )
     {
         Utils.logf( ""onPostExecute()"" );
         ArrayAdapter<String> adapter = 
             new ArrayAdapter<String>( m_context,
                                       android.R.layout.simple_spinner_item,
                                       result );
         int resID = android.R.layout.simple_spinner_dropdown_item;
         adapter.setDropDownViewResource( resID );
         m_resultSpinner.setAdapter( adapter );

         m_progress.cancel();

         if ( result.length == 0 ) {
             m_nnf.NoNameFound();
         }

         Utils.logf( ""onPostExecute() done"" );
     }
}
",True,48,22,1,1,4,8,1,3,L3
29,org.eehouse.android.xw4.BoardView.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.view.View;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.Bitmap;
import android.content.Context;
import android.util.AttributeSet;
import org.eehouse.android.xw4.jni.*;
import android.view.MotionEvent;
import android.graphics.drawable.Drawable;
import android.content.res.Resources;
import android.graphics.Paint.FontMetricsInt;
import android.os.Handler;
import java.nio.IntBuffer;

import junit.framework.Assert;

public class BoardView extends View implements DrawCtx, BoardHandler,
                                               SyncedDraw {
    private static final int k_miniTextSize = 24;
    private static final int k_miniPaddingH = 2;
    private static final int k_miniPaddingV = 2;
    private static final float MIN_FONT_DIPS = 14.0f;

    private Context m_context;
    private Paint m_drawPaint;
    private Paint m_fillPaint;
    private Paint m_strokePaint;
    private int m_defaultFontHt;
    private int m_mediumFontHt;
    private Paint m_tileStrokePaint;
    private int m_jniGamePtr;
    private CurGameInfo m_gi;
    private int m_layoutWidth;
    private int m_layoutHeight;
    private Bitmap m_bitmap;    // the board
    private Canvas m_canvas;    // owns the bitmap
    private int m_trayOwner;
    private Rect m_valRect;
    private Rect m_letterRect;
    private Drawable m_rightArrow;
    private Drawable m_downArrow;
    private Drawable m_origin;
    private int m_left, m_top;
    private JNIThread m_jniThread;
    private String[][] m_scores;
    private String[] m_dictChars;
    private Rect m_boundsScratch;
    private String m_remText;
    private int m_dictPtr = 0;
    private int m_lastSecsLeft;
    private Handler m_viewHandler;

    // FontDims: exists to translate space available to the largest
    // font we can draw within that space taking advantage of our use
    // being limited to a known small subset of glyphs.  We need two
    // numbers from this: the textHeight to pass to Paint.setTextSize,
    // and the descent to use when drawing.  Both can be calculated
    // proportionally.  We know the ht we passed to Paint to get the
    // height we've now measured; that gives a percent to multiply any
    // future wantHt by.  Ditto for the descent
    private class FontDims {
        FontDims( float askedHt, int topRow, int bottomRow, float width ) {
            // Utils.logf( ""FontDims(): askedHt="" + askedHt );
            // Utils.logf( ""FontDims(): topRow="" + topRow );
            // Utils.logf( ""FontDims(): bottomRow="" + bottomRow );
            // Utils.logf( ""FontDims(): width="" + width );
            float gotHt = bottomRow - topRow + 1;
            m_htProportion = gotHt / askedHt;
            Assert.assertTrue( (bottomRow+1) >= askedHt );
            float descent = (bottomRow+1) - askedHt;
            Utils.logf( ""descent: "" + descent );
            m_descentProportion = descent / askedHt;
            Assert.assertTrue( m_descentProportion >= 0 );
            m_widthProportion = width / askedHt;
            // Utils.logf( ""m_htProportion: "" + m_htProportion );
            // Utils.logf( ""m_descentProportion: "" + m_descentProportion );
        }
        private float m_htProportion;
        private float m_descentProportion;
        private float m_widthProportion;
        int heightFor( int ht ) { return (int)(ht / m_htProportion); }
        int descentFor( int ht ) { return (int)(ht * m_descentProportion); }
        int widthFor( int width ) { return (int)(width / m_widthProportion); }
    }
    FontDims m_fontDims;

    private static final int BLACK = 0xFF000000;
    private static final int WHITE = 0xFFFFFFFF;
    private static final int GREY = 0xFF7F7F7F;
    private int[] m_bonusColors;
    private int[] m_playerColors;
    private int[] m_otherColors;
    private String[] m_bonusSummaries;

    // called when inflating xml
    public BoardView( Context context, AttributeSet attrs ) 
    {
        super( context, attrs );
        init( context );
    }

    public boolean onTouchEvent( MotionEvent event ) 
    {
        int action = event.getAction();
        int xx = (int)event.getX() - m_left;
        int yy = (int)event.getY() - m_top;
        
        switch ( action ) {
        case MotionEvent.ACTION_DOWN:
            m_jniThread.handle( JNIThread.JNICmd.CMD_PEN_DOWN, xx, yy );
            break;
        case MotionEvent.ACTION_MOVE:
            m_jniThread.handle( JNIThread.JNICmd.CMD_PEN_MOVE, xx, yy );
            break;
        case MotionEvent.ACTION_UP:
            m_jniThread.handle( JNIThread.JNICmd.CMD_PEN_UP, xx, yy );
            break;
        default:
            Utils.logf( ""unknown action: "" + action );
            Utils.logf( event.toString() );
        }

        return true;             // required to get subsequent events
    }

    // This will be called from the UI thread
    @Override
    protected void onDraw( Canvas canvas ) 
    {
        synchronized( this ) {
            if ( layoutBoardOnce() ) {
                canvas.drawBitmap( m_bitmap, m_left, m_top, m_drawPaint );
            }
        }
    }

    private void init( Context context )
    {
        m_context = context;
        final float scale = getResources().getDisplayMetrics().density;
        m_defaultFontHt = (int)(MIN_FONT_DIPS * scale + 0.5f);
        m_mediumFontHt = m_defaultFontHt * 3 / 2;

        m_drawPaint = new Paint();
        m_fillPaint = new Paint( Paint.ANTI_ALIAS_FLAG );
        m_strokePaint = new Paint();
        m_strokePaint.setStyle( Paint.Style.STROKE );
        m_tileStrokePaint = new Paint();
        m_tileStrokePaint.setStyle( Paint.Style.STROKE );
        Utils.logf( ""stroke starts at "" + m_tileStrokePaint.getStrokeWidth() );
        float curWidth = m_tileStrokePaint.getStrokeWidth();
        curWidth *= 2;
        if ( curWidth < 2 ) {
            curWidth = 2;
        }
        m_tileStrokePaint.setStrokeWidth( curWidth );

        Resources res = getResources();
        m_rightArrow = res.getDrawable( R.drawable.rightarrow );
        m_downArrow = res.getDrawable( R.drawable.downarrow );
        m_origin = res.getDrawable( R.drawable.origin );

        m_boundsScratch = new Rect();

        CommonPrefs prefs = CommonPrefs.get(context);
        m_playerColors = prefs.playerColors;
        m_bonusColors = prefs.bonusColors;
        m_otherColors = prefs.otherColors;

        m_bonusSummaries = new String[5];
        int[] ids = { R.string.bonus_l2x_summary,
                      R.string.bonus_w2x_summary ,
                      R.string.bonus_l3x_summary,
                      R.string.bonus_w3x_summary };
        for ( int ii = 0; ii < ids.length; ++ii ) {
            m_bonusSummaries[ ii+1 ] = getResources().getString( ids[ii] );
        }

        m_viewHandler = new Handler();
    }

    private BoardDims figureBoardDims( int width, int height,
                                       CurGameInfo gi )
    {
        BoardDims result = new BoardDims();
        result.width = width;
        result.left = 0;

        int nCells = gi.boardSize;
        int cellSize = width / nCells;
        int maxCellSize = 3 * m_defaultFontHt;
        if ( cellSize > maxCellSize ) {
            cellSize = maxCellSize;

            int boardWidth = nCells * cellSize;
            result.left = (width - boardWidth) / 2;
            result.width = boardWidth;
        }
        result.maxCellSize = maxCellSize;

        result.trayHt = cellSize * 3;
        result.scoreHt = 2 * m_defaultFontHt;
        int wantHt = result.trayHt + result.scoreHt + (cellSize * nCells);
        int nToScroll = 0;
        if ( wantHt <= height ) {
            result.top = (height - wantHt) / 2;
        } else {
            int minTray = 3 * m_defaultFontHt;
            nToScroll = 
                nCells - ((height - minTray - result.scoreHt) / cellSize);
            result.trayHt = 
                height - result.scoreHt - (cellSize * (nCells-nToScroll));
            result.top = 0;
        }

        result.boardHt = cellSize * (nCells-nToScroll);
        result.trayTop = result.scoreHt + result.boardHt;
        result.height = result.scoreHt + result.boardHt + result.trayHt;
        result.cellSize = cellSize;

        if ( gi.timerEnabled ) {
            Paint paint = new Paint();
            paint.setTextSize( m_mediumFontHt );
            paint.getTextBounds( ""-00:00"", 0, 6, m_boundsScratch );
            result.timerWidth = m_boundsScratch.width();
        }

        return result;
    } // figureBoardDims

    private boolean layoutBoardOnce() 
    {
        final int width = getWidth();
        final int height = getHeight();
        boolean layoutDone = width == m_layoutWidth && height == m_layoutHeight;
        if ( layoutDone ) {
            // nothing to do
        } else if ( null == m_gi ) {
            // nothing to do either
        } else {
            m_layoutWidth = width;
            m_layoutHeight = height;
            m_fontDims = null; // force recalc of font
            m_letterRect = null;
            m_valRect = null;

            BoardDims dims = figureBoardDims( width, height, m_gi );
            m_left = dims.left;
            m_top = dims.top;
            
            m_bitmap = Bitmap.createBitmap( 1 + dims.width,
                                            1 + dims.height,
                                            Bitmap.Config.ARGB_8888 );
            m_canvas = new Canvas( m_bitmap );

            // need to synchronize??
            m_jniThread.handle( JNIThread.JNICmd.CMD_LAYOUT, dims );
            m_jniThread.handle( JNIThread.JNICmd.CMD_DRAW );
            layoutDone = true;
        }
        return layoutDone;
    } // layoutBoardOnce

    // BoardHandler interface implementation
    public void startHandling( JNIThread thread, int gamePtr, CurGameInfo gi ) 
    {
        m_jniThread = thread;
        m_jniGamePtr = gamePtr;
        m_gi = gi;
        m_layoutWidth = 0;
        m_layoutHeight = 0;
    }

    // SyncedDraw interface implementation
    public void doJNIDraw()
    {
        boolean drew;
        synchronized( this ) {
            drew = XwJNI.board_draw( m_jniGamePtr );
        }
        if ( !drew ) {
            Utils.logf( ""draw not complete"" );
        }
    }

    public void doIconDraw( int resID, final Rect rect )
    {
        synchronized( this ) {
            if ( null != m_canvas ) {
                if ( 0 == resID ) {
                    clearToBack( rect );
                } else {
                    Drawable icon = getResources().getDrawable( resID );
                    icon.setBounds( rect );
                    icon.draw( m_canvas );
                }
            }
        }
    }

    // DrawCtxt interface implementation
    public boolean scoreBegin( Rect rect, int numPlayers, int[] scores, 
                               int remCount, int dfs )
    {
        clearToBack( rect );
        m_canvas.save( Canvas.CLIP_SAVE_FLAG );
        m_canvas.clipRect(rect);
        m_scores = new String[numPlayers][];
        return true;
    }

    public void measureRemText( Rect r, int nTilesLeft, int[] width, 
                                int[] height ) 
    {
        if ( nTilesLeft > 0 ) {
            // should cache a formatter
            m_remText = String.format( ""%d"", nTilesLeft );
            m_fillPaint.setTextSize( m_mediumFontHt );
            m_fillPaint.getTextBounds( m_remText, 0, m_remText.length(), 
                                       m_boundsScratch );

            int minWidth = m_boundsScratch.width();
            if ( minWidth < 20 ) {
                minWidth = 20; // it's a button; make it bigger
            }
            width[0] = minWidth;
            height[0] = m_boundsScratch.height();
        } else {
            width[0] = height[0] = 0;
        }
    }

    public void drawRemText( Rect rInner, Rect rOuter, int nTilesLeft, 
                             boolean focussed )
    {
        int indx = focussed ? CommonPrefs.COLOR_FOCUS
            : CommonPrefs.COLOR_TILE_BACK;
        fillRect( rOuter, m_otherColors[indx] );

        m_fillPaint.setColor( BLACK );
        drawCentered( m_remText, rInner, null );
    }

    public void measureScoreText( Rect r, DrawScoreInfo dsi, 
                                  int[] width, int[] height )
    {
        String[] scoreInfo = new String[dsi.isTurn?1:2];
        int indx = 0;
        StringBuffer sb = new StringBuffer();

        // If it's my turn I get one line.  Otherwise squeeze into
        // two.

        if ( dsi.isTurn ) {
            sb.append( dsi.name );
            sb.append( "":"" );
        } else {
            scoreInfo[indx++] = dsi.name;
        }
        sb.append( dsi.totalScore );
        if ( dsi.nTilesLeft >= 0 ) {
            sb.append( "":"" );
            sb.append( dsi.nTilesLeft );
        }
        scoreInfo[indx] = sb.toString();
        m_scores[dsi.playerNum] = scoreInfo;

        m_fillPaint.setTextSize( dsi.isTurn? r.height() : m_defaultFontHt );

        int needWidth = 0;
        for ( int ii = 0; ii < scoreInfo.length; ++ii ) {
            m_fillPaint.getTextBounds( scoreInfo[ii], 0, scoreInfo[ii].length(), 
                                       m_boundsScratch );
            if ( needWidth < m_boundsScratch.width() ) {
                needWidth = m_boundsScratch.width();
            }
        }
        if ( needWidth > r.width() ) {
            needWidth = r.width();
        }
        width[0] = needWidth;

        height[0] = r.height();
    }

    public void score_drawPlayer( Rect rInner, Rect rOuter, DrawScoreInfo dsi )
    {
        if ( 0 != (dsi.flags & CELL_ISCURSOR) ) {
            fillRect( rOuter, m_otherColors[CommonPrefs.COLOR_FOCUS] );
        }
        String[] texts = m_scores[dsi.playerNum];
        m_fillPaint.setColor( m_playerColors[dsi.playerNum] );

        Rect rect = new Rect( rOuter );
        int height = rect.height() / texts.length;
        rect.bottom = rect.top + height;
        for ( String text : texts ) {
            drawCentered( text, rect, null );
            rect.offset( 0, height );
        }
    }

    public void drawTimer( Rect rect, int player, int secondsLeft )
    {
        if ( null != m_canvas && m_lastSecsLeft != secondsLeft ) {
            m_lastSecsLeft = secondsLeft;

            String negSign = secondsLeft < 0? ""-"":"""";
            secondsLeft = Math.abs( secondsLeft );
            String time = String.format( ""%s%d:%02d"", negSign, secondsLeft/60, 
                                         secondsLeft%60 );

            clearToBack( rect );
            m_fillPaint.setColor( m_playerColors[player] );

            Rect shorter = new Rect( rect );
            shorter.inset( 0, shorter.height() / 5 );
            drawCentered( time, shorter, null );

            m_jniThread.handle( JNIThread.JNICmd.CMD_DRAW );
        }
    }

    public boolean drawCell( final Rect rect, String text, int tile, int owner, 
                             int bonus, int hintAtts, final int flags ) 
    {
        int backColor;
        boolean empty = 0 != (flags & (CELL_DRAGSRC|CELL_ISEMPTY));
        boolean pending = 0 != (flags & CELL_HIGHLIGHT);
        String bonusStr = null;

        figureFontDims();

        if ( owner < 0 ) {
            owner = 0;
        }
        int foreColor = m_playerColors[owner];

        if ( 0 != (flags & CELL_ISCURSOR) ) {
            backColor = m_otherColors[CommonPrefs.COLOR_FOCUS];
        } else if ( empty ) {
            if ( 0 == bonus ) {
                backColor = m_otherColors[CommonPrefs.COLOR_BKGND];
            } else {
                backColor = m_bonusColors[bonus];
                if ( CommonPrefs.getShowBonusSumms(m_context) ) {
                    bonusStr = m_bonusSummaries[bonus];
                }
            }
        } else if ( pending ) {
            backColor = BLACK;
            foreColor = WHITE;
        } else {
            backColor = m_otherColors[CommonPrefs.COLOR_TILE_BACK];
        }

        fillRect( rect, backColor );

        if ( empty ) {
            if ( (CELL_ISSTAR & flags) != 0 ) {
                m_origin.setBounds( rect );
                m_origin.draw( m_canvas );
            } else if ( null != bonusStr ) {
                m_fillPaint.setColor( GREY );
                Rect brect = new Rect( rect );
                brect.inset( 0, (brect.height() - m_defaultFontHt)/2 );
                drawCentered( bonusStr, brect, m_fontDims );
            }
        } else {
            m_fillPaint.setColor( foreColor );
            drawCentered( text, rect, m_fontDims );
        }

        if ( (CELL_ISBLANK & flags) != 0 ) {
            markBlank( rect, pending );
        }
        // frame the cell
        m_canvas.drawRect( rect, m_strokePaint );

        drawCrosshairs( rect, flags );
        
        return true;
    } // drawCell

    public void drawBoardArrow( Rect rect, int bonus, boolean vert, 
                                int hintAtts, int flags )
    {
        rect.inset( 2, 2 );
        Drawable arrow = vert? m_downArrow : m_rightArrow;
        arrow.setBounds( rect );
        arrow.draw( m_canvas );
    }

    public boolean trayBegin ( Rect rect, int owner, int dfs ) 
    {
        m_trayOwner = owner;
        return true;
    }

    public void drawTile( Rect rect, String text, int val, int flags ) 
    {
        drawTileImpl( rect, text, val, flags, true );
    }

    public void drawTileMidDrag( Rect rect, String text, int val, int owner, 
                                 int flags ) 
    {
        drawTileImpl( rect, text, val, flags, false );
    }

    public void drawTileBack( Rect rect, int flags ) 
    {
        drawTileImpl( rect, ""?"", -1, flags, true );
    }

    public void drawTrayDivider( Rect rect, int flags ) 
    {
        boolean isCursor = 0 != (flags & CELL_ISCURSOR);
        boolean selected = 0 != (flags & CELL_HIGHLIGHT);

        int backColor = isCursor? m_otherColors[CommonPrefs.COLOR_FOCUS]:WHITE;
        rect.inset( 0, 1 );
        fillRect( rect, backColor );

        rect.inset( rect.width()/4, 0 );
        if ( selected ) {
            m_canvas.drawRect( rect, m_strokePaint );
        } else {
            fillRect( rect, BLACK );
        }
    }

    public void score_pendingScore( Rect rect, int score, int playerNum, 
                                    int flags ) 
    {
        String text = score >= 0? String.format( ""%d"", score ) : ""??"";
        ++rect.top;
        fillRect( rect, (0 == (flags & CELL_ISCURSOR)) 
                  ? WHITE : m_otherColors[CommonPrefs.COLOR_FOCUS] );
        m_fillPaint.setColor( m_playerColors[playerNum] );

        rect.bottom -= rect.height() / 2;
        drawCentered( text, rect, null );

        rect.offset( 0, rect.height() );
        drawCentered( getResources().getString( R.string.pts ), rect, null );
    }

    public String getMiniWText ( int textHint )
    {
        int id = 0;
        switch( textHint ) {
        case BONUS_DOUBLE_LETTER:
            id = R.string.bonus_l2x;
            break;
        case BONUS_DOUBLE_WORD:
            id = R.string.bonus_w2x;
            break;
        case BONUS_TRIPLE_LETTER:
            id = R.string.bonus_l3x;
            break;
        case BONUS_TRIPLE_WORD:
            id = R.string.bonus_w3x;
            break;
        case INTRADE_MW_TEXT:
            id = R.string.trading_text;
            break;
        default:
            Assert.fail();
        }
        return getResources().getString( id );
    }

    public void measureMiniWText( String str, int[] width, int[] height )
    {
        m_fillPaint.setTextSize( k_miniTextSize );
        FontMetricsInt fmi = m_fillPaint.getFontMetricsInt();
        int lineHeight = -fmi.top + fmi.leading;
        
        String[] lines = str.split(""\n"");
        height[0] = (lines.length * lineHeight) + (2 * k_miniPaddingV);

        int maxWidth = 0;
        for ( String line : lines ) {
            m_fillPaint.getTextBounds( line, 0, line.length(), m_boundsScratch );
            int thisWidth = m_boundsScratch.width();
            if ( maxWidth < thisWidth ) {
                maxWidth = thisWidth;
            }
        }
        width[0] = maxWidth + (k_miniPaddingH * 2);
    }

    public void drawMiniWindow( String text, Rect rect )
    {
        clearToBack( rect );

        m_fillPaint.setTextSize( k_miniTextSize );
        m_fillPaint.setTextAlign( Paint.Align.CENTER );
        m_fillPaint.setColor( BLACK );

        String[] lines = text.split(""\n"");
        int lineHt = rect.height() / lines.length;
        int bottom = rect.top + lineHt
            - m_fillPaint.getFontMetricsInt().descent;
        int center = rect.left + (rect.width() / 2);

        for ( String line : lines ) {
            m_canvas.drawText( line, center, bottom, m_fillPaint );
            bottom += lineHt;
        }

        m_canvas.drawRect( rect, m_strokePaint );

        // Unlike other draw methods, this one is usually called from
        // outside board_draw and so doesn't benefit from the canvas
        // getting moved to the board.  Set that up manually.  Sending
        // DRAW cmd as I used to do draws *everything* and may well
        // overwrite the miniwindow.
        m_viewHandler.post( new Runnable() {
                public void run() {
                    BoardView.this.invalidate();
                }
            } );
    }

    public void objFinished( /*BoardObjectType*/int typ, Rect rect, int dfs )
    {
        if ( DrawCtx.OBJ_SCORE == typ ) {
            m_canvas.restoreToCount(1); // in case new canvas...
        }
    }

    public void dictChanged( int dictPtr )
    {
        if ( m_dictPtr != dictPtr ) {
            if ( m_dictPtr == 0 || 
                 !XwJNI.dict_tilesAreSame( m_dictPtr, dictPtr ) ) {
                m_fontDims = null;
                m_dictChars = XwJNI.dict_getChars( dictPtr );
            }
            m_dictPtr = dictPtr;
        }
    }

    private void drawTileImpl( Rect rect, String text, int val, 
                               int flags, boolean clearBack )
    {
        // boolean valHidden = (flags & CELL_VALHIDDEN) != 0;
        boolean notEmpty = (flags & CELL_ISEMPTY) == 0;
        boolean isCursor = (flags & CELL_ISCURSOR) != 0;

        m_canvas.save( Canvas.CLIP_SAVE_FLAG );
        rect.top += 1;
        m_canvas.clipRect( rect );

        if ( clearBack ) {
            clearToBack( rect );
        }

        if ( isCursor || notEmpty ) {

            if ( clearBack ) {
                int indx = isCursor? CommonPrefs.COLOR_FOCUS 
                    : CommonPrefs.COLOR_TILE_BACK;
                fillRect( rect, m_otherColors[indx] );
            }

            m_fillPaint.setColor( m_playerColors[m_trayOwner] );

            if ( notEmpty ) {
                positionDrawTile( rect, text, val );

                m_canvas.drawRect( rect, m_tileStrokePaint); // frame
                if ( 0 != (flags & CELL_HIGHLIGHT) ) {
                    rect.inset( 2, 2 );
                    m_canvas.drawRect( rect, m_tileStrokePaint ); // frame
                }
            }
        }
        m_canvas.restoreToCount(1); // in case new canvas....
    } // drawTileImpl

    private void drawCentered( String text, Rect rect, FontDims fontDims ) 
    {
        int descent = -1;
        int textSize;
        if ( null == fontDims ) {
            textSize = rect.height() - 2;
        } else {
            int height = rect.height() - 4; // borders and padding, 2 each 
            descent = fontDims.descentFor( height );
            textSize = fontDims.heightFor( height );
            // Utils.logf( ""using descent: "" + descent + "" and textSize: "" 
            //             + textSize + "" in height "" + height );
        }
        m_fillPaint.setTextSize( textSize );
        if ( descent == -1 ) {
            descent = m_fillPaint.getFontMetricsInt().descent;
        }
        descent += 2;

        m_fillPaint.getTextBounds( text, 0, text.length(), m_boundsScratch );
        if ( m_boundsScratch.width() > rect.width() ) {
            m_fillPaint.setTextAlign( Paint.Align.LEFT );
            drawScaled( text, rect, descent );
        } else {
            int bottom = rect.bottom - descent;
            int center = rect.left + ( rect.width() / 2 );
            m_fillPaint.setTextAlign( Paint.Align.CENTER );
            m_canvas.drawText( text, center, bottom, m_fillPaint );
        }
    } // drawCentered

    private void drawScaled( String text, final Rect rect, int descent )
    {
        Rect local = new Rect();
        m_fillPaint.getTextBounds( text, 0, text.length(), local );
        local.bottom = rect.height();

        Bitmap bitmap = Bitmap.createBitmap( local.width(),
                                             rect.height(), 
                                             Bitmap.Config.ARGB_8888 );

        Canvas canvas = new Canvas( bitmap );
        int bottom = local.bottom - descent;
        canvas.drawText( text, 0, bottom, m_fillPaint );

        m_canvas.drawBitmap( bitmap, null, rect, m_drawPaint );
    }

    private void positionDrawTile( final Rect rect, String text, int val )
    {
        figureFontDims();

        if ( null != text ) {
            if ( null == m_letterRect ) {
                m_letterRect = new Rect( 0, 0, rect.width() * 3 / 4, 
                                         rect.height() * 3 / 4 );
            }
            m_letterRect.offsetTo( rect.left+2, rect.top+2 );
            drawCentered( text, m_letterRect, m_fontDims );
        }

        if ( val >= 0 ) {
            if ( null == m_valRect ) {
                m_valRect = new Rect( 0, 0, rect.width() / 4, rect.height() / 4 );
                m_valRect.inset( 2, 2 );
            }
            m_valRect.offsetTo( rect.right - (rect.width() / 4),
                                rect.bottom - (rect.height() / 4) );
            text = String.format( ""%d"", val );
            m_fillPaint.setTextSize( m_valRect.height() );
            m_fillPaint.setTextAlign( Paint.Align.RIGHT );
            m_canvas.drawText( text, m_valRect.right, m_valRect.bottom, 
                               m_fillPaint );
        }
    }

    private void drawCrosshairs( final Rect rect, final int flags )
    {
        int color = m_otherColors[CommonPrefs.COLOR_FOCUS];
        if ( 0 != (flags & CELL_CROSSHOR) ) {
            Rect hairRect = new Rect( rect );
            hairRect.inset( 0, hairRect.height() / 3 );
            fillRect( hairRect, color );
        }
        if ( 0 != (flags & CELL_CROSSVERT) ) {
            Rect hairRect = new Rect( rect );
            hairRect.inset( hairRect.width() / 3, 0 );
            fillRect( hairRect, color );
        }
    }

    private void fillRect( Rect rect, int color )
    {
        m_fillPaint.setColor( color );
        m_canvas.drawRect( rect, m_fillPaint );
    }

    private void clearToBack( Rect rect ) 
    {
        fillRect( rect, m_otherColors[CommonPrefs.COLOR_BKGND] );
    }

    private void figureFontDims()
    {
        if ( null == m_fontDims ) {
            final int ht = 24;
            final int width = 20;

            Paint paint = new Paint(); // CommonPrefs.getFontFlags()??
            paint.setStyle( Paint.Style.STROKE );
            paint.setTextAlign( Paint.Align.LEFT );
            paint.setTextSize( ht );

            Bitmap bitmap = Bitmap.createBitmap( width, (ht*3)/2, 
                                                 Bitmap.Config.ARGB_8888 );
            Canvas canvas = new Canvas( bitmap );

            // FontMetrics fmi = paint.getFontMetrics();
            // Utils.logf( ""ascent: "" + fmi.ascent );
            // Utils.logf( ""bottom: "" + fmi.bottom );
            // Utils.logf( ""descent: "" + fmi.descent );
            // Utils.logf( ""leading: "" + fmi.leading );
            // Utils.logf( ""top : "" + fmi.top );

            // Utils.logf( ""using as baseline: "" + ht );

            Rect bounds = new Rect();
            int maxWidth = 0;
            for ( String str : m_dictChars ) {
                if ( str.length() == 1 && str.charAt(0) >= 32 ) {
                    canvas.drawText( str, 0, ht, paint );
                    paint.getTextBounds( str, 0, 1, bounds );
                    if ( maxWidth < bounds.right ) {
                        maxWidth = bounds.right;
                    }
                }
            }

            // for ( int row = 0; row < bitmap.getHeight(); ++row ) {
            //     StringBuffer sb = new StringBuffer( bitmap.getWidth() );
            //     for ( int col = 0; col < bitmap.getWidth(); ++col ) {
            //         int pixel = bitmap.getPixel( col, row );
            //         sb.append( pixel==0? ""."" : ""X"" );
            //     }
            //     Utils.logf( sb.append(row).toString() );
            // }

            int topRow = 0;
            findTop:
            for ( int row = 0; row < bitmap.getHeight(); ++row ) {
                for ( int col = 0; col < bitmap.getWidth(); ++col ) {
                    if ( 0 != bitmap.getPixel( col, row ) ){
                        topRow = row;
                        break findTop;
                    }
                }
            }

            int bottomRow = 0;
            findBottom:
            for ( int row = bitmap.getHeight() - 1; row > topRow; --row ) {
                for ( int col = 0; col < bitmap.getWidth(); ++col ) {
                    if ( 0 != bitmap.getPixel( col, row ) ){
                        bottomRow = row;
                        break findBottom;
                    }
                }
            }
        
            m_fontDims = new FontDims( ht, topRow, bottomRow, maxWidth );
        }
    } // figureFontDims

    private void markBlank( final Rect rect, boolean whiteOnBlack )
    {
        RectF oval = new RectF( rect.left, rect.top, rect.right, rect.bottom );
        int curColor = 0;
        if ( whiteOnBlack ) {
            curColor = m_strokePaint.getColor();
            m_strokePaint.setColor( WHITE );
        }
        m_canvas.drawArc( oval, 0, 360, false, m_strokePaint );
        if ( whiteOnBlack ) {
            m_strokePaint.setColor( curColor );
        }
    }
}",True,28,31,1,1,5,9,1,9,L3
30,org.eehouse.android.xw4.DictImportActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.os.Bundle;
import android.os.AsyncTask;
import android.content.Intent;
import android.net.Uri;
import android.view.Window;
import android.widget.ProgressBar;
import android.widget.TextView;
import java.io.InputStream;
import java.io.File;
import java.net.URI;

import junit.framework.Assert;

public class DictImportActivity extends XWActivity {

    private class DownloadFilesTask extends AsyncTask<Uri, Integer, Long> {
        @Override
        protected Long doInBackground( Uri... uris )
        {
            int count = uris.length;
            Assert.assertTrue( 1 == count );
            long totalSize = 0;
            for ( int ii = 0; ii < count; ii++ ) {
                Uri uri = uris[ii];
                Utils.logf( ""trying %s"", uri );

                try {
                    URI jUri = new URI( uri.getScheme(), 
                                        uri.getSchemeSpecificPart(), 
                                        uri.getFragment() );
                    InputStream is = jUri.toURL().openStream();
                    saveDict( is, uri.getPath() );
                } catch ( java.net.URISyntaxException use ) {
                    Utils.logf( ""URISyntaxException: %s"" + use.toString() );
                } catch ( java.net.MalformedURLException mue ) {
                    Utils.logf( ""MalformedURLException: %s"" + mue.toString() );
                } catch ( java.io.IOException ioe ) {
                    Utils.logf( ""IOException: %s"" + ioe.toString() );
                }
            }
            return totalSize;
        }

        @Override
        protected void onPostExecute( Long result )
        {
            Utils.logf( ""onPostExecute passed %d"", result );
            finish();
        }
    } // class DownloadFilesTask

	@Override
	protected void onCreate( Bundle savedInstanceState ) 
    {
		super.onCreate( savedInstanceState );

		requestWindowFeature( Window.FEATURE_LEFT_ICON );
		setContentView( R.layout.import_dict );
		getWindow().setFeatureDrawableResource( Window.FEATURE_LEFT_ICON,
                                                R.drawable.icon48x48 );

		ProgressBar progressBar = (ProgressBar)findViewById( R.id.progress_bar );

		Intent intent = getIntent();
		Uri uri = intent.getData();
		if ( null != uri) {
			if ( null != intent.getType() 
                 && intent.getType().equals( ""application/x-xwordsdict"" ) ) {
                Utils.logf( ""based on MIME type"" );
                new DownloadFilesTask().execute( uri );
            } else if ( uri.toString().endsWith( XWConstants.DICT_EXTN ) ) {
                String fmt = getString( R.string.downloading_dictf );
                String txt = String.format( fmt, basename( uri.getPath()) );
                TextView view = (TextView)findViewById( R.id.dwnld_message );
                view.setText( txt );
                new DownloadFilesTask().execute( uri );
			} else {
                Utils.logf( ""bogus intent: %s/%s"", intent.getType(), uri );
				finish();
			}
        }
	}

    private void saveDict( InputStream inputStream, String path )
    {
        try {
            String name = basename( path );
            GameUtils.saveDict( this, name, inputStream );
            DictLangCache.inval( GameUtils.removeDictExtn( name ) );
            inputStream.close();
        } catch ( java.io.IOException ioe ) {
            Utils.logf( ""IOException: %s"" + ioe.toString() );
        }
    }

    private String basename( String path )
    {
        return new File(path).getName();
    }
}


",True,9,25,0,0,4,11,0,5,L3
31,org.eehouse.android.xw4.Toolbar.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.content.Context;
import android.content.DialogInterface;
import android.view.View;
import android.widget.LinearLayout;
import android.widget.ImageButton;
//import android.view.LayoutInflater;
//import java.util.HashMap;
//import junit.framework.Assert;

import org.eehouse.android.xw4.jni.*;

public class Toolbar {

    private static class TBButtonInfo {
        public TBButtonInfo( int... ids ) {
            m_ids = ids;
        }
        public int m_ids[];
    }

    public static final int BUTTON_HINT_PREV = 0;
    public static final int BUTTON_HINT_NEXT = 1;
    public static final int BUTTON_FLIP = 2;
    public static final int BUTTON_JUGGLE = 3;
    public static final int BUTTON_ZOOM = 4;
    public static final int BUTTON_UNDO = 5;
    public static final int BUTTON_CHAT = 6;

    private static TBButtonInfo[] s_buttonInfo = {
        // BUTTON_HINT_PREV
        new TBButtonInfo(R.id.prevhint_button_horizontal, 
                         R.id.prevhint_button_vertical),
        // BUTTON_HINT_NEXT
        new TBButtonInfo(R.id.nexthint_button_horizontal, 
                         R.id.nexthint_button_vertical),
        // BUTTON_FLIP
        new TBButtonInfo(R.id.flip_button_horizontal,
                         R.id.flip_button_vertical),
        // BUTTON_JUGGLE
        new TBButtonInfo( R.id.shuffle_button_horizontal,
                          R.id.shuffle_button_vertical ),
        // BUTTON_ZOOM
        new TBButtonInfo( R.id.zoom_button_horizontal,
                          R.id.zoom_button_vertical ),
        // BUTTON_UNDO
        new TBButtonInfo( R.id.undo_button_horizontal,
                          R.id.undo_button_vertical ),
        // BUTTON_CHAT
        new TBButtonInfo( R.id.chat_button_horizontal,
                          R.id.chat_button_vertical ),
    };

    private XWActivity m_activity;
    private LinearLayout m_horLayout;
    private LinearLayout m_vertLayout;

    private enum ORIENTATION { ORIENT_UNKNOWN,
            ORIENT_PORTRAIT,
            ORIENT_LANDSCAPE,
            };
    private ORIENTATION m_curOrient = ORIENTATION.ORIENT_UNKNOWN;

    public Toolbar( XWActivity activity, View horLayout, View vertLayout )
    {
        m_activity = activity;
        m_horLayout = (LinearLayout)horLayout;
        m_vertLayout = (LinearLayout)vertLayout;
    }

    public void setListener( int index, View.OnClickListener listener )
    {
        TBButtonInfo info = s_buttonInfo[index];
        for ( int id : info.m_ids ) {
            ImageButton button = (ImageButton)m_activity.findViewById( id );
            button.setOnClickListener( listener );
        }
    }

    public void setListener( int index, final int msgID, final int prefsKey, 
                             final Runnable proc )
    {
        View.OnClickListener listener = new View.OnClickListener() {
                public void onClick( View view ) {
                    m_activity.showNotAgainDlgThen( msgID, prefsKey, proc );
                }
            };
        setListener( index, listener );
    }

    public void orientChanged( boolean landscape )
    {
        if ( landscape && m_curOrient == ORIENTATION.ORIENT_LANDSCAPE ) {
            // do nothing
        } else if ( !landscape && m_curOrient == ORIENTATION.ORIENT_PORTRAIT ) {
            // do nothing
        } else {
            LinearLayout prevLayout, nextLayout;
            if ( landscape ) {
                m_curOrient = ORIENTATION.ORIENT_LANDSCAPE;
                prevLayout = m_horLayout;
                nextLayout = m_vertLayout;
            } else {
                m_curOrient = ORIENTATION.ORIENT_PORTRAIT;
                prevLayout = m_vertLayout;
                nextLayout = m_horLayout;
            }

            prevLayout.setVisibility( View.GONE );
            nextLayout.setVisibility( View.VISIBLE );
        }
    }

    public void update( int index, int enable )
    {
        boolean show = enable!=0;
        TBButtonInfo info = s_buttonInfo[index];
        int vis = enable != 0 ? View.VISIBLE : View.GONE;

        ImageButton button;
        for ( int id : info.m_ids ) {
            button = (ImageButton)m_activity.findViewById( id );
            button.setVisibility( vis );
        }
    }

}
",True,51,30,2,3,6,8,2,1,L3
32,org.eehouse.android.xw4.RelayReceiver.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.content.Intent;
import android.content.BroadcastReceiver;
import android.widget.Toast;
import android.app.AlarmManager;
import android.app.PendingIntent;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import java.net.Socket;
import java.io.InputStream;
import java.io.DataInputStream;
import java.io.OutputStream;
import java.io.DataOutputStream;
import java.util.ArrayList;

import org.eehouse.android.xw4.jni.CommonPrefs;

public class RelayReceiver extends BroadcastReceiver {

    @Override
    public void onReceive( Context context, Intent intent )
    {
        Utils.logf( ""RelayReceiver::onReceive()"" );
        Toast.makeText(context, ""RelayReceiver: fired"", 
                       Toast.LENGTH_SHORT).show();

        // Do the actual background work.  Could do it here, but only
        // if we're sure to finish in 10 seconds and if it'll always
        // result in posting a notification.  Some scenarios

        query_relay( context );

        // Intent service = new Intent( context, RelayService.class );
        // context.startService( service );
    }

    private void query_relay( Context context ) 
    {
        String[] relayIDs = NetUtils.QueryRelay( context );
        if ( null != relayIDs ) {
            setupNotification( context, relayIDs );
        }
    }

    private void setupNotification( Context context, String[] relayIDs )
    {
        Intent intent = new Intent( context, DispatchNotify.class );
        //intent.addFlags( Intent.FLAG_ACTIVITY_CLEAR_TOP );
        intent.putExtra( context.getString(R.string.relayids_extra), 
                         relayIDs );

        PendingIntent pi = PendingIntent.
            getActivity( context, 0, intent, 
                         PendingIntent.FLAG_UPDATE_CURRENT );
        String title = context.getString(R.string.notify_title);
        Notification notification = 
            new Notification( R.drawable.icon48x48, title,
                              System.currentTimeMillis() );
        notification.flags |= Notification.FLAG_AUTO_CANCEL;

        notification.
            setLatestEventInfo( context, title, 
                                context.getString(R.string.notify_body), pi );

        NotificationManager nm = (NotificationManager)
            context.getSystemService( Context.NOTIFICATION_SERVICE );
        nm.notify( R.string.relayids_extra, notification );
    }

    public static void RestartTimer( Context context )
    {
        RestartTimer( context, 
                      1000 * CommonPrefs.getProxyInterval( context ) );
    }

    public static void RestartTimer( Context context, long interval_millis )
    {
        AlarmManager am =
            (AlarmManager)context.getSystemService( Context.ALARM_SERVICE );

        Intent intent = new Intent( context, RelayReceiver.class );
        PendingIntent pi = PendingIntent.getBroadcast( context, 0, intent, 0 );

        if ( interval_millis > 0 ) {
            Utils.logf( ""setting alarm for %d millis"", interval_millis );
            am.setInexactRepeating( AlarmManager.ELAPSED_REALTIME_WAKEUP, 
                                    0, // first firing
                                    interval_millis, pi );
        } else {
            am.cancel( pi );
        }
    }
}",False,29,23,1,2,5,7,2,3,L1
33,org.eehouse.android.xw4.DBHelper.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.content.Context;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteDatabase;

public class DBHelper extends SQLiteOpenHelper {

    public static final String TABLE_NAME_SUM = ""summaries"";
    public static final String TABLE_NAME_OBITS = ""obits"";
    private static final String DB_NAME = ""xwdb"";
    private static final int DB_VERSION = 6;

    public static final String FILE_NAME = ""FILE_NAME"";
    public static final String NUM_MOVES = ""NUM_MOVES"";
    public static final String PLAYERS = ""PLAYERS"";
    public static final String NUM_PLAYERS = ""NUM_PLAYERS"";
    public static final String GAME_OVER = ""GAME_OVER"";
    public static final String SCORES = ""SCORES"";
    // GAMEID: this isn't used yet but we'll want it to look up games
    // for which messages arrive.  Add now while changing the DB
    // format
    public static final String GAMEID = ""GAMEID"";
    public static final String DICTLANG = ""DICTLANG"";
    public static final String DICTNAME = ""DICTNAME"";
    public static final String HASMSGS = ""HASMSGS"";
    public static final String SNAPSHOT = ""SNAPSHOT"";
    public static final String CONTYPE = ""CONTYPE"";
    public static final String SERVERROLE = ""SERVERROLE"";
    public static final String ROOMNAME = ""ROOMNAME"";
    public static final String RELAYID = ""RELAYID"";
    public static final String SEED = ""SEED"";
    public static final String SMSPHONE = ""SMSPHONE"";
    // not used yet
    public static final String CREATE_TIME = ""CREATE_TIME"";
    // not used yet
    public static final String LASTPLAY_TIME = ""LASTPLAY_TIME"";


    public DBHelper( Context context )
    {
        super( context, DB_NAME, null, DB_VERSION );
    }

    private void onCreateSum( SQLiteDatabase db ) 
    {
        db.execSQL( ""CREATE TABLE "" + TABLE_NAME_SUM + "" (""
                    + FILE_NAME   + "" TEXT PRIMARY KEY,""
                    + NUM_MOVES   + "" INTEGER,""
                    + NUM_PLAYERS + "" INTEGER,""
                    + PLAYERS     + "" TEXT,""
                    + GAME_OVER   + "" INTEGER,""

                    + SERVERROLE + "" INTEGER,""
                    + CONTYPE    + "" INTEGER,""
                    + ROOMNAME   + "" TEXT,""
                    + RELAYID    + "" TEXT,""
                    + SEED       + "" INTEGER,""
                    + DICTLANG   + "" INTEGER,""
                    + DICTNAME   + "" TEXT,""

                    + SMSPHONE   + "" TEXT,""
                    + SCORES     + "" TEXT,""
                    + GAMEID     + "" INTEGER,""
                    // HASMSGS: sqlite doesn't have bool; use 0 and 1
                    + HASMSGS    + "" INTEGER DEFAULT 0,""

                    + CREATE_TIME + "" INTEGER,""
                    + LASTPLAY_TIME + "" INTEGER,""

                    + SNAPSHOT   + "" BLOB""
                    + "");"" );
    }

    private void onCreateObits( SQLiteDatabase db ) 
    {
        db.execSQL( ""CREATE TABLE "" + TABLE_NAME_OBITS + "" (""
                    + RELAYID    + "" TEXT,""
                    + SEED       + "" INTEGER""
                    + "");"" );
    }

    @Override
    public void onCreate( SQLiteDatabase db ) 
    {
        onCreateSum( db );
        onCreateObits( db );
    }

    @Override
    public void onUpgrade( SQLiteDatabase db, int oldVersion, int newVersion ) 
    {
        Utils.logf( ""onUpgrade: old: %d; new: %d"", oldVersion, newVersion );

        if ( newVersion == 6 && oldVersion == 5 ) {
            onCreateObits(db);
        } else {
            db.execSQL( ""DROP TABLE "" + TABLE_NAME_SUM + "";"" );
            if ( oldVersion >= 6 ) {
                db.execSQL( ""DROP TABLE "" + TABLE_NAME_OBITS + "";"" );
            }
            onCreate( db );
        }
    }
}
",False,23,20,0,0,5,9,1,1,L0
34,org.eehouse.android.xw4.XWActivity.java,"/* -*- compile-command: ""cd ../../../../../; ant install""; -*- */
/*
 * Copyright 2010 by Eric House (xwords@eehouse.org).  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4;

import android.app.Activity;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.view.LayoutInflater;
import android.net.Uri;
import junit.framework.Assert;
import android.view.View;
import android.widget.TextView;
import android.app.AlertDialog;
import android.os.Bundle;

import org.eehouse.android.xw4.jni.CommonPrefs;

public class XWActivity extends Activity {

    private DlgDelegate m_delegate;

    protected void onCreate( Bundle savedInstanceState ) 
    {
        super.onCreate( savedInstanceState );
        m_delegate = new DlgDelegate( this );
    }

    @Override
    protected void onStart()
    {
        super.onStart();
        DispatchNotify.SetRunning( this );
    }

    @Override
    protected void onStop()
    {
        super.onStop();
        DispatchNotify.ClearRunning( this );
    }

    @Override
    protected Dialog onCreateDialog( int id )
    {
        return m_delegate.onCreateDialog( id );
    }

    @Override
    protected void onPrepareDialog( int id, Dialog dialog )
    {
        m_delegate.onPrepareDialog( id, dialog );
    }

    // these are duplicated in XWListActivity -- sometimes multiple
    // inheritance would be nice to have...
    protected void showAboutDialog()
    {
        m_delegate.showAboutDialog();
    }

    protected void showNotAgainDlgThen( int msgID, int prefsKey,
                                        Runnable proc )
    {
        m_delegate.showNotAgainDlgThen( msgID, prefsKey, proc );
    }

    protected void showOKOnlyDialog( int msgID )
    {
        m_delegate.showOKOnlyDialog( msgID );
    }
}
",False,11,34,3,5,5,8,5,3,L2
35,org.eehouse.android.xw4.jni.DrawScoreInfo.java,"/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

public class DrawScoreInfo {
    public String name;
    public int playerNum;
    public int totalScore;
    public int nTilesLeft;   /* < 0 means don't use */
    public int flags;        // was CellFlags; use CELL_ constants above
    public boolean isTurn;
    public boolean selected;
    public boolean isRemote;
    public boolean isRobot;
};
",False,24,41,6,15,0,0,2,0,L0
36,org.eehouse.android.xw4.jni.CurGameInfo.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import java.util.Random;
import android.content.Context;
import junit.framework.Assert;

import org.eehouse.android.xw4.Utils;
import org.eehouse.android.xw4.GameUtils;
import org.eehouse.android.xw4.R;
import org.eehouse.android.xw4.DictLangCache;

public class CurGameInfo {

    public static final int MAX_NUM_PLAYERS = 4;

    public enum XWPhoniesChoice { PHONIES_IGNORE, PHONIES_WARN, PHONIES_DISALLOW };
    public enum DeviceRole { SERVER_STANDALONE, SERVER_ISSERVER, SERVER_ISCLIENT };

    public String dictName;
    public LocalPlayer[] players;
    public int dictLang;
    public int gameID;
    public int gameSeconds;
    public int nPlayers;
    public int boardSize;
    public DeviceRole serverRole;

    public boolean hintsNotAllowed;
    public boolean timerEnabled;
    public boolean allowPickTiles;
    public boolean allowHintRect;
    public int robotSmartness;
    public XWPhoniesChoice phoniesAction;
    public boolean confirmBTConnect;   /* only used for BT */

    // private int[] m_visiblePlayers;
    // private int m_nVisiblePlayers;
    private boolean m_inProgress;

    public CurGameInfo( Context context )
    {
        this( context, false );
    }

    public CurGameInfo( Context context, boolean isNetworked )
    {
        m_inProgress = false;
        nPlayers = 2;
        gameSeconds = 60 * nPlayers *
            CommonPrefs.getDefaultPlayerMinutes( context );
        boardSize = CommonPrefs.getDefaultBoardSize( context );
        players = new LocalPlayer[MAX_NUM_PLAYERS];
        serverRole = isNetworked ? DeviceRole.SERVER_ISCLIENT
            : DeviceRole.SERVER_STANDALONE;
        dictName = CommonPrefs.getDefaultDict( context );
        dictLang = DictLangCache.getLangCode( context, dictName );
        hintsNotAllowed = false;
        phoniesAction = CommonPrefs.getDefaultPhonies( context );
        timerEnabled = CommonPrefs.getDefaultTimerEnabled( context );
        allowPickTiles = false;
        allowHintRect = false;
        robotSmartness = 1;

        // Always create MAX_NUM_PLAYERS so jni code doesn't ever have
        // to cons up a LocalPlayer instance.
        int ii;
        for ( ii = 0; ii < MAX_NUM_PLAYERS; ++ii ) {
            players[ii] = new LocalPlayer( context, ii );
        }
        if ( isNetworked ) {
            players[1].isLocal = false;
        } else {
            players[0].isRobot = true;
        }
    }

    public CurGameInfo( CurGameInfo src )
    {
        m_inProgress = src.m_inProgress;
        gameID = src.gameID;
        nPlayers = src.nPlayers;
        gameSeconds = src.gameSeconds;
        boardSize = src.boardSize;
        players = new LocalPlayer[MAX_NUM_PLAYERS];
        serverRole = src.serverRole;
        dictName = src.dictName;
        dictLang = src.dictLang;
        hintsNotAllowed = src.hintsNotAllowed;
        phoniesAction = src.phoniesAction;
        timerEnabled = src.timerEnabled;
        allowPickTiles = src.allowPickTiles;
        allowHintRect = src.allowHintRect;
        robotSmartness = src.robotSmartness;
        
        int ii;
        for ( ii = 0; ii < MAX_NUM_PLAYERS; ++ii ) {
            players[ii] = new LocalPlayer( src.players[ii] );
        }
    }

    public void setServerRole( DeviceRole newRole )
    {
        serverRole = newRole;
        Assert.assertTrue( nPlayers > 0 );
        if ( nPlayers == 0 ) { // must always be one visible player
            Assert.assertFalse( players[0].isLocal );
            players[0].isLocal = true;
        }
    }

    public void setInProgress( boolean inProgress )
    {
        m_inProgress = inProgress;
    }

    /** return true if any of the changes made would invalide a game
     * in progress, i.e. require that it be restarted with the new
     * params.  E.g. changing a player to a robot is harmless for a
     * local-only game but illegal for a connected one.
     */
    public boolean changesMatter( final CurGameInfo other )
    {
        boolean matter = nPlayers != other.nPlayers
            || serverRole != other.serverRole
            || dictLang != other.dictLang
            || boardSize != other.boardSize
            || hintsNotAllowed != other.hintsNotAllowed
            || allowPickTiles != other.allowPickTiles
            || phoniesAction != other.phoniesAction;

        if ( !matter && DeviceRole.SERVER_STANDALONE != serverRole ) {
            for ( int ii = 0; ii < nPlayers; ++ii ) {
                LocalPlayer me = players[ii];
                LocalPlayer him = other.players[ii];
                matter = me.isRobot != him.isRobot
                    || me.isLocal != him.isLocal
                    || !me.name.equals( him.name );
                if ( matter ) {
                    break;
                }
            }
        }

        return matter;
    }

    public int remoteCount()
    {
        int count = 0;
        for ( int ii = 0; ii < nPlayers; ++ii ) {
            if ( !players[ii].isLocal ) {
                ++count;
            }
        }
        Utils.logf( ""remoteCount()=>%d"", count );
        return count;
    }

    public boolean forceRemoteConsistent()
    {
        boolean consistent = serverRole == DeviceRole.SERVER_STANDALONE;
        if ( !consistent ) {
            if ( remoteCount() == 0 ) {
                players[0].isLocal = false;
            } else if ( remoteCount() == nPlayers ) {
                players[0].isLocal = true;
            } else {
                consistent = true; // nothing changed
            }
        }
        return !consistent;
    }

    public String[] visibleNames( Context context )
    {
        String[] names = new String[nPlayers];
        for ( int ii = 0; ii < nPlayers; ++ii ) {
            LocalPlayer lp = players[ii];
            if ( lp.isLocal || serverRole == DeviceRole.SERVER_STANDALONE ) {
                names[ii] = lp.name;
                if ( lp.isRobot ) {
                    names[ii] += "" "" + context.getString( R.string.robot_name );
                }
            } else {
                names[ii] = context.getString( R.string.guest_name );
            }
        }
        return names;
    }

    public boolean addPlayer() 
    {
        boolean added = nPlayers < MAX_NUM_PLAYERS;
        // We can add either by adding a player, if nPlayers <
        // MAX_NUM_PLAYERS, or by making an unusable player usable.
        if ( added ) {
            ++nPlayers;
        }
        return added;
    }

    public void setFirstLocalName( String name ) {
        for ( int ii = 0; ii < nPlayers; ++ii ) {
            if ( players[ii].isLocal ) {
                players[ii].name = name;
                break;
            }
        }
    }

    public boolean moveUp( int which )
    {
        boolean canMove = which > 0 && which < nPlayers;
        if ( canMove ) {
            LocalPlayer tmp = players[which-1];
            players[which-1] = players[which];
            players[which] = tmp;
        }
        return canMove;
    }

    public boolean moveDown( int which )
    {
        return moveUp( which + 1 );
    }

    public boolean delete( int which )
    {
        boolean canDelete = nPlayers > 0;
        if ( canDelete ) {
            LocalPlayer tmp = players[which];
            for ( int ii = which; ii < nPlayers - 1; ++ii ) {
                moveDown( ii );
            }
            --nPlayers;
            players[nPlayers] = tmp;
        }
        return canDelete;
    }

    public boolean juggle()
    {
        boolean canJuggle = nPlayers > 1;
        if ( canJuggle ) {
            // for each element, exchange with randomly chocsen from
            // range <= to self.
            Random rgen = new Random();

            for ( int ii = nPlayers - 1; ii > 0; --ii ) {
                // Contrary to docs, nextInt() comes back negative!
                int rand = Math.abs(rgen.nextInt()); 
                int indx = rand % (ii+1);
                if ( indx != ii ) {
                    LocalPlayer tmp = players[ii];
                    players[ii] = players[indx];
                    players[indx] = tmp;
                }
            }
        }
        return canJuggle;
    }
}
",True,5,29,1,9,4,8,14,5,L0
37,org.eehouse.android.xw4.jni.GameSummary.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.content.Context;
import junit.framework.Assert;
import org.eehouse.android.xw4.R;


/** Info we want to access when the game's closed that's not available
 * in CurGameInfo
 */
public class GameSummary {
    public int nMoves;
    public int nPlayers;
    public int[] scores;
    public boolean gameOver;
    public String players;
    public CommsAddrRec.CommsConnType conType;
    public String smsPhone;
    // relay-related fields
    public String roomName;
    public String relayID;
    public int seed;
    public boolean msgsPending;

    public int dictLang;
    public String dictName;
    public CurGameInfo.DeviceRole serverRole;

    private CurGameInfo m_gi;

    public GameSummary(){}

    public GameSummary( CurGameInfo gi )
    {
        nPlayers = gi.nPlayers;
        dictLang = gi.dictLang;
        dictName = gi.dictName;
        serverRole = gi.serverRole;
        m_gi = gi;
    }

    public boolean inNetworkGame()
    {
        return null != relayID;
    }

    public String summarizePlayers( Context context )
    {
        StringBuffer sb = new StringBuffer();
        String vsString = context.getString( R.string.vs );
        for ( int ii = 0; ; ) {

            int score = 0;
            try {
                // scores can be null, but I've seen array OOB too.
                score = scores[ii];
            } catch ( Exception ex ){}

            sb.append( String.format( ""%s(%d)"", m_gi.players[ii].name, score ) );
            if ( ++ii >= nPlayers ) {
                break;
            }
            sb.append( String.format( "" %s "", vsString ) );
        }
        return sb.toString();
    }

    public String summarizeState( Context context )
    {
        String result = null;
        if ( gameOver ) {
            result = context.getString( R.string.gameOver );
        } else {
            result = String.format( context.getString(R.string.movesf),
                                    nMoves );
        }
        return result;
    }

    public String summarizeRole( Context context )
    {
        String result = null;
        if ( null != conType 
             && serverRole != CurGameInfo.DeviceRole.SERVER_STANDALONE ) {
            Assert.assertTrue( CommsAddrRec.CommsConnType.COMMS_CONN_RELAY
                               == conType );
            String fmt = context.getString( R.string.summary_fmt_relay );
            result = String.format( fmt, roomName );
        }
        return result;
    }

}
",True,40,28,2,4,5,6,7,3,L0
38,org.eehouse.android.xw4.jni.JNIUtilsImpl.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.graphics.drawable.BitmapDrawable;
import android.graphics.Bitmap;
import java.util.ArrayList;
import java.io.ByteArrayInputStream;
import java.io.InputStreamReader;

import org.eehouse.android.xw4.*;

public class JNIUtilsImpl implements JNIUtils {

    private static JNIUtils s_impl = null;

    private JNIUtilsImpl(){}

    public static JNIUtils get()
    {
        if ( null == s_impl ) {
            s_impl = new JNIUtilsImpl();
        }
        return s_impl;
    }

    /** Working around lack of utf8 support on the JNI side: given a
     * utf-8 string with embedded small number vals starting with 0,
     * convert into individual strings.  The 0 is the problem: it's
     * not valid utf8.  So turn it and the other nums into strings and
     * catch them on the other side.
     */
    public String[] splitFaces( byte[] chars, boolean isUTF8 )
    {
        ArrayList<String> al = new ArrayList<String>();
        ByteArrayInputStream bais = new ByteArrayInputStream( chars );
        InputStreamReader isr;
        try {
            isr = new InputStreamReader( bais, isUTF8? ""UTF8"" : ""ISO8859_1"" );
        } catch( java.io.UnsupportedEncodingException uee ) {
            Utils.logf( ""splitFaces: %s"", uee.toString() );
            isr = new InputStreamReader( bais );
        }
        
        int[] codePoints = new int[1];

        for ( ; ; ) {
            int chr = -1;
            try {
                chr = isr.read();
            } catch ( java.io.IOException ioe ) {
                Utils.logf( ioe.toString() );
            }
            if ( -1 == chr ) {
                break;
            } else {
                String letter;
                if ( chr < 32 ) {
                    letter = String.format( ""%d"", chr );
                } else {
                    codePoints[0] = chr;
                    letter = new String( codePoints, 0, 1 );
                }
                al.add( letter );
            }
        }
        
        String[] result = al.toArray( new String[al.size()] );
        return result;
    }
}",False,3,22,1,2,5,8,4,2,L0
39,org.eehouse.android.xw4.jni.BoardHandler.java,"/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

public interface BoardHandler {

    void startHandling( JNIThread thread, int gamePtr, CurGameInfo gi );

}
",False,26,31,2,1,5,12,1,2,L3
40,org.eehouse.android.xw4.jni.JNIUtils.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.graphics.drawable.BitmapDrawable;

public interface JNIUtils {

    // Stuff I can't do in C....
    String[] splitFaces( byte[] chars, boolean isUTF8 );
}",False,50,40,5,14,0,0,3,0,L0
41,org.eehouse.android.xw4.jni.LocalPlayer.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.content.Context;
import org.eehouse.android.xw4.R;

public class LocalPlayer {
    public String name;
    public String password;
    public int secondsUsed;
    public boolean isRobot;
    public boolean isLocal;

    public LocalPlayer( Context context, int num )
    {
        isLocal = true;
        isRobot = false;
        String fmt = context.getString( R.string.playerf );
        name = String.format( fmt, num + 1 );
        password = """";
    }

    public LocalPlayer( final LocalPlayer src )
    {
        isLocal = src.isLocal;
        isRobot = src.isRobot;
        if ( null != src.name ) {
            name = new String(src.name);
        }
        if ( null != src.password ) {
            password = new String(src.password);
        }
        secondsUsed = src.secondsUsed;
    }
}

",True,13,40,4,13,0,0,3,0,L0
42,org.eehouse.android.xw4.jni.DictInfo.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

public class DictInfo {
    public int langCode;
    public int wordCount;
};
",False,49,40,5,21,0,0,2,0,L0
43,org.eehouse.android.xw4.jni.UtilCtxt.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

public interface UtilCtxt {
    static final int BONUS_NONE = 0;
    static final int BONUS_DOUBLE_LETTER = 1;
    static final int BONUS_DOUBLE_WORD = 2;
    static final int BONUS_TRIPLE_LETTER = 3;
    static final int BONUS_TRIPLE_WORD = 4;

    int getSquareBonus( int col, int row );
    int userPickTile( /* PickInfo* pi, add once tile-picking is enabled */
                     int playerNum, String[] texts );

    String askPassword( String name );
    void turnChanged();

    boolean engineProgressCallback();
    void engineStarting( int nBlanks );
    void engineStopping();

    // Values for why; should be enums
    public static final int TIMER_PENDOWN = 1;
    public static final int TIMER_TIMERTICK = 2;
    public static final int TIMER_COMMS = 3;
    public static final int TIMER_SLOWROBOT = 4;
    void setTimer( int why, int when, int handle );
    void clearTimer( int why );

    void requestTime();
    void remSelected();
    void setIsServer( boolean isServer );

    static final int STRD_ROBOT_TRADED =                  1;
    static final int STR_ROBOT_MOVED =                    2;
    static final int STRS_VALUES_HEADER =                 3;
    static final int STRD_REMAINING_TILES_ADD =           4;
    static final int STRD_UNUSED_TILES_SUB =              5;
    static final int STR_REMOTE_MOVED =                   6;
    static final int STRD_TIME_PENALTY_SUB =              7;
    static final int STR_PASS =                           8;
    static final int STRS_MOVE_ACROSS =                   9;
    static final int STRS_MOVE_DOWN =                    10;
    static final int STRS_TRAY_AT_START =                11;
    static final int STRSS_TRADED_FOR =                  12;
    static final int STR_PHONY_REJECTED =                13;
    static final int STRD_CUMULATIVE_SCORE =             14;
    static final int STRS_NEW_TILES =                    15;
    static final int STR_PASSED =                        16;
    static final int STRSD_SUMMARYSCORED =               17;
    static final int STRD_TRADED =                       18;
    static final int STR_LOSTTURN =                      19;
    static final int STR_COMMIT_CONFIRM =                20;
    static final int STR_LOCAL_NAME =                    21;
    static final int STR_NONLOCAL_NAME =                 22;
    static final int STR_BONUS_ALL =                     23;
    static final int STRD_TURN_SCORE =                   24;
    String getUserString( int stringCode );

    static final int QUERY_COMMIT_TURN = 0;
    static final int QUERY_COMMIT_TRADE = 1;
    static final int QUERY_ROBOT_MOVE = 2;
    static final int QUERY_ROBOT_TRADE = 3;
    boolean userQuery( int id, String query );


    // These oughtto be an enum but then I'd have to cons one up in C.
    static final int ERR_NONE = 0;
    static final int ERR_TILES_NOT_IN_LINE = 1;
    static final int ERR_NO_EMPTIES_IN_TURN = 2;
    static final int ERR_TWO_TILES_FIRST_MOVE = 3;
    static final int ERR_TILES_MUST_CONTACT = 4;
    static final int ERR_TOO_FEW_TILES_LEFT_TO_TRADE = 5;
    static final int ERR_NOT_YOUR_TURN = 6;
    static final int ERR_NO_PEEK_ROBOT_TILES = 7;
    static final int ERR_SERVER_DICT_WINS = 8;
    static final int ERR_NO_PEEK_REMOTE_TILES = 9;
    static final int ERR_REG_UNEXPECTED_USER = 10;
    static final int ERR_REG_SERVER_SANS_REMOTE = 11;
    static final int STR_NEED_BT_HOST_ADDR = 12;
    static final int ERR_CANT_TRADE_MID_MOVE = 13;
    static final int ERR_CANT_UNDO_TILEASSIGN = 14;
    static final int ERR_CANT_HINT_WHILE_DISABLED = 15;
    static final int ERR_RELAY_BASE = 16;
    void userError( int id );

    void notifyGameOver();
    // Don't need this unless we have a scroll thumb to indicate position
    //void yOffsetChange( int maxOffset, int oldOffset, int newOffset );

    boolean warnIllegalWord( String[] words, int turn, boolean turnLost );

    void showChat( String msg );
}
",False,31,40,5,15,0,0,2,0,L0
44,org.eehouse.android.xw4.jni.CommonPrefs.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.content.Context;
import android.content.SharedPreferences;
import android.preference.PreferenceManager;
import android.graphics.Paint;
import android.content.res.Resources;
import junit.framework.Assert;

import org.eehouse.android.xw4.Utils;
import org.eehouse.android.xw4.R;
import org.eehouse.android.xw4.GameUtils;

public class CommonPrefs {
    public static final int COLOR_TILE_BACK = 0;
    public static final int COLOR_BKGND = 1;
    public static final int COLOR_FOCUS = 2;
    public static final int COLOR_LAST = 3;

    private static CommonPrefs s_cp = null;

    public boolean showBoardArrow;
    public boolean showRobotScores;
    public boolean hideTileValues; 
    public boolean skipCommitConfirm;
    public boolean showColors;
    public boolean sortNewTiles;
    public boolean allowPeek;

    public int[] playerColors;
    public int[] bonusColors;
    public int[] otherColors;

    static {
        Utils.logf( ""CommonPrefs class initialized"" );
    }

    private CommonPrefs()
    {
        playerColors = new int[4];
        bonusColors = new int[5];
        bonusColors[0] = 0xF0F0F0F0; // garbage
        otherColors = new int[COLOR_LAST];
    }

    private CommonPrefs refresh( Context context )
    {
        String key;
        SharedPreferences sp = PreferenceManager
            .getDefaultSharedPreferences( context );

        showBoardArrow = getBoolean( context, sp, R.string.key_show_arrow, 
                                     true );
        showRobotScores = getBoolean( context, sp, R.string.key_explain_robot, 
                                      false );
        hideTileValues = getBoolean( context, sp, R.string.key_hide_values, 
                                     false );
        skipCommitConfirm = getBoolean( context, sp, 
                                        R.string.key_skip_confirm, false );
        showColors = getBoolean( context, sp, R.string.key_color_tiles, true );
        sortNewTiles = getBoolean( context, sp, R.string.key_sort_tiles, true );
        allowPeek = getBoolean( context, sp, R.string.key_peek_other, false );

        int ids[] = { R.string.key_player0,
                      R.string.key_player1,
                      R.string.key_player2,
                      R.string.key_player3,
        };

        for ( int ii = 0; ii < ids.length; ++ii ) {
            playerColors[ii] = prefToColor( context, sp, ids[ii] );
        }

        int ids2[] = { R.string.key_bonus_l2x,
                       R.string.key_bonus_w2x,
                       R.string.key_bonus_l3x,
                       R.string.key_bonus_w3x,
        };
        for ( int ii = 0; ii < ids2.length; ++ii ) {
            bonusColors[ii+1] = prefToColor( context, sp, ids2[ii] );
        }

        int idsOther[] = { R.string.key_tile_back,
                           R.string.key_empty,
                           R.string.key_clr_crosshairs,
        };
        for ( int ii = 0; ii < idsOther.length; ++ii ) {
            otherColors[ii] = prefToColor( context, sp, idsOther[ii] );
        }

        return this;
    }

    private boolean getBoolean( Context context, SharedPreferences sp, 
                                int id, boolean dflt )
    {
        String key = context.getString( id );
        return sp.getBoolean( key, dflt );
    }

    private int prefToColor( Context context, SharedPreferences sp, int id )
    {
        String key = context.getString( id );
        return 0xFF000000 | sp.getInt( key, 0 );
    }

    /*
     * static methods
     */
    public static CommonPrefs get( Context context )
    {
        if ( null == s_cp ) {
            s_cp = new CommonPrefs();
        }
        return s_cp.refresh( context );
    }

    public static String getDefaultRelayHost( Context context )
    {
        return getString( context, R.string.key_relay_host );
    }

    public static int getDefaultRelayPort( Context context )
    {
        String val = getString( context, R.string.key_relay_port );
        int result = 0;
        try {
            result = Integer.parseInt( val );
        } catch ( Exception ex ) {
        } 
        return result;
    }

    public static int getDefaultProxyPort( Context context )
    {
        String val = getString( context, R.string.key_proxy_port );
        int result = 0;
        try {
            result = Integer.parseInt( val );
        } catch ( Exception ex ) {
        } 
        Utils.logf( ""getDefaultProxyPort=>%d"", result );
        return result;
    }

    public static String getDefaultDictURL( Context context )
    {
        return getString( context, R.string.key_dict_host );
    }

    public static boolean getVolKeysZoom( Context context )
    {
        return getPrefsBoolean( context, R.string.key_ringer_zoom, false );
    }

    public static int getDefaultBoardSize( Context context )
    {
        String value = getString( context, R.string.key_board_size );
        try {
            return Integer.parseInt( value.substring( 0, 2 ) );
        } catch ( Exception ex ) {
            return 15;
        } 
    }

    public static int getDefaultPlayerMinutes( Context context )
    {
        String value = getString( context, R.string.key_initial_player_minutes );
        try {
            return Integer.parseInt( value );
        } catch ( Exception ex ) {
            return 25;
        }
    }

    public static long getProxyInterval( Context context )
    {
        String value = getString( context, R.string.key_connect_frequency );
        try {
            return Long.parseLong( value );
        } catch ( Exception ex ) {
            return -1;
        }
    }

    public static String getDefaultDict( Context context )
    {
        String value = getString( context, R.string.key_default_dict );
        if ( value.equals("""") || !GameUtils.dictExists( context, value ) ) {
            value = GameUtils.dictList( context )[0];
        }
        return value;
    }

    public static CurGameInfo.XWPhoniesChoice 
        getDefaultPhonies( Context context )
    {
        String value = getString( context, R.string.key_default_phonies );

        CurGameInfo.XWPhoniesChoice result = 
            CurGameInfo.XWPhoniesChoice.PHONIES_IGNORE;
        Resources res = context.getResources();
        String[] names = res.getStringArray( R.array.phony_names );
        for ( int ii = 0; ii < names.length; ++ii ) {
            String name = names[ii];
            if ( name.equals( value ) ) {
                result = CurGameInfo.XWPhoniesChoice.values()[ii];
                break;
            }
        }
        return result;
    }
    
    public static boolean getDefaultTimerEnabled( Context context )
    {
        return getPrefsBoolean( context, R.string.key_default_timerenabled, 
                                false );
    }

    public static boolean getHideTitleBar( Context context )
    {
        return getPrefsBoolean( context, R.string.key_hide_title, true );
    }

    public static boolean getShowBonusSumms( Context context )
    {
        return getPrefsBoolean( context, R.string.key_show_bonussum, false );
    }

    public static boolean getPrefsBoolean( Context context, int keyID,
                                           boolean defaultValue )
    {
        String key = context.getString( keyID );
        SharedPreferences sp = PreferenceManager
            .getDefaultSharedPreferences( context );
        return sp.getBoolean( key, defaultValue );
    }

    public static void setPrefsBoolean( Context context, int keyID, 
                                        boolean newValue )
    {
        SharedPreferences sp = PreferenceManager
            .getDefaultSharedPreferences( context );
        SharedPreferences.Editor editor = sp.edit();
        String key = context.getString( keyID );
        editor.putBoolean( key, newValue );
        editor.commit();
    }

    private static String getString( Context context, int keyID )
    {
        String key = context.getString( keyID );
        SharedPreferences sp = PreferenceManager
            .getDefaultSharedPreferences( context );
        return sp.getString( key, """" );
    }

}
",True,46,37,2,9,4,9,15,3,L0
45,org.eehouse.android.xw4.jni.TransportProcs.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

public interface TransportProcs {
    int transportSend( byte[] buf, final CommsAddrRec addr );

    enum CommsRelayState { COMMS_RELAYSTATE_UNCONNECTED
            , COMMS_RELAYSTATE_DENIED
            , COMMS_RELAYSTATE_CONNECT_PENDING
            , COMMS_RELAYSTATE_CONNECTED
            , COMMS_RELAYSTATE_RECONNECTED
            , COMMS_RELAYSTATE_ALLCONNECTED
    };
    void relayStatus( CommsRelayState newState );

    void relayConnd( String room, int devOrder, boolean allHere, int nMissing );

    public static enum XWRELAY_ERROR { NONE
            ,OLDFLAGS 
            ,BADPROTO
            ,RELAYBUSY
            ,SHUTDOWN
            ,TIMEOUT 
            ,HEART_YOU
            ,HEART_OTHER
            ,LOST_OTHER
            ,OTHER_DISCON
            ,NO_ROOM
            ,DUP_ROOM
            ,TOO_MANY
            ,DELETED
    };
    void relayErrorProc( XWRELAY_ERROR relayErr );
}
",False,33,25,2,3,6,7,3,1,L0
46,org.eehouse.android.xw4.jni.JNIThread.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */


package org.eehouse.android.xw4.jni;

import org.eehouse.android.xw4.Utils;
import android.content.Context;
import java.lang.InterruptedException;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.Iterator;
import android.os.Handler;
import android.os.Message;
import android.graphics.Paint;
import android.graphics.Rect;

import org.eehouse.android.xw4.R;
import org.eehouse.android.xw4.BoardDims;
import org.eehouse.android.xw4.GameUtils;
import org.eehouse.android.xw4.DBUtils;
import org.eehouse.android.xw4.Toolbar;
import org.eehouse.android.xw4.jni.CurGameInfo.DeviceRole;

public class JNIThread extends Thread {

    public enum JNICmd { CMD_NONE,
            CMD_DRAW,
            CMD_LAYOUT,
            CMD_START,
            CMD_SWITCHCLIENT,
            CMD_RESET,
            CMD_SAVE,
            CMD_DO,
            CMD_RECEIVE,
            CMD_TRANSFAIL,
            CMD_PREFS_CHANGE,
            CMD_PEN_DOWN,
            CMD_PEN_MOVE,
            CMD_PEN_UP,
            CMD_KEYDOWN,
            CMD_KEYUP,
            CMD_TIMER_FIRED,
            CMD_COMMIT,
            CMD_JUGGLE,
            CMD_FLIP,
            CMD_TOGGLE_TRAY,
            CMD_TRADE,
            CMD_UNDO_CUR,
            CMD_UNDO_LAST,
            CMD_HINT,
            CMD_ZOOM,
            CMD_TOGGLEZOOM,
            CMD_PREV_HINT,
            CMD_NEXT_HINT,
            CMD_VALUES,
            CMD_COUNTS_VALUES,
            CMD_REMAINING,
            CMD_RESEND,
            CMD_HISTORY,
            CMD_FINAL,
            CMD_ENDGAME,
            CMD_POST_OVER,
            CMD_SENDCHAT,
            CMD_DRAW_CONNS_STATUS,
            };

    public static final int RUNNING = 1;
    public static final int DRAW = 2;
    public static final int DIALOG = 3;
    public static final int QUERY_ENDGAME = 4;
    public static final int TOOLBAR_STATES = 5;

    private boolean m_stopped = false;
    private int m_jniGamePtr;
    private String m_path;
    private Context m_context;
    private CurGameInfo m_gi;
    private Handler m_handler;
    private SyncedDraw m_drawer;
    private static final int kMinDivWidth = 10;
    private Rect m_connsIconRect;
    private int m_connsIconID = 0;
    private boolean m_inBack = false;

    LinkedBlockingQueue<QueueElem> m_queue;

    private class QueueElem {
        protected QueueElem( JNICmd cmd, boolean isUI, Object[] args )
        {
            m_cmd = cmd; m_isUIEvent = isUI; m_args = args;
        }
        boolean m_isUIEvent;
        JNICmd m_cmd;
        Object[] m_args;
    }

    public JNIThread( int gamePtr, CurGameInfo gi, SyncedDraw drawer, 
                      String path, Context context, Handler handler ) 
    {
        m_jniGamePtr = gamePtr;
        m_gi = gi;
        m_drawer = drawer;
        m_path = path;
        m_context = context;
        m_handler = handler;

        m_queue = new LinkedBlockingQueue<QueueElem>();
    }

    public void waitToStop() {
        m_stopped = true;
        handle( JNICmd.CMD_NONE );     // tickle it
        try {
            join(200);          // wait up to 2/10 second
        } catch ( java.lang.InterruptedException ie ) {
            Utils.logf( ""got InterruptedException: "" + ie.toString() );
        }
    }

    public boolean busy()
    {                           // synchronize this!!!
        boolean result = false;
        Iterator<QueueElem> iter = m_queue.iterator();
        while ( iter.hasNext() ) {
            if ( iter.next().m_isUIEvent ) {
                result = true;
                break;
            }
        }
        return result;
    }

    public void setInBackground( boolean inBack )
    {
        m_inBack = inBack;
        if ( inBack ) {
            handle( JNICmd.CMD_SAVE );
        }
    }

    private boolean toggleTray() {
        boolean draw;
        int state = XwJNI.board_getTrayVisState( m_jniGamePtr );
        if ( state == XwJNI.TRAY_REVEALED ) {
            draw = XwJNI.board_hideTray( m_jniGamePtr );
        } else {
            draw = XwJNI.board_showTray( m_jniGamePtr );
        }
        return draw;
    }

    private void sendForDialog( int titleArg, String text )
    {
        Message.obtain( m_handler, DIALOG, titleArg, 0, text ).sendToTarget();
    }

    private void doLayout( BoardDims dims )
    {
        int scoreWidth = dims.width;

        if ( DeviceRole.SERVER_STANDALONE != m_gi.serverRole ) {
            scoreWidth -= dims.cellSize;
            m_connsIconRect = 
                new Rect( scoreWidth, 0, scoreWidth + dims.cellSize, 
                          Math.min( dims.scoreHt, dims.cellSize ) );
        }

        if ( m_gi.timerEnabled ) {
            scoreWidth -= dims.timerWidth;
            XwJNI.board_setTimerLoc( m_jniGamePtr, scoreWidth, 0, 
                                     dims.timerWidth, dims.scoreHt );
        } 
        XwJNI.board_setScoreboardLoc( m_jniGamePtr, 0, 0, scoreWidth, 
                                      dims.scoreHt, true );

        XwJNI.board_setPos( m_jniGamePtr, 0, dims.scoreHt, 
                            dims.width-1, dims.boardHt, dims.maxCellSize, 
                            false );

        XwJNI.board_setTrayLoc( m_jniGamePtr, 0, dims.trayTop,
                                dims.width-1, dims.trayHt, kMinDivWidth );

        XwJNI.board_invalAll( m_jniGamePtr );
    }

    private boolean nextSame( JNICmd cmd ) 
    {
        QueueElem nextElem = m_queue.peek();
        return null != nextElem && nextElem.m_cmd == cmd;
    }

    private boolean processKeyEvent( JNICmd cmd, XwJNI.XP_Key xpKey,
                                     boolean[] barr )
    {
        boolean draw = false;
        return draw;
    } // processKeyEvent

    private void checkButtons()
    {
        int visTileCount = XwJNI.board_visTileCount( m_jniGamePtr );
        int canFlip = visTileCount > 1 ? 1 : 0;
        Message.obtain( m_handler, TOOLBAR_STATES, Toolbar.BUTTON_FLIP,
                        canFlip ).sendToTarget();

        int canShuffle = XwJNI.board_canShuffle( m_jniGamePtr ) ? 1 : 0;
        Message.obtain( m_handler, TOOLBAR_STATES, Toolbar.BUTTON_JUGGLE,
                        canShuffle ).sendToTarget();

        int canRedo = XwJNI.board_canTogglePending( m_jniGamePtr ) ? 1 : 0;
        Message.obtain( m_handler, TOOLBAR_STATES, Toolbar.BUTTON_UNDO,
                        canRedo ).sendToTarget();

        int canHint = XwJNI.board_canHint( m_jniGamePtr ) ? 1 : 0;
        Message.obtain( m_handler, TOOLBAR_STATES, Toolbar.BUTTON_HINT_PREV,
                        canHint ).sendToTarget();
        Message.obtain( m_handler, TOOLBAR_STATES, Toolbar.BUTTON_HINT_NEXT,
                        canHint ).sendToTarget();

        int canMsg = XwJNI.comms_canChat( m_jniGamePtr ) ? 1 : 0;
        Message.obtain( m_handler, TOOLBAR_STATES, Toolbar.BUTTON_CHAT,
                        canMsg ).sendToTarget();
    }

    public void run() 
    {
        boolean[] barr = new boolean[2]; // scratch boolean
        while ( !m_stopped ) {
            QueueElem elem;
            Object[] args;
            try {
                elem = m_queue.take();
            } catch ( InterruptedException ie ) {
                Utils.logf( ""interrupted; killing thread"" );
                break;
            }
            boolean draw = false;
            args = elem.m_args;
            switch( elem.m_cmd ) {

            case CMD_SAVE:
                if ( nextSame( JNICmd.CMD_SAVE ) ) {
                    continue;
                }
                GameSummary summary = new GameSummary( m_gi );
                XwJNI.game_summarize( m_jniGamePtr, summary );
                byte[] state = XwJNI.game_saveToStream( m_jniGamePtr, null );
                GameUtils.saveGame( m_context, state, m_path );
                DBUtils.saveSummary( m_context, m_path, summary );
                break;

            case CMD_DRAW:
                if ( nextSame( JNICmd.CMD_DRAW ) ) {
                    continue;
                }
                draw = true;
                break;

            case CMD_LAYOUT:
                doLayout( (BoardDims)args[0] );
                draw = true;
                // check and disable zoom button at limit
                handle( JNICmd.CMD_ZOOM, 0 );
                break;

            case CMD_RESET:
                XwJNI.comms_resetSame( m_jniGamePtr );
                // FALLTHRU
            case CMD_START:
                XwJNI.comms_start( m_jniGamePtr );
                if ( m_gi.serverRole == DeviceRole.SERVER_ISCLIENT ) {
                    XwJNI.server_initClientConnection( m_jniGamePtr );
                }
                draw = XwJNI.server_do( m_jniGamePtr );
                break;

            case CMD_SWITCHCLIENT:
                XwJNI.server_reset( m_jniGamePtr );
                XwJNI.server_initClientConnection( m_jniGamePtr );
                draw = XwJNI.server_do( m_jniGamePtr );
                break;

            case CMD_DO:
                if ( nextSame( JNICmd.CMD_DO ) ) {
                    continue;
                }
                draw = XwJNI.server_do( m_jniGamePtr );
                break;

            case CMD_RECEIVE:
                draw = XwJNI.game_receiveMessage( m_jniGamePtr, 
                                                  (byte[])args[0] );
                handle( JNICmd.CMD_DO );
                if ( m_inBack ) {
                    handle( JNICmd.CMD_SAVE );
                }
                break;

            case CMD_TRANSFAIL:
                XwJNI.comms_transportFailed( m_jniGamePtr );
                break;

            case CMD_PREFS_CHANGE:
                // need to inval all because some of prefs,
                // e.g. colors, aren't known by common code so
                // board_prefsChanged's return value isn't enough.
                XwJNI.board_invalAll( m_jniGamePtr );
                XwJNI.board_server_prefsChanged( m_jniGamePtr, 
                                                 CommonPrefs.get( m_context ) );
                draw = true;
                break;

            case CMD_PEN_DOWN:
                draw = XwJNI.board_handlePenDown( m_jniGamePtr, 
                                                  ((Integer)args[0]).intValue(),
                                                  ((Integer)args[1]).intValue(),
                                                  barr );
                break;
            case CMD_PEN_MOVE:
                if ( nextSame( JNICmd.CMD_PEN_MOVE ) ) {
                    continue;
                }
                draw = XwJNI.board_handlePenMove( m_jniGamePtr, 
                                                  ((Integer)args[0]).intValue(),
                                                  ((Integer)args[1]).intValue() );
                break;
            case CMD_PEN_UP:
                draw = XwJNI.board_handlePenUp( m_jniGamePtr, 
                                                ((Integer)args[0]).intValue(),
                                                ((Integer)args[1]).intValue() );
                break;

            case CMD_KEYDOWN:
            case CMD_KEYUP:
                draw = processKeyEvent( elem.m_cmd, (XwJNI.XP_Key)args[0], barr );
                break;

            case CMD_COMMIT:
                draw = XwJNI.board_commitTurn( m_jniGamePtr );
                break;

            case CMD_JUGGLE:
                draw = XwJNI.board_juggleTray( m_jniGamePtr );
                break;
            case CMD_FLIP:
                draw = XwJNI.board_flip( m_jniGamePtr );
                break;
            case CMD_TOGGLE_TRAY:
                draw = toggleTray();
                break;
            case CMD_TRADE:
                draw = XwJNI.board_beginTrade( m_jniGamePtr );
                break;
            case CMD_UNDO_CUR:
                draw = XwJNI.board_replaceTiles( m_jniGamePtr )
                    || XwJNI.board_redoReplacedTiles( m_jniGamePtr );
                break;
            case CMD_UNDO_LAST:
                XwJNI.server_handleUndo( m_jniGamePtr );
                draw = true;
                break;

            case CMD_HINT:
                XwJNI.board_resetEngine( m_jniGamePtr );
                handle( JNICmd.CMD_NEXT_HINT );
                break;

            case CMD_NEXT_HINT:
            case CMD_PREV_HINT:
                if ( nextSame( elem.m_cmd ) ) {
                    continue;
                }
                draw = XwJNI.board_requestHint( m_jniGamePtr, false, 
                                                JNICmd.CMD_PREV_HINT==elem.m_cmd,
                                                barr );
                if ( barr[0] ) {
                    handle( elem.m_cmd );
                    draw = false;
                }
                break;

            case CMD_TOGGLEZOOM:
                XwJNI.board_zoom( m_jniGamePtr, 0 , barr );
                int zoomBy = 0;
                if ( barr[1] ) { // always go out if possible
                    zoomBy = -4;
                } else if ( barr[0] ) {
                    zoomBy = 4;
                }
                draw = XwJNI.board_zoom( m_jniGamePtr, zoomBy, barr );
                break;
            case CMD_ZOOM:
                draw = XwJNI.board_zoom( m_jniGamePtr, 
                                         ((Integer)args[0]).intValue(),
                                         barr );
                break;

            case CMD_VALUES:
                draw = XwJNI.board_toggle_showValues( m_jniGamePtr );
                break;

            case CMD_COUNTS_VALUES:
                sendForDialog( ((Integer)args[0]).intValue(),
                               XwJNI.server_formatDictCounts( m_jniGamePtr, 3 )
                               );
                break;
            case CMD_REMAINING:
                sendForDialog( ((Integer)args[0]).intValue(),
                               XwJNI.board_formatRemainingTiles( m_jniGamePtr )
                               );
                break;

            case CMD_RESEND:
                XwJNI.comms_resendAll( m_jniGamePtr );
                break;

            case CMD_HISTORY:
                boolean gameOver = XwJNI.server_getGameIsOver( m_jniGamePtr );
                sendForDialog( ((Integer)args[0]).intValue(),
                               XwJNI.model_writeGameHistory( m_jniGamePtr, 
                                                             gameOver ) );
                break;

            case CMD_FINAL:
                if ( XwJNI.server_getGameIsOver( m_jniGamePtr ) ) {
                    handle( JNICmd.CMD_POST_OVER );
                } else {
                    Message.obtain( m_handler, QUERY_ENDGAME ).sendToTarget();
                }
                break;

            case CMD_ENDGAME:
                XwJNI.server_endGame( m_jniGamePtr );
                draw = true;
                break;

            case CMD_POST_OVER:
                if ( XwJNI.server_getGameIsOver( m_jniGamePtr ) ) {
                    sendForDialog( R.string.finalscores_title,
                                   XwJNI.server_writeFinalScores( m_jniGamePtr ) );
                }
                break;

            case CMD_SENDCHAT:
                XwJNI.server_sendChat( m_jniGamePtr, (String)args[0] );
                break;

            case CMD_DRAW_CONNS_STATUS:
                int newID = 0;
                switch( (TransportProcs.CommsRelayState)(args[0]) ) {
                case COMMS_RELAYSTATE_UNCONNECTED:
                case COMMS_RELAYSTATE_DENIED:
                case COMMS_RELAYSTATE_CONNECT_PENDING:
                    newID = R.drawable.netarrow_unconn;
                    break;
                case COMMS_RELAYSTATE_CONNECTED: 
                case COMMS_RELAYSTATE_RECONNECTED: 
                    newID = R.drawable.netarrow_someconn;
                    break;
                case COMMS_RELAYSTATE_ALLCONNECTED:
                    newID = R.drawable.netarrow_allconn;
                    break;
                default:
                    newID = 0;
                }
                if ( m_connsIconID != newID ) {
                    draw = true;
                    m_connsIconID = newID;
                }
                break;

            case CMD_TIMER_FIRED:
                draw = XwJNI.timerFired( m_jniGamePtr, 
                                         ((Integer)args[0]).intValue(),
                                         ((Integer)args[1]).intValue(),
                                         ((Integer)args[2]).intValue() );
                break;
            }

            if ( draw ) {
                // do the drawing in this thread but in BoardView
                // where it can be synchronized with that class's use
                // of the same bitmap for blitting.
                m_drawer.doJNIDraw();
                if ( null != m_connsIconRect ) {
                    m_drawer.doIconDraw( m_connsIconID, m_connsIconRect );
                }

                // main UI thread has to invalidate view as it created
                // it.
                Message.obtain( m_handler, DRAW ).sendToTarget();

                checkButtons();
            }
        }
        Utils.logf( ""run exiting"" );
    } // run

    public void handle( JNICmd cmd, boolean isUI, Object... args )
    {
        QueueElem elem = new QueueElem( cmd, isUI, args );
        // Utils.logf( ""adding: "" + cmd.toString() );
        m_queue.add( elem );
    }

    public void handle( JNICmd cmd, Object... args )
    {
        handle( cmd, true, args );
    }

}
",True,25,32,1,4,4,12,4,11,L3
47,org.eehouse.android.xw4.jni.SyncedDraw.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.graphics.Rect;

public interface SyncedDraw {
    void doJNIDraw();
    void doIconDraw( int resID, final Rect rect );
}
",False,12,6,2,3,0,0,2,0,L3
48,org.eehouse.android.xw4.jni.XwJNI.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

// Collection of native methods
public class XwJNI {


    // This needs to be called before the first attempt to use the
    // jni.  I figure this class has to be loaded before that cna
    // happen.  Doing this in GamesList isn't enough because sometimes
    // BoardActivity is the first Activity loaded.
    static {
        System.loadLibrary(""xwjni"");
    }
    
    /* XW_TrayVisState enum */
    public static final int TRAY_HIDDEN = 0;
    public static final int TRAY_REVERSED = 1;
    public static final int TRAY_REVEALED = 2;

    // Methods not part of the common interface but necessitated by
    // how java/jni work (or perhaps my limited understanding of it.)

    // callback into jni from java when timer set here fires.
    public static native boolean timerFired( int gamePtr, int why, 
                                             int when, int handle );

    // Stateless methods
    public static native byte[] gi_to_stream( CurGameInfo gi );
    public static native void gi_from_stream( CurGameInfo gi, byte[] stream );
    public static native void comms_getInitialAddr( CommsAddrRec addr,
                                                    String relayHost,
                                                    int relayPort );

    // Game methods
    public static native int initJNI();
    public static native void game_makeNewGame( int gamePtr,
                                                CurGameInfo gi, 
                                                UtilCtxt util,
                                                JNIUtils jniu,
                                                DrawCtx draw, CommonPrefs cp, 
                                                TransportProcs procs, 
                                                byte[] dict, String dictName );

    public static native boolean game_makeFromStream( int gamePtr,
                                                      byte[] stream, 
                                                      CurGameInfo gi, 
                                                      byte[] dict, 
                                                      String dictName,
                                                      UtilCtxt util, 
                                                      JNIUtils jniu,
                                                      DrawCtx draw,
                                                      CommonPrefs cp,
                                                      TransportProcs procs );

    // leave out options params for when game won't be rendered or
    // played
    public static void game_makeNewGame( int gamePtr, CurGameInfo gi,
                                         JNIUtils jniu, CommonPrefs cp, 
                                         byte[] dict, String dictName ) {
        game_makeNewGame( gamePtr, gi, (UtilCtxt)null, jniu,
                          (DrawCtx)null, cp, (TransportProcs)null, 
                          dict, dictName );
    }

    public static boolean game_makeFromStream( int gamePtr,
                                               byte[] stream, 
                                               JNIUtils jniu,
                                               CurGameInfo gi, 
                                               byte[] dict, String dictName,
                                               CommonPrefs cp ) {
        return game_makeFromStream( gamePtr, stream, gi, dict, dictName,
                                    (UtilCtxt)null, jniu, (DrawCtx)null, cp, 
                                    (TransportProcs)null );
    }

    public static native boolean game_receiveMessage( int gamePtr, 
                                                      byte[] stream );
    public static native void game_summarize( int gamePtr, GameSummary summary );
    public static native byte[] game_saveToStream( int gamePtr,
                                                   CurGameInfo gi  );
    public static native boolean game_hasComms( int gamePtr );
    public static native void game_dispose( int gamePtr );

    // Board methods
    public static native void board_invalAll( int gamePtr );
    public static native boolean board_draw( int gamePtr );
    public static native void board_setPos( int gamePtr, int left, int top,
                                            int width, int height, 
                                            int maxCellHt, boolean lefty );
    public static native boolean board_zoom( int gamePtr, int zoomBy, 
                                             boolean[] canZoom );
    public static native void board_setScoreboardLoc( int gamePtr, int left, 
                                                      int top, int width, 
                                                      int height,
                                                      boolean divideHorizontally );
    public static native void board_setTrayLoc( int gamePtr, int left, 
                                                int top, int width, 
                                                int height, int minDividerWidth );
    public static native void board_setTimerLoc( int gamePtr,
                                                 int timerLeft, int timerTop,
                                                 int timerWidth, int timerHeight );

    public static native boolean board_handlePenDown( int gamePtr, 
                                                      int xx, int yy, 
                                                      boolean[] handled );
    public static native boolean board_handlePenMove( int gamePtr, 
                                                      int xx, int yy );
    public static native boolean board_handlePenUp( int gamePtr, 
                                                    int xx, int yy );

    public static native boolean board_juggleTray( int gamePtr );
    public static native int board_getTrayVisState( int gamePtr );
    public static native boolean board_hideTray( int gamePtr );
    public static native boolean board_showTray( int gamePtr );
    public static native boolean board_toggle_showValues( int gamePtr );
    public static native boolean board_commitTurn( int gamePtr );
    public static native boolean board_flip( int gamePtr );
    public static native boolean board_replaceTiles( int gamePtr );
    public static native boolean board_redoReplacedTiles( int gamePtr );
    public static native void board_resetEngine( int gamePtr );
    public static native boolean board_requestHint( int gamePtr, 
                                                    boolean useTileLimits,
                                                    boolean goBackwards,
                                                    boolean[] workRemains );
    public static native boolean board_beginTrade( int gamePtr );

    public static native String board_formatRemainingTiles( int gamePtr );

    public static native int board_visTileCount( int gamePtr );
    public static native boolean board_canHint( int gamePtr );
    public static native boolean board_canShuffle( int gamePtr );
    public static native boolean board_canTogglePending( int gamePtr );

    public enum XP_Key {
        XP_KEY_NONE,
        XP_CURSOR_KEY_DOWN,
        XP_CURSOR_KEY_ALTDOWN,
        XP_CURSOR_KEY_RIGHT,
        XP_CURSOR_KEY_ALTRIGHT,
        XP_CURSOR_KEY_UP,
        XP_CURSOR_KEY_ALTUP,
        XP_CURSOR_KEY_LEFT,
        XP_CURSOR_KEY_ALTLEFT,

        XP_CURSOR_KEY_DEL,
        XP_RAISEFOCUS_KEY,
        XP_RETURN_KEY,

        XP_KEY_LAST
    };
    public static native boolean board_handleKey( int gamePtr, XP_Key key, 
                                                  boolean up, boolean[] handled );
    // public static native boolean board_handleKeyDown( XP_Key key, 
    //                                                   boolean[] handled );
    // public static native boolean board_handleKeyRepeat( XP_Key key, 
    //                                                     boolean[] handled );

    // Model
    public static native String model_writeGameHistory( int gamePtr, 
                                                        boolean gameOver );
    public static native int model_getNMoves( int gamePtr );

    // Server
    public static native void server_reset( int gamePtr );
    public static native void server_handleUndo( int gamePtr );
    public static native boolean server_do( int gamePtr );
    public static native String server_formatDictCounts( int gamePtr, int nCols );
    public static native boolean server_getGameIsOver( int gamePtr );
    public static native String server_writeFinalScores( int gamePtr );
    public static native void server_initClientConnection( int gamePtr );
    public static native void server_endGame( int gamePtr );
    public static native void server_sendChat( int gamePtr, String msg );

    // hybrid to save work
    public static native boolean board_server_prefsChanged( int gamePtr, 
                                                            CommonPrefs cp );

    // Comms
    public static native void comms_start( int gamePtr );
    public static native void comms_resetSame( int gamePtr );
    public static native void comms_getAddr( int gamePtr, CommsAddrRec addr );
    public static native void comms_setAddr( int gamePtr, CommsAddrRec addr );
    public static native void comms_resendAll( int gamePtr );
    public static native void comms_transportFailed( int gamePtr );
    public static native boolean comms_canChat( int gamePtr );
    public static native boolean comms_isConnected( int gamePtr );

    // Dicts
    public static native boolean dict_tilesAreSame( int dictPtr1, int dictPtr2 );
    public static native String[] dict_getChars( int dictPtr );
    public static native void dict_getInfo( byte[] dict, JNIUtils jniu, 
                                            DictInfo info );
}
",True,45,26,2,3,4,9,5,9,L0
49,org.eehouse.android.xw4.jni.DrawCtx.java,"/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import android.graphics.Rect;

public interface DrawCtx {
    static final int CELL_NONE = 0x00;
    static final int CELL_ISBLANK = 0x01;
    static final int CELL_HIGHLIGHT = 0x02;
    static final int CELL_ISSTAR = 0x04;
    static final int CELL_ISCURSOR = 0x08;
    static final int CELL_ISEMPTY = 0x10;       /* of a tray tile slot */
    static final int CELL_VALHIDDEN = 0x20;     /* show letter only, not value */
    static final int CELL_DRAGSRC = 0x40;       /* where drag originated */
    static final int CELL_DRAGCUR = 0x80;       /* where drag is now */
    static final int CELL_CROSSVERT = 0x100;
    static final int CELL_CROSSHOR = 0x200;
    static final int CELL_ALL = 0x3FF;

    /* BoardObjectType */
    static final int OBJ_NONE = 0;
    static final int OBJ_BOARD = 1;
    static final int OBJ_SCORE = 2;
    static final int OBJ_TRAY = 3;


    boolean scoreBegin( Rect rect, int numPlayers, int[] scores, int remCount,
                        int dfs );
    void measureRemText( Rect r, int nTilesLeft, int[] width, int[] height );
    void measureScoreText( Rect r, DrawScoreInfo dsi, int[] width, int[] height );
    void drawRemText( Rect rInner, Rect rOuter, int nTilesLeft, boolean focussed );
    void score_drawPlayer( Rect rInner, Rect rOuter, DrawScoreInfo dsi );
    void drawTimer( Rect rect, int player, int secondsLeft );

    boolean drawCell( Rect rect, String text, int tile, 
                      int owner, int bonus, int hintAtts, int flags );
    void drawBoardArrow ( Rect rect, int bonus, boolean vert, int hintAtts,
                          int flags );
    boolean trayBegin ( Rect rect, int owner, int dfs );
    void drawTile( Rect rect, String text, int val, int flags );
    void drawTileMidDrag ( Rect rect, String text, int val, int owner, 
                           int flags );
    void drawTileBack( Rect rect, int flags );
    void drawTrayDivider( Rect rect, int flags );
    void score_pendingScore( Rect rect, int score, int playerNum, int flags );

    public static final int BONUS_NONE = 0;
    public static final int BONUS_DOUBLE_LETTER = 1;
    public static final int BONUS_DOUBLE_WORD = 2;
    public static final int BONUS_TRIPLE_LETTER = 3;
    public static final int BONUS_TRIPLE_WORD = 4;
    public static final int INTRADE_MW_TEXT = 5;
    String getMiniWText ( int textHint );
    void measureMiniWText( String text, int[] width, int[] height );
    void drawMiniWindow( String text, Rect rect );

    void objFinished( /*BoardObjectType*/int typ, Rect rect, int dfs );

    void dictChanged( int dictPtr );

}
",False,38,41,5,15,1,1,2,1,L0
50,org.eehouse.android.xw4.jni.CommsAddrRec.java,"/* -*- compile-command: ""cd ../../../../../../; ant install""; -*- */
/*
 * Copyright 2009-2010 by Eric House (xwords@eehouse.org).  All
 * rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.eehouse.android.xw4.jni;

import java.net.InetAddress;
import android.content.Context;

import org.eehouse.android.xw4.Utils;

public class CommsAddrRec {

    public enum CommsConnType { COMMS_CONN_NONE,
            COMMS_CONN_IR,
            COMMS_CONN_IP_DIRECT,
            COMMS_CONN_RELAY,
            COMMS_CONN_BT,
            COMMS_CONN_SMS,
    };

    // The C equivalent of this struct uses a union for the various
    // data sets below.  So don't assume that any fields will be valid
    // except those for the current conType.
    public CommsConnType conType;

    // relay case
    public String ip_relay_invite;
    public String ip_relay_hostName;
    public InetAddress ip_relay_ipAddr;    // a cache, maybe unused in java
    public int ip_relay_port;
    public boolean ip_relay_seeksPublicRoom;
    public boolean ip_relay_advertiseRoom;

    // sms case
    public String sms_phone;
    public int sms_port;                   // NBS port, if they still use those

    public CommsAddrRec( Context context ) 
    {
        conType = CommsConnType.COMMS_CONN_RELAY;
        ip_relay_hostName = CommonPrefs.getDefaultRelayHost( context );
        ip_relay_port = CommonPrefs.getDefaultRelayPort( context );
        ip_relay_seeksPublicRoom = false;
        ip_relay_advertiseRoom = false;
    }

    public CommsAddrRec( final CommsAddrRec src ) 
    {
        this.copyFrom( src );
    }

    public boolean changesMatter( final CommsAddrRec other )
    {
        boolean matter = conType != other.conType;
        if ( !matter ) {
            matter = ! ip_relay_invite.equals( other.ip_relay_invite )
                || ! ip_relay_hostName.equals( other.ip_relay_hostName )
                || ip_relay_port != other.ip_relay_port;
        }
        return matter;
    }

    private void copyFrom( CommsAddrRec src )
    {
        conType = src.conType;
        ip_relay_invite = src.ip_relay_invite;
        ip_relay_hostName = src.ip_relay_hostName;
        ip_relay_port = src.ip_relay_port;
        ip_relay_seeksPublicRoom = src.ip_relay_seeksPublicRoom;
        ip_relay_advertiseRoom = src.ip_relay_advertiseRoom;
    }
}
",False,21,25,2,4,5,7,9,2,L0
